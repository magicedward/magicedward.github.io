<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MarkDown基本语法</title>
    <url>/2020/12/31/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题"></a>我展示的是一级标题</h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题"></a>我展示的是二级标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br>当然也可以在段落后面使用一个空行来表示重新开始一个段落。</p>
<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong>  </p>
<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下</p>
<p>RUNOOB.COM<br>GOOGLE.COM<br><del>BAIDU.COM</del>  </p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 &lt;u&gt; 标签来实现：<br><u>带下划线文本</u></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是对文本的补充说明。<br>Markdown 脚注的格式如下:</p>
<p>[^要注明的文本]</p>
<h3 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
<li></li>
</ul>
<p>有序列表使用数字并加上 . 号来表示，如:</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
<li></li>
</ul>
</li>
</ol>
<h3 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h3><p>arkdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p>
<blockquote>
<p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p>
</blockquote>
<p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p>
<blockquote>
<p>最外层  </p>
<blockquote>
<p>第一层嵌套  </p>
<blockquote>
<p>第二层嵌套  </p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表实例如下：</p>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p>
<p>区块中使用列表实例如下：</p>
<ul>
<li>第一项<blockquote>
<p>菜鸟教程<br>学的不仅是技术更是梦想</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<h3 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h3><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），<br>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：<br>例如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">printf(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h3><p>链接使用方法如下：<br><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a><br>或者<br>&lt;链接地址&gt;</p>
<p>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a><br>&lt;<a href="http://www.baidu.com&gt;/">www.baidu.com&gt;</a></p>
<h4 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h4><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：<br>这个链接用 1 作为网址变量 [Google][1]<br>这个链接用 runoob 作为网址变量 [Runoob][runoob]<br>然后在文档的结尾为变量赋值（网址）<br>[1]: <a href="http://www.google.com/">http://www.google.com/</a><br>[runoob]: <a href="http://www.runoob.com/">http://www.runoob.com/</a></p>
<h3 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h3><p>Markdown 图片语法格式如下：</p>
<p><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"><br><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"><br>开头一个感叹号 !<br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</p>
<p>使用实例：<br><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p>
<p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p>
<h3 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h3><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p>
<p>语法格式如下：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<h6 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h6><p>我们可以设置表格的对齐方式：<br>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>实例如下：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h3 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h3><p>支持的 HTML 元素<br>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：</p>
<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：<br><strong>文本加粗</strong><br>** 正常显示星号 **</p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure>

<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$  </p>
]]></content>
  </entry>
  <entry>
    <title>APN 设置及查询</title>
    <url>/2020/12/31/Android/APN%20%E8%AE%BE%E7%BD%AE%E5%8F%8A%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p><strong><em>APN 设置及查询</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getDefaultAPN</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">       Cursor mCursor = context.getContentResolver().query(Uri.parse(<span class="string">&quot;content://telephony/carriers/preferapn&quot;</span>),</span><br><span class="line">               <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">while</span> (mCursor != <span class="keyword">null</span> &amp;&amp; mCursor.moveToNext()) &#123;</span><br><span class="line">           String id = mCursor.getString(mCursor.getColumnIndex(<span class="string">&quot;_id&quot;</span>));</span><br><span class="line">           String name = mCursor.getString(mCursor.getColumnIndex(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">           String apn = mCursor.getString(mCursor.getColumnIndex(<span class="string">&quot;apn&quot;</span>));</span><br><span class="line">           String type = mCursor.getString(mCursor.getColumnIndex(<span class="string">&quot;type&quot;</span>));</span><br><span class="line">           Log.d(TAG,<span class="string">&quot;DefaultAPN:&quot;</span>+id+<span class="string">&quot; &quot;</span>+name+<span class="string">&quot; &quot;</span>+apn+<span class="string">&quot; &quot;</span>+type);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(mCursor != <span class="keyword">null</span>)</span><br><span class="line">           mCursor.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkAPN</span><span class="params">(Context context,String apn)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> apnId = -<span class="number">1</span>;</span><br><span class="line">       ContentResolver resolver = context.getContentResolver();</span><br><span class="line">       Cursor c = resolver.query(Uri.parse(<span class="string">&quot;content://telephony/carriers&quot;</span>), <span class="keyword">new</span> String[] &#123; <span class="string">&quot;_id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;apn&quot;</span> &#125;,</span><br><span class="line">               <span class="string">&quot;apn like &#x27;%&quot;</span>+apn+<span class="string">&quot;%&#x27;&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; c.moveToNext()) &#123;</span><br><span class="line">           apnId = c.getShort(c.getColumnIndex(<span class="string">&quot;_id&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(c != <span class="keyword">null</span>)</span><br><span class="line">           c.close();</span><br><span class="line">       <span class="keyword">return</span> apnId;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">AddApn</span><span class="params">(Context context,String name,String apn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> apnId = -<span class="number">1</span>;</span><br><span class="line">       TelephonyManager iPhoneManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">       String NUMERIC = iPhoneManager.getSimOperator();</span><br><span class="line">       <span class="keyword">if</span> (NUMERIC == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ContentResolver resolver = context.getContentResolver();</span><br><span class="line">       ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line"></span><br><span class="line">       values.put(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">       values.put(<span class="string">&quot;apn&quot;</span>,apn);</span><br><span class="line">       values.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;default,xcap,supl&quot;</span>);</span><br><span class="line">       values.put(<span class="string">&quot;numeric&quot;</span>, NUMERIC);</span><br><span class="line">       values.put(<span class="string">&quot;mcc&quot;</span>, NUMERIC.substring(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">       values.put(<span class="string">&quot;mnc&quot;</span>, NUMERIC.substring(<span class="number">3</span>));</span><br><span class="line">       values.put(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       values.put(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       values.put(<span class="string">&quot;mmsproxy&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       values.put(<span class="string">&quot;mmsport&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       values.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       values.put(<span class="string">&quot;server&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       values.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       values.put(<span class="string">&quot;mmsc&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       Cursor c = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Uri newRow = resolver.insert(Uri.parse(<span class="string">&quot;content://telephony/carriers&quot;</span>), values);</span><br><span class="line">           <span class="keyword">if</span> (newRow != <span class="keyword">null</span>) &#123;</span><br><span class="line">               c = resolver.query(newRow, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span>(c != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   apnId = c.getShort(c.getColumnIndex(<span class="string">&quot;_id&quot;</span>));</span><br><span class="line">                   c.moveToFirst();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c != <span class="keyword">null</span>)</span><br><span class="line">           c.close();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> apnId;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setDefaultApn</span><span class="params">(Context context,<span class="keyword">int</span> apnId)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> ret = <span class="keyword">false</span>;</span><br><span class="line">       ContentResolver resolver = context.getContentResolver();</span><br><span class="line">       ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">       values.put(<span class="string">&quot;apn_id&quot;</span>, apnId);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Uri uri = Uri.parse(<span class="string">&quot;content://telephony/carriers/preferapn&quot;</span>);</span><br><span class="line">           resolver.update(uri, values, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">           Cursor c = resolver.query(uri, <span class="keyword">new</span> String[] &#123; <span class="string">&quot;name&quot;</span>, <span class="string">&quot;apn&quot;</span> &#125;, <span class="string">&quot;_id=&quot;</span> + apnId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">               c.close();</span><br><span class="line">               ret = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Adding for auto update FW in vold</title>
    <url>/2020/12/31/Android/Adding%20for%20auto%20update%20FW%20in%20vold/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//CM: Adding for auto update FW in vold</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CM_UPDATE_PATH_LEN    256</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">chkUpFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">char</span> *upFile)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *FILE_NAME = <span class="string">&quot;cm_update.zip&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> UPDATE_FILE_NAME[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> UPDATE_FILE_PATH[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> UPDATE_FILE_PATH_NEW[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if OTA update file exists or not</span></span><br><span class="line">    <span class="built_in">snprintf</span>(UPDATE_FILE_PATH, <span class="keyword">sizeof</span>(UPDATE_FILE_PATH), <span class="string">&quot;%s/%s&quot;</span>, label, FILE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (access(UPDATE_FILE_PATH, F_OK|R_OK) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        SLOGW(<span class="string">&quot;CheckUpdate update file %s is not exist&quot;</span>, UPDATE_FILE_PATH);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rename OTA update files to prevent updating at next boot/plugin</span></span><br><span class="line">    <span class="built_in">strncpy</span>(UPDATE_FILE_NAME, FILE_NAME, <span class="keyword">sizeof</span>(UPDATE_FILE_NAME));</span><br><span class="line">    <span class="keyword">char</span> *dot = <span class="built_in">strrchr</span>(UPDATE_FILE_NAME, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dot != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *dot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> *prefix = UPDATE_FILE_NAME;</span><br><span class="line">        <span class="keyword">char</span> *postfix = dot+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">snprintf</span>(UPDATE_FILE_PATH_NEW, <span class="keyword">sizeof</span>(UPDATE_FILE_PATH_NEW), <span class="string">&quot;%s/%s-%ld.%s&quot;</span>, label, prefix, time(<span class="literal">NULL</span>), postfix);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(UPDATE_FILE_PATH_NEW, <span class="keyword">sizeof</span>(UPDATE_FILE_PATH_NEW), <span class="string">&quot;%s/%s-%ld&quot;</span>, label, UPDATE_FILE_NAME, time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rename(UPDATE_FILE_PATH, UPDATE_FILE_PATH_NEW) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        SLOGW(<span class="string">&quot;CheckUpdate rename %s to %s failure&quot;</span>, UPDATE_FILE_PATH, UPDATE_FILE_PATH_NEW);</span><br><span class="line">        <span class="built_in">snprintf</span>(upFile, MAX_CM_UPDATE_PATH_LEN, <span class="string">&quot;%s&quot;</span>, UPDATE_FILE_PATH);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(upFile, MAX_CM_UPDATE_PATH_LEN, <span class="string">&quot;%s&quot;</span>, UPDATE_FILE_PATH_NEW);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SLOGI(<span class="string">&quot;CheckUpdate updateFile = %s&quot;</span>, upFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">chkUpFolder</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">char</span> *upFile)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *FOLDER_NAME = <span class="string">&quot;cm_update&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> UPDATE_PATH[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> FOLDER_NAME_NEW[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">bool</span> isUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if OTA update folder exists or not</span></span><br><span class="line">    <span class="built_in">snprintf</span>(UPDATE_PATH, <span class="keyword">sizeof</span>(UPDATE_PATH), <span class="string">&quot;%s/%s&quot;</span>, label, FOLDER_NAME);</span><br><span class="line">    DIR *dirptr = opendir(UPDATE_PATH);</span><br><span class="line">    <span class="keyword">if</span> (dirptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        SLOGW(<span class="string">&quot;CheckUpdate update folder %s is not exist&quot;</span>, UPDATE_PATH);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dirptr)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;entry: %s\n&quot;</span>, entry-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span> ((entry-&gt;d_type == DT_REG) || (entry-&gt;d_type == DT_UNKNOWN)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strstr</span>(entry-&gt;d_name, <span class="string">&quot;.bin&quot;</span>) || <span class="built_in">strstr</span>(entry-&gt;d_name, <span class="string">&quot;.img&quot;</span>))</span><br><span class="line">                isUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dirptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( isUpdate == <span class="literal">false</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rename OTA update files to prevent updating at next boot/plugin</span></span><br><span class="line">    <span class="built_in">snprintf</span>(FOLDER_NAME_NEW, <span class="keyword">sizeof</span>(FOLDER_NAME_NEW), <span class="string">&quot;%s/%s-%ld&quot;</span>, label, FOLDER_NAME, time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">if</span> (rename(UPDATE_PATH, FOLDER_NAME_NEW) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(upFile, MAX_CM_UPDATE_PATH_LEN, <span class="string">&quot;%s/boot.img&quot;</span>, UPDATE_PATH);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(upFile, MAX_CM_UPDATE_PATH_LEN, <span class="string">&quot;%s/boot.img&quot;</span>, FOLDER_NAME_NEW);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SLOGI(<span class="string">&quot;CheckUpdate updateFile = %s&quot;</span>, upFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">prepareRecovery</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *upFile)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *RECOVERY_DIR = <span class="string">&quot;/cache/recovery&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *COMMAND_FILE = <span class="string">&quot;/cache/recovery/command&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> UPDATE_ARG[<span class="number">256</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( upFile == <span class="literal">NULL</span> || <span class="built_in">strlen</span>(upFile) &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove recovery folder</span></span><br><span class="line">    remove(COMMAND_FILE);</span><br><span class="line">    mkdir(RECOVERY_DIR, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (access(RECOVERY_DIR, F_OK|R_OK|W_OK|X_OK) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        SLOGE(<span class="string">&quot;CheckUpdate create RECOVERY_DIR:%s failure&quot;</span>, RECOVERY_DIR);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create recovery data file</span></span><br><span class="line">    <span class="keyword">int</span> fd = creat(COMMAND_FILE, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        SLOGE(<span class="string">&quot;CheckUpdate create COMMAND_FILE:%s failure&quot;</span>, COMMAND_FILE);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write recovery arg</span></span><br><span class="line">    <span class="built_in">snprintf</span>(UPDATE_ARG, <span class="keyword">sizeof</span>(UPDATE_ARG), <span class="string">&quot;--update_package=%s\n&quot;</span>, upFile);</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(UPDATE_ARG);</span><br><span class="line">    <span class="keyword">int</span> written = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = write(fd, UPDATE_ARG+written, length-written);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;CheckUpdate write UPDATE_ARG:%s failure&quot;</span>, UPDATE_ARG);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        written += n;</span><br><span class="line">    &#125;<span class="keyword">while</span> (written &lt; length);</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    SLOGI(<span class="string">&quot;CheckUpdate write %s is success&quot;</span>, COMMAND_FILE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Synchronize files</span></span><br><span class="line">    system(<span class="string">&quot;sync&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkUpdate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (label == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        SLOGW(<span class="string">&quot;CheckUpdate label is NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// label must be contain sdcard</span></span><br><span class="line">    SLOGI(<span class="string">&quot;CheckUpdate label:%s&quot;</span>, label);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(label, <span class="string">&quot;sdcard&quot;</span>) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        SLOGW(<span class="string">&quot;CheckUpdate skipped&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check android properties</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prop = <span class="string">&quot;persist.updatefw.auto&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> prop_value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">if</span> (property_get(prop, prop_value, <span class="string">&quot;1&quot;</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        SLOGW(<span class="string">&quot;CheckUpdate get android prop error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SLOGI(<span class="string">&quot;CheckUpdate %s: %s&quot;</span>, prop, prop_value);</span><br><span class="line">    <span class="keyword">if</span> (prop_value[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; prop_value[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        SLOGI(<span class="string">&quot;CheckUpdate android prop: disable auto update&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check label is exist</span></span><br><span class="line">    <span class="keyword">if</span> (access(label, F_OK|R_OK|X_OK) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        SLOGW(<span class="string">&quot;CheckUpdate label:%s is not exist&quot;</span>, label);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SLOGI(<span class="string">&quot;CheckUpdate fork parent process:%d&quot;</span>, getpid());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        SLOGE(<span class="string">&quot;CheckUpdate fork failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        SLOGI(<span class="string">&quot;CheckUpdate forked child process:%d&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// wait child process exit to avoid it become zombie(defunct)</span></span><br><span class="line">        <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) == pid ) &#123;</span><br><span class="line">            SLOGI(<span class="string">&quot;CheckUpdate child(%d) completed.&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Child process...</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> updateFile[MAX_CM_UPDATE_PATH_LEN];</span><br><span class="line">    <span class="built_in">memset</span>(updateFile, <span class="number">0</span>, MAX_CM_UPDATE_PATH_LEN);</span><br><span class="line">    <span class="keyword">if</span> ( chkUpFile(label, updateFile) == <span class="literal">false</span> )&#123;</span><br><span class="line">        chkUpFolder(label, updateFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( prepareRecovery(updateFile) ) &#123;</span><br><span class="line">        <span class="comment">// Reboot to recovery</span></span><br><span class="line">        SLOGI(<span class="string">&quot;CheckUpdate reboot to recovery&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (execlp(<span class="string">&quot;reboot&quot;</span>, <span class="string">&quot;reboot&quot;</span>, <span class="string">&quot;recovery&quot;</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            SLOGE(<span class="string">&quot;CheckUpdate run command \&quot;reboot recovery\&quot; failure&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">VolumeManager::mountVolume</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CM: Adding for auto update FW in vold</span></span><br><span class="line">    <span class="comment">//return v-&gt;mountVol();</span></span><br><span class="line">    <span class="keyword">int</span> ret = v-&gt;mountVol();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)&#123;</span><br><span class="line">        checkUpdate(label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Uevent发送（热插拔）事件到用户空间</title>
    <url>/2020/12/31/Android/Uevent%E5%8F%91%E9%80%81%EF%BC%88%E7%83%AD%E6%8F%92%E6%8B%94%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%88%B0%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume_set_reasen</span><span class="params">(<span class="keyword">char</span> * reasen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> name_buf[<span class="number">120</span>];</span><br><span class="line">        <span class="keyword">char</span> state_buf[<span class="number">120</span>];</span><br><span class="line">        <span class="keyword">char</span> *prop_buf;</span><br><span class="line">        <span class="keyword">char</span> *envp[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> env_offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resume_dev</span> *<span class="title">sdev</span> =</span> &amp;sdev_g;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(state_buf, <span class="keyword">sizeof</span>(state_buf),<span class="string">&quot;resume_reason=%s&quot;</span>,reasen);</span><br><span class="line">    envp[env_offset++] = state_buf;</span><br><span class="line"></span><br><span class="line">    envp[env_offset] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kobject_uevent_env(&amp;sdev-&gt;dev-&gt;kobj, KOBJ_CHANGE, envp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(resume_set_state);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//system\vold\NetlinkHandler.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetlinkHandler::onEvent</span><span class="params">(NetlinkEvent *evt)</span> </span>&#123;</span><br><span class="line">    VolumeManager *vm = VolumeManager::Instance();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *subsys = evt-&gt;getSubsystem();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!subsys) &#123;</span><br><span class="line">        SLOGW(<span class="string">&quot;No subsystem found in netlink event&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">&quot;resume_wake&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *resume_reason = evt-&gt;findParam(<span class="string">&quot;resume_reason&quot;</span>);</span><br><span class="line">        ALOGD(<span class="string">&quot;resume_reason %s\n&quot;</span>,resume_reason);        </span><br><span class="line">		vm-&gt;getBroadcaster()-&gt;sendBroadcast(<span class="number">697</span>,resume_reason, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">&quot;video4linux&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> action = evt-&gt;getAction();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *path = evt-&gt;findParam(<span class="string">&quot;DEVPATH&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> usbcam_path[<span class="number">32</span>];</span><br><span class="line">        ALOGI(<span class="string">&quot;video4linux path: %s&quot;</span>, path);</span><br><span class="line">        <span class="built_in">memset</span>(usbcam_path, <span class="number">0</span>, <span class="keyword">sizeof</span>(usbcam_path));</span><br><span class="line">        <span class="comment">//default message: &quot;uvc&quot;</span></span><br><span class="line">        <span class="built_in">strcpy</span>(usbcam_path, <span class="string">&quot;uvc&quot;</span>);</span><br><span class="line">        stripUSBCamNode(path, usbcam_path);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>(action == NetlinkEvent::NlActionAdd)&#123;</span><br><span class="line">            updateUSBCameraProp(path, usbcam_path);</span><br><span class="line">	        vm-&gt;getBroadcaster()-&gt;sendBroadcast(<span class="number">698</span>, usbcam_path, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(action == NetlinkEvent::NlActionRemove)&#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;USBCam NetlinkEvent::NlActionRemove, Force Power Off &quot;</span>);</span><br><span class="line">			vm-&gt;getBroadcaster()-&gt;sendBroadcast(<span class="number">699</span>, usbcam_path, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Linux kernel – Uevent发送（热插拔）事件到用户空间</p>
<p>Jackson_csdn 2016-07-15 14:16:30  14825  收藏 11<br>分类专栏： Linux内核<br>版权<br>Uevent是一种在内核空间和用户空间之间通信的机制，主要用于热插拔事件（hotplug）。</p>
<p>uevent事件<br>根据include/linux/kobject.h中的定义，kobject对应的动作可分为以下几种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">kobject_action</span> &#123;</span></span><br><span class="line">    KOBJ_ADD,</span><br><span class="line">    KOBJ_REMOVE,</span><br><span class="line">    KOBJ_CHANGE,</span><br><span class="line">    KOBJ_MOVE,</span><br><span class="line">    KOBJ_ONLINE,</span><br><span class="line">    KOBJ_OFFLINE,</span><br><span class="line">    KOBJ_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些动作对应的事件相应有以下几种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *kobject_actions[] = &#123;</span><br><span class="line">    [KOBJ_ADD] =        <span class="string">&quot;add&quot;</span>,</span><br><span class="line">    [KOBJ_REMOVE] =     <span class="string">&quot;remove&quot;</span>,</span><br><span class="line">    [KOBJ_CHANGE] =     <span class="string">&quot;change&quot;</span>,</span><br><span class="line">    [KOBJ_MOVE] =       <span class="string">&quot;move&quot;</span>,</span><br><span class="line">    [KOBJ_ONLINE] =     <span class="string">&quot;online&quot;</span>,</span><br><span class="line">    [KOBJ_OFFLINE] =    <span class="string">&quot;offline&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说明：本文所有的源代码均取自内核2.6.32。</p>
<p>uevent环境变量<br>Uevent事件具体以环境变量（即字符串）的形式发送到用户空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_uevent_env</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *envp[UEVENT_NUM_ENVP]; <span class="comment">/*环境变量指针数组*/</span></span><br><span class="line">    <span class="keyword">int</span> envp_idx; <span class="comment">/*数组下标*/</span></span><br><span class="line">    <span class="keyword">char</span> buf[UEVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">int</span> buflen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>发送事件方法<br>在内核中通过kobject_uevent_env函数将事件发送到用户空间，但是实际上发送事件的动作由调用函数kobject_uevent_env实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_uevent - notify userspace by ending an uevent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @action: action that is happening</span></span><br><span class="line"><span class="comment"> * @kobj: struct kobject that the action is happening to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 if kobject_uevent() is completed with success or the</span></span><br><span class="line"><span class="comment"> * corresponding error when it fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_uevent</span><span class="params">(struct kobject *kobj, <span class="keyword">enum</span> kobject_action action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> kobject_uevent_env(kobj, action, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kobject_uevent);</span><br></pre></td></tr></table></figure>
<p>kobject_uevent_env函数主要做了两方面的工作：</p>
<p>获取整理了与即将发送的事件相关的环境变量，如ACTION、DEVPATH和SUBSYSTE等。<br>发送事件到用户空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kobject_uevent_env - send an uevent with environmental data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @action: action that is happening</span></span><br><span class="line"><span class="comment"> * @kobj: struct kobject that the action is happening to</span></span><br><span class="line"><span class="comment"> * @envp_ext: pointer to environmental data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 if kobject_uevent() is completed with success or the</span></span><br><span class="line"><span class="comment"> * corresponding error when it fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_uevent_env</span><span class="params">(struct kobject *kobj, <span class="keyword">enum</span> kobject_action action,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">char</span> *envp_ext[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_uevent_env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *action_string = kobject_actions[action];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devpath = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *subsystem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">top_kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">    u64 seq;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s\n&quot;</span>,</span><br><span class="line">         kobject_name(kobj), kobj, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* search the kset we belong to */</span></span><br><span class="line">    top_kobj = kobj;</span><br><span class="line">    <span class="keyword">while</span> (!top_kobj-&gt;kset &amp;&amp; top_kobj-&gt;parent)</span><br><span class="line">        top_kobj = top_kobj-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!top_kobj-&gt;kset) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: attempted to send uevent &quot;</span></span><br><span class="line">             <span class="string">&quot;without kset!\n&quot;</span>, kobject_name(kobj), kobj,</span><br><span class="line">             __func__);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kset = top_kobj-&gt;kset;</span><br><span class="line">    uevent_ops = kset-&gt;uevent_ops;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip the event, if uevent_suppress is set*/</span></span><br><span class="line">    <span class="keyword">if</span> (kobj-&gt;uevent_suppress) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: uevent_suppress &quot;</span></span><br><span class="line">                 <span class="string">&quot;caused the event to drop!\n&quot;</span>,</span><br><span class="line">                 kobject_name(kobj), kobj, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* skip the event, if the filter returns zero. */</span></span><br><span class="line">    <span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;filter)</span><br><span class="line">        <span class="keyword">if</span> (!uevent_ops-&gt;filter(kset, kobj)) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: filter function &quot;</span></span><br><span class="line">                 <span class="string">&quot;caused the event to drop!\n&quot;</span>,</span><br><span class="line">                 kobject_name(kobj), kobj, __func__);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* originating subsystem */</span></span><br><span class="line">    <span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;name)</span><br><span class="line">        subsystem = uevent_ops-&gt;name(kset, kobj);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        subsystem = kobject_name(&amp;kset-&gt;kobj);</span><br><span class="line">    <span class="keyword">if</span> (!subsystem) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: unset subsystem caused the &quot;</span></span><br><span class="line">             <span class="string">&quot;event to drop!\n&quot;</span>, kobject_name(kobj), kobj,</span><br><span class="line">             __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* environment buffer */</span></span><br><span class="line">    env = kzalloc(<span class="keyword">sizeof</span>(struct kobj_uevent_env), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!env)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* complete object path */</span></span><br><span class="line">    devpath = kobject_get_path(kobj, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!devpath) &#123;</span><br><span class="line">        retval = -ENOENT;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* default keys */</span></span><br><span class="line">    retval = add_uevent_var(env, <span class="string">&quot;ACTION=%s&quot;</span>, action_string);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    retval = add_uevent_var(env, <span class="string">&quot;DEVPATH=%s&quot;</span>, devpath);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    retval = add_uevent_var(env, <span class="string">&quot;SUBSYSTEM=%s&quot;</span>, subsystem);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* keys passed in from the caller */</span></span><br><span class="line">    <span class="keyword">if</span> (envp_ext) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; envp_ext[i]; i++) &#123;</span><br><span class="line">            retval = add_uevent_var(env, <span class="string">&quot;%s&quot;</span>, envp_ext[i]);</span><br><span class="line">            <span class="keyword">if</span> (retval)</span><br><span class="line">                <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the kset specific function add its stuff */</span></span><br><span class="line">    <span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;uevent) &#123;</span><br><span class="line">        retval = uevent_ops-&gt;uevent(kset, kobj, env);</span><br><span class="line">        <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;kobject: &#x27;%s&#x27; (%p): %s: uevent() returned &quot;</span></span><br><span class="line">                 <span class="string">&quot;%d\n&quot;</span>, kobject_name(kobj), kobj,</span><br><span class="line">                 __func__, retval);</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Mark &quot;add&quot; and &quot;remove&quot; events in the object to ensure proper</span></span><br><span class="line"><span class="comment">     * events to userspace during automatic cleanup. If the object did</span></span><br><span class="line"><span class="comment">     * send an &quot;add&quot; event, &quot;remove&quot; will automatically generated by</span></span><br><span class="line"><span class="comment">     * the core, if not already done by the caller.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (action == KOBJ_ADD)</span><br><span class="line">        kobj-&gt;state_add_uevent_sent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (action == KOBJ_REMOVE)</span><br><span class="line">        kobj-&gt;state_remove_uevent_sent = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we will send an event, so request a new sequence number */</span></span><br><span class="line">    spin_lock(&amp;sequence_lock);</span><br><span class="line">    seq = ++uevent_seqnum;</span><br><span class="line">    spin_unlock(&amp;sequence_lock);</span><br><span class="line">    retval = add_uevent_var(env, <span class="string">&quot;SEQNUM=%llu&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)seq);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NET)</span></span><br><span class="line">    <span class="comment">/* send netlink message */</span></span><br><span class="line">    <span class="keyword">if</span> (uevent_sock) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* allocate message with the maximum possible size */</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(action_string) + <span class="built_in">strlen</span>(devpath) + <span class="number">2</span>;</span><br><span class="line">        skb = alloc_skb(len + env-&gt;buflen, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (skb) &#123;</span><br><span class="line">            <span class="keyword">char</span> *scratch;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* add header */</span></span><br><span class="line">            scratch = skb_put(skb, len);</span><br><span class="line">            <span class="built_in">sprintf</span>(scratch, <span class="string">&quot;%s@%s&quot;</span>, action_string, devpath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* copy keys to our continuous event payload buffer */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; env-&gt;envp_idx; i++) &#123;</span><br><span class="line">                len = <span class="built_in">strlen</span>(env-&gt;envp[i]) + <span class="number">1</span>;</span><br><span class="line">                scratch = skb_put(skb, len);</span><br><span class="line">                <span class="built_in">strcpy</span>(scratch, env-&gt;envp[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            NETLINK_CB(skb).dst_group = <span class="number">1</span>;</span><br><span class="line">            retval = netlink_broadcast(uevent_sock, skb, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">                           GFP_KERNEL);</span><br><span class="line">            <span class="comment">/* ENOBUFS should be handled in userspace */</span></span><br><span class="line">            <span class="keyword">if</span> (retval == -ENOBUFS)</span><br><span class="line">                retval = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            retval = -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call uevent_helper, usually only enabled during early boot */</span></span><br><span class="line">    <span class="keyword">if</span> (uevent_helper[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">char</span> *argv [<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        argv [<span class="number">0</span>] = uevent_helper;</span><br><span class="line">        argv [<span class="number">1</span>] = (<span class="keyword">char</span> *)subsystem;</span><br><span class="line">        argv [<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        retval = add_uevent_var(env, <span class="string">&quot;HOME=/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        retval = add_uevent_var(env,</span><br><span class="line">                    <span class="string">&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">        retval = call_usermodehelper(argv[<span class="number">0</span>], argv,</span><br><span class="line">                         env-&gt;envp, UMH_WAIT_EXEC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    kfree(devpath);</span><br><span class="line">    kfree(env);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kobject_uevent_env);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第29～41行，查询当前kobject所属的kset。<br>第44～49行，如果设置了kobj-&gt;uevent_suppress（==1），则跳过该事件。<br>第50～57行，如果可以过滤该事件也跳过该事件。</p>
<p>至此，既然确定事件可以被发送，接下来设置要发送的环境变量：<br>第60～69行，获取subsystem。<br>第77～81行，获取devpath。<br>第84～92行，根据形参和获取的subsystem和devpath的值设置默认的环境变量 - ACTION、DEVPATH和SUBSYSTEM。<br>第95～101行，添加调用函数传递的其他环境变量。</p>
<p>即将发送事件给用户空间，那么需要标记该动作表示事件已（其实是即将）发送：<br>第120～123行，如果是添加事件则为kobj-&gt;state_add_uevent_sent赋值1；如果是移除事件则为kobj-&gt;state_remove_uevent_sent赋值1。</p>
<p>第126～131行，为即将发送的事件分配一个数字标识SEQNUM。</p>
<p>通过以上的准备工作环境变量均设置完毕，接下来就是将这些环境变量发送到用户空间。发送的方法可分为两种：Netlink socket和执行uevent_helper。<br>现在先分析Netlink socket方法。实现该方法的前提条件是定义了CONFIG_NET，然后将要发送的信息（message）存放到网络结构sk_buff中，最后调用netlink_broadcast函数广播到用户空间。这部分的源码见133～165行。<br>如果未定义CONFIG_NET，则可通过call_usermodehelper执行uevent_helper（缺省值是“/sbin/hotplug“）命令发送事件到用户空间。</p>
<p>获取热插拔事件实例<br>热插拔事件最终发送给udev，由udev根据获取的环境变量作相应的操作，如创建设备节点、移除设备节点等。udevadm是一个udev管理工具，可以获取内核发送的事件。下面以插拔优盘实例获取内核发送的事件。</p>
<p>优盘插入后内核立即将该事件发送到用户空间，udev根据规则（/etc/udev/rules.d/<em>.rules或/lib/udev/rules.d/</em>.rules）创建了设备节点/dev/sdb和设备链接文件等。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>cpu_info</title>
    <url>/2020/12/31/Android/cpu_info.sh/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/busybox/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print top info if you need</span></span><br><span class="line"><span class="comment">#top -t -m 9 &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ 1 ]; <span class="keyword">do</span> </span><br><span class="line">zone_type=<span class="string">&quot;zone?&quot;</span> </span><br><span class="line">maxTemp=0</span><br><span class="line">Cur_zone=9</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$Cur_zone</span> -ge 0 ]; <span class="keyword">do</span></span><br><span class="line">    Cur_temp=`cat /sys/class/thermal/thermal_zone<span class="variable">$Cur_zone</span>/temp`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$Cur_temp</span> -gt <span class="variable">$maxTemp</span> ]; <span class="keyword">then</span></span><br><span class="line">        maxTemp=<span class="variable">$Cur_temp</span></span><br><span class="line">        zone_type=`cat /sys/class/thermal/thermal_zone<span class="variable">$Cur_zone</span>/<span class="built_in">type</span>`</span><br><span class="line">        zone_type=<span class="string">&quot;<span class="variable">$zone_type</span>-<span class="variable">$Cur_zone</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;Cur_zone=<span class="variable">$Cur_zone</span> - 1&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">cpu_Temp=`cat /sys/class/thermal/thermal_zone7/temp`</span><br><span class="line">freq=`cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq`</span><br><span class="line">core=`cat /proc/cpuinfo | grep <span class="string">&quot;processor&quot;</span> | busybox wc -l`</span><br><span class="line">tm=`date +%H:%M:%S`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$tm</span> maxTemp(<span class="variable">$zone_type</span>)=<span class="variable">$maxTemp</span> cpu_Temp=<span class="variable">$cpu_Temp</span> core=<span class="variable">$core</span> freq=<span class="variable">$freq</span>&quot;</span></span><br><span class="line">sleep 2</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>hook</title>
    <url>/2020/12/31/Android/hook.sh/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/busybox/sh</span></span><br><span class="line"></span><br><span class="line">PATH=/system/bin:/busybox:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">LOG ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> log_file=/dev/console</span><br><span class="line">    <span class="built_in">local</span> tag=<span class="string">&quot;CM_hook&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> sDate=`date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[<span class="variable">$tag</span>] <span class="variable">$&#123;sDate&#125;</span> <span class="variable">$@</span>&quot;</span> &gt; <span class="variable">$log_file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOG <span class="string">&quot;Start <span class="variable">$0</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#turn off radar power</span></span><br><span class="line">ln -s /dev/ttyMT1  /dev/ttyS1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0&quot;</span>&gt;/sys/devices/virtual/misc/radar/ctl</span><br><span class="line"></span><br><span class="line">ln -s /dev/ttyMT2  /dev/ttyS2</span><br><span class="line">ln -s /dev/ttyMT3  /dev/ttyS3</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/hps/enabled</span><br><span class="line"><span class="built_in">echo</span> performance &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</span><br><span class="line"><span class="built_in">echo</span> 4 &gt;proc/cpufreq/cpufreq_oppidx </span><br><span class="line"><span class="built_in">echo</span> 0 &gt;sys/devices/system/cpu/cpu3/online </span><br><span class="line"><span class="built_in">echo</span> 0 &gt;sys/devices/system/cpu/cpu2/online </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#set wifi bt mac addr</span></span><br><span class="line">/system/bin/wifibt_mac random&amp;</span><br><span class="line"></span><br><span class="line">gsensor_bmi=`cat /proc/cmdline | grep gs=bmi160`</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$gsensor_bmi</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    LOG <span class="string">&quot;trigger bmibmmd for gsensor of bmi160&quot;</span></span><br><span class="line">    setprop sys.hw_gsensor.bmi 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> t=300</span><br><span class="line"><span class="built_in">local</span> tm_boot=0</span><br><span class="line"><span class="built_in">local</span> boot_ok=</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$t</span> -gt 0 ]; <span class="keyword">do</span></span><br><span class="line">    boot_ok=`getprop sys.boot_completed`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$boot_ok</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        LOG <span class="string">&quot;<span class="variable">$0</span>: Boot finished(<span class="variable">$tm_boot</span>), then trigger xlog&quot;</span></span><br><span class="line">        <span class="comment">#/system/bin/xlog filter-set on</span></span><br><span class="line">        /system/bin/xlog filter-reset</span><br><span class="line">        <span class="comment">#am start -n com.mediatek.engineermode/.EngineerMode</span></span><br><span class="line">        <span class="comment">#am start -n com.mediatek.mtklogger/.MainActivity</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sleep 2</span><br><span class="line">        <span class="built_in">let</span> <span class="string">&quot;t = t - 1&quot;</span></span><br><span class="line">        <span class="built_in">let</span> <span class="string">&quot;tm_boot = tm_boot + 2&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> cta=`getprop ro.cta`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$cta</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    iptables -I INPUT -s 10.0.0.172 -j DROP</span><br><span class="line">    iptables -I INPUT -s mmsc.monternet.com -j DROP</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#remove it to init.project.rc</span></span><br><span class="line"><span class="comment">#default param tempCtrl/less/full Trig: 100 85 75</span></span><br><span class="line"><span class="comment">#/system/backup/bin/loop.sh 100 85 75 &amp;</span></span><br><span class="line"></span><br><span class="line">memTotal=`cat /proc/meminfo | grep MemTotal | sed <span class="string">&#x27;s/[ ]\+/ /g&#x27;</span> | cut -d<span class="string">&#x27; &#x27;</span> -f2`</span><br><span class="line">memTotal=`expr <span class="variable">$memTotal</span> \/ 1024`</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> min_free_kbytes=`cat /proc/sys/vm/min_free_kbytes`</span><br><span class="line"></span><br><span class="line">chmod 660 /sys/module/lowmemorykiller/parameters/minfree</span><br><span class="line">lowmemkiller=`cat /sys/module/lowmemorykiller/parameters/minfree`</span><br><span class="line">LOG <span class="string">&quot;memTotal=<span class="variable">$memTotal</span> MB, org min_free_kbytes=<span class="variable">$min_free_kbytes</span> lowmemkiller=<span class="variable">$lowmemkiller</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$memTotal</span> -gt 768 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#1G DDR</span></span><br><span class="line">    min_free_kbytes=28672</span><br><span class="line">    lowmemkiller=<span class="string">&quot;6144,8192,16384,20480,22528,24576&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$memTotal</span> -gt 660 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#768M DDR</span></span><br><span class="line">    min_free_kbytes=15360</span><br><span class="line">    lowmemkiller=<span class="string">&quot;2304,3072,6144,7680,8448,9216&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">#512M DDR</span></span><br><span class="line">    min_free_kbytes=10240</span><br><span class="line">    lowmemkiller=<span class="string">&quot;1536,2048,4096,5120,5632,6144&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$min_free_kbytes</span> &gt; /proc/sys/vm/min_free_kbytes</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$lowmemkiller</span> &gt; /sys/module/lowmemorykiller/parameters/minfree</span><br><span class="line">min_free_kbytes=`cat /proc/sys/vm/min_free_kbytes`</span><br><span class="line">lowmemkiller=`cat /sys/module/lowmemorykiller/parameters/minfree`</span><br><span class="line">LOG <span class="string">&quot;new min_free_kbytes=<span class="variable">$min_free_kbytes</span> lowmemkiller=<span class="variable">$lowmemkiller</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#isHeadless=`getprop ro.product.class`</span></span><br><span class="line"><span class="comment">#if [ &quot;$isHeadless&quot; == &quot;headless&quot; ]; then</span></span><br><span class="line"><span class="comment">#    curTimeoff=`sqlite3 /data/data/com.android.providers.settings/databases/settings.db \</span></span><br><span class="line"><span class="comment">#               &quot;select value from system where name=&#x27;screen_off_timeout&#x27;&quot;`</span></span><br><span class="line"><span class="comment">#    STANGE： sqlite will fail when system boot, but OK by cmd line!!!</span></span><br><span class="line"><span class="comment">#    if [ $curTimeoff -eq 30 ]; then</span></span><br><span class="line"><span class="comment">#        LOG &quot;screen off timeout is already $curTimeoff&quot;</span></span><br><span class="line"><span class="comment">#    else</span></span><br><span class="line"><span class="comment">#        LOG &quot;set screen off timeout to 30s&quot;</span></span><br><span class="line"><span class="comment">#        sqlite3 /data/data/com.android.providers.settings/databases/settings.db \</span></span><br><span class="line"><span class="comment">#        &quot;insert into system (name, value) values (&#x27;screen_off_timeout&#x27;, 30)&quot;</span></span><br><span class="line"><span class="comment">#    fi</span></span><br><span class="line"><span class="comment">#fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> cntFail=`getprop persist.bootup.fail`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$boot_ok</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    filter_size_org=`<span class="built_in">stat</span> -c <span class="string">&quot;%s&quot;</span> /system/etc/xlog-filter-default`</span><br><span class="line">    filter_size_running=`<span class="built_in">stat</span> -c <span class="string">&quot;%s&quot;</span> /data/misc/xlog-filter`</span><br><span class="line">    size=`expr <span class="variable">$filter_size_org</span> - <span class="variable">$filter_size_running</span>`</span><br><span class="line">    abs_size=`<span class="built_in">echo</span> <span class="variable">$size</span> | tr -d -`</span><br><span class="line">    <span class="comment">#if [ $abs_size -gt 1000 ]; then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$filter_size_running</span> -lt 1000 ]; <span class="keyword">then</span></span><br><span class="line">        LOG <span class="string">&quot;ERROR: xlog-filter size abnormal, try to filter-reset...&quot;</span></span><br><span class="line">        LOG <span class="string">&quot;org=<span class="variable">$filter_size_org</span> running=<span class="variable">$filter_size_running</span> abs=<span class="variable">$abs_size</span>&quot;</span></span><br><span class="line">        rm /data/misc/xlog-filter</span><br><span class="line">        /system/bin/xlog filter-reset</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LOG <span class="string">&quot;checking xlog-filter OK&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$cntFail</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        LOG <span class="string">&quot;Bootup OK, reset cntFail(<span class="variable">$cntFail</span>)&quot;</span></span><br><span class="line">        setprop persist.bootup.fail 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$cntFail</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        cntFail=1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">let</span> <span class="string">&quot;cntFail = cntFail + 1&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$cntFail</span> -gt 2 ]; <span class="keyword">then</span></span><br><span class="line">        LOG <span class="string">&quot;Bootup failed(<span class="variable">$cntFail</span>), remove all in /data/ and reboot system...&quot;</span></span><br><span class="line">        stop</span><br><span class="line">        rm -rf /data/*</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        setprop persist.bootup.fail <span class="variable">$cntFail</span></span><br><span class="line">        LOG <span class="string">&quot;Bootup failed(<span class="variable">$cntFail</span>), reboot system...&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    reboot -p</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#PowerOn UsbCamara, need do it here?</span></span><br><span class="line"><span class="comment">#echo 1 &gt; /sys/devices/virtual/misc/gpio_ctl/usbcam</span></span><br><span class="line"></span><br><span class="line">LOG <span class="string">&quot;Sleeping a while to wait for T card being mounted&quot;</span></span><br><span class="line"><span class="built_in">local</span> delayT=15</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$delayT</span> -gt 0 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">local</span> T_ok=`df | grep sdcard | wc -l`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$T_ok</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">        LOG <span class="string">&quot;T card is mounted(remain <span class="variable">$delayT</span> second)&quot;</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sleep 1</span><br><span class="line">        <span class="built_in">let</span> <span class="string">&quot;delayT = delayT - 1&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>loop</title>
    <url>/2020/12/31/Android/loop.sh/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/busybox/sh</span></span><br><span class="line">PATH=/system/bin:/busybox:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">tempCtrl=100</span><br><span class="line">lessCoreTrig=85</span><br><span class="line">fullCoreTrig=75</span><br><span class="line"></span><br><span class="line"><span class="comment">#display CPU info on screen by default</span></span><br><span class="line"><span class="comment">#setprop debug.disp.cpu_info 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#limit max cpu-feq and reduce back-light according to cpu temperature</span></span><br><span class="line">blLevel1=120</span><br><span class="line">blLevel2=20</span><br><span class="line"><span class="comment">#set max freq to 1.0G(1040000)</span></span><br><span class="line">tempLevel1=90000</span><br><span class="line"><span class="comment">#set max freq to 800M(819000)</span></span><br><span class="line">tempLevel2=94000</span><br><span class="line"><span class="comment">#set back-light to blLevel1</span></span><br><span class="line">tempLevel3=98000</span><br><span class="line"><span class="comment">#set back-light to blLevel2</span></span><br><span class="line">tempLevel4=102000</span><br><span class="line"><span class="comment">#set max freq to 600M(598000)</span></span><br><span class="line">tempLevel5=106000</span><br><span class="line"><span class="comment">#set back-light to screen off</span></span><br><span class="line">tempLevel6=108000</span><br><span class="line">strScreenOff=<span class="string">&quot;系统温度过高，自动熄屏&quot;</span></span><br><span class="line"><span class="comment">#time-out of no user operation, then auto screen off</span></span><br><span class="line">freeTimeout=180</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -gt 1 ]; <span class="keyword">then</span></span><br><span class="line">    tempCtrl=<span class="variable">$1</span></span><br><span class="line">    lessCoreTrig=<span class="variable">$2</span></span><br><span class="line">    fullCoreTrig=<span class="variable">$3</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">LOG ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> log_file=/dev/console</span><br><span class="line">    <span class="built_in">local</span> tag=<span class="string">&quot;CM_loop&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> sDate=`date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[<span class="variable">$tag</span>] <span class="variable">$&#123;sDate&#125;</span> <span class="variable">$@</span>&quot;</span> &gt; <span class="variable">$log_file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#para1: string fileWild</span></span><br><span class="line"><span class="comment">#para2: int keepCount</span></span><br><span class="line">Clear_old ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> [ ! <span class="variable">$#</span> -eq 2 ]; <span class="keyword">then</span></span><br><span class="line">        LOG <span class="string">&quot;*E* error parameter(<span class="variable">$#</span>)&quot;</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    fileWild=<span class="variable">$1</span></span><br><span class="line">    keepCount=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">local</span> Files=</span><br><span class="line">    <span class="built_in">local</span> Total=`/busybox/ls -lrc <span class="variable">$fileWild</span> | wc -l 2&gt;/dev/null`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$Total</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">        Files=`/busybox/ls -rc <span class="variable">$fileWild</span>`</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LOG <span class="string">&quot;*I* no more <span class="variable">$fileWild</span> &quot;</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment">#LOG &quot;Files=$Files&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$Files</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$Total</span> -gt <span class="variable">$keepCount</span> ]; <span class="keyword">then</span></span><br><span class="line">            LOG <span class="string">&quot;Total=<span class="variable">$Total</span>, curFile=<span class="variable">$i</span>&quot;</span></span><br><span class="line">            rm -rf <span class="variable">$i</span></span><br><span class="line">            <span class="built_in">let</span> <span class="string">&quot;Total = Total - 1&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Auto_Log ()</span><br><span class="line">&#123;</span><br><span class="line">    TID=`date +%Y%m%d.%H%M`</span><br><span class="line">    A_log=Alog_<span class="variable">$TID</span>.txt</span><br><span class="line">    R_log=Rlog_<span class="variable">$TID</span>.txt</span><br><span class="line">    K_log=Klog_<span class="variable">$TID</span>.txt</span><br><span class="line">    DEV_PATH=/sdcard/log_dbg</span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="variable">$DEV_PATH</span> ]; <span class="keyword">then</span></span><br><span class="line">        mkdir -p <span class="variable">$DEV_PATH</span></span><br><span class="line">        <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">            LOG <span class="string">&quot;*E* failed to create <span class="variable">$DEV_PATH</span>&quot;</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    lastLog=3</span><br><span class="line">    Clear_old <span class="string">&quot;<span class="variable">$DEV_PATH</span>/Alog_*&quot;</span> <span class="variable">$lastLog</span></span><br><span class="line">    Clear_old <span class="string">&quot;<span class="variable">$DEV_PATH</span>/Rlog_*&quot;</span> <span class="variable">$lastLog</span></span><br><span class="line">    Clear_old <span class="string">&quot;<span class="variable">$DEV_PATH</span>/Klog_*&quot;</span> <span class="variable">$lastLog</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#dump kernel log</span></span><br><span class="line">    cat /proc/kmsg &gt; <span class="variable">$DEV_PATH</span>/<span class="variable">$K_log</span> &amp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> ReleaseVersion:    `getprop ro.mediatek.version.release` &gt; <span class="variable">$DEV_PATH</span>/<span class="variable">$A_log</span></span><br><span class="line">    <span class="built_in">echo</span> DeviceID:          `getprop ro.device.id` &gt;&gt; <span class="variable">$DEV_PATH</span>/<span class="variable">$A_log</span></span><br><span class="line">    <span class="comment">#dump ps/df info and android log</span></span><br><span class="line">    ps &gt;&gt; <span class="variable">$DEV_PATH</span>/<span class="variable">$A_log</span></span><br><span class="line">    df &gt;&gt; <span class="variable">$DEV_PATH</span>/<span class="variable">$A_log</span></span><br><span class="line">    logcat -v threadtime -r 20480 -n 5 -f <span class="variable">$DEV_PATH</span>/<span class="variable">$A_log</span> &amp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#dump ril log</span></span><br><span class="line">    <span class="built_in">echo</span> ReleaseVersion:    `getprop ro.mediatek.version.release` &gt; <span class="variable">$DEV_PATH</span>/<span class="variable">$R_log</span></span><br><span class="line">    <span class="built_in">echo</span> DeviceID:          `getprop ro.device.id` &gt;&gt; <span class="variable">$DEV_PATH</span>/<span class="variable">$R_log</span></span><br><span class="line">    logcat -b radio -v threadtime -r 20480 -n 5 -f <span class="variable">$DEV_PATH</span>/<span class="variable">$R_log</span> &amp;</span><br><span class="line">    <span class="comment">#logcat -v time -s GpsLocationProvider gps_mtk -f $DEV_PATH/$A_log</span></span><br><span class="line">    </span><br><span class="line">    isCatchingLog=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curMaxFreq=</span><br><span class="line">cpuTemp=</span><br><span class="line">pmuTemp=</span><br><span class="line">LimitMaxFreq ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> setFreq=<span class="variable">$1</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$setFreq</span> -gt 1300000 ] || [ <span class="variable">$setFreq</span> -lt 598000 ]; <span class="keyword">then</span></span><br><span class="line">        LOG <span class="string">&quot;*W* Freq(<span class="variable">$setFreq</span>) is out of range!&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$curMaxFreq</span> -ne <span class="variable">$setFreq</span> ]; <span class="keyword">then</span></span><br><span class="line">            LOG <span class="string">&quot;limit MaxFreq to <span class="variable">$setFreq</span> at <span class="variable">$cpuTemp</span> (-gt <span class="variable">$2</span>)&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$setFreq</span> &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReduceBL ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> setBL=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> curBL=`cat /sys/devices/platform/leds-mt65xx/leds/lcd-backlight/brightness`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$curBL</span> -gt <span class="variable">$setBL</span> ]; <span class="keyword">then</span></span><br><span class="line">        LOG <span class="string">&quot;set back-light to <span class="variable">$setBL</span> at <span class="variable">$cpuTemp</span> (-gt <span class="variable">$2</span>)&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$setBL</span> &gt; /sys/devices/platform/leds-mt65xx/leds/lcd-backlight/brightness</span><br><span class="line">        /system/xbin/sqlite3 /data/data/com.android.providers.settings/databases/settings.db <span class="string">&quot;insert into system (name, value) values (&#x27;screen_brightness&#x27;, <span class="variable">$setBL</span>)&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baiduID=`sqlite3 /data/data/com.android.providers.settings/databases/settings.db \</span><br><span class="line">               <span class="string">&quot;select value from system where name=&#x27;com.baidu.deviceid&#x27;&quot;</span>`</span><br><span class="line">LOG <span class="string">&quot;baiduID = <span class="variable">$baiduID</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$baiduID</span>&quot;</span> == <span class="string">&quot;BA1DCFD325ACAFDE5B2A997B69978374&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    LOG <span class="string">&quot;Clear old baiduID which backup in old data_cust.tgz&quot;</span></span><br><span class="line">    sqlite3 /data/data/com.android.providers.settings/databases/settings.db \</span><br><span class="line">            <span class="string">&quot;delete from system where name=&#x27;com.baidu.deviceid&#x27;&quot;</span></span><br><span class="line">    sqlite3 /data/data/com.android.providers.settings/databases/settings.db \</span><br><span class="line">            <span class="string">&quot;delete from system where name=&#x27;com.baidu.deviceid.v2&#x27;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">LOG <span class="string">&quot;tempCtrl/less/full Trig: <span class="variable">$tempCtrl</span>, <span class="variable">$lessCoreTrig</span>, <span class="variable">$fullCoreTrig</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#level of core/freq, default is 100, 0 means revert to original of MTK</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$tempCtrl</span> &gt; /sys/power/ts_cpu_control</span><br><span class="line"><span class="comment">#internal temp value is 1/1000 unit</span></span><br><span class="line">lessCoreTrig=`expr <span class="variable">$lessCoreTrig</span> \* 1000`</span><br><span class="line">fullCoreTrig=`expr <span class="variable">$fullCoreTrig</span> \* 1000`</span><br><span class="line">LOG <span class="string">&quot;tempCtrl/less/full Trig: <span class="variable">$tempCtrl</span>, <span class="variable">$lessCoreTrig</span>, <span class="variable">$fullCoreTrig</span>&quot;</span></span><br><span class="line"></span><br><span class="line">isFull=`cat /sys/devices/system/cpu/cpu1/online`</span><br><span class="line">isUIMsgRunning=`ps | grep UpdateUIMsg | wc -l`</span><br><span class="line">isCatchingLog=0</span><br><span class="line"></span><br><span class="line">bAutoScrnOff=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ 1 ]; <span class="keyword">do</span> </span><br><span class="line">    cpuTemp=`cat /sys/class/thermal/thermal_zone7/temp`</span><br><span class="line">    pmuTemp=`cat /sys/class/thermal/thermal_zone1/temp`</span><br><span class="line">    curMaxFreq=`cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq`</span><br><span class="line">    <span class="comment">#check whether need to decrease back-light according current cpu temperature</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$cpuTemp</span> -gt <span class="variable">$tempLevel6</span> ]; <span class="keyword">then</span></span><br><span class="line">        userFree=`dumpsys power | grep mLastUserActivityTime= | cut -d<span class="string">&quot;(&quot;</span> -f2 | cut -d<span class="string">&quot; &quot;</span> -f1`</span><br><span class="line">        userFree=`expr <span class="variable">$userFree</span> \/ 1000`</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$bAutoScrnOff</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">local</span> tmpBL=`cat /sys/devices/platform/leds-mt65xx/leds/lcd-backlight/brightness`</span><br><span class="line">            <span class="keyword">if</span> [ ! <span class="variable">$tmpBL</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">                LOG <span class="string">&quot;maybe screen on by voice wakeup, just trigger a useless key event to clear mLastUserActivityTime&quot;</span></span><br><span class="line">                input keyevent KEYCODE_VOLUME_UP</span><br><span class="line">                sleep 1</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        LimitMaxFreq 598000 <span class="variable">$tempLevel5</span></span><br><span class="line">        ReduceBL <span class="variable">$blLevel2</span> <span class="variable">$tempLevel4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$userFree</span> -gt <span class="variable">$freeTimeout</span> ] &amp;&amp; [ <span class="variable">$bAutoScrnOff</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="comment">#cpu temp is too hot, need to screen off to reduce tempture</span></span><br><span class="line">            LOG <span class="string">&quot;auto screen off after LastUserActivityTime=<span class="variable">$userFree</span> at cupTemp=<span class="variable">$cpuTemp</span>&quot;</span></span><br><span class="line">            am broadcast -a <span class="string">&quot;com.car.screen.request&quot;</span> --ei screen_on 0 --es reason <span class="variable">$strScreenOff</span></span><br><span class="line">            bAutoScrnOff=1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$userFree</span> -lt <span class="variable">$freeTimeout</span> ] &amp;&amp; [ <span class="variable">$bAutoScrnOff</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">            LOG <span class="string">&quot;clear flag of bAutoScrnOff&quot;</span></span><br><span class="line">            am broadcast -a <span class="string">&quot;com.car.screen.request&quot;</span> --ei screen_on -1</span><br><span class="line">            bAutoScrnOff=0</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$cpuTemp</span> -gt <span class="variable">$tempLevel5</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment">#cpu temp is very hot, limit cpuMaxFreq to 600M</span></span><br><span class="line">        LimitMaxFreq 598000 <span class="variable">$tempLevel5</span></span><br><span class="line">        ReduceBL <span class="variable">$blLevel2</span> <span class="variable">$tempLevel4</span></span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$cpuTemp</span> -gt <span class="variable">$tempLevel4</span> ]; <span class="keyword">then</span></span><br><span class="line">        LimitMaxFreq 819000 <span class="variable">$tempLevel2</span></span><br><span class="line">        ReduceBL <span class="variable">$blLevel2</span> <span class="variable">$tempLevel4</span></span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$cpuTemp</span> -gt <span class="variable">$tempLevel3</span> ]; <span class="keyword">then</span></span><br><span class="line">        LimitMaxFreq 819000 <span class="variable">$tempLevel2</span></span><br><span class="line">        ReduceBL <span class="variable">$blLevel1</span> <span class="variable">$tempLevel3</span></span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$cpuTemp</span> -gt <span class="variable">$tempLevel2</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment">#cpu temp is hot, limit cpuMaxFreq to 800M</span></span><br><span class="line">        LimitMaxFreq 819000 <span class="variable">$tempLevel2</span></span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$cpuTemp</span> -gt <span class="variable">$tempLevel1</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment">#cpu temp is a little hot, limit cpuMaxFreq to 1.0G</span></span><br><span class="line">        LimitMaxFreq 819000 <span class="variable">$tempLevel1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">#cpu temp is already cool, restore cpuMaxFreq to 1.3G</span></span><br><span class="line">        restoreMaxFreq=819000</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$curMaxFreq</span> -lt <span class="variable">$restoreMaxFreq</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="comment">#LOG &quot;restore cpu_max_freq to $restoreMaxFreq for cpu_temp is less than $tempLevel1&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$restoreMaxFreq</span> &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    strStat=</span><br><span class="line"><span class="keyword">if</span> [ 0 -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$cpuTemp</span> -gt <span class="variable">$lessCoreTrig</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$isFull</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> 0 &gt; /sys/devices/system/cpu/cpu3/online</span><br><span class="line">            isFull=0</span><br><span class="line">            strStat=<span class="string">&quot;trigger less core!&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            strStat=<span class="string">&quot;already less core...&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$cpuTemp</span> -lt <span class="variable">$fullCoreTrig</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$isFull</span>&quot;</span> == <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> 1 &gt; /sys/devices/system/cpu/cpu3/online</span><br><span class="line">            isFull=1</span><br><span class="line">            strStat=<span class="string">&quot;trigger full core!&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            strStat=<span class="string">&quot;already full core...&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        strStat=<span class="string">&quot;Keep previous state.&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    core=`cat /proc/cpuinfo | grep <span class="string">&quot;processor&quot;</span> | busybox wc -l`</span><br><span class="line">    freq=`cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq`</span><br><span class="line">    cpuTemp=`expr <span class="variable">$cpuTemp</span> \/ 100`</span><br><span class="line">    pmuTemp=`expr <span class="variable">$pmuTemp</span> \/ 100`</span><br><span class="line">    strInfo=<span class="string">&quot;<span class="variable">$cpuTemp</span>:<span class="variable">$pmuTemp</span>:<span class="variable">$core</span>:<span class="variable">$freq</span>:<span class="variable">$isFull</span>&quot;</span></span><br><span class="line">    setprop sys.cpu.info <span class="string">&quot;<span class="variable">$strInfo</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    disp=`getprop debug.disp.cpu_info`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$disp</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$disp</span>&quot;</span> == <span class="string">&quot;2&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        strInfo=<span class="string">&quot;T(cpu:pmu)=<span class="variable">$cpuTemp</span>:<span class="variable">$pmuTemp</span>, core=<span class="variable">$core</span>, fq=<span class="variable">$freq</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$disp</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            LOG <span class="string">&quot;<span class="variable">$strInfo</span>&quot;</span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="variable">$isUIMsgRunning</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">                LOG <span class="string">&quot;No need UpdateUIMsg, stop it!&quot;</span></span><br><span class="line">                killall UpdateUIMsg</span><br><span class="line">                isUIMsgRunning=0</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$disp</span>&quot;</span> == <span class="string">&quot;2&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            setprop sys.updateui.message <span class="string">&quot;<span class="variable">$strInfo</span>&quot;</span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="variable">$isUIMsgRunning</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">                LOG <span class="string">&quot;Startup UpdateUIMsg...&quot;</span></span><br><span class="line">                /system/bin/UpdateUIMsg &amp;</span><br><span class="line">                isUIMsgRunning=1</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$isUIMsgRunning</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">            LOG <span class="string">&quot;No need UpdateUIMsg, stop it!&quot;</span></span><br><span class="line">            killall UpdateUIMsg</span><br><span class="line">            isUIMsgRunning=0</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    enableAutoLog=`getprop persist.auto.log`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$isCatchingLog</span> -eq 0 ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$enableAutoLog</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        Auto_Log</span><br><span class="line">        isCatchingLog=1</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$isCatchingLog</span> -eq 1 ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$enableAutoLog</span>&quot;</span> == <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        stopReason=`getprop sys.cm.stop_log`</span><br><span class="line">        LOG <span class="string">&quot;stopping save log: <span class="variable">$stopReason</span>&quot;</span></span><br><span class="line">        <span class="built_in">local</span> sDate=`date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;[<span class="variable">$sDate</span>] stopped saving log: <span class="variable">$stopReason</span>&quot;</span> &gt;&gt; /sdcard/log_dbg/stopLog.txt</span><br><span class="line">        killall logcat cat</span><br><span class="line">        sync</span><br><span class="line">        isCatchingLog=0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    isAccOn=`getprop sys.acc.on`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$isAccOn</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        isPlayMov4AccOn=`getprop persist.PlayMov.AccOn`</span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$isPlayMov4AccOn</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            prl_player /system/custom/bootanimation/boot.mov &amp;</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        setprop sys.acc.on 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    sleep 3</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>packages above can set RTC_WAKEUP ELAPSED_REALTIME_WAKEUP alarm</title>
    <url>/2020/12/31/Android/packages%20above%20can%20set%20RTC_WAKEUP%20ELAPSED_REALTIME_WAKEUP%20alarm/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] sAlarmWhiteList = &#123;</span><br><span class="line">      <span class="string">&quot;com.car.carservice&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * Only packages above can set RTC_WAKEUP/ELAPSED_REALTIME_WAKEUP alarm.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">filterType</span><span class="params">(<span class="keyword">int</span> type, PendingIntent operation)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>( type == AlarmManager.RTC_WAKEUP || type == AlarmManager.ELAPSED_REALTIME_WAKEUP  ) &#123;</span><br><span class="line">          String pakeageName = operation==<span class="keyword">null</span>?<span class="keyword">null</span>:operation.getTargetPackage();</span><br><span class="line">          <span class="keyword">for</span>(String packet : sAlarmWhiteList) &#123;</span><br><span class="line">              <span class="keyword">if</span>( packet.equals(pakeageName) ) &#123;</span><br><span class="line">                  <span class="keyword">return</span> type;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">String values = SystemProperties.get(<span class="string">&quot;sys.rtc.packages&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (values.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	String[] list = values.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (String p: list) &#123;</span><br><span class="line">              		<span class="keyword">if</span>( p.equals(pakeageName) ) &#123;</span><br><span class="line">                  			<span class="keyword">return</span> type;</span><br><span class="line">              		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">          type = (type == AlarmManager.RTC_WAKEUP )? AlarmManager.RTC : AlarmManager.ELAPSED_REALTIME;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">  &#125;    </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImplLocked</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">long</span> when, <span class="keyword">long</span> whenElapsed, <span class="keyword">long</span> windowLength,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">long</span> maxWhen, <span class="keyword">long</span> interval, PendingIntent operation, <span class="keyword">boolean</span> isStandalone,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">boolean</span> doValidate, WorkSource workSource, AlarmManager.AlarmClockInfo alarmClock,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> userId, <span class="keyword">boolean</span> mNeedGrouping)</span> </span>&#123;</span><br><span class="line">      Alarm a = <span class="keyword">new</span> Alarm(filterType(type, operation), when, whenElapsed, windowLength, maxWhen, interval,</span><br><span class="line">              operation, workSource, alarmClock, userId, mNeedGrouping);</span><br><span class="line">      removeLocked(operation);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Bean Overview &amp;&amp; Dependencies (Spring 笔记)</title>
    <url>/2020/12/31/Spring/Bean%20Overview%20&amp;&amp;%20Dependencies%20(Spring%20%E7%AC%94%E8%AE%B0)/</url>
    <content><![CDATA[<h2 id="Bean-Overview"><a href="#Bean-Overview" class="headerlink" title="Bean Overview"></a>Bean Overview</h2><h3 id="Aliasing-a-Bean-outside-the-Bean-Definition"><a href="#Aliasing-a-Bean-outside-the-Bean-Definition" class="headerlink" title="Aliasing a Bean outside the Bean Definition"></a>Aliasing a Bean outside the Bean Definition</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;myApp-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemA-dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;myApp-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemB-dataSource&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Instantiating-Beans"><a href="#Instantiating-Beans" class="headerlink" title="Instantiating Beans"></a>Instantiating Beans</h3><p>With XML-based configuration metadata you can specify your bean class as follows:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;anotherExample&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBeanTwo&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Instantiation-with-a-Static-Factory-Method"><a href="#Instantiation-with-a-Static-Factory-Method" class="headerlink" title="Instantiation with a Static Factory Method"></a>Instantiation with a Static Factory Method</h3><p>In this example, the createInstance() method must be a static method. The following example shows how to specify a factory method:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>The following example shows a class that would work with the preceding bean definition:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Instantiation-by-Using-an-Instance-Factory-Method"><a href="#Instantiation-by-Using-an-Instance-Factory-Method" class="headerlink" title="Instantiation by Using an Instance Factory Method"></a>Instantiation by Using an Instance Factory Method</h4><p> Set the name of the factory method itself with the factory-method attribute</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p> The following example shows the corresponding class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>One factory class can also hold more than one factory method, as the following example shows:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createAccountServiceInstance&quot;</span>/&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>The following example shows the corresponding class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h2><h3 id="Dependency-injection-DI"><a href="#Dependency-injection-DI" class="headerlink" title="Dependency injection (DI)"></a>Dependency injection (DI)</h3><h3 id="Constructor-Argument-Resolution"><a href="#Constructor-Argument-Resolution" class="headerlink" title="Constructor Argument Resolution"></a>Constructor Argument Resolution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThingOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThingOne</span><span class="params">(ThingTwo thingTwo, ThingThree thingThree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;beanTwo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;beanThree&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingTwo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanThree&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingThree&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Constructor-argument-type-matching"><a href="#Constructor-argument-type-matching" class="headerlink" title="Constructor argument type matching"></a>Constructor argument type matching</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Constructor-argument-index"><a href="#Constructor-argument-index" class="headerlink" title="Constructor argument index"></a>Constructor argument index</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Constructor-argument-name"><a href="#Constructor-argument-name" class="headerlink" title="Constructor argument name"></a>Constructor argument name</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Keep in mind that, to make this work out of the box, your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor. If you cannot or do not want to compile your code with the debug flag, you can use the @ConstructorProperties JDK annotation to explicitly name your constructor arguments. The sample class would then have to look as follows:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields omitted</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Examples-of-Dependency-Injection"><a href="#Examples-of-Dependency-Injection" class="headerlink" title="Examples of Dependency Injection"></a>Examples of Dependency Injection</h3><p>The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions as follows:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- setter injection using the nested ref element --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;integerProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>The following example shows the corresponding ExampleBean class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanOne = beanOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanTwo = beanTwo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntegerProperty</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the preceding example, setters are declared to match against the properties specified in the XML file. The following example uses constructor-based DI:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- constructor injection using the nested ref element --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>The following example shows the corresponding ExampleBean class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanOne = anotherBean;</span><br><span class="line">        <span class="keyword">this</span>.beanTwo = yetAnotherBean;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now consider a variant of this example, where, instead of using a constructor, Spring is told to call a static factory method to return an instance of the object:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>The following example shows the corresponding ExampleBean class:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a private constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleBean</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a static factory method; the arguments to this method can be</span></span><br><span class="line">    <span class="comment">// considered the dependencies of the bean that is returned,</span></span><br><span class="line">    <span class="comment">// regardless of how those arguments are actually used.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExampleBean <span class="title">createInstance</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExampleBean eb = <span class="keyword">new</span> ExampleBean (...);</span><br><span class="line">        <span class="comment">// some other operations...</span></span><br><span class="line">        <span class="keyword">return</span> eb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>（Container Overview）Spring笔记</title>
    <url>/2020/12/31/Spring/%EF%BC%88Container%20Overview%EF%BC%89Spring%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Container-Overview"><a href="#Container-Overview" class="headerlink" title="Container Overview"></a>Container Overview</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul>
<li><strong>Inversion of Control (IoC)</strong>  控制反转</li>
<li><strong>dependency injection (DI)</strong>   依赖注入</li>
</ul>
<p><img src="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/images/container-magic.png" alt="The Spring IoC container"></p>
<h3 id="Configuration-Metadata"><a href="#Configuration-Metadata" class="headerlink" title="Configuration Metadata"></a>Configuration Metadata</h3><p>The following example shows the basic structure of XML-based configuration metadata:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Instantiating-a-Container"><a href="#Instantiating-a-Container" class="headerlink" title="Instantiating a Container"></a>Instantiating a Container</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>The following example shows the service layer objects (services.xml) configuration file:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;petStore&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;itemDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;itemDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The following example shows the data access objects daos.xml file:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;itemDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Composing-XML-based-Configuration-Metadata"><a href="#Composing-XML-based-Configuration-Metadata" class="headerlink" title="Composing XML-based Configuration Metadata"></a>Composing XML-based Configuration Metadata</h3><p> Alternatively, use one or more occurrences of the <import/> element to load bean definitions from another file or files. The following example shows how to do so:</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;services.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;resources/messageSource.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;/resources/themeSource.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>


<h3 id="Using-the-Container"><a href="#Using-the-Container" class="headerlink" title="Using the Container"></a>Using the Container</h3><p> The ApplicationContext lets you read bean definitions and access them, as the following example shows:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line">PetStoreService service = context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2020/12/31/mybatis/Mybatis/</url>
    <content><![CDATA[<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。</p>
<p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h4><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>


<p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。</p>
<p>现在你可能很想知道 SqlSession 和 Mapper 到底具体执行了些什么操作</p>
<p>这里给出一个基于 XML 映射语句的示例，它应该可以满足上个示例中 SqlSession 的调用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p>
<h4 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h4><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis-spring-boot-autoconfigure</title>
    <url>/2020/12/31/mybatis/mybatis-spring-boot-autoconfigure/</url>
    <content><![CDATA[<h3 id="mybatis-spring-boot-autoconfigure"><a href="#mybatis-spring-boot-autoconfigure" class="headerlink" title="mybatis-spring-boot-autoconfigure"></a>mybatis-spring-boot-autoconfigure</h3><p>If you are using Maven just add the following dependency to your <code>pom.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile(&quot;org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.3&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM CITY WHERE state = #&#123;state&#125;&quot;)</span></span><br><span class="line">  <span class="function">City <span class="title">findByState</span><span class="params">(<span class="meta">@Param(&quot;state&quot;)</span> String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleMybatisApplication</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CityMapper cityMapper;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SampleMybatisApplication</span><span class="params">(CityMapper cityMapper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cityMapper = cityMapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SampleMybatisApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.cityMapper.findByState(<span class="string">&quot;CA&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>文档00-音视频格式封装原理</title>
    <url>/2020/12/31/%E9%9F%B3%E8%A7%86%E9%A2%91/%E6%96%87%E6%A1%A300-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F%E5%B0%81%E8%A3%85%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="视频解码基础01-封裝格式"><a href="#视频解码基础01-封裝格式" class="headerlink" title="视频解码基础01-封裝格式"></a>视频解码基础01-封裝格式</h3><p>​        我们播放的视频文件一般都是用一种<strong>封装格式</strong>封装起来的，封装格式的作用是什么呢？一般视频文件里不光有视频，还有音频，封装格式的作用就是把视频和音频打包起来。 所以我们先要<strong>解封装格式</strong>，看有哪些视频流和哪些音频流，此时的音频流和视频流都还是<strong>压缩数据</strong>，不能直接用于显示的，这就需要<strong>解码</strong>。下面是播放一个视频文件时的流程图。</p>
<p><img src="/img/4.png" alt="1"></p>
<p>FFmpeg  视频文件  是一个容器  (视频流（H264）  音频流(aac))</p>
<h4 id="二、视频文件封装格式"><a href="#二、视频文件封装格式" class="headerlink" title="二、视频文件封装格式"></a>二、视频文件封装格式</h4><p>封装格式（也叫容器），就是将已经编码压缩好的视频轨和音频轨按照一定的格式放到一个文件中，也就是说仅仅是一个外壳，或者大家把它当成一个放视频轨和音频轨的文件夹也可以。说得通俗点，视频轨相当于饭，而音频轨相当于菜，封装格式就是一个碗，或者一个锅，用来盛放饭菜的容器。 下面是几种常用的 <strong>视频文件后缀类型</strong> 与其相对应的 <strong>封装格式</strong>。</p>
<table>
<thead>
<tr>
<th>视频文件格式</th>
<th>视频封装格式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>.avi</strong></td>
<td>AVI（Audio Video Interleaved）</td>
</tr>
<tr>
<td><strong>.wmv、.asf</strong></td>
<td>WMV（Windows Media Video）</td>
</tr>
<tr>
<td><strong>.mpg、.mpeg、.vob、.dat、.3gp、.mp4</strong></td>
<td>MPEG（Moving Picture Experts Group）</td>
</tr>
<tr>
<td><strong>.mkv</strong></td>
<td>Matroska</td>
</tr>
<tr>
<td><strong>.rm、.rmvb</strong></td>
<td>Real Video</td>
</tr>
<tr>
<td><strong>.mov</strong></td>
<td>QuickTime File Format</td>
</tr>
<tr>
<td><strong>.flv</strong></td>
<td>Flash Video</td>
</tr>
</tbody></table>
<h4 id="三、-音视频编码方式简介"><a href="#三、-音视频编码方式简介" class="headerlink" title="三、 音视频编码方式简介"></a>三、 音视频编码方式简介</h4><h5 id="1、视频编码方式"><a href="#1、视频编码方式" class="headerlink" title="1、视频编码方式"></a>1、视频编码方式</h5><ul>
<li><strong>视频编码的作用：</strong> 将视频像素数据（<strong>RGB，YUV</strong> 等）压缩成视频码流，从而降低视频的数据量。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>HEVC（H.265）</strong></th>
<th><strong>MPEG/ITU-T</strong></th>
<th>2013</th>
<th>研发中</th>
</tr>
</thead>
<tbody><tr>
<td>名称</td>
<td>推出机构</td>
<td>推出时间</td>
<td>目前使用领域</td>
</tr>
<tr>
<td><strong>H.264</strong></td>
<td><strong>MPEG/ITU-T</strong></td>
<td>2003</td>
<td>各个领域</td>
</tr>
<tr>
<td><strong>MPEG4</strong></td>
<td><strong>MPEG</strong></td>
<td>2001</td>
<td>不温不火</td>
</tr>
<tr>
<td><strong>MPEG2</strong></td>
<td><strong>MPEG</strong></td>
<td>1994</td>
<td>数字电视</td>
</tr>
<tr>
<td><strong>VP9</strong></td>
<td>Google</td>
<td>2013</td>
<td>研发中</td>
</tr>
<tr>
<td><strong>VP8</strong></td>
<td>Google</td>
<td>2008</td>
<td>不普及</td>
</tr>
<tr>
<td><strong>VC-1</strong></td>
<td>Microsoft Inc.</td>
<td>2006</td>
<td>微软平台</td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="四-音频编码方式"><a href="#四-音频编码方式" class="headerlink" title="四, 音频编码方式"></a>四, 音频编码方式</h4><p><strong>音频编码的作用：</strong> 将音频采样数据（<strong>PCM</strong> 等）压缩成音频码流，从而降低音频的数据量。 常用的音频编码方式有以下几种：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>推出时间</th>
<th>目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AAC</strong></td>
<td><strong>MPEG</strong></td>
<td>1997</td>
<td>各个领域（新）</td>
</tr>
<tr>
<td><strong>MP3</strong></td>
<td><strong>MPEG</strong></td>
<td>1993</td>
<td>各个领域（旧）</td>
</tr>
<tr>
<td><strong>WMV</strong></td>
<td><strong>Microsoft Inc.</strong></td>
<td>1999</td>
<td>微软平台</td>
</tr>
<tr>
<td><strong>AC-3</strong></td>
<td><strong>Dolby Inc.</strong></td>
<td>1992</td>
<td>电影</td>
</tr>
</tbody></table>
<h5 id="1-MP3"><a href="#1-MP3" class="headerlink" title="1  MP3"></a>1  MP3</h5><p><strong>MP3</strong>，英文全称 <strong>MPEG-1 or MPEG-2 Audio Layer III</strong>，是曾经非常流行的一种数字音频编码和有损压缩格式，它被设计来大幅降低音频数据量。它是在 <strong>1991</strong> 年，由位于德国埃尔朗根的研究组织 <strong>Fraunhofer-Gesellschaft</strong> 的一组工程师发明和标准化的。<strong>MP3</strong> 的普及，曾对音乐产业造成极大的冲击与影响。</p>
<h5 id="2-AAC"><a href="#2-AAC" class="headerlink" title="2 AAC"></a>2 AAC</h5><p><strong>AAC</strong>，英文全称 <strong>Advanced Audio Coding</strong>，是由 <strong>Fraunhofer IIS</strong>、杜比实验室、<strong>AT&amp;T</strong>、<strong>Sony</strong> 等公司共同开发，在 <strong>1997</strong> 年推出的基于 <strong>MPEG-2</strong> 的音频编码技术。<strong>2000</strong> 年，<strong>MPEG-4</strong> 标准出现后，<strong>AAC</strong> 重新集成了其特性，加入了 <strong>SBR</strong> 技术和 <strong>PS</strong> 技术，为了区别于传统的 <strong>MPEG-2 AAC</strong> 又称为 <strong>MPEG-4 AAC</strong>。 <strong>AAC</strong> 比 <strong>MP3</strong> 有更高的压缩比，同样大小的音频文件，<strong>AAC</strong> 的音质更高。</p>
<h5 id="3-WMA"><a href="#3-WMA" class="headerlink" title="3 WMA"></a>3 WMA</h5><p><strong>WMA</strong>，英文全称 <strong>Windows Media Audio</strong>，由微软公司开发的一种数字音频压缩格式，本身包括有损和无损压缩格式。</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>文档02-帧内预测</title>
    <url>/2020/12/31/%E9%9F%B3%E8%A7%86%E9%A2%91/%E6%96%87%E6%A1%A302-%E5%B8%A7%E5%86%85%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<h4 id="H264编码-帧内预测"><a href="#H264编码-帧内预测" class="headerlink" title="H264编码(帧内预测)"></a>H264编码(帧内预测)</h4><blockquote>
<p><strong>预测？</strong>总感觉这个词有股神奇的力量,能够将你引向未来</p>
<p>是不是这样呢~</p>
<p>那么</p>
<p>帧内预测是不是力量更大呢</p>
<p>它又有什么样的作用呢？</p>
<p>帧内预测可以防止视频产生锯齿现象。</p>
</blockquote>
<p>在帧内预测模式中，预测块P是基于已编码重建块和当前块形成的。对亮度像素而言，P块用于4×4子块或者16×16宏块的相关操作。4×4亮度子块有9种可选预测模式，独立预测每一个4×4亮度子块，适用于带有大量细节的图像编码；16×16亮度块有4种预测模式，预测整个16×16亮度块，适用于平坦区域图像编码；色度块也有4种预测模式，类似于16×16亮度块预测模式。编码器通常选择使P块和编码块之间差异最小的预测模式。</p>
<p>4×4亮度预测模式</p>
<p>如图6.14所示，4×4亮度块的上方和左方像素A～M为已编码和重构像素，用作编解码器中的预测参考像素。a～p为待预测像素，利用A～M值和9种模式实现。其中模式2(DC预测)根据A～M中已编码像素预测，而其余模式只有在所需预测像素全部提供才能使用。图6.15箭头表明了每种模式预测方向。对模式3～8，预测像素由A～M加权平均而得。例如，模式4中，d=round(B/4+C/2+D/4)。</p>
<p><img src="/img/13.png" alt="img"></p>
<p><img src="/img/14.png" alt="img"></p>
<p><img src="/img/15.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描 述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">模式0（垂直）</td>
<td align="left">由A、B、C、D 垂直推出相应像素值</td>
</tr>
<tr>
<td align="left">模式1（水平）</td>
<td align="left">由I、J、K、L 水平推出相应像素值</td>
</tr>
<tr>
<td align="left">模式2（DC）</td>
<td align="left">由A<del>D 及I</del>L 平均值推出所有像素值</td>
</tr>
<tr>
<td align="left">模式3（下左对角线）</td>
<td align="left">由45°方向像素内插得出相应像素值</td>
</tr>
<tr>
<td align="left">模式4（下右对角线）</td>
<td align="left">由45°方向像素内插得出相应像素值</td>
</tr>
<tr>
<td align="left">模式5（右垂直）</td>
<td align="left">由26.6°方向像素值内插得出相应像素值</td>
</tr>
<tr>
<td align="left">模式6（下水平）</td>
<td align="left">由26.6°方向像素值内插得出相应像素值</td>
</tr>
<tr>
<td align="left">模式7（左垂直）</td>
<td align="left">由26.6° 方向像素值内插得出相应像素值</td>
</tr>
<tr>
<td align="left">模式8（上水平）</td>
<td align="left">由26.6° 方向像素值内插得出相应像素值</td>
</tr>
</tbody></table>
<p><img src="/img/16.png" alt="img"></p>
<p><img src="/img/17.png" alt="img"></p>
<p>表2 16×16预测模式</p>
<p><img src="/img/18.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描 述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">模式0（垂直）</td>
<td align="left">由上边像素推出相应像素值</td>
</tr>
<tr>
<td align="left">模式1（水平）</td>
<td align="left">由左边像素推出相应像素值</td>
</tr>
<tr>
<td align="left">模式2（DC）</td>
<td align="left">由上边和左边像素平均值推出相应像素值</td>
</tr>
<tr>
<td align="left">模式3（平面）</td>
<td align="left">利用线形“plane”函数及左、上像素推出相应像素值，适用于亮度变化平缓区域</td>
</tr>
</tbody></table>
<p>8×8色度块预测模式</p>
<p>每个帧内编码宏块的8×8色度成分由已编码左上方色度像素预测而得，两种色度成分常用同一种预测模式。</p>
<p>4种预测模式类似于帧内16×16预测的4种预测模式，只是模式编号不同。其中DC（模式0）、水平（模式1）、垂直（模式2）、平面（模式3）。</p>
<p><img src="/img/19.png" alt="img"></p>
<p>对于当前块C, 编解码器按照如下方法计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">probableprediction mode＝</span><br><span class="line"></span><br><span class="line">​          min&#123;prediction mode of A, predictionmodes of B&#125;</span><br><span class="line"></span><br><span class="line">当A (或者 B）的预测模式不可用时，</span><br><span class="line"></span><br><span class="line">​         prediction mode of A＝ 2.</span><br></pre></td></tr></table></figure>


<p>例如</p>
<p>  A 和 B块的预测模式分别为 3 和1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">most probable mode for block C &#x3D;1</span><br></pre></td></tr></table></figure>




<p>编码器为每个4x4 块发送一个标记 flag,解码器按照如下方式 解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ifflag&#x3D;&#x3D;1, prediction mode&#x3D;most_probable_mode</span><br><span class="line"></span><br><span class="line">Ifflag&#x3D;&#x3D;0</span><br><span class="line"></span><br><span class="line">   If rem_intra4×4_pred_mode&lt; most_probable_mode</span><br><span class="line"></span><br><span class="line">​     prediction mode&#x3D;rem_intra4×4_pred_mode</span><br><span class="line"></span><br><span class="line">   else</span><br><span class="line"></span><br><span class="line">​     prediction mode&#x3D;rem_intra4×4_pred_mode+1</span><br></pre></td></tr></table></figure>


<p>这样表示9中预测模式只需要8个值 (0 to 7)</p>
<p><img src="/img/20.png" alt="img"></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>文档01-视频压缩原理</title>
    <url>/2020/12/31/%E9%9F%B3%E8%A7%86%E9%A2%91/%E6%96%87%E6%A1%A301-%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>H264视频压缩算法现在无疑是所有视频压缩技术中使用最广泛，</p>
<p>最流行的。随着 x264/openh264以及ffmpeg等开源库的推出，大多数使用者无需再对H264的细节做过多的研究，这大降低了人们使用H264的成本。</p>
<p>但为了用好H264，我们还是要对H264的基本原理弄清楚才行。今天我们就来看看H264的基本原理。</p>
<h2 id="H264概述"><a href="#H264概述" class="headerlink" title="H264概述"></a>H264概述</h2><p><img src="/img/30.png" alt="img"></p>
<p>H264压缩技术主要采用了以下几种方法对视频数据进行压缩。包括：</p>
<p>　　帧内预测压缩，解决的是空域数据冗余问题。<br>　　帧间预测压缩（运动估计与补偿），解决的是时域数据冗徐问题。<br>　　整数离散余弦变换（DCT），将空间上的相关性变为频域上无关的数据然后进行量化。<br>　　CABAC压缩。</p>
<p>经过压缩后的帧分为：I帧，P帧和B帧:</p>
<p>　　I帧：关键帧，采用帧内压缩技术。<br>　　P帧：向前参考帧，在压缩时，只参考前面已经处理的帧。采用帧音压缩技术。<br>　　B帧：双向参考帧，在压缩时，它即参考前而的帧，又参考它后面的帧。采用帧间压缩技术。</p>
<p>除了I/P/B帧外，还有图像序列GOP。</p>
<p>　　GOP:两个I帧之间是一个图像序列，在一个图像序列中只有一个I帧。如下图所示：</p>
<p><img src="/img/31.png" alt="img"></p>
<p>下面我们就来详细描述一下H264压缩技术。</p>
<h2 id="H264压缩技术"><a href="#H264压缩技术" class="headerlink" title="H264压缩技术"></a>H264压缩技术</h2><p>H264的基本原理其实非常简单，下我们就简单的描述一下H264压缩数据的过程。通过摄像头采集到的视频帧（按每秒 30 帧算），被送到 H264 编码器的缓冲区中。编码器先要为每一幅图片划分宏块。</p>
<p>以下面这张图为例:</p>
<p> <img src="/img/32.png" alt="img"></p>
<h3 id="划分宏块"><a href="#划分宏块" class="headerlink" title="划分宏块"></a>划分宏块</h3><p>H264默认是使用 16X16 大小的区域作为一个宏块，也可以划分成 8X8 大小。</p>
<p> <img src="/img/33.png" alt="img"></p>
<p>划分好宏块后，计算宏块的象素值。</p>
<p> <img src="/img/34.png" alt="img"></p>
<p>以此类推，计算一幅图像中每个宏块的像素值，所有宏块都处理完后如下面的样子。</p>
<p> <img src="/img/35.png" alt="img"></p>
<h3 id="划分子块"><a href="#划分子块" class="headerlink" title="划分子块"></a>划分子块</h3><p>H264对比较平坦的图像使用 16X16 大小的宏块。但为了更高的压缩率，还可以在 16X16 的宏块上更划分出更小的子块。子块的大小可以是 8X16､ 16X8､ 8X8､ 4X8､ 8X4､ 4X4非常的灵活。</p>
<p> <img src="/img/36.png" alt="img"></p>
<p>上幅图中，红框内的 16X16 宏块中大部分是蓝色背景，而三只鹰的部分图像被划在了该宏块内，为了更好的处理三只鹰的部分图像，H264就在 16X16 的宏块内又划分出了多个子块。</p>
<p> <img src="/img/37.png" alt="img"></p>
<p>这样再经过帧内压缩，可以得到更高效的数据。下图是分别使用mpeg-2和H264对上面宏块进行压缩后的结果。其中左半部分为MPEG-2子块划分后压缩的结果，右半部分为H264的子块划压缩后的结果，可以看出H264的划分方法更具优势。</p>
<p> <img src="/img/39.png" alt="img"></p>
<p>宏块划分好后，就可以对H264编码器缓存中的所有图片进行分组了。</p>
<h3 id="帧分组"><a href="#帧分组" class="headerlink" title="帧分组"></a>帧分组</h3><p>对于视频数据主要有两类数据冗余，一类是时间上的数据冗余，另一类是空间上的数据冗余。其中时间上的数据冗余是最大的。下面我们就先来说说视频数据时间上的冗余问题。</p>
<p>为什么说时间上的冗余是最大的呢？假设摄像头每秒抓取30帧，这30帧的数据大部分情况下都是相关联的。也有可能不止30帧的的数据，可能几十帧，上百帧的数据都是关联特别密切的。</p>
<p>对于这些关联特别密切的帧，其实我们只需要保存一帧的数据，其它帧都可以通过这一帧再按某种规则预测出来，所以说视频数据在时间上的冗余是最多的。</p>
<p>为了达到相关帧通过预测的方法来压缩数据，就需要将视频帧进行分组。那么如何判定某些帧关系密切，可以划为一组呢？我们来看一下例子，下面是捕获的一组运动的台球的视频帧，台球从右上角滚到了左下角。</p>
<p> <img src="/img/40.png" alt="img"></p>
<p><img src="/img/41.png" alt="img"></p>
<p>H264编码器会按顺序，每次取出两幅相邻的帧进行宏块比较，计算两帧的相似度。如下图：</p>
<p> <img src="/img/42.png" alt="img"></p>
<p>通过宏块扫描与宏块搜索可以发现这两个帧的关联度是非常高的。进而发现这一组帧的关联度都是非常高的。因此，上面这几帧就可以划分为一组。其算法是：<strong>在相邻几幅图像画面中，一般有差别的像素只有10%以内的点,亮度差值变化不超过2%，而色度差值的变化只有1%以内，我们认为这样的图可以分到一组。</strong></p>
<p>在这样一组帧中，经过编码后，我们只保留第一帖的完整数据，其它帧都通过参考上一帧计算出来。我们称第一帧为<strong>IDR／I帧</strong>，其它帧我们称为<strong>P／B帧</strong>，这样编码后的数据帧组我们称为<strong>GOP</strong>。</p>
<h3 id="运动估计与补偿"><a href="#运动估计与补偿" class="headerlink" title="运动估计与补偿"></a>运动估计与补偿</h3><p>在H264编码器中将帧分组后，就要计算帧组内物体的运动矢量了。还以上面运动的台球视频帧为例，我们来看一下它是如何计算运动矢量的。</p>
<p>H264编码器首先按顺序从缓冲区头部取出两帧视频数据，然后进行宏块扫描。当发现其中一幅图片中有物体时，就在另一幅图的邻近位置（搜索窗口中）进行搜索。如果此时在另一幅图中找到该物体，那么就可以计算出物体的运动矢量了。下面这幅图就是搜索后的台球移动的位置。</p>
<p> <img src="/img/43.png" alt="img"></p>
<p> 抖音 —-》视频  1M  9M   </p>
<p>通过上图中台球位置相差，就可以计算出台图运行的方向和距离。H264依次把每一帧中球移动的距离和方向都记录下来就成了下面的样子。</p>
<p> <img src="/img/44.png" alt="img"></p>
<p>运动矢量计算出来后，将相同部分（也就是绿色部分）减去，就得到了补偿数据。我们最终只需要将补偿数据进行压缩保存，以后在解码时就可以恢复原图了。压缩补偿后的数据只需要记录很少的一点数据。如下所示：</p>
<p> <img src="/img/45.png" alt="img"></p>
<p>我们把运动矢量与补偿称为<strong>帧间压缩技术</strong>，它解决的是视频帧在时间上的数据冗余。除了帧间压缩，帧内也要进行数据压缩，帧内数据压缩解决的是空间上的数据冗余。下面我们就来介绍一下帧内压缩技术。</p>
<h3 id="帧内预测"><a href="#帧内预测" class="headerlink" title="帧内预测"></a>帧内预测</h3><p>人眼对图象都有一个识别度，对低频的亮度很敏感，对高频的亮度不太敏感。所以基于一些研究，可以将一幅图像中人眼不敏感的数据去除掉。这样就提出了帧内预测技术。</p>
<p>H264的帧内压缩与JPEG很相似。一幅图像被划分好宏块后，对每个宏块可以进行 9 种模式的预测。找出与原图最接近的一种预测模式。</p>
<p> <img src="/img/46.png" alt="img"></p>
<p>下面这幅图是对整幅图中的每个宏块进行预测的过程。</p>
<p> <img src="/img/1307424-20181107191243491-673612486.png" alt="img"></p>
<p>帧内预测后的图像与原始图像的对比如下：</p>
<p> <img src="/img/1307424-20181107191249101-214889465.png" alt="img"></p>
<p>然后，将原始图像与帧内预测后的图像相减得残差值。</p>
<p> <img src="/img/1307424-20181107191253955-1987839456.png" alt="img"></p>
<p>再将我们之前得到的预测模式信息一起保存起来，这样我们就可以在解码时恢复原图了。效果如下：</p>
<p> <img src="/img/1307424-20181107191259057-1084466018.png" alt="img"></p>
<p>经过帧内与帧间的压缩后，虽然数据有大幅减少，但还有优化的空间。</p>
<h3 id="对残差数据做DCT"><a href="#对残差数据做DCT" class="headerlink" title="对残差数据做DCT"></a>对残差数据做DCT</h3><p>可以将残差数据做整数离散余弦变换，去掉数据的相关性，进一步压缩数据。如下图所示，左侧为原数据的宏块，右侧为计算出的残差数据的宏块。</p>
<p> <img src="/img/1307424-20181107191314043-1719104258.png" alt="img"></p>
<p>将残差数据宏块数字化后如下图所示：</p>
<p> <img src="/img/1307424-20181107191318906-1060673182.png" alt="img"></p>
<p>将残差数据宏块进行 DCT 转换。</p>
<p> <img src="/img/1307424-20181107191325145-505363573.png" alt="img"></p>
<p>去掉相关联的数据后，我们可以看出数据被进一步压缩了。</p>
<p> <img src="/img/1307424-20181107191330244-1287304627.png" alt="img"></p>
<p>做完 DCT 后，还不够，还要进行 CABAC 进行无损压缩。</p>
<h3 id="DCT原理大白话"><a href="#DCT原理大白话" class="headerlink" title="DCT原理大白话"></a>DCT原理大白话</h3><p> 这是第一帧画面：P1（我们的参考帧） </p>
<p><img src="/img/50.jpg" alt="50"></p>
<p> 这是第二帧画面：P2（需要编码的帧） </p>
<p><img src="/img/51.jpg" alt="50"></p>
<p> 从视频中截取的两张间隔1-2秒的画面，和实际情况类似，下面我们进行几次运动搜索： </p>
<p> 这是一个演示程序，鼠标选中P2上任意<strong>16x16</strong>的Block，即可搜索出<strong>P1上的 BestMatch</strong> 宏块。虽然车辆在运动，从远到近，但是依然找到了最接近的宏块坐标。 </p>
<p><img src="/img/53.jpg" alt="50"></p>
<p> 这是一个演示程序，鼠标选中P2上任意16x16的Block，即可搜索出P1上的 BestMatch 宏块。虽然车辆在运动，从远到近，但是依然找到了最接近的宏块坐标。 </p>
<p> 搜索演示2：空中电线交叉位置（上图P1，下图P2） </p>
<p><img src="/img/55.jpg" alt="50"></p>
<p><img src="/img/54.jpg" alt="50"></p>
<p> 同样顺利在P1中找到最接近P2里海报的宏块位置。 </p>
<p> 图片全搜索：根据P1和运动矢量数据（在P2中搜索到每一个宏块在P1中最相似的位置集合）还原出来的P2’，即完全用P1各个位置的宏块拼凑出来最像P2的图片P2’，效果如下： </p>
<p><img src="/img/56.jpg" alt="50"></p>
<h5 id="仔细观察，有些支离破碎对吧？肯定啊，拼凑出来的东西就是这样，现在我们用P2-和P2像素相减，得到差分图-D2-P2’-P2-2-0x80："><a href="#仔细观察，有些支离破碎对吧？肯定啊，拼凑出来的东西就是这样，现在我们用P2-和P2像素相减，得到差分图-D2-P2’-P2-2-0x80：" class="headerlink" title="仔细观察，有些支离破碎对吧？肯定啊，拼凑出来的东西就是这样，现在我们用P2`和P2像素相减，得到差分图 D2 = (P2’ - P2) / 2 + 0x80："></a>仔细观察，有些支离破碎对吧？肯定啊，拼凑出来的东西就是这样，现在我们用P2`和P2像素相减，得到差分图 D2 = (P2’ - P2) / 2 + 0x80：</h5><p><img src="/img/57.jpg" alt="50"></p>
<p> 这就是之前支离破碎的 P2` 加上误差 D2之后变成了清晰可见的样子，基本还原了原图P2。 </p>
<p><img src="/img/58.jpg" alt="50"></p>
<p> 由于D2仅仅占5KB，加上压缩过后的运动矢量不过7KB，所以参考P1我们只需要额外 7KB的数据量就可以完整表示P2了，而如果独立将P2用质量尚可的有损压缩方式独立压缩，则至少要去到50-60KB，这一下节省了差不多8倍的空间，正就是所谓运动编码的基本原理。 </p>
<p> 实际在使用中，参考帧并不一定是前面一帧，也不一定是同一个GOP的I帧，因为GOP间隔较长时，后面的图片离I帧变化可能已经很大了，因此常见做法是最近15帧中选择一帧误差最小的作为参考帧，虽然彩色画面有YUV三个分量，但是大量的预测工作和最有选择通常是根据Y分量的灰度帧进行判断的。 </p>
<p> 再者误差我们保存的是（P2-P2’）/2 + 0x80，实际使用时我们会用更有效率的方式，比如让[-64,64]之间的色差精度为1，[-255,-64], [64, 255] 之间的色差精度为2-3，这样会更加真实一些。 </p>
<p> 同时上文很多地方用的是直接lzma2进行简单存储，实际使用时一般会引入熵编码，对数据进行一定层次的整理然后再压缩，性能会好不少。 </p>
<h3 id="CABAC"><a href="#CABAC" class="headerlink" title="CABAC"></a>CABAC</h3><p>上面的帧内压缩是属于有损压缩技术。也就是说图像被压缩后，无法完全复原。而CABAC属于无损压缩技术。</p>
<p>无损压缩技术大家最熟悉的可能就是哈夫曼编码了，给高频的词一个短码，给低频词一个长码从而达到数据压缩的目的。MPEG-2中使用的VLC就是这种算法，我们以 A-Z 作为例子，A属于高频数据，Z属于低频数据。看看它是如何做的。</p>
<p> <img src="/img/1307424-20181107191345116-277907586.png" alt="img"></p>
<p>CABAC也是给高频数据短码，给低频数据长码。同时还会根据上下文相关性进行压缩，这种方式又比VLC高效很多。其效果如下：</p>
<p> <img src="/img/1307424-20181107191350500-1400387362.png" alt="img"></p>
<p>现在将 A-Z 换成视频帧，它就成了下面的样子。</p>
<p> <img src="/img/1307424-20181107191355172-2085276841.png" alt="img"></p>
<p>从上面这张图中明显可以看出采用 CACBA 的无损压缩方案要比 VLC 高效的多。</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>文档03-切片</title>
    <url>/2020/12/31/%E9%9F%B3%E8%A7%86%E9%A2%91/%E6%96%87%E6%A1%A303-%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<p>视频流H264的组装</p>
<h4 id="1-H264介绍"><a href="#1-H264介绍" class="headerlink" title="1 H264介绍"></a>1 H264介绍</h4><blockquote>
<p> 我们了解了什么是宏快，宏快作为压缩视频的最小的一部分，需要被组织，然后在网络之间做相互传输。</p>
</blockquote>
<p>H264更深层次    —》宏块   太浅了</p>
<p>​        如果单纯的用<strong>宏快</strong>来发送数据是<strong>杂乱无章</strong>的，就好像在没有<strong>集装箱</strong> 出现之前，货物总是随意被堆放到船上。</p>
<p>上货（编码），下货是非常痛苦的。 当集装箱出现之后，一切都发生了改变，传输效率大大增高。</p>
<p>​        集装箱可以理解成<strong>H264编码标准</strong>，他制定了相互传输的格式，将宏快 有组织，有结构，有顺序的形成一系列的码流。这种码流既可 通过 InputStream 网络流的数据进行传输，也可以封装成一个文件进行保存</p>
<p><strong>H264: H264/AVC是广泛采用的一种编码方式。</strong>主要作用是为了传输</p>
<h4 id="1-1-H264码流组成"><a href="#1-1-H264码流组成" class="headerlink" title="1.1 H264码流组成"></a>1.1 H264码流组成</h4><p><strong>组成H264码流的结构中 包含以下几部分 ，从大到小排序依次是</strong> </p>
<blockquote>
<p><strong>H264视频序列，图像，片组，片，NALU，宏块 ，像素。</strong> </p>
<p>类似 地球 国家 城市  镇 村落</p>
</blockquote>
<p><img src="/img/66.png"></p>
<h5 id="1-1-1-H264编码分层"><a href="#1-1-1-H264编码分层" class="headerlink" title="1.1.1  H264编码分层"></a>1.1.1  H264编码分层</h5><ul>
<li><strong>NAL层:（Network Abstraction Layer,视频数据网络抽象层）</strong>：  它的作用是H264只要在网络上传输，在传输的过程每个包以太网是1500字节，而H264的帧往往会大于1500字节，所以要进行拆包，将一个帧拆成多个包进行传输，所有的拆包或者组包都是通过NAL层去处理的。</li>
<li><strong>VCL层:（Video Coding Layer,视频数据编码层）</strong>： 对视频原始数据进行压缩</li>
</ul>
<h5 id="1-1-2-H264的传输"><a href="#1-1-2-H264的传输" class="headerlink" title="1.1.2  H264的传输"></a>1.1.2  H264的传输</h5><p>​    <strong>H264是一种码流</strong>  类似与一种不见头，也不见尾的一条<strong>河流</strong>。如何从和流中取到自己想要的<strong>数据</strong>呢，</p>
<p>在H264的标砖中有这样的一个封装格式叫做”Annex-B”的字节流格式。 它是H264编码的主要字节流格式。</p>
<p>几乎市面上的编码器是以这种格式进行输出的。<strong>起始码0x 00 00 00 01 或者 0x 00 00 01</strong> 作为<strong>分隔符</strong>。 </p>
<p>两个 0x 00 00 00 01之间的字节数据 是表示一个NAL Unit</p>
<p><img src="/img/67.png"></p>
<h5 id="1-1-3-编码结构"><a href="#1-1-3-编码结构" class="headerlink" title="1.1.3  编码结构"></a>1.1.3  编码结构</h5><p><img src="/img/68.jpg"></p>
<p> <strong>切片头</strong>：包含了一组片的信息，比如片的数量，顺序等等 </p>
<h5 id="1-1-4-H264码流分层结构图"><a href="#1-1-4-H264码流分层结构图" class="headerlink" title="1.1.4  H264码流分层结构图"></a>1.1.4  H264码流分层结构图</h5><p><img src="/img/69.jpg"></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>文档04-H264分层</title>
    <url>/2020/12/31/%E9%9F%B3%E8%A7%86%E9%A2%91/%E6%96%87%E6%A1%A304-H264%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<h4 id="音视频高手课07-视频流H264码流分析实战"><a href="#音视频高手课07-视频流H264码流分析实战" class="headerlink" title="音视频高手课07-视频流H264码流分析实战"></a>音视频高手课07-视频流H264码流分析实战</h4><h4 id="1-1-H-264编码格式"><a href="#1-1-H-264编码格式" class="headerlink" title="1.1 H.264编码格式"></a>1.1 H.264编码格式</h4><p>H.264的功能分为两层：</p>
<blockquote>
<ul>
<li>视频编码层 </li>
<li>网络提取层 </li>
</ul>
</blockquote>
<blockquote>
<p>H.264 的编码视频序列包括一系列的NAL 单元，每个NAL 单元包含一个RBSP。一个原始的H.264由<strong>N个NALU单元组成</strong>、 NALU 单元常由 [StartCode] [NALU Header] [NALU Payload] 三部分组成，其中 Start Code 用于标示这是一个NALU 单元的开始，必须是”00 00 00 01” 或”00 00 01”。    </p>
</blockquote>
<p><img src="/img/68.png" alt="img"></p>
<p>​     </p>
<h4 id="1-2-H-264网络传输"><a href="#1-2-H-264网络传输" class="headerlink" title="1.2 H.264网络传输"></a>1.2 H.264网络传输</h4><p>​        H.264的编码视频序列包括一系列的<strong>NAL单元</strong>，每个NAL单元包含<strong>一个RBSP</strong>，</p>
<p>见表1。编码片（包括数据分割片IDR片）和序列RBSP结束符被定义为VCL NAL单元，其余为NAL单元。</p>
<p>​        <strong>典型的RBSP单元序列如图2所示。</strong></p>
<p>RBSP  顺丰 头   顺丰公司尾部</p>
<p>每个单元都按独立的NAL单元传送。单元的信息头（一个字节）定义了RBSP单元的类型，NAL单元的其余部分为RBSP数据。</p>
<p><img src="/img/69.png" alt="img"></p>
<p><img src="/img/70.png" alt="img"></p>
<ol>
<li>2.1 <strong>H.264码流结构图</strong>     </li>
</ol>
<p><img src="/img/71.png" alt="img"></p>
<p>起始码：如果NALU对应的Slice为一帧的开始，则用4字节表示，即0x00000001；否则用3字节表示，0x000001。 NAL Header：forbidden_bit，nal_reference_bit（优先级），nal_unit_type（类型）。 脱壳操作：为了使NALU主体不包括起始码，在编码时每遇到两个字节（连续）的0，就插入一字节0x03，以和起始码相区别。解码时，则将相应的0x03删除掉。</p>
<p><img src="/img/72.png" alt="img"></p>
<p> H.264解码 <strong>NAL头信息</strong>的nal_referrence_idc（NRI）用于在重建过程中标记一个NAL单元的重要性，</p>
<ol>
<li>值为0表示这个NAL单元没有用预测，因此可以被解码器抛弃而不会有错误扩散；</li>
<li>值高于0表示NAL单元要用于无漂移重构，且值越高，对此NAL单元丢失的影响越大。</li>
<li> NAL头信息的隐藏比特位，在H.264编码器中默认为0，当网络识别到单元中存在比特错误时，可将其置为1。隐藏比特位主要用于适应不同种类的网络环境（比如有线无线相结合的环境）。     </li>
</ol>
<p><img src="/img/73.png" alt="img"></p>
<p>NAL单元解码的流程为：首先从NAL单元中提取出RBSP语法结构，然后按照如图4所示的流程处理RBSP语法结构。输入的是NAL单元，输出结果是经过解码的当前图像的样值点。 NAL单元中分别包含了序列参数集和图像参数集。图像参数集和序列参数集在其他NAL单元传输过程中作为参考使用，在这些数据NAL单元的片头中，通过语法元素pic_parameter_set_id设置它们所使用的图像参数集编号；而相应的每个图像参数集中，通过语法元素seq_paramter_set_id设置他们使用的序列参数集编号。</p>
<p>几个例子：</p>
<p><img src="http://img.blog.csdn.net/20140720115202062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbmNob25nXzIxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>硬解–soc 芯片</p>
<p>软件   ffmpeg</p>
<p>3、 ffmpeg解析H264流程分析</p>
<p>这是一段实际的码流</p>
<p><img src="http://img.blog.csdn.net/20140720115512525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbmNob25nXzIxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  ffmpeg -i input.mp4 -vcodec h264 -preset fast -b:v 2000k hello.h264 </p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>文档07-H264与H265的区别于差异</title>
    <url>/2020/12/31/%E9%9F%B3%E8%A7%86%E9%A2%91/%E6%96%87%E6%A1%A307-H264%E4%B8%8EH265%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%8E%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<h2 id="H-265与H-264的差异详解"><a href="#H-265与H-264的差异详解" class="headerlink" title="H.265与H.264的差异详解"></a>H.265与H.264的差异详解</h2><blockquote>
<p><strong>码牛只为跟牛逼的你</strong></p>
</blockquote>
<p>通过以下几种来对比H264与H265的差异</p>
<blockquote>
<p>1.编解码框架差异</p>
<p>2.压缩性能比较</p>
<p>3.各模块技术差异汇总</p>
<p>4.块划分结构</p>
<p>5.帧内预测</p>
<p>6.帧间预测</p>
<p>7.去块滤波</p>
<p>8.SAO滤波</p>
<p>9.Tile</p>
<p>10.WPP</p>
<p>11.Dependent slice</p>
<p>12.其他技术</p>
</blockquote>
<h4 id="1-1-H-264与H-265的主要差异"><a href="#1-1-H-264与H-265的主要差异" class="headerlink" title="1.1  H.264与H.265的主要差异"></a>1.1  H.264与H.265的主要差异</h4><p>H.265仍然采用混合编解码，编解码结构域H.264基本一致，</p>
<p>主要的不同在于：</p>
<p>Ø 编码块划分结构：采用CU (CodingUnit)、PU(PredictionUnit)和TU(TransformUnit)的递归结构。</p>
<p>Ø 基本细节：各功能块的内部细节有很多差异</p>
<p>Ø 并行工具：增加了Tile以及WPP等并行工具集以提高编码速度</p>
<p>Ø 滤波器：在去块滤波之后增加了SAO（sample adaptive offset）滤波模块</p>
<p><img src="https://img-blog.csdn.net/20170903222110391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>Fig.H.265的框架图</p>
<h4 id="2-压缩性能比较"><a href="#2-压缩性能比较" class="headerlink" title="2.  压缩性能比较"></a>2.  压缩性能比较</h4><p>PSNR计算方式</p>
<p><img src="https://img-blog.csdn.net/20170903222300500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>H.265/HEVC HM-9.0 和H.264 JM-18.4 的BD-rate 比较：</p>
<p> AllIntra case:           22%</p>
<p> RandomAccess case:       34%</p>
<p> LowDelay case:          37%</p>
<h4 id="3-各模块技术差异汇总"><a href="#3-各模块技术差异汇总" class="headerlink" title="3.  各模块技术差异汇总"></a>3.  各模块技术差异汇总</h4><p><img src="https://img-blog.csdn.net/20170903222335956?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20170903222351940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h4 id="4-块划分结构"><a href="#4-块划分结构" class="headerlink" title="4.  块划分结构"></a>4.  块划分结构</h4><p>在H.265中，将宏块的大小从H.264的16×16扩展到了64×64，以便于高分辨率视频的压缩。</p>
<p>同时，采用了更加灵活的编码结构来提高编码效率，</p>
<p>包括编码单元（CodingUnit）、预测单元（PredictUnit）和变换单元（TransformUnit）。</p>
<p>如下图所示:</p>
<p><img src="https://img-blog.csdn.net/20170903222441671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>其中:</p>
<p>编码单元类似于H.264/AVC中的宏块的概念，用于编码的过程。</p>
<p>预测单元是进行预测的基本单元，</p>
<p>变换单元是进行变换和量化的基本单元。</p>
<p>这三个单元的分离，使得变换、预测和编码各个处理环节更加灵活，</p>
<p>也有利于各环节的划分更加符合视频图像的纹理特征，</p>
<p>有利于各个单元更优化的完成各自的功能。</p>
<p> <img src="https://img-blog.csdn.net/20170903222542263?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>RQT是一种自适应的变换技术，这种思想是对H.264/AVC中ABT（AdaptiveBlock-size Transform）技术的延伸和扩展。</p>
<p>对于帧间编码来说，它允许变换块的大小根据运动补偿块的大小进行自适应的调整；</p>
<p>对于帧内编码来说，它允许变换块的大小根据帧内预测残差的特性进行自适应的调整。</p>
<p>大块的变换相对于小块的变换，一方面能够提供更好的能量集中效果，并能在量化后保存更多的图像细节，但是另一方面在量化后却会带来更多的振铃效应。</p>
<p>因此，根据当前块信号的特性，自适应的选择变换块大小，如下图所示，可以得到能量集中、细节保留程度以及图像的振铃效应三者最优的折中。</p>
<p><img src="https://img-blog.csdn.net/20170903222512555?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>Fig. 灵活的块结构示意图</p>
<h4 id="5-帧内预测模式"><a href="#5-帧内预测模式" class="headerlink" title="5.  帧内预测模式"></a>5.  帧内预测模式</h4><p>本质上H.265是在H.264的预测方向基础上增加了更多的预测方向</p>
<p>H.265：所有尺寸的CU块，亮度有35种预测方向，色度有5种预测方向</p>
<p>H.264：亮度 4x4块9个方向，8x8块9个方向，16x16块4种方向，色度4种方向</p>
<p> <img src="https://img-blog.csdn.net/20170903222603597?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>H.264的帧内预测方向:</p>
<p> <img src="https://img-blog.csdn.net/20170903222635669?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>H.265的帧内预测方向：</p>
<h4 id="6-帧间预测"><a href="#6-帧间预测" class="headerlink" title="6.  帧间预测"></a>6.  帧间预测</h4><p>本质上H.265是在H.264基础上增加插值的抽头系数个数，改变抽头系数值以及增加运动矢量预测值的候选个数，以达到减少预测残差的目的。</p>
<p>H.265与H.264一样插值精度都是亮度到1/4，色度到1/8精度，但插值滤波器抽头长度和系数不同.</p>
<p>H.265的增加了运动矢量预测值候选的个数，而H.264预测值只有一个</p>
<p> <img src="https://img-blog.csdn.net/20170903222712796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>H.265的空域候选项：</p>
<p><img src="https://img-blog.csdn.net/20170903222726452?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>H.265时域共同位置候选项</p>
<h4 id="7-去块滤波"><a href="#7-去块滤波" class="headerlink" title="7.  去块滤波"></a>7.  去块滤波</h4><p>本质上H.265的去块滤波与H.264的去块滤波及流程是一致的，做了如下最显著的改变：</p>
<p>Ø 滤波边界： H.264最小到4x4边界滤波；而H.265适应最新的CU、PU和TU划分结构的滤波边缘，最小滤波边界为8x8，</p>
<p>Ø 滤波顺序：H264先宏块内采用垂直边界，再当前宏块内水平边界；而H.265先整帧的垂直边界，再整帧的水平边界</p>
<p>ALF在编解码环路内，位于Deblock和SAO之后，</p>
<p>用于恢复重建图像以达到重建图像与原始图像之间的均方差（MSE）最小。</p>
<p>ALF的系数是在帧级计算和传输的，可以整帧应用ALF，</p>
<p>也可以对于基于块或基于量化树（quadtree）的部分区域进行ALF，</p>
<p>如果是基于部分区域的ALF，还必须传递指示区域信息的附加信息。</p>
<h4 id="8-采样点自适应偏移（Sample-AdaptiveOffset）滤波"><a href="#8-采样点自适应偏移（Sample-AdaptiveOffset）滤波" class="headerlink" title="8.  采样点自适应偏移（Sample AdaptiveOffset）滤波"></a>8.  采样点自适应偏移（Sample AdaptiveOffset）滤波</h4><p>SAO(sample adaptive offset)滤波其实就是对去块滤波后的重建像素按照不同的模板进行分类，并对每一种分类像素进行补偿, 分类模板分为BO(Band offset)和EO(Edge offset)。</p>
<p> <img src="https://img-blog.csdn.net/20170903222824890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>BO分类：</p>
<p> <img src="https://img-blog.csdn.net/20170903222838657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>EO分类模块：</p>
<p>SAO在编解码环路内，位于Deblock之后，通过对重建图像的分类，对每一类图像像素值加减一个偏移，达到减少失真的目的，从而提高压缩率，减少码流。</p>
<p>采用SAO后，平均可以减少2%~6%的码流,而编码器和解码器的性能消耗仅仅增加了约2%。</p>
<h4 id="9-Tile划分"><a href="#9-Tile划分" class="headerlink" title="9.  Tile划分"></a>9.  Tile划分</h4><p>Tile： 将图像分割为矩形区域。</p>
<p>其主要目的是增强并行处理性能。</p>
<p>每个tile区域相当于一幅子图像，可独立的以LCU块为单位进行编解码。</p>
<p>一个Tile块为基本的并行单元，每个Tile为一个子码流</p>
<p> <img src="https://img-blog.csdn.net/20170903222909352?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>\10. WPP</p>
<p>WPP:  全称为wavefront parallel process，以LCU行为基本的编码单位。</p>
<p>以一行LCU块为基本的并行单元，每一行LCU为一个子码流</p>
<p> <img src="https://img-blog.csdn.net/20170903222931315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>\11. Dependentslice</p>
<p>Dependent slice：该技术可以理解为对原先Slice NALU的数据划分，使其可以适合更加灵活的打包方式。</p>
<p>Slice 和dependent slice 的示意图如下</p>
<p><img src="https://img-blog.csdn.net/20170903223007796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmlyZXJvbGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>\12. 其他相关技术</p>
<p>Ø Transform_skip模式：transform_skip_flag，该模式不进行变换，但是要进行量化，该模式对文本桌面视频有较好效果</p>
<p>Ø 内部比特深度增加：为了保证中间预测、变换以及量化过程中的内部比特精度，以达到更好的压缩性能</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>1、禁止所有通讯 -- 正常工作</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/1%E3%80%81%E7%A6%81%E6%AD%A2%E6%89%80%E6%9C%89%E9%80%9A%E8%AE%AF%20--%20%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>1、禁止所有通讯 – 正常工作 </p>
<p>iptables -P INPUT ACCEPT      </p>
<p>iptables -P OUTPUT DROP      </p>
<p>iptables -P FORWARD DROP   </p>
<p>2、允许所有通讯 – 正常工作</p>
<p>iptables -P INPUT ACCEPT      </p>
<p>iptables -P OUTPUT ACCEPT  </p>
<p>iptables -P FORWARD ACCEPT  </p>
<p>3、清空所有规则 – 貌似工作不正常，如果在禁止所有通讯后，清空规则后上网极不正常，只有在允许所有通讯后才正常 </p>
<p>iptables -F  </p>
<p>iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>2</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/2.%E9%80%9A%E8%BF%87%E6%9F%A5%E7%9C%8BFFMPEG%E6%BA%90%E4%BB%A3%E7%A0%81%E6%88%91%E4%BB%AC%E5%8F%91%E7%8E%B0%EF%BC%8CAVPacket%E4%B8%AD%E7%9A%84/</url>
    <content><![CDATA[<p>2.通过查看FFMPEG源代码我们发现，AVPacket中的数据起始处没有分隔符(0x00000001), 也不是0x65、0x67、0x68、0x41等字节，所以可以AVPacket肯定这不是标准的nalu。其实，AVPacket前4个字表示的是nalu的长度，从第5个字节开始才是nalu的数据。所以直接将AVPacket前4个字节替换为0x00000001即可得到标准的nalu数据。</p>
<p>具体代码如下：</p>
<p>copy</p>
<p>char nal_start[]={0,0,0,1};  </p>
<p>fwrite(nal_start,4,1,fp);  </p>
<p>fwrite(pkt-&gt;data+4,pkt-&gt;size-4,1,fp);  </p>
<p>fclose(fp);  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>312x uboot 签名可擦写</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/312x%20uboot%20%E7%AD%BE%E5%90%8D%E5%8F%AF%E6%93%A6%E5%86%99/</url>
    <content><![CDATA[<p>diff –git a/board/rockchip/common/SecureBoot/SecureBoot.c b/board/rockchip/common/SecureBoot/SecureBoot.c</p>
<p>index 2b0f7b5..a639a24 100755</p>
<p>— a/board/rockchip/common/SecureBoot/SecureBoot.c</p>
<p>+++ b/board/rockchip/common/SecureBoot/SecureBoot.c</p>
<p>@@ -32,7 +32,7 @@ uint32  SecureBootLock_backup;</p>
<p> BOOT_CONFIG_INFO gBootConfig <strong>attribute</strong>((aligned(ARCH_DMA_MINALIGN)));</p>
<p> DRM_KEY_INFO gDrmKeyInfo <strong>attribute</strong>((aligned(ARCH_DMA_MINALIGN)));</p>
<p>-</p>
<p>+#define ERASE_DRM_KEY_EN</p>
<p> #ifdef ERASE_DRM_KEY_EN</p>
<p> void SecureBootEraseDrmKey(void)</p>
<p> {</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>270 android 动画 D 不见 修改</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/270%20android%20%E5%8A%A8%E7%94%BB%20D%20%E4%B8%8D%E8%A7%81%20%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>ro.sf.fakerotation=true</p>
<p>ro.sf.hwrotation=270</p>
<p>android 动画 D 不见 修改</p>
<p>diff –git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp<br>index d5ffacf..71fec48 100755<br>— a/services/surfaceflinger/DisplayDevice.cpp<br>+++ b/services/surfaceflinger/DisplayDevice.cpp<br>-110,8 +110,14 DisplayDevice::DisplayDevice(<br>mViewport.makeInvalid();<br>mFrame.makeInvalid(); </p>
<ul>
<li>mViewport.set(bounds());</li>
<li>mFrame.set(bounds());</li>
</ul>
<ul>
<li>if (mFlinger-&gt;orientationSwap()) {</li>
<li>mViewport.set(Rect(mDisplayHeight, mDisplayWidth));</li>
<li>mFrame.set(Rect(mDisplayHeight, mDisplayWidth));</li>
<li>} else {</li>
<li>mViewport.set(bounds());</li>
<li>mFrame.set(bounds());</li>
<li>}</li>
<li></li>
</ul>
<p>// virtual displays are always considered enabled<br>mScreenAcquired = (mType &gt;= DisplayDevice::DISPLAY_VIRTUAL); </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>3G常见问题</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/3G%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一、3G相关日志信息的获取</p>
<p>     1、使用串口捕捉LOG 信息：</p>
<p>          A、打开串口，输入：</p>
<p>               logcat –b radio &amp;</p>
<p>               logcat –s pppd CHAT &amp;</p>
<p>               此时串口屏幕上会不断打印出捕捉到的信息</p>
<p>          B、插入Dongle 或者开启modem，把出问题的流程走一遍</p>
<p>          C、把串口输出的信息保存成文件</p>
<p>      2、使用 adb工具捕捉LOG信息：</p>
<p>          A、打开adb shell： adb shell</p>
<p>          B、输入命令</p>
<p>               $ logcat –b radio &gt; /cache/radio.log &amp;</p>
<p>               $ logcat –s pppd CHAT &gt; /cache/pppd.log &amp;</p>
<p>               如果你有root 权限，还可以捕捉kernel的打印：</p>
<p>               # cat /proc/kmsg &gt; /cache/kernel.log &amp;</p>
<p>          C、插入 Dongle或者开启modem，把出问题的流程走一遍</p>
<p>          D、退出adb shell，把机器中的log 文件pull到本地</p>
<p>               $ exit</p>
<p>               adb pull /cache/*.log d:\</p>
<p>     3、使用 android应用捕捉LOG 信息，如aLogcat，请参考文档《通过alogcat 获取Radio日志信息.pdf》</p>
<p>二、3G无法使用(1) – 无法找到modem设备</p>
<p>3G出现问题，通常应先检查系统是否识别到了modem设备，可用如下命令确认：</p>
<p>     ls /dev/ttyU*</p>
<p>     或者</p>
<p>     ls /dev/ttyA*</p>
<p>如果在/dev下没有找到ttyU* 或者 ttyA* 设备，此时可通过观察内核LOG来定位问题：</p>
<p>     1. USB设备枚举失败或者系统根本就没有发现USB设备，此时应检查硬件电路</p>
<p>     2. USB枚举成功，但没有注册到ttyUSB或者ttyACM设备，此时应检查你的内核：</p>
<p>          a). 你的内核没有开启usb serial功能</p>
<p>          b). 你的内核代码中的usb serial相应驱动中没有添加该设备的VID/PID，请修改kernel/drivers/usb/serial/option.c，在数组static struct usb_device_id option_ids[] 的末尾添加上新设备的VID/PID</p>
<p>     3. USB枚举成功，且相关配置且ID都已添加，但还是不出来 ttyUSB或者ttyACM设备，此时可观察系统是否有对它执行usb mode switch，可通过logcat：</p>
<p>          # logcat –s Vold vold &amp;</p>
<p>        观察是否有调用了usb_modeswitch 程序，如果没有执行，则检查如下：</p>
<p>          a). 检查一些必要的文件是否存在：</p>
<p>               ls /system/bin/usb_modeswitch</p>
<p>               ls /etc/usb_modeswitch.sh</p>
<p>               ls /etc/usb_modeswitch.d/[VID_PID]  #[VID_PID]应替换成你的modem的VID/PID，如: 12d1_1001</p>
<p>          如果是缺少了usb_modeswitch、usb_modeswitch.sh等文件，则可能是你的gingerbread/device/rockchip/sdkDemo/BoardConfig.mk中的配置存在问题，请确认BOARD_RADIO_DATAONLY := true</p>
<p>          如果是缺少了/etc/usb_modeswitch.d/[VID_PID]，请告知我！</p>
<p>          b). VOLD中关于usb_modeswitch这部分的代码没有被编译，你可查看Vold的log中是否有“Start Misc devices Manager…”的字样，如果没有这串字符，请检查你的gingerbread/system/vold/下的内容。</p>
<p>通常，3G问题中，不出来ttyUSB或者ttyACM设备，主要就是上述的那些情况</p>
<p>三、3G无法使用(2) –有找到modem设备，但信号一直打叉</p>
<p>     当系统已经识别到你的modem，但状态栏上的信号图标却一直是打叉的，此时你应做如下检查：</p>
<p>     1. 先检查系统中的ril daemon是否已经正常启动。查看radio的LOG，若是不断打印字符串&quot;Do not switch user to radio&quot;，则可能是你的库的名称不对，请确定文件/default.prop中的&quot;rild.libpath=&quot;所指定的ril库与你实际使用的ril库是否一致，若不一致，请修改。例如：</p>
<p>          我在/default.prop中指定了使用的库是&quot;rild.libpath=/system/lib/libril-rk29-mid.so&quot;，但是我实际使用的RIL库是/system/lib/libril-rk29-dataonly.so，此时需要修改/default.prop的内容： &quot;rild.libpath=/system/lib/libril-rk29-dataonly.so&quot;</p>
<p>     2. 此modem在我们的系统中是否支持？这可以通过查看《3G_Support_List》，或者找下radio的LOG中是否有”Not support modem”的字样出现。如果检查的结果是不支持的modem，请联系我。</p>
<p>     3. 信号图标旁边出现一个SIM卡的图标，表示没有找到SIM卡或者SIM卡有问题，此时你应检查：</p>
<p>          a) SIM卡是否插正确</p>
<p>          b) 是否插入了不适合的SIM卡，比如你用的WCDMA modem，却插入了电信的SIM卡。</p>
<p>          c) SIM卡座是否出问题了？可联系硬件。</p>
<p>     4. 该SIM卡已经欠费停机，所以信号一直是打叉的。可联系当地客服咨询。</p>
<p>     5. Modem硬件出现问题，导致无法正常通信。此种情况可更换modem再行测试。可将LOG发给我。</p>
<p>四、3G无法使用(3) –有信号，但无法连接上数据网络。</p>
<p>     当系统已经识别到你的modem，且状态栏上的信号图标已经不再打叉了，说明你的modem已经初始化完成，但状态栏上没有出现新图标如”E”、”G”、”3G”等数据连接的图标，说明没有连接上数据网络，此时应做如下检查：</p>
<p>     1. 没有勾选上“已启用数据”，可从【设置】-&gt;【无线和网络】-&gt;【移动网络】，勾选【已启用数据】。</p>
<p>     2. 缺少拨号所需要的一些程序。可查看如下：</p>
<p>          ls /system/bin/pppd</p>
<p>          ls /system/bin/chat</p>
<p>          ls /etc/ppp/</p>
<p>               call-pppd</p>
<p>               ip-down</p>
<p>               ip-up</p>
<p>               ip-up-vpn</p>
<p>     3. kernel未开启ppp协议栈。可查看下系统中是否存在文件：/dev/ppp，如果没有这个文件，说明你的kernel没有开启ppp协议栈，请如下配置</p>
<p>           2011-8-5 11:21:56 上传下载附件 (88.32 KB) </p>
<p>PPP配置 </p>
<p>     4. PS服务（即数据业务）受限，导致无法上网。可先咨询客户看该SIM卡是否已开通数据业务，且是否已欠费。</p>
<p>     5. 缺少APN（Access Point Name），APN信息由各个运营商提供，目前在系统中默认放置的是中国大陆的运营商的APN，如果你要在其它国家或港/澳/台使用，需添加APN：</p>
<p>          a). 手动设置APN</p>
<p>               进入【设置】-&gt;【无线和网络】-&gt;【移动网络】-&gt;【接入点名称】，选择新建，然后手动填入APN的信息</p>
<p>          b). 添加默认APN</p>
<p>               修改文件 android/frameworks/base/core/res/res/xml/apns.xml，在其中添加APN，然后生成新固件</p>
<p>     通过以上步骤，若还是无法拨号成功，请发LOG给我</p>
<p>六、3G无法使用(5) –3G与WIFI/Ethernet的冲突</p>
<p>     有发现如下现象：当系统中开启了3G及wifi后，当Wifi连接成功后，3G的数据连接最终会被断开，这没有问题；但是，当把wifi、3G等网络设备全部关闭后，再次打开3G，发现3G在注册网络成功后，不会自动去拨号上网，而必须手动点击两次【设置】-&gt;【无线和网络】-&gt;【移动网络】-&gt;【已启用数据】，方能正常上网。</p>
<p>     修改代码：frameworks/base/telephony/java/com/android/internal/telephony/DataConnectionTracker.java</p>
<p>import java.util.ArrayList;</p>
<p>+/* BEGIN: Added by cmy, 2011/7/5 PN:[bug 110705001] */</p>
<p>+import android.content.Context;</p>
<p>+import android.net.IConnectivityManager;</p>
<p>+import android.os.ServiceManager;</p>
<p>+/* END: Added by cmy, 2011/7/5 PN:[bug 110705001] */</p>
<p>/**</p>
<ul>
<li>{@hide}</li>
</ul>
<p>*</p>
<p>@@ -297,6 +302,19 @@ public abstract class DataConnectionTracker extends Handler {</p>
<p>break;</p>
<p>case EVENT_RADIO_AVAILABLE:</p>
<ul>
<li><p>/* BEGIN: Added by cmy, 2011/7/5 PN:[bug 110705001] */</p>
</li>
<li><p>if (Settings.Secure.getInt(phone.getContext().getContentResolver(),</p>
</li>
<li><p>Settings.Secure.MOBILE_DATA, 1) == 1)</p>
</li>
<li><p>{</p>
</li>
<li><p>Settings.Secure.putInt(phone.getContext().getContentResolver(),</p>
</li>
<li><p>Settings.Secure.MOBILE_DATA, 0);</p>
</li>
<li><p>try {</p>
</li>
<li><p>IConnectivityManager.Stub.asInterface(ServiceManager.</p>
</li>
<li><p>getService(Context.CONNECTIVITY_SERVICE)).setMobileDataEnabled(true);</p>
</li>
<li><p>} catch (Exception e) {</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>/* END: Added by cmy, 2011/7/5 PN:[bug 110705001] */</p>
</li>
</ul>
<p>onRadioAvailable();</p>
<p>break;</p>
<p>     此BUG在补丁【rk29_gingerbread_3g_patch_20110628_v2】中已有修正。</p>
<p>七、使用3G的一些默认行为、以及如何修改</p>
<p>     1. 当系统中同时启用3G、WIFI时，默认优先使用WIFI连接，而原有的3G连接会被断开。如何改变它们的优先级？</p>
<p>          修改代码：frameworks/base/core/res/res/values/config.xml，其中红色数字便是优先级，数字越大，优先级超高</p>
<p>    &lt;!– An Array of &quot;[Connection name],[ConnectivityManager connection type],</p>
<p>         [associated radio-type],[priority]  –&gt;</p>
<p>    &lt;string-array translatable=&quot;false&quot; name=&quot;networkAttributes&quot;&gt;</p>
<p>        &lt;item&gt;&quot;wifi,1,1,1&quot;&lt;/item&gt;</p>
<p>        &lt;item&gt;&quot;mobile,0,0,0&quot;&lt;/item&gt;</p>
<p>        &lt;item&gt;&quot;mobile_mms,2,0,2&quot;&lt;/item&gt;</p>
<p>        &lt;item&gt;&quot;mobile_supl,3,0,2&quot;&lt;/item&gt;</p>
<p>        &lt;item&gt;&quot;mobile_hipri,5,0,3&quot;&lt;/item&gt;</p>
<p>        &lt;item&gt;&quot;eth,7,7,7&quot;&lt;/item&gt;</p>
<p>    &lt;/string-array&gt;</p>
<p>     2. 当3G打开后，系统会根据所注册的网络，自动切换系统的语言、时区等。不过，如果你曾经手动设置过系统的语言、时区等，则3G打开后不会自动切换它们。如何设置以保持系统的语言、时区不因3G而改变？</p>
<p>          修改代码：frameworks/base/telephony/java/com/android/internal/telephony/MccTable.java，</p>
<p>    public static void updateMccMncConfiguration(PhoneBase phone, String mccmnc) {</p>
<p>        if (!TextUtils.isEmpty(mccmnc)) {</p>
<p>            ……</p>
<p>            if (mcc != 0) {</p>
<p>                setTimezoneFromMccIfNeeded(phone, mcc); // 设置时区</p>
<p>                setLocaleFromMccIfNeeded(phone, mcc); // 设置语言</p>
<p>                setWifiChannelsFromMcc(phone, mcc); //设置Wifi频道</p>
<p>            }</p>
<p>            ……</p>
<p>        }</p>
<p>    }     </p>
<p>     3. 系统在首次连接上3G网络时，会因为设置默认APN的缘故，导致刚连接上网络后会自动断开并再次连接。还有，当你交替使用EVDO、WCDMA两种不同网络类型的modem时，也会出现这种现象。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.0%E4%BD%BF%E7%94%A8%E6%89%8B%E6%9C%BA%E8%B5%84%E6%BA%90%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%85%B3%E6%9C%BA%E7%95%8C%E9%9D%A2%EF%BC%8C%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>//注释tablet的判断，使用使用手机的资源文件</p>
<p>frameworks\base\services\java\com\android\server\wm\WindowManagerService.java     </p>
<p> //   if (SystemProperties.get(&quot;ro.build.characteristics&quot;,&quot;none&quot;).equals(&quot;tablet&quot;)</p>
<p>        //        &amp;&amp; sw &lt; 600) {</p>
<p>        //    sw = 600;</p>
<p>      //  }</p>
<p> //忽略tablet配置，按屏幕分辨率判断使用的资源</p>
<p> frameworks\base\policy\src\com\android\internal\policy\impl\PhoneWindowManager.java</p>
<p>     // if (SystemProperties.get(&quot;ro.build.characteristics&quot;,&quot;none&quot;).equals(&quot;tablet&quot;)) {</p>
<p>       //   mStatusBarCanHide = false;</p>
<p>      // } else {</p>
<p>            mStatusBarCanHide = shortSizeDp &lt; 600;</p>
<p>     //}</p>
<p>//长按电源键，直接弹出关机界面   //在frameworks\base\core\res\res\values config.xml也可以设置</p>
<p>                 case LONG_PRESS_POWER_GLOBAL_ACTIONS:</p>
<p>                mPowerKeyHandled = true;</p>
<p>                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);</p>
<p>                sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</p>
<p>                //showGlobalActionsDialog();</p>
<p>                 ShutdownThread.shutdown(mContext, true);</p>
<p>     //核心服务的配置信息</p>
<p>frameworks\base\core\res\res\values config.xml</p>
<p>//全方向转动</p>
<p>    &lt;bool name=&quot;config_allowAllRotations&quot;&gt;true&lt;/bool&gt;</p>
<p>//使桌面锁可以转动</p>
<p>&lt;bool name=&quot;config_enableLockScreenRotation&quot;&gt;true&lt;/bool&gt;</p>
<p>     //显示导航栏</p>
<p>     &lt;bool name=&quot;config_showNavigationBar&quot;&gt;true&lt;/bool&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.1%20%E6%9C%80%E8%BF%91%E5%BA%94%E7%94%A8%E5%88%97%E8%A1%A8%20%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<p>frameworks/base/packages/SystemUI/res/layout/system_bar_recent_panel.xml</p>
<p>     &lt;FrameLayout</p>
<p>         android:id=&quot;@+id/recents_bg_protect&quot;</p>
<ul>
<li>       android:background=&quot;@drawable/recents_bg_protect_tile&quot;</li>
</ul>
<ul>
<li>       android:background=&quot;@android:color/transparent&quot;</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.1%20%E7%8A%B6%E6%80%81%E6%A0%8F%20systembar/</url>
    <content><![CDATA[<p>系统条的布局</p>
<p>frameworks/base/packages/SystemUI/res/layout/system_bar.xml</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.2%20Laucher2%E5%8E%BB%E6%8E%89%E4%B8%A4%E8%BE%B9%E9%98%B4%E5%BD%B1/</url>
    <content><![CDATA[<p>必须两步同时修改：</p>
<p>1.在launcher布局中去掉android:background=&quot;@drawable/workspace_bg</p>
<p>packages/apps/Launcher2/res/layout-port/launcher.xml</p>
<p>packages/apps/Launcher2/res/layout-land/launcher.xml</p>
<p>2.packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p> private void setWorkspaceBackground(boolean workspace) {</p>
<p>   //    mLauncherView.setBackground(workspace ?</p>
<p>    //            mWorkspaceBackgroundDrawable : mBlackBackgroundDrawable);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.2%20phonestatusbar%20%E7%8A%B6%E6%80%81%E6%A0%8F%E6%A0%87%E9%A2%98%E6%98%BE%E7%A4%BA100%25%E7%99%BE%E5%88%86%E6%AF%94/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/packages/SystemUI/res/layout/status_bar.xml b/frameworks/base/packages/SystemUI/res/layout/status_bar.xml</p>
<p>index bf20e9d..c686e95 100644</p>
<p>— a/frameworks/base/packages/SystemUI/res/layout/status_bar.xml</p>
<p>+++ b/frameworks/base/packages/SystemUI/res/layout/status_bar.xml</p>
<p>@@ -100,7 +100,17 @@</p>
<p>                     android:layout_height=&quot;wrap_content&quot;</p>
<p>                     android:layout_width=&quot;wrap_content&quot;</p>
<p>                     android:paddingLeft=&quot;4dip&quot;</p>
<ul>
<li>                   /&gt;</li>
</ul>
<ul>
<li><p>                  /&gt;</p>
</li>
<li><p>              &lt;TextView</p>
</li>
<li><p>               android:id=&quot;@+id/battery_text&quot;</p>
</li>
<li><p>               android:textAppearance=&quot;@style/TextAppearance.StatusBar.Clock&quot;</p>
</li>
<li><p>               android:layout_width=&quot;wrap_content&quot;</p>
</li>
<li><p>               android:layout_height=&quot;wrap_content&quot;</p>
</li>
<li><p>               android:layout_gravity=&quot;left|center_vertical&quot;</p>
</li>
<li><p>               android:paddingRight=&quot;2dp&quot;</p>
</li>
<li><p>               android:singleLine=&quot;true&quot;</p>
</li>
<li><p>               android:text=&quot;@string/status_bar_settings_settings_button&quot;</p>
</li>
<li><p>               /&gt;</p>
</li>
</ul>
<p>             &lt;/LinearLayout&gt;</p>
<p>             &lt;com.android.systemui.statusbar.policy.Clock</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/stat</p>
<p>index 7f92e75..4513a3b 100755</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java</p>
<p>@@ -629,6 +629,7 @@ public class PhoneStatusBar extends BaseStatusBar {</p>
<p>         mLocationController = new LocationController(mContext); // will post a notification</p>
<p>         mBatteryController = new BatteryController(mContext);</p>
<p>         mBatteryController.addIconView((ImageView)mStatusBarView.findViewById(R.id.battery));</p>
<ul>
<li>              mBatteryController.addLabelView((TextView)mStatusBarView.findViewById(R.id.battery_text));</li>
</ul>
<p>         mNetworkController = new NetworkController(mContext);</p>
<p>         mBluetoothController = new BluetoothController(mContext);</p>
<p>         final SignalClusterView signalCluster =</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.2%20tablet%20%E7%8A%B6%E6%80%81%E6%A0%8F%20%E5%B9%BF%E5%91%8A%20%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<p>1.修改背景</p>
<p>device/rockchip/rk30sdk/overlay/frameworks/base/packages/SystemUI/res/layout-sw480dp/system_bar.xml</p>
<ul>
<li>   android:background=&quot;@drawable/statubarbg&quot;</li>
</ul>
<ul>
<li>   android:background=&quot;@drawable/system_bar_background&quot;</li>
</ul>
<p>2.增加TextView广告</p>
<p>可以加在导航栏navigationArea这边</p>
<p>device/rockchip/rk30sdk/overlay/frameworks/base/packages/SystemUI/res/layout-sw480dp/system_bar.xml</p>
<p>也可以加到system_bar_notification_area这边</p>
<p>frameworks/base/packages/SystemUI/res/layout/system_bar_notification_area.xml</p>
<p>@@ -78,6 +78,18 @@</p>
<p>         android:layout_height=&quot;match_parent&quot;</p>
<p>         android:gravity=&quot;center&quot;</p>
<p>         &gt;</p>
<p>+</p>
<ul>
<li><p>       &lt;TextView</p>
</li>
<li><p>              android:text=&quot;@string/ad_num&quot;</p>
</li>
<li><p>              android:layout_width=&quot;wrap_content&quot;</p>
</li>
<li><p>              android:layout_height=&quot;wrap_content&quot;</p>
</li>
<li><p>              android:visibility=&quot;visible&quot;</p>
</li>
<li><p>              android:textSize=&quot;20sp&quot;</p>
</li>
<li><p>              android:layout_alignParentRight=&quot;true&quot;</p>
</li>
<li><p>              android:paddingRight=&quot;80dp&quot;</p>
</li>
<li><p>              android:gravity=&quot;center&quot;</p>
</li>
<li><p>       /&gt;</p>
</li>
</ul>
<p>+</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.2%20tablet%20ui%20%20%E5%8F%91%E9%80%9A%E7%9F%A5%20%E9%9A%90%E8%97%8F%E7%8A%B6%E6%80%81%E6%A0%8FStatusBar/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/DelegateViewHelper.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/status</p>
<p>index 3ac1bcf..31a1301 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/DelegateViewHelper.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/DelegateViewHelper.java</p>
<p>@@ -48,6 +48,7 @@ public class DelegateViewHelper {</p>
<p>     }</p>
<p>     public boolean onInterceptTouchEvent(MotionEvent event) {</p>
<ul>
<li>              if(mBar==null) return false;</li>
</ul>
<p>         if (mSourceView == null || mDelegateView == null</p>
<p>                 || mBar.shouldDisableNavbarGestures()) {</p>
<p>             return false;</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/NotificationPanel.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/</p>
<p>index 5e290c6..a2ae45c 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/NotificationPanel.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/NotificationPanel.java</p>
<p>@@ -447,7 +447,7 @@ public class NotificationPanel extends RelativeLayout implements StatusBarPanel,</p>
<p>     public void setSettingsEnabled(boolean settingsEnabled) {</p>
<p>         if (mSettingsButton != null) {</p>
<p>             mSettingsButton.setEnabled(settingsEnabled);</p>
<ul>
<li>           mSettingsButton.setVisibility(settingsEnabled ? View.VISIBLE : View.GONE);</li>
</ul>
<ul>
<li>           //mSettingsButton.setVisibility(settingsEnabled ? View.VISIBLE : View.GONE);</li>
</ul>
<p>         }</p>
<p>     }</p>
<p> }</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/st</p>
<p>index fe42a4d..b7358ce 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>@@ -235,7 +235,7 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>     private void addStatusBarWindow() {</p>
<p>         final View sb = makeStatusBarView();</p>
<p>-</p>
<p>+</p>
<p>         final WindowManager.LayoutParams lp = new WindowManager.LayoutParams(</p>
<p>                 ViewGroup.LayoutParams.MATCH_PARENT,</p>
<p>                 ViewGroup.LayoutParams.MATCH_PARENT,</p>
<p>@@ -256,6 +256,23 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>         mWindowManager.addView(sb, lp);</p>
<p>     }</p>
<p>+</p>
<ul>
<li><p>      public void showStatusBarBar() {</p>
</li>
<li><p>              if(mStatusBarView == null){</p>
</li>
<li><p>        addStatusBarWindow() ;</p>
</li>
<li><p>               }</p>
</li>
<li><p>   }</p>
</li>
</ul>
<p>+</p>
<ul>
<li>   public void hideStatusBarBar() {</li>
</ul>
<p>+</p>
<ul>
<li><p>       if ( mStatusBarView != null) {</p>
</li>
<li><p>           mWindowManager.removeView(mStatusBarView);</p>
</li>
<li><p>       }</p>
</li>
<li><p>       mStatusBarView = null;</p>
</li>
<li><p>   }</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<p>+</p>
<p>     protected void addPanelWindows() {</p>
<p>         final Context context = mContext;</p>
<p>         final Resources res = mContext.getResources();</p>
<p>@@ -404,6 +421,8 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>     @Override</p>
<p>     protected void onConfigurationChanged(Configuration newConfig) {</p>
<p>+</p>
<ul>
<li>    if (mStatusBarView != null){</li>
</ul>
<p>         loadDimens();</p>
<p>                if(&quot;true&quot;.equals(isEnableShowVoiceIcon)){</p>
<p>                        if ((mDisabled &amp; (StatusBarManager.DISABLE_RECENT</p>
<p>@@ -434,6 +453,7 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>             mStatusBarView.invalidate();</p>
<p>             mWindowManager.updateViewLayout(mStatusBarView, lp);</p>
<p>         }</p>
<ul>
<li>              }</li>
</ul>
<p>     }</p>
<p>     protected void loadDimens() {</p>
<p>@@ -494,6 +514,7 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>         IntentFilter intentfilter=new IntentFilter();</p>
<p>         intentfilter.addAction(&quot;rk.android.screenshot.SHOW&quot;);</p>
<p>         intentfilter.addAction(&quot;rk.android.screenshot.ACTION&quot;);</p>
<ul>
<li>              intentfilter.addAction(&quot;bx.android.statusbar.SHOW&quot;);</li>
</ul>
<p>         context.registerReceiver(receiver, intentfilter);</p>
<p>         loadDimens();</p>
<p>@@ -900,11 +921,13 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>                     break;</p>
<p>                 case MSG_SHOW_CHROME:</p>
<p>                     if (DEBUG) Slog.d(TAG, &quot;hiding shadows (lights on)&quot;);</p>
<ul>
<li>                                      if(mStatusBarView != null){</li>
</ul>
<p>                     mBarContents.setVisibility(View.VISIBLE);</p>
<p>                     mShadow.setVisibility(View.GONE);</p>
<p>                     mSystemUiVisibility &amp;= ~View.SYSTEM_UI_FLAG_LOW_PROFILE;</p>
<p>                     mStatusBarView.setVisibility(View.VISIBLE);</p>
<p>                     notifyUiVisibilityChanged();</p>
<ul>
<li>                                      }</li>
</ul>
<p>                     break;</p>
<p>                 case MSG_HIDE_CHROME:</p>
<p>                     if (DEBUG) Slog.d(TAG, &quot;showing shadows (lights out)&quot;);</p>
<p>@@ -913,11 +936,13 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>                     mBarContents.setVisibility(View.GONE);</p>
<p>                     mShadow.setVisibility(View.VISIBLE);</p>
<p>                     mSystemUiVisibility |= View.SYSTEM_UI_FLAG_LOW_PROFILE;</p>
<ul>
<li>                                      if(mStatusBarView != null){</li>
</ul>
<p>                     if (HIDE_TABLET_STATUSBAR) {</p>
<p>                         mStatusBarView.setVisibility(View.GONE);</p>
<p>                     } else {</p>
<p>                         mStatusBarView.setVisibility(View.VISIBLE);</p>
<p>                     }</p>
<ul>
<li>                                      }</li>
</ul>
<p>                     notifyUiVisibilityChanged();</p>
<p>                     break;</p>
<p>                 case MSG_STOP_TICKER:</p>
<p>@@ -1077,6 +1102,7 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>         // until status bar window is attached to the window manager,</p>
<p>         // because…  well, what’s the point otherwise?  And trying to</p>
<p>         // run a ticker without being attached will crash!</p>
<ul>
<li>              if(mStatusBarView!=null){</li>
</ul>
<p>         if (hasTicker(n.notification) &amp;&amp; mStatusBarView.getWindowToken() != null) {</p>
<p>             if (0 == (mDisabled &amp; (StatusBarManager.DISABLE_NOTIFICATION_ICONS</p>
<p>                             | StatusBarManager.DISABLE_NOTIFICATION_TICKER))) {</p>
<p>@@ -1084,6 +1110,7 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>                 mFeedbackIconArea.setVisibility(View.GONE);</p>
<p>             }</p>
<p>         }</p>
<ul>
<li>              }</li>
</ul>
<p>     }</p>
<p>     // called by TabletTicker when it’s done with all queued ticks</p>
<p>@@ -1180,7 +1207,7 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>             }</p>
<p>             mHandler.sendEmptyMessage((lp != 0 || fs != 0) ? MSG_HIDE_CHROME : MSG_SHOW_CHROME);</p>
<ul>
<li>           // }</li>
</ul>
<p>+</p>
<p>             notifyUiVisibilityChanged();</p>
<p>         }</p>
<p>     }</p>
<p>@@ -1423,7 +1450,7 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>                 public void onReceive(Context context, Intent intent) {</p>
<p>                         // TODO Auto-generated method stub</p>
<p>                         String action=intent.getAction();</p>
<ul>
<li>                       Log.d(&quot;screenshot&quot;,action);</li>
</ul>
<ul>
<li>                       //Log.d(&quot;screenshot&quot;,action);</li>
</ul>
<p>                         if(action.equals(&quot;rk.android.screenshot.SHOW&quot;)){</p>
<p>                         boolean show=intent.getBooleanExtra(&quot;show&quot;, false);</p>
<p>                          if(show){</p>
<p>@@ -1434,9 +1461,17 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>                                 mScreenShotButton.setVisibility(View.GONE);</p>
<p>                          }</p>
<ul>
<li>                       }else{</li>
</ul>
<ul>
<li>                       }else if(action.equals(&quot;rk.android.screenshot.ACTION&quot;)){</li>
</ul>
<p>                             takeScreenshot();</p>
<ul>
<li>                       }</li>
</ul>
<ul>
<li><p>                       }else if(action.equals(&quot;bx.android.statusbar.SHOW&quot;)){</p>
</li>
<li><p>                                                      boolean showbar = intent.getBooleanExtra(&quot;show&quot;, true);</p>
</li>
<li><p>                                                      //Log.d(&quot;edward&quot;,&quot;statusbar show? =:&quot;+ showbar);</p>
</li>
<li><p>                                                      if(showbar){</p>
</li>
<li><p>                                                      showStatusBarBar() ;</p>
</li>
<li><p>                                                      }else{</p>
</li>
<li><p>                                                      hideStatusBarBar() ;</p>
</li>
<li><p>                                                      }</p>
</li>
<li><p>                                              }</p>
</li>
</ul>
<p>                 }</p>
<p>         };</p>
<p>     public void onClickRecentButton() {</p>
<p>@@ -1565,6 +1600,7 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>         // to avoid removing &amp; readding everything</p>
<p>         if (mIconLayout == null) return;</p>
<ul>
<li>              if(mStatusBarView == null) return;</li>
</ul>
<p>         // first, populate the main notification panel</p>
<p>         loadNotificationPanel();</p>
<p>@@ -1640,13 +1676,18 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>             mIconLayout.removeView(remove);</p>
<p>         }</p>
<ul>
<li>              try{</li>
</ul>
<p>         for (int i=0; i&lt;toShow.size(); i++) {</p>
<p>             View v = toShow.get(i);</p>
<p>             v.setPadding(mIconHPadding, 0, mIconHPadding, 0);</p>
<p>             if (v.getParent() == null) {</p>
<ul>
<li>               mIconLayout.addView(v, i, params);</li>
</ul>
<ul>
<li>               mIconLayout.addView(v, i, params);  //IndexOutOfBoundsException</li>
</ul>
<p>             }</p>
<p>         }</p>
<ul>
<li><p>              }catch(Exception ex){</p>
</li>
<li><p>                      Log.d(&quot;edward&quot;,ex.toString());</p>
</li>
<li><p>                      return ;</p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>         if(toShow.size()&gt;0)</p>
<p>         {</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.2%20%E7%8A%B6%E6%80%81%E6%A0%8F%E6%97%B6%E9%97%B4am%20pm/</url>
    <content><![CDATA[<p>frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\policy\Clock.java</p>
<p>private static final int AM_PM_STYLE_NORMAL  = 0;</p>
<p>    private static final int AM_PM_STYLE_SMALL   = 1;</p>
<p>    private static final int AM_PM_STYLE_GONE    = 2;</p>
<p>    private static final int AM_PM_STYLE = AM_PM_STYLE_NORMAL;//AM_PM_STYLE_GONE;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.2%20%E8%A7%A3%E9%94%81%E6%97%B6%E9%92%9F%E6%A1%86%20%E7%84%A6%E7%82%B9/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardWidgetFrame.java b/frameworks/base/policy/src/com/android/internal/policy/impl/keyg</p>
<p>index babb9cb..550a793 100644</p>
<p>— a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardWidgetFrame.java</p>
<p>+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardWidgetFrame.java</p>
<p>@@ -236,7 +236,7 @@ public class KeyguardWidgetFrame extends FrameLayout {</p>
<p>         if (ENABLE_HOVER_OVER_DELETE_DROP_TARGET_OVERLAY) {</p>
<p>             canvas.save();</p>
<p>         }</p>
<ul>
<li>       drawBg(canvas);</li>
</ul>
<ul>
<li>       //drawBg(canvas);</li>
</ul>
<p>         super.dispatchDraw(canvas);</p>
<p>         drawGradientOverlay(canvas);</p>
<p>         if (ENABLE_HOVER_OVER_DELETE_DROP_TARGET_OVERLAY) {</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.4%20%E5%8E%BB%E6%8E%89%E7%94%A8%E6%88%B7%E5%A4%B4%E5%83%8F%20systemui/</url>
    <content><![CDATA[<p>diff –git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettings.java b/packages/SystemUI/src/com/android/systemui/st</p>
<p>index c37978a..10b4f18 100644</p>
<p>— a/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettings.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettings.java</p>
<p>@@ -270,7 +270,7 @@ class QuickSettings {</p>
<p>         addSystemTiles(mContainerView, inflater);</p>
<p>         addTemporaryTiles(mContainerView, inflater);</p>
<ul>
<li>       queryForUserInformation();</li>
</ul>
<ul>
<li>       //queryForUserInformation();</li>
</ul>
<p>         queryForSslCaCerts();</p>
<p>         mTilesSetUp = true;</p>
<p>     }</p>
<p>@@ -301,6 +301,7 @@ class QuickSettings {</p>
<p>     }</p>
<p>     private void addUserTiles(ViewGroup parent, LayoutInflater inflater) {</p>
<ul>
<li>      /*</li>
</ul>
<p>         QuickSettingsTileView userTile = (QuickSettingsTileView)</p>
<p>                 inflater.inflate(R.layout.quick_settings_tile, parent, false);</p>
<p>         userTile.setContent(R.layout.quick_settings_tile_user, inflater);</p>
<p>@@ -344,7 +345,7 @@ class QuickSettings {</p>
<p>             }</p>
<p>         });</p>
<p>         parent.addView(userTile);</p>
<ul>
<li>       mDynamicSpannedTiles.add(userTile);</li>
</ul>
<ul>
<li>       mDynamicSpannedTiles.add(userTile); */</li>
</ul>
<p>         // Brightness</p>
<p>         final QuickSettingsBasicTile brightnessTile</p>
<p>@@ -868,10 +869,10 @@ class QuickSettings {</p>
<p>                 mBluetoothState.connected = (status == BluetoothAdapter.STATE_CONNECTED);</p>
<p>                 applyBluetoothStatus();</p>
<p>             } else if (Intent.ACTION_USER_SWITCHED.equals(action)) {</p>
<ul>
<li>               reloadUserInfo();</li>
</ul>
<ul>
<li>               //reloadUserInfo();</li>
</ul>
<p>             } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {</p>
<p>                 if (mUseDefaultAvatar) {</p>
<ul>
<li>                   queryForUserInformation();</li>
</ul>
<ul>
<li>                  // queryForUserInformation();</li>
</ul>
<p>                 }</p>
<p>             } else if (KeyChain.ACTION_STORAGE_CHANGED.equals(action)) {</p>
<p>                 queryForSslCaCerts();</p>
<p>@@ -890,7 +891,7 @@ class QuickSettings {</p>
<p>                     final int changedUser =</p>
<p>                             intent.getIntExtra(Intent.EXTRA_USER_HANDLE, getSendingUserId());</p>
<p>                     if (changedUser == currentUser) {</p>
<ul>
<li>                       reloadUserInfo();</li>
</ul>
<ul>
<li>                       //reloadUserInfo();</li>
</ul>
<p>                     }</p>
<p>                 } catch (RemoteException e) {</p>
<p>                     Log.e(TAG, &quot;Couldn’t get current user id for profile change&quot;, e);</p>
<p>(END)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.4%20%E7%94%B5%E6%B1%A0%E5%9B%BE%E6%A0%87%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>diff –git a/packages/SystemUI/res/values/arrays.xml b/packages/SystemUI/res/values/arrays.xml</p>
<p>index bfb600d..48b8906 100644</p>
<p>— a/packages/SystemUI/res/values/arrays.xml</p>
<p>+++ b/packages/SystemUI/res/values/arrays.xml</p>
<p>@@ -47,9 +47,9 @@</p>
<p>         &lt;item&gt;100&lt;/item&gt;</p>
<p>     &lt;/array&gt;</p>
<p>     &lt;array name=&quot;batterymeter_color_values&quot;&gt;</p>
<ul>
<li><p>       &lt;item&gt;#FFFF3300&lt;/item&gt;</p>
</li>
<li><p>       &lt;item&gt;#FFFF3300&lt;/item&gt;</p>
</li>
<li><p>       &lt;item&gt;#FFFFFFFF&lt;/item&gt;</p>
</li>
</ul>
<ul>
<li><p>       &lt;item&gt;#FF493EDA&lt;/item&gt;</p>
</li>
<li><p>       &lt;item&gt;#FF3225D9&lt;/item&gt;</p>
</li>
<li><p>       &lt;item&gt;#FF0000FF&lt;/item&gt;</p>
</li>
</ul>
<p>     &lt;/array&gt;</p>
<p>     &lt;array name=&quot;batterymeter_bolt_points&quot;&gt;</p>
<p>         &lt;item&gt;73&lt;/item&gt; &lt;item&gt;0&lt;/item&gt;</p>
<p>diff –git a/packages/SystemUI/res/values/colors.xml b/packages/SystemUI/res/values/colors.xml</p>
<p>index 0bbdead..1cd290d 100644</p>
<p>— a/packages/SystemUI/res/values/colors.xml</p>
<p>+++ b/packages/SystemUI/res/values/colors.xml</p>
<p>@@ -33,7 +33,7 @@</p>
<p>     &lt;drawable name=&quot;notification_header_bg&quot;&gt;#FF000000&lt;/drawable&gt;</p>
<p>     &lt;color name=&quot;notification_panel_scrim_color&quot;&gt;#B0000000&lt;/color&gt;</p>
<p>     &lt;color name=&quot;batterymeter_frame_color&quot;&gt;#66FFFFFF&lt;/color&gt;&lt;!– 40% white –&gt;</p>
<ul>
<li><p>   &lt;color name=&quot;batterymeter_charge_color&quot;&gt;#FFFFFFFF&lt;/color&gt;</p>
</li>
<li><p>   &lt;color name=&quot;batterymeter_bolt_color&quot;&gt;#B2000000&lt;/color&gt;&lt;!– 70% black –&gt;</p>
</li>
</ul>
<ul>
<li><p>   &lt;color name=&quot;batterymeter_charge_color&quot;&gt;#FF00FF00&lt;/color&gt;</p>
</li>
<li><p>   &lt;color name=&quot;batterymeter_bolt_color&quot;&gt;#FFFF0000&lt;/color&gt;&lt;!– 70% black –&gt;</p>
</li>
</ul>
<p>     &lt;color name=&quot;status_bar_clock_color&quot;&gt;#FFFFFFFF&lt;/color&gt;</p>
<p> &lt;/resources&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/4.4%20%E9%94%81%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<p>keyguard_glow_pad_view.xml</p>
<p>&lt;com.android.internal.widget.multiwaveview.GlowPadView</p>
<p>    xmlns:prvandroid=&quot;<a href="http://schemas.android.com/apk/prv/res/android">http://schemas.android.com/apk/prv/res/android</a>&quot;</p>
<p>    xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;</p>
<p>    android:id=&quot;@+id/glow_pad_view&quot;</p>
<p>    android:layout_width=&quot;wrap_content&quot;</p>
<p>    android:layout_height=&quot;wrap_content&quot;</p>
<p>    android:layout_gravity=&quot;center&quot;</p>
<p>    android:orientation=&quot;horizontal&quot;</p>
<p>    android:gravity=&quot;@integer/kg_selector_gravity&quot;</p>
<p>    android:contentDescription=&quot;@string/keyguard_accessibility_slide_area&quot;</p>
<p>    prvandroid:targetDrawables=&quot;@array/lockscreen_targets_unlock_only&quot;</p>
<p>    prvandroid:targetDescriptions=&quot;@array/lockscreen_target_descriptions_unlock_only&quot;</p>
<p>    prvandroid:directionDescriptions=&quot;@array/lockscreen_direction_descriptions&quot;</p>
<p>    prvandroid:handleDrawable=&quot;@drawable/ic_lockscreen_handle&quot;</p>
<p>packages/Keyguard/res/drawable-sw600dp-hdpi/ic_lockscreen_handle_normal.png</p>
<p>packages/Keyguard/res/drawable-sw600dp-hdpi/ic_lockscreen_unlock_activated.png</p>
<p>packages/Keyguard/res/drawable-sw600dp-hdpi/ic_lockscreen_unlock_normal.png</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>5</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/5.1%20SIM,%203G%20dongle%E6%98%BE%E7%A4%BA%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>packages/Keyguard/src/com/android/keyguard/CarrierText.java</p>
<p>@@ -147,7 +147,7 @@ public class CarrierText extends TextView {</p>
<p>                         getContext().getText(R.string.keyguard_missing_sim_message_short), text);</p>
<p>             }</p>
<p>         }</p>
<ul>
<li>       setText(displayText);</li>
</ul>
<ul>
<li>       setText(&quot;&quot;);//displayText</li>
</ul>
<p>SIM, 3G dongle显示符号问题</p>
<p>packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTileForSlot.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTileForSlot.java</p>
<p>@@ -92,7 +92,7 @@ public class CellularTileForSlot extends QSTile&lt;QSTile.SignalState&gt; {</p>
<p>     @Override</p>
<p>     protected void handleUpdateState(SignalState state, Object arg) {</p>
<ul>
<li>       state.visible = mController.hasMobileDataFeature();</li>
</ul>
<ul>
<li>       state.visible = false;//mController.hasMobileDataFeature();</li>
</ul>
<p>         if (!state.visible) return;</p>
<p>         final CallbackInfo cb = (CallbackInfo) arg;</p>
<p>         if (cb == null) return;</p>
<p>diff –git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/Networ</p>
<p>index 7cff4a1..7f84b6d 100644</p>
<p>— a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java</p>
<p>@@ -470,7 +470,7 @@ public class NetworkControllerImpl extends BroadcastReceiver</p>
<p>     @VisibleForTesting</p>
<p>     protected void updateNoSims() {</p>
<ul>
<li>       boolean hasNoSims = mHasMobileDataFeature &amp;&amp; mMobileSignalControllers.size() == 0;</li>
</ul>
<ul>
<li>       boolean hasNoSims = false ;//mHasMobileDataFeature &amp;&amp; mMobileSignalControllers.size() == 0;</li>
</ul>
<p>         if (hasNoSims) {</p>
<p>             // Boot up camp NW performance:</p>
<p>             // if hasSims but subInfo not ready yet, mMobileSignalControllers.size() == 0 but hasIccCard.</p>
<p>@@ -1673,7 +1673,7 @@ public class NetworkControllerImpl extends BroadcastReceiver</p>
<p>             if (mCurrentState.connected) {</p>
<p>                 return getIcons().mSbIcons[mCurrentState.inetCondition][mCurrentState.level];</p>
<p>             } else if (mCurrentState.enabled) {</p>
<ul>
<li>               return getIcons().mSbDiscState;</li>
</ul>
<ul>
<li>               return getIcons().mSbNullState;</li>
</ul>
<p>             } else {</p>
<p>                 return getIcons().mSbNullState;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>5</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/5.1%20%E9%94%81%E7%95%8C%E9%9D%A2%20%E9%94%81%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<p>diff –git a/packages/SystemUI/res/values/dimens.xml b/packages/SystemUI/res/values/dimens.xml</p>
<p>index 44330e8..e18eb8f 100644</p>
<p>— a/packages/SystemUI/res/values/dimens.xml</p>
<p>+++ b/packages/SystemUI/res/values/dimens.xml</p>
<p>@@ -478,12 +478,12 @@</p>
<p>     &lt;dimen name=&quot;search_panel_threshold&quot;&gt;100dp&lt;/dimen&gt;</p>
<p>     &lt;!– The width/height of the phone/camera/unlock icon view on keyguard. –&gt;</p>
<ul>
<li><p>   &lt;dimen name=&quot;keyguard_affordance_height&quot;&gt;56dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;keyguard_affordance_width&quot;&gt;56dp&lt;/dimen&gt;</p>
</li>
</ul>
<ul>
<li><p>   &lt;dimen name=&quot;keyguard_affordance_height&quot;&gt;80dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;keyguard_affordance_width&quot;&gt;80dp&lt;/dimen&gt;</p>
</li>
</ul>
<p>     &lt;!– The width/height of the phone/camera/unlock icon drawable on keyguard. –&gt;</p>
<ul>
<li><p>   &lt;dimen name=&quot;keyguard_affordance_icon_height&quot;&gt;24dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;keyguard_affordance_icon_width&quot;&gt;24dp&lt;/dimen&gt;</p>
</li>
</ul>
<ul>
<li><p>   &lt;dimen name=&quot;keyguard_affordance_icon_height&quot;&gt;64dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;keyguard_affordance_icon_width&quot;&gt;64dp&lt;/dimen&gt;</p>
</li>
</ul>
<p>     &lt;dimen name=&quot;keyguard_indication_margin_bottom&quot;&gt;65dp&lt;/dimen&gt;</p>
<p>diff –git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java b/packages/SystemUI/src/com/android/s</p>
<p>index 0c21b20..8834cbe 100644</p>
<p>— a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java</p>
<p>@@ -396,10 +396,10 @@ public class KeyguardBottomAreaView extends FrameLayout implements View.OnClickL</p>
<p>             return;</p>
<p>         }</p>
<p>         // TODO: Real icon for facelock.</p>
<ul>
<li>       int iconRes = mUnlockMethodCache.isFaceUnlockRunning()</li>
</ul>
<ul>
<li>       int iconRes = R.drawable.ic_lockscre; /*mUnlockMethodCache.isFaceUnlockRunning()</li>
</ul>
<p>                 ? com.android.internal.R.drawable.ic_account_circle</p>
<p>                 : mUnlockMethodCache.isCurrentlyInsecure() ? R.drawable.ic_lock_open_24dp</p>
<ul>
<li>               : R.drawable.ic_lock_24dp;</li>
</ul>
<ul>
<li>               : R.drawable.ic_lock_24dp;*/</li>
</ul>
<p>         if (mLastUnlockIconRes != iconRes) {</p>
<p>             Drawable icon = mContext.getDrawable(iconRes);</p>
<p>             int iconHeight = getResources().getDimensionPixelSize(</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>512MB  camera2</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/512MB%20%20camera2/</url>
    <content><![CDATA[<p>src/com/android/camera/WideAnglePanoramaModule.java</p>
<p>@@ -380,6 +380,10 @@ public class WideAnglePanoramaModule</p>
<p>             if (need4To3 &amp;&amp; (h * 4 != w * 3)) {</p>
<p>                 continue;</p>
<p>             }</p>
<p>+</p>
<ul>
<li><p>if(h &gt; 480)// no bigger preview than 480x for 512MB ddr</p>
</li>
<li><p>continue;</p>
</li>
</ul>
<p>+</p>
<p>             d = Math.abs(d);</p>
<p>             if (d &lt; pixelsDiff) {</p>
<p>                 mCameraPreviewWidth = w;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>64bit 编译android4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/64bit%20%E7%BC%96%E8%AF%91android4.0%20%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>frameworks/compile/slang/slang_rs_export_foreach.cpp:247:23: error: variable ‘ParamName’ set but not used [-Werror=unused-but-set-variable] <br>解决办法： <br>vim frameworks/compile/slang/Android.mk <br>把： <br>local_cflags_for_slang := -Wno-sign-promo -Wall -Wno-unused-parameter -Werror <br>改为： <br>local_cflags_for_slang := -Wno-sign-promo -Wall -Wno-unused-parameter <br>参考：<a href="http://code.google.com/p/android/issues/detail?id=22006#c0">http://code.google.com/p/android/issues/detail?id=22006#c0</a> <br>参考：<a href="http://groups.google.com/group/android-building/browse_thread/thread/0207abb98ed72304">http://groups.google.com/group/android-building/browse_thread/thread/0207abb98ed72304</a>  </p>
<p>external/mesa3d/src/glsl/linker.cpp: 在函数‘void assign_varying_locations(gl_shader_program*, gl_shader*, gl_shader*)’中: <br>external/mesa3d/src/glsl/linker.cpp:1394:49: 错误： expected primary-expression before ‘,’ token <br>external/mesa3d/src/glsl/linker.cpp:1394:50: 错误： ‘varyings’在此作用域中尚未声明 <br>…<br>解决方法： <br>vim external/mesa3d/src/glsl/linker.cpp <br>添加： <br>#include &lt;cstddef&gt; </p>
<p>In file included from external/oprofile/libpp/arrange_profiles.cpp:24:0: <br>external/oprofile/libpp/format_output.h:94:22: error: reference ‘counts’ cannot be declared ‘mutable’ [-fpermissive] <br>make: *** [out/host/linux-x86/obj/STATIC_LIBRARIES/liboprofile_pp_intermediates/arrange_profiles.o] Error 1 <br>解决办法： <br>external/oprofile/libpp/format_output.h <br>把： <br>mutable counts_t &amp; counts; <br>改为： <br>counts_t &amp; counts;  </p>
<p>3.external/gtest/src/../include/gtest/internal/gtest-param-util.h:122:11: 错误： ‘ptrdiff_t’不是一个类型名 <br>In file included from external/gtest/src/../include/gtest/gtest-param-test.h:157:0, <br>                 from external/gtest/src/../include/gtest/gtest.h:69, <br>                 from external/gtest/src/../src/gtest.cc:34, <br>                 from external/gtest/src/gtest-all.cc:36: <br>解决方法： <br>$vim external/gtest/src/../include/gtest/internal/gtest-param-util.h <br>#include &lt;cstddef&gt; </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>9820e debug</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/9820e%20debug/</url>
    <content><![CDATA[<p>IMEI</p>
<p>dumpsys iphonesubinfo</p>
<p>Device ID = 867400020316612</p>
<p>获取手机分辨率</p>
<p>adb shell &quot;dumpsys window | grep mUnrestrictedScreen&quot;</p>
<p>手机物理密度</p>
<p>adb shell wm density</p>
<p>mac</p>
<p>/sys/class/net/wlan0/address</p>
<p>frameworks\base\services\java\com\android\server\wifi\WifiService.java</p>
<p>checkAndStartWifi</p>
<p> 在frameworks\base\services\java\com\android\server\SystemServer.java里搜索wifi.checkAndStartWifi()， </p>
<p> frameworks\base\wifi\java\android\net\wifi\WifiApConfigStore.java</p>
<p>setDefaultApConfiguration</p>
<p>/data/misc/wifi/softap.conf</p>
<p>    public boolean setWifiApEnabled(boolean enabled) {</p>
<p>        if (enabled) { // disable WiFi in any case</p>
<p>            //wifi和热点不能同时打开，所以打开热点的时候需要关闭wifi</p>
<p>            wifiManager.setWifiEnabled(false);</p>
<p>        }</p>
<p>        try {</p>
<p>            //热点的配置类</p>
<p>            WifiConfiguration apConfig = new WifiConfiguration();</p>
<p>            //配置热点的名称(可以在名字后面加点随机数什么的)</p>
<p>            apConfig.SSID = &quot;YRCCONNECTION&quot;;</p>
<p>            //配置热点的密码</p>
<p>            apConfig.preSharedKey=&quot;12122112&quot;;</p>
<p>                //通过反射调用设置热点</p>
<p>            Method method = wifiManager.getClass().getMethod(</p>
<p>                    &quot;setWifiApEnabled&quot;, WifiConfiguration.class, Boolean.TYPE);</p>
<p>            //返回热点打开状态</p>
<p>            return (Boolean) method.invoke(wifiManager, apConfig, enabled);</p>
<p>        } catch (Exception e) {</p>
<p>            return false;</p>
<p>        }</p>
<p>    }</p>
<p>FM</p>
<p><a href="https://blog.csdn.net/liyanfei123456/article/details/53516741">https://blog.csdn.net/liyanfei123456/article/details/53516741</a></p>
<p>am start -n com.sprd.engineermode/com.sprd.engineermode.EngineerModeActivity</p>
<p>am start -n com.spreadtrum.sgps/com.spreadtrum.sgps.SgpsActivity</p>
<p>am start -n com.alibaba.sdk.aligeniesdkdemo/com.yunos.tv.alitvasr.MainActivity</p>
<p>am start -n com.android.settings/.wifi.HotspotSettings</p>
<p>am start -n com.hizen.genius.mini/com.hizen.genius.mini.MainActivity</p>
<p>am start -n ai.t.rec/ai.test.rec.Main</p>
<p> am start -n com.sprd.fileexplorer/.activities.FileExploreActivity</p>
<p>am start -n com.sprd.simple.launcher/com.sprd.classichome.Home</p>
<p>am start -n com.chartcross.gpstest/.GPSTest</p>
<p>am start -n com.android.gpstest/.GpsTestActivity</p>
<p>device/sprd/sharkle/common/BoardCommon.mk:19:KERNEL_DEFCONFIG := sprd_sharkle_fp_defconfig</p>
<p>kernel\arch\arm\configs\sprd_sharkle_fp_defconfig</p>
<p>setprop persist.sys.engpc.disable 0</p>
<p> make snod </p>
<p> make userdataimage-nodeps</p>
<p> bootimage-nodeps</p>
<p> make bootloader</p>
<p>procrank</p>
<p> dumpsys meminfo</p>
<p>dumpsys [options]</p>
<p>               meminfo 显示内存信息</p>
<p>               cpuinfo 显示CPU信息</p>
<p>               account 显示accounts信息</p>
<p>               activity 显示所有的activities的信息</p>
<p>               window 显示键盘，窗口和它们的关系</p>
<p>               wifi 显示wifi信息</p>
<p>cat /d/gpio</p>
<p>/d/regulator</p>
<p>echo 3 &gt;/proc/sys/kernel/printk</p>
<p>// 设置 Ylog 默认开启开关 1 开启，0或不写 关闭</p>
<p>setprop persist.ylog.enabled 1</p>
<p>start ylog</p>
<p>// 设置sysdump 默认开关属性值 开启为true  关闭 false</p>
<p>setprop debug.sysdump.enabled true</p>
<p>setprop persist.sys.eng.reset 0</p>
<p>SystemProperties.set(“ctl.start”,serviceName);</p>
<p>SystemProperties.set(“ctl.stop”,serviceName);</p>
<p>setprop ctl.stop serviceName</p>
<p>start service</p>
<p>make otapackage</p>
<p>out/target/product/sp9820e_2h10/sp9820e_2h10_native-ota-eng.hz.zip</p>
<p>out/target/product/sp9820e_2h10/obj/PACKAGING/target_files_intermediates/sp9820e_2h10_native-target_files-eng.hz.zip</p>
<p> ./build/tools/releasetools/ota_from_target_files -k [keypath] -i oldotapackage newotapackage update.zip</p>
<p>./build/tools/releasetools/ota_from_target_files -k build/target/product/security/testkey -i ota/sp9820e_2h10_native-target_files-eng.hz_test6.zip ota/sp9820e_2h10_native-target_files-eng.hz_test7.zip ota/update.zip</p>
<p>bootable/recovery/nvmerge/</p>
<p>vendor/sprd/tools/ota/repart</p>
<p>build/core/</p>
<p>partition_size_self_adaption.sh</p>
<p>执行完make otapackage之后，会在out/target/product/工程/obj/PACKAGING/target_files_intermediates/xxx.zip（xxx.zip就是所需要的资源包）</p>
<p>build/tools/releasetools/ota_from_target_files -i A.zip -k build/target/product/security/testkey B.zip update.zip（update.zip即为差分升级包）</p>
<p>proc/cmdline</p>
<p>proc/sys/kernel/printk </p>
<p>echo 1       4       1      7 &gt; /proc/sys/kernel/printk</p>
<p>控制台日志级别：优先级高于该值的消息将被打印至控制台</p>
<p>默认的消息日志级别：将用该优先级来打印没有优先级的消息</p>
<p>最低的控制台日志级别：控制台日志级别可被设置的最小值(最高优先级)</p>
<p>默认的控制台日志级别：控制台日志级别的缺省值</p>
<p>恢复出厂</p>
<p>am broadcast -a android.intent.action.MASTER_CLEAR</p>
<p>service.adb.tcp.port </p>
<p>sudo sshfs <a href="mailto:&#x7a;&#104;&#x6f;&#x75;&#x7a;&#104;&#101;&#110;&#x73;&#104;&#x75;&#64;&#x31;&#57;&#50;&#46;&#x31;&#54;&#x38;&#46;&#x31;&#x2e;&#50;&#48;&#48;">&#x7a;&#104;&#x6f;&#x75;&#x7a;&#104;&#101;&#110;&#x73;&#104;&#x75;&#64;&#x31;&#57;&#50;&#46;&#x31;&#54;&#x38;&#46;&#x31;&#x2e;&#50;&#48;&#48;</a>:/home/  /opt/disk1/share/zzs200 -o allow_other,nonempty</p>
<p>u-boot15/include/configs/sp9820e_2h10.h</p>
<p>kernel/arch/arm/boot/dts/sp9820e-2h10-native.dts</p>
<p>console = null loglevel=0</p>
<p>echo &quot;–update_package=/storage/sdcard0/update.zip&quot; &gt; /cache/recovery/command</p>
<p>echo &quot;–update_package=/sdcard/update.zip&quot; &gt; /cache/recovery/command</p>
<p>com.adups.fota/.GoogleOtaClient</p>
<p>[89860619000016217618] 芯联</p>
<p>private void sendSoftApConnectionChangedBroadcast(boolean isConnected, String macString){</p>
<p>            final Intent intent = new Intent(WifiManager.WIFI_AP_CONNECTION_CHANGED_ACTION);</p>
<p>            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);</p>
<p>            intent.putExtra(WifiManager.EXTRA_WIFI_AP_CONNECTED_STATION, isConnected);</p>
<p>            intent.putExtra(WifiManager.EXTRA_WIFI_AP_CONNCTION_STA_MAC, macString);</p>
<p>            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);</p>
<p>        }</p>
<p> private void sendLinkConfigurationChangedBroadcast() {</p>
<p>        Intent intent = new Intent(WifiManager.LINK_CONFIGURATION_CHANGED_ACTION);</p>
<p>        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);</p>
<p>        intent.putExtra(WifiManager.EXTRA_LINK_PROPERTIES, new LinkProperties(mLinkProperties));</p>
<p>        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);</p>
<p>    }</p>
<p>{REG_PIN_CTRL2,0x60400000}  —— uart0</p>
<p>{REG_PIN_CTRL2,0x60400510}  —— uart2</p>
<p>{REG_PIN_CTRL2,0x60400090}  —— uart1</p>
<p> am broadcast -a com.bidostar.tts –es content &quot;this is test string&quot; </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>=== sendevent ===</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/===%20sendevent%20===/</url>
    <content><![CDATA[<p>命令格式2：adb shell sendevent [device] [type] [code] [value]</p>
<p>发送时间,格式和上面的一样,需要注意的是在get中code显示的是十六进制,而send中需要用十进制,例如</p>
<h1 id="sendevent-dev-input-event0-1-5-1"><a href="#sendevent-dev-input-event0-1-5-1" class="headerlink" title="sendevent /dev/input/event0 1 5 1"></a>sendevent /dev/input/event0 1 5 1</h1><p>这个命令就是发送数字4的keydown消息,所以在屏幕上就会一直打印出很多个4(因为没有发送keyup) </p>
<p>如： adb shell sendevent /dev/input/event0 1 229 1 代表按下按下menu键</p>
<p>adb shell sendevent /dev/input/event0 1 229 0 代表按下松开menu键</p>
<p>说明：上述的命令需组合使用</p>
<p>另外所知道的命令如下：</p>
<p>Key Name                        CODE</p>
<p>MENU                                 229</p>
<p>HOME                                 102</p>
<p>BACK (back button)            158</p>
<p>CALL (call button)               231</p>
<p>END (end call button)         107</p>
<p>2. 发送鼠标事件(Touch)：</p>
<p>命令格式：adb shell sendevent [device] [type] [code] [value]</p>
<p>情况1：在某坐标点上touch</p>
<p>如在屏幕的x坐标为40，y坐标为210的点上touch一下，命令如下</p>
<p>adb shell sendevent /dev/input/event0 3 0 40<br>adb shell sendevent /dev/input/event0 3 1 210<br>　　 <br>adb shell sendevent /dev/input/event0 1 330 1 //touch<br>adb shell sendevent /dev/input/event0 0 0 0       //it must have<br>　　 <br>adb shell sendevent /dev/input/event0 1 330 0 //untouch<br>adb shell sendevent /dev/input/event0 0 0 0 //it must have </p>
<p>注：以上六组命令必须配合使用，缺一不可</p>
<p>情况2：模拟滑动轨迹（可下载并采用aPaint软件进行试验）</p>
<p>如下例是在aPaint软件上画出一条开始于（100,200），止于（108,200）的水平直线</p>
<p>adb shell sendevent /dev/input/event0 3 0 100 //start from point (100,200)<br>adb shell sendevent /dev/input/event0 3 1 200<br>　　 <br>adb shell sendevent /dev/input/event0 1 330 1 //touch<br>adb shell sendevent /dev/input/event0 0 0 0<br>　　 <br>adb shell sendevent /dev/input/event0 3 0 101 //step to point (101,200)<br>adb shell sendevent /dev/input/event0 0 0 0<br>……………………                                                  //must list each step, here just skip<br>adb shell sendevent /dev/input/event0 3 0 108 //end point(108,200)<br>adb shell sendevent /dev/input/event0 0 0 0<br>　　 <br>adb shell sendevent /dev/input/event0 1 330 0 //untouch<br>adb shell sendevent /dev/input/event0 0 0 0 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ACCELEROMETER_ROTATION</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ACCELEROMETER_ROTATION/</url>
    <content><![CDATA[<p>frameworks/base/core/java/com/android/internal/view/RotationPolicy.java</p>
<p>  * Returns true if rotation lock is enabled.</p>
<p>     */</p>
<p>    public static boolean isRotationLocked(Context context) {</p>
<p>        return Settings.System.getIntForUser(context.getContentResolver(),</p>
<p>                Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) == 0;</p>
<p>    }</p>
<p>   /**</p>
<p>     * Enables or disables rotation lock.</p>
<p>     *</p>
<p>     * Should be used by the rotation lock toggle.</p>
<p>     */</p>
<p>    public static void setRotationLock(Context context, final boolean enabled) {</p>
<p>        Settings.System.putIntForUser(context.getContentResolver(),</p>
<p>                Settings.System.HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY, 0,</p>
<p>                UserHandle.USER_CURRENT);</p>
<p>        AsyncTask.execute(new Runnable() {</p>
<p>            @Override</p>
<p>            public void run() {</p>
<p>                try {</p>
<p>                    IWindowManager wm = WindowManagerGlobal.getWindowManagerService();</p>
<p>                    if (enabled) {</p>
<p>                        wm.freezeRotation(-1);</p>
<p>                    } else {</p>
<p>                        wm.thawRotation();</p>
<p>                    }</p>
<p>                } catch (RemoteException exc) {</p>
<p>                    Log.w(TAG, &quot;Unable to save auto-rotate setting&quot;);</p>
<p>                }</p>
<p>            }</p>
<p>        });</p>
<p>    }</p>
<p>systemui\statusbar\policy</p>
<p>RotationLockController.java</p>
<p>    public boolean isRotationLocked() {</p>
<p>        if (RotationPolicy.isRotationLockToggleSupported(mContext)) {</p>
<p>            return RotationPolicy.isRotationLocked(mContext);</p>
<p>        }</p>
<p>        return false;</p>
<p>    }</p>
<p>    public void setRotationLocked(boolean locked) {</p>
<p>        if (RotationPolicy.isRotationLockToggleSupported(mContext)) {</p>
<p>            RotationPolicy.setRotationLock(mContext, locked);</p>
<p>        }</p>
<p>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ADB  (Android Debug Bridge)</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ADB%20%20(Android%20Debug%20Bridge)/</url>
    <content><![CDATA[<p>Android Debug Bridge 简称  ADB 是一种多用途的命令行工具。通过它我们可以和模拟器或者设备通信。ADB 在Android 系统是一个常用的工具。Android系统中都有一个守护进程（ADB Daemon), 通过客户端的命令与adbd进行通信，是开发中一种常用的调试工具。</p>
<p>    你可以在sdk/platform-tools下面找到adb工具。也可以在sdk源码中 system/core/adb中的源码编译获得。</p>
<p>以下是adb 常用命令：</p>
<p>adb start-server      启动adb 服务</p>
<p>adb kill-server        关闭adb 服务</p>
<p>通过这两个命令可以重启PC上的adb 服务，特别是当手机助手等软件运行了它们的adb时，可以用此命令关闭后，用自己的adb </p>
<p>adb devices         列出连上adb 的设备列表</p>
<p>C:&amp;gt;adb devices</p>
<p>List of devices attached</p>
<p>U33BXCAGFI device</p>
<p>YFBB9KU4V2 device</p>
<p>adb shell         进入设备控制台console</p>
<p>C:&amp;gt;adb shell</p>
<p>root@android:/ #</p>
<p>adb remount       重新挂载system，获得rw的权限，但必须有root权限</p>
<p>C:&amp;gt;adb remount</p>
<p>remount succeeded</p>
<p>adb push &lt;local&gt; &lt;remote&gt;       将测试文件推到设备中，需要remount 获得权限</p>
<p>C:&amp;gt;adb remount</p>
<p>remount succeeded</p>
<p>C:&amp;gt;adb push c:\Maps.apk system/app</p>
<p>2593 KB/s (6597416 bytes in 2.484s)</p>
<p>adb pull &lt;remote&gt; [&lt;local&gt;]       将设备中的文件，拉到本地PC上</p>
<p>C:&amp;gt;adb pull system/app/Maps.apk c:\</p>
<p>2316 KB/s (6597416 bytes in 2.781s)</p>
<p>adb reboot [bootloader|recovery]      重启设备、重启设备到bootloader模式</p>
<p>C:&amp;gt;adb reboot</p>
<p>C:&amp;gt;adb reboot bootloader</p>
<p>adb install  [-r] [-s]   &lt;file&gt;        安装本地apk, -r 重新安装 , -s 安装到sdcard</p>
<p>C:&amp;gt;adb install -r c:\SimpleJNI.apk</p>
<p>329 KB/s (5276 bytes in 0.015s)</p>
<p>        pkg: /data/local/tmp/SimpleJNI.apk</p>
<p>Success</p>
<p>adb uninstall [-k]  &lt;package&gt;    根据包名，卸截apk, -k 不删除数据</p>
<p>C:&amp;gt;adb uninstall com.example.android.simplejni</p>
<p>Success</p>
<p>更多用法请上官网</p>
<p><a href="http://developer.android.com/tools/help/adb.html">http://developer.android.com/tools/help/adb.html</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Activity屏幕的方向</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Activity%E5%B1%8F%E5%B9%95%E7%9A%84%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p>设置屏幕的方向 </p>
<p>值描述</p>
<p>unspecified默认值。系统自动选择屏幕方向</p>
<p>behind跟activity堆栈中的下面一个activity的方向一致</p>
<p>landscape横屏方向，显示的宽比高长</p>
<p>portrait竖屏方向，显示的高比宽长</p>
<p>sensor由设备的物理方向传感器决定，如果用户旋转设备，这屏幕就会横竖屏切换</p>
<p>nosensor忽略物理方向传感器，这样就不会随着用户旋转设备而横竖屏切换了（&quot;unspecified&quot;设置除外）</p>
<p>user用户当前首选的方向</p>
<p>reverseLandscapeAPI 9 以上，反向横屏</p>
<p>reversePortraitAPI 9 以上，反向竖屏</p>
<p>sensorLandscapeAPI 9 以上，横屏，但是可以根据 物理方向传感器来切换正反向横屏</p>
<p>sensorPortraitAPI 9 以上，竖屏，但是可以根据 物理方向传感器来切换正反向竖屏</p>
<p>fullSensorAPI 9 以上，上下左右四个方向，由物理方向传感器决定</p>
<p>lockedAPI 18 以上，锁死当前屏幕的方向</p>
<p>android:screenOrientation=&quot;portrait&quot; </p>
<p>setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); </p>
<p> setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</p>
<p>  有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ActivityManager调试</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ActivityManager%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>am start -a android.intent.action.VIEW -d <a href="http://www.china.com/">http://www.china.com</a></p>
<p>am start -a android.intent.action.CALL -d tel:123456789</p>
<p>am start -a android.intent.action.VIEW geo:0,0?q=shanghai</p>
<p>am start -a android.intent.action.VIEW -t application/pdf</p>
<p>usage: am [subcommand] [options]</p>
<p>usage: am start [-D] [-W] [-P &lt;FILE&gt;] [–start-profiler &lt;FILE&gt;]</p>
<p>               [–R COUNT] [-S] [–opengl-trace] &lt;INTENT&gt;</p>
<p>       am startservice &lt;INTENT&gt;</p>
<p>       am force-stop &lt;PACKAGE&gt;</p>
<p>       am kill &lt;PACKAGE&gt;</p>
<p>       am kill-all</p>
<p>       am broadcast &lt;INTENT&gt;</p>
<p>       am instrument [-r] [-e &lt;NAME&gt; &lt;VALUE&gt;] [-p &lt;FILE&gt;] [-w]</p>
<p>               [–no-window-animation] &lt;COMPONENT&gt;</p>
<p>       am profile start &lt;PROCESS&gt; &lt;FILE&gt;</p>
<p>       am profile stop [&lt;PROCESS&gt;]</p>
<p>       am dumpheap [flags] &lt;PROCESS&gt; &lt;FILE&gt;</p>
<p>       am set-debug-app [-w] [–persistent] &lt;PACKAGE&gt;</p>
<p>       am clear-debug-app</p>
<p>       am monitor [–gdb &lt;port&gt;]</p>
<p>       am screen-compat [on|off] &lt;PACKAGE&gt;</p>
<p>       am display-size [reset|MxN]</p>
<p>       am to-uri [INTENT]</p>
<p>       am to-intent-uri [INTENT]</p>
<p>am start: start an Activity.  Options are:</p>
<p>    -D: enable debugging</p>
<p>    -W: wait for launch to complete</p>
<p>    –start-profiler &lt;FILE&gt;: start profiler and send results to &lt;FILE&gt;</p>
<p>    -P &lt;FILE&gt;: like above, but profiling stops when app goes idle</p>
<p>    -R: repeat the activity launch &lt;COUNT&gt; times.  Prior to each repeat,</p>
<p>        the top activity will be finished.</p>
<p>    -S: force stop the target app before starting the activity</p>
<p>    –opengl-trace: enable tracing of OpenGL functions</p>
<p>am startservice: start a Service.</p>
<p>am force-stop: force stop everything associated with &lt;PACKAGE&gt;.</p>
<p>am kill: Kill all processes associated with &lt;PACKAGE&gt;.  Only kills.</p>
<p>  processes that are safe to kill – that is, will not impact the user</p>
<p>  experience.</p>
<p>am kill-all: Kill all background processes.</p>
<p>am broadcast: send a broadcast Intent.</p>
<p>am instrument: start an Instrumentation.  Typically this target &lt;COMPONENT&gt;</p>
<p>  is the form &lt;TEST_PACKAGE&gt;/&lt;RUNNER_CLASS&gt;.  Options are:</p>
<p>    -r: print raw results (otherwise decode REPORT_KEY_STREAMRESULT).  Use with</p>
<p>        [-e perf true] to generate raw output for performance measurements.</p>
<p>    -e &lt;NAME&gt; &lt;VALUE&gt;: set argument &lt;NAME&gt; to &lt;VALUE&gt;.  For test runners a</p>
<p>        common form is [-e &lt;testrunner_flag&gt; &lt;value&gt;[,&lt;value&gt;…]].</p>
<p>    -p &lt;FILE&gt;: write profiling data to &lt;FILE&gt;</p>
<p>    -w: wait for instrumentation to finish before returning.  Required for</p>
<p>        test runners.</p>
<p>    –no-window-animation: turn off window animations will running.</p>
<p>am profile: start and stop profiler on a process.</p>
<p>am dumpheap: dump the heap of a process.  Options are:</p>
<p>    -n: dump native heap instead of managed heap</p>
<p>am set-debug-app: set application &lt;PACKAGE&gt; to debug.  Options are:</p>
<p>    -w: wait for debugger when application starts</p>
<p>    –persistent: retain this value</p>
<p>am clear-debug-app: clear the previously set-debug-app.</p>
<p>am monitor: start monitoring for crashes or ANRs.</p>
<p>    –gdb: start gdbserv on the given port at crash/ANR</p>
<p>am screen-compat: control screen compatibility mode of &lt;PACKAGE&gt;.</p>
<p>am display-size: override display size.</p>
<p>am to-uri: print the given Intent specification as a URI.</p>
<p>am to-intent-uri: print the given Intent specification as an intent: URI.</p>
<p>&lt;INTENT&gt; specifications include these flags and arguments:</p>
<p>    [-a &lt;ACTION&gt;] [-d &lt;DATA_URI&gt;] [-t &lt;MIME_TYPE&gt;]</p>
<p>    [-c &lt;CATEGORY&gt; [-c &lt;CATEGORY&gt;] …]</p>
<p>    [-e|–es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt; …]</p>
<p>    [–esn &lt;EXTRA_KEY&gt; …]</p>
<p>    [–ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; …]</p>
<p>    [–ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; …]</p>
<p>    [–el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; …]</p>
<p>    [–ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; …]</p>
<p>    [–eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; …]</p>
<p>    [–ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;]</p>
<p>    [–eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE…]]</p>
<p>    [–ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE…]]</p>
<p>    [–efa &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;[,&lt;EXTRA_FLOAT_VALUE…]]</p>
<p>    [-n &lt;COMPONENT&gt;] [-f &lt;FLAGS&gt;]</p>
<p>    [–grant-read-uri-permission] [–grant-write-uri-permission]</p>
<p>    [–debug-log-resolution] [–exclude-stopped-packages]</p>
<p>    [–include-stopped-packages]</p>
<p>    [–activity-brought-to-front] [–activity-clear-top]</p>
<p>    [–activity-clear-when-task-reset] [–activity-exclude-from-recents]</p>
<p>    [–activity-launched-from-history] [–activity-multiple-task]</p>
<p>    [–activity-no-animation] [–activity-no-history]</p>
<p>    [–activity-no-user-action] [–activity-previous-is-top]</p>
<p>    [–activity-reorder-to-front] [–activity-reset-task-if-needed]</p>
<p>    [–activity-single-top] [–activity-clear-task]</p>
<p>    [–activity-task-on-home]</p>
<p>    [–receiver-registered-only] [–receiver-replace-pending]</p>
<p>    [–selector]</p>
<p>    [&lt;URI&gt; | &lt;PACKAGE&gt; | &lt;COMPONENT&gt;]</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Adapter深入理解与优化</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Adapter%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Android高手进阶：Adapter深入理解与优化</p>
<p>2014-07-15 17:17 佚名 eoeandroid 字号：T | T</p>
<p>一般是针对包含多个元素的View，如ListView，GridView，ExpandableListview，的时候我们是给其设置一个Adapter。Adapter是与View之间提供数据的桥梁，也是提供每个Item的视图桥梁。</p>
<p>AD：51CTO网+ 首届中国APP创新评选大赛火热招募中……</p>
<p>一般是针对包含多个元素的View，如ListView，GridView，ExpandableListview，的时候我们是给其设置一个Adapter。Adapter是与View之间提供数据的桥梁，也是提供每个Item的视图桥梁。</p>
<p>以ListView为例，其工作原理为:</p>
<p>● ListView针对List中每个item， adapter都会调用一个getView的方法获得布局视图</p>
<p>●我们一般会Inflate一个新的View，填充数据并返回显示</p>
<p>当然如果我们的Item很多话（比如上万个），都会新建一个View吗？很明显这样内存是接受不了的，Google也不会这么做，Android中有个叫做Recycler的构件，下图是他的工作原理：</p>
<p>很明显，无论数据中是多少个item，在显示上Recycler只存储其中可见的View在内存中。当向下滑动时，顶部不可见Item直接回移动到下方再次填充数据变为新增项。这样就不用每次都新建一个View了。</p>
<p>这个也就是我们在Adapter中常见的getView方法的调用，对应此方法我们就能看出，convertView就是每一Item在Recyler之前的布局视图。</p>
<p>public View getView(int position, View convertView, ViewGrouppare</p>
<p>所以，Android已经给我们提供了Recycler机制了，我们就应该利用此机制，而不是每次都去inflate一个View。</p>
<p>Example</p>
<p>Don’t</p>
<p>public View getView(int position, View convertView, ViewGroupparent){   </p>
<p>    convertView = LayoutInflater.from(mContext).inflate(R.layout.item_view,null);   </p>
<p>//dosomething…   </p>
<p>return converView;   </p>
<p>}   </p>
<p>Do</p>
<p>public View getView(int position, View convertView, ViewGroupparent){   </p>
<p>if (convertView ==null) {   </p>
<p>           convertView =LayoutInflater.from(mContext).inflate(R.layout.item_view, null);   </p>
<p>     }   </p>
<p>//dosomething…   </p>
<p>return converView;   </p>
<p>}   </p>
<p>ViewHolder的作用</p>
<p>之前所说的Recycler模式是为了解决重复inflate时候造成的View资源浪费，还哪有什么方法何可再次优化我们的性能吗？答案是Yes。</p>
<p>我们还是从getView中的每一个方法调用去查看，发现其实我们拿到convertView的时候，每次都会根据这个布局去findViewById。如下，使我们通常的写法：</p>
<p>findViewById是在解析layout.xml布局那种其中的子View，解析xml是一个力气活，所以Google也建议我们将这个费力不讨好的活优化起来，所以提出了ViewHolder的概念。</p>
<p>即，使用一个静态类，保存xml中的各个子View的引用关系，这样就不必要每次都去解析xml了。如下：就是针对上面代码写的一个ViewHolder</p>
<p>if (convertView == null) {                </p>
<p>   convertView = mInflater.inflate(R.layout.item_view, null);             </p>
<p>}    </p>
<p>TextView titleTextView = (TextView) convertView.findViewById(R.id.text));            </p>
<p>ImageView iconImageView = (ImageView)convertView.findViewButId( R.id.icon));    </p>
<p>//DoSomething…   </p>
<p>findViewById是在解析layout.xml布局那种其中的子View，解析xml是一个力气活，所以Google也建议我们将这个费力不讨好的活优化起来，所以提出了ViewHolder的概念。</p>
<p>即，使用一个静态类，保存xml中的各个子View的引用关系，这样就不必要每次都去解析xml了。如下：就是针对上面代码写的一个ViewHolder</p>
<p>static class ViewHolder {    </p>
<p>    TextView titleTextView;    </p>
<p>    ImageView iconImageView;    </p>
<p>}    </p>
<p>但是，在getView方法中我们只能拿到三个参数，position、convertView、viewGroup是拿不到我们自定义的ViewHolder的。所以，我们希望通过convertView拿到ViewHolder只能将其放在tag里。</p>
<p>下面是一个完整的ViewHolder使用exmaple:</p>
<p>public View getView(int position, View convertView, ViewGroup parent) {   </p>
<p>    ViewHolder holder;   </p>
<p>if (convertView == null) {   </p>
<p>        convertView = mInflater.inflate(R.layout.item_view, null);   </p>
<p>        holder = new ViewHolder();   </p>
<p>        holder.titleTextView = (TextView) convertView.findViewById(R.id.text);   </p>
<p>        holder.iconImageView = (ImageView) convertView.findViewById(R.id.icon);   </p>
<p>        convertView.setTag(holder);   </p>
<p>    } else {   </p>
<p>        holder = (ViewHolder) convertView.getTag();   </p>
<p>    }   </p>
<p>    holder.titleTextView.setText(DATA[pos].title);   </p>
<p>    holder.iconImageView.setImageBitmap(DATA[pos].bitmap);   </p>
<p>return convertView;   </p>
<p>}   </p>
<p>static class ViewHolder {   </p>
<p>    TextView titleTextView;   </p>
<p>    ImageView iconImageView;   </p>
<p>}   </p>
<p>Tips. Support.v7中的RecyclerView 就是采用了此思想来制作的。</p>
<p>多个类型的ViewType</p>
<p>当我们在Adapter中调用方法getView的时候，如果整个列表中的Item View如果有多种类型布局，如：</p>
<p>我们继续使用convertView来将数据从新填充貌似不可行了，因为每次返回的convertView类型都不一样，无法重用。</p>
<p>Android在设计上的时候，也想到了这点。所以，在adapter中预留的两个方法。</p>
<p>public int getItemViewType(int position) ; </p>
<p>public int getViewTypeCount();</p>
<p>只需要重新这两个方法，设置一下ItemViewType的个数和判断方法，Recycler就能有选择性的给出不同的convertView了。 </p>
<p>       Example：</p>
<p>@Override   </p>
<p>public intgetItemViewType(int position) {   </p>
<p>if (DATA[pos].type == 0) {   </p>
<p>return 0;   </p>
<p>    } else {   </p>
<p>return 1;   </p>
<p>    }   </p>
<p>}   </p>
<p>@Override   </p>
<p>public int getViewTypeCount() {   </p>
<p>return 2;   </p>
<p>}   </p>
<p>@Override   </p>
<p>public View getView(int position, View convertView, ViewGroup arg2) {   </p>
<p>    TitleViewHolder titleHolder;   </p>
<p>    InfoViewHolder infoHolder;   </p>
<p>int type = getItemViewType(position);   </p>
<p>if (convertView == null) {   </p>
<p>switch (type) {   </p>
<p>case 0:   </p>
<p>            convertView = mInflater.inflate(R.layout.item_view, null);   </p>
<p>            titleHolder = new TitleViewHolder();   </p>
<p>            titleHolder.titleTextView = (TextView) convertView.findViewById(R.id.text);   </p>
<p>            titleHolder.iconImageView = (ImageView) convertView.findViewById(R.id.icon);   </p>
<p>            convertView.setTag(titleHolder);   </p>
<p>break;   </p>
<p>case 1:   </p>
<p>            convertView = mInflater.inflate(R.layout.item_view2, null);   </p>
<p>            infoHolder = new InfoViewHolder();   </p>
<p>            infoHolder.titleTextView = (TextView) convertView.findViewById(R.id.text);   </p>
<p>            convertView.setTag(infoHolder);   </p>
<p>break;   </p>
<p>        }   </p>
<p>    } else {   </p>
<p>switch (type) {   </p>
<p>case 0:   </p>
<p>            titleHolder = (TitleViewHolder) convertView.getTag();   </p>
<p>break;   </p>
<p>case 1:   </p>
<p>            infoHolder = (InfoViewHolder) convertView.getTag();   </p>
<p>break;   </p>
<p>        }   </p>
<p>    }   </p>
<p>switch (type) {   </p>
<p>case 0:   </p>
<p>        titleHolder.titleTextView.setText(DATA[pos].title);   </p>
<p>break;   </p>
<p>case 1:   </p>
<p>        infoHolder.titleTextView.setText(DATA[pos].title);   </p>
<p>        infoHolder.iconImageView.setImageBitmap(DATA[pos].bitmap);   </p>
<p>break;   </p>
<p>    }   </p>
<p>return convertView;   </p>
<p>}   </p>
<p>static class TitleViewHolder {   </p>
<p>public ImageView iconImageView;   </p>
<p>public TextView titleTextView;   </p>
<p>}   </p>
<p>static class InfoViewHolder {   </p>
<p>    TextView titleTextView;   </p>
<p>    ImageView iconImageView;   </p>
<p>}   </p>
<p>NotifyDataSetChanged刷新机制</p>
<p>当ListView中的数据发生了改变，我们希望刷新ListView中的View时，我们一般会调用NotifyDataSetChanged来刷新ListView。看一下它的源码：</p>
<p>public void notifyChanged() {   </p>
<p>synchronized (mObservers) {   </p>
<p>// 向每一个子View发送onChanged   </p>
<p>for (int i = mObservers.size() - 1; i &gt;= 0; i–) {   </p>
<p>            mObservers.get(i).onChanged();   </p>
<p>        }   </p>
<p>    }   </p>
<p>}   </p>
<p>发 现它针对每一个子View都做了刷新，当然，如果我们的数据都变量还可以理解。但是，一般条件下，我们需要更新的View不多。频繁的调用 NotifyDataSetChanged方法，刷新整个界面不合适。这样会把界面上显示的所有item都全部重绘一次，即使只有一个view的内容发生 了变化。</p>
<p>所以，我们可以写一个update的方法，来单独刷新一个View</p>
<p>private void updateView(int itemIndex){   </p>
<p>    intvisiblePosition = yourListView.getFirstVisiblePosition();   </p>
<p>    Viewv = yourListView.getChildAt(itemIndex - visiblePosition);   </p>
<p>         ViewHolder viewHolder =(ViewHolder)v.getTag();   </p>
<p>if(viewHolder!= null){   </p>
<p>               viewHolder.titleTextView.setText(&quot;我更新了&quot;);   </p>
<p>         }      </p>
<p>}   </p>
<p>Adapter中的网络图片优化</p>
<p>ListView中的每一项Item基本都会带着网络图片，当item比较多的时候，过多的网络请求和过多的图片存储都会是ListView变慢变卡。</p>
<p>所以针对其做一下优化：</p>
<p>  ●  采用线程池进行网络图片请求，网络图片请求获取后使用本地缓存处理（LRUCache），内存+本地文件缓存。当然，为了防止内存溢出与回收不及时，需要使用弱引用（WeakReference）来存储内存中的图片。</p>
<p>  ●  对网络中取到的图片进行按比例缩放，以减少内存消耗。</p>
<p>  ●  滑动的时候不需要对网络图片进行请求。因为，网络请求一般比较耗时，某Item的图片，在请求来的时候如果被Recycler换掉，图片就会对应不上该Item。 </p>
<p>Tips.网络请求的工具类比较多不方便举例子，但是使用比较频繁的网络图片请求工具类就是Volley了，Volley提供了一个ImageLoader的工具类和NetworkImageView的网络图片请求View</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android BT 通讯</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20BT%20%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<p>（一）服务端</p>
<p>实现思路：</p>
<p>1、拿到本地蓝牙设备。</p>
<p>2、蓝牙之间的通讯需要一个唯一识别UUID来匹配正确的设备，使用UUID获取蓝牙的通讯Socket。</p>
<p>3、开启获取数据的线程</p>
<p>[java] view plain copy</p>
<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener {  </p>
<p>    BluetoothSocket BTSocket;  </p>
<p>    BluetoothAdapter BTAdapter;  </p>
<p>    Button bt_start;  </p>
<p>    TextView tv_msg;  </p>
<p>    StringBuilder sb;  </p>
<p>@Override  </p>
<p>protected void onCreate(Bundle savedInstanceState) {  </p>
<p>super.onCreate(savedInstanceState);  </p>
<p>        setContentView(R.layout.activity_main);  </p>
<p>        bt_start = (Button) findViewById(R.id.bt_start);  </p>
<p>        tv_msg = (TextView) findViewById(R.id.tv_msg);  </p>
<p>        bt_start.setOnClickListener(this);  </p>
<p>        sb = new StringBuilder();  </p>
<p>        show(&quot;服务端:检查BT&quot;);  </p>
<p>        checkBT(this);  </p>
<p>    }  </p>
<p>/** </p>
<p>     * 检查蓝牙 </p>
<p>     */  </p>
<p>public void checkBT(Context context) {  </p>
<p>        BTAdapter = BluetoothAdapter.getDefaultAdapter();  </p>
<p>if (BTAdapter != null) {  </p>
<p>if (!BTAdapter.isEnabled()) {  </p>
<p>                Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);  </p>
<p>// 设置蓝牙可见性，最多300秒  </p>
<p>                intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);  </p>
<p>                context.startActivity(intent);  </p>
<p>            }  </p>
<p>        } else {  </p>
<p>            show(&quot;本地设备驱动异常!&quot;);  </p>
<p>        }  </p>
<p>    }  </p>
<p>/** </p>
<p>     * UI文本输出 </p>
<p>     * </p>
<p>     * @param msg </p>
<p>     */  </p>
<p>public void show(String msg) {  </p>
<p>        sb.append(msg + &quot;\n&quot;);  </p>
<p>        runOnUiThread(new Runnable() {  </p>
<p>@Override  </p>
<p>public void run() {  </p>
<p>                tv_msg.setText(sb.toString());  </p>
<p>            }  </p>
<p>        });  </p>
<p>    }  </p>
<p>@Override  </p>
<p>public void onClick(View v) {  </p>
<p>//开启服务器  </p>
<p>        ServerThread startServerThread = new ServerThread();  </p>
<p>        startServerThread.start();  </p>
<p>    }  </p>
<p>/** </p>
<p>     * 开启服务器 </p>
<p>     */  </p>
<p>private class ServerThread extends Thread {  </p>
<p>public void run() {  </p>
<p>try {  </p>
<p>                BluetoothServerSocket mserverSocket = BTAdapter.listenUsingRfcommWithServiceRecord(&quot;btspp&quot;,  </p>
<p>                        UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));  </p>
<p>                show(&quot;服务端:等待连接&quot;);  </p>
<p>                BTSocket = mserverSocket.accept();  </p>
<p>                show(&quot;服务端:连接成功&quot;);  </p>
<p>                readThread mreadThread = new readThread();  </p>
<p>                mreadThread.start();  </p>
<p>                show(&quot;服务端:启动接受数据&quot;);  </p>
<p>            } catch (IOException e) {  </p>
<p>                e.printStackTrace();  </p>
<p>            }  </p>
<p>        }  </p>
<p>    }  </p>
<p>/** </p>
<p>     * 读取数据 </p>
<p>     */  </p>
<p>private class readThread extends Thread {  </p>
<p>public void run() {  </p>
<p>byte[] buffer = new byte[1024];  </p>
<p>int bytes;  </p>
<p>            InputStream mmInStream = null;  </p>
<p>try {  </p>
<p>                mmInStream = BTSocket.getInputStream();  </p>
<p>                show(&quot;服务端:获得输入流&quot;);  </p>
<p>            } catch (IOException e1) {  </p>
<p>                e1.printStackTrace();  </p>
<p>            }  </p>
<p>while (true) {  </p>
<p>try {  </p>
<p>if ((bytes = mmInStream.read(buffer)) &gt; 0) {  </p>
<p>byte[] buf_data = new byte[bytes];  </p>
<p>for (int i = 0; i &lt; bytes; i++) {  </p>
<p>                            buf_data[i] = buffer[i];  </p>
<p>                        }  </p>
<p>                        String s = new String(buf_data);  </p>
<p>                        show(&quot;服务端:读取数据了~~&quot; + s);  </p>
<p>                    }  </p>
<p>                } catch (IOException e) {  </p>
<p>try {  </p>
<p>                        mmInStream.close();  </p>
<p>                    } catch (IOException e1) {  </p>
<p>                        e1.printStackTrace();  </p>
<p>                    }  </p>
<p>break;  </p>
<p>                }  </p>
<p>            }  </p>
<p>        }  </p>
<p>    }  </p>
<p>}  </p>
<p>（二）客户端</p>
<p>实现思路：</p>
<p>1、检查是否开启蓝牙。</p>
<p>2、注册一系列蓝牙的广播。</p>
<p>3、由于蓝牙每经过一个阶段都会发送一个广播，根据广播来实现对应的方法。</p>
<p>4、蓝牙配对-&gt;蓝牙连接-&gt;发送消息（UUID必须相同）</p>
<p>其实客户端的操作就是上面那张思路图，根据里面的步骤进行就可以完成</p>
<p>① 检查蓝牙</p>
<p>[java] view plain copy</p>
<p>/** </p>
<p> * 检查蓝牙 </p>
<p> */  </p>
<p>public void checkBT(Context context) {  </p>
<p>    BTAdapter = BluetoothAdapter.getDefaultAdapter();  </p>
<p>if (BTAdapter != null) {  </p>
<p>if (!BTAdapter.isEnabled()) {  </p>
<p>            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);  </p>
<p>// 设置蓝牙可见性，最多300秒  </p>
<p>            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);  </p>
<p>            context.startActivity(intent);  </p>
<p>        }  </p>
<p>    } else {  </p>
<p>        show(&quot;本地设备驱动异常!&quot;);  </p>
<p>    }  </p>
<p>}  </p>
<p>② 注册广播</p>
<p>[java] view plain copy</p>
<p>/** </p>
<p> * 注册广播 </p>
<p> */  </p>
<p>public void registerBTReceiver() {  </p>
<p>// 设置广播信息过滤  </p>
<p>    IntentFilter intentFilter = new IntentFilter();  </p>
<p>    intentFilter.addAction(BluetoothDevice.ACTION_FOUND);  </p>
<p>    intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED);  </p>
<p>    intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);  </p>
<p>    intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);  </p>
<p>    intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);  </p>
<p>// 注册广播接收器，接收并处理搜索结果  </p>
<p>    registerReceiver(BTReceive, intentFilter);  </p>
<p>}  </p>
<p>③ 搜索附近设备</p>
<p>[java] view plain copy</p>
<p>BTAdapter.startDiscovery();  </p>
<p>④ 获取搜索到设备的通知</p>
<p>[java] view plain copy</p>
<p>/** </p>
<p> * 广播接收者 </p>
<p> */  </p>
<p>private BroadcastReceiver BTReceive = new BroadcastReceiver() {  </p>
<p>@Override  </p>
<p>public void onReceive(Context context, Intent intent) {  </p>
<p>        String action = intent.getAction();  </p>
<p>//打印Action，调试使用  </p>
<p>        show(action);  </p>
<p>//找到设备通知  ACTION_FOUND,设备已配对通知  ACTION_BOND_STATE_CHANGED  </p>
<p>if (BluetoothDevice.ACTION_FOUND.equals(action)) {  </p>
<p>            device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  </p>
<p>            show(&quot;客户端:找到的BT名:&quot; + device.getName());  </p>
<p>// 如果查找到的设备符合，添加到UI上  </p>
<p>            addBT();  </p>
<p>        } else if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {  </p>
<p>// 获取蓝牙设备的连接状态  </p>
<p>int connectState = device.getBondState();  </p>
<p>// 已配对  </p>
<p>if (connectState == BluetoothDevice.BOND_BONDED) {  </p>
<p>try {  </p>
<p>                    show(&quot;客户端:开始连接:&quot;);  </p>
<p>                    clientThread clientConnectThread = new clientThread();  </p>
<p>                    clientConnectThread.start();  </p>
<p>                } catch (Exception e) {  </p>
<p>                    e.printStackTrace();  </p>
<p>                }  </p>
<p>            }  </p>
<p>        }  </p>
<p>    }  </p>
<p>};  </p>
<p>/** </p>
<p> * 添加找到的BT </p>
<p> */  </p>
<p>private void addBT() {  </p>
<p>    Button bt = new Button(MainActivity.this);  </p>
<p>    bt.setTag(device.getName());  </p>
<p>    bt.setText(device.getName());  </p>
<p>    ly_device.addView(bt);  </p>
<p>//处理选中BT设备，进行绑定  </p>
<p>    bt.setOnClickListener(new View.OnClickListener() {  </p>
<p>@Override  </p>
<p>public void onClick(View v) {  </p>
<p>            bondBT((String) v.getTag());  </p>
<p>        }  </p>
<p>    });  </p>
<p>}  </p>
<p>/** </p>
<p> * 绑定蓝牙 </p>
<p> * </p>
<p> * @param deviceName </p>
<p> */  </p>
<p>private void bondBT(String deviceName) {  </p>
<p>if (device.getName().equalsIgnoreCase(deviceName)) {  </p>
<p>        show(&quot;客户端:配对蓝牙开始&quot;);  </p>
<p>// 搜索蓝牙设备的过程占用资源比较多，一旦找到需要连接的设备后需要及时关闭搜索  </p>
<p>        BTAdapter.cancelDiscovery();  </p>
<p>// 获取蓝牙设备的连接状态  </p>
<p>int connectState = device.getBondState();  </p>
<p>switch (connectState) {  </p>
<p>// 未配对  </p>
<p>case BluetoothDevice.BOND_NONE:  </p>
<p>                show(&quot;客户端:开始配对&quot;);  </p>
<p>try {  </p>
<p>                    Method createBondMethod = BluetoothDevice.class.getMethod(&quot;createBond&quot;);  </p>
<p>                    createBondMethod.invoke(device);  </p>
<p>                } catch (Exception e) {  </p>
<p>                    e.printStackTrace();  </p>
<p>                }  </p>
<p>break;  </p>
<p>// 已配对  </p>
<p>case BluetoothDevice.BOND_BONDED:  </p>
<p>try {  </p>
<p>                    show(&quot;客户端:开始连接:&quot;);  </p>
<p>                    clientThread clientConnectThread = new clientThread();  </p>
<p>                    clientConnectThread.start();  </p>
<p>                } catch (Exception e) {  </p>
<p>                    e.printStackTrace();  </p>
<p>                }  </p>
<p>break;  </p>
<p>        }  </p>
<p>    }  </p>
<p>}  </p>
<p>⑤ 进行连接</p>
<p>[java] view plain copy</p>
<p>/** </p>
<p> * 开启客户端 </p>
<p> */  </p>
<p>private class clientThread extends Thread {  </p>
<p>public void run() {  </p>
<p>try {  </p>
<p>//创建一个Socket连接：只需要服务器在注册时的UUID号  </p>
<p>            BTSocket = device.createRfcommSocketToServiceRecord(UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));  </p>
<p>//连接  </p>
<p>            show(&quot;客户端:开始连接…&quot;);  </p>
<p>            BTSocket.connect();  </p>
<p>            show(&quot;客户端:连接成功&quot;);  </p>
<p>//启动接受数据  </p>
<p>            show(&quot;客户端:启动接受数据&quot;);  </p>
<p>            readThread mreadThread = new readThread();  </p>
<p>            mreadThread.start();  </p>
<p>        } catch (IOException e) {  </p>
<p>            show(&quot;客户端:连接服务端异常！断开连接重新试一试&quot;);  </p>
<p>            e.printStackTrace();  </p>
<p>        }  </p>
<p>    }  </p>
<p>}  </p>
<p>⑥ 读取数据</p>
<p>[java] view plain copy</p>
<p>/** </p>
<p> * 读取数据 </p>
<p> */  </p>
<p>private class readThread extends Thread {  </p>
<p>public void run() {  </p>
<p>byte[] buffer = new byte[1024];  </p>
<p>int bytes;  </p>
<p>        InputStream is = null;  </p>
<p>try {  </p>
<p>            is = BTSocket.getInputStream();  </p>
<p>            show(&quot;客户端:获得输入流&quot;);  </p>
<p>        } catch (IOException e1) {  </p>
<p>            e1.printStackTrace();  </p>
<p>        }  </p>
<p>while (true) {  </p>
<p>try {  </p>
<p>if ((bytes = is.read(buffer)) &gt; 0) {  </p>
<p>byte[] buf_data = new byte[bytes];  </p>
<p>for (int i = 0; i &lt; bytes; i++) {  </p>
<p>                        buf_data[i] = buffer[i];  </p>
<p>                    }  </p>
<p>                    String s = new String(buf_data);  </p>
<p>                    show(&quot;客户端:读取数据了&quot; + s);  </p>
<p>                }  </p>
<p>            } catch (IOException e) {  </p>
<p>try {  </p>
<p>                    is.close();  </p>
<p>                } catch (IOException e1) {  </p>
<p>                    e1.printStackTrace();  </p>
<p>                }  </p>
<p>break;  </p>
<p>            }  </p>
<p>        }  </p>
<p>    }  </p>
<p>}  </p>
<p>⑦ 发送数据</p>
<p>[java] view plain copy</p>
<p>/** </p>
<p> * 发送数据 </p>
<p> */  </p>
<p>public void sendMessage() {  </p>
<p>if (BTSocket == null) {  </p>
<p>        Toast.makeText(this, &quot;没有连接&quot;, Toast.LENGTH_SHORT).show();  </p>
<p>return;  </p>
<p>    }  </p>
<p>try {  </p>
<p>        OutputStream os = BTSocket.getOutputStream();  </p>
<p>        os.write(&quot;我爱你dahsid132456@#%￥*&quot;.getBytes());  </p>
<p>        os.flush();  </p>
<p>        show(&quot;客户端:发送信息成功&quot;);  </p>
<p>    } catch (IOException e) {  </p>
<p>        e.printStackTrace();  </p>
<p>    }  </p>
<p>}  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android LCD(一)：LCD基本原理篇</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20LCD(%E4%B8%80)%EF%BC%9ALCD%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    <content><![CDATA[<p>LCD的种类分类标准比多，按驱动方式可以分为：被动矩阵式、主动矩阵式两种<br>被动矩阵式：被动矩阵式LCD又可分为TN-LCD(TwistedNematic-LCD，扭曲向列LCD)、STN—LCD(SuperTN-LCD，超扭曲向列LCD)和DSTN-LCD(Doublelayer STN-LCD，双层超扭曲向列LCD)。这部分内容就不详细解释， 我们重点讲TFT-LCD。<br>主动矩阵式:目前应用比较广泛的主动矩阵式LCD，也称TFT-LCD。TFT-LCD 即是Thin-FilmTransistor Liquid-Crystal Display的缩写(薄膜电晶体液晶显示器)TFT-LCD如何点亮?TFT-LCD现在比较广泛的应用，我们从TFT-LCD说起。<br>TFT-Thin Film Transistor  薄膜电晶体<br>LCD-Liquid Crystal Display液晶显示器<br>TFT-LCD Transistor Liquid-CrystalDisplay的缩写(薄膜电晶体液晶显示器)<br>由于TFT-LCD具有体积小，重量轻，低辐射，低耗电量，全彩化等优点，因此在各类显示器材上得到了广泛的应用。<br>一、TFT-lCD 的结构<br>1、TFT-LCD 的结构如下图所示</p>
<p>Reflector:反光板</p>
<p>CCF lamps：冷光灯管</p>
<p>Ligh pipe：导光片</p>
<p>Extraction pattern：</p>
<p>Diffuser：散光板，起散光作用，使光线散布较为均匀</p>
<p>这部分主要是光源部分，CCFL或者LED背光光源，其他反光板、散光板，作用是这些光分布的更均匀</p>
<p>Rear polarizer：后部偏光片</p>
<p>Front Polarizer：前端偏光片</p>
<p>偏光片的作用把自然光变成偏极光</p>
<p>Selected Subpixels：子像素</p>
<p>TFT：</p>
<p>Liquid crystal：液晶</p>
<p>Color filters：彩色滤色片</p>
<p>这部分是LCD的核心部分，选择光源的导通、阻断，彩色在这部分控制。</p>
<p>Back glass：背部玻璃基板</p>
<p>Front glass：前部玻璃基板</p>
<p>起保护作用</p>
<p>TFT-LCD各结构的功能<br>（1）、背光板模组:提供光的来源;<br>（2）、上下偏光板，TFT Glass Substrate，液晶：形成偏振光，控制光线的通过与否;<br>（3）、彩色滤光片：提供TFT LCD红、绿、蓝(光的三原色)的来源;<br>（4）、ITO透明导电层：提供透明的导电通路;<br>（5）、Photo Spacer：提供一固定高度給彩色滤光片和TFT Glass Substrate。作为灌入液晶时的空间.及作为上下两层Glass的支撑。<br>2、TFT-LCD 结构侧视图   </p>
<p>一、TFT-LCD显示原理<br>1、 液晶的背光<br>背光也就是显示器的光源，LCD的背光常用有两种：CCFL背光、LED背光<br>（1）、CCFL Cold Cathode Fluorescent Lamp简称CCFL，中文译名为冷阴极光灯管，具有高功率、高亮度、低能耗等优点，广泛应用于显示器、照明等领域。</p>
<p>（2）、LED背光<br>相对于CCFL,LED有功耗低、光源均匀、寿命长、体积小的优势，价格方面会贵点，不过现在平板上用的TFT-lCD好像都是LED背光的，上次搞破了一片顺便拆开看了下。</p>
<p>（3）、LED与LED背光<br>市面上所谓LED显示器，其实是“LED背光液晶显示器”；现在流行的液晶显示器，属于“CCFL背光液晶显示器”。所以此二者仍是液晶显示器，只是背光源不一样而已。不要看到LED显示器就误以为是下一代技术显示器，其实技术最新的是叫OLED。所以在买电视的时候不要被忽悠了。<br>2、液晶简介<br>（1）、液晶晶体的形状<br>TFT-LCD使用的液晶为TN（Twist Nematic）型液晶，液晶分子呈椭圆状。</p>
<p>（2）、液晶的特性<br>TN型液晶一般是顺着长轴方向串接，长轴间彼此平行方式排列。当接触到槽装表面时，液晶分子就会顺着槽的方向排列于槽中。</p>
<p>（3）、液晶垂直分布<br>当液晶被包含在两个槽状表面中间，且槽的方向互相垂直，则液晶分子的排列为：<br>上表面分子：沿着a方向；<br>下表面分子：沿着b方向；<br>介于上下表面中间的分子：产生旋转的效应。因此液晶分子在两槽状表面间产生90度的旋转。</p>
<p>（4）光与液晶分子产生偏转效果</p>
<p>（5）、液晶在电压做用下均匀分布<br>当在上下表面之间加电压时，液晶分子会顺着电场方向排列，形成直立排列的现象。此时入射光线不受液晶分子影响，直线射出下表面。</p>
<p>3、偏光板的特性<br>作用：将非偏极光（一般光线）过滤成偏极光。当非偏极光通过a方向的偏光片时，光线被过滤成与a方向平行的线性偏极光。<br>上图：线性偏极光继续前进，通过第二片偏光片时，光线通过。<br>下图：通过第二片时，光线被完全阻挡。</p>
<p>偏光板、槽状表面、液晶组合后产生的光学效果，如下图所示</p>
<p>（1）、当上下偏光片相互垂直时，若未施加电压，光线可通过</p>
<p>（2）、当施加电压时，光线被完全阻挡</p>
<p>当电流通过电晶体产生电场变化，造成液晶分子偏转，借以改变光线的偏极性，再利用偏光片决定画素(Pixel)的明暗状态。这样就可以实现对光线亮暗的控制，如果要显示彩色，我们后面在讲彩色滤光片。</p>
<p>4、彩色滤光片原理 color fliters<br>（1）、C/F 的结构<br>像之前像素低的显示器仔细都能看得到这些方格。比较简单的方法，在显示器上放一个水滴，你就可以看到红、绿、蓝、三色的点。</p>
<p>（2）、C/F Pixel Array的常见排列方式<br>如下图所示分别是马赛克、直条式、三角形式、四画素。</p>
<p>（3）、不同颜色的显示<br>我们再看下我们要显示相应颜色时，控制相应的pixel electrode就可以。如下图所示：</p>
<p>C/F彩色单元，对应到TFT的控制单元，就可以完成我们像素点颜色的控制。TFT Array 等效电路如下图所示：</p>
<p>三、TFT-LCD显像原理<br>我们前面解释了液晶透光原理、偏光片透光原理、彩色滤光片工作原理，这些把他理解成一个像素控制单元，然后我们来整理下TFT-LCD整体的显示原理。<br>（1）、SCAN IC传输信号；<br>完成图像信号输入；<br>（2）、DRIVER IC传输显像控制信号；<br>完成TFT单元控制；<br>（3）、当某一Sub-Pixel导通时，该Sub-Pixel因无法透光呈现黑色；<br>这部分完成像素点是亮还是暗。<br>（4）、若该Sub-Pixel未导通，则因光通过CF而显示颜色。经过光的合成效果，显示器即可产生彩色效果。如下图所示：</p>
<p>现在回头看我们开始那张结构图是不是清晰一点了：光源部分先把自然光通过偏光片转成偏极光–&gt;TFT subpixels单元控制液晶单元是否导光、色彩–&gt;通过前置偏光片把色彩图像显示。其实图像也就是不同色彩的光，我们看到的光其实也是偏极光。</p>
<p>这张图好像跟清晰的描述：</p>
<p>四、LCD常用到的知识点<br>1、残影<br>残影是指画面切换之后前一个画面不会立刻消失而是慢慢不见的现象，残影与反应时间不算同一件事，残影可能要两三秒后才会完全消失，而液晶的反应时间是十几到几十毫秒。一个设计得好的液晶显示器，就算反应时间是 15+35ms，也不可能让使用者看到残影。<br>残影发生机制有些复杂，通常是同一画面显示太久的情况下液晶内的带电离子吸附在上下玻璃两端形成内建电场，画面切换之后这些离子没有立刻释放出来，使得液晶分子没有立刻转到应转的角度所造成。另外一种可能情况则是因为画素电极设计不良，使得液晶分子在状态切换时排列错乱，这种情况之下也有可能看到残影。</p>
<p>2、坏点(dot defect)<br>所谓坏点, 是指液晶显示器上无法控制的恒亮或恒暗的点，坏点的造成是液晶面板生产时因各种因素造成的瑕疵可能是颗粒物落在面板里面，可能是静电伤害破坏面板，可能是制程控制不良等等等。坏点分为两种:亮点与暗点。一般来说，亮点会比暗点更令人无法接受，所以很多厂商会保证无亮点，但好象比较少保证无暗点的，有些面板厂商会在出货前把亮点修成暗点。<br>面板厂商会把有坏点的面板降价卖出，通常是无坏点算A grade，三点以内算B grade，六点以内算C grade。<br>市场上现在好多公司做平板，用IPAD2、IPAD3、MINIPAD的屏，然后在宣传产品时拿苹果说事，跟苹果比较，国内这些公司真实搞笑。其实他们用的屏就是生产过程中苹果检验通不过的屏，比如苹果只用A+的屏，A-包括A-以下等级的屏，都流入市场，国内的平板都是垃圾，虽然我也一直做这些东西，环境不好。</p>
<p>3、mura<br>mura本来是一个日本字，意思不均匀，有斑点，随着日本的液晶显示器在世界各地发扬光大。mura是指显示器亮度不均匀造成各种痕迹的现象，最简单的判断方法就是在暗室中切换到黑色画面以及其它低灰阶画面，然后从各种不同的角度用力去看，有问题的显示器比较容易看出。</p>
<p>4、色饱和度 (color gamut)<br>色饱和度是指显示器色彩鲜艳的程度，显示器是由红色绿色蓝色三种颜色光来组合成任意颜色光，如果RGB三原色越鲜艳, 则该显示器可以表示的颜色范围就更广。</p>
<p>5、亮度<br>亮度是指显示器在白色画面之下明亮的程度，单位是cd/m^2, 或是nit。亮度是直接影响画面品质的重要因素。在实验室里面我们常讲一句话:“一亮遮三丑”。一个明亮的显示器即使色饱和度比较差或颜色偏黄等其它不利因素，还是有可能看起来画面会比较漂亮。<br>亮度跟灯光有关了，灯管有寿命的，尤其是比较早的CCFL背光的，时间久了会发黄，这个如果家里有比较老的显示器就能明显的感受到。</p>
<p>6、视角<br>液晶显示器由于天生的物理特性, 使得使用者从不同角度去看时画面品质会 有所变化. 与正看时相比, 斜看的时候, 转到当画面品质已经变化到无法接受的临界角度时, 称之为该显示器之视角.</p>
<p>7、色温(color temperature):<br>色温是用来形容显示器的白色的颜色，不限于LCD, 所有的显示器都通用，当显示器的颜色与黑体的温度高到某一绝对温度时所发出来的光一样时，称为该显示器的色温等于该温度。比如说，当显示器的白色设计成接近，黑体在温度6500K的时候所发出来的光颜色(接近晴天时上午的太阳光)，称为该显示器的色温为6500K。<br>色温越低颜色会越偏黄色，色温越高颜色会越偏蓝色，一个色温偏高的显示器在秀图片的时候整个画面看起来色调就会偏蓝。</p>
<p>8、Gamma Curve:<br>Gamma curve是指不同灰阶与亮度的关系曲线。把零到二五五灰阶当x轴, 亮度当y轴, 画出来的曲线就叫做gamma curve. Gamma curve通常不会是一条直线,因为人眼对不同亮度有不同辨识的效果, 比如说低亮度的辨识能力较高(一点点亮度变化就有感觉)。<br>五、LCD调试过程常用到的图片下载<br>下载链接：LCD常用测试图片，这里面有色阶、彩条之类的图片。调试效果时用到的。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ARM基础</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ARM%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>一 ARM主要课程内容</p>
<p>1 ARM编程模型</p>
<p> 硬件: ARM9 fs2410  电路原理</p>
<p> 软件:寄存器 体系结构 指令系统 指令集</p>
<p>2 ARM编程技术</p>
<p>  汇编/C语言 编译 链接 烧写 调试</p>
<p>  windows: MDK</p>
<p>  linux: gcc</p>
<p>3 ARM接口编程</p>
<p>  原理图</p>
<p>  datasheet ==&gt;裸奔程序</p>
<p>LED timer 中断 uart等(裸奔程序:不带操作系统,直接操作硬件)</p>
<p>  中断技术</p>
<p>  初始化程序</p>
<p>二 ARM基础知识</p>
<p>1 软件和硬件关系:</p>
<p>没有硬件支持的软件是空中楼阁,没有软件支持的硬件是一堆废铁</p>
<p>2  冯诺依曼体系结构</p>
<p>  数据和指令采用二进制表示</p>
<p>  存储程序</p>
<p>  PC指针</p>
<p>  五大部件(运算器 控制器 存储器 输入/输出设备)</p>
<p>3 硬件组成</p>
<p>学习路线:</p>
<p>core -&gt; soc -&gt; 接口</p>
<p>4 存储器</p>
<p>  RAM:(易失性)掉电丢失数据</p>
<p>SRAM:静态 片内 4KB</p>
<p>DRAM:动态 SDRAM 64MB DDRII等</p>
<p>  ROM:(非易失性)掉电不丢失数据 只读</p>
<p>PROM</p>
<p>EPROM</p>
<p>E2PROM</p>
<p>BIOS</p>
<p>  flash:</p>
<p>norflash:</p>
<p>(或非) 88年 intel</p>
<p>有地址 片上执行(CPU可以直接访问) </p>
<p>读写速度总体上没有nandflash快,存储启动程序</p>
<p>nandflash:(与非)</p>
<p>89年 toshiba</p>
<p>无地址 不能偏上执行,</p>
<p>读写速度快,主要用于存储大量数据</p>
<p> fs2410存储系统层次结构</p>
<p>CPU</p>
<p>寄存器组: 内核 (37个bit)</p>
<p>cache : 缓存 I/D cache 16kB*2 (I-指令 D-数据)</p>
<p>加快计算机访问速度</p>
<p>SRAM : 片内 4KB</p>
<p>SDRAM : 板卡 64MB</p>
<p>norflash: 板卡 2MB</p>
<p>nandflash: 外设 64MB</p>
<p>总线:</p>
<p>地址总线:AB</p>
<p>数据总线:DB</p>
<p>控制总线:CB</p>
<p>AMBA : AHB(高速) APB(低速)</p>
<p>三 ARM体系结构</p>
<p>1 为什么学习ARM?</p>
<p>嵌入式使用比较多的一款芯片,</p>
<p>它是32位机,应用广泛,功耗低,运算速度快,</p>
<p>市场份额达到90%以上</p>
<p>2 ARM:</p>
<p>advanced RISC machine</p>
<p>RISC:精简指令集</p>
<p>            指令长度固定(32bit)</p>
<p>    单周期执行</p>
<p>    规整 代码量少 容易实现流水线(关键技术)</p>
<p>    大量寄存器(37个32bit)</p>
<p>    访存简单</p>
<p>    简单的指令实现复杂的操作</p>
<p>CISC:</p>
<p>  含义:</p>
<p>一家公司</p>
<p>一门技术</p>
<p>一类微处理器</p>
<p>四 编程模型</p>
<p>1 设置目的和目标:</p>
<p>掌握ARM处理的数据类型</p>
<p>掌握ARM内核的基本工作原理</p>
<p>掌握ARM处理器的寄存器</p>
<p>2 了解一款CPU</p>
<p>体系结构</p>
<p>指令集</p>
<p>寄存器</p>
<p>3 数据类型</p>
<p>字节:8bit</p>
<p>半字:16bit(2个字节)</p>
<p>字  :32bit(4个字节)</p>
<p>cpu一个地址 对应 一个字节</p>
<p>对齐:</p>
<p>字对齐: (4字节) [1:0] = 00  被4整除</p>
<p>半字对齐: (2字节) [0]   = 0   被2整除</p>
<p>4 处理器的工作模式</p>
<p>工作模式:CPU提供一种处理机制</p>
<p>用户模式 usr 不能直接切换到其他模式</p>
<p>系统模式 sys 可以直接切换到其他模式</p>
<p>管理模式 svc 系统复位、软件中断响应</p>
<p>中止模式 abt 对程序存储器和数据存储器访问失败</p>
<p>未定义   und 未定义</p>
<p>中断 irq IRQ异常</p>
<p>快速中断 fiq FIQ异常</p>
<p>寄存器(37个32bit)</p>
<p>CPU不同的工作模式 对应 资源(寄存器)不同</p>
<p>多种寄存器减少时间开销,提高运算的速度和工作效率</p>
<p>CPSR:</p>
<p>  31   30 29    28</p>
<p>标识域 F (N(Negative)  Z(zero)  C(Carried) V(verflowed)  </p>
<p>27 Q(饱和)  24J(jazelle)</p>
<p>系统域 S </p>
<p>扩展域 X</p>
<p>控制域 C (I F T   mode)</p>
<p>  7 6 5   4-0</p>
<p>PC:pc指针指向哪里,程序运行到哪里</p>
<p>5 异常处理过程</p>
<p>异常产生:(硬件自动完成)</p>
<p>1 CPSR–&gt;SPSR_mode</p>
<p>2 设置CPSR</p>
<p>CPSR[5] = 0 (处于ARM状态)</p>
<p>CPSR[4:0] = mode</p>
<p>CPSR[7:6] = 11 (根据实际情况)</p>
<p>3 返回地址–&gt;LR_mode</p>
<p>4 PC = 异常向量表的入口地址</p>
<p>5 保护现场(程序可选)</p>
<p>异常退出:(程序员)</p>
<p>1 SPSR_mode –&gt; CPSR</p>
<p>2 LR_mode  –&gt;  pc</p>
<p>3 恢复现场(堆栈)</p>
<p>异常产生或者退出的时候一定是处于ARM状态</p>
<p>6 ARM发展</p>
<p>ARCH V4T</p>
<p>family core ARM9TDMI</p>
<p>core ARM920T</p>
<p>soc S3C2410</p>
<p>board fs2410</p>
<p>五 指令集</p>
<p>1 格式:</p>
<p>    操作码 + 目标寄存器 + op1 + op2…</p>
<p>|–助记符</p>
<p>|–条件码</p>
<p>2 操作数基本寻址方式</p>
<p>立即数 mov r0,#1</p>
<p>寄存器寻址 mov r0,r1</p>
<p>移位寻址 mov r0,r1,lsl #2</p>
<p>间接寻址 ldr r0,[r1]</p>
<p>基址寻址 ldr r0,[r1,#2]</p>
<p>多寄存器寻址 ldmia r0!,{r0-r7}</p>
<p>堆栈寻址 ldmfd sp!,{r0-r15,lr}</p>
<p>相对寻址 b lable</p>
<p>六 系统设计</p>
<p>1 SOC概念:</p>
<p>ARM芯片 = ARM核 + 片内的存储器  + 片内外围电路</p>
<p>S3C2410   ARM920T  SRAM 各种接口电路</p>
<p>2 ARM处理器内核</p>
<p>流水线:</p>
<p>ARM状态:        PC值 = 当前执行指令地址 + 8     (取值地址)</p>
<p>Thumb状态: PC值 = 当前执行指令地址 + 4</p>
<p>3 ARM920T = ARM9TDMI + I/D cache + MMU + CP14 + CP15</p>
<p>                      16KB  (内存管理单元)(调试)(管理/ARM cache控制器)</p>
<p>七 总结</p>
<p>1 体系结构</p>
<p>7种工作模式</p>
<p>状态:ARM/Thumb</p>
<p>寄存器组可见性 特殊性(CPSR  PC)</p>
<p>异常处理过程(进入/退出)</p>
<p>2 指令集</p>
<p>ARM指令集:8种基本寻址方式 数据处理 跳转指令</p>
<p>3 SOC/core</p>
<p>4 流水线</p>
<p>PC值:ARM/THUMB</p>
<p>八 实验</p>
<p>start size</p>
<p>ROM1:norflash 0x0 0x200000 2M</p>
<p>RAM1:SDRAM 0x30000000 0x4000000 64M</p>
<p>IRAM1:SRAM 0x40000000 0x1000 4k</p>
<p>R/O: .text 运行代码段</p>
<p>R/W: .data 静态 全局变量 已初始化的变量</p>
<p>ZI : .bss 零初始化</p>
<p>操作码=助记符+条件码</p>
<p>条件码是一种简化测试ALU状态的方法</p>
<p>简化对CPSR特定位精确测试</p>
<p>CMP r3,#0    //影响CPSR</p>
<p>BEQ skip</p>
<p>ADD r0,r1,r2 //ADDNE r0,r1,r2</p>
<p>skip</p>
<p>//添加S 可以影响标志位</p>
<p>SUBS r1,r1,#1</p>
<p>分支指令：//位置无关 //不因pc当前值变化而变化</p>
<p>B label</p>
<p>BL label  //fun  </p>
<p>BX label  //arm-thumb</p>
<p>跳转范围 +/- 32M  /2^26=64M</p>
<p>长跳转 LDR PC，=label</p>
<p>：PC+偏移量(24bit&lt;&lt;2)//pc值+offset&lt;&lt;2</p>
<p>BIC:rd,rn,operand2 //位清0  rd&lt;-rn&amp;(~operand2)</p>
<p>ORR:rd,rn,operand2 //位置1  rd&lt;-rn|operand2</p>
<p>AND:rd,rn,operand2 //逻辑与 位屏蔽</p>
<p>EOR:rd,rn,operand2 //位反转,异或</p>
<p>CMP:不要结果比较，影响cpsr</p>
<p>SUB:要结果减，不影响cpsr</p>
<p>TST:不要结果，位测试，影响CPSR</p>
<p>AND:要结果</p>
<p>RSB:rd,rn,operand2 //rd&lt;-operand2-rn</p>
<p>RSC:带进位，逆向减法</p>
<p>MOV:数据传送</p>
<p>MVN:数据非 传送</p>
<p>立即数:[11:0] </p>
<p>//用8位常数循环右移2*移位次数</p>
<p>8位图(只有8位常数)</p>
<p>1.找出8位常数：从立即数中找到第一个1，和最后一个1的距离，不大于8</p>
<p>2.把找出的8位常数，循环右移偶数次，还原8位常数</p>
<p>ldr r0, =const 伪指令(无直接对应机器码)</p>
<p>1.当const是8位图常数， mov r0,#const</p>
<p>2.当const不是8位图常数， ldr r0, [pc,#offset]</p>
<p>!，自动更新寄存器</p>
<p>寄存器传送指令：</p>
<p>LDR:加载字数据 –&gt;rd</p>
<p>STR:存储字数据 –&gt;addr</p>
<p>堆栈：满递减</p>
<p>STMFD:   //(压栈)多寄存器存储  </p>
<p>LDMFD:   //(出栈)多寄存器加载</p>
<p>LDMFD SP!,{r0-r7,lr}^</p>
<p>^ 列表里有PC时，恢复SPSR操作 spsr_mode-&gt;cpsr</p>
<p>SWP:寄存器与存储器数据交换 原子操作</p>
<p>SWI:num 软中断</p>
<p>异常是由指令本身引起的，计算LR时，PC值并没有被更新</p>
<p>PSR传送指令：</p>
<p>MRS:psr-&gt;rd (读)</p>
<p>2012.04.12</p>
<p>异常：</p>
<p>遇到异常，工作模式切换，返回</p>
<p>进入异常arm core 自动完成：</p>
<p>1.cpsr -&gt; spsr_mode</p>
<p>2.cpsr 设置 </p>
<p>  [4:0] = mode</p>
<p>  [5] = 0 //arm</p>
<p>  [7:6] = 1 1 //禁中断</p>
<p>3.返回地址 -&gt; LR_mode</p>
<p>4.pc=异常向量表入口地址</p>
<p>5.保护现场(压栈)(程序员做)</p>
<p>返回，退出异常</p>
<p>1.spsr_mode -&gt; cpsr</p>
<ol start="2">
<li><p>lr_mode -&gt; pc</p>
</li>
<li><p>恢复现场(出栈)</p>
</li>
</ol>
<p>进入异常：LR_svc = PC - 4 //刚好下一条</p>
<p> &quot;指令带有S后缀，PC作为目的寄存器&quot;  </p>
<p> 或 &quot;^&quot; :  LDMFD sp! ,{px}^</p>
<p>S*WI Undef 返回：MOV pc,lr</p>
<p>FIQ IRQ   返回: SUBS pc,lr,#4</p>
<p>DataAbort 返回: SUBS pc,lr,#8</p>
<p>向量表跳转</p>
<p>1.B /BL lable  +/- 32M</p>
<ol start="2">
<li><p>ldr pc,=label</p>
</li>
<li><p>ldr pc, label(间接)</p>
</li>
</ol>
<p>处理FIQ时，禁止IRQ</p>
<p>使FIQ响应尽量快：</p>
<p>FIQ向量位于中断向量的最末</p>
<p>FIQ模式有5个额外私有寄存器(r8-r12)</p>
<p>可以有多个FIQ中断源</p>
<p>异常向量表：</p>
<p>0x1C FIQ 3</p>
<p>0x18 IRQ 4</p>
<p>0x14 reserved</p>
<p>0x10 Data Abort 2</p>
<p>0x0C Prefetch Abort 5</p>
<p>0x08 Software Interrupt 6</p>
<p>0x04 Undedfined Instruction 6</p>
<p>0x00 Reset 1</p>
<p>C中用 __irq (使用前确保堆栈指针已经被设置)</p>
<p>1.所有寄存器被保护</p>
<p>2.其他远程调用寄存器保护</p>
<p>3.pc=lr-4 spsr-&gt;cpsr</p>
<p>复位：</p>
<p>1.定义入口地址</p>
<p>2.建立异常向量表，实现向量表定义</p>
<p>3.初始化存储系统</p>
<p>4.时钟初始化，I/O，外围部件初始化</p>
<p>5.中断初始化</p>
<p>6.堆栈初始化</p>
<p>7.系统变量初始化</p>
<p>8.进入C程序运行</p>
<p>C/C++优代级别</p>
<p>-O0 -O1 -O2(default 完全优化)</p>
<p>ATPCS: ARM-Thumb Procedure Call Standard</p>
<p>r0-r3:传递参数</p>
<p>r4-r11:必须保护</p>
<p>r12:子程序内部调用</p>
<p>RAM:SDRAM SRAM</p>
<p>ROM:–&gt;EEPROM</p>
<p>flash:Norflash(有地址) Nandflash(无地址 4k拷到SRAM)</p>
<p>Norflash: 0x0 2M</p>
<p>SDRAM: 0x30000000 64M</p>
<p>SRAM 0x40000000 4k</p>
<p>加载地址：映象文件执行前的地址</p>
<p>运行地址：映象文件执行时的地址(连接地址)</p>
<p>ld  -Ttext 0x3000000 指定连接地址</p>
<p>ld  -Txxx.lds        lds文件来指定</p>
<p>//lds example</p>
<p>OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</p>
<p>OUTPUT_ARCH(arm)</p>
<p>ENTRY(XLOADER_ENTRY)</p>
<p>SECTIONS</p>
<p>{</p>
<p>    . = 0x00000000;</p>
<p>    . = ALIGN(4);</p>
<p>    .text    :</p>
<p>    {</p>
<p>      ./obj/init.o    (.text)</p>
<p>      *(.text)</p>
<p>    }</p>
<p>    .rodata . :</p>
<p>        {</p>
<p>                *(.rodata)</p>
<p>        }</p>
<p>        . = ALIGN(4);</p>
<p>    .data : { *(.data) }</p>
<p>    . = ALIGN(4);</p>
<p>    .got : { *(.got) }</p>
<p>    . = ALIGN(4);</p>
<p>    __bss_start = .;</p>
<p>    .bss : { *(.bss) }</p>
<p>    _end = .;</p>
<p>}</p>
<p>elf:包括目标文件(<em>.o)、可执行文件、共享目标文件(</em>.so *.a)</p>
<p>ELF header</p>
<p>.text</p>
<p>.rodata</p>
<p>.data</p>
<p>.bass</p>
<p>.symtab</p>
<p>.rel.text</p>
<p>.rel.data</p>
<p>.debug</p>
<p>.line</p>
<p>.strtab</p>
<p>Section header tables</p>
<p>elf:</p>
<p>1.映射不同存储区 权限管理</p>
<p>2.CPU cache 命中率</p>
<p>3.便于共享</p>
<p>readelf -h test</p>
<p>readelf -S test</p>
<p>size: 列出目标文件每一段大小及总大小</p>
<p>nm: 列出目标文件中的符号</p>
<p>strip:丢弃目标文件中全部或特定符号</p>
<p>strings:用来打印某个文件的可打印字符串</p>
<p>objdump:可以显示一个或者更多目标文件的信息，主要用来反编译</p>
<p>objcopy:可以进行目标文件格式转换</p>
<p>arm-linux-objcopy -O binary -S led_elf led.bin</p>
<p>arm-linux-objdump -D -m arm led_elf &gt; led.dis</p>
<p>arm-linux-ld: //可直接指定xx段的起始地址</p>
<p>-Ttext startaddress</p>
<p>-Tdata startaddress</p>
<p>-Tbss startaddress</p>
<p>GPIO:</p>
<p>GPxCON</p>
<p>GPxDAT</p>
<p>GPxUP:0 为内部上拉</p>
<p> 清0：&amp;=</p>
<p> 置1：|=</p>
<p> 存储控制器 13个寄存器</p>
<p> BANK 0-5  &lt;&lt;– BWSCON BANKCONx</p>
<p> BANK 6-7  &lt;&lt;–  -SDRAM –&gt; + REFRESH BANKSIZE  (SDRAM模式)MRSRB6 MRSRB7</p>
<p> BANK(128)*8 = 1G</p>
<p> BANK 0-6 固定</p>
<p> BANK0 : NOR Flash 0x0 0x001FFFFF 2M 16bit</p>
<p> BANK1 : IDE命令</p>
<p> BANK2 : IDE控制</p>
<p> BANK3 : 10M网卡CS8900A 0x19000000-0x190FFFFF 1M</p>
<p> BANK4 : 10/100M网卡DM9000   只有2个地址 0x20000000 0x00000004</p>
<p> BANK5 : 扩展串口A</p>
<p> BANK5 : 扩展串口B</p>
<p> BANK6 : SDRAM 0x30000000 0x33FFFFFF 64M</p>
<p>AHB(Advanced High performance Bus):CPU DMA DSP 间</p>
<p>APB(Advanced Peripheral Bus):低带宽</p>
<p>外围的</p>
<p>MPLL -&gt; FCLK、HCLK、PLCK </p>
<p>UPLL -&gt; USB</p>
<p>FCLK 用于CPU核</p>
<p>HCLK 用于AHB总线</p>
<p>PCLK 用于APB总线</p>
<p>MPLL -&gt;&gt; LOCKTIME MPLLCON CLKDIVN</p>
<p>2410:   </p>
<p>     MPLL(FCLK) = (m<em>Fin)/(p</em>2^s)</p>
<p>m = MDIV + 8, </p>
<p>p = PDIV + 2,</p>
<p>s = SDIV</p>
<p>PWM (Pulse Width Modulation)  </p>
<p>时钟源为:PCLK</p>
<p> time 0、1      &lt;&lt;– TCFG0 Prescaler0<a href="8%E4%BD%8D%E5%B8%B8%E6%95%B0">7:0</a></p>
<p> time 2、3、4   &lt;&lt;– TCFG0 Prescaler1[15:8]</p>
<ol>
<li><p>TCMBn TCNTBn</p>
</li>
<li><p>TCON –&gt;start  (TCMPBn TCNTBn value –&gt; TCMPn TCNTn)</p>
</li>
<li><p>TCNTn=TCMPn –&gt;TOUTn 反转 –&gt;中断</p>
</li>
<li><p>TCNTn==0  –&gt;TOUTn再次反转</p>
</li>
</ol>
<p>TCON:</p>
<p> 第一次装载:(TCMPBn TCNTBn value –&gt; TCMPn TCNTn)</p>
<p> 启动</p>
<p> 是否自动装载</p>
<p> 是否反转</p>
<p>UART(Universal Asynchronous Receiver Transmitter)</p>
<p>TTL/CMOS逻辑电平 –&gt; RS-232 逻辑电平 (3-12v)0 </p>
<ol>
<li><p>GPHCON –&gt; GPH2 GPH3 -&gt; TXD0 TXD0</p>
</li>
<li><p>UBRDIVn  = (int) (UART clock / (buad rate * 16)) -1</p>
</li>
<li><p>ULCONn (UART LINE CONTROL) //数据位宽度、停止位、校验模式、红外模式</p>
</li>
<li><p>UCONn  (UART CONTROL)//接收、发送、中断、时钟</p>
</li>
</ol>
<p>使用中断步骤：</p>
<p>1.设置好栈</p>
<p>2.准备中断处理函数 </p>
<p>  异向量表 中断服务程序 清除中断(写1) &quot;INTPND=INTPND&quot;</p>
<p>3.保护现场、恢复现场</p>
<p> IRQ:</p>
<p>  sub lr,lr,#4</p>
<p>stmdb sp!, {r0-r12,lr}</p>
<p>…</p>
<p>ldmia sp!, {r0-r12,pc}^</p>
<p> FIQ:</p>
<p>  sub lr,lr,#4</p>
<p>stmdb sp!, {r0-r7,lr}</p>
<p>…</p>
<p>ldmia sp!, {r0-r7,pc}^</p>
<p>4.触发方式 中断模式</p>
<ol start="5">
<li>FIQ IRQ (INTMOD)</li>
</ol>
<p> SUBSRCPND-&gt;INTSUBMSK-&gt;SRCPND-&gt;INTMSK-&gt;INTMOD PRIORITY</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android LCD(二)：LCD常用接口原理篇</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20LCD(%E4%BA%8C)%EF%BC%9ALCD%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    <content><![CDATA[<p>TFT-LCD常用的接口，TTL（RGB）、LVDS、EDP、MIPI,这篇我们大致说一下这些接口的信号组成已经基本原理。</p>
<p>一、TTL<br>1、TTL接口概述<br>TTL（Transistor Transistor Logic）即晶体管-晶体管逻辑，TTL电平信号由TTL器件产生。TTL器件是数字集成电路的一大门类，它采用双极型工艺制造，具有高速度、低功耗和品种多等特点。<br>TTL接口属于并行方式传输数据的接口，采用这种接口时，不必在液晶显示器的驱动板端和液晶面板端使用专用的接口电路，而是由驱动板主控芯片输出的TTL数据信号经电缆线直接传送到液晶面板的输人接口。</p>
<p>由于TTL接口信号电压高、连线多、传输电缆长，因此，电路的抗干扰能力比较差，而且容易产生电磁干扰（EMI）。在实际应用中，TTL接口电路多用来驱动小尺寸（15in以下）或低分辨率的液晶面板。</p>
<p>TTL最高像素时钟只有28MHz。<br>TTL是信号时TFT-LCD唯一能识别的信号，早期的数字处理芯片都是TTL的，也就是RGB直接输出到TFT-LCD。</p>
<p>2、TTL接口的信号类型<br>驱动板TTL输出接口中一般包含RGB数据信号、时钟信号和控制信号这三大类信号。如下图所示：</p>
<p>（1）RGB数据信号</p>
<p>a、单通道TTL</p>
<p>单通道6bit TTL输出接口<br>对于6bit单路TTL输出接口，共有18条RGB数据线，分别是R0～R5红基色数据6条，G0～G5绿基色数据6条，B0～B5蓝基色数据6条，共3<em>6=18条。由于基色RGB数据为18bit，因此，也称18位或18bitTTL接口。<br>单通道8bit TTL输出接口<br>对于8bit单路TTI，输出接口，共有24条RGB数据线，分别是R0～R7红基色数据8条，B0～B7绿基色数据8条，BO～B7蓝基色数据8条，共3</em>8=24条。由于基色RGB数据为24bit，因此，也称24位或24bitTTL接口。</p>
<p>b、双通道TTL<br>双通道，也就是两组RGB数据，分为奇通道、偶通道，时钟有的也分为OCLK/ECLK,有的公用一个，我们示意图上画了两个，如下所示：</p>
<p>双通道6bit TTL输出接口<br>对于6bit双路TTL，输出接口，共有36条RGB数据线，分别是奇路RGB数据线18条，偶路RGB数据线18条，3<em>6</em>2=36条。由于基色RGB数据为36bit，因此，也称36位或36bitTTL接口。<br>双通道8bit TTL输出接口<br>对于8bit双路TTL输出接口，共有48条RGB数据线，分别是奇路RGB数据线24条，偶路RGB数据线24条，3<em>8</em>2=48条。由于基色RGB数据为48bit，因此，也称48位或48bitTTL接口。</p>
<p>（2）时钟信号<br>是指像素时钟信号，是传输数据和对数据信号进行读取的基准。在使用奇/偶像素双路方式传输RGB数据时，不同的输出接口使用像素时钟的方法有所不同。有的输出接口奇/偶像素双路数据共用一个像素时钟信号，有的输出接口奇/偶两路分别设置奇数像素数据时钟和偶数像素两个时钟信号，以适应不同液晶面板的需要。<br>（3）控制信号<br>控制信号包括数据使能信号（或有效显示数据选通信号）DE、行同步信号HS、场同步信号VS。</p>
<p>二、LVDS</p>
<p>1、LVDS接口概述<br>LVDS，即Low Voltage Differential Signaling，是一种低压差分信号技术接口。克服以TTL电平方式传输宽带高码率数据时功耗大、EMI电磁干扰大等缺点而研制的一种数字视频信号传输方式。LVDS输出接口利用非常低的电压摆幅（约350mV）在两条PCB走线或一对平衡电缆上通过差分进行数据的传输，即低压差分信号传输。采用LVDS输出接口，可以使得信号在差分PCB线或平衡电缆上以几百Mbit／s的速率传输，由于采用低压和低电流驱动方式，因此，实现了低噪声和低功耗。</p>
<p>2、LVDS接口电路的组成<br>在液晶显示器中，LVDS接口电路包括两部分，即主板侧的LVDS输出接口电路（LVDS发送端）和液晶面板侧的LVDS输入接口电路（LVDS接收器）。LVDS发送端将TTL信号转换成LVDS信号，然后通过驱动板与液晶面板之间的柔性电缆（排线）将信号传送到液晶面板侧的LVDS接收端的LVDS解码IC中，LVDS接收器再将串行信号转换为TTL电平的并行信号，送往液晶屏时序控制与行列驱动电路。也就是其实TFT只识别TTL（RGB）信号。这部分我们做samsung的方案中用的比较多，因为samsung芯片没有LVDS输出，所以我们用LVDS接口的TFT-LCD的时候就要加一个（RGB-LVDS）转换芯片，这个后面我们重点说。</p>
<p>3、LVDS接口的信号类型<br>LVDS信号有数据差分和时钟差分信号组成。如下图所示：</p>
<p>（1）、单通道LVDS</p>
<p>单通道6位数据（如果是6位的Y3M/P这组红色的线没有）</p>
<p>有4组差分线，3组信号线，一组时钟线。Y0M、Y0P、Y1M、Y1P、Y2M、Y2P、CLKOUT_M、CLKOUT_P。</p>
<p>单通道8位数据</p>
<p>有5组差分线，4组信号线，一组时钟线。分别是Y0M、Y0P、Y1M、Y1P、Y2M、Y2P、Y3M、Y3P、CLKOUT_M、CLKOUT_P。</p>
<p>（2）、双通道</p>
<p> LVDS在传输分辨率较高的数据时，抗干扰能力比较强，可是1920X1080以上分辨率时，单路不堪重负，所以有双路接口出现。目的很简单，加快速度，增强抗干扰能力。<br>双通道6位数据<br>刚好是单通道的两倍，时钟也是两路，红色部分：Y3M、Y3P、Y3M1、Y3M1这两组信号不接。<br>双通道8位数据<br>和前面的比较类似。</p>
<p>三、EDP<br>这个接口比较陌生，我接触到一个屏IPAD3的，用于高清屏，比如2048<em>1536，goole n10的分辨率2536</em>  也是用这个接口。</p>
<p>(整理中…………)</p>
<p>四、MIPI接口<br>这个我们公司有产品用，不过是其他平台的，不是我们调试 ，我也没接触过。只是过一下。感觉这类接口非常类似：比如LVDS、EDP、HDMI、MIPI，都是差分信息+差分时钟。</p>
<p>(整理中…………)</p>
<p>五、TTL（RGB）转换成LVDS  </p>
<p>我们在项目中用到过两颗芯片：SN75LVDS83B 、THC63LVD827（可输出双路LVDS），以SN75LVDS83B来说明。</p>
<p>1、SN75LVDS83B、主控、LVDS接口的LCD关系<br>如下图所示SN75LVDS83B的应用：</p>
<p>其实就是：把三星芯片输出的TTL（RGB）信号转换成LVDS差分信号输出的LCD接收端。</p>
<p>硬件的接口如下所示：</p>
<p>2、SN75LVDS83B的参考电路<br>其实这部分要注意的是LCD的位数，你的屏是16bit、18bit、还是24bit的，不同位数的LCD有不同的硬件接线方法。如下图是samsung exynos4412提到的AP端，在不同位数输出时的接线图。</p>
<p>（1）、24bitRGB 24bit lcd<br>注意到用到五组差分信号线，四组信号一组时钟。</p>
<p>（2）、24bitRGB 18bit lcd<br>注意到用到四组差分信号线，三组信号一组时钟，Y3M、Y3P是NC的。AP端RGB的接线方式也不一样，6、7两个bit接地。</p>
<p>如果按（1）中的接线方法（24bit输出），接上18bit的屏。18bit 屏RGB（纯色）信号显示正常，可是有画面、渐变的就不正常。为此跟硬件争论了好久，不过问题解决了就好。做技术实践是非常重要的一个环节，有些事认识上的误区，就会导致工作的失误。</p>
<p>六、RGB转换成EDP<br>这个我们点过一个屏，不过分辨率太大，我们的系统非常卡，最后就停掉了。<br>线路图如下所示：</p>
<p>示意图：</p>
<p>edp 的信号和和lvds比较类似，不过多了一个HPD的信号。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android wifi 调试</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20wifi%20%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>切换WIFI模式</p>
<p>adb tcpip 端口号</p>
<p>切换USB模式</p>
<p>adb usb</p>
<p>adb connect IP</p>
<p>adb disconnect IP </p>
<p>adb connect 172.22.46.8:8888</p>
<p>adb devices -l</p>
<p>adb -e shell  //remote device</p>
<p>切换回USB连接</p>
<p>setprop service.adb.tcp.port -1</p>
<p>stop adbd</p>
<p>start adbd</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android 按键映射</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>1．EventHub中基本的处理</p>
<p>libui库中frameworks/base/libs/ui中的EventHub.cpp文件是用户输入系统的中枢，主要的功能都是在这个文件中实现的。</p>
<p>EventHub.cpp中定义设备节点所在的路径，内容如下所示：</p>
<ol>
<li>static const char *device_path = &quot;/dev/input&quot;; // 输入设备的目录</li>
</ol>
<p>在处理过程中，将搜索路径下面的所有Input驱动的设备节点，这在openPlatformInput()中通过调用scan_dir()来实现，scan_dir()将会从目录中查找设备，找到后调用open_device()将其打开。</p>
<p>poll()函数将会阻塞程序的运行，此时为等待状态，无开销，直到Input设备的相应事件发生，事件发生后poll()将返回，然后通过read()函数读取Input设备发生的事件代码。</p>
<p>注意，EventHub默认情况可以在/dev/input之中扫描各个设备进行处理，通常情况下所有的输入设备均在这个目录中。</p>
<p>实际上，系统中可能有一些input设备可能不需要被Android整个系统使用，也就是说不需要经过EventHub的处理，在这种情况下可以根据EventHub中open_device()函数的处理，设置驱动程序中的一些标志，屏蔽一些设备。open_device()中处理了键盘，轨迹球和触摸屏等几种设备，对其他设备可以略过。另外一个简单的方法就是将不需要EventHub处理的设备的设备节点不放置在/dev/input之中。</p>
<p>open_device()函数还将打开system/usr/keylayout/中的kl文件来处理，默认情况下使用的就是qwerty.kl，这里只是扫描各个后缀名为kl的文件，然后交由KeyLayoutMap去解析处理，KeyLayoutMap是一个内部使用的类。</p>
<p>2．按键的增加</p>
<p>Android已经定义了比较丰富、完整的标准按键。在一般情况下，不需要为Android系统增加按键，只需要根据kl配置按键即可。在系统中有比较奇特按键的时候，需要更改Android系统的框架层来更改按键。</p>
<p>增加按键需要更改的文件较多，主要的文件如下所示。</p>
<p>  frameworks/base/include/ui/KeycodeLabels.h：中的KeyCode枚举数值和KeycodeLabel 类型Code数组（以NULL为结尾）</p>
<p>  frameworks/base/core/Java/android/view/KeyEvent.Java：定义整数值，作为平台的API供Java应用程序使用</p>
<p>  frameworks/base/core/res/res/values/attrs.xml：表示属性的资源文件，需要修改其中的name=&quot;keycode&quot;的attr。</p>
<p>示例：</p>
<p>对keypad来说，涉及到的文件有以下几个：</p>
<p>        1，/vendor/qcom/7k_ffa_keypad.kl</p>
<p>               首先在此文件中，添加新的键值信息：Example: key 123 WLS flag</p>
<p>              注意：新加的键值不要与已有的重复。</p>
<p>        2. kernel/arch/arm/mach-msm/keypad_surf_ffa.c</p>
<p>              在keypad对应的键位添加自定义的键码 如 :123</p>
<p>       3. frameworks/base/include/ui/keycodeLabels.h</p>
<p>               在数组keycodes 中添加 新定义的信息</p>
<p>                { &quot;MUTE&quot;, 91 }, { &quot;WLS&quot; , 92 }</p>
<p>               枚举类型 KeyCode 中添加</p>
<p>                    kKeyCodeMute = 91</p>
<p>                    kKeyCodeWLS = 92</p>
<p>       4. frameworks/base/core/res/res/values/attrs.xml</p>
<p>                &lt;enum name=&quot;KEYCODE_MUTE&quot; value=&quot;91&quot;/&gt;</p>
<p>               &lt;enum name=&quot;KEYCODE_WLS&quot; value=&quot;92&quot; /&gt;</p>
<p>      5. frameworks/base/core/java/android/view/KeyEvent.java</p>
<p>              public static final int KEYCODE_MUTE = 91;</p>
<p>              public static final int KEYCODE_WLS = 92;</p>
<p>              注意： private static final int LAST_KEYCODE = KEYCODE_MUTE;</p>
<p>              应改为： private static final int LAST_KEYCODE = KEYCODE_WLS;</p>
<p>             在函数 public final boolean isSystem() 中，同样需要添加：</p>
<p>                case KEYCODE_SEARCH:</p>
<p>                case KEYCODE_WLS:</p>
<p>             通过以上的更改，新的键值就添加上去了，由于更改了 KeyEvent，影响到了API，</p>
<p>             所以需要make update-api</p>
<p>            如果对新键值进行处理，可以通过获取相应的keycode，对它进行处理；</p>
<p>            对于按键事件的处理一般如下文件中</p>
<p>    6. frameworks/policies/base/phone/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>          综上可知，我们可以根据需求定义自己的键值，并对键值所对应的事件信息进行合理化处理。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android 添加新的自定义按键</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<p> NOTE: If you add a new keycode here you must also add it to:</p>
<p>    //  isSystem()</p>
<p>    //  frameworks/native/include/android/keycodes.h</p>
<p>    //  frameworks/native/include/input/KeycodeLabels.h</p>
<p>    //  external/webkit/WebKit/android/plugins/ANPKeyCodes.h  ??</p>
<p>    //  frameworks/base/core/res/res/values/attrs.xml</p>
<p>    //  emulator?</p>
<p>    //  LAST_KEYCODE</p>
<p>    //  KEYCODE_SYMBOLIC_NAMES</p>
<p>  getevent -i    //获取输入设备信息</p>
<p>rk29-keypad.kl //板级键配置 在loadConfigurationLocked加载 </p>
<p>frameworks/base/data/keyboards/Generic.kl   //默认</p>
<p>EventHub::getEvents -&gt; EventHub::scanDevicesLocked -&gt; EventHub::scanDirLocked</p>
<p> -&gt; EventHub::openDeviceLocked // 打开设备 设置InputDeviceIdentifier</p>
<p>     // 加载 idc配置  </p>
<p>    /usr/  or /system/devices/</p>
<p>          +                      + </p>
<p>             &quot;idc/&quot;,                         *.idc</p>
<p>            &quot;keylayout/&quot;,                *.kl</p>
<p>            &quot;keychars/&quot;,                 *.kcm</p>
<p>     Vendor_%04x_Product_%04x_Version_%04x   // try vendor product version </p>
<p>     Vendor_%04x_Product_%04x //Try vendor product.</p>
<p>      Identifier.name  //Try device name , rk29-keypad.kl </p>
<p>    –&gt;loadConfigurationLocked  </p>
<p>    –&gt; loadKeyMapLocked  //如果是keyboard类型，加载 kl</p>
<p>          –&gt; KeyMap::load  //  Keyboard.cpp    if (probeKeyMap(deviceIdenfifier, String8(&quot;Generic&quot;))) {  //默认              </p>
<p>//idc文件</p>
<p>touch.deviceType = touchScreen</p>
<p>touch.orientationAware = 1</p>
<p>keyboard.layout = qwerty   // kl</p>
<p>keyboard.characterMap = qwerty2  //kcm</p>
<p>keyboard.orientationAware = 1</p>
<p>keyboard.builtIn = 1</p>
<p>cursor.mode = navigation</p>
<p>cursor.orientationAware = 1</p>
<p>驱动定义按键值</p>
<p> /include/linux/input/input.h 或  /include/uapi/ linux/input.h  </p>
<p>#define KEY_MY           250   //内核的值</p>
<p>framework层添加</p>
<ol>
<li>frameworks/base/core/res/res/values/attr.xml  </li>
</ol>
<p>    &lt;enum name=&quot;KEYCODE_MY_KEYS&quot; value=&quot;250&quot; /&gt;&lt;/attr&gt;</p>
<ol start="2">
<li>frameworks/native/include/input/KeycodeLabels.h</li>
</ol>
<p>static const KeycodeLabelKEYCODES[] = {</p>
<p>  …</p>
<p>  { &quot;MY_KEYS&quot; ,250}, //</p>
<p>  { NULL,0 }</p>
<ol start="3">
<li>frameworks/native/include/android/keycode.h</li>
</ol>
<p>enum { </p>
<p>AKEYCODE_MY_KEYS  =250,  //</p>
<ol start="4">
<li>frameworks/base/core/java/android/view/KeyEvent.java</li>
</ol>
<p>public static final int KEYCODE_MY_KEYS        = 250；//</p>
<p>private static final int LAST_KEYCODE = KEYCODE_MY_KEYS; //LAST</p>
<p>populateKeycodeSymbolicNames    </p>
<p>        names.append(KEYCODE_MY_KEYS, &quot; KEYCODE_MY_KEYS &quot;);</p>
<ol start="5">
<li>frameworks/native/libs/input/input.cpp  //(不是必须的) KeyEvent.java -&gt;(JNI) android_view_KeyEvent.cpp -&gt;input.cpp</li>
</ol>
<p>boolKeyEvent::hasDefaultAction(int32_t keyCode) </p>
<p>boolKeyEvent::isSystemKey(int32_t keyCode)      // System keys can not be used for menu shortcuts.</p>
<p> make update-api //更新 frameworks/base/api/current.txt  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android 添加自定义系统服务</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>本文以一个简单的例子详细介绍如何为Android 6.0 系统新增一个系统服务,以及如何使用自定义系统服务。</p>
<p>目标：1.创建一个自定义服务CCCService</p>
<p>        2.APP 开发过程中可以使用 getSystemService(&quot;ccc&quot;) 获取 CCCManager 并且调用里面的函数。</p>
<p> step1 创建aidl文件</p>
<p>在源码frameworks/base/core/java/android/os/ 下面新增 一个 ICCCService.aidl</p>
<p>假设我们定义了5个函数，这些函数将会在SystemServer进程执行。</p>
<p>内容如下 </p>
<p>// ICCCService.aidlpackage android.os;// Declare any non-default types here with import statementsinterface ICCCService {    /**<br>     * Demonstrates some basic types that you can use as parameters<br>     * and return values in AIDL.<br>     */<br>   void setVal(String key,String value);<br>   String getVal(String key);   void appendLog(String log);   void clearLog();<br>   String readLog();<br>}</p>
<p>step2 创建Service文件 （CCCService）</p>
<p>在 frameworks/base/services/core/java/com/android/server/ 下面新增一个 CCCService.java 用来实现aidl文件定义的接口。</p>
<p>内容如下</p>
<p>package com.android.server;import java.io.InputStreamReader;import java.io.LineNumberReader;import java.lang.*;</p>
<p>import java.util.HashMap;import android.os.RemoteException;import android.os.ICCCService;/**</p>
<p> *</p>
<ul>
<li>Created by zhuangqianliu on 2016/9/21. */</li>
</ul>
<p>public class CCCService extends ICCCService.Stub {    </p>
<p>private static HashMap&lt;String,String&gt; map=new HashMap&lt;&gt;();    </p>
<p>private static String inner_log=&quot;&quot;;    </p>
<p>public CCCService() {</p>
<p>}</p>
<pre><code>@Override    public void setVal(String key, String value) throws RemoteException &#123;
    map.put(key,value);
&#125;

@Override    public String getVal(String key) throws RemoteException &#123;        return map.get(key);
&#125;

@Override    public void appendLog(String log) throws RemoteException &#123;
    inner_log+=log+&amp;quot;\n&amp;quot;;
&#125;

@Override    public void clearLog() throws RemoteException &#123;
    inner_log=&amp;quot;&amp;quot;;
&#125;

@Override    public String readLog() throws RemoteException &#123;        return inner_log;
&#125;</code></pre>
<p>}</p>
<p>step3 将自定义Service 加入到SystemServer 启动进程</p>
<p>先在 frameworks/base/core/java/android/content/Context.java 中添加一行 </p>
<p>public static final String CCC_SERVICE=&quot;ccc&quot;;</p>
<p>修改 frameworks/base/services/java/com/android/server/SystemServer.java</p>
<p>在  startOtherServices() 函数 的try模块中增加以下代码</p>
<p>try {</p>
<pre><code>            Slog.i(TAG, &amp;quot;CCC Service&amp;quot;);

            ServiceManager.addService(Context.CCC_SERVICE, new CCCService());

        &#125; catch (Throwable e) &#123;

            Slog.e(TAG, &amp;quot;Failure starting CCC Service&amp;quot;, e);

        &#125;</code></pre>
<p>step4 创建Manager，即CCCManager</p>
<p>在frameworks/base/core/java/android/app/ 下创建CCCManager.java 文件 内容如下</p>
<p>package android.app;/**</p>
<ul>
<li>Created by liam on 16/10/2. */import android.annotation.SdkConstant;import android.annotation.SystemApi;import android.content.Context;import android.content.Intent;import android.os.Build;import android.os.Parcel;import android.os.Parcelable;import android.os.RemoteException;import android.os.ICCCService;import android.util.Log;public class CCCManager {</li>
</ul>
<p>   ICCCService mService;    </p>
<p>public CCCManager(Context ctx,ICCCService service){</p>
<p>mService=service;<br>    }    public void setVal(String key,String value){        try{<br>            mService.setVal(key,value);<br>        }catch(Exception e){<br>            Log.e(&quot;CCCManager&quot;,e.toString());<br>            e.printStackTrace();<br>        }</p>
<pre><code>&#125;    public String getVal(String key)&#123;        try&#123;            return mService.getVal(key);
    &#125;catch(Exception e)&#123;
        Log.e(&amp;quot;CCCManager&amp;quot;,e.toString());
        e.printStackTrace();
    &#125;        return null;
&#125;    public void appendLog(String log)&#123;        try&#123;
        mService.appendLog(log);
    &#125;catch(Exception e)&#123;
        Log.e(&amp;quot;CCCManager&amp;quot;,e.toString());
        e.printStackTrace();
    &#125;
&#125;    public void clearLog()&#123;        try&#123;
        mService.clearLog();
    &#125;catch(Exception e)&#123;
        Log.e(&amp;quot;CCCManager&amp;quot;,e.toString());
        e.printStackTrace();
    &#125;
&#125;    public String readLog()&#123;        try&#123;            return mService.readLog();
    &#125;catch(Exception e)&#123;
        Log.e(&amp;quot;CCCManager&amp;quot;,e.toString());
        e.printStackTrace();
    &#125;        return null;
&#125;</code></pre>
<p>}</p>
<p>step5 注册到SystemService</p>
<p>修改frameworks/base/core/java/android/app/SystemServiceRegistry.java  //4.4 在ContextImpl中</p>
<p>在静态代码块中增加</p>
<p> registerService(Context.CCC_SERVICE, CCCManager.class,                new CachedServiceFetcher&lt;CCCManager&gt;() {<br>                    @Override                    public CCCManager createService(ContextImpl ctx) {<br>                        IBinder b = ServiceManager.getService(Context.CCC_SERVICE);<br>                        ICCCService service = ICCCService.Stub.asInterface(b);                        return new CCCManager(ctx, service);<br>                    }});</p>
<p>step6 修改SePolicy的编译验证</p>
<p>修改 /external/sepolicy/service.te</p>
<p>在最后一行添加</p>
<p>type ccc_service, system_api_service, system_server_service, service_manager_type;</p>
<p>然后修改同目录下 /external/sepolicy/service_contexts 文件</p>
<p>中间插入一行 </p>
<p>ccc u:object_r:ccc_service:s0</p>
<p>如图所示</p>
<p>step7 重新编译源码</p>
<p>别忘了先 make update-api。</p>
<p>Step8 测试 </p>
<p>tip: </p>
<p>可以先创建一个java工程简单写一个CCCManager类，导出jar 在ide中使用provided 依赖。这样开发过程中就不会报错。</p>
<p>java临时工程如下使用 IDEA创建的java项目</p>
<p>Android studio 项目配置</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android.mk%20%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%20jar%20%E5%8C%85/</url>
    <content><![CDATA[<p>LOCAL_STATIC_JAVA_LIBRARIES := libname #保持两个libname名字一致  LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := libname:lib/needimport.jar  </p>
<p>   导入多个jar包</p>
<p>LOCAL_STATIC_JAVA_LIBRARIES := libname \                                  libname2  LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := libname:lib/needimport.jar \                                           libname2:lib/needimport2.jar   </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android5</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android5.0%20%E5%AE%9A%E5%88%B6MTP%E6%98%BE%E7%A4%BA%E7%9A%84%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<p>找到frameworks/base/media/java/android/mtp/MtpDatabase.java</p>
<p>找到以下方法：</p>
<p> private int getDeviceProperty(int property, long[] outIntValue, char[] outStringValue) </p>
<p>对应的一个switch语句，找到以下case分支:</p>
<p>case MtpConstants.DEVICE_PROPERTY_DEVICE_FRIENDLY_NAME:</p>
<p>一般会看到这样的语句：</p>
<p>String value = mDeviceProperties.getString(Integer.toString(property), &quot;&quot;);</p>
<p>在&quot;&quot;中添加自己想要在PC上显示的内容即可。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android4.4%20%E5%85%A8%E5%B1%8F%E6%A8%A1%E5%BC%8F-%E6%B2%89%E6%B5%B8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>// This snippet hides the system bars.</p>
<p>private void hideSystemUI() {</p>
<p>    // Set the IMMERSIVE flag.</p>
<p>    // Set the content to appear under the system bars so that the content</p>
<p>    // doesn’t resize when the system bars hide and show.</p>
<p>    //开启全屏模式</p>
<p>    mDecorView.setSystemUiVisibility(</p>
<p>            View.SYSTEM_UI_FLAG_LAYOUT_STABLE</p>
<p>            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</p>
<p>            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</p>
<p>            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // hide nav bar</p>
<p>            | View.SYSTEM_UI_FLAG_FULLSCREEN // hide status bar</p>
<p>            | View.SYSTEM_UI_FLAG_IMMERSIVE);</p>
<p>}</p>
<p>// This snippet shows the system bars. It does this by removing all the flags</p>
<p>// except for the ones that make the content appear under the system bars.</p>
<p>//取消全屏模式</p>
<p>private void showSystemUI() {</p>
<p>    mDecorView.setSystemUiVisibility(</p>
<p>            View.SYSTEM_UI_FLAG_LAYOUT_STABLE</p>
<p>            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</p>
<p>            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);</p>
<p>}</p>
<p>getWindow().getDecorView().setSystemUiVisibility</p>
<p>唤出的是透明的系统栏和虚拟按钮，短暂的时间后系统栏和虚拟按钮会自动隐藏。</p>
<p>只需要把View.SYSTEM_UI_FLAG_IMMERSIVE改为View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY。</p>
<p>如果你用的是support v7兼容包的ActionBar可能会设置不了样式，请看我之前的一篇随笔来解决这个问题。</p>
<p>要解决被覆盖的问题需要动态设置根布局的内边距，请看下面的设置：</p>
<p> 1 public class MainActivity extends Activity implements OnClickListener { 2     private RelativeLayout rlLayout; 3  4     @Override 5     protected void onCreate(Bundle savedInstanceState) { 6         super.onCreate(savedInstanceState); 7         setContentView(R.layout.activity_main); 8         //设置ACtionBar 9         ActionBar actionBar = getActionBar();10         actionBar.setDisplayHomeAsUpEnabled(true);11         actionBar.setHomeButtonEnabled(true);12 13         rlLayout = (RelativeLayout) findViewById(R.id.rlayout);14         Button mButtonOn = (Button) findViewById(R.id.button_on);15         Button mButtonOff = (Button) findViewById(R.id.button_off);16         mButtonOn.setOnClickListener(this);17         mButtonOff.setOnClickListener(this);18     }19 20     public void onClick(View v) {21         //获得根视图22         View view = getWindow().getDecorView();23         switch (v.getId()) {24         case R.id.button_on:25             //进入沉浸模式26             hideSystemUI(view);27             //把内边距设为028             rlLayout.setPadding(0, 0, 0, 0);29             break;30         case R.id.button_off:31             //退出沉浸模式32             showSystemUI(view);33             //获得系统栏高度34             Rect frame = new Rect();35             view.getWindowVisibleDisplayFrame(frame);36             //需要设置的内边距为ActionBar高度和系统栏高度相加37             int paddingTop = getActionBar().getHeight() + frame.top;38             rlLayout.setPadding(0, paddingTop, 0, 0);39             break;40         }41 42     }43 44     @Override45     public boolean onCreateOptionsMenu(Menu menu) {46         getMenuInflater().inflate(R.menu.main, menu);47         return true;48     }49 50     @SuppressLint(&quot;NewApi&quot;)51     public static void hideSystemUI(View view) {52         view.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE53                 | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION54                 | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN55                 | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION56                 | View.SYSTEM_UI_FLAG_FULLSCREEN57                 | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);58     }59 60     @SuppressLint(&quot;NewApi&quot;)61     public static void showSystemUI(View view) {62         view.setSystemUiVisibility(63                 View.SYSTEM_UI_FLAG_LAYOUT_STABLE64                 | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION65                 | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);66     }67 }</p>
<p>1 &lt;RelativeLayout xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android&quot;2">http://schemas.android.com/apk/res/android&quot;2</a>     xmlns:tools=&quot;<a href="http://schemas.android.com/tools&quot;3">http://schemas.android.com/tools&quot;3</a>     android:id=&quot;@+id/rlayout&quot;4     android:layout_width=&quot;match_parent&quot;5     android:layout_height=&quot;match_parent&quot;6     android:paddingTop=&quot;?android:attr/actionBarSize&quot;7     tools:context=&quot;.MainActivity&quot; &gt;</p>
<p>如果我需要把一个应用里的所有activity都设为沉浸模式呢？只需要重写activity的onResume()方法，然后把这个activity设为父类，让所有的activity继承它就可以了。</p>
<p>因为每创建一个新的activity都要检测是否开启全屏模式，而如果在后一个activity里设为全屏后返回上一个activity时也要检测是否变成全屏模式。</p>
<p>下面是我的应用里onResume()的设置，因为我的应用要兼容android2.1所以Actionbar用的是support v7包，获取Actionbar是用getSupportActionBar();</p>
<p>如果你的应用需要在进入沉浸模式后通知其他UI改变的话可以加入一个监听器View.OnSystemUiVisibilityChangeListener()。</p>
<p>检测当前activity是否为沉浸模式的方法是</p>
<p>1 int status = View.SYSTEM_UI_FLAG_LAYOUT_STABLE2 　　　　　　| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION3 　　　　　　| View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN4 　　　　　　| View.SYSTEM_UI_FLAG_HIDE_NAVIGATION5 　　　　　　| View.SYSTEM_UI_FLAG_FULLSCREEN6 　　　　　　| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;7 view.getSystemUiVisibility() == status;</p>
<p>如果在后面的activity里退出了沉浸模式。那么返回前一个activity的时候，前一个activity要检查下是否要退出沉浸模式。在onResume()里面检查就可以。</p>
<p> 1 protected void onResume() { 2          // 判断是否是android4.4 3          if (SystemInfo.getSystemVersion() &gt; 18) { 4              SharedPreferences sPreferences = getSharedPreferences(&quot;AppBrightness&quot;, 0); 5              // 读取存在SharedPreferences里的设置 6              boolean Fullscreen = sPreferences.getBoolean(&quot;Fullscreen&quot;, false); 7              ActionBar actionBar = getSupportActionBar(); 8              // 获得根视图 9              View view = getWindow().getDecorView();10              // 获得根布局11              ViewGroup vGroup = (ViewGroup) (view.findViewById(android.R.id.content));12              // 用于判断应用是否已经退出沉浸模式了。13              int status = View.SYSTEM_UI_FLAG_LAYOUT_STABLE14                         | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION15                         | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN16                         | View.SYSTEM_UI_FLAG_VISIBLE17                         | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;18              // 判断是否要开启沉浸模式19              if (Fullscreen) {20                  // 需要开启沉浸模式则把actionbar先隐藏掉，不然在Activity跳转时会闪出来。21                  actionBar.hide();22                  // 进入沉浸模式23                  SystemUI.hideSystemUI(view);24                  // 在根布局获得第一个控件，也就是最上层的layout。把内边距设为025                  vGroup.getChildAt(0).setPadding(0, 0, 0, 0);26              } else if (view.getSystemUiVisibility() == status){          27                  // 如果应用已经退出沉浸模式，但是这个activity还是在沉浸模式内，则退出沉浸模式。28                  actionBar.show();29                  SystemUI.showSystemUI(view);30                  // 获得系统栏高度和actionbar高度，设置内边距。31                  Rect frame = new Rect();32                  view.getWindowVisibleDisplayFrame(frame);33                  vGroup.getChildAt(0).setPadding(0, actionBar.getHeight() + frame.top, 0, 0);34              }35          }36          super.onResume();37      }</p>
<p>1 public static int getSystemVersion() { //这是获取系统版本的方法2         int ver = android.os.Build.VERSION.SDK_INT;3         return ver;4     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>AndroidAp名称</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/AndroidAp%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<p>diff –git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml</p>
<p>index 098fbbe..e0589ec 100644</p>
<p>— a/core/res/res/values/strings.xml</p>
<p>+++ b/core/res/res/values/strings.xml</p>
<p>@@ -3364,7 +3364,7 @@</p>
<p>     &lt;string name=&quot;wifi_watchdog_network_disabled_detailed&quot;&gt;\u0020has a poor Internet connection.&lt;/string&gt;</p>
<p>     &lt;!– Do not translate. Default access point SSID used for tethering –&gt;</p>
<ul>
<li>   &lt;string name=&quot;wifi_tether_configure_ssid_default&quot; translatable=&quot;false&quot;&gt;AndroidAP&lt;/string&gt;</li>
</ul>
<ul>
<li>   &lt;string name=&quot;wifi_tether_configure_ssid_default&quot; translatable=&quot;false&quot;&gt;NEOTACK Pro&lt;/string&gt;</li>
</ul>
<p>     &lt;string name=&quot;wifi_p2p_dialog_title&quot;&gt;Wi-Fi Direct&lt;/string&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android动画效果之Frame Animation（逐帧动画）</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E4%B9%8BFrame%20Animation%EF%BC%88%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB%EF%BC%89/</url>
    <content><![CDATA[<p>Frame Animation（逐帧动画）：</p>
<p>       逐帧动画（Frame-by-frame Animations）从字面上理解就是一帧挨着一帧的播放图片，就像放电影一样。和补间动画一样可以通过xml实现也可以通过java代码实现。接下来借助目前项目中的一个开奖的动画来总结如何使用。</p>
<p>具体实现过程：</p>
<p>1.）在res/drawable目录下一个文件lottery_animlist.xml，内容如下：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;<br>    android:oneshot=&quot;false&quot;&gt;</p>
<pre><code>&amp;lt;item</code></pre>
<p>        android:drawable=&quot;@mipmap/lottery_1&quot;<br>        android:duration=&quot;200&quot; /&gt;<br>    &lt;item<br>        android:drawable=&quot;@mipmap/lottery_2&quot;<br>        android:duration=&quot;200&quot; /&gt;<br>    &lt;item<br>        android:drawable=&quot;@mipmap/lottery_3&quot;<br>        android:duration=&quot;200&quot; /&gt;<br>    &lt;item<br>        android:drawable=&quot;@mipmap/lottery_4&quot;<br>        android:duration=&quot;200&quot; /&gt;<br>    &lt;item<br>        android:drawable=&quot;@mipmap/lottery_5&quot;<br>        android:duration=&quot;200&quot; /&gt;<br>    &lt;item<br>        android:drawable=&quot;@mipmap/lottery_6&quot;<br>        android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt;</p>
<p>根节点是animation-list（动画列表），里面有一个或者多个item节点组成，oneshot属性表示是否只播放一次，true表示只会播放一次，false表示一直循环播放，内部用item节点声明一个动画帧，android:drawable指定此帧动画所对应的图片资源，android:druation代表此帧持续的时间，整数，单位为毫秒。</p>
<p>注意:</p>
<p>   之前使用eclipse或者Android ADT开发的时候，文件可以放在res/anim和res/drawable两个文件夹下面，虽然谷歌推荐放在res/drawable文件夹下但是不会报错，在使用Android studio时候就没那么幸运了，如果不放在res/drawable文件夹下面会报如下错误:</p>
<p>2.）用ImageView控件作为动画载体来显示动画</p>
<p>&lt;ImageView<br>   android:id=&quot;@+id/animation_iv&quot;<br>   android:layout_width=&quot;wrap_content&quot;<br>   android:layout_height=&quot;wrap_content&quot;<br>   android:layout_gravity=&quot;center&quot;<br>   android:layout_margin=&quot;10dp&quot;<br>   android:src=&quot;@drawable/lottery_animlist&quot; /&gt;</p>
<p>这个时候我们运行一下，发现动画没有运行而是停留在第一帧，那是因为AnimationDrawable播放动画是依附在window上面的，而在Activity onCreate方法中调用时Window还未初始化完毕，所有才会停留在第一帧，要想实现播放必须在onWindowFocusChanged中添加如下代码：</p>
<p>imageView.setImageResource(R.drawable.lottery_animlist);<br>AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getDrawable();<br>animationDrawable.start();</p>
<p>如果想要停止播放动画可以调用AnimationDrawable的stop方法</p>
<p>  imageView.setImageResource(R.drawable.lottery_animlist);<br>  AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getDrawable();<br>  animationDrawable.stop();</p>
<p>3.)纯Java代码实现方式</p>
<p>AnimationDrawable anim = new AnimationDrawable();<br>    for (int i = 1; i &lt;= 6; i++) {<br>    int id = getResources().getIdentifier(&quot;lottery_&quot; + i, &quot;mipmap&quot;, getPackageName());<br>    Drawable drawable = getResources().getDrawable(id);<br>    anim.addFrame(drawable, 200);<br>    }<br>    anim.setOneShot(false);<br>    imageView.setImageDrawable(anim);<br>    anim.start();</p>
<p>4.）AnimationDrawable 几个常见的api</p>
<p>void start() - 开始播放动画</p>
<p>void stop() - 停止播放动画</p>
<p>addFrame(Drawable frame, int duration) - 添加一帧，并设置该帧显示的持续时间</p>
<p>void setOneShoe(boolean flag) - false为循环播放，true为仅播放一次</p>
<p>boolean isRunning() - 是否正在播放</p>
<p>总结：</p>
<p>   Frame Animation（逐帧动画）相对来说比较简单，但是在实际开发中使用的频率还是比较高的。希望以这个小例子能够掌握逐帧动画，但是逐帧动画只能实现比较小的动画效果，如果复杂而且帧数比较多的动画不太建议使用逐帧动画，一方面是因为会造成OOM，另一方面会显得很卡，如果真是超级复杂的动画的话建议选择双缓冲绘制View来实现。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android动画效果之Tween Animation（补间动画）</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E4%B9%8BTween%20Animation%EF%BC%88%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB%EF%BC%89/</url>
    <content><![CDATA[<p> Tween Animation（补间动画）：</p>
<p>    Tween动画，通过对View的内容进行一系列的图形变换 (包括平移、缩放、旋转、改变透明度)来实现动画效果。动画效果的定义可以采用XML来做也可以采用编码来做。</p>
<p>动画类型XML配置方式Java代码实现方式</p>
<p>渐变透明度动画效果&lt;alpha/&gt;AlphaAnimation</p>
<p>渐变尺寸缩放动画效果&lt;scale/&gt;ScaleAnimation</p>
<p>画面旋转动画效果&lt;rotate/&gt;RotateAnimation</p>
<p>画面位置移动动画效果&lt;translate/&gt;TranslateAnimation</p>
<p>组合动画效果&lt;set/&gt;AnimationSet</p>
<p>xml文件存放目录如下图所示：</p>
<p>具体如何实现：</p>
<p>1.）alpha渐变透明度动画效果</p>
<p>xml方式：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;<br>    android:duration=&quot;500&quot;<br>    android:fillAfter=&quot;false&quot;<br>    android:fromAlpha=&quot;1.0&quot;<br>    android:toAlpha=&quot;0.0&quot; /&gt;</p>
<p>fromAlpha:开始时透明度<br>toAlpha： 结束时透明度<br>duration：动画持续时间<br>fillAfter：设置动画结束后保持当前的位置</p>
<p>XML方式加载方式通过AnimationUtils.loadAnimation(this, R.anim.anim_alpha)获取Animation</p>
<p>  Animation alphaAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_alpha);<br>  imageView.startAnimation(alphaAnimation);</p>
<p>Java代码方式：</p>
<p>  Animation alphaAnimation = new AlphaAnimation(1.0f, 0.0f);<br>  alphaAnimation.setDuration(500);//设置动画持续时间为500毫秒<br>  alphaAnimation.setFillAfter(false);//设置动画结束后保持当前的位置（即不返回到动画开始前的位置）<br>  imageView.startAnimation(alphaAnimation);</p>
<p>2.）scale渐变尺寸缩放动画效果</p>
<p>xml方式：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;<br>    android:duration=&quot;500&quot;<br>    android:fromXScale=&quot;0.0&quot;<br>    android:fromYScale=&quot;0.0&quot;<br>    android:interpolator=&quot;@android:anim/decelerate_interpolator&quot;<br>    android:pivotX=&quot;50%&quot;<br>    android:pivotY=&quot;50%&quot;<br>    android:repeatCount=&quot;1&quot;<br>    android:repeatMode=&quot;reverse&quot;<br>    android:startOffset=&quot;0&quot;<br>    android:toXScale=&quot;1.5&quot;<br>    android:toYScale=&quot;1.5&quot; /&gt;</p>
<p>fromXDelta,fromYDelta 起始时X，Y座标,屏幕右下角的座标是X:320,Y:480<br>toXDelta， toYDelta 动画结束时X,Y的座标 <br>interpolator 指定动画插入器<br>fromXScale,fromYScale， 动画开始前X,Y的缩放，0.0为不显示， 1.0为正常大小<br>toXScale，toYScale， 动画最终缩放的倍数， 1.0为正常大小，大于1.0放大<br>pivotX， pivotY 动画起始位置，相对于屏幕的百分比,两个都为50%表示动画从自身中间开始<br>startOffset， 动画多次执行的间隔时间，如果只执行一次，执行前会暂停这段时间，单位毫秒 <br>duration，一次动画效果消耗的时间，单位毫秒，值越小动画速度越快 <br>repeatCount，动画重复的计数，动画将会执行该值+1次<br>repeatMode，动画重复的模式，reverse为反向，当第偶次执行时，动画方向会相反。restart为重新执行，方向不变</p>
<p>Java方式：</p>
<p> Animation scaleAnimation = new ScaleAnimation(0.0f, 1.5f, 0.0f, 1.5f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);<br>    scaleAnimation.setDuration(500);//设置动画持续时间为500毫秒<br>    scaleAnimation.setFillAfter(true);//如果fillAfter的值为true,则动画执行后，控件将停留在执行结束的状态<br>    scaleAnimation.setFillBefore(false);//如果fillBefore的值为true，则动画执行后，控件将回到动画执行之前的状态<br>    scaleAnimation.setRepeatCount(3);//设置动画循环次数    scaleAnimation.setRepeatMode(Animation.REVERSE);<br>    scaleAnimation.setStartOffset(0);<br>    scaleAnimation.setInterpolator(this, android.R.anim.decelerate_interpolator);//设置动画插入器<br>    imageView.startAnimation(scaleAnimation);</p>
<p>3.）rotate画面旋转动画效果</p>
<p>xml方式：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;rotate xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;<br>    android:duration=&quot;500&quot;<br>    android:fromDegrees=&quot;0&quot;<br>    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;<br>    android:pivotX=&quot;50%&quot;<br>    android:pivotY=&quot;50%&quot;<br>    android:toDegrees=&quot;-360&quot; /&gt;</p>
<p>fromDegrees 动画开始时的角度<br>toDegrees 动画结束时物件的旋转角度,正代表顺时针<br>pivotX 属性为动画相对于物件的X坐标的开始位置<br>pivotY 属性为动画相对于物件的Y坐标的开始位置</p>
<p>Java方式：</p>
<p>Animation rotateAnimation = new RotateAnimation(0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);<br>rotateAnimation.setDuration(500);<br>rotateAnimation.setFillAfter(true);<br>rotateAnimation.setInterpolator(this, android.R.anim.accelerate_decelerate_interpolator);//设置动画插入器imageView.startAnimation(rotateAnimation);</p>
<p>4.）translate画面位置移动动画效果</p>
<p>xml方式：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;<br>    android:duration=&quot;500&quot;<br>    android:fromXDelta=&quot;100&quot;<br>    android:fromYDelta=&quot;0&quot;<br>    android:interpolator=&quot;@android:anim/cycle_interpolator&quot;<br>    android:toXDelta=&quot;0&quot;<br>    android:toYDelta=&quot;0&quot; /&gt;</p>
<p>fromXDelta,fromYDelta 起始时X，Y座标,屏幕右下角的座标是X:320,Y:480<br>toXDelta， toYDelta 动画结束时X,Y的座标</p>
<p>Java方式：</p>
<p>Animation translateAnimation = new TranslateAnimation(0, 100, 0, 0);<br>translateAnimation.setDuration(500);<br>translateAnimation.setInterpolator(this, android.R.anim.cycle_interpolator);//设置动画插入器translateAnimation.setFillAfter(true);//设置动画结束后保持当前的位置（即不返回到动画开始前的位置）imageView.startAnimation(translateAnimation);</p>
<p>5.）set组合动画效果</p>
<p>xml方式：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;&gt;<br>    &lt;alpha<br>        android:duration=&quot;500&quot;<br>        android:fromAlpha=&quot;1.0&quot;<br>        android:toAlpha=&quot;0.0&quot; /&gt;</p>
<pre><code>&amp;lt;scale</code></pre>
<p>        android:duration=&quot;500&quot;<br>        android:fromXScale=&quot;0.0&quot;<br>        android:fromYScale=&quot;0.0&quot;<br>        android:interpolator=&quot;@android:anim/decelerate_interpolator&quot;<br>        android:pivotX=&quot;50%&quot;<br>        android:pivotY=&quot;50%&quot;<br>        android:repeatCount=&quot;1&quot;<br>        android:repeatMode=&quot;reverse&quot;<br>        android:startOffset=&quot;0&quot;<br>        android:toXScale=&quot;1.5&quot;<br>        android:toYScale=&quot;1.5&quot; /&gt;&lt;/set&gt;</p>
<p>如何使用</p>
<p>   AnimationSet animationSet = (AnimationSet) AnimationUtils.loadAnimation(this, R.anim.anim_set);<br>   imageView.startAnimation(animationSet);</p>
<p>Java方式</p>
<p>AnimationSet animationSet = new AnimationSet(true);</p>
<p>Animation alphaAnimation = new AlphaAnimation(1.0f, 0.1f);<br>alphaAnimation.setDuration(500);//设置动画持续时间为500毫秒Animation scaleAnimation = new ScaleAnimation(0.0f, 1.5f, 0.0f, 1.5f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);<br>scaleAnimation.setDuration(500);//设置动画持续时间为500毫秒scaleAnimation.setRepeatMode(Animation.REVERSE);<br>scaleAnimation.setStartOffset(0);<br>scaleAnimation.setInterpolator(this, android.R.anim.decelerate_interpolator);//设置动画插入器animationSet.addAnimation(alphaAnimation);<br>animationSet.addAnimation(scaleAnimation);</p>
<p>imageView.startAnimation(animationSet);</p>
<p>动画监听器Animation.AnimationListener：</p>
<p> 有时可能我们要在动画的每个周期里面做不同的操作，这时候就要借助动画监听器了</p>
<p>  alphaAnimation.setAnimationListener(new Animation.AnimationListener() {<br>    @Override<br>    public void onAnimationStart(Animation animation) {<br>        //动画开始时调用    }</p>
<p>    @Override<br>    public void onAnimationEnd(Animation animation) {<br>        //动画结束时调用    }</p>
<p>    @Override<br>    public void onAnimationRepeat(Animation animation) {<br>        //动画重复时调用    }<br>    });</p>
<p>几种自带的动画插入器</p>
<p>AccelerateInterpolator 加速，开始时慢中间加速</p>
<p>DecelerateInterpolator 减速，开始时快然后减速</p>
<p>AccelerateDecelerateInterolator 先加速后减速，开始结束时慢，中间加速</p>
<p>AnticipateInterpolator 反向，先向相反方向改变一段再加速播放</p>
<p>AnticipateOvershootInterpolator 反向加超越，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值</p>
<p>BounceInterpolator 跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100</p>
<p>CycleIinterpolator 循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2* mCycles* Math.PI* input)</p>
<p>LinearInterpolator 线性，线性均匀改变</p>
<p>OvershootInterpolator超越，最后超出目的值然后缓慢改变到目的值</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android图片加载：采用二级缓存、异步加载网络图片</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%EF%BC%9A%E9%87%87%E7%94%A8%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E3%80%81%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>Android图片加载：采用二级缓存、异步加载网络图片</p>
<p>2015-06-11 10:12 博客园 字号：T | T</p>
<p>Android应用中经常涉及从网络中加载大量图片，为提升加载速度和效率，减少网络流量都会采用二级缓存和异步加载机制，所谓二级缓存就是通过先从内存中获取、再从文件中获取，最后才会访问网络。</p>
<p>AD：51CTO网+ 首届中国APP创新评选大赛火热招募中……</p>
<p>一、问题描述</p>
<p>Android应用中经常涉及从网络中加载大量图片，为提升加载速度和效率，减少网络流量都会采用二级缓存和异步加载机制，所谓二级缓存就是通过先从内存中获取、再从文件中获取，最后才会访问网络。内存缓存（一级）本质上是Map集合以key-value对的方式存储图片的url和Bitmap信息，由于内存缓存会造成堆内存泄露， 管理相对复杂一些，可采用第三方组件，对于有经验的可自己编写组件，而文件缓存比较简单通常自己封装一下即可。下面就通过案例看如何实现网络图片加载的优化。</p>
<p>二、案例介绍</p>
<p>案例新闻的列表图片</p>
<p>三、主要核心组件</p>
<p>下面先看看实现一级缓存（内存）、二级缓存（磁盘文件）所编写的组件</p>
<p>1、MemoryCache</p>
<p>在内存中存储图片（一级缓存）, 采用了1个map来缓存图片代码如下：</p>
<p>public class MemoryCache { </p>
<p>// 最大的缓存数 </p>
<p>private static final int MAX_CACHE_CAPACITY = 30; </p>
<p>//用Map软引用的Bitmap对象, 保证内存空间足够情况下不会被垃圾回收 </p>
<p>private HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt; mCacheMap = </p>
<p>new LinkedHashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;() { </p>
<p>private static final long serialVersionUID = 1L; </p>
<p>//当缓存数量超过规定大小（返回true）会清除最早放入缓存的 </p>
<p>protected boolean removeEldestEntry( </p>
<p>Map.Entry&lt;String,SoftReference&lt;Bitmap&gt;&gt; eldest){ </p>
<p>return size() &gt; MAX_CACHE_CAPACITY;}; </p>
<p>}; </p>
<p>/** </p>
<p>* 从缓存里取出图片 </p>
<p>* @param id </p>
<p>* @return 如果缓存有，并且该图片没被释放，则返回该图片，否则返回null </p>
<p>*/ </p>
<p>public Bitmap get(String id){ </p>
<p>if(!mCacheMap.containsKey(id)) return null; </p>
<p>SoftReference&lt;Bitmap&gt; ref = mCacheMap.get(id); </p>
<p>return ref.get(); </p>
<p>} </p>
<p>/** </p>
<p>* 将图片加入缓存 </p>
<p>* @param id </p>
<p>* @param bitmap </p>
<p>*/ </p>
<p>public void put(String id, Bitmap bitmap){ </p>
<p>mCacheMap.put(id, new SoftReference&lt;Bitmap&gt;(bitmap)); </p>
<p>} </p>
<p>/** </p>
<p>* 清除所有缓存 </p>
<p>*/ </p>
<p>public void clear() { </p>
<p>try { </p>
<p>for(Map.Entry&lt;String,SoftReference&lt;Bitmap&gt;&gt;entry :mCacheMap.entrySet()) </p>
<p>{ SoftReference&lt;Bitmap&gt; sr = entry.getValue(); </p>
<p>if(null != sr) { </p>
<p>Bitmap bmp = sr.get(); </p>
<p>if(null != bmp) bmp.recycle(); </p>
<p>} </p>
<p>} </p>
<p>mCacheMap.clear(); </p>
<p>} catch (Exception e) { </p>
<p>e.printStackTrace();} </p>
<p>} </p>
<p>} </p>
<p>2、FileCache</p>
<p>在磁盘中缓存图片(二级缓存)，代码如下</p>
<p>public class FileCache { </p>
<p>//缓存文件目录 </p>
<p>private File mCacheDir; </p>
<p>/** </p>
<p>* 创建缓存文件目录，如果有SD卡，则使用SD，如果没有则使用系统自带缓存目录 </p>
<p>* @param context </p>
<p>* @param cacheDir 图片缓存的一级目录 </p>
<p>*/ </p>
<p>public FileCache(Context context, File cacheDir, String dir){ </p>
<p>if(android.os.Environment.getExternalStorageState().equals、(android.os.Environment.MEDIA_MOUNTED)) </p>
<p>mCacheDir = new File(cacheDir, dir); </p>
<p>else </p>
<p>mCacheDir = context.getCacheDir();// 如何获取系统内置的缓存存储路径 </p>
<p>if(!mCacheDir.exists()) mCacheDir.mkdirs(); </p>
<p>} </p>
<p>public File getFile(String url){ </p>
<p>File f=null; </p>
<p>try { </p>
<p>//对url进行编辑，解决中文路径问题 </p>
<p>String filename = URLEncoder.encode(url,&quot;utf-8&quot;); </p>
<p>f = new File(mCacheDir, filename); </p>
<p>} catch (UnsupportedEncodingException e) { </p>
<p>e.printStackTrace(); </p>
<p>} </p>
<p>return f; </p>
<p>} </p>
<p>public void clear(){//清除缓存文件 </p>
<p>File[] files = mCacheDir.listFiles(); </p>
<p>for(File f:files)f.delete(); </p>
<p>} </p>
<p>} </p>
<p>3、编写异步加载组件AsyncImageLoader</p>
<p>android中采用单线程模型即应用运行在UI主线程中，且Android又是实时操作系统要求及时响应否则出现ANR错误，因此对于耗时操作要求不能阻塞UI主线程，需要开启一个线程处理（如本应用中的图片加载）并将线程放入队列中，当运行完成后再通知UI主线程进行更改，同时移除任务——这就是异步任务，在android中实现异步可通过本系列一中所用到的AsyncTask或者使用thread+handler机制，在这里是完全是通过代码编写实现的，这样我们可以更清晰的看到异步通信的实现的本质，代码如下</p>
<p>public class AsyncImageLoader{ </p>
<p>private MemoryCache mMemoryCache;//内存缓存 </p>
<p>private FileCache mFileCache;//文件缓存 </p>
<p>private ExecutorService mExecutorService;//线程池 </p>
<p>//记录已经加载图片的ImageView </p>
<p>private Map&lt;ImageView, String&gt; mImageViews = Collections </p>
<p>.synchronizedMap(new WeakHashMap&lt;ImageView, String&gt;()); </p>
<p>//保存正在加载图片的url </p>
<p>private List&lt;LoadPhotoTask&gt; mTaskQueue = new ArrayList&lt;LoadPhotoTask&gt;(); </p>
<p>/** </p>
<p>* 默认采用一个大小为5的线程池 </p>
<p>* @param context </p>
<p>* @param memoryCache 所采用的高速缓存 </p>
<p>* @param fileCache 所采用的文件缓存 </p>
<p>*/ </p>
<p>public AsyncImageLoader(Context context, MemoryCache memoryCache, FileCache fileCache) { </p>
<p>mMemoryCache = memoryCache; </p>
<p>mFileCache = fileCache; </p>
<p>mExecutorService = Executors.newFixedThreadPool(5);//建立一个容量为5的固定尺寸的线程池（最大正在运行的线程数量） </p>
<p>} </p>
<p>/** </p>
<p>* 根据url加载相应的图片 </p>
<p>* @param url </p>
<p>* @return 先从一级缓存中取图片有则直接返回，如果没有则异步从文件（二级缓存）中取，如果没有再从网络端获取 </p>
<p>*/ </p>
<p>public Bitmap loadBitmap(ImageView imageView, String url) { </p>
<p>//先将ImageView记录到Map中,表示该ui已经执行过图片加载了 </p>
<p>mImageViews.put(imageView, url); </p>
<p>Bitmap bitmap = mMemoryCache.get(url);//先从一级缓存中获取图片 </p>
<p>if(bitmap == null) { </p>
<p>enquequeLoadPhoto(url, imageView);//再从二级缓存和网络中获取 </p>
<p>} </p>
<p>return bitmap; </p>
<p>} </p>
<p>/** </p>
<p>* 加入图片下载队列 </p>
<p>* @param url </p>
<p>*/ </p>
<p>private void enquequeLoadPhoto(String url, ImageView imageView) { </p>
<p>//如果任务已经存在，则不重新添加 </p>
<p>if(isTaskExisted(url)) </p>
<p>return; </p>
<p>LoadPhotoTask task = new LoadPhotoTask(url, imageView); </p>
<p>synchronized (mTaskQueue) { </p>
<p>mTaskQueue.add(task);//将任务添加到队列中 </p>
<p>} </p>
<p>mExecutorService.execute(task);//向线程池中提交任务，如果没有达到上限(5),则运行否则被阻塞 </p>
<p>} </p>
<p>/** </p>
<p>* 判断下载队列中是否已经存在该任务 </p>
<p>* @param url </p>
<p>* @return </p>
<p>*/ </p>
<p>private boolean isTaskExisted(String url) { </p>
<p>if(url == null) </p>
<p>return false; </p>
<p>synchronized (mTaskQueue) { </p>
<p>int size = mTaskQueue.size(); </p>
<p>for(int i=0; i&lt;size; i++) { </p>
<p>LoadPhotoTask task = mTaskQueue.get(i); </p>
<p>if(task != null &amp;&amp; task.getUrl().equals(url)) </p>
<p>return true; </p>
<p>} </p>
<p>} </p>
<p>return false; </p>
<p>} </p>
<p>/** </p>
<p>* 从缓存文件或者网络端获取图片 </p>
<p>* @param url </p>
<p>*/ </p>
<p>private Bitmap getBitmapByUrl(String url) { </p>
<p>File f = mFileCache.getFile(url);//获得缓存图片路径 </p>
<p>Bitmap b = ImageUtil.decodeFile(f);//获得文件的Bitmap信息 </p>
<p>if (b != null)//不为空表示获得了缓存的文件 </p>
<p>return b; </p>
<p>return ImageUtil.loadBitmapFromWeb(url, f);//同网络获得图片 </p>
<p>} </p>
<p>/** </p>
<p>* 判断该ImageView是否已经加载过图片了（可用于判断是否需要进行加载图片） </p>
<p>* @param imageView </p>
<p>* @param url </p>
<p>* @return </p>
<p>*/ </p>
<p>private boolean imageViewReused(ImageView imageView, String url) { </p>
<p>String tag = mImageViews.get(imageView); </p>
<p>if (tag == null || !tag.equals(url)) </p>
<p>return true; </p>
<p>return false; </p>
<p>} </p>
<p>private void removeTask(LoadPhotoTask task) { </p>
<p>synchronized (mTaskQueue) { </p>
<p>mTaskQueue.remove(task); </p>
<p>} </p>
<p>} </p>
<p>class LoadPhotoTask implements Runnable { </p>
<p>private String url; </p>
<p>private ImageView imageView; </p>
<p>LoadPhotoTask(String url, ImageView imageView) { </p>
<p>this.url = url; </p>
<p>this.imageView = imageView; </p>
<p>} </p>
<p>@Override </p>
<p>public void run() { </p>
<p>if (imageViewReused(imageView, url)) {//判断ImageView是否已经被复用 </p>
<p>removeTask(this);//如果已经被复用则删除任务 </p>
<p>return; </p>
<p>} </p>
<p>Bitmap bmp = getBitmapByUrl(url);//从缓存文件或者网络端获取图片 </p>
<p>mMemoryCache.put(url, bmp);// 将图片放入到一级缓存中 </p>
<p>if (!imageViewReused(imageView, url)) {//若ImageView未加图片则在ui线程中显示图片 </p>
<p>BitmapDisplayer bd = new BitmapDisplayer(bmp, imageView, url); Activity a = (Activity) imageView.getContext(); </p>
<p>a.runOnUiThread(bd);//在UI线程调用bd组件的run方法，实现为ImageView控件加载图片 </p>
<p>} </p>
<p>removeTask(this);//从队列中移除任务 </p>
<p>} </p>
<p>public String getUrl() { </p>
<p>return url; </p>
<p>} </p>
<p>} </p>
<p>/** </p>
<p>* </p>
<p>*由UI线程中执行该组件的run方法 </p>
<p>*/ </p>
<p>class BitmapDisplayer implements Runnable { </p>
<p>private Bitmap bitmap; </p>
<p>private ImageView imageView; </p>
<p>private String url; </p>
<p>public BitmapDisplayer(Bitmap b, ImageView imageView, String url) { </p>
<p>bitmap = b; </p>
<p>this.imageView = imageView; </p>
<p>this.url = url; </p>
<p>} </p>
<p>public void run() { </p>
<p>if (imageViewReused(imageView, url)) </p>
<p>return; </p>
<p>if (bitmap != null) </p>
<p>imageView.setImageBitmap(bitmap); </p>
<p>} </p>
<p>} </p>
<p>/** </p>
<p>* 释放资源 </p>
<p>*/ </p>
<p>public void destroy() { </p>
<p>mMemoryCache.clear(); </p>
<p>mMemoryCache = null; </p>
<p>mImageViews.clear(); </p>
<p>mImageViews = null; </p>
<p>mTaskQueue.clear(); </p>
<p>mTaskQueue = null; </p>
<p>mExecutorService.shutdown(); </p>
<p>mExecutorService = null; </p>
<p>} </p>
<p>} </p>
<p>编写完成之后，对于异步任务的执行只需调用AsyncImageLoader中的loadBitmap()方法即可非常方便，对于AsyncImageLoader组件的代码最好结合注释好好理解一下，这样对于Android中线程之间的异步通信就会有深刻的认识。</p>
<p>4、工具类ImageUtil</p>
<p>public class ImageUtil { </p>
<p>/** </p>
<p>* 从网络获取图片，并缓存在指定的文件中 </p>
<p>* @param url 图片url </p>
<p>* @param file 缓存文件 </p>
<p>* @return </p>
<p>*/ </p>
<p>public static Bitmap loadBitmapFromWeb(String url, File file) { </p>
<p>HttpURLConnection conn = null; </p>
<p>InputStream is = null; </p>
<p>OutputStream os = null; </p>
<p>try { </p>
<p>Bitmap bitmap = null; </p>
<p>URL imageUrl = new URL(url); </p>
<p>conn = (HttpURLConnection) imageUrl.openConnection(); </p>
<p>conn.setConnectTimeout(30000); </p>
<p>conn.setReadTimeout(30000); </p>
<p>conn.setInstanceFollowRedirects(true); </p>
<p>is = conn.getInputStream(); </p>
<p>os = new FileOutputStream(file); </p>
<p>copyStream(is, os);//将图片缓存到磁盘中 </p>
<p>bitmap = decodeFile(file); </p>
<p>return bitmap; </p>
<p>} catch (Exception ex) { </p>
<p>ex.printStackTrace(); </p>
<p>return null; </p>
<p>} finally { </p>
<p>try { </p>
<p>if(os != null) os.close(); </p>
<p>if(is != null) is.close(); </p>
<p>if(conn != null) conn.disconnect(); </p>
<p>} catch (IOException e) { } </p>
<p>} </p>
<p>} </p>
<p>public static Bitmap decodeFile(File f) { </p>
<p>try { </p>
<p>return BitmapFactory.decodeStream(new FileInputStream(f), null, null); </p>
<p>} catch (Exception e) { } </p>
<p>return null; </p>
<p>} </p>
<p>private static void copyStream(InputStream is, OutputStream os) { </p>
<p>final int buffer_size = 1024; </p>
<p>try { </p>
<p>byte[] bytes = new byte[buffer_size]; </p>
<p>for (;;) { </p>
<p>int count = is.read(bytes, 0, buffer_size); </p>
<p>if (count == -1) </p>
<p>break; </p>
<p>os.write(bytes, 0, count); </p>
<p>} </p>
<p>} catch (Exception ex) { </p>
<p>ex.printStackTrace(); </p>
<p>} </p>
<p>} </p>
<p>} </p>
<p>四、测试应用</p>
<p>组件之间的时序图：</p>
<p>1、编写MainActivity</p>
<p>public class MainActivity extends Activity { </p>
<p>ListView list; </p>
<p>ListViewAdapter adapter; </p>
<p>@Override </p>
<p>public void onCreate(Bundle savedInstanceState) { </p>
<p>super.onCreate(savedInstanceState); </p>
<p>setContentView(R.layout.main); </p>
<p>list=(ListView)findViewById(R.id.list); </p>
<p>adapter=new ListViewAdapter(this, mStrings); </p>
<p>list.setAdapter(adapter); </p>
<p>} </p>
<p>public void onDestroy(){ </p>
<p>list.setAdapter(null); </p>
<p>super.onDestroy(); </p>
<p>adapter.destroy(); </p>
<p>} </p>
<p>private String[] mStrings={ </p>
<p>&quot;<a href="http://news.21-sun.com/UserFiles/x_Image/x_20150606083511_0.jpg">http://news.21-sun.com/UserFiles/x_Image/x_20150606083511_0.jpg</a>&quot;, </p>
<p>&quot;<a href="http://news.21-sun.com/UserFiles/x_Image/x_20150606082847_0.jpg">http://news.21-sun.com/UserFiles/x_Image/x_20150606082847_0.jpg</a>&quot;, </p>
<p>…..}; </p>
<p>} </p>
<p>2、编写适配器</p>
<p>public class ListViewAdapter extends BaseAdapter { </p>
<p>private Activity mActivity; </p>
<p>private String[] data; </p>
<p>private static LayoutInflater inflater=null; </p>
<p>private AsyncImageLoader imageLoader;//异步组件 </p>
<p>public ListViewAdapter(Activity mActivity, String[] d) { </p>
<p>this.mActivity=mActivity; </p>
<p>data=d; </p>
<p>inflater = (LayoutInflater)mActivity.getSystemService( </p>
<p>Context.LAYOUT_INFLATER_SERVICE); </p>
<p>MemoryCache mcache=new MemoryCache();//内存缓存 </p>
<p>File sdCard = android.os.Environment.getExternalStorageDirectory();//获得SD卡 </p>
<p>File cacheDir = new File(sdCard, &quot;jereh_cache&quot; );//缓存根目录 </p>
<p>FileCache fcache=new FileCache(mActivity, cacheDir, &quot;news_img&quot;);//文件缓存 </p>
<p>imageLoader = new AsyncImageLoader(mActivity, mcache,fcache); </p>
<p>} </p>
<p>public int getCount() { </p>
<p>return data.length; </p>
<p>} </p>
<p>public Object getItem(int position) { </p>
<p>return position; </p>
<p>} </p>
<p>public long getItemId(int position) { </p>
<p>return position; </p>
<p>} </p>
<p>public View getView(int position, View convertView, ViewGroup parent) { </p>
<p>ViewHolder vh=null; </p>
<p>if(convertView==null){ </p>
<p>convertView = inflater.inflate(R.layout.item, null); </p>
<p>vh=new ViewHolder(); </p>
<p>vh.tvTitle=(TextView)convertView.findViewById(R.id.text); </p>
<p>vh.ivImg=(ImageView)convertView.findViewById(R.id.image); </p>
<p>convertView.setTag(vh); </p>
<p>}else{ </p>
<p>vh=(ViewHolder)convertView.getTag(); </p>
<p>} </p>
<p>vh.tvTitle.setText(&quot;标题信息测试———— &quot;+position); </p>
<p>vh.ivImg.setTag(data[position]); </p>
<p>//异步加载图片，先从一级缓存、再二级缓存、最后网络获取图片 </p>
<p>Bitmap bmp = imageLoader.loadBitmap(vh.ivImg, data[position]); </p>
<p>if(bmp == null) { </p>
<p>vh.ivImg.setImageResource(R.drawable.default_big); </p>
<p>} else { </p>
<p>vh.ivImg.setImageBitmap(bmp); </p>
<p>} </p>
<p>return convertView; </p>
<p>} </p>
<p>private class ViewHolder{ </p>
<p>TextView tvTitle; </p>
<p>ImageView ivImg; </p>
<p>} </p>
<p>public void destroy() { </p>
<p>imageLoader.destroy(); </p>
<p>} </p>
<p>} </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android多屏幕适配方案 sw</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E5%A4%9A%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%20sw/</url>
    <content><![CDATA[<p>获取机器的最小屏幕宽度：</p>
<p>代码中可以用getResources().getConfiguration().smallestScreenWidthDp获取sw</p>
<p>这里的sw代表smallwidth的意思，当你所有屏幕的最小宽度都大于600dp时,屏幕就会自动到带sw600dp后缀的资源文件里去寻找相关资源文件，这里的最小宽度是指屏幕宽高的较小值，每个屏幕都是固定的，不会随着屏幕横向纵向改变而改变。</p>
<p>当应用程序提供了多个带有不同值的最小宽度限定符资源目录时，系统会使用最接近（不超出）设备最小宽度的那个资源。<br>这个限定符被添加在API级别13中。<br>还要看android:requiresSmallestWidthDp属性，它声明了与你的应用程序兼容的最小的最小宽度，并且smallestScreenWidthDp配置字段会持有这个设备最小宽度的值。</p>
<p>dip和dp是一个意思，都是Density Independent Pixels的缩写，即密度无关像素，规定以160dpi为基准，1dip=1px，如果密度是320dpi，则1dip=2px，以此类推。</p>
<p>理论计算公式：</p>
<p>smallestScreenWidthDp  =  最小宽度 * 160 / DPI </p>
<p>图片尺寸</p>
<p>密度</p>
<p>建议尺寸</p>
<p>mipmap-mdpi</p>
<p>48 * 48</p>
<p>mipmap-hdpi</p>
<p>72 * 72</p>
<p>mipmap-xhdpi</p>
<p>96 * 96</p>
<p>mipmap-xxhdpi</p>
<p>144 * 144</p>
<p>mipmap-xxxhdpi</p>
<p>192 * 192</p>
<p>DPI:每英寸像素数</p>
<p>简单的屏幕分辨率计算方法：</p>
<p>DisplayMetrics metrics = this.getResources().getDisplayMetrics();<br>float density = metrics.density;<br>int dpi = metrics.densityDpi;<br>int heightPixels = metrics.heightPixels;<br>int widthPixels = metrics.widthPixels;<br>Log.e(&quot;—metrics—&quot;, &quot;比例:&quot;+density+&quot;dpi:&quot;+dpi+&quot;高像素:&quot;+heightPixels+&quot;宽像素:&quot;+widthPixels);</p>
<p>dp与px计算图（mdpi  1dp=1px）：</p>
<p>ldpi:1dp=0.75px  mdpi:1dp=1px  hdpi:1dp=1.5px  xhdpi:1dp=2px  xxhdpi:1dp=3px  xxxhdpi:1dp=4px</p>
<p>Android手机屏幕标准                      对应图标尺寸标准      屏幕密度         比例</p>
<p>xxxhdpi 3840<em>2160                           192</em>192             640          16</p>
<p>xxhdpi 1920<em>1080                            144</em>144             480          12</p>
<p>xhdpi  1280<em>720                            96</em>96              320           8</p>
<p>hdpi   480<em>800                             72</em>72              240           6</p>
<p>mdpi   480<em>320                             48</em>48              160           4</p>
<p>ldpi   320<em>240                             36</em>36              120           3</p>
<p>注：Android studio mipmap文件夹只存放启动图标icon</p>
<p>自动生成 values-swxxdp/strings.xml </p>
<p>import java.io.BufferedReader;<br>import java.io.BufferedWriter;<br>import java.io.File;<br>import java.io.FileReader;<br>import java.io.FileWriter;<br>import java.io.IOException;<br>import java.io.PrintWriter;<br>import java.text.DecimalFormat;</p>
<p>public class DimenTool {</p>
<pre><code>public static void gen() &#123;
    //以此文件夹下的dimens.xml文件内容为初始值参照
    File file = new File(&amp;quot;./Adiag/src/main/res/values/dimens.xml&amp;quot;);

    BufferedReader reader = null;
    StringBuilder sw480 = new StringBuilder();
    StringBuilder sw600 = new StringBuilder();
    StringBuilder sw720 = new StringBuilder();
    StringBuilder sw800 = new StringBuilder();

    try &#123;
        System.out.println(&amp;quot;生成不同分辨率：&amp;quot;);
        reader = new BufferedReader(new FileReader(file));
        String tempString;
        int line = 1;
        // 一次读入一行，直到读入null为文件结束
        while ((tempString = reader.readLine()) != null) &#123;

            if (tempString.contains(&amp;quot;&amp;lt;/dimen&amp;gt;&amp;quot;)) &#123;
                //tempString = tempString.replaceAll(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;);
                String start = tempString.substring(0, tempString.indexOf(&amp;quot;&amp;gt;&amp;quot;) + 1);
                String end = tempString.substring(tempString.lastIndexOf(&amp;quot;&amp;lt;&amp;quot;) - 2);
                //截取&amp;lt;dimen&amp;gt;&amp;lt;/dimen&amp;gt;标签内的内容，从&amp;gt;右括号开始，到左括号减2，取得配置的数字
                Double num = Double.parseDouble
                        (tempString.substring(tempString.indexOf(&amp;quot;&amp;gt;&amp;quot;) + 1,
                                tempString.indexOf(&amp;quot;&amp;lt;/dimen&amp;gt;&amp;quot;) - 2));
                //根据不同的尺寸，计算新的值，拼接新的字符串，并且结尾处换行。
                DecimalFormat df = new DecimalFormat(&amp;quot;#0.00&amp;quot;);
                //df.setMinimumFractionDigits(2);</code></pre>
<p>//                    sw480.append(start).append(df.format(num * 0.8)).append(end).append(&quot;\r\n&quot;);<br>//                    sw600.append(start).append(df.format(num * 1)).append(end).append(&quot;\r\n&quot;);<br>//                    sw720.append(start).append(df.format(num * 1.2)).append(end).append(&quot;\r\n&quot;);<br>//                    sw800.append(start).append(df.format(num * 8/6)).append(end).append(&quot;\r\n&quot;);</p>
<pre><code>                sw480.append(start).append(df.format(num * 0.6)).append(end).append(&amp;quot;\r\n&amp;quot;);
                sw600.append(start).append(df.format(num * 0.75)).append(end).append(&amp;quot;\r\n&amp;quot;);
                sw720.append(start).append(df.format(num * 0.9)).append(end).append(&amp;quot;\r\n&amp;quot;);
                sw800.append(start).append(df.format(num * 1)).append(end).append(&amp;quot;\r\n&amp;quot;);

            &#125; else &#123;
                sw480.append(tempString).append(&amp;quot;\n&amp;quot;);
                sw600.append(tempString).append(&amp;quot;\n&amp;quot;);
                sw720.append(tempString).append(&amp;quot;\n&amp;quot;);
                sw800.append(tempString).append(&amp;quot;\n&amp;quot;);
            &#125;

            line++;

        &#125;

        reader.close();
        System.out.println(&amp;quot;&amp;lt;!--  sw480 --&amp;gt;&amp;quot;);
        System.out.println(sw480);
        System.out.println(&amp;quot;&amp;lt;!--  sw600 --&amp;gt;&amp;quot;);
        System.out.println(sw600);
        System.out.println(&amp;quot;&amp;lt;!--  sw720 --&amp;gt;&amp;quot;);
        System.out.println(sw720);
        System.out.println(&amp;quot;&amp;lt;!--  sw800 --&amp;gt;&amp;quot;);
        System.out.println(sw800);


        String sw480file = &amp;quot;./Adiag/src/main/res/values-sw480dp/dimens.xml&amp;quot;;

        String sw600file = &amp;quot;./Adiag/src/main/res/values-sw600dp/dimens.xml&amp;quot;;

        String sw720file = &amp;quot;./Adiag/src/main/res/values-sw720dp/dimens.xml&amp;quot;;

        String sw800file = &amp;quot;./Adiag/src/main/res/values-sw800dp/dimens.xml&amp;quot;;


        //将新的内容，写入到指定的文件中去

        writeFile(sw480file, sw480.toString());
        writeFile(sw600file, sw600.toString());
        writeFile(sw720file, sw720.toString());
        writeFile(sw800file, sw800.toString());

    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        if (reader != null) &#123;
            try &#123;
                reader.close();
            &#125; catch (IOException e1) &#123;
                e1.printStackTrace();
            &#125;
        &#125;

    &#125;

&#125;


/**
 * 写入方法
 */

public static void writeFile(String file, String text) &#123;

    PrintWriter out = null;
    File fileOut = new File(file);
    if(!fileOut.getParentFile().exists())
        fileOut.getParentFile().mkdirs();
    try &#123;
        out = new PrintWriter(new BufferedWriter(new FileWriter(file)));
        out.println(text);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
    try &#123;
        out = new PrintWriter(new BufferedWriter(new FileWriter(file)));
        out.println(text);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;

    out.close();

&#125;

public static void main(String[] args) &#123;
    gen();
&#125;</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android媒体库框架Mediascanner</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E5%AA%92%E4%BD%93%E5%BA%93%E6%A1%86%E6%9E%B6Mediascanner/</url>
    <content><![CDATA[<p>Android平台上的媒体文件管理和桌面系统不同。在桌面系统上，不同目录下的媒体文件呈树状结构显示给用户，用户需要进入不同目录寻找该目录下的文件。而在Android平台上，不同目录下的媒体文件则以一层列表方式显示给用户，用户不需进入子目录就可以列出（某种类型的）所有媒体文件。</p>
<p>在Android上，为了实现这种模式的媒体文件管理，对所有管理的媒体文件抽取其元数据,也就是ID3（mp3文件包含的元数据可参考<a href="http://en.wikipedia.org/wiki/ID3%EF%BC%89%EF%BC%8C%E5%AD%98%E5%82%A8%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%EF%BC%8C%E5%B9%B6%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AAcontent">http://en.wikipedia.org/wiki/ID3），存储在数据库中，并作为一个content</a> provider提供给其他应用使用。用户的每一次显示媒体文件的操作，就是对这个数据库的一次查询操作。在多媒体管理模块中，主要分成三个模块：</p>
<p>多媒体数据库</p>
<p>MediaStore这个类是android系统提供的一个多媒体数据库，android中多媒体信息都可以从这里提取。这个MediaStore包括了多媒体数据库的所有信息，包括音频，视频和图像,android把所有的多媒体数据库接口进行了封装，所有的数据库不用自己进行创建，直接调用利用ContentResolver去掉用那些封装好的接口就可以进行数据库的操作，多媒体数据库的使用方法和SQLITE3的方法是一样的。</p>
<p>         MediaStore中的数据是在MediaScanner扫描后通过MediaProvider中的一个service进行更新的。框架图如下：</p>
<p>MediaScanner</p>
<p>在Android系统中，多媒体库是通过MediaScanner去扫描磁盘文件，对元信息的处理，并通过MediaProvider保存到MediaStore中。下图为MediaScannerr 框架：</p>
<p>图1-1  MediaScanner框架流程</p>
<p>MediaScanner可以通过手动控制，在ANDROID系统中，已经定制了三种事件会触发MediaScanner去扫描磁盘文件：ACTION_BOOT_COMPLETED、ACTION_MEDIA_MOUNTED、 ACTION_MEDIA_SCANNER_SCAN_FILE。其中ACTION_BOOT_COMPLETED是系统启动完后发出这个消息，ACTION_MEDIA_MOUNTED是插卡事件触发的消息，ACTION_MEDIA_SCANNER_SCAN_FILE消息一般是在一些文件操作后，开发人员手动发出的一个重新扫描多媒体文件的消息。发送消息通过sendBroadcast函数完成，比如广播一个ACTION_MEDIA_MOUNTED消息：</p>
<p>sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse(&quot;file://&quot;</p>
<p>                       + Environment.getExternalStorageDirectory())));</p>
<p>     由上可知是通过发送了一个广播（传递对应的扫描要求）来触发重新扫描磁盘事件，那么可以猜测系统肯定存在一个广播接收器（何时何地注册？），在收到这个广播消息后，通过对应参数启动MediaScannerService。MediaScannerService调用一个公用类MediaScanner去处理真正的工作。MediaScannerReceiver维持两种扫描目录：一种是内部卷（internal volume）指向$(ANDROID_ROOT)/media. 另一种是外部卷（external volume）指向$(EXTERNAL_STORAGE)，扫描的位置可以修改（一般外部不用修改，默认为SDCARD，内部根据驱动命名的INAND路经名做对应的修改），对应图1-1系统源码具体位置：</p>
<p>MediaScannerReceiver：/mydroid/packages/providers/MediaProvider/src/com/android/providers/media/MediaScannerReceiver.java</p>
<p>    Scanner事件接收，继承了BroadcastReceiver类，收到扫描消息后启动MediaScannerService，但有一点要注意的是： Service的onCreate的方法只会被调用一次，就是你无论多少次的startService又 bindService，Service只被创建一次。如果先是bind了，那么start的时候就直接运行Service的 onStart方法，如果先是start，那么bind的时候就直接运行onBind方法。如果你先bind上了，就stop不掉了，对啊，就是stopService不好使了，只能先UnbindService, 再StopService,所以是先start还是先bind行为是有区别的。（关于BINDLE接口请参考其它文档）</p>
<p>MediaScannerService：</p>
<p>/mydroid/packages/providers/MediaProvider/src/com/android/providers/media/MediaScannerService.java</p>
<p>通过此服务，去调用MediaScanner的具体实现方法。</p>
<p>MediaScanner:  (方法)</p>
<p>\frameworks\base\media\java\android\media\ MediaScanner.java</p>
<p>MediaPlayer整体流程：</p>
<p>Thumbnails缩略图概述</p>
<p>缩略图保存位置：/sdcard/DCIM/.thumbnails</p>
<p>缩略图（大）：一张张的JPEG文件</p>
<p>所有的都存入同一个二进制文件.thumbdata+version+”-”+hashcode，字节大小均为 10000bytes</p>
<p>详解：</p>
<p>对于每一张图片，都会生成大缩略图和小缩略图，大缩略图保存在（外部设备）/sdcard/DCIM/.thumbnails/ 目录下，大缩略图大小上限是512 X 384,下限1 X1。小缩略图被统一保存到一个随机访问文件 （外部设备）/sdcard/DCIM/.thumbnails/ +&quot;.thumbdata&quot; + version + &quot;-&quot;+ mUri.hashcode()</p>
<p>缩略图存储到数据库里面</p>
<p>扫描一个文件的最后endfile()会mMediaProvider.insert（）或者mMediaProvider.update（）。在mMediaProvider.insert（）时对于IMAGES_MEDIA 和VIDEO_MEDIA类型：requestMediaThumbnail（）—&gt;mCurrentThumbRequest.execute(); 在执行时会首先会去缩略图的数据库中查询，查询到就返回，未查询到会ThumbnailUtil.createVideoThumbnail(mPath)或者 ThumbnailUtil.createImageThumbnail(mCr, mPath, mUri, mOrigId,Images.Thumbnails.MICRO_KIND, true/<em>saveMini</em>/));</p>
<p>创建图片缩略图：</p>
<p>创建thumbnail时调用ThumbnailUtil.makeBitmap（）创建；如果saveMini为真会保存缩略图ThumbnailUtil.storeThumbnail(cr, origId, thumbData, bitmap.getWidth(), bitmap.getHeight());; 保存时会通过origId向数据库查询，查到返回对应的uri，未查找到就插入数据库并返回uri，最终返回bitmap。对于创建视频缩略图：直接在视频文件中取一帧得到bintmap并返回保存大缩略图到文件： bitmap.compress(Bitmap.CompressFormat.JPEG, 75, miniOutStream);保存小缩略图到随机访问文件：data = miniOutStream.toByteArray(); miniThumbFile.saveMiniThumbToFile(data, mOrigId, magic);</p>
<p>在mMediaProvider.update（）时，对IMAGES_MEDIA，IMAGES_MEDIA_ID，VIDEO_MEDIA，VIDEO_MEDIA_ID类型会查询magic，如果没查到会执行requestMediaThumbnail（），流程同上。</p>
<p>MediaProvider是对上面整个流程的实现。可参考里面的代码。</p>
<p>图3 MediaProvider 代码架构e</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发之ActivityManager</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E5%BC%80%E5%8F%91%E4%B9%8BActivityManager/</url>
    <content><![CDATA[<p>ActivityManager服务是对Activity管理、运行时功能管理和运行时数据结构的封装，进程(Process)、应用程序/包、服务(Service)、任务(Task)信息等。包括以下功能：</p>
<p>激活／去激活activity</p>
<p>注册／取消注册动态接受intent</p>
<p>发送／取消发送intent</p>
<p>activity生命周期管理（暂停，恢复，停止，销毁等）</p>
<p>activity task管理（前台－&gt;后台，后台－&gt;前台，最近task查询，运行时task查询）</p>
<p>激活／去激活service</p>
<p>激活／去激活provider等</p>
<p>常用内部静态类有：</p>
<p>ActivityManager.MemoryInfo： 系统可用内存信息</p>
<p>ActivityManager.RecentTaskInfo： 最近的任务信息</p>
<p>ActivityManager.RunningAppProcessInfo： 正在运行的进程信息</p>
<p>ActivityManager.RunningServiceInfo： 正在运行的服务信息</p>
<p>ActivityManager.RunningTaskInfo： 正在运行的任务信息</p>
<p>用法：</p>
<p>1.获取ActivityManager服务：</p>
<p>ActivityManager mActivityManager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</p>
<p>2.获取内存信息：</p>
<p>MemoryInfo memoryInfo = new MemoryInfo() ; <br>     mActivityManager.getMemoryInfo(memoryInfo);</p>
<p>3.获取正在运行的task信息：</p>
<p> List&lt;RunningTaskInfo&gt; runningTaskInfos = mActivityManager.getRunningTasks(Integer.MAX_VALUE);<br>    String cmpNameTemp = null;<br>    if (null != runningTaskInfos)<br>    {<br>        cmpNameTemp = (runningTaskInfos.get(0).topActivity).toString();<br>    }</p>
<p>4.判断android应用是否在前台：</p>
<p>public static boolean isAppOnForeground(Context context)<br>    {<br>        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);<br>        String packageName = context.getPackageName();<br>        List&lt;RecentTaskInfo&gt; appTask = activityManager.getRecentTasks(Integer.MAX_VALUE, 1);</p>
<pre><code>    if (appTask == null)
    &#123;
        return false;
    &#125;

    if (appTask.get(0).baseIntent.toString().contains(packageName))
    &#123;
        return true;
    &#125;
    return false;
&#125;</code></pre>
<p>5.获取android手机内安装的所有桌面：</p>
<p>private static List&lt;String&gt; getAllTheLauncher(Context context)<br>    {<br>        List&lt;String&gt; names = null;<br>        PackageManager pkgMgt = context.getPackageManager();<br>        Intent it = new Intent(Intent.ACTION_MAIN);<br>        it.addCategory(Intent.CATEGORY_HOME);<br>        List&lt;ResolveInfo&gt; ra = pkgMgt.queryIntentActivities(it, 0);<br>        if (ra.size() != 0)<br>        {<br>            names = new ArrayList&lt;String&gt;();<br>        }<br>        for (int i = 0; i &lt; ra.size(); i++)<br>        {<br>            String packageName = ra.get(i).activityInfo.packageName;<br>            names.add(packageName);<br>        }<br>        return names;<br>    }</p>
<p>6.判断程序前后台状态：</p>
<p>public static boolean isLauncherRunning(Context context)<br>    {<br>        boolean result = false;<br>        List&lt;String&gt; names = getAllTheLauncher(context);<br>        ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);<br>        List&lt;ActivityManager.RunningAppProcessInfo&gt; appList = mActivityManager.getRunningAppProcesses();<br>        for (RunningAppProcessInfo running : appList)<br>        {<br>            if (running.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND)<br>            {<br>                for (int i = 0; i &lt; names.size(); i++)<br>                {<br>                    if (names.get(i).equals(running.processName))<br>                    {<br>                        result = true;<br>                        break;<br>                    }<br>                }<br>            }<br>        }<br>        return result;<br>    }</p>
<p>7.获取系统中进程信息：</p>
<p>private void getRunningAppProcessInfo() {   <br>        processInfoList = new ArrayList&lt;ProcessInfo&gt;(); </p>
<p>   List&lt;ActivityManager.RunningAppProcessInfo&gt; appProcessList = mActivityManager.getRunningAppProcesses(); </p>
<p>   for (ActivityManager.RunningAppProcessInfo appProcessInfo : appProcessList) { </p>
<p>        int pid = appProcessInfo.pid; </p>
<p>        int uid = appProcessInfo.uid; </p>
<p>       String processName = appProcessInfo.processName; </p>
<p>       int[] myMempid = new int[] { pid }; </p>
<p>       Debug.MemoryInfo[] memoryInfo = mActivityManager.getProcessMemoryInfo(myMempid); </p>
<p>       int memSize = memoryInfo[0].dalvikPrivateDirty; </p>
<p>       Log.i(TAG, &quot;processName: &quot; + processName + &quot;  pid: &quot; + pid </p>
<p>                    + &quot; uid:&quot; + uid + &quot; memorySize is –&gt;&quot; + memSize + &quot;kb&quot;); </p>
<p>            // 构造一个ProcessInfo对象</p>
<p>            ProcessInfo processInfo = new ProcessInfo(); </p>
<p>            processInfo.setPid(pid); </p>
<p>            processInfo.setUid(uid); </p>
<p>            processInfo.setMemSize(memSize); </p>
<p>            processInfo.setPocessName(processName); </p>
<p>            processInfoList.add(processInfo); </p>
<p>           // 获得每个进程里运行的应用程序(包),即每个应用程序的包名</p>
<p>            String[] packageList = appProcessInfo.pkgList; </p>
<p>            Log.i(TAG, &quot;process id is &quot; + pid + &quot;has &quot; + packageList.length); </p>
<p>            for (String pkg : packageList) { </p>
<p>                Log.i(TAG, &quot;packageName &quot; + pkg + &quot; in process id is –&gt;&quot;+ pid); </p>
<p>            } </p>
<p>        } </p>
<p>    } </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android禁止系统升级</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E7%A6%81%E6%AD%A2%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>/system/etc/security/otacerts.zip</p>
<p>将此文件重命名即可</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android私有文件资源文件的存取</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E7%A7%81%E6%9C%89%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%8F%96/</url>
    <content><![CDATA[<p>一、私有文件夹下的文件存取（/data/data/包名）</p>
<p>import java.io.FileInputStream;   import java.io.FileOutputStream;    import org.apache.http.util.EncodingUtils;       public void writeFileData(String fileName,String message){       try{         FileOutputStream fout = openFileOutput(fileName, MODE_PRIVATE);        byte [] bytes = message.getBytes();         fout.write(bytes);         fout.close();         }       catch(Exception e){         e.printStackTrace();       }    }             public String readFileData(String fileName){         String res=&quot;&quot;;        try{          FileInputStream fin = openFileInput(fileName);         int length = fin.available();          byte [] buffer = new byte[length];         fin.read(buffer);              res = EncodingUtils.getString(buffer, &quot;UTF-8&quot;);         fin.close();             }        catch(Exception e){          e.printStackTrace();        }         return res;       }      </p>
<p>二、从resource中的raw文件夹中获取文件并读取数据（资源文件只能读不能写）</p>
<p>dpublic String getFromRaw(String fileName){  </p>
<p>    String res = &quot;&quot;;           try{            InputStream in = getResources().openRawResource(R.raw.test1);             int length = in.available();                  byte [] buffer = new byte[length];                   in.read(buffer);                    res = EncodingUtils.getString(buffer, &quot;UTF-8&quot;);               in.close();                      }           catch(Exception e){            e.printStackTrace();                   }        return res ;       }    </p>
<p>三、从asset中获取文件并读取数据（资源文件只能读不能写）</p>
<p>public String getFromAsset(String fileName){       String res=&quot;&quot;;        try{        InputStream in = getResources().getAssets().open(fileName);           int length = in.available();                   byte [] buffer = new byte[length];                   in.read(buffer);                      res = EncodingUtils.getString(buffer, &quot;UTF-8&quot;);            }       catch(Exception e){         e.printStackTrace();               }        return res;      }     </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android系统 启动三种模式 及OTA包升级流程</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E7%B3%BB%E7%BB%9F%20%E5%90%AF%E5%8A%A8%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%20%E5%8F%8AOTA%E5%8C%85%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>三种模式</p>
<p>        烧写的过程中，需要在三种模式下互相切换。确切的说，应该是三个操作环境：bootloader、recovery和main system。</p>
<p>        bootloader主要用来屏蔽硬件的差异，类似于PC中的BIOS，它的功能相对比较简单，内部提供了一些命令，比如：可以将nand flash分区加载到内存、运行内存中的程序、操作SD卡等。Android中的booloader是uboot，位于源码的uboot目录下。</p>
<p>        main system就是正常运行的Android操作系统，而recovery则是一个mini的Android系统，顾名思义，就是用来进行系统恢复相关的操作的，它的运行规则和main system一样，只是，它在启动时只加载recovery服务，此服务用于烧写Android系统。</p>
<p>        三者之间的关系如下图所示：</p>
<p>        系统先启动到bootloader模式下，然后根据情况，启动到recovery或者main system模式下。</p>
<p>bootloader</p>
<p>        板子启动时，在Putty控制台中按回车，可以进入uboot，输入help可以查看其可用的命令。uboot的命令是可以自定义的，需要在uboot源码中进行设置。</p>
<p>uboot下可以使用fastboot命令，进入fastboot模式下，可以使用PC与之连接（此时，使用fastboot协议通信），进行Android系统的烧写工作。</p>
<p>        在uboot中，你可以更新uboot在内的所有系统模块。</p>
<p>recovery</p>
<p>        recovery系统包含了内核和类似于根文件系统两部分，启动时仍采用init进程和init.rc配置脚本，不同的是init.rc脚本比较简单，system目录中只存放了一些必备的工具。</p>
<p>        recovery系统下，你能更新除uboot之外的所有Android系统模块。</p>
<p>        recovery模式下，只有一个recovery服务，该服务对应于recovery进程，源码位置：bootable\recovery。</p>
<p>main system</p>
<p>        main system是正常运行的Android系统。</p>
<p>通信</p>
<p>        Android板子每个时刻只可以处于bootloader、recovery、main system其中的一个模式中，烧写过程中，三个模式之间需要通信，比如：main system通知recovery烧写那个升级包。</p>
<p>大致有三种方式可以用来通信：BCB、寄存器和cache分区。</p>
<p>BCB</p>
<p>        BCB (bootloader control block)可以用于main system传递数据给bootloader和recovery模式。BCB的内容存在于nand flash的一个独立的分区，可以在nand flash分区表中看到，分区的名称为misc。</p>
<p>        通过BCB，main system可以通知bootloader启动到recovery模式下，同时也可以传递命令给recovery，比如烧写哪个文件。</p>
<p>        recovery在烧写的过程中，会设置BCB，以确保烧写成功前，一直会开机启动到recovery模式下，这样可以防止烧写过程中断电的情况。</p>
<p>寄存器</p>
<p>        main system模式下，运行如下命令会重启，并进入recovery模式：（也可调用android_reboot函数） </p>
<p> reboot recovery  </p>
<p>        reboot命令实际上是系统调用，最终会调用到内核的kernel_restart函数，该函数最终会设置某个寄存器的位置，然后执行重启操作。</p>
<p>重启后，bootloader会检测到该寄存器的值，并根据其值，启动到recovery模式下。</p>
<p>cache分区</p>
<p>        recovery和main system模式下，都会将nand flash的cache分区挂载到cache目录从而实现这两种模式下的通信。比如：main system模式下，下载升级包update.zip，并将其路径设置到文件/cache/recovery/command中，然后重启到recovery模式下，recovery进程会读取到文件/cache/recovery/command中的值，并执行系统升级工作。</p>
<p>升级包</p>
<p>        通常升级包的名称为update.zip，它包含了要升级的内容和升级脚本，也就是说，整个升级的过程都由升级包本省控制。</p>
<p>        升级脚本解析对应的源码：META-INF\com\google\android\updater-script。可用的命令列表可以参见bootable\recovery\updater\install.c的函数RegisterInstallFunctions()。</p>
<p>        解析升级脚本采用语言Edify，源码位置：bootable\recovery\updater和bootable\recovery\edify。</p>
<p>        若想自己制作update.zip包，需要使用的一下三个文件：</p>
<p>out/host/linux-x86/framework/signapk.jar</p>
<p>build/target/product/security/testkey.pk8</p>
<p>build/target/product/security/testkey.x509.pem</p>
<p>        制作的过程：</p>
<p>解压从源码中编译出来的update.zip。</p>
<p>修改解压后的文件。</p>
<p>重新压成包update.zip</p>
<p>使用命令处理update.zip，该命令主要是最zip执行签名操作：java -Xmx1024m -jar signapk.jar -w testkey.x509.pem testkey.pk8 update.zip update_unsigned.zip</p>
<p>update_unsigned.zip就是最终的升级包。</p>
<p>启动流程</p>
<p>        启动流程大致路下：</p>
<p>        1.开机后，启动到bootloader下，bootloader会作一些初始化的操作，然后会从三个地方确定后面的动作：</p>
<p>        查找SD卡上指定的文件：此种情况，主要用于，通过SD卡，升级系统。只要在SD卡中按照规则放置升级文件和相关的脚本，即可实现系统的升级。</p>
<p>        查找按键的状态：此种情况主要用于开机后进入bootloader或者recovery模式，按键也通常是硬件上的几个键按下的状态。</p>
<p>        获取BCB的内容：需要根据BCB的内容，来执行具体的操作，通常是进入recovery模式。</p>
<p>        若没有发现上述的三种信息，则会按照正常的启动流程，进入main system模式。</p>
<p>        2.若需要通过SD卡升级，则会显示升级提示界面，并开始系统升级，完成后，重启进入main system。</p>
<p>        3.若需要进入recovery模式，在bootloader模式下，会加载recovery分区到内存，然后进入recovery模式下。</p>
<p>        recovery会启动recovery进程，该进程会读取/cache/recovery分区中的内容，决定具体的操作。若没有相关的配置，则进入控制台模式。</p>
<p>        4.若需要进入main system模式，则会加载boot分区中的内容，然后进入正常的启动流程。</p>
<p>升级流程</p>
<p>        升级的流程大致如下：</p>
<p>        1.main system模式下，下载update.zip到/cache目录。</p>
<p>        2.设置/cache/recovery/command目录的内容为：–update_package=/cache/update.zip。</p>
<p>        3.调用函数android_reboot，并设置进入recovery模式的代码。</p>
<p>        4.系统重启，进入recovery模式，并启动recovery进程，该进程会检测/cache/recovery/command的内容，然后升级update.zip。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android编译</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>Android移植流程</p>
<p>1.Seftup Develop Environment &amp;&amp; Get Android Source</p>
<p>1)Host System –&gt; Git , Repo</p>
<p>2)Getting Android Source Code</p>
<p>2.Build Linux Kernel</p>
<p>1)Configuration Option</p>
<p>2)Code modification for Android</p>
<p>3)Building Linux Kernel –&gt; uImage</p>
<p>3.Build File System</p>
<p>1)Produce file system</p>
<p>2)Modify Initialization Procedure</p>
<p>3)Generating File System Image –&gt; yaffs2 iamge</p>
<p>android编译 步骤</p>
<p>1.source ./build/envsetup.sh  or . ./build/envsetup.sh</p>
<p>envsetup.sh 定义许多function ,放入内存</p>
<p>mmm , mm ,choosecombo</p>
<p>2.choosecomdbo or lunch full-eng</p>
<p>choosesim $1</p>
<p>choosetype $2</p>
<p>chooseproduct $3</p>
<p>choosevariant $4</p>
<p>set_stuff_for_environment </p>
<p>printfconfig</p>
<p>PLATFROM_VERSION_CODENAME: release  debug</p>
<p>TARGET_PRODUCT=fs100  产品名</p>
<p>TARGET_BUILD_VARIANT = eng  userdebug user</p>
<p>3.make -j4</p>
<p>Makefile </p>
<p>-&gt;include build/core/main.mk</p>
<p> -&gt;include $(BUILD_SYSTEM)/config.mk</p>
<p>  -&gt;./build/core/config.mk</p>
<p>   -&gt;include $(BUILD_SYSTEM)/envsetup.mk</p>
<p>    -&gt;include $(BUILD_SYSTEM)/product_config.mk</p>
<p>     -&gt;include $(BUILD_SYSTEM)/product.mk</p>
<p>      -&gt;$(shell test -d vendor &amp;&amp; find vendor -maxdepth 6 -name AndroidProducts.mk)\</p>
<p>$(SRC_TARGET_DIR)/product/AndroidProducts.mk</p>
<p>遍历整个 vendor 子目录 ，找到device所有的 AndroidProducts.mk</p>
<p>AndroidBoard.mk</p>
<p>BoardConfig.mk</p>
<p>AndroidProducts.mk</p>
<p>&lt;product_name&gt;.mk</p>
<p>Android.mk</p>
<p>Android.mk</p>
<p>1.编译可执行程序</p>
<p>2.编译动态或静态库</p>
<p>3.预编译文件</p>
<p>4.编译apk</p>
<p>LOCAL_PATH := $(call my-dir) //返回当前源码路径</p>
<p>include $(CLEAR_VARS)        //清除LOCALxxx变量</p>
<p>LOCAL_MODULE := hello_exe    //必须定义 目标对象</p>
<p>LOCAL_SRC_FILES := main.c    //源文件</p>
<p>include $(BUILD_EXECUTABLE)  //指定编译成可执行文件</p>
<p>//编译链接库</p>
<p>LOCAL_PATH := $(call my-dir)</p>
<p>include $(CLEAR_VARS)</p>
<p>LOCAL_MODULE = libhello</p>
<p>LOCAL_SRC_FILES = main.c</p>
<p>TARGET_PRELINK_MODULES := false</p>
<p>LOCAL_C_INCLUDES = $(INCLUDES)</p>
<p>include $(BUILD_SHARED_LIBRARY)</p>
<p>/BUILD_STATIC_LIBRARY</p>
<p>//预编译</p>
<p>//将GfanMobile.apk 预编译到 out/target/product/*/system/app/</p>
<p>LOCAL_PATH := $(call my-dir)</p>
<p>include $(CLEAR_VARS)</p>
<p>LOCAL_MODULE := GfanMobile.apk</p>
<p>LOCAL_MODULE_TAGS := user</p>
<p>LOCAL_MODULE_CLASS := APPS</p>
<p>LOCAL_SRC_FILES := $(LOCAL_MODULE)</p>
<p>include $(BUILD_PREBUILT)</p>
<p>//编译apk</p>
<p>LOCAL_PATH := $(call my-dir)</p>
<p>include $(CLEAR_VARS)</p>
<p>LOCAL_MODULE_TAGS := APPS</p>
<p>LOCAL_SRC_FILES := $(call all-java-files-under,src)</p>
<p>LOCAL_PACKAGE_NAME := FarsightHello</p>
<p>LOCAL_SDK_VERSION := current</p>
<p>include $(BUILD_PACKAGE)</p>
<p>ramdisk.img //根文件系统</p>
<p>/out/target/product/xxx/root</p>
<p>包含 : init , init.rc</p>
<p>system.img //system目录 android的系统文件夹</p>
<p>/out/target/product/xxx/system</p>
<p>包含：app bin lib  framework etc </p>
<p>userdata.img  //data 系统运行时系统文件夹 一般为空 </p>
<p>/out/target/product/xx/</p>
<p>userdata.img 将挂载到/data </p>
<p>system/app –&gt; /data</p>
<p>cache &gt;&gt;  /data/misc/wifi  /data/system/wpa_supplicant</p>
<p>//cache目录</p>
<p>ramdisk 运行起来后 init.rc 将设备定义为cache 挂载到 /cache</p>
<p>Java调用c/c++框架</p>
<p>1.编写java代码</p>
<p>   static{</p>
<p>System.loadLibrary(&quot;hell_jni&quot;);</p>
<p>}</p>
<p>   private static native int fsSayHello();</p>
<p>2.编写jni文件</p>
<p>  jint JNI_OnLoad(JavaVM* vm,void* reserved){}</p>
<p>  static JNINAtiveMethod gMethods[]=  //方法映射</p>
<p>   { &quot;fsSayHello&quot;, &quot;()I&quot;, (void*)hello_printf};</p>
<p>  RegisterNative(clazz,gMethods,sizeof(gMethods) sizeof(gMethos[0]))</p>
<p>3.将jni实现文件编译成一个native lib</p>
<p>static jint hello_printf(JNIEnv *env,jobject thiz)</p>
<p>HAL 主要目录</p>
<p> libhardware_legacy 旧的架构 采取链接库模块的观念</p>
<p> libhardware    新架构 调整为 HAL stub观念</p>
<p> ril   Radio Interface Layer</p>
<p> //旧HAL  HAL module </p>
<p> //function call 多个进程使用 mapping到多个进程空间 造成浪费</p>
<p> libhardware_legacy: module -&gt;.so</p>
<p> framework &amp; applications</p>
<p>   -&gt;external Libraries &amp;&amp; Runtime</p>
<p>     -&gt;*.so(libhardware_legacy)</p>
<p>-&gt;Linux Device Driver</p>
<p> //新HAL  HAL stub</p>
<p> //HAL module 与 HAL stub结合</p>
<p> //编译上层时只拥有HAL stub 函数指针</p>
<p> //上层通过HAL module提供统一并操作HAL stub</p>
<p> //so文件只会被mapping 到一个进程</p>
<p>  libhardware: HAL stub proxy 概念</p>
<p>  framework &amp; applications</p>
<p>   -&gt;External Libraries &amp; Runtime</p>
<p>     -&gt;   HAL (libhardware)</p>
<p>      -&gt;  sensor stub  xstub  xxstub</p>
<p>        -&gt; Linux Device Driver    </p>
<p>HAL module 三个结构</p>
<p>struct hw_module_t;</p>
<p>struct hw_module_methods_t;</p>
<p>struct hw_device_t;</p>
<p>app -&gt; jni -&gt; hal -&gt; ctrl hardware</p>
<p>logcat [options] [filterspecs]</p>
<p> -s 过滤</p>
<p>  logcat -s ActivityManager:v*:s</p>
<p> -f &lt;filename&gt;  or &gt;&gt; &gt;</p>
<p>  logcat -f /data/log.txt</p>
<p> -v &lt;format&gt;  brief process tag thread raw time</p>
<p> -c clean and quit</p>
<p> -d print out all log then quit</p>
<p> -b &lt;buffer&gt;</p>
<p>优先级</p>
<p>V – Verbose</p>
<p>D – Debug</p>
<p>I – Info </p>
<p>W – Warning</p>
<p>E – Error</p>
<p>F – Fatal</p>
<p>S – Silent</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android系统版本信息</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF.Build/</url>
    <content><![CDATA[<p>android.os.Build</p>
<p>public static final String BOARD The name of the underlying board, like &quot;goldfish&quot;.</p>
<p>public static final String BOOTLOADER The system bootloader version number.</p>
<p>public static final String BRAND The brand (e.g., carrier) the software is customized for, if any.</p>
<p>public static final String CPU_ABI The name of the instruction set (CPU type + ABI convention) of native code.</p>
<p>public static final String CPU_ABI2 The name of the second instruction set (CPU type + ABI convention) of native code.</p>
<p>public static final String DEVICEThe name of the industrial design.</p>
<p>public static final String DISPLAY A build ID string meant for displaying to the user</p>
<p>public static final String FINGERPRINTA string that uniquely identifies this build.</p>
<p>public static final String HARDWARE The name of the hardware (from the kernel command line or /proc).</p>
<p>public static final String HOST</p>
<p>public static final String ID Either a changelist number, or a label like &quot;M4-rc20&quot;.</p>
<p>public static final String MANUFACTURER The manufacturer of the product/hardware.</p>
<p>public static final String MODELThe end-user-visible name for the end product.</p>
<p>public static final String PRODUCT The name of the overall product.</p>
<p>public static final String RADIO This field was deprecated in API level 14. The radio firmware version is frequently not available when this class is initialized, leading to a blank or &quot;unknown&quot; value for this string. Use getRadioVersion() instead.</p>
<p>public static final String SERIAL A hardware serial number, if available.</p>
<p>public static final String TAGS Comma-separated tags describing the build, like &quot;unsigned,debug&quot;.</p>
<p>public static final long TIME</p>
<p>public static final String TYPE The type of build, like &quot;user&quot; or &quot;eng&quot;.</p>
<p>public static final String USER</p>
<p>android.os.Build.VERSION</p>
<p>public static final String CODENAME The current development codename, or the string &quot;REL&quot; if this is a release build.</p>
<p>public static final String INCREMENTAL The internal value used by the underlying source control to represent this build.</p>
<p>public static final String RELEASE The user-visible version string.</p>
<p>public static final String SDK This field was deprecated in API level 4. Use SDK_INT to easily get this as an integer.</p>
<p>public static final int SDK_INT The user-visible SDK version of the framework; its possible values are defined in Build.VERSION_CODES.</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android设备节点的创建</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p>Android设备节点的创建</p>
<p>在编写linux设备驱动程序的时候，很多时候都是利用mknod命令来手动创建设备节点的，带上名字和主次设备号就可以在/dev目录下生成设备节点。同样Android沿用了linux内核，很多设备驱动的节点是又是什么时候创建的呢？</p>
<p>在kernel自解压模块加载完成之后，会去运行android第一个应用程序init。在init.c的main函数中。</p>
<p>System/core/init/init.c</p>
<p>int main(int argc, char **argv)</p>
<p>{</p>
<p>……</p>
<p>action_for_each_trigger(&quot;boot&quot;, action_add_queue_tail);</p>
<p>……</p>
<p>}</p>
<p>在init进程解析init.rc脚本完成后，在on boot的最后两句是class start main和core，其中class</p>
<p>Start是命令，在keyword.h中定义了class_start对应的function实际就是do_class_start。</p>
<p>System/core/init/builtins.c</p>
<p>int do_class_start(int nargs, char **args)</p>
<p>{</p>
<p>  service_for_each_class(args[1], service_start_if_not_disabled);</p>
<p>    return 0;</p>
<p>}</p>
<p>System/core/init/init_parser.c</p>
<p>void service_for_each_class(const char *classname, void (*func)(struct service *svc))</p>
<p>{</p>
<p>……</p>
<p>list_for_each(node, &amp;service_list) {</p>
<p>        svc = node_to_item(node, struct service, slist);</p>
<p>        if (!strcmp(svc-&gt;classname, classname)) {</p>
<p>            func(svc);</p>
<p>        }  </p>
<p>}</p>
<p>在之前解析init.rc脚本的时候，service会被放在service_list的链表里。接下来就是要执行service_for_each_class的func(svc)，也就是service_start_if_not_disabled。</p>
<p>System/core/init/builtins.c</p>
<p>static void service_start_if_not_disabled(struct service *svc)</p>
<p>{</p>
<p>    if (!(svc-&gt;flags &amp; SVC_DISABLED)) {</p>
<p>        service_start(svc, NULL);</p>
<p>    }  </p>
<p>}</p>
<p>Android的service大都是编译成可执行文件以命令的格式，我们注意到在init.rc中又这么个service值得关注下。</p>
<p>service ueventd /sbin/ueventd</p>
<p>    class core</p>
<p>    critical</p>
<p>Android的服务不是选项不是disabled并且带core和main的选项的服务都是需要开机自动加载的服务。而ueventd是由system/core/init/ueventd.c编译而成的。</p>
<p>System/core/init/ueventd.c</p>
<p>int ueventd_main(int argc, char **argv)</p>
<p>{</p>
<p>……</p>
<p>ueventd_parse_config_file(&quot;/ueventd.rc&quot;);</p>
<p>……</p>
<p>snprintf(tmp, sizeof(tmp), &quot;/ueventd.%s.rc&quot;, hardware);</p>
<p>ueventd_parse_config_file(tmp);</p>
<p>……</p>
<p>device_init();</p>
<p>……</p>
<p>while(1) {</p>
<p>        ufd.revents = 0;</p>
<p>        nr = poll(&amp;ufd, 1, -1);</p>
<p>        if (nr &lt;= 0)</p>
<p>            continue;</p>
<p>        if (ufd.revents == POLLIN)</p>
<p>               handle_device_fd();</p>
<p>}</p>
<p>}</p>
<p>Ueventd的main函数做的事情比较多，首先是要解析根文件系统下的ueventd.rc以及ueventd.</p>
<p>${hardware}.rc。</p>
<p>System/core/init/ueventd_parser.c</p>
<p>int ueventd_parse_config_file(const char *fn)</p>
<p>{</p>
<p>char *data;</p>
<p>    data = read_file(fn, 0);</p>
<p>    if (!data) return -1;</p>
<p>    parse_config(fn, data);</p>
<p>    DUMP();</p>
<p>    return 0;</p>
<p>}</p>
<p>static void parse_config(const char *fn, char *s)</p>
<p>{</p>
<p>……</p>
<p>state.parse_line = parse_line_device;</p>
<p>……</p>
<p>for (;;) {</p>
<p>……</p>
<p>switch (token) {</p>
<p>        case T_EOF:</p>
<p>            state.parse_line(&amp;state, 0, 0);</p>
<p>            return;</p>
<p>        case T_NEWLINE:</p>
<p>            if (nargs) {</p>
<p>            tate.parse_line(&amp;state, 0, 0);</p>
<p>……</p>
<p>}</p>
<p>解析过程中，会去循环解析这个文件，对解析的结果调用state.parse_line，对应的回调函数就是parse_line_device。</p>
<p>System/core/init/ueventd_parser.c</p>
<p>static void parse_line_device(struct parse_state* state, int nargs, char **args)</p>
<p>{</p>
<p>    set_device_permission(nargs, args);</p>
<p>}</p>
<p>在set_device_permission(nargs, args)中会获取设备的mode，uid，gid。给设备增加操作权限。</p>
<p>然后通过device_init给设备添加创建NETLINK套接字。</p>
<p>System/core/init/ueventd.c</p>
<p>int ueventd_main(int argc, char **argv)</p>
<p>{</p>
<p>……</p>
<p>ueventd_parse_config_file(&quot;/ueventd.rc&quot;);</p>
<p>……</p>
<p>snprintf(tmp, sizeof(tmp), &quot;/ueventd.%s.rc&quot;, hardware);</p>
<p>ueventd_parse_config_file(tmp);</p>
<p>……</p>
<p>device_init();</p>
<p>……</p>
<p>while(1) {</p>
<p>        ufd.revents = 0;</p>
<p>        nr = poll(&amp;ufd, 1, -1);</p>
<p>        if (nr &lt;= 0)</p>
<p>            continue;</p>
<p>        if (ufd.revents == POLLIN)</p>
<p>               handle_device_fd();</p>
<p>}</p>
<p>}</p>
<p>通过轮询的方式查看设备的uevent的变化，在设备注册产生kobject_uevent。在设备处理时候调用了handle_device_fd()。</p>
<p>System/core/init/devices.c</p>
<p>void handle_device_fd()</p>
<p>{</p>
<p>……</p>
<p>char msg[UEVENT_MSG_LEN+2];</p>
<p>    int  n;</p>
<p>    while ((n = uevent_kernel_multicast_recv(device_fd, msg, UEVENT_MSG_LEN)) &gt; 0) {</p>
<p>        if(n &gt;= UEVENT_MSG_LEN)   /* overflow – discard */</p>
<p>            continue;</p>
<p>        msg[n] = ‘\0’;</p>
<p>        msg[n+1] = ‘\0’;</p>
<p>        struct uevent uevent;</p>
<p>        parse_event(msg, &amp;uevent);</p>
<p>        handle_device_event(&amp;uevent);</p>
<p>        handle_firmware_event(&amp;uevent);</p>
<p>    }      </p>
<p>}  </p>
<p>接收的uevent的小心不能超过1024个字节，如果超出就算溢出将不会处理。如果接收的uevent有效，解析这个uevent会根据设备的类型来解析。之后handle_device_event会处理设备的event。而handle_firmware_event则是和某些设备需要firmware回去处理firmware的加载。</p>
<p>System/core/init/devices.c</p>
<p>static void handle_device_event(struct uevent *uevent)</p>
<p>{</p>
<p>    if (!strcmp(uevent-&gt;action,&quot;add&quot;))</p>
<p>        fixup_sys_perms(uevent-&gt;path);</p>
<p>    if (!strncmp(uevent-&gt;subsystem, &quot;block&quot;, 5)) {</p>
<p>        handle_block_device_event(uevent);</p>
<p>    } else if (!strncmp(uevent-&gt;subsystem, &quot;platform&quot;, 8)) {</p>
<p>        handle_platform_device_event(uevent);</p>
<p>    } else {</p>
<p>        handle_generic_device_event(uevent);</p>
<p>    }</p>
<p>}</p>
<p>如果event的subsystem为block，说明是个块设备，就会交由handle_block_device_event去处理。或者subsystem是platform设备的话，则有handle_platform_device_event来处理。如果两者都不是的话，说明是一个普通设备，handle_generic_device_event会来处理。块设备和平台设备的处理方式比较特殊，先看一般通用设备的处理过程。</p>
<p>System/core/init/devices.c</p>
<p>static void handle_generic_device_event(struct uevent *uevent)</p>
<p>{</p>
<p>……</p>
<p>name = parse_device_name(uevent, 64);</p>
<p>……</p>
<p>if (!strncmp(uevent-&gt;subsystem, &quot;usb&quot;, 3)) {</p>
<p>         if (!strcmp(uevent-&gt;subsystem, &quot;usb&quot;)) {</p>
<p>             /* This imitates the file system that would be created</p>
<p>              * if we were using devfs instead.</p>
<p>              * Minors are broken up into groups of 128, starting at &quot;001&quot;</p>
<p>              */</p>
<p>             int bus_id = uevent-&gt;minor / 128 + 1;</p>
<p>             int device_id = uevent-&gt;minor % 128 + 1;</p>
<p>             /* build directories */</p>
<p>             mkdir(&quot;/dev/bus&quot;, 0755);</p>
<p>             mkdir(&quot;/dev/bus/usb&quot;, 0755);</p>
<p>             snprintf(devpath, sizeof(devpath), &quot;/dev/bus/usb/%03d&quot;, bus_id);</p>
<p>             mkdir(devpath, 0755);</p>
<p>             snprintf(devpath, sizeof(devpath), &quot;/dev/bus/usb/%03d/%03d&quot;, bus_id, device_id);</p>
<p>         } else {</p>
<p>             /* ignore other USB events */</p>
<p>             return;</p>
<p>         }</p>
<p>……</p>
<p>else if (!strncmp(uevent-&gt;subsystem, &quot;graphics&quot;, 8)) {</p>
<p>         base = &quot;/dev/graphics/&quot;;</p>
<p>         mkdir(base, 0755);</p>
<p>     } else if (!strncmp(uevent-&gt;subsystem, &quot;drm&quot;, 3)) {</p>
<p>         base = &quot;/dev/dri/&quot;;</p>
<p>         mkdir(base, 0755);</p>
<p>     } else if (!strncmp(uevent-&gt;subsystem, &quot;oncrpc&quot;, 6)) {</p>
<p>         base = &quot;/dev/oncrpc/&quot;;</p>
<p>         mkdir(base, 0755);</p>
<p>     } else if (!strncmp(uevent-&gt;subsystem, &quot;adsp&quot;, 4)) {</p>
<p>         base = &quot;/dev/adsp/&quot;;</p>
<p>……</p>
<p>     handle_device(uevent-&gt;action, devpath, uevent-&gt;path, 0,</p>
<p>             uevent-&gt;major, uevent-&gt;minor, links);</p>
<p>}</p>
<p>首先得到设备的名字，然后是创建一些设备的子目录，如果uevent-&gt;subsystem是usb，就需要创建一个/dev/bus/usb的目录。如果是uevent-&gt;subsystem是graphic的话，就需要创建一个/dev/graphics的目录，按照这样依次比较下去，创建设备类所需要的子目录。</p>
<p>System/core/init/devices.c</p>
<p>static void handle_device(const char *action, const char <em>devpath, const char *path, int block, int major, int minor, char *</em>links)</p>
<p>{</p>
<p>……</p>
<p>    if(!strcmp(action, &quot;add&quot;)) {</p>
<p>        make_device(devpath, path, block, major, minor);</p>
<p>……</p>
<p>｝</p>
<p>如果uevent的action是设备添加，就会调用make_device来创建设备节点。</p>
<p>System/core/init/devices.c</p>
<p>static void make_device(const char *path, const char *upath,  int block, int major, int minor)</p>
<p>{</p>
<p>……</p>
<p>mode = get_device_perm(path, &amp;uid, &amp;gid) | (block ? S_IFBLK : S_IFCHR);</p>
<p>dev = makedev(major, minor);</p>
<p>setegid(gid);</p>
<p>mknod(path, mode, dev);</p>
<p>chown(path, uid, -1);</p>
<p>setegid(AID_ROOT);</p>
<p>}</p>
<p>通过get_device_perm得到设备的访问权限，makedev根据主设备号和次设备号得到dev。设置临时setegid，然后又mknod就在设备相应的目录下面创建了设备节点。最后将设备的egid设备为AID_ROOT。到这里整个android的设备目录和节点就创建完成了。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>AppStore APP图标 下载</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/AppStore%20APP%E5%9B%BE%E6%A0%87%20%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>1.打开APP主页面</p>
<p><a href="https://itunes.apple.com/cn/app/ropro-cam/id1108722947?mt=8">https://itunes.apple.com/cn/app/ropro-cam/id1108722947?mt=8</a> </p>
<p>2.查看网页源码，找到图片链接</p>
<p><a href="https://is5-ssl.mzstatic.com/image/thumb/Purple118/v4/01/e4/8c/01e48c9b-94ac-cc34-88d6-7da0b2300515/AppIcon-1x_U007emarketing-85-220-5.png/1200x630bb.jpg">https://is5-ssl.mzstatic.com/image/thumb/Purple118/v4/01/e4/8c/01e48c9b-94ac-cc34-88d6-7da0b2300515/AppIcon-1x_U007emarketing-85-220-5.png/1200x630bb.jpg</a></p>
<p>3.把链接1200x630bb.jpg，改成1200x1024bb.jpg 就可以下载l024的图片了。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>BT 蓝牙 搜索时不可见</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/BT%20%E8%93%9D%E7%89%99%20%E6%90%9C%E7%B4%A2%E6%97%B6%E4%B8%8D%E5%8F%AF%E8%A7%81/</url>
    <content><![CDATA[<p>diff –git a/src/com/android/settings/bluetooth/BluetoothDiscoverableEnabler.java b/src/com/android/settings/bluetooth/BluetoothDiscoverableEnabler.java</p>
<p>index d687136..4f69c18 100755</p>
<p>— a/src/com/android/settings/bluetooth/BluetoothDiscoverableEnabler.java</p>
<p>+++ b/src/com/android/settings/bluetooth/BluetoothDiscoverableEnabler.java</p>
<p>@@ -125,7 +125,8 @@ final class BluetoothDiscoverableEnabler implements Preference.OnPreferenceClick</p>
<p>     public boolean onPreferenceClick(Preference preference) {</p>
<p>         // toggle discoverability</p>
<ul>
<li>       mDiscoverable = !mDiscoverable;</li>
</ul>
<ul>
<li><p>       mDiscoverable = !mDiscoverable;</p>
</li>
<li><p>              if(!mLocalAdapter.isDiscovering())</p>
</li>
</ul>
<p>         setEnabled(mDiscoverable);</p>
<p>         return true;</p>
<p>     }</p>
<p>diff –git a/src/com/android/settings/bluetooth/BluetoothSettings.java b/src/com/android/settings/bluetooth/BluetoothSettings.java</p>
<p>index eaf362d..61d56e0 100755</p>
<p>— a/src/com/android/settings/bluetooth/BluetoothSettings.java</p>
<p>+++ b/src/com/android/settings/bluetooth/BluetoothSettings.java</p>
<p>@@ -196,6 +196,8 @@ public final class BluetoothSettings extends DeviceListPreferenceFragment {</p>
<p>             case MENU_ID_SCAN:</p>
<p>                 if (mLocalAdapter.getBluetoothState() == BluetoothAdapter.STATE_ON) {</p>
<p>                     startScanning();</p>
<ul>
<li><p>                                      mLocalAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE);</p>
</li>
<li><p>                                  BluetoothDiscoverableTimeoutReceiver.cancelDiscoverableAlarm(getActivity());</p>
</li>
</ul>
<p>                 }</p>
<p>                 return true;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>BT</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/BT.601%E4%B8%8EBT.656/</url>
    <content><![CDATA[<p>BT.601与BT.656<br>ITU-R Recommendation BT.601，简称Rec.601或者BT.601（或者它的前身，CCIR601），是1982年由ITU-R发布的一个标准，用于将各行数位视讯讯号进行数位化。旧名称为CCIR 601，国际电信联盟（ITU）所制订的标准规格。为现今标准电视放送规格标准。对应NTSC（525/60）与PAL（扫描线625/50）、对应4:3和16:9纵横比画面。规定了视频信号数字编码方法。虽然色彩成份为RGB 4:4:4跟色差(YCbCr) 4:2:2为既订的，但是，这里记录的是作为广播放送用的一般的色差方式。 PAL技术指标 场频：50Hz 帧频：25Hz 行频：15625Hz=625行/帧x25帧/秒 总行数：625 场回扫行数：25x2 图像行数：575       数字场：场1消隐24行，场2消隐25行，有效行576 NTSC技术指标 场频：29.97x2Hz 帧频：29.97Hz 行频：15734.25Hz=525x29.97 总行数：525 场回扫行数：20x2 图像行数：485(480) 为什么NTSC制式帧频是29.97FPS（精确来说是60FPS（场速率）/1.001）？ 是避免4.5MHz处的干扰而提出的，NTSC经过调查研究后，于1954年决定从30FPS更改为29.97FPS，因为干扰跳动频率出现在颜色副载波（3.5795MHz）和声音载波（4.5MHz）之间，以及颜色副载波和视频亮度信号的高频之间，选择水平频率fH=15734.25Hz（其286次谐波频率为4.5MHz，其227.5倍频率为3.5795MHz），可将干扰最小化。垂直频率从而变成了fH/525=29.97Hz 亮度采样频率fs 视频带宽6MHz PAL的fH和NTSC的fH的行扫描频率的最小公倍数是2.25MHz fs&gt;6x2MHz，采样定理 取fs=2.25MHzx6=13.5MHz&gt;6x2MHz 整合NTSC和PAL，减少硬件设计成本，所以选13.5MHz 色差信号抽样频率 6.75MHz（4:2:2） 3.375MHz（4:1:1和4:2:0） 每行采样样本N PAL 13.5MHz/(625x25)=864 NTSC 13.5MHz/(525x29.97)=858 每一扫描行的有效样本数 720 ITU-R BT.601规定采样时间是53.3333us 53.3333x13.5=719.99955=720 720x576x50=720x480x60=20736000=162x902x10 16x16是压缩算法的主要子块单位 4:2:2格式 CCIR建议两种制式有效行的取样点亮度信号取720个，两个色差信号各取360个 即每个有效行包括720个亮度数据和720个色度数据（两个色度各360个） 统一了数字分量编码标准，使三种制式便于转换和统一 所以有效行亮度信号与两个色差信号的取样点之比也为4:2:2（720:360:360） 分辨率 分辨率即是每帧图像有效行内的有效样本数，CCIR601规定对所有的制式，其每一行的有效样本点数为720个。由于不同的制式其有效行数不同，其分辨率也不同，分别为 PAL制和SECAM制 720×576 NTSC制 720×480 640x480 320x240（320x262），LCD实验 352x288，CMOS Sensor实验 数据量 4:2:2的格式采样，10Bit量化 13.5×10+6.75×10+6.75×10=270Mbps 4:2:2的格式采样，8Bit量化 13.5×8+6.75×8+6.75×8=216Mbps 数据时分复用 经量化、编码后的视频数据字有3个样本值，CCIR601规定进行多路复用后按27Mwords/s来传递,其中字按以下顺序传递:Cb、Y、Cr、Y、Cb、Y、Cr、Y、Cb、Y、Cr、Y…,也就是说，ITU-RBT601，16位数据传输；21芯；Y、U、V信号同时传输。601是并行数据，行场同步有单独输出。 分量取值 CCIR601规定，每个样本点都按8位数字化，也即有256个等级。但实际上亮度信号占220级，色度信号占225级，其它位作同步、编码等控制用。 Y：16（全黑）<del>235（全白） Cb，Cr：16</del>240，128除外 这种规格的机器通常可连接serial digital interface（SDI）规格SMPTE 259M为标准的接口。为了跟HDTV有所区别又称SD-SDI。<br>串行数字接口 (SDI) 是 ITU-R BT.656 以及移动图像和电视工程师协会 ( SMPTE) 提出的串行链路标准，在演播环境中通过 75 欧姆同轴电缆来传输未压缩的数字视频，大部分专业视频基础设备都采用了该标准。该标准的第一版是 SMPTE 259M，定义了通过串行接口来传输数字化的 NTSC 和 PAL 等模拟视频，它更流行的名称是标准清晰度 (SD) SDI 。传输 SD SDI 所需的数据速率是 270 Mbps。随着 1080i 和 720p 等高清晰 (HD) 视频标准的出现，对接口进行了调整以处理更高的 1.485 Gbps 数据速率。1.485-Gbps 串行接口通常被称为 HD SDI 接口，由 SMPTE 292M 进行定义，它使用同样的 75 欧姆同轴电缆。演播和其他视频产品开发商在同轴电缆硬件基础设备上进行了大量投入，希望能够延长其基础设备的生命周期。幸运的是，SMPTE 最近批准了名为 SMPTE 424M 的新标准，在同样的75欧姆同轴电缆上，SDI数据速率加倍，达到了2.97 Gbps。这一新标准也称为 3-Gbps (3G) SDI，支持 1080p 和数字影院等分辨率更高的图像质量。<br>BT.601它规定彩色电视信号采用分量编码。所谓分量编码就是彩色全电视信号在转换成数字形式之前，先被分离成亮度信号和色差信号，然后对它们分别进行编码。 ITU BT.656 ITU-R Recommendation BT.656，有时候也称为ITU656（前身CCIR 656），是一个简单的数字视频协议，用于将未压缩的PAL或NTSC（525行或者625行）信号进行编码。9芯，其输入接口有一根pixel_CLK时钟信号,8根YUV的数据信号,还有二根SVVS/SVHS(垂直水平同步信号)，8/10位数据传输；不需要同步信号；串行数据传输；传输速率是601的2倍；先传Y，后传UV。行场同步信号嵌入在数据流中。 BT656主要用于实时视频数据传递。包含三部分 1：视频信号，依BT.6012：数字消隐数据， 0x80,0x10,0x80,0x10(8位)，200h，40h，200h，40h（10位），分别与Cb,Y,Cr，Y的消隐电平相对应。 3：定时基准信号： 有两个定时基准信号，一个在每个视频数据块的开始(Start of ActiveVideo，SAV)，另一个在每个视频数据块的结束(End of Active Video，EAV)；每个定时基准信号由4个字的序列组成，格式如下： FF 00 00 XY（16进制）头三个是固定前缀，第4个字包含定义第二场标识、场消隐状态和行消隐状态的信息。 4：辅助信号： <br>辅助数据信号可以以10比特形式只在行消隐期间传送，还可以以8比特形式只在场消隐中的行的有效期间传送。依BT.1364标准。<br>简单的说ITU-R BT.601是&quot;演播室数字电视编码参数&quot;标准,而ITU-R BT.656则是ITU-R      BT.601附件A中的数字接口标准,用于主要数字视频设备(包括芯片)之间采用27Mhz/s并口或243Mb/s串行接口的数字传输接口标准. BT.601规划了对视频进行数字编码的方法 BT.656则实际定义了实施BT.601所必需的物理接口和数据流，以及位并行和位串行模式 位并行模式 只需要27MHz的时钟（在NTSC 30 帧/s条件下）以及8或10条连线（具体取决于像素的分辨率）。 所有的同步化信号都嵌入到数据流中，因此无需额外添加硬件连线。（25针D型迷你连接器） 位串行模式 只需要在单个通道上传输一路复用化的10bit/像素串行数据流，不过它需要运用复杂的同步化、频谱整形和时钟恢复调理等技术手段。 此外，其位时钟速率接近300MHz，因此要在很多系统中实施基于采用串行位形式的BT.656是极富挑战性的任务。<br>￼<br>帧划分：<br>￼<br>数据流：<br>￼<br>￼<br>请注意，视频数据有一个由三个字节构成的前导码（8bit视频是0xFF, 0x00，0x00，而10bit视频则是0x3FF, 0x000, 0x000），后面跟随着XY状态字，这个字除了包含F （场）, V （垂直消隐） 和 H （水平消隐）位之外，还包含了4个保护位，以实现单位错误的检测和纠正。请注意，F和V只能作为EAV序列的一部分来变化（即，从H = 0切换到H = 1）。此外，请注意，对于10bit视频来说，增加的两位实际上是最低位，而不是最高位。<br>￼<br>另外，垂直消隐间隔可以被用来发送非视频的信息，如字幕，音频，文字电视广播或者甚至交互电视应用所需的数据。这些辅助数据包并未采用通常的控制代码的前导码，而以0x00,0xFF,0xFF为前导码。如果不发送辅助数据，则在水平和垂直消隐间隔发送（0x80, 0x10, 0x80, 0x10, 0x80, 0x10。。。）对应（Cb, Y, Cr, Y, Cb, Y, …）。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>BT搜时间</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/BT%E6%90%9C%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>diff –git a/external/bluetooth/bluedroid/btif/src/btif_dm.c b/external/bluetooth/bluedroid/btif/src/btif_dm.c</p>
<p>index 5517f55..ee4d028 100755</p>
<p>— a/external/bluetooth/bluedroid/btif/src/btif_dm.c</p>
<p>+++ b/external/bluetooth/bluedroid/btif/src/btif_dm.c</p>
<p>@@ -58,7 +58,7 @@</p>
<p> #define BTIF_DM_DEFAULT_INQ_MAX_RESULTS     0</p>
<p>-#define BTIF_DM_DEFAULT_INQ_MAX_DURATION    10</p>
<p>+#define BTIF_DM_DEFAULT_INQ_MAX_DURATION    30  //10 BT搜时间</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Battery框架</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Battery%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>frameworks/base/policy/src/com/android/internal/policy/impl/KeyguardUpdateMonitor.java</p>
<p>KeyguardUpdateMonitor</p>
<p>import static android.os.BatteryManager.EXTRA_LEVEL;</p>
<p>//注册BroadcastReceiver 监听电池信息变化</p>
<p>else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {</p>
<p>                    final int status = intent.getIntExtra(EXTRA_STATUS, BATTERY_STATUS_UNKNOWN);</p>
<p>                    final int plugged = intent.getIntExtra(EXTRA_PLUGGED, 0);</p>
<p>                    final int level = intent.getIntExtra(EXTRA_LEVEL, 0);//从sys/class/power_supply中获取信息</p>
<p>                    final int health = intent.getIntExtra(EXTRA_HEALTH, BATTERY_HEALTH_UNKNOWN);</p>
<p>                    final Message msg = mHandler.obtainMessage(</p>
<p>                            MSG_BATTERY_UPDATE, new BatteryStatus(status, level, plugged, health));</p>
<p>                    mHandler.sendMessage(msg);</p>
<p>。。。</p>
<p>//handler</p>
<p>case MSG_BATTERY_UPDATE:</p>
<p>                        handleBatteryUpdate((BatteryStatus) msg.obj);</p>
<p>                        break;</p>
<p>handleBatteryUpdate(){</p>
<p>        mInfoCallbacks.get(i).onRefreshBatteryInfo(</p>
<p>                    shouldShowBatteryInfo(),isPluggedIn(batteryStatus), batteryStatus.level);</p>
<p>}</p>
<p>frameworks/base/policy/src/com/android/internal/policy/impl/KeyguardStatusViewManager.java</p>
<p>//KeyguardStatusViewManager</p>
<p> private InfoCallbackImpl mInfoCallback = new InfoCallbackImpl() {//在KeyguardUpdateMonitor中定义</p>
<p>        @Override</p>
<p>        public void onRefreshBatteryInfo(boolean showBatteryInfo, boolean pluggedIn,</p>
<p>                int batteryLevel) {</p>
<p>            mShowingBatteryInfo = showBatteryInfo;</p>
<p>            mPluggedIn = pluggedIn;</p>
<p>            mBatteryLevel = batteryLevel;</p>
<p>            final MutableInt tmpIcon = new MutableInt(0);</p>
<p>update(BATTERY_INFO, getAltTextMessage(tmpIcon));//更新电池信息</p>
<p>        }</p>
<p>frameworks/base/packages/SystemUI/src/com/android/systemui/power/PowerUI.java</p>
<p> void showLowBatteryWarning() //低电警告</p>
<p> playLowBatterySound() //低电警告声音</p>
<p>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryController.java</p>
<p>addIconView(ImageView v)</p>
<p>addLabelView(TextView v) </p>
<p> public void onReceive(Context context, Intent intent) {</p>
<p>        final String action = intent.getAction();</p>
<p>        if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {</p>
<p>            final int level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);</p>
<p>            final boolean plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0) != 0;</p>
<p>            final int icon = plugged ? R.drawable.stat_sys_battery_charge </p>
<p>                                     : R.drawable.stat_sys_battery;</p>
<p>            int N = mIconViews.size();</p>
<p>            for (int i=0; i&lt;N; i++) {///N ???</p>
<p>                ImageView v = mIconViews.get(i);</p>
<p>                v.setImageResource(icon);</p>
<p>  v.setImageLevel(level); //显示不同的电量</p>
<p>                v.setContentDescription(mContext.getString(R.string.accessibility_battery_level,</p>
<p>                        level));</p>
<p>            }</p>
<p>            N = mLabelViews.size();</p>
<p>            for (int i=0; i&lt;N; i++) {</p>
<p>                TextView v = mLabelViews.get(i);</p>
<p>                v.setText(mContext.getString(R.string.status_bar_settings_battery_meter_format,</p>
<p>                        level));</p>
<p>            }</p>
<p>        }</p>
<p>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>mBatteryController.addIconView((ImageView)mNotificationPanel.findViewById(R.id.battery));</p>
<p>        mBatteryController.addLabelView((TextView)mNotificationPanel.findViewById(R.id.battery_text));</p>
<p>mBatteryController.addIconView((ImageView)sb.findViewById(R.id.battery));</p>
<p>BatteryService </p>
<p>private final int getIcon(int level) {</p>
<p>        if (mBatteryStatus == BatteryManager.BATTERY_STATUS_CHARGING) {</p>
<p>            return com.android.internal.R.drawable.stat_sys_battery_charge;</p>
<p>        } else if (mBatteryStatus == BatteryManager.BATTERY_STATUS_DISCHARGING) {</p>
<p>            return com.android.internal.R.drawable.stat_sys_battery;</p>
<p>        } else if (mBatteryStatus == BatteryManager.BATTERY_STATUS_NOT_CHARGING</p>
<p>                || mBatteryStatus == BatteryManager.BATTERY_STATUS_FULL) {</p>
<p>            if (isPowered() &amp;&amp; mBatteryLevel &gt;= 100) {</p>
<p>                return com.android.internal.R.drawable.stat_sys_battery_charge;</p>
<p>            } else {</p>
<p>                return com.android.internal.R.drawable.stat_sys_battery;</p>
<p>            }</p>
<p>        } else {</p>
<p>            return com.android.internal.R.drawable.stat_sys_battery_unknown;</p>
<p>        }</p>
<p>    }</p>
<p>    private native void native_update();//jni本地方法</p>
<p>    private synchronized final void update() {</p>
<p>        native_update(); </p>
<p>        processValues();</p>
<p>    }</p>
<p>//定义两个UEventObserver 调用update()更新数据</p>
<p>mPowerSupplyObserver</p>
<p>mInvalidChargerObserver</p>
<p>    private final void sendIntent() { //BatteryService主动通过Intent发出广播</p>
<p>        //  Pack up the values and broadcast them to everyone</p>
<p>Intent intent = new Intent(Intent.ACTION_BATTERY_CHANGED);</p>
<p>        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</p>
<p>                | Intent.FLAG_RECEIVER_REPLACE_PENDING);</p>
<p>        int icon = getIcon(mBatteryLevel);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_STATUS, mBatteryStatus);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_HEALTH, mBatteryHealth);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_PRESENT, mBatteryPresent);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_LEVEL, mBatteryLevel);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_SCALE, BATTERY_SCALE);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_ICON_SMALL, icon);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_PLUGGED, mPlugType);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_VOLTAGE, mBatteryVoltage);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_TEMPERATURE, mBatteryTemperature);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_TECHNOLOGY, mBatteryTechnology);</p>
<p>        intent.putExtra(BatteryManager.EXTRA_INVALID_CHARGER, mInvalidCharger);  </p>
<p>        ActivityManagerNative.broadcastStickyIntent(intent, null);</p>
<p>    }</p>
<p>注册过的应用才能收到广播，在代码中注册方法如下：<br>IntentFilter mIntentFilter = new IntentFilter();<br>mIntentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);<br>registerReceiver(mIntentReceiver, mIntentFilter); </p>
<p>再根据BatteryManager 相应属性判断</p>
<p>JNI层：</p>
<p>com_android_server_BatteryService.cpp</p>
<p>#define POWER_SUPPLY_PATH &quot;/sys/class/power_supply&quot;</p>
<p>//jni 方法 供android_server_BatteryService_update调用</p>
<p>getBatteryStatus</p>
<p>getBatteryHealth</p>
<p>android_server_BatteryService_update </p>
<p>static JNINativeMethod sMethods[] = {</p>
<p>     /* name, signature, funcPtr */</p>
<p>{&quot;native_update&quot;, &quot;()V&quot;,  //呈现给上层的方法  (void*)android_server_BatteryService_update},</p>
<p>};</p>
<p>struct FieldIds {</p>
<p>    // members</p>
<p>    jfieldID mAcOnline;</p>
<p>    jfieldID mUsbOnline;</p>
<p>    jfieldID mBatteryStatus;</p>
<p>    jfieldID mBatteryHealth;</p>
<p>    jfieldID mBatteryPresent;</p>
<p>    jfieldID mBatteryLevel;</p>
<p>    jfieldID mBatteryVoltage;</p>
<p>    jfieldID mBatteryTemperature;</p>
<p>    jfieldID mBatteryTechnology;</p>
<p>};</p>
<p>static FieldIds gFieldIds;</p>
<p>struct BatteryManagerConstants {</p>
<p>    jint statusUnknown;</p>
<p>    jint statusCharging;</p>
<p>    jint statusDischarging;</p>
<p>    jint statusNotCharging;</p>
<p>    jint statusFull;</p>
<p>    jint healthUnknown;</p>
<p>    jint healthGood;</p>
<p>    jint healthOverheat;</p>
<p>    jint healthDead;</p>
<p>    jint healthOverVoltage;</p>
<p>    jint healthUnspecifiedFailure;</p>
<p>    jint healthCold;</p>
<p>};</p>
<p>static BatteryManagerConstants gConstants;</p>
<p>int register_android_server_BatteryService(JNIEnv* env)  //注册</p>
<p>    gFieldIds.mAcOnline = env-&gt;GetFieldID(clazz, &quot;mAcOnline&quot;, &quot;Z&quot;);</p>
<p>    gFieldIds.mUsbOnline = env-&gt;GetFieldID(clazz, &quot;mUsbOnline&quot;, &quot;Z&quot;);</p>
<p>    gFieldIds.mBatteryStatus = env-&gt;GetFieldID(clazz, &quot;mBatteryStatus&quot;, &quot;I&quot;);</p>
<p>    gFieldIds.mBatteryHealth = env-&gt;GetFieldID(clazz, &quot;mBatteryHealth&quot;, &quot;I&quot;);</p>
<p>    gFieldIds.mBatteryPresent = env-&gt;GetFieldID(clazz, &quot;mBatteryPresent&quot;, &quot;Z&quot;);</p>
<p>    gFieldIds.mBatteryLevel = env-&gt;GetFieldID(clazz, &quot;mBatteryLevel&quot;, &quot;I&quot;);</p>
<p>    gFieldIds.mBatteryTechnology = env-&gt;GetFieldID(clazz, &quot;mBatteryTechnology&quot;, &quot;Ljava/lang/String;&quot;);</p>
<p>    gFieldIds.mBatteryVoltage = env-&gt;GetFieldID(clazz, &quot;mBatteryVoltage&quot;, &quot;I&quot;);</p>
<p>    gFieldIds.mBatteryTemperature = env-&gt;GetFieldID(clazz, &quot;mBatteryTemperature&quot;, &quot;I&quot;);</p>
<p>//上面这些变量的值，对应是从下面的文件中读取的，一只文件存储一个数值。<br>#define AC_ONLINE_PATH “/sys/class/power_supply/ac/online”<br>#define USB_ONLINE_PATH “/sys/class/power_supply/usb/online”<br>#define BATTERY_STATUS_PATH “/sys/class/power_supply/battery/status”<br>#define BATTERY_HEALTH_PATH “/sys/class/power_supply/battery/health”<br>#define BATTERY_PRESENT_PATH “/sys/class/power_supply/battery/present”<br>#define BATTERY_CAPACITY_PATH “/sys/class/power_supply/battery/capacity”<br>#define BATTERY_VOLTAGE_PATH “/sys/class/power_supply/battery/batt_vol”<br>#define BATTERY_TEMPERATURE_PATH “/sys/class/power_supply/battery/batt_temp”<br>#define BATTERY_TECHNOLOGY_PATH “/sys/class/power_supply/battery/technology” </p>
<p>/sys/class/power_supply  由Platform来控制</p>
<p>  gConstants.statusUnknown = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_STATUS_UNKNOWN&quot;, &quot;I&quot;));</p>
<p>    gConstants.statusCharging = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_STATUS_CHARGING&quot;, &quot;I&quot;));</p>
<p>    gConstants.statusDischarging = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_STATUS_DISCHARGING&quot;, &quot;I&quot;));</p>
<p>    gConstants.statusNotCharging = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_STATUS_NOT_CHARGING&quot;, &quot;I&quot;));</p>
<p>    gConstants.statusFull = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_STATUS_FULL&quot;, &quot;I&quot;));</p>
<p>    gConstants.healthUnknown = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_HEALTH_UNKNOWN&quot;, &quot;I&quot;));</p>
<p>    gConstants.healthGood = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_HEALTH_GOOD&quot;, &quot;I&quot;));</p>
<p>    gConstants.healthOverheat = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_HEALTH_OVERHEAT&quot;, &quot;I&quot;));</p>
<p>    gConstants.healthDead = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_HEALTH_DEAD&quot;, &quot;I&quot;));</p>
<p>    gConstants.healthOverVoltage = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_HEALTH_OVER_VOLTAGE&quot;, &quot;I&quot;));</p>
<p>    gConstants.healthUnspecifiedFailure = env-&gt;GetStaticIntField(clazz, </p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_HEALTH_UNSPECIFIED_FAILURE&quot;, &quot;I&quot;));</p>
<p>    gConstants.healthCold = env-&gt;GetStaticIntField(clazz,</p>
<p>            env-&gt;GetStaticFieldID(clazz, &quot;BATTERY_HEALTH_COLD&quot;, &quot;I&quot;));</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Bluetooth 服务 工作流程</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Bluetooth%20%E6%9C%8D%E5%8A%A1%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>一、Bluez编译配置支持<br>    在BoardConfig.mk中添加：<br>    BOARD_HAVE_BLUETOOTH := true。<br>二、启动hciattach </p>
<p>    BlueZ核心子系统使用hciattach守护进程添加指定的硬件串口驱动。<br>    修改init.rc来启动hciattach： </p>
<p>    service hciattach /system/bin/hciattch -n -s 115200 /dev/ttyS2 bcm2035 115200<br>            user bluetooth<br>            group bluetooth net_bt_admin<br>            disabled<br>     同时也要启动dbus daemon,因为bluez需要dbus与其它进程通讯的。 </p>
<p>用户可以在代码中通过调用property_service.c 中函数<br>property_set(&quot;ctl.start&quot;,hciattach)<br>property_set(&quot;ctl.stop&quot;,hciattach)<br>来使得android property service 去开启或结束 hciattach service. </p>
<p>当然用户也可以在控制台直接使用命令<br>#setprop ctl.start hciattach<br>#setprop ctl.stop hciattach<br>来做同样的事情</p>
<p>三、Bluez控制流程</p>
<p>     class bluetoothsetting是UI的入口，通过按button scan进入搜索状态，<br>     applicaton层调用bluetoothdevice, 接着就是bluetoothservice的调用， <br>     bluetoothservice调用native方法，到此全部的java程序结束了。<br>     下面的调用都是JNI, cpp实现的。android_server_bluetoothservice.cpp里面实现了native </p>
<p>     方法，最终通过dbus封装，调用 HCID deamon 的function DiscoverDevice。</p>
<p>     Bluetooth的启动流程是：</p>
<p>        1.  打开蓝牙电源，通过rfkill来enable;(system/bluetooth/bluedroid/bluetooth.c)<br>        2.  启动service hciattch -n -s 115200 /dev/ttyS2 bcm2035 115200；<br>        3.  检测HCI是否成功（接受HCIDEVUP socket来判断或hciconfig hci0 up）；<br>        4.  hcid deamon start up。</p>
<p>四、Bluetooth结构</p>
<p>    1、JAVA层</p>
<p>       frameworks/base/core/java/android/bluetooth/</p>
<p>       包含了bluetooth的JAVA类。</p>
<p>以及frameworks/base/core/java/android/server/</p>
<p>    2、JNI层</p>
<p>       frameworks/base/core/jni/android_bluetooth_开头的文件</p>
<p>       定义了bluez通过JNI到上层的接口。</p>
<p>       frameworks/base/core/jni/android_server_bluetoothservice.cpp</p>
<p>       调用硬件适配层的接口system/bluetooth/bluedroid/bluetooth.c</p>
<p>    3、bluez库</p>
<p>       external/bluez/</p>
<p>       这是bluez用户空间的库，开源的bluetooth代码，包括很多协议，生成libbluetooth.so。</p>
<p>    4、硬件适配层</p>
<p>       system/bluetooth/bluedroid/bluetooth.c</p>
<p>       包含了对硬件操作的接口</p>
<p>       system/bluetooth/data/*</p>
<p>       一些配置文件，复制到/etc/bluetooth/。</p>
<p>       还有其他一些测试代码和工具。</p>
<p>(2)蓝牙服务启动</p>
<p>SystemServer</p>
<p>frameworks/base/services/java/com/android/server/SystemServer.java</p>
<p>                 bluetooth = new BluetoothService(context);</p>
<p>                ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);</p>
<p>     int bluetoothOn = Settings.Secure.getInt(mContentResolver, Settings.Secure.BLUETOOTH_ON, 0);</p>
<p>                if (bluetoothOn != 0)      bluetooth.enable();       </p>
<p>     or ============= 4.2.2 ==================================</p>
<p>                bluetooth = new BluetoothManagerService(context);</p>
<p>                ServiceManager.addService(BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE, bluetooth);</p>
<p>frameworks/base/services/java/com/android/server/BluetoothManagerService.java</p>
<p>(3)enable过程</p>
<p>LocalBluetoothAdapter.enable()</p>
<p>       |―― mAdapter.enable();</p>
<p>              |―― mService.enable();</p>
<p>                     |―― mBluetoothState.sendMessage(USER_TURN_ON, saveSetting);</p>
<p>                            |―― broadcastState(BluetoothAdapter.STATE_TURNING_ON);</p>
<p>                            |―― prepareBluetooth();</p>
<p>                                   |―― mBluetoothService.enableNative();</p>
<p>                                          |―― bt_enable();</p>
<p>（4）scan过程</p>
<p>BluetoothSettings</p>
<p>|―― onPreferenceTreeClick              KEY_BT_SCAN  点击scan</p>
<p>       |―― mLocalAdapter.startScanning(true);</p>
<p>                     |―― a2dp.isA2dpPlaying() – return; 如果A2DP正在播放,则退出</p>
<p>                     |―― mAdapter.startDiscovery()</p>
<p>                            |―― mService.startDiscovery()</p>
<p>                                   |―― startDiscoveryNative()</p>
<p>                                          |―― dbus接口 – StartDiscovery</p>
<p>                                                 |―― adapter_start_discovery    bluez中接收到</p>
<p>                                                        |―― start_discovery(adapter);</p>
<p>                                                               |―― hciops_start_discovery</p>
<p>                                                                      |­―― hciops_start_inquiry</p>
<p>                                                                             |―― hci_send_cmd(,OCF_INQUIRY, ,);</p>
<p>事件返回处理</p>
<p>Inquiry指令发出后，host会收到三种event事件回复</p>
<p>Command status Event、Inquiry result Event、Inquiry Complete event</p>
<p>io_security_event</p>
<p>       |―― read(fd, buf, sizeof(buf));</p>
<p>              |―― switch (eh-&gt;evt)事件类型查找</p>
<p>                     |——cmd_status  case EVT_CMD_STATUS  Discovering</p>
<p>                     |―― inquiry_complete_evt – case EVT_INQUIRY_COMPLETE</p>
<p>                            |―― set_state(index, DISCOV_HALTED);</p>
<p>                     |―― inquiry_result – case EVT_INQUIRY_RESULT</p>
<p>                            |―― btd_event_device_found</p>
<p>                                   |―― adapter_update_found_devices</p>
<p>                                          |―― adapter_emit_device_found</p>
<p>                                                 |―― emit_device_found</p>
<p>                                                        |―― dbus_message_new_signal(, , &quot;DeviceFound&quot;);</p>
<p>                                                               |―― g_dbus_send_message(connection, signal);</p>
<p>JNI处的dbus接收到” DeviceFound” singal后，回调到JNI</p>
<p>BluetoothEventLoop. event_filter</p>
<p>       |―― dbus_message_is_signal(,&quot;org.bluez.Adapter&quot;, &quot;DeviceFound&quot;)??</p>
<p>              |―― parse_remote_device_properties(env, &amp;iter)</p>
<p>              |―― env-&gt;CallVoidMethod(,method_onDeviceFound, ,);</p>
<p>                     |―― onDeviceFound</p>
<p>                            |―― addDevice(address, properties);</p>
<p>                                   |―― send intent BluetoothDevice.ACTION_FOUND</p>
<p>BluetoothEventManager.java 接收intent</p>
<p>DeviceFoundHandler</p>
<p>       |―― mDeviceManager.addDevice  – cachedDevice</p>
<p>       |―― dispatchDeviceAdded(cachedDevice);</p>
<p>回调，在UI上显示扫描到得设备</p>
<p>（5）SDP流程</p>
<p>搜索到某设备后，确定该设备所具有的profile</p>
<p>CachedBluetoothDevice</p>
<p>       |―― fillData()</p>
<p>              |―― fetchName();</p>
<p>              |―― fetchBtClass();</p>
<p>|―― updateProfiles();</p>
<p>                     |―― mProfileManager.updateProfiles</p>
<p>                            add  A2dpProfile  HeadsetProfile</p>
<p>                     |——dispatchAttributesChanged();</p>
<p>回调，UI显示</p>
<p>（6）pair过程</p>
<p>BluetoothSettings</p>
<p>       DeviceListPreferenceFragment</p>
<p>|―― onPreferenceTreeClick                点击除scan外的其它区域</p>
<p>|——onDevicePreferenceClick</p>
<p>|——BluetoothDevicePreference.onClicked()</p>
<p>|——pair()     配对</p>
<p>|——CachedBluetoothDevice. startPairing()</p>
<p>|——BluetoothDevice. createBond()</p>
<p>IBluetooth callback接口</p>
<p>|——BluetoothService. createBond</p>
<p>|——createPairedDeviceNative (address, 60000)  一分钟</p>
<p>|——dbus_func_args_async(, , , ,&quot;CreatePairedDevice&quot;,)</p>
<p>                            |——dbus接口 CreatePairedDevice</p>
<p>                                   |——create_paired_device            bluez中处理</p>
<p>                                          |——dbus_message_get_args 读取需要匹配的device信息</p>
<p>                                          |——create_device_internal</p>
<p>                                                 |——adapter_create_device</p>
<p>                                                        |——dbus signal “DeviceCreated”</p>
<p>                                                        |——adapter_update_devices</p>
<p>                                                               |——dbus  “PropertyChanged” “Devices”</p>
<p>                                          |——device_create_bonding</p>
<p>                                                 |——adapter_create_bonding</p>
<p>                                                        |——hciops_create_bonding(BT_IO_L2RAW, , ,)</p>
<p>                                                               |——l2cap_connect 建立L2CAP连接</p>
<p>                                                               |——connect_add</p>
<p>                                                 |——bonding_request_new</p>
<p>       |——mBondState.setBondState(,BOND_BONDING)  改变状态为bonding</p>
<p>              |——new Intent  ACTION_BOND_STATE_CHANGED</p>
<p>BluetoothEventManager.java 接收intent</p>
<p>              |——BondStateChangedHandler</p>
<p>                     |——dispatchAttributesChanged();</p>
<p>UI上显示</p>
<p>JNI收到 “DeviceCreated” signal</p>
<p>onDeviceCreated</p>
<p>       |——mBluetoothService.getRemoteDeviceProperties</p>
<p>       |——addDevice(address, properties)</p>
<p>              |——send intent “ACTION_FOUND”</p>
<p>JNI处的dbus接收到”RequestPairingConsent” singal后，回调到JNI</p>
<p>env-&gt;CallVoidMethod(, method_onRequestPairingConsent,,)</p>
<p>BluetoothEventLoop.java</p>
<p>       |——onRequestPairingConsent</p>
<p>              |——send intent ACTION_PAIRING_REQUEST</p>
<p>(7)connect过程</p>
<p>BluetoothDevicePreference.onClicked()</p>
<p>       |——CachedBluetoothDevice. connect(true)</p>
<p>              |——connectWithoutResettingTimer(connectAllProfiles);  连接所有profile</p>
<p>                     |——for (LocalBluetoothProfile profile : mProfiles) 遍历每个profile</p>
<p>|——connectInt (profile)</p>
<p>       |——profile.connect (mDevice)  A2DP  HSP connect</p>
<p>(8)A2DP profile</p>
<p>A2dpProfile. connect()</p>
<p>       |——BluetoothA2dp. connect()</p>
<p>              |——BluetoothA2dpService. connect()</p>
<p>                     |——BluetoothService. connectSink</p>
<p>                            msg.arg1 = BluetoothDeviceProfileState.CONNECT_A2DP_OUTGOING;</p>
<p>                            |——BluetoothProfileState. sendMsg(msg)</p>
<p>                                   |——BluetoothDeviceProfileState. sendMessage(cmd)</p>
<p>                                          |——BluetoothA2dpService. connectSinkInternal</p>
<p>                                                 |——handleSinkStateChange   STATE_CONNECTING</p>
<p>                                                        |——BluetoothService.sendConnectionStateChange</p>
<p>                                                               |——updateProfileConnectionState</p>
<p>                                                 |——connectSinkNative</p>
<p>                                                        |——dbus_func_args_async</p>
<p>(&quot;org.bluez.AudioSink&quot;, &quot;Connect&quot;,)</p>
<p>Bluez  org.bluez.AudioSink 收到Connect信号后</p>
<p>bluez/audio/device.c</p>
<p>dev_connect</p>
<p>       |——sink_setup_stream</p>
<p>              |——avdtp_discover</p>
<p>                     |——send_request(,,,AVDTP_DISCOVER,)</p>
<p>BluetoothA2dpService.cpp 收到dbus信号</p>
<p>onConnectSinkResult</p>
<p>回调到 BluetoothA2dpService.java</p>
<p>       |——onConnectSinkResult</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Build Cookbook</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Build%20Cookbook/</url>
    <content><![CDATA[<p><a href="http://www.kandroid.org/online-pdk/guide/build_cookbook.html">http://www.kandroid.org/online-pdk/guide/build_cookbook.html</a></p>
<p>Build Cookbook</p>
<p>In this document</p>
<p>Simple APK APK Dependent on static .jar file APK signed with the platform key APK that signed with vendor key Prebuilt APK Adding a Static Java Library Android.mk variables  </p>
<p>The Android Build Cookbook offers code snippets to help you quickly implement some common build tasks. For additional instruction, please see the other build documents in this section.</p>
<p>Building a simple APK</p>
<p>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)</p>
<h1 id="Build-all-java-files-in-the-java-subdirectory"><a href="#Build-all-java-files-in-the-java-subdirectory" class="headerlink" title="Build all java files in the java subdirectory"></a>Build all java files in the java subdirectory</h1><p>  LOCAL_SRC_FILES := $(call all-subdir-java-files)</p>
<h1 id="Name-of-the-APK-to-build"><a href="#Name-of-the-APK-to-build" class="headerlink" title="Name of the APK to build"></a>Name of the APK to build</h1><p>  LOCAL_PACKAGE_NAME := LocalPackage</p>
<h1 id="Tell-it-to-build-an-APK"><a href="#Tell-it-to-build-an-APK" class="headerlink" title="Tell it to build an APK"></a>Tell it to build an APK</h1><p>  include $(BUILD_PACKAGE)</p>
<p>Building a APK that depends on a static .jar file</p>
<p>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)</p>
<h1 id="List-of-static-libraries-to-include-in-the-package"><a href="#List-of-static-libraries-to-include-in-the-package" class="headerlink" title="List of static libraries to include in the package"></a>List of static libraries to include in the package</h1><p>  LOCAL_STATIC_JAVA_LIBRARIES := static-library</p>
<h1 id="Build-all-java-files-in-the-java-subdirectory-1"><a href="#Build-all-java-files-in-the-java-subdirectory-1" class="headerlink" title="Build all java files in the java subdirectory"></a>Build all java files in the java subdirectory</h1><p>  LOCAL_SRC_FILES := $(call all-subdir-java-files)</p>
<h1 id="Name-of-the-APK-to-build-1"><a href="#Name-of-the-APK-to-build-1" class="headerlink" title="Name of the APK to build"></a>Name of the APK to build</h1><p>  LOCAL_PACKAGE_NAME := LocalPackage</p>
<h1 id="Tell-it-to-build-an-APK-1"><a href="#Tell-it-to-build-an-APK-1" class="headerlink" title="Tell it to build an APK"></a>Tell it to build an APK</h1><p>  include $(BUILD_PACKAGE)</p>
<p>Building a APK that should be signed with the platform key</p>
<p>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)</p>
<h1 id="Build-all-java-files-in-the-java-subdirectory-2"><a href="#Build-all-java-files-in-the-java-subdirectory-2" class="headerlink" title="Build all java files in the java subdirectory"></a>Build all java files in the java subdirectory</h1><p>  LOCAL_SRC_FILES := $(call all-subdir-java-files)</p>
<h1 id="Name-of-the-APK-to-build-2"><a href="#Name-of-the-APK-to-build-2" class="headerlink" title="Name of the APK to build"></a>Name of the APK to build</h1><p>  LOCAL_PACKAGE_NAME := LocalPackage</p>
<p>  LOCAL_CERTIFICATE := platform</p>
<h1 id="Tell-it-to-build-an-APK-2"><a href="#Tell-it-to-build-an-APK-2" class="headerlink" title="Tell it to build an APK"></a>Tell it to build an APK</h1><p>  include $(BUILD_PACKAGE)</p>
<p>Building a APK that should be signed with a specific vendor key</p>
<p>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)</p>
<h1 id="Build-all-java-files-in-the-java-subdirectory-3"><a href="#Build-all-java-files-in-the-java-subdirectory-3" class="headerlink" title="Build all java files in the java subdirectory"></a>Build all java files in the java subdirectory</h1><p>  LOCAL_SRC_FILES := $(call all-subdir-java-files)</p>
<h1 id="Name-of-the-APK-to-build-3"><a href="#Name-of-the-APK-to-build-3" class="headerlink" title="Name of the APK to build"></a>Name of the APK to build</h1><p>  LOCAL_PACKAGE_NAME := LocalPackage</p>
<p>  LOCAL_CERTIFICATE := vendor/example/certs/app</p>
<h1 id="Tell-it-to-build-an-APK-3"><a href="#Tell-it-to-build-an-APK-3" class="headerlink" title="Tell it to build an APK"></a>Tell it to build an APK</h1><p>  include $(BUILD_PACKAGE)</p>
<p>Adding a prebuilt APK</p>
<p>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)</p>
<h1 id="Module-name-should-match-apk-name-to-be-installed"><a href="#Module-name-should-match-apk-name-to-be-installed" class="headerlink" title="Module name should match apk name to be installed."></a>Module name should match apk name to be installed.</h1><p>  LOCAL_MODULE := LocalModuleName<br>  LOCAL_SRC_FILES := $(LOCAL_MODULE).apk<br>  LOCAL_MODULE_CLASS := APPS<br>  LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)</p>
<p>  include $(BUILD_PREBUILT)</p>
<p>Adding a Static Java Library</p>
<p>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)</p>
<h1 id="Build-all-java-files-in-the-java-subdirectory-4"><a href="#Build-all-java-files-in-the-java-subdirectory-4" class="headerlink" title="Build all java files in the java subdirectory"></a>Build all java files in the java subdirectory</h1><p>  LOCAL_SRC_FILES := $(call all-subdir-java-files)</p>
<h1 id="Any-libraries-that-this-library-depends-on"><a href="#Any-libraries-that-this-library-depends-on" class="headerlink" title="Any libraries that this library depends on"></a>Any libraries that this library depends on</h1><p>  LOCAL_JAVA_LIBRARIES := android.test.runner</p>
<h1 id="The-name-of-the-jar-file-to-create"><a href="#The-name-of-the-jar-file-to-create" class="headerlink" title="The name of the jar file to create"></a>The name of the jar file to create</h1><p>  LOCAL_MODULE := sample</p>
<h1 id="Build-a-static-jar-file"><a href="#Build-a-static-jar-file" class="headerlink" title="Build a static jar file."></a>Build a static jar file.</h1><p>  include $(BUILD_STATIC_JAVA_LIBRARY)</p>
<p>Android.mk Variables</p>
<p>These are the variables that you’ll commonly see in Android.mk files, listed alphabetically. First, a note on the variable naming:</p>
<p>LOCAL_ - These variables are set per-module. They are cleared by the include $(CLEAR_VARS) line, so you can rely on them being empty after including that file. Most of the variables you’ll use in most modules are LOCAL_ variables. PRIVATE_ - These variables are make-target-specific variables. That means they’re only usable within the commands for that module. It also means that they’re unlikely to change behind your back from modules that are included after yours. This link to the make documentation describes more about target-specific variables. HOST_ and TARGET_ - These contain the directories and definitions that are specific to either the host or the target builds. Do not set variables that start with HOST_ or TARGET_ in your makefiles. BUILD_ and CLEAR_VARS - These contain the names of well-defined template makefiles to include. Some examples are CLEAR_VARS and BUILD_HOST_PACKAGE. Any other name is fair-game for you to use in your Android.mk. However, remember that this is a non-recursive build system, so it is possible that your variable will be changed by another Android.mk included later, and be different when the commands for your rule / module are executed.  </p>
<p>Parameter  Description </p>
<p>LOCAL_AAPT_FLAGS  </p>
<p>LOCAL_ACP_UNAVAILABLE  </p>
<p>LOCAL_ADDITIONAL_JAVA_DIR  </p>
<p>LOCAL_AIDL_INCLUDES  </p>
<p>LOCAL_ALLOW_UNDEFINED_SYMBOLS  </p>
<p>LOCAL_ARM_MODE  </p>
<p>LOCAL_ASFLAGS  </p>
<p>LOCAL_ASSET_DIR  </p>
<p>LOCAL_ASSET_FILES In Android.mk files that include $(BUILD_PACKAGE) set this to the set of files you want built into your app. Usually:</p>
<p>LOCAL_ASSET_FILES += $(call find-subdir-assets)</p>
<p>LOCAL_BUILT_MODULE_STEM  </p>
<p>LOCAL_C_INCLUDES  </p>
<p>Additional directories to instruct the C/C++ compilers to look for header files in. These paths are rooted at the top of the tree. Use LOCAL_PATH if you have subdirectories of your own that you want in the include paths. For example:</p>
<p>LOCAL_C_INCLUDES += extlibs/zlib-1.2.3<br>LOCAL_C_INCLUDES += $(LOCAL_PATH)/src </p>
<p>You should not add subdirectories of include to LOCAL_C_INCLUDES, instead you should reference those files in the #includestatement with their subdirectories. For example:</p>
<p>#include &lt;utils/KeyedVector.h&gt;<br>not #include &lt;KeyedVector.h&gt; </p>
<p>LOCAL_CC If you want to use a different C compiler for this module, set LOCAL_CC to the path to the compiler. If LOCAL_CC is blank, the appropriate default compiler is used. </p>
<p>LOCAL_CERTIFICATE  </p>
<p>LOCAL_CFLAGS If you have additional flags to pass into the C or C++ compiler, add them here. For example:</p>
<p>LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1</p>
<p>LOCAL_CLASSPATH  </p>
<p>LOCAL_COMPRESS_MODULE_SYMBOLS  </p>
<p>LOCAL_COPY_HEADERS  </p>
<p>The set of files to copy to the install include tree. You must also supply LOCAL_COPY_HEADERS_TO.</p>
<p>This is going away because copying headers messes up the error messages, and may lead to people editing those headers instead of the correct ones. It also makes it easier to do bad layering in the system, which we want to avoid. We also aren’t doing a C/C++ SDK, so there is no ultimate requirement to copy any headers.</p>
<p>LOCAL_COPY_HEADERS_TO  </p>
<p>The directory within &quot;include&quot; to copy the headers listed in LOCAL_COPY_HEADERS to.</p>
<p>This is going away because copying headers messes up the error messages, and may lead to people editing those headers instead of the correct ones. It also makes it easier to do bad layering in the system, which we want to avoid. We also aren’t doing a C/C++ SDK, so there is no ultimate requirement to copy any headers.</p>
<p>LOCAL_CPP_EXTENSION If your C++ files end in something other than &quot;.cpp&quot;, you can specify the custom extension here. For example:</p>
<p>LOCAL_CPP_EXTENSION := .cc</p>
<p>Note that all C++ files for a given module must have the same extension; it is not currently possible to mix different extensions. </p>
<p>LOCAL_CPPFLAGS If you have additional flags to pass into only the C++ compiler, add them here. For example:</p>
<p>LOCAL_CPPFLAGS += -ffriend-injection</p>
<p>LOCAL_CPPFLAGS is guaranteed to be after LOCAL_CFLAGS on the compile line, so you can use it to override flags listed inLOCAL_CFLAGS </p>
<p>LOCAL_CXX If you want to use a different C++ compiler for this module, set LOCAL_CXX to the path to the compiler. If LOCAL_CXX is blank, the appropriate default compiler is used. </p>
<p>LOCAL_DX_FLAGS  </p>
<p>LOCAL_EXPORT_PACKAGE_RESOURCES  </p>
<p>LOCAL_FORCE_STATIC_EXECUTABLE  </p>
<p>If your executable should be linked statically, set LOCAL_FORCE_STATIC_EXECUTABLE:=true. There is a very short list of libraries that we have in static form (currently only libc). This is really only used for executables in /sbin on the root filesystem.</p>
<p>LOCAL_GENERATED_SOURCES  </p>
<p>Files that you add to LOCAL_GENERATED_SOURCES will be automatically generated and then linked in when your module is built. See the Custom Tools template makefile for an example.</p>
<p>LOCAL_INSTRUMENTATION_FOR  </p>
<p>LOCAL_INSTRUMENTATION_FOR_PACKAGE_NAME  </p>
<p>LOCAL_INTERMEDIATE_SOURCES  </p>
<p>LOCAL_INTERMEDIATE_TARGETS  </p>
<p>LOCAL_IS_HOST_MODULE  </p>
<p>LOCAL_JAR_MANIFEST  </p>
<p>LOCAL_JARJAR_RULES  </p>
<p>LOCAL_JAVA_LIBRARIES  </p>
<p>When linking Java apps and libraries, LOCAL_JAVA_LIBRARIES specifies which sets of java classes to include. Currently there are two of these: core and framework. In most cases, it will look like this:</p>
<p>LOCAL_JAVA_LIBRARIES := core framework</p>
<p>Note that setting LOCAL_JAVA_LIBRARIES is not necessary (and is not allowed) when building an APK with &quot;include $(BUILD_PACKAGE)&quot;. The appropriate libraries will be included automatically.</p>
<p>LOCAL_JAVA_RESOURCE_DIRS  </p>
<p>LOCAL_JAVA_RESOURCE_FILES  </p>
<p>LOCAL_JNI_SHARED_LIBRARIES  </p>
<p>LOCAL_LDFLAGS  </p>
<p>You can pass additional flags to the linker by setting LOCAL_LDFLAGS. Keep in mind that the order of parameters is very important to ld, so test whatever you do on all platforms.</p>
<p>LOCAL_LDLIBS  </p>
<p>LOCAL_LDLIBS allows you to specify additional libraries that are not part of the build for your executable or library. Specify the libraries you want in -lxxx format; they’re passed directly to the link line. However, keep in mind that there will be no dependency generated for these libraries. It’s most useful in simulator builds where you want to use a library preinstalled on the host. The linker (ld) is a particularly fussy beast, so it’s sometimes necessary to pass other flags here if you’re doing something sneaky. Some examples:</p>
<p>LOCAL_LDLIBS += -lcurses -lpthread<br>LOCAL_LDLIBS += -Wl,-z,origin </p>
<p>LOCAL_MODULE LOCAL_MODULE is the name of what’s supposed to be generated from your Android.mk. For exmample, for libkjs, theLOCAL_MODULE is &quot;libkjs&quot; (the build system adds the appropriate suffix – .so .dylib .dll). For app modules, useLOCAL_PACKAGE_NAME instead of LOCAL_MODULE. </p>
<p>LOCAL_MODULE_PATH Instructs the build system to put the module somewhere other than what’s normal for its type. If you override this, make sure you also set LOCAL_UNSTRIPPED_PATH if it’s an executable or a shared library so the unstripped binary has somewhere to go. An error will occur if you forget to.</p>
<p>See Putting modules elsewhere for more.</p>
<p>LOCAL_MODULE_STEM  </p>
<p>LOCAL_MODULE_TAGS  </p>
<p>Set LOCAL_MODULE_TAGS to any number of whitespace-separated tags.</p>
<p>This variable controls what build flavors the package gets included in. For example:</p>
<p>user: include this in user/userdebug builds eng: include this in eng builds tests: the target is a testing target and makes it available for tests optional: don’t include this   </p>
<p>LOCAL_NO_DEFAULT_COMPILER_FLAGS  </p>
<p>LOCAL_NO_EMMA_COMPILE  </p>
<p>LOCAL_NO_EMMA_INSTRUMENT  </p>
<p>LOCAL_NO_STANDARD_LIBRARIES  </p>
<p>LOCAL_OVERRIDES_PACKAGES  </p>
<p>LOCAL_PACKAGE_NAME LOCAL_PACKAGE_NAME is the name of an app. For example, Dialer, Contacts, etc. </p>
<p>LOCAL_POST_PROCESS_COMMAND  </p>
<p>For host executables, you can specify a command to run on the module after it’s been linked. You might have to go through some contortions to get variables right because of early or late variable evaluation:</p>
<p>module := $(HOST_OUT_EXECUTABLES)/$(LOCAL_MODULE)<br>LOCAL_POST_PROCESS_COMMAND := /Developer/Tools/Rez -d <strong>DARWIN</strong> -t APPL<br>       -d <strong>WXMAC</strong> -o $(module) Carbon.r  </p>
<p>LOCAL_PREBUILT_EXECUTABLES When including $(BUILD_PREBUILT) or $(BUILD_HOST_PREBUILT), set these to executables that you want copied. They’re located automatically into the right bin directory. </p>
<p>LOCAL_PREBUILT_JAVA_LIBRARIES  </p>
<p>LOCAL_PREBUILT_LIBS When including $(BUILD_PREBUILT) or $(BUILD_HOST_PREBUILT), set these to libraries that you want copied. They’re located automatically into the right lib directory. </p>
<p>LOCAL_PREBUILT_OBJ_FILES  </p>
<p>LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES  </p>
<p>LOCAL_PRELINK_MODULE  </p>
<p>LOCAL_REQUIRED_MODULES  </p>
<p>Set LOCAL_REQUIRED_MODULES to any number of whitespace-separated module names, like &quot;libblah&quot; or &quot;Email&quot;. If this module is installed, all of the modules that it requires will be installed as well. This can be used to, e.g., ensure that necessary shared libraries or providers are installed when a given app is installed.</p>
<p>LOCAL_RESOURCE_DIR  </p>
<p>LOCAL_SDK_VERSION  </p>
<p>LOCAL_SHARED_LIBRARIES These are the libraries you directly link against. You don’t need to pass transitively included libraries. Specify the name without the suffix:</p>
<p>LOCAL_SHARED_LIBRARIES := <br>    libutils <br>    libui <br>    libaudio <br>    libexpat <br>    libsgl   </p>
<p>LOCAL_SRC_FILES The build system looks at LOCAL_SRC_FILES to know what source files to compile – .cpp .c .y .l .java. For lex and yacc files, it knows how to correctly do the intermediate .h and .c/.cpp files automatically. If the files are in a subdirectory of the one containing the Android.mk, prefix them with the directory name:</p>
<p>LOCAL_SRC_FILES := <br>    file1.cpp <br>    dir/file2.cpp  </p>
<p>LOCAL_STATIC_JAVA_LIBRARIES  </p>
<p>LOCAL_STATIC_LIBRARIES These are the static libraries that you want to include in your module. Mostly, we use shared libraries, but there are a couple of places, like executables in sbin and host executables where we use static libraries instead.</p>
<p>LOCAL_STATIC_LIBRARIES := <br>    libutils <br>    libtinyxml  </p>
<p>LOCAL_UNINSTALLABLE_MODULE  </p>
<p>LOCAL_UNSTRIPPED_PATH Instructs the build system to put the unstripped version of the module somewhere other than what’s normal for its type. Usually, you override this because you overrode LOCAL_MODULE_PATH for an executable or a shared library. If you overrodeLOCAL_MODULE_PATH, but not LOCAL_UNSTRIPPED_PATH, an error will occur.</p>
<p>See Putting modules elsewhere for more.</p>
<p>LOCAL_WHOLE_STATIC_LIBRARIES These are the static libraries that you want to include in your module without allowing the linker to remove dead code from them. This is mostly useful if you want to add a static library to a shared library and have the static library’s content exposed from the shared library.</p>
<p>LOCAL_WHOLE_STATIC_LIBRARIES := <br>    libsqlite3_android</p>
<p>LOCAL_YACCFLAGS Any flags to pass to invocations of yacc for your module. A known limitation here is that the flags will be the same for all invocations of YACC for your module. This can be fixed. If you ever need it to be, just ask.</p>
<p>LOCAL_YACCFLAGS := -p kjsyy</p>
<p>OVERRIDE_BUILT_MODULE_PATH </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>C+＋不同于C的地方</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/C+%EF%BC%8B%E4%B8%8D%E5%90%8C%E4%BA%8EC%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    <content><![CDATA[<p>//对于内联函数的调用，编译器是将其函数体放在调用的地方，没有非内联函数调用时的栈内存的创建和释放开销。但是，所执行的计算是完全相同的。</p>
<p>//使用内联函数时应注意以下几个问题：</p>
<p>　　（1） 在一个文件中定义的内联函数不能在另一个文件中使用。它们通常放在头文件中共享。</p>
<p>　　（2） 内联函数应该简洁，只有几个语句，如果语句较多，不适合于定义为内联函数。 </p>
<p>　　（3） 内联函数体中，不能有循环语句、if语句或switch语句，否则，函数定义时即使有inline关键字，编译器也会把该函数作为非内联函数处理。</p>
<p>　　（4） 内联函数要在函数被调用之前声明。例如下面的代码将内联函数放在函数调用之后声明，不能起到预期的效果。</p>
<p>大多数运算符都是按从左到右计算，只有三类运算符的结合性是从右到左。他们是：单目、三目和赋值。</p>
<p>short ishort = 1000;</p>
<p>unsigned char uichar;</p>
<p>uichar = ishort;</p>
<p>ishort = uichar;</p>
<p>ishort=232，相当于1000%256。</p>
<p>//运用全局运算符::</p>
<p>//</p>
<p>//用extern说明全局变量的时候，不能给初值</p>
<p>//</p>
<p>堆：C++中，对内存用new命令创建（我们在后面要介绍），用delete命令释放。</p>
<p>//定义重载的函数时， 我们应该注意以下几个问题：</p>
<p>　　（1） 避免函数名字相同，但功能完全不同的情形。例如上面的重载函数show的功能就是相关的，它们均是向屏幕打印信息。</p>
<p>　　（2） 函数的形参变量名不同不能作为函数重载的依据。 </p>
<p>　　（3） C++中不允许几个函数名相同、形参个数和类型也相同，仅仅是返回值不同的情形，否则，程序编译时会出现函数重复定义的错误。</p>
<p>    （4） 函数重载有时可能会产生意想不到的结果。如：　show(0); 0可以为空指针</p>
<p>    （5） 调用重载的函数时，如果实参类型与形参类型不匹配，编译器会自动进行类型转换。如果转换后仍然不能匹配到重载的函数，则会产生一个编译错误。</p>
<p>void指针在被使用之前，必须转换为正确的类型。</p>
<p>全局指针变量被自动初始化为NULL，局部指针变量的初值是随机的。</p>
<p>malloc,free和new ,delete的不同，前者是函数而后者是运算符。new和delete都是单目运算符，new的操作数是一个数据类型，返回为该类型的变量分配的内存块的指针。</p>
<p>delete运算符用于释放由new运算符分配的内存。delete的操作数是指针，释放该指针所指向的内存。</p>
<p>当被释放的内存块是数组时，需要添加[]。</p>
<p>双冒号::是域运算符,它主要用于类的成员函数的定义。</p>
<p>由于函数体在类内，所以函数原型后不需要分号，且所有的函数参数必须有名的</p>
<p>//一个对象被动态创建时，依次发生两件事情：</p>
<p>　　1． 为对象分配内存；</p>
<p>　　2． 调用构造函数来初始化这块内存。</p>
<p>//同样，一个对象被动态销毁时，按照顺序发生了下面两件事情：</p>
<p>　　1． 调用析构函数清除对象；</p>
<p>　　2． 释放对象的内存；</p>
<p>用new创建的对象必须用delete销毁，否则，会出现内存泄漏。</p>
<p>对私有数据成员的访问只能通过成员函数</p>
<p>类是用户定义的数据类型（不占内存），对象是类的实例（占内存单元）</p>
<p>析构函数的调用顺序与构造函数的调用顺序相反</p>
<p>当一个类的成员定义为public，就能够在类外访问，包括它的派生类。</p>
<p>当一个成员定义为private，它仅能在类内访问，不能被它的派生类访问。</p>
<p>当一个成员定义为proteced，它仅能在类内访问，但是能被它的派生类访问。</p>
<p>当一个成员没有指定访问说明符时，默认为private。</p>
<p>公有继承时，基类的公有成员，变为派生类的公有成员，基类的保护成员，变为派生类的保护成员。</p>
<p>　　保护继承时，基类的公有和保护成员，均变为派生类的保护成员。</p>
<p>　　私有继承时，基类的公有和保护成员，均变为派生类的私有成员。</p>
<p>　　double B::g()</p>
<p>　　{</p>
<p>　　　double res1 = A::g();</p>
<p>　　　// 调用A中的函数g</p>
<p>　　　double res2 = h(); </p>
<p>　　　// 调用B中的函数h</p>
<p>　　　w = w+res1+res2+u+f();</p>
<p>　　　// 修改w</p>
<p>　　　return res1;</p>
<p>　　} </p>
<p>在B的成员函数中调用A的成员函数时，要用域运算符::</p>
<p>某一个类的虚函数地址表被该类的所有对象共享，甚至有可能两个类共享同一个虚函数地址表。内存开销包括：</p>
<p>　　◇ 每一个对象增加了一个额外的数据成员。</p>
<p>　　◇ 每一个类有一个指针表，用于存储该类各虚函数的地址。</p>
<p>在C++中，也可以在基类中仅定义虚函数的信号：函数的名字、返回类型和参数，而没有实现，但在派生类中必须有该虚函数实现。</p>
<p>　　仅定义了函数的信号，而没有函数实现的虚函数称之为纯虚函数。定义纯虚函数的方法是在虚函数参数表右边的括号后加一个&quot;=0&quot;的后缀，例如：</p>
<p>　　class vehicle</p>
<p>　　{</p>
<p>　　　…</p>
<p>　　　virtual void message(void) = 0;</p>
<p>　　};</p>
<p>当一个类声明了纯虚函数后，首先，编译器知道这个函数应使用动态联编，然后它会为这个类建立VTABLE表。由于这个函数是纯虚函数，没有实现，所以没有函数指针。编译器遇到这种情况会在VTABLE表中为它留下一个间隔，即一个函数指针大小的空间，不放任何东西。只要类中声明了一个纯虚函数，这个类的VTABLE表就是不完全的。编译器会禁止使用这个类创建对象。</p>
<p>在C++中，构造函数不能定义为虚函数，而析构函数可以定义为虚函数。</p>
<p>虚析构函数的工作过程与普通虚函数不同，普通虚函数只是调用相应层上的函数，而虚析构函数是先调用相应层上的析构函数，然后逐层向上调用基类的析构函数。</p>
<p>继承是软件复用的一个重要方法，我们在设计基类和派生类时，必须考虑如何复用基类。设计类时，有一些基本的原则需要遵循：</p>
<p>　　（1） 类应该定义有：</p>
<p>　　◇ public接口，供派生类或其它类使用。</p>
<p>　　◇ 友元类或友元函数（如果需要地话）。</p>
<p>　　◇ protected接口，供派生类使用。</p>
<p>　　◇ private部分。</p>
<p>　　（2） 如果对象创建了受管的资源（例如申请了堆内存），必须提供析构函数释放该资源。</p>
<p>　　（3） 在继承链中，如果用基类的指针操作对象。要保证调用正确的析构函数，就必须把基类的析构函数应定义为虚函数。</p>
<p>　　（4） 如果一个类包含指向另一个对象的指针数据成员，应为该类提供复制构造函数，通常还要提供一个重载的赋值运算符，以确保对象能够被正确地复制和赋值。</p>
<p>　　（5） 被派生类覆盖的成员函数，通常定义为虚函数。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>CMakeLists 样例</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/CMakeLists%20%E6%A0%B7%E4%BE%8B/</url>
    <content><![CDATA[<p> CMakeLists.txt</p>
<p>cmake_minimum_required(VERSION 3.4.1)<br>add_library(hello-jnicallback SHARED<br>           hello-jnicallback.c)</p>
<h1 id="build-native-app-glue-as-a-static-lib"><a href="#build-native-app-glue-as-a-static-lib" class="headerlink" title="build native_app_glue as a static lib"></a>build native_app_glue as a static lib</h1><p>add_library(native_app_glue STATIC</p>
<p>    ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c)</p>
<h1 id="Include-libraries-needed-for-hello-jnicallback-lib"><a href="#Include-libraries-needed-for-hello-jnicallback-lib" class="headerlink" title="Include libraries needed for hello-jnicallback lib"></a>Include libraries needed for hello-jnicallback lib</h1><p>target_link_libraries(hello-jnicallback<br>                     android<br>                     log)</p>
<p>set(ndk_helper_dir ../../../../common/ndk_helper)</p>
<p>add_subdirectory(${ndk_helper_dir} ndk_helper)</p>
<p>target_include_directories(ChoreographerNativeActivity PRIVATE</p>
<p>    ${ANDROID_NDK}/sources/android/cpufeatures  </p>
<p>    ${ndk_helper_dir})</p>
<p># Export ANativeActivity_onCreate(), </p>
<h1 id="Refer-to-https-github-com-android-ndk-ndk-issues-381"><a href="#Refer-to-https-github-com-android-ndk-ndk-issues-381" class="headerlink" title="Refer to: https://github.com/android-ndk/ndk/issues/381."></a>Refer to: <a href="https://github.com/android-ndk/ndk/issues/381">https://github.com/android-ndk/ndk/issues/381</a>.</h1><p>set(CMAKE_SHARED_LINKER_FLAGS</p>
<p>    &quot;${CMAKE_SHARED_LINKER_FLAGS} -u ANativeActivity_onCreate&quot;)</p>
<p>set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=gnu++11 -Wall -fno-exceptions -fno-rtti&quot;)</p>
<p>set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS}  -Wall -Werror&quot;)</p>
<p>set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Werror&quot;)</p>
<p>set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -Wall -UNDEBUG&quot;)</p>
<p>set(CMAKE_VERBOSE_MAKEFILE on)</p>
<p>add_definitions(&quot;-DANDROID_NDK -DDISABLE_IMPORTGL&quot;)</p>
<h1 id="build-app’s-shared-lib"><a href="#build-app’s-shared-lib" class="headerlink" title="build app’s shared lib"></a>build app’s shared lib</h1><h1 id="set-up-neon-build-flag-for-file-using-intrinsics"><a href="#set-up-neon-build-flag-for-file-using-intrinsics" class="headerlink" title="set up neon build flag for file using intrinsics"></a>set up neon build flag for file using intrinsics</h1><h1 id="name-helloneon-intrinsics-c-It-is-named-EXACTLY-as-this-on-disk"><a href="#name-helloneon-intrinsics-c-It-is-named-EXACTLY-as-this-on-disk" class="headerlink" title="name: helloneon-intrinsics.c (It is named EXACTLY as this on disk,"></a>name: helloneon-intrinsics.c (It is named EXACTLY as this on disk,</h1><h1 id="just-like-a-normal-source-file"><a href="#just-like-a-normal-source-file" class="headerlink" title="just like a normal source file)"></a>just like a normal source file)</h1><h1 id="then-set-up-neon-flag-for-neon-files"><a href="#then-set-up-neon-flag-for-neon-files" class="headerlink" title="then set up neon flag for neon files"></a>then set up neon flag for neon files</h1><h1 id="This-example-only-build-for-armeabi-v7a-x86-could-be-done-the-same-way"><a href="#This-example-only-build-for-armeabi-v7a-x86-could-be-done-the-same-way" class="headerlink" title="[This example only build for armeabi-v7a, x86 could be done the same way]"></a>[This example only build for armeabi-v7a, x86 could be done the same way]</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>if (${ANDROID_ABI} STREQUAL &quot;armeabi-v7a&quot;)</p>
<p>  # make a list of neon files and add neon compiling flags to them</p>
<p>  set(neon_SRCS helloneon-intrinsics.c)</p>
<p>  set_property(SOURCE ${neon_SRCS}</p>
<p>               APPEND_STRING PROPERTY COMPILE_FLAGS &quot; -mfpu=neon&quot;)</p>
<p>  add_definitions(&quot;-DHAVE_NEON=1&quot;)</p>
<p>else ()</p>
<p>  set(neon_SRCS)</p>
<p>endif ()</p>
<h1 id="copy-out-the-lib-binary-and-remove-generated-files"><a href="#copy-out-the-lib-binary-and-remove-generated-files" class="headerlink" title="copy out the lib binary and remove generated files"></a>copy out the lib binary and remove generated files</h1><p>set(distribution_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../../../../distribution)</p>
<p>set_target_properties(gperf</p>
<p>                      PROPERTIES</p>
<p>                      LIBRARY_OUTPUT_DIRECTORY</p>
<p>                      &quot;${distribution_DIR}/gperf/lib/${ANDROID_ABI}&quot;)</p>
<p>add_custom_command(TARGET gperf POST_BUILD</p>
<p>                   COMMAND &quot;${CMAKE_COMMAND}&quot; -E</p>
<p>                   copy &quot;${CMAKE_CURRENT_SOURCE_DIR}/src/gperf.h&quot;</p>
<p>                   &quot;${distribution_DIR}/gperf/include/gperf.h&quot;</p>
<p>                   COMMENT &quot;Copying gperf to output directory&quot;)</p>
<p>set(CMAKE_VERBOSE_MAKEFILE on)</p>
<p>set(lib_src_DIR ${CMAKE_CURRENT_SOURCE_DIR})</p>
<p>set(lib_build_DIR $ENV{HOME}/tmp)</p>
<p>file(MAKE_DIRECTORY ${lib_build_DIR})</p>
<p>add_subdirectory(${lib_src_DIR}/gmath ${lib_build_DIR}/gmath)</p>
<p>add_subdirectory(${lib_src_DIR}/gperf ${lib_build_DIR}/gperf)</p>
<p>set(webp_src_dir ../libwebp)</p>
<h1 id="clone-the-dependency-repo"><a href="#clone-the-dependency-repo" class="headerlink" title="clone the dependency repo."></a>clone the dependency repo.</h1><h1 id="git-submodule-could-also-be-used-if-this-sample-does-not-need"><a href="#git-submodule-could-also-be-used-if-this-sample-does-not-need" class="headerlink" title="git submodule could also be used if this sample does not need"></a>git submodule could also be used if this sample does not need</h1><h1 id="Android-Studio’s-quot-Import-Android-code-sample-quot-option"><a href="#Android-Studio’s-quot-Import-Android-code-sample-quot-option" class="headerlink" title="Android Studio’s &quot;Import Android code sample&quot; option"></a>Android Studio’s &quot;Import Android code sample&quot; option</h1><p>if ((NOT EXISTS ${webp_src_dir}) OR</p>
<p>    (NOT EXISTS ${webp_src_dir}/CMakeLists.txt))</p>
<p>    execute_process(COMMAND git clone</p>
<p>                            <a href="https://chromium.googlesource.com/webm/libwebp">https://chromium.googlesource.com/webm/libwebp</a></p>
<p>                            libwebp</p>
<p>                    WORKING_DIRECTORY  ${CMAKE_CURRENT_SOURCE_DIR}/..)</p>
<p>endif()</p>
<h1 id="build-native-app-glue-as-a-static-lib-1"><a href="#build-native-app-glue-as-a-static-lib-1" class="headerlink" title="build native_app_glue as a static lib"></a>build native_app_glue as a static lib</h1><p>include_directories(${ANDROID_NDK}/sources/android/native_app_glue)</p>
<p>find_package(cdep-dependencies REQUIRED)</p>
<p>add_all_cdep_dependencies(hello-cdep)</p>
<p>if (${ANDROID_PLATFORM_LEVEL} LESS 12)</p>
<p>  message(FATAL_ERROR &quot;OpenGL 2 is not supported before API level 11 (currently using ${ANDROID_PLATFORM_LEVEL}).&quot;)</p>
<p>  return()</p>
<p>elseif (${ANDROID_PLATFORM_LEVEL} LESS 18)</p>
<p>  add_definitions(&quot;-DDYNAMIC_ES3&quot;)</p>
<p>  set(OPENGL_LIB GLESv2)</p>
<p>else ()</p>
<p>  set(OPENGL_LIB GLESv3)</p>
<p>endif (${ANDROID_PLATFORM_LEVEL} LESS 11)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>CMakeLists</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/CMakeLists.txt%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>cmake_minimum_required(VERSION 3.4.1)<br>#add_definitions(-Wno-bitwise-op-parentheses)<br>set(ADIAG_PATH ../Adiag/src/main/jni)<br>aux_source_directory(${ADIAG_PATH}/Application SRC1)<br>aux_source_directory(${ADIAG_PATH}/Application/Android SRC2)<br>aux_source_directory(${ADIAG_PATH}/Application/Appdiag SRC3)<br>aux_source_directory(${ADIAG_PATH}/Application/Applib SRC4)<br>aux_source_directory(${ADIAG_PATH}/Application/AppSystem SRC5)<br>aux_source_directory(${ADIAG_PATH}/Application/Appwin32 SRC6)<br>aux_source_directory(${ADIAG_PATH}/Application/ngui SRC7)<br>aux_source_directory(${ADIAG_PATH}/Application/ui SRC8)<br>set(SRC_LIST ${SRC1} ${SRC2} ${SRC3} ${SRC4} ${SRC5} ${SRC6} ${SRC7} ${SRC8})<br>add_library(mainframe SHARED ${SRC_LIST})<br>target_include_directories(mainframe PRIVATE<br>     ${ADIAG_PATH}/Application/<br>     ${ADIAG_PATH}/Application/Android<br>     ${ADIAG_PATH}/Application/ngui<br>     ${ADIAG_PATH}/Application/Include<br>     ${ADIAG_PATH}/Application/AppSystem<br>     ${ADIAG_PATH}/Application/Applib<br>     ${ADIAG_PATH}/Application/Appdiag<br>     ${ADIAG_PATH}/Application/Appwin32<br>    )<br>target_compile_options(mainframe PRIVATE<br>                -Wno-bitwise-op-parentheses<br>                -Wno-implicit-function-declaration<br>                -Wno-unused-value<br>                -Wno-unsequenced<br>                )</p>
<h1 id="Include-libraries-needed-for-xx-lib"><a href="#Include-libraries-needed-for-xx-lib" class="headerlink" title="Include libraries needed for xx lib"></a>Include libraries needed for xx lib</h1><p>target_link_libraries(mainframe<br>                      android<br>                      log)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>CMakeLists</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/CMakeLists.txt%20%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<p>﻿</p>
<p>cmake_minimum_required(VERSION 3.4.1)</p>
<p>帮助文档</p>
<p><a href="https://cmake.org/cmake/help/latest/">https://cmake.org/cmake/help/latest/</a></p>
<p>添加-D 选项</p>
<p>add_definitions(-Wno-bitwise-op-parentheses)</p>
<p>给taget 添加编译选项</p>
<p>target_compile_options(mainframe PRIVATE</p>
<pre><code>            -Wno-bitwise-op-parentheses
            -Wno-implicit-function-declaration
            -Wno-unused-value
            -Wno-unsequenced</code></pre>
<p>)</p>
<p>设置变量值</p>
<p>set(ADIAG_PATH ../Adiag/src/main/jni)</p>
<p>查找指定目录下的源文件</p>
<p>aux_source_directory(${ADIAG_PATH}/Application SRC1)<br>编译动态库<br>add_library(mainframe SHARED ${SRC_LIST})</p>
<p>添加头文件目录</p>
<p>target_include_directories(mainframe PRIVATE<br>     ${ADIAG_PATH}/Application/<br>    )</p>
<p> 指定链接的库</p>
<p>target_link_libraries(mainframe</p>
<p>android</p>
<p>build.gradle 配置</p>
<p>ndk {<br>    abiFilters ‘x86’, ‘x86_64’, ‘armeabi’, ‘armeabi-v7a’, ‘arm64-v8a’    <br>}</p>
<p>android {</p>
<p>defaultConfig {</p>
<p>externalNativeBuild {<br>cmake {<br>arguments ‘-DANDROID_PLATFORM=android-21’,<br>                 ‘-DANDROID_TOOLCHAIN=clang’<br>       }<br>    }</p>
<p>  }</p>
<p>externalNativeBuild {<br>cmake {<br>path &quot;src/main/cpp/CMakeLists.txt&quot;<br>   }<br>}</p>
<p>}</p>
<p> externalNativeBuild {</p>
<p>ndkBuild {</p>
<p>            path ‘Android.mk’</p>
<p>        }</p>
<p>    }</p>
<p>log)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>CVBS、S－Video、YPbPr、模拟RGB、DVI和HDMI</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/CVBS%E3%80%81S%EF%BC%8DVideo%E3%80%81YPbPr%E3%80%81%E6%A8%A1%E6%8B%9FRGB%E3%80%81DVI%E5%92%8CHDMI/</url>
    <content><![CDATA[<p>CVBS、S－Video、YPbPr、模拟RGB、DVI和HDMI<br>AV 也称CVBS（复合端子） 就是你家DVD接到电视上的接口，清晰度差。<br>S-Video端子就是电脑显卡上那个圆口，可以接电视，比AV清晰一点。<br>VGA就是电脑连显示器（CRT）的接口，传输模拟的RGB信号<br>DVI是电脑连液晶（LCD）的接口，传输数字信号RGB，下两个好像是色差线，<br>HDMI是DVI升级版，传输视频&amp;音频，带宽最大，最清晰，数字 信号，未来发展趋势 <br>YPbPR和YCbCr端子：只是使用3根线对yuv信号分别传输。<br>CVBS：复合视频基带信号（或复合视频消隐与同步）。复合的视频一般通过黄色<br>RCA接头来连接的。它将亮度、色度、同步和色彩脉冲信息整合到一根电<br>缆内。<br>CVBS <br>是被广泛使用的标准，也叫做基带视频或RCA视频，是全国电视系统委员会（NTSC）电视信号的传统图像数据传输方法，它以模拟波形来传输数据。复合视频包含色差（色调和饱和度）和亮度（光亮）信息，并将它们同步在消隐脉冲中，用同一信号传输。<br>快速扫描的NTSC电视中，甚高频（VHF）或超高频（UHF）载波是复合视频所使用的调整振幅，这使产生的信号大约有6MHz宽。一些闭路电视系统使用同轴电缆近距离传输复合视频，一些DVD播放器和视频磁带录像机（VCR）通过拾音插座提供复合视频输入和输出.<br>S－Video（Y/C）：可以分别传送亮度和色度内容。将亮度信息与色差信号分离<br>开来，可以大幅改善图像质量，这也正是S－Video连接在当今的家庭影院<br>系统中流行的原因。连接器是S端子。<br>分量视频，也称为YPbPr，这是YCbCr数字视频的的模拟版本。在这种视频中，<br>每个亮度与色度通道都是单独提取、输出的，每路都带有自己的时序。这就<br>保证了模拟传输后图像的高品质。分量连接在家用影院系统组件，如DVD播<br>放器和A/V接收机中。<br>模拟RGB（VGA）：具有分离的红、绿、蓝信号通道。这可以提供类似于分量视<br>频的图像质量，但它一般用于计算机图形图像领域，而分量视频则主要应用<br>于消费类电子方面。RGB连接器是DB15连接器。<br>DVI（Digital Visual Interface）接口，即数字视频接口。<br>目前的DVI接口分为两种：一个是DVI-D接口，只能接收数字信号，接口上只有3排8列共24个针<br>脚，其中右上角的一个针脚为空。不兼容模拟信号。<br>另外一种则是DVI-I接口，可同时兼容模拟和数字信号。兼容模拟信号并<br>不意味着模拟信号的接口D-Sub接口可以连接在DVI-I接口上，而是必须通过<br>一个转换接头才能使用，一般采用这种接口的显卡都会带有相关的转换接头。<br>HDMI，英文全称是High Definition Multimedia Interface，中文名称是高清晰<br>多媒体接口的缩写。专用接口，现在新品影视产品基本都有此接口。 <br>VGA接口产生原因： 显卡所处理的信息最终都要输出到显示器上，显卡的输出接口就是电脑与显示器之间的桥梁，它负责向显示器输出相应的图像信号。CRT显示器因为设计制造上的原因，只能接受模拟信号输入，这就需要显卡能输入模拟信号。VGA接口就是显卡上输出模拟信号的接口，VGA（Video Graphics Array）接口，也叫D-Sub接口。虽然液晶显示器可以直接接收数字信号，但很多低端产品为了与VGA接口显卡相匹配，因而采用VGA接口。<br>  VGA接口是一种D型接口，上面共有15针空，分成三排，每排五个。VGA接口是显卡上应用最为广泛的接口类型，多数的显卡都带有此种接口。有些不带VGA接口而带有DVI(Digital Visual Interface数字视频接口）接口的显卡，也可以通过一个简单的转接头将DVI接口转成VGA接口，通常没有VGA接口的显卡会附赠这样的转接头。 <br>  目前大多数计算机与外部显示设备之间都是通过模拟VGA接口连接，计算机内部以数字方式生成的显示图像信息，被显卡中的数字/模拟转换器转变为R、G、B三原色信号和行、场同步信号，信号通过电缆传输到显示设备中。对于模拟显示设备，如模拟CRT显示器，信号被直接送到相应的处理电路，驱动控制显像管生成图像。而对于LCD、DLP等数字显示设备，显示设备中需配置相应的A/D（模拟/数字）转换器，将模拟信号转变为数字信号。在经过D/A和A/D2次转换后，不可避免地造成了一些图像细节的损失。VGA接口应用于CRT显示器无可厚非，但用于连接液晶之类的显示设备，则转换过程的图像损失会使显示效果略微下降。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Camera缩略图</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Camera%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
    <content><![CDATA[<p>packages\apps\Camera\res\layout\review_thumbnail.xml</p>
<p>&lt;com.android.camera.ui.RotateImageView xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;</p>
<p>        android:id=&quot;@+id/thumbnail&quot;</p>
<p>        style=&quot;@style/ReviewThumbnail&quot;</p>
<p>        android:onClick=&quot;onThumbnailClicked&quot;</p>
<p>        android:clickable=&quot;true&quot;</p>
<p>        android:focusable=&quot;false&quot;</p>
<p>android:layout_width=&quot;105dp&quot;</p>
<p>      android:layout_height=&quot;105dp&quot;</p>
<p>        android:visibility=&quot;gone&quot;</p>
<p>android:layout_marginTop=&quot;5dp&quot;</p>
<p>android:layout_marginRight=&quot;45dp&quot;</p>
<p>        android:contentDescription=&quot;@string/accessibility_review_thumbnail&quot;</p>
<p>        android:background=&quot;@drawable/border_last_picture&quot; /&gt;</p>
<p>//在camera_control.xml中引入</p>
<p>packages\apps\Camera\res\layout-land\camera_control.xml</p>
<p>   &lt;include layout=&quot;@layout/review_thumbnail&quot; /&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Category</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Category/</url>
    <content><![CDATA[<p> <a href="http://developer.android.com/guide/components/intents-filters.html">http://developer.android.com/guide/components/intents-filters.html</a><br>Category  A string containing additional information about the kind of component that should handle the intent. Any number of category descriptions can be placed in an Intent object. As it does for actions, the Intent class defines several category constants, including these:    </p>
<p>Constant  Meaning </p>
<p>CATEGORY_BROWSABLE  The target activity can be safely invoked by the browser to display data referenced by a link — for example, an image or an e-mail message. </p>
<p>CATEGORY_GADGET  The activity can be embedded inside of another activity that hosts gadgets. </p>
<p>CATEGORY_HOME  The activity displays the home screen, the first screen the user sees when the device is turned on or when the Home button is pressed. </p>
<p>CATEGORY_LAUNCHER  The activity can be the initial activity of a task and is listed in the top-level application launcher. </p>
<p>CATEGORY_PREFERENCE  The target activity is a preference panel. </p>
<p>See the Intent class description for the full list of categories.</p>
<p>The addCategory() method places a category in an Intent object, removeCategory() deletes a category previously added, and getCategories() gets the set of all categories currently in the object.</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>CodeIgniter PHP MVC框架</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/CodeIgniter%20PHP%20MVC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p><a href="http://codeigniter.org.cn/">http://codeigniter.org.cn/</a> 中文官网</p>
<p><a href="https://github.com/CodeIgniter-Chinese/rapid-php-application-development">https://github.com/CodeIgniter-Chinese/rapid-php-application-development</a>  教程</p>
<p><a href="https://github.com/magicedward/codeigniter-restserver">https://github.com/magicedward/codeigniter-restserver</a>  RestFul API</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>C语言 Static的两个作用</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/C%E8%AF%AD%E8%A8%80%20Static%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>Static的两个作用：</p>
<p>（1）第一个作用：修饰变量。变量又分为局部和全局变量，但它们都存在内存的静态区。静态全局变量，作用域仅限于变量被定义的文件中，其他文件即使用extern  声明也没法使用他。准确地说作用域是从定义之处开始，到文件结尾处结束，在定义之处前面的那些代码行也不能使用它。静态局部变量，在函数体里面定义的，就只能在这个函数里用了，同一个文档中的其他函数也用不了。由于被static  修饰的变量总是存在内存的静态区，所以即使这个函数运行结束，这个静态变量的值还是不会被销毁，函数下次使用时仍然能用到这个值。</p>
<p>（2）修饰函数。函数前加static  使得函数成为静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件(所以又称内部函数)。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Compatibility Test Suite (CTS)</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Compatibility%20Test%20Suite%20(CTS)/</url>
    <content><![CDATA[<p>官网资源：</p>
<p><a href="http://source.android.com/compatibility/downloads.html">http://source.android.com/compatibility/downloads.html</a></p>
<ol>
<li><p>什么要过CTS ？</p>
</li>
<li><p>Give your users the best possible experience with the applications they run.</p>
</li>
</ol>
<p>When a device is compatible with Android, users can choose from among many </p>
<p>high-quality applications. Applications that take full advantage of Android’s </p>
<p>features are likely to perform best on compatible devices.</p>
<p>2.</p>
<p>Make it easy for developers to write top-quality applications for your device.</p>
<p>Developers want to streamline their applications for Android, and this is easiest for </p>
<p>them when they are writing for a predictable platform. </p>
<p>3.</p>
<p>Take advantage of the Android Market.</p>
<p>Compatible handsets can give users access to the Android Market.</p>
<ol start="2">
<li>adb 环境</li>
</ol>
<p>RK的SDK直接执行setpaths , 或参考Android官网</p>
<p>3.拷贝媒体文件</p>
<p>CTS Media 1.0</p>
<p>执行 copy_media.sh</p>
<p>4.设置及安装测试APK</p>
<p>Settings &gt; Wi-Fi</p>
<p>Settings &gt; Display &gt; Sleep &gt; never timeout</p>
<p>Settings &gt; Security &gt; Screen Lock  should be ‘None’</p>
<p>Settings &gt; Developer options &gt; USB debugging</p>
<p>Settings &gt; Developer options &gt; Stay Awake is checked</p>
<p>Settings &gt; Developer options &gt; Allow mock locations is checked</p>
<p>Settings &gt; Location services &gt; Google’s location service (network location needed)</p>
<p>Settings &gt; Data &amp; time &gt; Select time zone (some timezone doesn’t work)</p>
<p>adb install android-cts/repository/testcases/CtsDelegatingAccessibilityService.apk</p>
<p>enable Settings &gt; Accessibility &gt; Delegating Accessibility Service</p>
<p>adb install android-cts/repository/testcases/CtsDeviceAdmin.apk</p>
<p>enable Settings &gt; Security &gt; Device Administrators &gt; android.deviceadmin.cts.CtsDeviceAdmin* settings</p>
<p>Make sure the device is at the home screen at the start of CTS</p>
<p>5. ./android-cts/tools/cts-tradefed   CTS 命令</p>
<p>  执行  run cts –plan CTS </p>
<p>  完成后生成报告 ：  $CTS_ROOT/repository/results/&lt;start time&gt;.zip  </p>
<p>run cts</p>
<p>    –plan &lt;test_plan_name&gt;</p>
<p>    – package/-p &lt;test_package_name&gt;  [–package/-p &lt;test_package2&gt;…]</p>
<p>    –class/-c &lt;class_name&gt; [–method/-m &lt;test_method_name&gt;</p>
<p>    –continue-session-id</p>
<p>    –shards  &lt;number_of_shards&gt;</p>
<p>    –serial/-s &lt;deviceID&gt;</p>
<p>List</p>
<p>    list packages</p>
<p>    list plans</p>
<p>    list invocations</p>
<p>    list commands</p>
<p>    list results  (l r)</p>
<p>    list devices</p>
<p>Add  （添加新计划）</p>
<p>add derivedplan –plan &lt;plan_name&gt;</p>
<p>–result/-r</p>
<p>[pass | fail | timeout | notExecuted]</p>
<p>[–session/-s &lt;session_id&gt;]</p>
<p>CTS-verifier</p>
<p>     Data Backup test</p>
<p>          –&gt;settings-&gt;Backup my data 勾选</p>
<p>    进入Data Backup test -&gt; Generate Test Data</p>
<p>  adb shell<br>                bmgr enable true</p>
<p>                bmgr transport android/com.android.internal.backup.LocalTransport</p>
<p>                bmgr run</p>
<p>  卸载Cts-verifier,重新安装，数据一样表示通过。</p>
<p>需要注意的地方：</p>
<ol>
<li>system/etc/permissions</li>
</ol>
<p> 相应权限必须对应，系统没有的功能，不能出现</p>
<p> 如 &lt;feature name=&quot;android.hardware.sensor.accelerometer&quot; /&gt;</p>
<p>在 hardware/rk29/sensor/st   sSensorList[] 对应定义</p>
<p> &lt;feature name=&quot;android.hardware.camera&quot; /&gt;</p>
<p>&lt;feature name=&quot;android.hardware.camera.front&quot; /&gt;</p>
<p>     &lt;feature name=&quot;android.hardware.location&quot; /&gt;</p>
<p>&lt;feature name=&quot;android.hardware.location.network&quot; /&gt;</p>
<p>前置摄象头与网络定位如此声明</p>
<p>2. media_profiles.xml 与 kernel 中 定义摄像头的帧率须相同</p>
<ol start="3">
<li>系统某些必须的APK是不能删除的，如 Phone.apk Gsmcore.apk 等</li>
</ol>
<p> 添加到system/app 中的apk ，需要SDK的签名。</p>
<p>android.hardware</p>
<p>android.hardware.cts.CameraTest</p>
<p>android.mediastress.cts.MediaRecorderStressTest</p>
<p>android.media.cts.CamcorderProfileTest  </p>
<p>-m testGet</p>
<p>-m testGetWithId</p>
<p>//7个网络问题</p>
<p>android.media.cts.StreamingMediaPlayerTest </p>
<p>– testHLS </p>
<p>– testHTTP_H263_AMR_Video1 </p>
<p>– testHTTP_H263_AMR_Video2 </p>
<p>– testHTTP_H264Base_AAC_Video1 </p>
<p>– testHTTP_H264Base_AAC_Video2 </p>
<p>– testHTTP_MPEG4SP_AAC_Video1 </p>
<p>– testHTTP_MPEG4SP_AAC_Video2 </p>
<p>//第一次可以过</p>
<p>android.provider.cts.MediaStore_Audio_AlbumsTest </p>
<p>– testStoreAudioAlbumsExternal  </p>
<p>android.provider.cts.MediaStore_Audio_ArtistsTest </p>
<p>– testStoreAudioArtistsExternal  </p>
<p>android.provider.cts.MediaStore_Audio_Artists_AlbumsTest </p>
<p>– testStoreAudioArtistsAlbumsExternal </p>
<p>//dpi 120 才可以过  与字体大小也有关</p>
<p>android.accessibilityservice.cts.AccessibilityTextTraversalTest </p>
<p>–testActionNextAndPreviousAtGranularityPageOverText</p>
<p>//Camera驱动 黑暗不行</p>
<p>android.media.cts.MediaRecorderTest</p>
<p>–testSetMaxFileSize</p>
<p>//测试BuildFingerprint是否符合ccd标准</p>
<p>android.os.cts.BuildVersionTest</p>
<p>–testBuildFingerprint</p>
<p>//sys不可以有写权限</p>
<p>android.permission.cts.FileSystemPermissionTest</p>
<p>– testAllFilesInSysAreNotWritable</p>
<p>//去掉hardware无关的sensor</p>
<p>// hardware\rk29\sensor\st\sensors.c  static const struct sensor_t sSensorList[]</p>
<p>android.hardware.cts.SensorTest</p>
<p>– testSensorOperations</p>
<p>//检查系统features 跟/etc/permissions对应</p>
<p>android.app.cts.SystemFeaturesTest</p>
<p>//检查签名 注意第三方apk 可以用系统签名</p>
<p>android.content.pm.cts.SignatureTest</p>
<p>//不能有Debug apk</p>
<p>android.permission.cts.DebuggableTest</p>
<p>device/rockchip/rk30sdk/overlay/frameworks/base/core/res/res/values/config.xml </p>
<p>//开机向导中有拨打紧急电话选项</p>
<p>    &lt;bool name=&quot;config_voice_capable&quot;&gt;false&lt;/bool&gt;</p>
<p>    &lt;bool name=&quot;config_sms_capable&quot;&gt;false&lt;/bool&gt;</p>
<p>//非3G版本 网络设置</p>
<p>&lt;string-array translatable=&quot;false&quot; name=&quot;networkAttributes&quot;&gt;</p>
<p>        &lt;item&gt;&quot;wifi,1,1,1,-1,true&quot;&lt;/item&gt;</p>
<p>        &lt;item&gt;&quot;wifi_p2p,13,1,0,-1,true&quot;&lt;/item&gt;</p>
<p>        &lt;item&gt;&quot;eth,9,9,4,60000,true&quot;&lt;/item&gt;</p>
<p> &lt;/string-array&gt;</p>
<p> run cts -c android.view.cts.DisplayRefreshRateTest -m testRefreshRate</p>
<p>adb logcat -s DisplayRefreshRateTest</p>
<p>DisplayRefreshRateTest( 1943): claimed 58.343 fps, achieved 58.10854 fps</p>
<p>只要claimed的帧数（驱动配置）与，achived得到（上层得到帧数）相当，这项测试才能通过</p>
<p>hb + hpw = m</p>
<p>vb + vpw = n </p>
<p>run cts -c com.android.cts.jank.opengl.CtsHostJankOpenGl -m testPixelOutput</p>
<p>fps &lt; = 60</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>C语言中最常用标准库函数</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%9C%80%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>标准头文件包括：</p>
<p>&lt;asset.h&gt;      &lt;ctype.h&gt;       &lt;errno.h&gt;       &lt;float.h&gt;  </p>
<p>&lt;limits.h&gt;      &lt;locale.h&gt;       &lt;math.h&gt;        &lt;setjmp.h&gt; </p>
<p>&lt;signal.h&gt;     &lt;stdarg.h&gt;      &lt;stddef.h&gt;      &lt;stdlib.h&gt;</p>
<p>&lt;stdio.h&gt;      &lt;string.h&gt;        &lt;time.h&gt;</p>
<p>一、标准定义（&lt;stddef.h&gt;） </p>
<p>    文件&lt;stddef.h&gt;里包含了标准库的一些常用定义，无论我们包含哪个标准头文件，&lt;stddef.h&gt;都会被自动包含进来。</p>
<p>    这个文件里定义：</p>
<p>  l    类型size_t   （sizeof运算符的结果类型，是某个无符号整型）；</p>
<p>  l    类型ptrdiff_t（两个指针相减运算的结果类型，是某个有符号整型）；</p>
<p>  l    类型wchar_t  （宽字符类型，是一个整型，其中足以存放本系统所支持的所有本地环境中的字符集的所有编码值。这里还保证空字符的编码值为0）；</p>
<p>l    符号常量NULL  （空指针值）；</p>
<p>  l    宏offsetor   （这是一个带参数的宏，第一个参数应是一个结构类型，第二个参数应是结构成员名。</p>
<p>                   offsetor(s,m)求出成员m在结构类型t的变量里的偏移量）。</p>
<p> 注：其中有些定义也出现在其他头文件里（如NULL）。</p>
<p>二、错误信息（&lt;errno.h&gt;）</p>
<p>     &lt;errno.h&gt;定义了一个int类型的表达式errno，可以看作一个变量，其初始值为0，一些标准库函数执行中出错时将它设为非0值，但任何标准库函数都设置它为0。</p>
<p>&lt;errno.h&gt;里还定义了两个宏EDOM和ERANGE，都是非0的整数值。数学函数执行中遇到参数错误，就会将errno置为EDOM，如出现值域错误就会将errno置为ERANGE。</p>
<p>三、输入输出函数（&lt;stdio.h&gt;）</p>
<p>文件打开和关闭：</p>
<p>      FILE *fopen(const char *filename, const char *mode);</p>
<p>      int fclose(FILE * stream);</p>
<p>字符输入输出：</p>
<p>      int fgetc(FILE *fp);</p>
<p>      int fputc(int c, FILE *fp);</p>
<p>   getc和putc与这两个函数类似，但通过宏定义实现。通常有下面定义：</p>
<p>      #define getchar()  getc(stdin)</p>
<p>      #define putchar(c) putc(c, stdout)</p>
<p>      int ungetc(int c, FILE* stream);//把字符 c 退回流 stream</p>
<p>格式化输入输出：</p>
<p>      int scanf(const char *format, …);</p>
<p>      int printf(const char *format, …);</p>
<p>      int fscanf(FILE *stream, const char *format, …);</p>
<p>      int fprintf(FILE *stream, const char *format, …);</p>
<p>      int sscanf(char *s, const char *format, …);</p>
<p>      int sprintf(char *s, const char *format, …);</p>
<p>行式输入输出：</p>
<p>      char *fgets(char *buffer, int n, FILE *stream);</p>
<p>      int fputs(const char *buffer, FILE *stream);</p>
<p>      char *gets(char *s);</p>
<p>      int puts(const char *s);</p>
<p>直接输入输出：</p>
<p>      size_t fread(void *pointer, size_t size, size_t num, FILE *stream);</p>
<p>      size_t fwrite(const void *pointer, size_t size, size_t num, FILE *stream);</p>
<p>四、数学函数（&lt;math.h&gt;）</p>
<p>三角函数：</p>
<p>三角函数</p>
<p>sin</p>
<p>cos</p>
<p>tan</p>
<p>反三角函数</p>
<p>asin</p>
<p>acos</p>
<p>atan</p>
<p>双曲函数</p>
<p>sinh</p>
<p>cosh</p>
<p>tanh</p>
<p>指数和对数函数：</p>
<p>以e为底的指数函数</p>
<p>exp</p>
<p>自然对数函数</p>
<p>log</p>
<p>以10为底的对数函数</p>
<p>log10</p>
<p>其他函数：</p>
<p>平方根</p>
<p>sqrt</p>
<p>绝对值</p>
<p>fabs</p>
<p>乘幂，第一个参数作为底，第二个是指数</p>
<p>double pow(double, double)</p>
<p>实数的余数，两个参数分别是被除数和除数</p>
<p>double fmod(double, double)</p>
<p>注：所有上面未给出类型特征的函数都取一个参数，其参数与返回值都是double类型。</p>
<p>下面函数返回双精度值（包括函数ceil和floor）。在下表里，除其中有特别说明的参数之外，所有函数的其他参数都是double类型。</p>
<p>函数原型</p>
<p>意义解释</p>
<p>ceil(x)</p>
<p>求出不小于x的最小整数（返回与这个整数对应的double值）</p>
<p>floor(x)</p>
<p>求出不大于x的最大整数（返回与这个整数对应的double值）</p>
<p>atan2(y, x)</p>
<p>求出 tan-1(y/x)，其值的范围是[-pai,pai] </p>
<p>ldexp(x, int n)</p>
<p>求出x*2n</p>
<p>frexp(x, int *exp)</p>
<p>把 x分解为 y<em>2n， 是位于区间 [1/2,1)里的一个小数，作为函数结果返回，整数n 通过指针</em>exp返回（应提供一个int变量地址）。当x 为0时这两个结果的值都是0</p>
<p>modf(x, double</p>
<p>*ip)</p>
<p>把x分解为小数部分和整数部分，小数部分作为函数返回值，整数部分通过指针*ip返回。</p>
<p>五、字符处理函数（&lt;ctype.h&gt;）</p>
<p>见下表：</p>
<p>int isalpha(c)</p>
<p>c是字母字符</p>
<p>int isdigit(c)</p>
<p>c是数字字符</p>
<p>int isalnum(c)</p>
<p>c是字母或数字字符</p>
<p>int isspace(c)</p>
<p>c是空格、制表符、换行符</p>
<p>int isupper(c)</p>
<p>c是大写字母</p>
<p>int islower(c)</p>
<p>c是小写字母</p>
<p>int iscntrl(c)</p>
<p>c是控制字符</p>
<p>int isprint(c)</p>
<p>c是可打印字符，包括空格</p>
<p>int isgraph(c)</p>
<p>c是可打印字符，不包括空格</p>
<p>int isxdigit(c)</p>
<p>c是十六进制数字字符</p>
<p>int ispunct(c)</p>
<p>c是标点符号</p>
<p>int tolower(int c)</p>
<p>当c是大写字母时返回对应小写字母，否则返回c本身</p>
<p>int toupper(int c)</p>
<p>当c是小写字母时返回对应大写字母，否则返回c本身</p>
<p>注：条件成立时这些函数返回非0值。最后两个转换函数对于非字母参数返回原字符。</p>
<p>六、字符串函数（&lt;string.h&gt;）</p>
<p>字符串函数</p>
<p>    所有字符串函数列在下表里，函数描述采用如下约定：s、t表示 (char <em>)类型的参数，cs、ct表示(const char</em>)类型的参数（它们都应表示字符串）。n表示size_t类型的参数（size_t是一个无符号的整数类型），c是整型参数（在函数里转换到char）：</p>
<p>函数原型</p>
<p>意义解释</p>
<p>size_t strlen(cs)</p>
<p>求出cs的长度</p>
<p>char *strcpy(s,ct)</p>
<p>把ct复制到s。要求s指定足够大的字符数组</p>
<p>char *strncpy(s,ct,n)</p>
<p>把ct里的至多n个字符复制到s。要求s指定一个足够大的字符数组。如果ct里的字符不够n个，就在s里填充空字符。</p>
<p>char *strcat(s,ct)</p>
<p>把ct里的字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。</p>
<p>char *strncat(s,ct,n)</p>
<p>把ct里的至多n个字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。</p>
<p>int strcmp(cs,ct)</p>
<p>比较字符串cs和ct的大小，在cs大于、等于、小于ct时分别返回正值、0、负值。</p>
<p>int strncmp(cs,ct,n)</p>
<p>比较字符串cs和ct的大小，至多比较n个字符。在cs大于、等于、小于ct时分别返回正值、0、负值。</p>
<p>char *strchr(cs,c)</p>
<p>在cs中查寻c并返回c第一个出现的位置，用指向这个位置的指针表示。当cs里没有c时返回值NULL</p>
<p>char *strrchr(cs,c)</p>
<p>在cs中查寻c并返回c最后一个出现的位置，没有时返回NULL</p>
<p>size_t strspn(cs,ct)</p>
<p>由cs起确定一段全由ct里的字符组成的序列，返回其长度</p>
<p>size_t strcspn(cs,ct)</p>
<p>由cs起确定一段全由非ct里的字符组成的序列，返回其长度</p>
<p>char *strpbrk(cs,ct)</p>
<p>在源字符串cs中找出最先含有搜索字符串ct中任一字符的位置并返回，若找不到则返回空指针。</p>
<p>char *strstr(cs,ct)</p>
<p>在cs中查寻串ct（查询子串），返回ct作为cs的子串的第一个出现的位置，ct未出现在cs里时返回NULL</p>
<p>char *strerror(n)</p>
<p>返回与错误编号n相关的错误信息串（指向该错误信息串的指针）</p>
<p>char *strtok(s,ct)</p>
<p>在s中查寻由ct中的字符作为分隔符而形成的单词</p>
<p>存储区操作</p>
<p>    &lt;string.h&gt;还有一组字符数组操作函数（存储区操作函数），名字都以mem开头，以某种高效方式实现。在下面原型中，参数s和t的类型是(void *)，cs和ct的类型是(const void *)，n的类型是size_t，c的类型是int（转换为unsigned char）。</p>
<p>函数原型</p>
<p>意义解释</p>
<p>void *memcpy(s,ct,n)</p>
<p>从ct处复制n个字符到s处，返回s</p>
<p>void *memmove(s,ct,n)</p>
<p>从ct处复制n个字符到s处，返回s，这里的两个段允许重叠</p>
<p>int memcmp(cs,ct,n)</p>
<p>比较由cs和ct开始的n个字符，返回值定义同strcmp</p>
<p>void *memchr(cs,c,n)</p>
<p>在n个字符的范围内查寻c在cs中的第一次出现，如果找到，返回该位置的指针值，否则返回NULL</p>
<p>void *memset(s,c,n)</p>
<p>将s的前n个字符设置为c，返回s</p>
<p>七、功能函数（&lt;stdlib.h&gt;）</p>
<p>随机数函数：</p>
<p>函数原型</p>
<p>意义解释</p>
<p>int rand(void)</p>
<p>生成一个0到RAND_MAX的随机整数</p>
<p>void srand(unsigned seed)</p>
<p>用seed为随后的随机数生成设置种子值</p>
<p>动态存储分配函数：</p>
<p>函数原型</p>
<p>意义解释</p>
<p>void *calloc(size_t n, size_t size)</p>
<p>分配一块存储，其中足以存放n个大小为size的对象，并将所有字节用0字符填充。返回该存储块的地址。不能满足时返回NULL</p>
<p>void *malloc(size_t size)</p>
<p>分配一块足以存放大小为size的存储，返回该存储块的地址，不能满足时返回NULL</p>
<p>void *realloc(void *p, size_t size)</p>
<p>将p所指存储块调整为大小size，返回新块的地址。如能满足要求，新块的内容与原块一致；不能满足要求时返回NULL，此时原块不变</p>
<p>void free(void *p)</p>
<p>释放以前分配的动态存储块</p>
<p>几个整数函数</p>
<p>    几个简单的整数函数见下表，div_t和ldiv_t是两个预定义结构类型，用于存放整除时得到的商和余数。div_t类型的成分是int类型的quot和rem，ldiv_t类型的成分是long类型的quot和rem。</p>
<p>函数原型</p>
<p>意义解释</p>
<p>int abs(int n)</p>
<p>求整数的绝对值</p>
<p>long labs(long n)</p>
<p>求长整数的绝对值</p>
<p>div_t div(int n, int m)</p>
<p>求n/m，商和余数分别存放到结果结构的对应成员里</p>
<p>ldiv_t ldiv(long n, long m)</p>
<p>同上，参数为长整数</p>
<p>数值转换</p>
<p>函数原型</p>
<p>意义解释</p>
<p>double atof(const char *s)</p>
<p>由串s构造一个双精度值</p>
<p>int atoi(const char *s)</p>
<p>由串s构造一个整数值</p>
<p>long atol(const char *s)</p>
<p>由串s构造一个长整数值</p>
<p>执行控制</p>
<p>1）非正常终止函数abort。</p>
<p>         原型是： void abort(void);</p>
<p>2）正常终止函数exit。</p>
<p>         原型是：void exit(int status);</p>
<p>   导致程序按正常方式立即终止。status作为送给执行环境的出口值，0表示成功结束，两个可用的常数为EXIT_SUCCESS，EXIT_FAILURE。</p>
<p>3）正常终止注册函数atexit。</p>
<p>         原型是：int atexit(void (*fcn)(void))</p>
<p>   可用本函数把一些函数注册为结束动作。被注册函数应当是无参无返回值的函数。注册正常完成时atexit返回值0，否则返回非零值。</p>
<p>与执行环境交互</p>
<p>1）向执行环境传送命令的函数system。</p>
<p>            原型是：int system(const char *s);</p>
<p>   把串s传递给程序的执行环境要求作为系统命令执行。如以NULL为参数调用，函数返回非0表示环境里有命令解释器。如果s不是NULL，返回值由实现确定。</p>
<p>2）访问执行环境的函数getenv。</p>
<p>           原型是：char *getenv(const char *s);</p>
<p>   从执行环境中取回与字符串s相关联的环境串。如果找不到就返回NULL。本函数的具体结果由实现确定。在许多执行环境里，可以用这个函数去查看“环境变量”的值。</p>
<p>常用函数bsearch和qsort</p>
<p>1）二分法查找函数bsearch：</p>
<p>    void *bsearch(const void *key, const void *base, size_t n, size_t size, int (*cmp)(const void *keyval, const void *datum));</p>
<p>   函数指针参数cmp的实参应是一个与字符串比较函数strcmp类似的函数，确定排序的顺序，当第一个参数keyval比第二个参数datum大、相等或小时分别返回正、零或负值。</p>
<p>2）快速排序函数qsort：</p>
<p>     void qsort(void *base, size_t n, size_t size, int (*cmp)(const void *, const void *));</p>
<p>   qsort对于比较函数cmp的要求与bsearch一样。设有数组base[0],…,base[n-1]，元素大小为size。用qsort可以把这个数组的元素按cmp确定的上升顺序重新排列。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>C语言注意点</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/C%E8%AF%AD%E8%A8%80%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<p>预科班C语言基础</p>
<p>预处理：gcc -E test.c -o test.i</p>
<p>1.文件包含，2.宏替换。3.条件编译 。 4.去除注释</p>
<p>int 字长与机器长度一样</p>
<p>float 4 byte  double 8 byte</p>
<p>//*.h头文件</p>
<p>普通函数声明</p>
<p>内联、静态的函数定义</p>
<p>结构体 联合体 枚举等模板</p>
<p>宏定义</p>
<p>全局变量</p>
<p>strlen 实际长度</p>
<p>sizeof 存储长度  (关键长度)</p>
<p>//数组：</p>
<p>int a[5]</p>
<p>1.a是常量</p>
<p>2.a表示数组首元素地址</p>
<p>3.&amp;a表示数组首地址  &amp;a+1 表示数组外第一个地址</p>
<p>int *p;</p>
<p>*p表示一个指针</p>
<p>int 表示指针指向内存的类型</p>
<p>段错误：常量字符串值不能改变(rodata)</p>
<p>函数传参：</p>
<p>1.实参与形参相对独立</p>
<p>2.形参通过实参初始化</p>
<p>声明：1.可多次声明。2.不分配空间</p>
<p>定义：1.只能定义一次。2.分配空间 3.定义是特殊的声明</p>
<p>typedef : 定义一个类型；给类型取别名</p>
<p>区别：</p>
<p>typedef:1.关键字。2.typedef int *p ;(运行时)  3.不能扩展。</p>
<p>#define:1.宏定义。2.#define p int * (宏替换)  3. 可扩展。</p>
<p>对于C 非0即真</p>
<p>int a; a=’A’+1.6 =&gt; a为B  </p>
<p>int a = 1.6  =&gt;a=1</p>
<p>i[ch] &lt;==&gt; ch[i]</p>
<p>T *s = NULL  F(s,100);  ….属于值传递</p>
<p>%d 有符号十进制整数</p>
<p>%o 无符号八进制整数</p>
<p>%u 无符号十进制整数</p>
<p>%x 无符号十六进制整数</p>
<p>%c 一个字符</p>
<p>%s 字符串</p>
<p>%f 十进制计数法的浮点数</p>
<p>%e E-计数法的浮点数</p>
<p>%p 指针</p>
<p>函数传参：若需改变实参的值，用地址传递；否则值传递。</p>
<p>1.赋值传递 2. 地址传递 3.全局变量</p>
<p>const型指针</p>
<p>const int *p; 或者 int const *p;</p>
<p>p为指向整型变量指针，且该变量相对于p而言只读。</p>
<p>int *const p;</p>
<p>p为指向整型变量指针，且该指针p本身只读。</p>
<p>const int *const p; 或者 int const *const p;</p>
<p>p为指向整型变量只读指针，且该变量相对于p而言也是只读的。</p>
<p>局部变量 全局变量</p>
<p>存储类别 auto register 局部static 外部static 外部</p>
<p>存储方式 自动 静态</p>
<p>存储区 栈内存 寄存器 静态存储区（数据段）</p>
<p>生存期 函数调用开始至结束 程序整个运行期间</p>
<p>作用域 定义变量的函数或复合语句内 本文件 其他文件</p>
<p>赋初值 每次函数调用时 编译时赋初值，只赋一次</p>
<p>未赋初值 不确定 自动赋初值为零值或NULL</p>
<p>每个Linux程序都有一个运行时存储器映像。</p>
<p>代码段总是从地址0x08048000开始，</p>
<p>而数据段在接下来的下一个4K对齐的地址上，</p>
<p>运行时堆在接下来的读写段之后的第一个4K对齐的地址处，</p>
<p>并通过调用malloc函数族向上增长。</p>
<p>用户栈总是从地址0xbfffffff处开始向下增长，</p>
<p>从栈的上部开始于地址0xc0000000处的段是为OS驻留存储器部分的代码和数据保留的。</p>
<p>宏定义</p>
<p>1、预定义符号</p>
<p><strong>FILE</strong> 正在编译的文件名</p>
<p><strong>LINE</strong> 文件当前的行号</p>
<p><strong>FUNCTION</strong> 当前所在的函数名</p>
<p><strong>DATE</strong> 预编译文件的日期</p>
<p><strong>TIME</strong> 预编译文件的时间</p>
<p><strong>STDC</strong> 判断编译器是否遵循ANSI C，是则为1</p>
<p>其中， __LINE__和__STDC__是整型常量，其余为字符串常量。</p>
<p>const 修饰的是readonly变量，不是常量，因此，不能作业数据大小也不能放在case后</p>
<p>也不能做数组的维数</p>
<p>//结构体部分初始化</p>
<p>struct student Michael = {.age=25, .score=88.5};</p>
<p>结构体指针</p>
<p>结构体指针也就是指向结构体的指针，例如：</p>
<p>struct student *pstudent = &amp;Bill; //指向结构体Bill的指针</p>
<p>用点运算符引用成员变量： (*pstudent).age = 27;</p>
<p>用箭头引用成员变量：pstudent-&gt;age = 27;</p>
<p>register 变量必须是一个单个的值，并且其长度应小于或等于整型的长度。而且register 变量可能不存放在内存中，所以不能用取址运算符“&amp;”</p>
<p>来获取register 变量的地址</p>
<p>0x01&lt;&lt;2+3；  =32</p>
<p>“+”号的优先级比移位运算符的优先级高</p>
<p>不能用define 宏定义注释符号</p>
<p>#define SEC_A_YEAR 60<em>60</em>24*365 (int 溢出)</p>
<p>#define SEC_A_YEAR (60<em>60</em>24*365)UL (正确)</p>
<p>每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里是n 字节)中较小的一个对齐，即：min( n, sizeof( item )) 。并且结构的长度必须为所用过的所有对齐参数的整数倍,不够就补空字节。</p>
<p>不论类型是什么,对齐的边界一定是1,2,4,8,16,32,64….中的一个</p>
<p>int *p = NULL;</p>
<p>在定义变量p 的同时把p 的值设置为0x00000000，而不是把*p 的值设置为0x00000000。这个过程叫做初始化，是在编译的时候进行的。</p>
<p>size of long is 4</p>
<p>size of long long  is 8</p>
<p>//变量： 是对程序中数据的存储空间的抽象。</p>
<p>1.预处理  Pre-Processing  (调用cpp预处理)</p>
<p>   *.c -&gt; *.i </p>
<p>gcc -E test.c -o test.i</p>
<p>2.编译 Compiling (cc1编译) 转化为汇编代码</p>
<p>  *.c/ *i  -&gt; *.s</p>
<p>gcc -S test.c -o test.s</p>
<p>3.汇编 Assembling (as 汇编)  </p>
<p>  *.c/ *.s -&gt; *.o  目标文件(可重定位文件)</p>
<p>gcc -c test.c -o test.o</p>
<p>4.链接 Linking -&gt; 可执行文件  (ld链接)</p>
<p>符号解析；重定位 多个elf -&gt; 可执行</p>
<p>//自然对齐：</p>
<p>变量存放的地址，能被变量的类型长度整除</p>
<p>那么，变量按照自然对齐存放</p>
<p>各种类型的长度(byte):</p>
<p>char 1  int 4    short 2   double 8 </p>
<p>//结构体类型的m值</p>
<p>1.若结构体中成员类型最大的m1&lt;机器字长 m=m1</p>
<p>2.基结构体中成员类型最大的m1&gt;=机器字长 m=机器字长</p>
<p>//变量m值的确定：(即m值&lt;=机器字长)</p>
<p>变量类型长度&lt;机器字长，则变量的m值为变量类型的长度</p>
<p>变量类型长度&gt;机器字长，则变量的m值为机器字长</p>
<p>//makefile</p>
<p>1.读当前目标下Makefile/makefile</p>
<p>2.找到makefile的第1个目标(abc)</p>
<p>3.在当前目录下找abc，若abc不存在或abc所依赖文件比abc新时，make执行相应命令，生成abc</p>
<p>4.若abc.o不存在 把abc.o作为目标，在makefile中找abc.o所依赖文件，执行相应命令。</p>
<p>//Makefile 规则</p>
<p>目标：依赖文件(若多个，以空格隔开)</p>
<p>&lt;Tab&gt;命令</p>
<p>伪目标：all</p>
<p>make 不会生成all(伪目标)  检查all的依赖文件</p>
<p>//变量；</p>
<p>自定义：递归 =   简单  :=(立即变量)   未定义就赋值 ?= (未定义时为延时变量)</p>
<p>+=(如果前面为立即变量:=,它也是立即变量)</p>
<p>预定义：  RM  CC  。。。</p>
<p>     (default)</p>
<p>AR    ar</p>
<p>CC    cc</p>
<p>CPP   $(cc) -E</p>
<p>EXX   g++       </p>
<p>RM    rm -f</p>
<p>//自动变量</p>
<p>$@  目标文件的完整名称</p>
<p>$*  不包括扩展名的目标文件名称</p>
<p>$+  所有依赖文件 以空格分开 顺序 可重复</p>
<p>$^  所有不重复的目标依赖文件，以空格分开</p>
<p>$&lt;  第一个依赖文件的名称</p>
<p>$?  所有时间戳比目标文件晚的依赖文件名称 空格分开</p>
<p>$%  目标归档成员名称</p>
<p>隐式规则：(同名，可以不写命令)  </p>
<p>hello.o:hello.c</p>
<p>e.g:</p>
<p>CC = gcc </p>
<p>CFLAGS = -Wall -o  </p>
<p>SRC = ${wildcard *.c}</p>
<p>OBJ = ${patsubst %.c,%,$(SRC)}</p>
<p>all:$(OBJ)</p>
<p>$(OBJ):%:%.c</p>
<p>        $(CC) $(CFLAGS) $@ $^</p>
<p>clean:</p>
<p>        @$(RM) -rvf $(OBJ) .*.swp</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>DOS xcopy</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/DOS%20xcopy/</url>
    <content><![CDATA[<p>xcopy e:<em>.</em> d: /s /h /c /y <br>XCOPY source [destination] 参数(如 /s /e) <br>source 指定要复制的文件。 <br>destination 指定新文件的位置和/或名称。 <br>/A 只复制有存档属性集的文件， <br>但不改变属性。 <br>/M 只复制有存档属性集的文件， <br>并关闭存档属性。 <br>/D:m-d-y 复制在指定日期或指定日期以后改变的文件。 <br>如果没有提供日期，只复制那些源时间 <br>比目标时间新的文件。 <br>/EXCLUDE:file1[+file2][+file3]… <br>指定含有字符串的文件列表。如果有任何 <br>字符串与要被复制的文件的绝对路径 <br>相符，那个文件将不会得到复制。 <br>例如，指定如 obj 或 .obj 的字符串会排除 <br>目录 obj 下面的所有文件或带有 <br>.obj 扩展名的文件。 <br>/P 创建每个目标文件前提示。 <br>/S 复制目录和子目录，除了空的。 <br>/E 复制目录和子目录，包括空的。 <br>与 /S /E 相同。可以用来修改 /T。 <br>/V 验证每个新文件。 <br>/W 提示您在复制前按键。 <br>/C 即使有错误，也继续复制。 <br>/I 如果目标不存在，又在复制一个以上的文件， <br>则假定目标一定是一个目录。 <br>/Q 复制时不显示文件名。 <br>/F 复制时显示完整的源和目标文件名。 <br>/L 显示要复制的文件。 <br>/G 允许将没有经过加密的文件复制到 <br>不支持加密的目标。 <br>/H 也复制隐藏和系统文件。 <br>/R 改写只读文件。 <br>/T 创建目录结构，但不复制文件。不 <br>包括空目录或子目录。/T /E 包括 <br>空目录和子目录。 <br>/U 只复制已经存在于目标中的文件。 <br>/K 复制属性。一般的 Xcopy 会重设只读属性。 <br>/N 用生成的短名复制。 <br>/O 复制文件所有权和 ACL 信息。 <br>/X 复制文件审核设置(隐含 /O)。 <br>/Y 禁止提示以确认改写一个 <br>现存目标文件。 <br>/-Y 导致提示以确认改写一个 <br>现存目标文件。 <br>/Z 用重新启动模式复制网络文件。 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Detailed Instructions</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Detailed%20Instructions/</url>
    <content><![CDATA[<p>Detailed Instructions</p>
<p>The steps below describe how to configure makefiles for new mobile devices and products running Android.</p>
<p>Create a company directory in //vendor/.</p>
<p>  mkdir vendor/&lt;company_name&gt;</p>
<p>Create a products directory beneath the company directory you created in step 1.</p>
<p>  mkdir vendor/&lt;company_name&gt;/products/</p>
<p>Create a product-specific makefile, called vendor/&lt;company_name&gt;/products/&lt;first_product_name&gt;.mk, that includes at least the following code:</p>
<p>  $(call inherit-product, $(SRC_TARGET_DIR)/product/generic.mk)<br>  #</p>
<h1 id="Overrides"><a href="#Overrides" class="headerlink" title="Overrides"></a>Overrides</h1><p>  PRODUCT_NAME := &lt;first_product_name&gt;<br>  PRODUCT_DEVICE := &lt;board_name&gt;</p>
<p>Additional product-specific variables can be added to this Product Definition file. In the products directory, create an AndroidProducts.mk file that point to (and is responsible for finding) the individual product make files.</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="This-file-should-set-PRODUCT-MAKEFILES-to-a-list-of-product-makefiles"><a href="#This-file-should-set-PRODUCT-MAKEFILES-to-a-list-of-product-makefiles" class="headerlink" title="This file should set PRODUCT_MAKEFILES to a list of product makefiles"></a>This file should set PRODUCT_MAKEFILES to a list of product makefiles</h1><h1 id="to-expose-to-the-build-system-LOCAL-DIR-will-already-be-set-to"><a href="#to-expose-to-the-build-system-LOCAL-DIR-will-already-be-set-to" class="headerlink" title="to expose to the build system.  LOCAL_DIR will already be set to"></a>to expose to the build system.  LOCAL_DIR will already be set to</h1><h1 id="the-directory-containing-this-file"><a href="#the-directory-containing-this-file" class="headerlink" title="the directory containing this file."></a>the directory containing this file.</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="This-file-may-not-rely-on-the-value-of-any-variable-other-than"><a href="#This-file-may-not-rely-on-the-value-of-any-variable-other-than" class="headerlink" title="This file may not rely on the value of any variable other than"></a>This file may not rely on the value of any variable other than</h1><h1 id="LOCAL-DIR-do-not-use-any-conditionals-and-do-not-look-up-the"><a href="#LOCAL-DIR-do-not-use-any-conditionals-and-do-not-look-up-the" class="headerlink" title="LOCAL_DIR; do not use any conditionals, and do not look up the"></a>LOCAL_DIR; do not use any conditionals, and do not look up the</h1><h1 id="value-of-any-variable-that-isn’t-set-in-this-file-or-in-a-file-that"><a href="#value-of-any-variable-that-isn’t-set-in-this-file-or-in-a-file-that" class="headerlink" title="value of any variable that isn’t set in this file or in a file that"></a>value of any variable that isn’t set in this file or in a file that</h1><h1 id="it-includes"><a href="#it-includes" class="headerlink" title="it includes."></a>it includes.</h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><p>  PRODUCT_MAKEFILES := <br>    $(LOCAL_DIR)/first_product_name.mk \</p>
<p>Create a board-specific directory beneath your company directory that matches the PRODUCT_DEVICE variable &lt;board_name&gt; referenced in the product-specific make file above. This will include a make file that gets accessed by any product using this board.</p>
<p>  mkdir vendor/&lt;company_name&gt;/&lt;board_name&gt;</p>
<p>Create a BoardConfig.mk file in the directory created in the previous step (vendor/&lt;company_name&gt;/&lt;board_name&gt;). </p>
<h1 id="These-definitions-override-the-defaults-in-config-config-make-for-lt-board-name-gt"><a href="#These-definitions-override-the-defaults-in-config-config-make-for-lt-board-name-gt" class="headerlink" title="These definitions override the defaults in config/config.make for &lt;board_name&gt;"></a>These definitions override the defaults in config/config.make for &lt;board_name&gt;</h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="TARGET-NO-BOOTLOADER-false"><a href="#TARGET-NO-BOOTLOADER-false" class="headerlink" title="TARGET_NO_BOOTLOADER := false"></a>TARGET_NO_BOOTLOADER := false</h1><h1 id="TARGET-HARDWARE-3D-false"><a href="#TARGET-HARDWARE-3D-false" class="headerlink" title="TARGET_HARDWARE_3D := false"></a>TARGET_HARDWARE_3D := false</h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><p>  TARGET_USE_GENERIC_AUDIO := true</p>
<p>If you wish to modify system properties, create a system.prop file in your &lt;board_name&gt; directory(vendor/&lt;company_name&gt;/&lt;board_name&gt;).</p>
<h1 id="system-prop-for"><a href="#system-prop-for" class="headerlink" title="system.prop for"></a>system.prop for</h1><h1 id="This-overrides-settings-in-the-products-generic-system-prop-file"><a href="#This-overrides-settings-in-the-products-generic-system-prop-file" class="headerlink" title="This overrides settings in the products/generic/system.prop file"></a>This overrides settings in the products/generic/system.prop file</h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><h1 id="rild-libpath-system-lib-libreference-ril-so"><a href="#rild-libpath-system-lib-libreference-ril-so" class="headerlink" title="rild.libpath=/system/lib/libreference-ril.so"></a>rild.libpath=/system/lib/libreference-ril.so</h1><h1 id="rild-libargs-d-dev-ttyS0"><a href="#rild-libargs-d-dev-ttyS0" class="headerlink" title="rild.libargs=-d /dev/ttyS0"></a>rild.libargs=-d /dev/ttyS0</h1><p>Add a pointer to &lt;second_product_name&gt;.mk within products/AndroidProducts.mk.</p>
<p>  PRODUCT_MAKEFILES := <br>    $(LOCAL_DIR)/first_product_name.mk <br>    $(LOCAL_DIR)/second_product_name.mk</p>
<p>An Android.mk file must be included in vendor/&lt;company_name&gt;/&lt;board_name&gt; with at least the following code:</p>
<h1 id="make-file-for-new-hardware-from"><a href="#make-file-for-new-hardware-from" class="headerlink" title="make file for new hardware  from"></a>make file for new hardware  from</h1><h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><p>  LOCAL_PATH := $(call my-dir)<br>  #</p>
<h1 id="this-is-here-to-use-the-pre-built-kernel"><a href="#this-is-here-to-use-the-pre-built-kernel" class="headerlink" title="this is here to use the pre-built kernel"></a>this is here to use the pre-built kernel</h1><p>  ifeq ($(TARGET_PREBUILT_KERNEL),)<br>  TARGET_PREBUILT_KERNEL := $(LOCAL_PATH)/kernel<br>  endif<br>  #<br>  file := $(INSTALLED_KERNEL_TARGET)<br>  ALL_PREBUILT += $(file)<br>  $(file): $(TARGET_PREBUILT_KERNEL) | $(ACP)<br>                $(transform-prebuilt-to-target)<br>  #</p>
<h1 id="no-boot-loader-so-we-don’t-need-any-of-that-stuff"><a href="#no-boot-loader-so-we-don’t-need-any-of-that-stuff" class="headerlink" title="no boot loader, so we don’t need any of that stuff.."></a>no boot loader, so we don’t need any of that stuff..</h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><p>  LOCAL_PATH := vendor/&lt;company_name&gt;/&lt;board_name&gt;<br>  #<br>  include $(CLEAR_VARS)<br>  #</p>
<h1 id="include-more-board-specific-stuff-here-Such-as-Audio-parameters"><a href="#include-more-board-specific-stuff-here-Such-as-Audio-parameters" class="headerlink" title="include more board specific stuff here? Such as Audio parameters."></a>include more board specific stuff here? Such as Audio parameters.</h1><h1 id="-8"><a href="#-8" class="headerlink" title=""></a></h1><p>To create a second product for the same board, create a second product-specific make file called vendor/company_name/products/&lt;second_product_name&gt;.mk that includes:</p>
<p>  $(call inherit-product, $(SRC_TARGET_DIR)/product/generic.mk)<br>  #</p>
<h1 id="Overrides-1"><a href="#Overrides-1" class="headerlink" title="Overrides"></a>Overrides</h1><p>  PRODUCT_NAME := &lt;second_product_name&gt;<br>  PRODUCT_DEVICE := &lt;board_name&gt;</p>
<p>By now, you should have two new products, called &lt;first_product_name&gt; and &lt;second_product_name&gt; associated with &lt;company_name&gt;. To verify that a product is properly configured (&lt;first_product_name&gt;, for example), execute the following:</p>
<p>  . build/envsetup.sh<br>  make PRODUCT-&lt;first_product_name&gt;-user</p>
<p>You should find new build binaries located in /out/target/product/&lt;board_name&gt;.</p>
<p>New Product File Tree</p>
<p>The file tree below illustrates what your own system should look like after completing the steps above.</p>
<p>&lt;company_name&gt;   &lt;board_name&gt;   Android.mk product_config.mk system.prop   products   AndroidProducts.mk &lt;first_product_name&gt;.mk &lt;second_product_name&gt;.mk      </p>
<p>Product Definition Files</p>
<p>Product-specific variables are defined in product definition files. A product definition file can inherit from other product definition files, thus reducing the need to copy and simplifying maintenance.</p>
<p>Variables maintained in a product definition files include:</p>
<p>Parameter  Description  Example </p>
<p>PRODUCT_NAME End-user-visible name for the overall product. Appears in the &quot;About the phone&quot; info.  </p>
<p>PRODUCT_MODEL End-user-visible name for the end product  </p>
<p>PRODUCT_LOCALES A space-separated list of two-letter language code, two-letter country code pairs that describe several settings for the user, such as the UI language and time, date and currency formatting. The first locale listed in PRODUCT_LOCALES is is used if the locale has never been set before. en_GB de_DE es_ES fr_CA </p>
<p>PRODUCT_PACKAGES Lists the APKs to install. Calendar Contacts </p>
<p>PRODUCT_DEVICE Name of the industrial design dream </p>
<p>PRODUCT_MANUFACTURER Name of the manufacturer acme </p>
<p>PRODUCT_BRAND The brand (e.g., carrier) the software is customized for, if any  </p>
<p>PRODUCT_PROPERTY_OVERRIDES List of property assignments in the format &quot;key=value&quot;  </p>
<p>PRODUCT_COPY_FILES List of words like source_path:destination_path. The file at the source path should be copied to the destination path when building this product. The rules for the copy steps are defined in config/Makefile  </p>
<p>PRODUCT_OTA_PUBLIC_KEYS List of OTA public keys for the product  </p>
<p>PRODUCT_POLICY Indicate which policy this product should use  </p>
<p>PRODUCT_PACKAGE_OVERLAYS Indicate whether to use default resources or add any product specific overlays vendor/acme/overlay </p>
<p>PRODUCT_CONTRIBUTORS_FILE HTML file containing the contributors to the project.  </p>
<p>PRODUCT_TAGS list of space-separated words for a given product  </p>
<p>The snippet below illustrates a typical product definition file.</p>
<p>$(call inherit-product, build/target/product/generic.mk)</p>
<p>#Overrides<br>PRODUCT_NAME := MyDevice<br>PRODUCT_MANUFACTURER := acme<br>PRODUCT_BRAND := acme_us<br>PRODUCT_LOCALES := en_GB es_ES fr_FR<br>PRODUCT_PACKAGE_OVERLAYS := vendor/acme/overlay</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>DevicePolicyManager Device-admin</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/DevicePolicyManager%20Device-admin/</url>
    <content><![CDATA[<p><a href="http://developer.android.com/guide/topics/admin/device-admin.html">http://developer.android.com/guide/topics/admin/device-admin.html</a></p>
<p>public void myDeviceAdmin(){ </p>
<p>        DevicePolicyManager mDPM = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);                                      </p>
<p>        ComponentName componentName = new ComponentName(this, AdminReceiver.class);               </p>
<p>        boolean isAdminActive = mDPM.isAdminActive(componentName);</p>
<p>if(!isAdminActive){</p>
<p>// set componentName active</p>
<p>        mDPM.setActiveAdmin(componentName, true);  </p>
<p>}</p>
<p>if(isAdminActive){            </p>
<p>mDPM.lockNow();  </p>
<p>// mDPM.setStorageEncryption(componentName, true);</p>
<p>        //  mDPM.resetPassword(&quot;123&quot;, 0);  </p>
<p>//  mDPM.wipeData(0); //0 or DevicePolicyManager.WIPE_EXTERNAL_STORAGE   </p>
<p>//  mDPM.setCameraDisabled(componentName, true);</p>
<p>//Intent intent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);</p>
<p>//startActivity(intent);</p>
<p>// set componentName inactive</p>
<p>mDPM.removeActiveAdmin(componentName);</p>
<p>        } else {</p>
<p>//set active by user</p>
<p>            Intent intent = new Intent();           </p>
<p>            intent.setAction(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);            </p>
<p>            intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, componentName);</p>
<p>            startActivity(intent);</p>
<p>        }</p>
<p>}</p>
<p>Here is an excerpt from the Device Administration sample manifest:</p>
<p>&lt;activity android:name=&quot;.app.DeviceAdminSample&quot;<br>android:label=&quot;@string/activity_sample_device_admin&quot;&gt;<br>&lt;intent-filter&gt;<br>&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;<br>&lt;category android:name=&quot;android.intent.category.SAMPLE_CODE&quot; /&gt;<br>&lt;/intent-filter&gt;<br>&lt;/activity&gt;<br>&lt;receiver android:name=&quot;.app.DeviceAdminSample$DeviceAdminSampleReceiver&quot;<br>android:label=&quot;@string/sample_device_admin&quot;<br>android:description=&quot;@string/sample_device_admin_description&quot;<br>android:permission=&quot;android.permission.BIND_DEVICE_ADMIN&quot;&gt;<br>&lt;meta-data android:name=&quot;android.app.device_admin&quot;<br>android:resource=&quot;@xml/device_admin_sample&quot; /&gt;<br>&lt;intent-filter&gt;<br>&lt;action android:name=&quot;android.app.action.DEVICE_ADMIN_ENABLED&quot; /&gt;<br>&lt;/intent-filter&gt;<br>&lt;/receiver&gt;</p>
<p>device_admin_sample.xml</p>
<p>&lt;device-admin xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;&gt;<br>&lt;uses-policies&gt;<br>&lt;limit-password /&gt;<br>&lt;watch-login /&gt;<br>&lt;reset-password /&gt;<br>&lt;force-lock /&gt;<br>&lt;wipe-data /&gt;<br>&lt;expire-password /&gt;<br>&lt;encrypted-storage /&gt;<br>&lt;disable-camera /&gt;<br>&lt;/uses-policies&gt;<br>&lt;/device-admin&gt;</p>
<p>In its DeviceAdminReceiver subclass, the sample application simply displays a Toast notification in response to particular events. For example:</p>
<p>public class DeviceAdminSample extends DeviceAdminReceiver {<br>void showToast(Context context, String msg) {<br>String status = context.getString(R.string.admin_receiver_status, msg);<br>Toast.makeText(context, status, Toast.LENGTH_SHORT).show();<br>}<br>@Override<br>public void onEnabled(Context context, Intent intent) {<br>        showToast(context, context.getString(R.string.admin_receiver_status_enabled));<br>}<br>@Override<br>public CharSequence onDisableRequested(Context context, Intent intent) {<br>return context.getString(R.string.admin_receiver_status_disable_warning);<br>}<br>@Override<br>public void onDisabled(Context context, Intent intent) {<br>        showToast(context, context.getString(R.string.admin_receiver_status_disabled));<br>}<br>@Override<br>public void onPasswordChanged(Context context, Intent intent) {<br>        showToast(context, context.getString(R.string.admin_receiver_status_pw_changed));<br>}<br>…<br>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ExecutorService</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ExecutorService/</url>
    <content><![CDATA[<p>【强制】 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方<br>式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说</p>
<p>int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors();</p>
<p>int KEEP_ALIVE_TIME = 1;<br>TimeUnit KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;<br>BlockingQueue&lt;Runnable&gt; taskQueue = new LinkedBlockingQueue&lt;Runnable&gt;();<br>ExecutorService executorService = new ThreadPoolExecutor(NUMBER_OF_CORES,<br>NUMBER_OF_CORES*2, KEEP_ALIVE_TIME, KEEP_ALIVE_TIME_UNIT,<br>taskQueue, new BackgroundThreadFactory(), new DefaultRejectedExecutionHandler());</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>FFMPEG命令行处理视频进阶</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/FFMPEG%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>FFMPEG拥有强大的视频处理能力，可惜的是有很多人不知道如何使用。本文深入介绍如何用编译好ffmpeg.exe程序处理视频，既有常用的简单的处理，也有一些比较少见的高大上的处理，一定能让你受益匪浅。ffmpeg是一把宝刀，在视频处理上，基本是一刀在手，天下我有。</p>
<p>首先下载编译好的ffmpeg程序，可以去下面的网址，<a href="https://ffmpeg.zeranoe.com/builds/#">https://ffmpeg.zeranoe.com/builds/#</a>  点击&quot;Donload Build&quot;按钮下载最新编译的版本，解压后可以看到ffmpeg.exe文件用于处理视频，ffplay.exe文件用于播放视频。也可以去ffmpeg的官网<a href="http://ffmpeg.org/">http://ffmpeg.org/</a>   下载源码自己编译（这个工作量比较大）。</p>
<p>打开命令行窗口，使用cd命令行进入到ffmpeg所在的目录，接下来就可以直接输入处理命令了。下面就来介绍各种各样的命令。下面命令行中的输入视频和输出视频的路径必须正确，如果路径不存在会出错的哦。</p>
<p>1、知道了视频流地址如何保存出本地文件：</p>
<p>ffmpeg -i rtmp://122.202.129.136:1935/live/ch4 -map 0 d:\work\yyy.mp4</p>
<p>2、知道了流地址，播放视频文件：</p>
<p>ffplay -rtsp_transport tcp rtsp://192.168.201.133:554/stream1.sdp</p>
<p>3、提取视频中的音频文件：</p>
<p>ffmpeg -i h:\work\yyy.avi -map 0:a d:\work\yyy.mp3</p>
<p>ffmpeg -i rtmp://122.202.129.136:1935/live/ch4 -map 0:a d:\work\yyy.mp3</p>
<p>4、提起多媒体中的视频（不要音频）</p>
<p>ffmpeg -i rtmp://122.202.129.136:1935/live/ch4 -map 0:v d:\work\yyy.mp4</p>
<p>5、把音频的左右声道分别保存为两个文件：</p>
<p>ffmpeg -i d:\work\yyy.mp3 -map_channel 0.0.0 d:\work\ch1.mp3 -map_channel 0.0.1 d:\work\ch2.mp3</p>
<p>6、把视频的音视频同时分为两个文件保存：</p>
<p>ffmpeg -i h:\work\video.mp4 -map 0:v  d:\work\video2.mp4 -map 0:a d:\work\video.mp3</p>
<p>7、把单纯的视频和单纯的音频合并为一个视频文件：</p>
<p>ffmpeg -i d:\work\out.mp4  -i d:\work\video.amr  -map 0:v  -map 1:a d:\work\strange.mp4</p>
<p>8、在视频的屏幕左上角加一个logo标志：</p>
<p>ffmpeg -i h:\work\video.mp4 -i h:\work\psu.png -filter_complex ‘overlay’ d:\work\video.mp4</p>
<p>9、输出视频的yuv数据：</p>
<p>ffmpeg -i d:\work\video.mp4 d:\work\hugefile.yuv</p>
<p>10、把视频的图像批量输出（(-r 1)一秒钟保存一张，缩放为640*480，名称为foo-001.jpeg, foo-002.jpeg……）：</p>
<p>ffmpeg -i h:\work\video.mp4 -r 1 -s 640x480 -f image2 d:\work\foo-%03d.jpeg</p>
<p>还可以添加更多参数</p>
<p>ffmpeg -i h:\work\video.mp4 -r 1 -ss 50 -vframes 3 -s 640x480 -f image2 d:\work\foo-%03d.jpeg</p>
<p>11、把一堆图像合成为一个视频：</p>
<p>ffmpeg -f image2 -framerate 25 -i d:\work\foo-%03d.jpeg   -s 1280x720  h:\work\foo.avi</p>
<p>12、转换视频的分辨率：</p>
<p>ffmpeg -i D:\work\hisense1.mp4 -vcodec libx264  -s 640x480  -acodec aac -strict experimental -ar 44100 -ac 2 -b:a 96k D:\work\outputfile.mp4</p>
<p>13、直接将视频变为原来大小的一半：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4  -vf scale=iw/2:ih/2 D:\work\yyy2642sm.mp4</p>
<p>14、裁剪视频中间的一段视频为一个单独视频：</p>
<p>ffmpeg -ss 00:00:30 -vsync 0 -t 00:00:30 -i D:\work\yyy2642.mp4 -vcodec libx264-acodec libfaac D:\work\outputfile.mp4</p>
<p>15、裁剪出视频屏幕正中间的一部分，宽度和高度都是原来视频的一半：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4 -vf crop=iw/2:ih/2 D:\work\yyy2642sm.mp4</p>
<p>16、裁剪出视频屏幕任意一部分（注意参数）：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4  -vf crop=iw/3:ih/3:100:100 D:\work\yyy2642sm.mp4</p>
<p>17、播放时自动检测视频周围的黑框（播放时，输出窗口可以看到检测出的crop），这个其实不是视频处理，只是播放效果：</p>
<p>ffplay D:\work\yyy2642.mp4 -vf cropdetect</p>
<p>18、在视频的四周增加一圈30个像素的粉红色边框：</p>
<p>ffmpeg -i D:\work\yyy2642sm.mp4 -vf pad=iw+60:ih+60:30:30:pink D:\work\pink.mp4</p>
<p>19、视频水平翻转：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4  -vf hflip D:\work\outputfile.mp4</p>
<p>20、视频上下翻转：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4  -vf vflip D:\work\outputfile.mp4</p>
<p>21、视频旋转：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4  -vf transpose=2 D:\work\outputfile.mp4</p>
<p>22、视频模糊处理（注意参数），可以让视频变模糊：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4  -vf  boxblur=1:10:4:10  D:\work\outputfile.mp4</p>
<p>23、视频锐化处理，一定程度可以让视频变清晰：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4  -vf unsharp=5:5:1.0:5:5:0.0 D:\work\outputfile.mp4</p>
<p>24、删除标志logo:</p>
<p>ffmpeg -i D:\work\outputfile.mp4 -vf delogo=10:10:256:256:0:0 D:\work\outputfile1.mp4</p>
<p>25、添加文字到视频上</p>
<p>ffmpeg  -i D:\work\yyy2642.mp4 -vf drawtext=&quot;fontfile=arial.ttf:text=’Happy Holidays’:x=(w-tw)/2:y=(h-th)/2:fontcolor=green:fontsize=60&quot; D:\work\outputfile.mp4</p>
<p>其中arial.ttf是从windows\fonts目录下拷贝过来的字体文件</p>
<p>26、添加上方的字符滚动显示（显示中文字符）：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4  -vf drawtext=&quot;fontfile=ARIALUNI.ttf:text=’程序明_Welcom’:x=w-mod(t*50,w):fontcolor=darkorange:fontsize=30&quot; D:\work\outputfile.mp4</p>
<p>添加的文字显示在下方：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4 -vf drawtext=&quot;fontfile=ARIALUNI.ttf:text=’程序明’:x=w-mod(t*50,w):y=h-th:fontcolor=darkorange:fontsize=30&quot;</p>
<p>27、视频右上角显示当前系统时间：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4  -vf drawtext=&quot;fontfile=arial.ttf:x=w-tw:fontcolor=white:fontsize=30:text=’%{localtime:%H\:%M\:%S}’&quot; D:\work\outputfile.mp4</p>
<p>28、视频播放时晃动：</p>
<p>ffplay  -i D:\work\yyy2642.mp4  -vf crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2+((in_h-out_h)/2)*sin(n/7)</p>
<p>29、播放时视频色彩不断变换：</p>
<p>ffplay -i D:\work\yyy2642.mp4 -vf hue=&quot;H=2<em>PI</em>t:s=sin(2<em>PI</em>t)+1&quot;</p>
<p>30、彩色视频转变为黑白视频：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4 -vf lutyuv=&quot;u=128:v=128&quot; D:\work\outputfile.mp4</p>
<p>31、视频转码为原来的播放速度的两倍：</p>
<p>ffmpeg -i D:\work\yyy2642.mp4 -vf setpts=PTS/2 -af atempo=2 D:\work\outputfile.mp4</p>
<p>32、视频转为gif（参数指定了位置）:</p>
<p>ffmpeg -i D:\work\yyy2642.mp4 -ss 50 -t 10 -pix_fmt rgb24  -s 640x480 D:\work\jidu.gif</p>
<p>33、从视频里面截取几张图到一张图里（大图是2行3列）：</p>
<p>ffmpeg  -i D:\work\yyy2642.mp4  -frames 1  -vf &quot;select=not(mod(n,300)),scale=320:240,tile=2x3&quot; D:\work\out.png</p>
<p>34、两个文件左右合并（无敌了）：</p>
<p>ffmpeg.exe -i &quot;D:\work\yyy264.mp4&quot; -vf &quot;[in] scale=iw/2:ih/2, pad=2*iw:ih [left]; movie=&#39;D:\work\yyy2642.mp4&#39;, scale=iw/2:ih/2 [right];[left][right] overlay=main_w/2:0 [out]&quot; -b:v 768k D:\work\output.mp4</p>
<p>35、两个文件上下合并（无敌了）：</p>
<p>ffmpeg.exe -i &quot;D:\work\yyy264.mp4&quot; -vf &quot;[in] scale=iw/2:ih/2, pad=iw:2*ih [top]; movie=&#39;D:\work\yyy2642.mp4&#39;, scale=iw/2:ih/2 [bottom];[top][bottom] overlay=0:main_h/2 [out]&quot; -b:v 768k D:\work\output.mp4</p>
<p>36、文件重叠合并，把第二个文件的视频缩小为四分之一后，放到第一个视频的宽高八分之一画面处（更无敌）：</p>
<p>ffmpeg.exe -i &quot;D:\work\yyy264.mp4&quot; -vf &quot;[in] scale=iw:ih, pad=iw:ih  [top]; movie=&#39;D:\work\yyy2642.mp4&#39;, scale=iw/4:ih/4 [bottom];[top][bottom] overlay=main_w/8:main_h/8 [out]&quot; -b:v 768k D:\work\output.mp4</p>
<p>37、普通的按顺序合并两个视频：</p>
<p>ffmpeg -i D:\work\yyy264.mp4 -qscale 0 D:\work\inputfile_01.mpg  </p>
<p>ffmpeg -i D:\work\yyy2642.mp4 -qscale 0  D:\work\inputfile_02.mpg</p>
<p>copy /b &quot;D:\work\inputfile_01.mpg&quot;+&quot;D:\work\inputfile_02.mpg&quot; &quot;D:\work\inputfile_all.mpg&quot;</p>
<p>ffmpeg -i D:\work\inputfile_all.mpg -qscale 0 D:\work\outputfile.mp4</p>
<p>38、音频的分割合并</p>
<p>把第一段音频分成两部分</p>
<p>ffmpeg.exe -ss 00:00:08.5 -vsync 0 -t 00:00:09 -i file1.mp3   file1end.mp3</p>
<p>ffmpeg.exe -ss 00:00:00 -vsync 0 -t 00:00:08 -i file1.mp3   file1New.mp3</p>
<p>把第一段音频的后半部分和第二段混音合并</p>
<p>ffmpeg -i file2.mp3 -i file1end.mp3   -filter_complex amix=inputs=2:duration=first:dropout_transition=0 file2forNew1.mp3</p>
<p>把第二段音频混音好的音频，分成前后两部分：</p>
<p>ffmpeg.exe -ss 00:00:00 -vsync 0 -t 00:00:04 -i file2forNew1.mp3   file2New.mp3</p>
<p>ffmpeg.exe -ss 00:00:04 -vsync 0 -t 00:00:05 -i file3.mp3   file2End.mp3</p>
<p>再把第二段的后半部分和第三段混音合并：</p>
<p>ffmpeg -i file3.mp3 -i file2End.mp3   -filter_complex amix=inputs=2:duration=first:dropout_transition=0 file3New.mp3</p>
<p>把新的三部分音频首尾连接连到一起：</p>
<p>ffmpeg -i file1New.mp3 -qscale 0 inputfile_01.mpg</p>
<p>ffmpeg -i file2New.mp3 -qscale 0  inputfile_02.mpg</p>
<p>copy /b &quot;inputfile_01.mpg&quot;+&quot;inputfile_02.mpg&quot; &quot;inputfile_all.mpg&quot;</p>
<p>ffmpeg -i file3New.mp3 -qscale 0  inputfile_05.mpg</p>
<p>copy /b &quot;inputfile_all.mpg&quot;+&quot;inputfile_05.mpg&quot; &quot;inputfile_al2.mpg&quot;</p>
<p>ffmpeg -i inputfile_al2.mpg -qscale 0 file5.mp4</p>
<p>ffmpeg -i file5.mp4 -map 0:a result.mp3</p>
<p>上面的所有命令都是笔者自己亲自测试使用的，其中有些命令行带有不少参数，参数需要根据实际情况修改，如果有命令不理解的欢迎提问。笔者尽量在百忙之中挤出时间答疑</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>FileProvider</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/FileProvider/</url>
    <content><![CDATA[<p>&lt;provider</p>
<p>           android:name=&quot;android.support.v4.content.FileProvider&quot;</p>
<p>           android:authorities=&quot;com.ckt.fileproviderservice&quot;</p>
<p>           android:exported=&quot;false&quot;</p>
<p>           android:grantUriPermissions=&quot;true&quot;&gt;</p>
<p>&lt;meta-data</p>
<p>               android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;</p>
<p>               android:resource=&quot;@xml/filepath&quot; /&gt;</p>
<p>&lt;/provider&gt;</p>
<p>android:name — 定义名子 </p>
<p>android:authorities –定义authority</p>
<p>android:exported=&quot;false&quot;  对其它应用不可用</p>
<p>android:grantUriPermissions=&quot;true&quot;  既然对其它应用不可用，只能授予content uri临时权限</p>
<p>&lt;meta-data&gt;中的 android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; （这个名子是固定的）</p>
<p>和 android:resource 指向一个xml文件，这个xml文件定义了要共享文件的路径</p>
<p>xml/filepath.xml</p>
<p>&lt;paths&gt;</p>
<p>&lt;files-path name=&quot;my_images&quot; path=&quot;image/&quot; /&gt; </p>
<p>&lt;external-path name=&quot;my_external&quot; /&gt; </p>
<p>&lt;cache-path name=&quot;my_cache&quot; /&gt;</p>
<p>    &lt;root-path path=&quot;device/f7s/data/&quot; name=&quot;mydata&quot; /&gt;</p>
<p>&lt;/paths&gt;</p>
<p>content://com.ckt.fileproviderservice/my_images/default_image.jpg</p>
<p>final Uri uri = FileProvider.getUriForFile(this, AUTHORITY, file);</p>
<p>final Intent intent = new Intent(Intent.ACTION_SEND);</p>
<p>       intent.setType(&quot;image/png&quot;);</p>
<p>       intent.putExtra(Intent.EXTRA_STREAM, uri);</p>
<p>       startActivity(intent);</p>
<p> &lt;provider</p>
<p>            android:name=&quot;android.support.v4.content.FileProvider&quot;</p>
<p>            android:authorities=&quot;com.fcar.fileprovider&quot;</p>
<p>            android:grantUriPermissions=&quot;true&quot;</p>
<p>            android:exported=&quot;false&quot;&gt;</p>
<p>            &lt;meta-data</p>
<p>                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;</p>
<p>                android:resource=&quot;@xml/filepaths&quot; /&gt;</p>
<p>        &lt;/provider&gt;</p>
<p>xml/filepaths.xml</p>
<p>&lt;paths&gt;</p>
<p>    &lt;root-path path=&quot;device/f7s/data/&quot; name=&quot;mydata&quot; /&gt;</p>
<p>    &lt;external-path path=&quot;data/&quot; name=&quot;myexdata&quot; /&gt;</p>
<p>&lt;/paths&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Framework</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Framework/</url>
    <content><![CDATA[<p>Activity Manager</p>
<p> 用来管理应用程序生命周期并提供常用的导航回退功能。</p>
<p>ActivityManager (Proxy模式)</p>
<p>    -&gt;ActivityManagerNative </p>
<p>            -&gt;ActivityManagerProxy</p>
<p>（Binder的transact机制）–&gt;ActivityManagerService </p>
<p>Window Manager</p>
<p>WindowManager</p>
<p>    –&gt;WindowManagerImpl</p>
<p>        –&gt;WindowManagerGlobal</p>
<p>            –&gt;IWindowSession</p>
<p>                –&gt;WindowManagerService</p>
<p>Package Manager</p>
<p> 提供对系统的安装包的访问。包括安装、卸载应用，查询permission相关信息，查询Application相关信息等。</p>
<p> 主要职责是管理应用程序包，通过它可以获取应用程序信息。</p>
<p>Content Providers</p>
<p>使得应用程序可以访问另一个应用程序的数据（如联系人数据库)， 或者共享它们自己的数据。</p>
<p>View System</p>
<p>可以用来构建应用程序， 它包括列表（Lists)，网格（Grids)，文本框（Text boxes)，按钮（Buttons)， 甚至可嵌入的web浏览器。</p>
<p>Notification Manager</p>
<p>使得应用程序可以在状态栏中显示自定义的提示信息。</p>
<p>Telephony Manager</p>
<p>主要提供了一系列用于访问与手机通讯相关的状态和信息的方法，查询电信网络状态信息，sim卡的信息等。</p>
<p>Resource Manager</p>
<p>提供非代码资源的访问，如本地字符串，图形，和布局文件（Layout files )。</p>
<p>Location Manager</p>
<p>提供设备的地址位置的获取方式。很显然，GPS导航肯定能用到位置服务。</p>
<p>XMPP</p>
<p>可扩展通讯和表示协议。前身为Jabber，提供即时通信服务。例如推送功能,Google Talk。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Gallery屏蔽camera按钮</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Gallery%E5%B1%8F%E8%94%BDcamera%E6%8C%89%E9%92%AE/</url>
    <content><![CDATA[<p>packages/apps/Gallery2/src/com/android/gallery3d/util/GalleryUtils.java</p>
<p>@@ -240,6 +240,7 @@ public class GalleryUtils {</p>
<p>     }</p>
<p>     public static boolean isCameraAvailable(Context context) {</p>
<ul>
<li>              return false;/*</li>
</ul>
<p>         if (sCameraAvailableInitialize</p>
<p>===============================================================================</p>
<p>diff –git a/packages/apps/Gallery2/AndroidManifest.xml b/packages/apps/Gallery2/AndroidManifest.xml</p>
<p>index c9c5ff6..e780485 100755</p>
<p>— a/packages/apps/Gallery2/AndroidManifest.xml</p>
<p>+++ b/packages/apps/Gallery2/AndroidManifest.xml</p>
<p>@@ -326,21 +326,12 @@</p>
<p>                         android:label=&quot;@string/camera_label&quot;</p>
<p>                         android:name=&quot;com.android.camera.CameraLauncher&quot;</p>
<p>                         android:targetActivity=&quot;com.android.camera.CameraActivity&quot; &gt;</p>
<ul>
<li><p>&lt;intent-filter&gt;</p>
</li>
<li><p>&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</p>
</li>
<li><p>&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</p>
</li>
<li><p>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</p>
</li>
<li><p>&lt;/intent-filter&gt;</p>
</li>
</ul>
<p>         &lt;/activity-alias&gt;</p>
<p>         &lt;activity-alias android:icon=&quot;@mipmap/ic_launcher_camera&quot;</p>
<p>                         android:label=&quot;@string/camera_label&quot;</p>
<p>                         android:name=&quot;com.android.camera.Camera&quot;</p>
<p>                         android:targetActivity=&quot;com.android.camera.CameraActivity&quot; &gt;</p>
<ul>
<li><p>&lt;intent-filter&gt;</p>
</li>
<li><p>&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</p>
</li>
<li><p>&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</p>
</li>
<li><p>&lt;/intent-filter&gt;</p>
</li>
</ul>
<p>         &lt;/activity-alias&gt;</p>
<p>         &lt;activity-alias android:icon=&quot;@mipmap/ic_launcher_video_camera&quot;</p>
<p>diff –git a/packages/apps/Gallery2/src/com/android/gallery3d/app/AlbumPage.java b/packages/apps/Gallery2/src/com/android/gallery3d/app/AlbumPage.java</p>
<p>index b1ce88a..8f145e6 100755</p>
<p>— a/packages/apps/Gallery2/src/com/android/gallery3d/app/AlbumPage.java</p>
<p>+++ b/packages/apps/Gallery2/src/com/android/gallery3d/app/AlbumPage.java</p>
<p>@@ -627,7 +627,7 @@ public class AlbumPage extends ActivityState implements GalleryActionBar.Cluster</p>
<p>                 return true;</p>
<p>             }</p>
<p>             case R.id.action_camera: {</p>
<ul>
<li>GalleryUtils.startCameraActivity(mActivity);</li>
</ul>
<ul>
<li>// GalleryUtils.startCameraActivity(mActivity);</li>
</ul>
<p>                 return true;</p>
<p>             }</p>
<p>             default:</p>
<p>diff –git a/packages/apps/Gallery2/src/com/android/gallery3d/app/AlbumSetPage.java b/packages/apps/Gallery2/src/com/android/gallery3d/app/AlbumSetPage.java</p>
<p>index a8a755f..4e8c1f6 100755</p>
<p>— a/packages/apps/Gallery2/src/com/android/gallery3d/app/AlbumSetPage.java</p>
<p>+++ b/packages/apps/Gallery2/src/com/android/gallery3d/app/AlbumSetPage.java</p>
<p>@@ -370,7 +370,7 @@ public class AlbumSetPage extends ActivityState implements</p>
<p>         mCameraButton.setOnClickListener(new OnClickListener() {</p>
<p>             @Override</p>
<p>             public void onClick(View arg0) {</p>
<ul>
<li>GalleryUtils.startCameraActivity(mActivity);</li>
</ul>
<ul>
<li>//GalleryUtils.startCameraActivity(mActivity);</li>
</ul>
<p>             }</p>
<p>         });</p>
<p>         RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(</p>
<p>@@ -604,7 +604,7 @@ public class AlbumSetPage extends ActivityState implements</p>
<p>                 }</p>
<p>                 return true;</p>
<p>             case R.id.action_camera: {</p>
<ul>
<li>GalleryUtils.startCameraActivity(activity);</li>
</ul>
<ul>
<li>//GalleryUtils.startCameraActivity(activity);</li>
</ul>
<p>                 return true;</p>
<p>             }</p>
<p>             case R.id.action_manage_offline: {</p>
<p>diff –git a/packages/apps/Gallery2/src/com/android/gallery3d/util/GalleryUtils.java b/packages/apps/Gallery2/src/com/android/gallery3d/util/GalleryUtils.java</p>
<p>index 547e2dd..87811f5 100644</p>
<p>— a/packages/apps/Gallery2/src/com/android/gallery3d/util/GalleryUtils.java</p>
<p>+++ b/packages/apps/Gallery2/src/com/android/gallery3d/util/GalleryUtils.java</p>
<p>@@ -240,6 +240,7 @@ public class GalleryUtils {</p>
<p>     }</p>
<p>     public static boolean isCameraAvailable(Context context) {</p>
<ul>
<li>return false;/*</li>
</ul>
<p>         if (sCameraAvailableInitialized) return sCameraAvailable;</p>
<p>         PackageManager pm = context.getPackageManager();</p>
<p>         ComponentName name = new ComponentName(context, CAMERA_LAUNCHER_NAME);</p>
<p>@@ -255,7 +256,7 @@ public class GalleryUtils {</p>
<p>         Intent intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA)</p>
<p>                 .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP</p>
<p>                         | Intent.FLAG_ACTIVITY_NEW_TASK);</p>
<ul>
<li>context.startActivity(intent);</li>
</ul>
<ul>
<li>context.startActivity(intent);*/</li>
</ul>
<p>     }</p>
<p>     public static void startGalleryActivity(Context context) {</p>
<p>(END)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>GMS　机型查询</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/GMS%E3%80%80%E6%9C%BA%E5%9E%8B%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p><a href="https://support.google.com/googleplay/answer/1727131?hl=zh-Hans">https://support.google.com/googleplay/answer/1727131?hl=zh-Hans</a></p>
<p>我们认证过GMS的机器：</p>
<p>Digi-In<br>Hipstreet HS-10DTB8           rk2928_4.1r3  </p>
<p>Anydata</p>
<p>ematic EGP010                   rk3066_4.1r3 ematic EGS102                   rk2928_4.1r3  </p>
<p> VENSTAR</p>
<p>VENSTAR2050                    rk3168_4.2.2r4  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>GitHubBitbucket 通过 SSH 密钥连接</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/GitHubBitbucket%20%E9%80%9A%E8%BF%87%20SSH%20%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p> &gt; ssh-keygen -t rsa -C &quot;<a href="mailto:&#x61;&#110;&#100;&#x72;&#x6f;&#x69;&#100;&#64;&#x65;&#x64;&#119;&#x61;&#114;&#x64;&#x2e;&#x6f;&#114;&#103;&#x2e;&#99;&#110;">&#x61;&#110;&#100;&#x72;&#x6f;&#x69;&#100;&#64;&#x65;&#x64;&#119;&#x61;&#114;&#x64;&#x2e;&#x6f;&#114;&#103;&#x2e;&#99;&#110;</a>&quot;</p>
<p>确认rsa存放路径–&gt;&gt; 设置密码 </p>
<p>&gt; cat ~/.ssh/id_rsa.pub </p>
<p>将pub内容SSH密钥复制，添加SSH-Key到 Github,Bitbucket上。</p>
<p>测试 </p>
<p>GitHub:</p>
<p>&gt; ssh -T <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#x6f;&#109;">&#103;&#105;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#x6f;&#109;</a></p>
<p>       Bitbucket:</p>
<p>       &gt; ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#98;&#x69;&#116;&#98;&#x75;&#x63;&#x6b;&#101;&#116;&#x2e;&#x6f;&#114;&#x67;">&#x67;&#x69;&#x74;&#x40;&#98;&#x69;&#116;&#98;&#x75;&#x63;&#x6b;&#101;&#116;&#x2e;&#x6f;&#114;&#x67;</a></p>
<ol start="4">
<li>clone</li>
</ol>
<p>git clone <a href="mailto:&#x67;&#x69;&#116;&#x40;&#x62;&#105;&#x74;&#x62;&#x75;&#99;&#x6b;&#x65;&#116;&#46;&#x6f;&#114;&#x67;">&#x67;&#x69;&#116;&#x40;&#x62;&#105;&#x74;&#x62;&#x75;&#99;&#x6b;&#x65;&#116;&#46;&#x6f;&#114;&#x67;</a>:magicedward/test.git</p>
<p>~/.gitconfig 加入以下可以保存密码</p>
<p>[credential]   </p>
<p>    helper = store</p>
<p>服务器代码比本地新时</p>
<p>1.使用强制push的方法：<br>$ git push -u origin master -f</p>
<p>2.新建name分支，git push -u origin [name]</p>
<p>添加远程版本</p>
<p>git remote add origin <a href="https://git.oschina.net/magicedward/ATools.git">https://git.oschina.net/magicedward/ATools.git</a></p>
<p>git pull origin master</p>
<p>git push</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Gitolite 构建 Git 服务器</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Gitolite%20%E6%9E%84%E5%BB%BA%20Git%20%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><a href="http://www.ossxp.com/doc/git/gitolite.html">http://www.ossxp.com/doc/git/gitolite.html</a></p>
<p><a href="http://git-scm.com/book/en/Git-on-the-Server-Gitolite">http://git-scm.com/book/en/Git-on-the-Server-Gitolite</a></p>
<p>b0b347abd366c2c7f20d042aca956b5ef36758ea</p>
<p>sudo useradd -m -s /bin/bash -U git</p>
<p>sudo passwd git</p>
<p>su - git</p>
<p>git clone <a href="https://github.com/sitaramc/gitolite.git">https://github.com/sitaramc/gitolite.git</a></p>
<p>sudo cp -rvf edward.gitolite.pub /home/git/</p>
<p>mkdir ~/bin</p>
<p>vi .bashrc</p>
<p>PATH=$PATH:~/bin</p>
<p>. .bashrc</p>
<p>gitolite/install -ln</p>
<p>gitolite setup -pk edward.gitolite.pub</p>
<p>Initialized empty Git repository in /home/git/repositories/gitolite-admin.git/</p>
<p>Initialized empty Git repository in /home/git/repositories/testing.git/</p>
<p>WARNING: /home/git/.ssh missing; creating a new one</p>
<p>WARNING: /home/git/.ssh/authorized_keys missing; creating a new one</p>
<p>测试</p>
<p>ssh -i edward.gitolite <a href="mailto:&#103;&#105;&#x74;&#64;&#49;&#x39;&#x32;&#x2e;&#x31;&#54;&#56;&#46;&#x31;&#46;&#53;">&#103;&#105;&#x74;&#64;&#49;&#x39;&#x32;&#x2e;&#x31;&#54;&#56;&#46;&#x31;&#46;&#53;</a></p>
<p>使用就的git库</p>
<p>1.git clone <a href="mailto:&#103;&#x69;&#x74;&#64;&#x31;&#x39;&#x32;&#x2e;&#x31;&#x36;&#x38;&#46;&#49;&#46;&#x32;">&#103;&#x69;&#x74;&#64;&#x31;&#x39;&#x32;&#x2e;&#x31;&#x36;&#x38;&#46;&#49;&#46;&#x32;</a>:gitolite-admin</p>
<p>2.使用原来的admin工程覆盖回来，cp -rvf ../../gitolite-admin_bak2/* . </p>
<p>3.提交到新的repositories</p>
<p>4.新的admin库，替换到原来的git中，cp -rvf ../repositories_bak/gitolite-admin.git/   /opt/disk2/git/</p>
<p>如果有这个问题，</p>
<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p>
<p>@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @</p>
<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p>
<p>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</p>
<p>Someone could be eavesdropping on you right now (man-in-the-middle attack)!</p>
<p>It is also possible that a host key has just been changed.</p>
<p>The fingerprint for the RSA key sent by the remote host is</p>
<p>27:b1:74:72:e9:aa:4c:a5:4f:63:b4:b4:d5:1d:23:84.</p>
<p>Please contact your system administrator.</p>
<p>Add correct host key in /home/edward/.ssh/known_hosts to get rid of this message.</p>
<p>Offending RSA key in /home/edward/.ssh/known_hosts:4</p>
<p>  remove with: ssh-keygen -f &quot;/home/edward/.ssh/known_hosts&quot; -R 192.168.1.5</p>
<p>RSA host key for 192.168.1.5 has changed and you have requested strict checking.</p>
<p>Host key verification failed.</p>
<p>则移动known_hosts</p>
<p>mv /home/edward/.ssh/known_hosts known_hosts_bak</p>
<p>设置别名</p>
<p>vi .ssh/config</p>
<p>host git</p>
<p>        user git</p>
<p>        hostname 192.168.1.5</p>
<p>        port 22</p>
<p>        identityfile ~/edward.gitolite</p>
<p>git clone git:gitolite-admin</p>
<p>$ ssh-keygen -f ~/.ssh/scott</p>
<p>$ git clone git://github.com/sitaramc/gitolite </p>
<p>$ gitolite/install -ln # assumes $HOME/bin exists and is in your $PATH </p>
<p>$ gitolite setup -pk $HOME/scott.pub</p>
<p>$ git clone git@gitserver:gitolite-admin</p>
<p>Config File and Access Control Rules</p>
<p>$ cd ~/gitolite-admin/ </p>
<p>$ ls conf/ keydir/ </p>
<p>$ find conf keydir -type f </p>
<p>conf/gitolite.conf keydir/scott.pub </p>
<p>$ cat conf/gitolite.conf </p>
<p> repo gitolite-admin </p>
<p> RW+ = scott repo </p>
<p> testing RW+ = @all</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Git版本控制日常使用规范</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>The most commonly used git commands are:</p>
<p>add        Add file contents to the index</p>
<p>   bisect     Find by binary search the change that introduced a bug</p>
<p>branch     List, create, or delete branches</p>
<p>checkout   Checkout a branch or paths to the working tree</p>
<p>   clone      Clone a repository into a new directory</p>
<p>commit     Record changes to the repository</p>
<p>   diff       Show changes between commits, commit and working tree, etc</p>
<p>   fetch      Download objects and refs from another repository</p>
<p>   grep       Print lines matching a pattern</p>
<p>init       Create an empty git repository or reinitialize an existing one</p>
<p>   log        Show commit logs</p>
<p>   merge      Join two or more development histories together</p>
<p>   mv         Move or rename a file, a directory, or a symlink</p>
<p>   pull       Fetch from and merge with another repository or a local branch</p>
<p>   push       Update remote refs along with associated objects</p>
<p>   rebase     Forward-port local commits to the updated upstream head</p>
<p>   reset      Reset current HEAD to the specified state</p>
<p>   rm         Remove files from the working tree and from the index</p>
<p>   show       Show various types of objects</p>
<p>   status     Show the working tree status</p>
<p>   tag        Create, list, delete or verify a tag object signed with GPG</p>
<p>git init  //初始化空的.git工程</p>
<p>//用户基本信息的配置</p>
<p>edward@bx-System:~/android4.0.4$ git config –global user.name edward</p>
<p>edward@bx-System:~/android4.0.4$ git config –global user.email &quot;<a href="mailto:&#x6d;&#x61;&#x67;&#105;&#x63;&#x65;&#100;&#x77;&#x61;&#x72;&#100;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;">&#x6d;&#x61;&#x67;&#105;&#x63;&#x65;&#100;&#x77;&#x61;&#x72;&#100;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;</a>&quot;</p>
<p>edward@bx-System:~/android4.0.4$ git config –global color.ui &quot;always&quot;</p>
<p>edward@bx-System:~/android4.0.4$ git config –global –list</p>
<p>user.name=edward</p>
<p>user.email=magicedward@qq.com</p>
<p>color.ui=always</p>
<p>git config –global core.quotepath false //解决中文文件名显示问题</p>
<p>git config –global i18n.logOutputEncoding gbk</p>
<p>git config –global i18n.commitEncoding  gbk </p>
<p>git add frameworks packages  //添加目录(文件)到工程</p>
<p>git commit -am &quot;init the project&quot;  //提交修改，初始化工程 -a all   -m comment</p>
<p>git commit -C HEAD -a –amend //复用HEAD留言，增补提交</p>
<p>git branch  //查看分支  </p>
<p>git branch ver //创建ver分支</p>
<p>git branch -d ver //删除ver分支 -D(未合并的也删除)</p>
<p>git branch -m &lt;old_branch&gt; &lt;new_branch&gt;   //重命名</p>
<p>git checkout ver  //切换到ver版本  -f   -p</p>
<p>git checkout frameworks  //撤消对frameworks的修改</p>
<p>git status  //查看当前版本的修改的状态</p>
<p>git log  ver //查看ver版本的提交记录 -n(n次commit)</p>
<p>git show commitid //查看某次提交的详细内容</p>
<p>git log –p -2 //-p显示每次提交的内容差异 -2表示最近2次更改</p>
<p>git rebase master //重新定义起点，使分支接受master的更新</p>
<p>git rebase -i origin/master // ‘-i’或’–interactive’ 交互式</p>
<p>git rebase –continue //解除rebase冲突 继续rebase</p>
<p>git rebase –abort  //中止退回rebase前状态</p>
<p>git merge branch  //合并branch到当前分支</p>
<p>git branch –merged //查看被合并到当前分支的分支</p>
<p>git diff master v2 &gt; test.patch //生成patch</p>
<p>git apply test.patch  //打补丁 –check(检查）</p>
<p>撤消提交 </p>
<p>    git reset –hard &lt;commit_id&gt;</p>
<p>    git push origin HEAD –force</p>
<p>根据–soft –mixed –hard，会对working tree和index和HEAD进行重置:</p>
<p>    git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息</p>
<p>    git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可</p>
<p>    git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容</p>
<p>    HEAD 最近一个提交</p>
<p>    HEAD^ 上一次</p>
<p>删除多余文件或目录</p>
<p>git clean -nd  //测试</p>
<p>git clean -fd   //删除</p>
<p>git stash list</p>
<p>git stash pop  //恢复后删除</p>
<p>git stash apply [–index] [&lt;stash&gt;]  //不删除</p>
<p>git stash apply stash@{0}</p>
<p>git stash drop  //删除工作进度</p>
<p>git stash [save [–patch] [-k | – [no-] keep-index] [-q| –quiet] [&lt;message&gt;]</p>
<p>–patch  显示工作区和HEAD的差异</p>
<p>-k 或 –keep-index  不会重置暂存区</p>
<p>git stash save &quot;message …&quot;</p>
<p>git config core.filemode false  忽略权限检查</p>
<p>GIT 自动补全</p>
<p>1.curl -OL  <a href="https://github.com/git/git/raw/master/contrib/completion/git-completion.bash">https://github.com/git/git/raw/master/contrib/completion/git-completion.bash</a>  //从github下载bash文件    <br>2.将此文件复制到你自己的用户主目录中,按照下面的示例,还应改名加上点: cp git-completion.bash ∼/.git-completion.bash<br>3.并把&quot;source ~/.git-completion.bash &quot; 添加到你的 .bashrc 文件中 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Google search voice 图标</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Google%20search%20voice%20%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<p> AndroidManifest.xml</p>
<p>&lt;meta-data android:name=&quot;com.android.launcher.toolbar_icon&quot; android:resource=&quot;@drawable/ic_google_logo_homescreen_default_ics&quot; /&gt;</p>
<p>&lt;meta-data android:name=&quot;com.android.launcher.toolbar_search_icon&quot; android:resource=&quot;@drawable/ic_google_logo_homescreen_default&quot; /&gt;</p>
<p>从meta-data 传到lancher2</p>
<p>Velvet .apk  </p>
<p>“g”图标     </p>
<p>ic_google_g_medium_light.png</p>
<p>// lancher2 使用 本地图标</p>
<p>/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>@@ -3097,14 +3097,14 @@ public final class Launcher extends Activity</p>
<p>         if (button != null) {</p>
<p>             // If we were unable to find the icon via the meta-data, use a</p>
<p>             // generic one</p>
<ul>
<li>           if (toolbarIcon == null) {</li>
</ul>
<ul>
<li>           //if (toolbarIcon == null) {</li>
</ul>
<p>                 button.setImageResource(fallbackDrawableId);</p>
<ul>
<li><p>           } else {</p>
</li>
<li><p>               button.setImageDrawable(toolbarIcon);</p>
</li>
<li><p>           }</p>
</li>
</ul>
<ul>
<li><p>          // } else {</p>
</li>
<li><p>            //   button.setImageDrawable(toolbarIcon);</p>
</li>
<li><p>          // }</p>
</li>
</ul>
<p>         }</p>
<p>-</p>
<ul>
<li>       return toolbarIcon != null ? toolbarIcon.getConstantState() : null;</li>
</ul>
<ul>
<li><p>              return null;</p>
</li>
<li><p>       //return toolbarIcon != null ? toolbarIcon.getConstantState() : null;</p>
</li>
</ul>
<p>     }</p>
<h1 id="modified-packages-apps-Launcher2-res-drawable-land-mdpi-ic-home-voice-search-holo-png"><a href="#modified-packages-apps-Launcher2-res-drawable-land-mdpi-ic-home-voice-search-holo-png" class="headerlink" title="modified:   packages/apps/Launcher2/res/drawable-land-mdpi/ic_home_voice_search_holo.png"></a>modified:   packages/apps/Launcher2/res/drawable-land-mdpi/ic_home_voice_search_holo.png</h1><h1 id="modified-packages-apps-Launcher2-res-drawable-mdpi-ic-allapps-png"><a href="#modified-packages-apps-Launcher2-res-drawable-mdpi-ic-allapps-png" class="headerlink" title="modified:   packages/apps/Launcher2/res/drawable-mdpi/ic_allapps.png"></a>modified:   packages/apps/Launcher2/res/drawable-mdpi/ic_allapps.png</h1><h1 id="modified-packages-apps-Launcher2-res-drawable-mdpi-ic-home-search-normal-holo-png"><a href="#modified-packages-apps-Launcher2-res-drawable-mdpi-ic-home-search-normal-holo-png" class="headerlink" title="modified:   packages/apps/Launcher2/res/drawable-mdpi/ic_home_search_normal_holo.png"></a>modified:   packages/apps/Launcher2/res/drawable-mdpi/ic_home_search_normal_holo.png</h1><h1 id="modified-packages-apps-Launcher2-res-drawable-mdpi-ic-home-voice-search-holo-png"><a href="#modified-packages-apps-Launcher2-res-drawable-mdpi-ic-home-voice-search-holo-png" class="headerlink" title="modified:   packages/apps/Launcher2/res/drawable-mdpi/ic_home_voice_search_holo.png"></a>modified:   packages/apps/Launcher2/res/drawable-mdpi/ic_home_voice_search_holo.png</h1><h1 id="modified-packages-apps-Launcher2-src-com-android-launcher2-Launcher-java"><a href="#modified-packages-apps-Launcher2-src-com-android-launcher2-Launcher-java" class="headerlink" title="modified:   packages/apps/Launcher2/src/com/android/launcher2/Launcher.java"></a>modified:   packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</h1>]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>GooglePlay手动安装更新出错问题</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/GooglePlay%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0%E5%87%BA%E9%94%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>— a/services/java/com/android/server/pm/PackageManagerService.java</p>
<p>+++ b/services/java/com/android/server/pm/PackageManagerService.java</p>
<p>@@ -1965,6 +1965,9 @@ public class PackageManagerService extends IPackageManager.Stub {</p>
<p>             Object obj = mSettings.getUserIdLPr(UserId.getAppId(uid));</p>
<p>             if (obj != null) {</p>
<p>                 GrantedPermissions gp = (GrantedPermissions)obj;</p>
<ul>
<li><p>               if (gp instanceof PackageSetting &amp;&amp; ((PackageSetting)gp).name.equals(&quot;com.android.vending&quot;)) {</p>
</li>
<li><p>                   return PackageManager.PERMISSION_GRANTED;</p>
</li>
<li><p>               }</p>
</li>
</ul>
<p>                 if (gp.grantedPermissions.contains(permName)) {</p>
<p>                     return PackageManager.PERMISSION_GRANTED;</p>
<p>                 }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>HOME桌面菜单MENU</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/HOME%E6%A1%8C%E9%9D%A2%E8%8F%9C%E5%8D%95MENU/</url>
    <content><![CDATA[<p>frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java</p>
<p>private void openPanel(PanelFeatureState st, KeyEvent event) {</p>
<p>        // System.out.println(&quot;Open panel: isOpen=&quot; + st.isOpen);</p>
<p>        // Already open, return</p>
<p>        if (st.isOpen || isDestroyed()) {</p>
<p>            return;</p>
<p>        }</p>
<p>        // Don’t open an options panel for honeycomb apps on xlarge devices.</p>
<p>        // (The app should be using an action bar for menu items.)</p>
<p>        if (st.featureId == FEATURE_OPTIONS_PANEL) {</p>
<p>            Context context = getContext();</p>
<p>            Configuration config = context.getResources().getConfiguration();</p>
<p>boolean isXLarge = (config.screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) ==</p>
<p>                    Configuration.SCREENLAYOUT_SIZE_XLARGE;</p>
<p>            boolean isHoneycombApp = context.getApplicationInfo().targetSdkVersion &gt;=</p>
<p>                    android.os.Build.VERSION_CODES.HONEYCOMB;</p>
<p>            if (isXLarge &amp;&amp; isHoneycombApp) {</p>
<p>                //return;</p>
<p>            }</p>
<p>        }</p>
<p>        Callback cb = getCallback();</p>
<p>        if ((cb != null) &amp;&amp; (!cb.onMenuOpened(st.featureId, st.menu))) {</p>
<p>            // Callback doesn’t want the menu to open, reset any state</p>
<p>            closePanel(st, true);</p>
<p>            return;</p>
<p>        }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>HTML特殊转义字符列表</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/HTML%E7%89%B9%E6%AE%8A%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>HTML特殊转义字符列表</p>
<p>最常用的字符实体<br>Character Entities </p>
<p>显示  说明  实体名称  实体编号 </p>
<p>半方大的空白  &amp;ensp;  &amp;#8194; </p>
<p>全方大的空白  &amp;emsp;  &amp;#8195; </p>
<p>不断行的空白格  &amp;nbsp;  &amp;#160; </p>
<p>&lt;  小于  &amp;lt;  &amp;#60; </p>
<p>&gt;  大于  &amp;gt;  &amp;#62; </p>
<p>&amp;  &amp;符号  &amp;amp;  &amp;#38; </p>
<p>&quot;  双引号  &amp;quot;  &amp;#34; </p>
<p>©  版权  &amp;copy;  &amp;#169; </p>
<p>®  已注册商标  &amp;reg;  &amp;#174; </p>
<p>™  商标（美国）  ™  &amp;#8482; </p>
<p>×  乘号  &amp;times;  &amp;#215; </p>
<p>÷  除号  &amp;divide;  &amp;#247; </p>
<p>ISO 8859-1 (Latin-1)字符集</p>
<p>HTML 4.01 支持 ISO 8859-1 (Latin-1) 字符集。</p>
<p>备注：为了方便起见，以下表格中，“实体名称”简称为“名称”，“实体编号”简称为“编号”</p>
<p>显示  名称  编号  显示  名称  编号  显示  名称  编号  显示  名称  编号  显示  名称  编号 </p>
<p>&amp;nbsp;  &amp;#160;  ¡  &amp;iexcl;  &amp;#161;  ¢  &amp;cent;  &amp;#162;  £  &amp;pound;  &amp;#163;  ¤  &amp;curren;  &amp;#164; </p>
<p>¥  &amp;yen;  &amp;#165;  ¦  &amp;brvbar;  &amp;#166;  §  &amp;sect;  &amp;#167;  ¨  &amp;uml;  &amp;#168;  ©  &amp;copy;  &amp;#169; </p>
<p>ª  &amp;ordf;  &amp;#170;  «  &amp;laquo;  &amp;#171;  ¬  &amp;not;  &amp;#172;    &amp;shy;  &amp;#173;  ®  &amp;reg;  &amp;#174; </p>
<p>¯  &amp;macr;  &amp;#175;  °  &amp;deg;  &amp;#176;  ±  &amp;plusmn;  &amp;#177;  ²  &amp;sup2;  &amp;#178;  ³  &amp;sup3;  &amp;#179; </p>
<p>´  &amp;acute;  &amp;#180;  µ  &amp;micro;  &amp;#181;  ¶  &amp;para;  &amp;#182;  ·  &amp;middot;  &amp;#183;  ¸  &amp;cedil;  &amp;#184; </p>
<p>¹  &amp;sup1;  &amp;#185;  º  &amp;ordm;  &amp;#186;  »  &amp;raquo;  &amp;#187;  ¼  &amp;frac14;  &amp;#188;  ½  &amp;frac12;  &amp;#189; </p>
<p>¾  &amp;frac34;  &amp;#190;  ¿  &amp;iquest;  &amp;#191;  À  &amp;Agrave;  &amp;#192;  Á  &amp;Aacute;  &amp;#193;  Â  &amp;Acirc;  &amp;#194; </p>
<p>Ã  &amp;Atilde;  &amp;#195;  Ä  &amp;Auml;  &amp;#196;  Å  &amp;Aring;  &amp;#197;  Æ  &amp;AElig;  &amp;#198;  Ç  &amp;Ccedil;  &amp;#199; </p>
<p>È  &amp;Egrave;  &amp;#200;  É  &amp;Eacute;  &amp;#201;  Ê  &amp;Ecirc;  &amp;#202;  Ë  &amp;Euml;  &amp;#203;  Ì  &amp;Igrave;  &amp;#204; </p>
<p>Í  &amp;Iacute;  &amp;#205;  Î  &amp;Icirc;  &amp;#206;  Ï  &amp;Iuml;  &amp;#207;  Ð  &amp;ETH;  &amp;#208;  Ñ  &amp;Ntilde;  &amp;#209; </p>
<p>Ò  &amp;Ograve;  &amp;#210;  Ó  &amp;Oacute;  &amp;#211;  Ô  &amp;Ocirc;  &amp;#212;  Õ  &amp;Otilde;  &amp;#213;  Ö  &amp;Ouml;  &amp;#214; </p>
<p>×  &amp;times;  &amp;#215;  Ø  &amp;Oslash;  &amp;#216;  Ù  &amp;Ugrave;  &amp;#217;  Ú  &amp;Uacute;  &amp;#218;  Û  &amp;Ucirc;  &amp;#219; </p>
<p>Ü  &amp;Uuml;  &amp;#220;  Ý  &amp;Yacute;  &amp;#221;  Þ  &amp;THORN;  &amp;#222;  ß  &amp;szlig;  &amp;#223;  à  &amp;agrave;  &amp;#224; </p>
<p>á  &amp;aacute;  &amp;#225;  â  &amp;acirc;  &amp;#226;  ã  &amp;atilde;  &amp;#227;  ä  &amp;auml;  &amp;#228;  å  &amp;aring;  &amp;#229; </p>
<p>æ  &amp;aelig;  &amp;#230;  ç  &amp;ccedil;  &amp;#231;  è  &amp;egrave;  &amp;#232;  é  &amp;eacute;  &amp;#233;  ê  &amp;ecirc;  &amp;#234; </p>
<p>ë  &amp;euml;  &amp;#235;  ì  &amp;igrave;  &amp;#236;  í  &amp;iacute;  &amp;#237;  î  &amp;icirc;  &amp;#238;  ï  &amp;iuml;  &amp;#239; </p>
<p>ð  &amp;eth;  &amp;#240;  ñ  &amp;ntilde;  &amp;#241;  ò  &amp;ograve;  &amp;#242;  ó  &amp;oacute;  &amp;#243;  ô  &amp;ocirc;  &amp;#244; </p>
<p>õ  &amp;otilde;  &amp;#245;  ö  &amp;ouml;  &amp;#246;  ÷  &amp;divide;  &amp;#247;  ø  &amp;oslash;  &amp;#248;  ù  &amp;ugrave;  &amp;#249; </p>
<p>ú  &amp;uacute;  &amp;#250;  û  &amp;ucirc;  &amp;#251;  ü  &amp;uuml;  &amp;#252;  ý  &amp;yacute;  &amp;#253;  þ  &amp;thorn;  &amp;#254; </p>
<p>ÿ  &amp;yuml;  &amp;#255; </p>
<p>数学和希腊字母标志<br>symbols, mathematical symbols, and Greek letters   </p>
<p>显示  名称  编号  显示  名称  编号  显示  名称  编号  显示  名称  编号  显示  名称  编号 </p>
<p>ƒ  &amp;fnof;  &amp;#402;  Α  &amp;Alpha;  &amp;#913;  Β  &amp;Beta;  &amp;#914;  Γ  &amp;Gamma;  &amp;#915;  Δ  &amp;Delta;  &amp;#916; </p>
<p>Ε  &amp;Epsilon;  &amp;#917;  Ζ  &amp;Zeta;  &amp;#918;  Η  &amp;Eta;  &amp;#919;  Θ  &amp;Theta;  &amp;#920;  Ι  &amp;Iota;  &amp;#921; </p>
<p>Κ  &amp;Kappa;  &amp;#922;  Λ  &amp;Lambda;  &amp;#923;  Μ  &amp;Mu;  &amp;#924;  Ν  &amp;Nu;  &amp;#925;  Ξ  &amp;Xi;  &amp;#926; </p>
<p>Ο  &amp;Omicron;  &amp;#927;  Π  &amp;Pi;  &amp;#928;  Ρ  &amp;Rho;  &amp;#929;  Σ  &amp;Sigma;  &amp;#931;  Τ  &amp;Tau;  &amp;#932; </p>
<p>Υ  &amp;Upsilon;  &amp;#933;  Φ  &amp;Phi;  &amp;#934;  Χ  &amp;Chi;  &amp;#935;  Ψ  &amp;Psi;  &amp;#936;  Ω  &amp;Omega;  &amp;#937; </p>
<p>α  &amp;alpha;  &amp;#945;  β  &amp;beta;  &amp;#946;  γ  &amp;gamma;  &amp;#947;  δ  &amp;delta;  &amp;#948;  ε  &amp;epsilon;  &amp;#949; </p>
<p>ζ  &amp;zeta;  &amp;#950;  η  &amp;eta;  &amp;#951;  θ  &amp;theta;  &amp;#952;  ι  &amp;iota;  &amp;#953;  κ  &amp;kappa;  &amp;#954; </p>
<p>λ  &amp;lambda;  &amp;#955;  μ  &amp;mu;  &amp;#956;  ν  &amp;nu;  &amp;#957;  ξ  &amp;xi;  &amp;#958;  ο  &amp;omicron;  &amp;#959; </p>
<p>π  &amp;pi;  &amp;#960;  ρ  &amp;rho;  &amp;#961;  ς  &amp;sigmaf;  &amp;#962;  σ  &amp;sigma;  &amp;#963;  τ  &amp;tau;  &amp;#964; </p>
<p>υ  &amp;upsilon;  &amp;#965;  φ  &amp;phi;  &amp;#966;  χ  &amp;chi;  &amp;#967;  ψ  &amp;psi;  &amp;#968;  ω  &amp;omega;  &amp;#969; </p>
<p>?  &amp;thetasym;  &amp;#977;  ?  &amp;upsih;  &amp;#978;  ?  &amp;piv;  &amp;#982;  •  &amp;bull;  &amp;#8226;  …  &amp;hellip;  &amp;#8230; </p>
<p>′  &amp;prime;  &amp;#8242;  ″  &amp;Prime;  &amp;#8243;  ‾  &amp;oline;  &amp;#8254;  ⁄  &amp;frasl;  &amp;#8260;  ℘  &amp;weierp;  &amp;#8472; </p>
<p>ℑ  &amp;image;  &amp;#8465;  ℜ  &amp;real;  &amp;#8476;  ™  &amp;trade;  &amp;#8482;  ℵ  &amp;alefsym;  &amp;#8501;  ←  &amp;larr;  &amp;#8592; </p>
<p>↑  &amp;uarr;  &amp;#8593;  →  &amp;rarr;  &amp;#8594;  ↓  &amp;darr;  &amp;#8595;  ↔  &amp;harr;  &amp;#8596;  ↵  &amp;crarr;  &amp;#8629; </p>
<p>⇐  &amp;lArr;  &amp;#8656;  ⇑  &amp;uArr;  &amp;#8657;  ⇒  &amp;rArr;  &amp;#8658;  ⇓  &amp;dArr;  &amp;#8659;  ⇔  &amp;hArr;  &amp;#8660; </p>
<p>∀  &amp;forall;  &amp;#8704;  ∂  &amp;part;  &amp;#8706;  ∃  &amp;exist;  &amp;#8707;  ∅  &amp;empty;  &amp;#8709;  ∇  &amp;nabla;  &amp;#8711; </p>
<p>∈  &amp;isin;  &amp;#8712;  ∉  &amp;notin;  &amp;#8713;  ∋  &amp;ni;  &amp;#8715;  ∏  &amp;prod;  &amp;#8719;  ∑  &amp;sum;  &amp;#8721; </p>
<p>−  &amp;minus;  &amp;#8722;  ∗  &amp;lowast;  &amp;#8727;  √  &amp;radic;  &amp;#8730;  ∝  &amp;prop;  &amp;#8733;  ∞  &amp;infin;  &amp;#8734; </p>
<p>∠  &amp;ang;  &amp;#8736;  ∧  &amp;and;  &amp;#8743;  ∨  &amp;or;  &amp;#8744;  ∩  &amp;cap;  &amp;#8745;  ∪  &amp;cup;  &amp;#8746; </p>
<p>∫  &amp;int;  &amp;#8747;  ∴  &amp;there4;  &amp;#8756;  ∼  &amp;sim;  &amp;#8764;  ∝  &amp;cong;  &amp;#8773;  ≈  &amp;asymp;  &amp;#8776; </p>
<p>≠  &amp;ne;  &amp;#8800;  ≡  &amp;equiv;  &amp;#8801;  ≤  &amp;le;  &amp;#8804;  ≥  &amp;ge;  &amp;#8805;  ⊂  &amp;sub;  &amp;#8834; </p>
<p>⊃  &amp;sup;  &amp;#8835;  ⊄  &amp;nsub;  &amp;#8836;  ⊆  &amp;sube;  &amp;#8838;  ⊇  &amp;supe;  &amp;#8839;  ⊕  &amp;oplus;  &amp;#8853; </p>
<p>⊗  &amp;otimes;  &amp;#8855;  ⊥  &amp;perp;  &amp;#8869;  ⋅  &amp;sdot;  &amp;#8901;  ?  &amp;lceil;  &amp;#8968;  ?  &amp;rceil;  &amp;#8969; </p>
<p>?  &amp;lfloor;  &amp;#8970;  ?  &amp;rfloor;  &amp;#8971;  ?  &amp;lang;  &amp;#9001;  ?  &amp;rang;  &amp;#9002;  ◊  &amp;loz;  &amp;#9674; </p>
<p>♠  &amp;spades; </p>
<p>重要的国际标记<br>markup-significant and internationalization characters   </p>
<p>显示  名称  编号  显示  名称  编号  显示  名称  编号  显示  名称  编号  显示  名称  编号 </p>
<p>&quot;  &amp;quot;  &amp;#34;  &amp;  &amp;amp;  &amp;#38;  &lt;  &amp;lt;  &amp;#60;  &gt;  &amp;gt;  &amp;#62;  Œ  &amp;OElig;  &amp;#338; </p>
<p>œ  &amp;oelig;  &amp;#339;  Š  &amp;Scaron;  &amp;#352;  š  &amp;scaron;  &amp;#353;  Ÿ  &amp;Yuml;  &amp;#376;  ˆ  &amp;circ;  &amp;#710; </p>
<p>˜  &amp;tilde;  &amp;#732;     &amp;ensp;  &amp;#8194;     &amp;emsp;  &amp;#8195;     &amp;thinsp;  &amp;#8201;  ‌  &amp;zwnj;  &amp;#8204; </p>
<p>‍  &amp;zwj;  &amp;#8205;  ‎  &amp;lrm;  &amp;#8206;  ‏  &amp;rlm;  &amp;#8207;  –  &amp;ndash;  &amp;#8211;  —  &amp;mdash;  &amp;#8212; </p>
<p>‘  &amp;lsquo;  &amp;#8216;  ’  &amp;rsquo;  &amp;#8217;  ‚  &amp;sbquo;  &amp;#8218;  “  &amp;ldquo;  &amp;#8220;  ”  &amp;rdquo;  &amp;#8221; </p>
<p>„  &amp;bdquo;  &amp;#8222;  †  &amp;dagger;  &amp;#8224;  ‡  &amp;Dagger;  &amp;#8225;  ‰  &amp;permil;  &amp;#8240;  ‹  &amp;lsaquo;  &amp;#8249; </p>
<p>›  &amp;rsaquo;  &amp;#8250;  €  &amp;euro;  &amp;#8364 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>HeadsetController</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/HeadsetController.java/</url>
    <content><![CDATA[<p>package com.android.systemui.statusbar.policy;</p>
<p>import java.util.ArrayList;</p>
<p>import com.android.systemui.R;</p>
<p>import android.bluetooth.BluetoothAdapter;</p>
<p>import android.content.BroadcastReceiver;</p>
<p>import android.content.Context;</p>
<p>import android.content.Intent;</p>
<p>import android.content.IntentFilter;</p>
<p>import android.view.View;</p>
<p>import android.widget.ImageView;</p>
<p>public class HeadsetController extends BroadcastReceiver {</p>
<p>    private static final String TAG = &quot;StatusBar.HeadsetController&quot;;</p>
<p>    private Context mContext;</p>
<p>    private ArrayList&lt;ImageView&gt; mIconViews = new ArrayList&lt;ImageView&gt;();</p>
<p>    private int mIconId = com.android.internal.R.drawable.stat_sys_headset;</p>
<p>    private int mContentDescriptionId = 0;</p>
<p>    private boolean mEnabled = false;</p>
<p>    public HeadsetController(Context context) {</p>
<p>        mContext = context;</p>
<p>        IntentFilter filter = new IntentFilter();</p>
<p>        //注释本句即可关闭此模块的功能</p>
<p>        filter.addAction(Intent.ACTION_HEADSET_PLUG);</p>
<p>        context.registerReceiver(this, filter);</p>
<p>        refreshViews();</p>
<p>    }</p>
<p>    public void addIconView(ImageView v) {</p>
<p>        mIconViews.add(v);</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void onReceive(Context context, Intent intent) {</p>
<p>        final String action = intent.getAction();</p>
<p>        if (action.equals(Intent.ACTION_HEADSET_PLUG)) {</p>
<p>mEnabled = (intent.getIntExtra(&quot;state&quot;, 0) == 1)?true:false;</p>
<p>        }</p>
<p>        refreshViews();</p>
<p>    }</p>
<p>    public void refreshViews() {</p>
<p>        int N = mIconViews.size();</p>
<p>        for (int i=0; i&lt;N; i++) {</p>
<p>            ImageView v = mIconViews.get(i);</p>
<p>            v.setImageResource(mIconId);</p>
<p>            v.setVisibility(mEnabled ? View.VISIBLE : View.GONE);</p>
<p>            v.setContentDescription((mContentDescriptionId == 0)</p>
<p>                    ? null</p>
<p>                    : mContext.getString(mContentDescriptionId));</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Hexo/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/tonydandelion2014/article/details/61615898">https://blog.csdn.net/tonydandelion2014/article/details/61615898</a></p>
<p><a href="https://www.jianshu.com/p/6991e8e7f01b">https://www.jianshu.com/p/6991e8e7f01b</a> 七牛</p>
<p>$ npm install -g hexo-cli</p>
<p>$ hexo init &lt;folder&gt;<br>$ cd &lt;folder&gt;<br>$ npm install</p>
<p>因为防火墙的缘故，很多境外网站被墙了，所以使用node.js的原生工具npm是无法正常安装模块的，建议使用淘宝前端组的国内镜像，使用他们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<p>$ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> </p>
<p>七牛插件</p>
<p>sudo cnpm install hexo-qiniu-sync –save</p>
<p>可视化编辑</p>
<p><a href="https://github.com/jaredly/hexo-admin">https://github.com/jaredly/hexo-admin</a></p>
<p>sudo npm install –save hexo-admin</p>
<p>RSS</p>
<p><a href="https://github.com/hexojs/hexo-generator-feed">https://github.com/hexojs/hexo-generator-feed</a></p>
<p>npm install hexo-generator-feed –save</p>
<p>Search</p>
<p><a href="https://github.com/wzpan/hexo-generator-search">https://github.com/wzpan/hexo-generator-search</a></p>
<p>npm install hexo-generator-searchdb –save</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>HttpURLConnection post</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/HttpURLConnection%20post/</url>
    <content><![CDATA[<p>/**</p>
<ul>
<li>POST请求操作</li>
</ul>
<p>* </p>
<ul>
<li><p>@param userName</p>
</li>
<li><p>@param userPass</p>
</li>
</ul>
<p>*/</p>
<p>public void loginByPost(String userName, String userPass) {</p>
<p>try {</p>
<p>// 请求的地址</p>
<p>String spec = &quot;<a href="http://172.16.237.200:8080/video/login.do">http://172.16.237.200:8080/video/login.do</a>&quot;;</p>
<p>// 根据地址创建URL对象</p>
<p>URL url = new URL(spec);</p>
<p>// 根据URL对象打开链接</p>
<p>HttpURLConnection urlConnection = (HttpURLConnection) url</p>
<p>.openConnection();</p>
<p>// 设置请求的方式</p>
<p>urlConnection.setRequestMethod(&quot;POST&quot;);</p>
<p>// 设置请求的超时时间</p>
<p>urlConnection.setReadTimeout(5000);</p>
<p>urlConnection.setConnectTimeout(5000);</p>
<p>// 传递的数据</p>
<p>String data = &quot;username=&quot; + URLEncoder.encode(userName, &quot;UTF-8&quot;)</p>
<ul>
<li>&quot;&amp;userpass=&quot; + URLEncoder.encode(userPass, &quot;UTF-8&quot;);</li>
</ul>
<p>// 设置请求的头</p>
<p>urlConnection.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;);</p>
<p>// 设置请求的头</p>
<p>urlConnection.setRequestProperty(&quot;Content-Type&quot;,</p>
<p>&quot;application/x-www-form-urlencoded&quot;);</p>
<p>// 设置请求的头</p>
<p>urlConnection.setRequestProperty(&quot;Content-Length&quot;,</p>
<p>String.valueOf(data.getBytes().length));</p>
<p>// 设置请求的头</p>
<p>urlConnection</p>
<p>.setRequestProperty(&quot;User-Agent&quot;,</p>
<p>&quot;Mozilla/5.0 (Windows NT 6.3; WOW64; rv:27.0) Gecko/20100101 Firefox/27.0&quot;);</p>
<p>urlConnection.setDoOutput(true); // 发送POST请求必须设置允许输出</p>
<p>urlConnection.setDoInput(true); // 发送POST请求必须设置允许输入</p>
<p>//setDoInput的默认值就是true</p>
<p>//获取输出流</p>
<p>OutputStream os = urlConnection.getOutputStream();</p>
<p>os.write(data.getBytes());</p>
<p>os.flush();</p>
<p>if (urlConnection.getResponseCode() == 200) {</p>
<p>// 获取响应的输入流对象</p>
<p>InputStream is = urlConnection.getInputStream();</p>
<p>// 创建字节输出流对象</p>
<p>ByteArrayOutputStream baos = new ByteArrayOutputStream();</p>
<p>// 定义读取的长度</p>
<p>int len = 0;</p>
<p>// 定义缓冲区</p>
<p>byte buffer[] = new byte[1024];</p>
<p>// 按照缓冲区的大小，循环读取</p>
<p>while ((len = is.read(buffer)) != -1) {</p>
<p>// 根据读取的长度写入到os对象中</p>
<p>baos.write(buffer, 0, len);</p>
<p>}</p>
<p>// 释放资源</p>
<p>is.close();</p>
<p>baos.close();</p>
<p>// 返回字符串</p>
<p>final String result = new String(baos.toByteArray());</p>
<p>// 通过runOnUiThread方法进行修改主线程的控件内容</p>
<p>LoginActivity.this.runOnUiThread(new Runnable() {</p>
<p>@Override</p>
<p>public void run() {</p>
<p>// 在这里把返回的数据写在控件上 会出现什么情况尼</p>
<p>tv_result.setText(result);</p>
<p>}</p>
<p>});</p>
<p>} else {</p>
<p>System.out.println(&quot;链接失败………&quot;);</p>
<p>}</p>
<p>} catch (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>I2C SPI 总线对比</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/I2C%20SPI%20%E6%80%BB%E7%BA%BF%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>一 IIC总线</p>
<p>I2C–INTER-IC串行总线的缩写，是PHILIPS公司推出的芯片间串行传输总线。它以1根串行数据线（SDA）和1根串行时钟线（SCL）实 现了双向的同步数据传输。具有接口线少，控制方式简化，器件封装形式小，通信速率较高等优点。在主从通信中，可以有多个I2C总线器件同时接到I2C总线 上，通过地址来识别通信对象。</p>
<p>IIC 接口的协议里面包括设备地址信息，可以同一总线上连接多个从设备，通过应答来互通数据及命令。但是传输速率有限，标准模式下可达到100Kbps，快速模式下可达到400Kbps（我们开发板一般在130Kbps），高速模式下达到4Mbps，不能实现全双工，不适合传输很多的数据。</p>
<p>IIC总线是一个真正的多主机总线，总线上多个主机初始化传输，可以通过传输检测和仲裁来防止数据被破坏 。</p>
<p>下来详细了解IIC总线时序：</p>
<p>1.1 总线数据有效性</p>
<p>IIC总线是单工，因此同一时刻数据只有一个流向，因此采样有效时钟也是单一的，是在SCL时钟的高电平采样数据。</p>
<p>IIC总线上SDA数据在SCL时钟低电平是可以发生变化，但是在时钟高电平时必须稳定，以便主从设备根据时钟采样数据，如下图：</p>
<p>1.2 总线空闲条件</p>
<p>IIC总线上设备都释放总线（发出传输停止）后，IIC总线根据上拉电阻变成高电平，SDA SCL都是高电平。</p>
<p>1.3 总线数据传输起始和结束条件</p>
<p>IIC总线SCL高电平时SDA出现由高到低的跳变，标志总线上数据传输的开始条件</p>
<p>IIC总线SCL高电平时SDA出现由低到高的跳变，标志总线上数据传输的结束条件</p>
<p>1.4 总线数据传输顺序以及ACK应答</p>
<p>IIC总线上数据传输室MSB在前，LSB在后，从示波器上看，从左向右依次读出数据即可</p>
<p>IIC总线传输的数据不收限制，但是每次发到SDA上的必须是8位，并且主机发送8位后释放总线，从机收到数据后必须拉低SDA一个时钟，回应ACK表示数据接收成功，我们如果示波器上看到的波形就是每次9位数据，8bit+1bit ack。如下：</p>
<p>从机收到一字节数据后，如果需要一些时间处理，则会拉低SCL，让传输进入等待状态，处理完成，释放SCL，继续传输，如下：</p>
<p>1.5 总线读写时序</p>
<p>数据的传输在起始条件之后，发送一个7位的从机地址，紧接着第8位是数据方向（R/ W），0-表示发送数据（写），1-表示接收数据（读）。数据传输一般由主机产生的停止位（P）终止。但是如果主机仍希望在总线上通讯，它可以产生重复起始条件（Sr），和寻址另一个从机，而不是首先产生一个停止条件。在这种传输中，可能有不同的读/写格式结合。</p>
<p>IIC总线主设备读写从设备，一般都是与从设备的寄存器打交道，这个可以通过阅读从设备的datasheet获取。总线写时序如下：</p>
<p>master start + master addr|w + slave ack + master reg|w + slave ack + master data + slave ack + master restart。。master data + slave nack + master stop</p>
<p>总线读时序如下：</p>
<p>master start + master addr|w + slave ack + master reg|w + slave ack + master restart + master addr|r + slave ack + slave data + master nack + master stop</p>
<p>总线读时序与写的不同之处在于读需要2次传输才能完成一次读取，首先要写寄存器地址到从设备，其实是写到了从设备的控制寄存器或者命令寄存器，从设备内部会根据这个地址来寻址所要操作的寄存器。</p>
<p>我在读我们的bios和内核时发现，2者在总线读时序上的实现不太一样，在于第一次寄存器地址写入后，一个发的是restart，一个发的是stop，然后再start开始读取数据，示波器抓波形发现读取数据都正确，说明这2种时序都是正确的。</p>
<p>IIC总线的读写时序比较固定，设备通信严格遵循协议，因此iIC总线设备驱动程序的编写也就相对简单一些。</p>
<p>主要应用的iIc总线设备有touchscreen rtc 外扩io等</p>
<p>二 SPI总线</p>
<p>SPI–Serial Peripheral Interface，串行外围设备接口，是Motorola公司推出的一种同步串行通讯方式，是一种三线同步总线，因其硬件功能很强，与SPI有关的软件就相当简单，使CPU有更多的时间处理其他事务。<br> SPI通常有SCK时钟，STB片选，DATA数据信号三个信号。 I2C通常有 SDA数据和SCL时钟两个信号。</p>
<p>SPI总线真正实现了全双工数据传输，SPI 有3线跟4线两种，4线的话，就是多了一条叫SDC的线，用来告知从设备现在传输的是数据还是指令。这个接口较快，可以传输较连续的数据。SPI要想连接多个从设备，就需要给每个从设备配备一根片选信号。如果要可以实现全双工，也是需要多加一根数据线（MOSI MISO）。</p>
<p>也就是说SPI总线是通过片选来选择从设备。</p>
<p>spi总线速度要比iic要快，我们开发板最快能达到30MHZ。</p>
<p>spi总线特点：</p>
<ol>
<li>采用主-从模式(Master-Slave) 的控制方式<br>       SPI 规定了两个 SPI 设备之间通信必须由主设备 (Master) 来控制次设备 (Slave). 一个 Master 设备可以通过提供 Clock 以及对 Slave 设备进行片选 (Slave Select) 来控制多个 Slave 设备, SPI 协议还规定 Slave 设备的 Clock 由 Master 设备通过 SCK 管脚提供给 Slave 设备, Slave 设备本身不能产生或控制 Clock, 没有 Clock 则 Slave 设备不能正常工作.</li>
<li>采用同步方式(Synchronous)传输数据<br>       Master 设备会根据将要交换的数据来产生相应的时钟脉冲(Clock Pulse), 时钟脉冲组成了时钟信号(Clock Signal) , 时钟信号通过时钟极性 (CPOL) 和 时钟相位 (CPHA) 控制着两个 SPI 设备间何时数据交换以及何时对接收到的数据进行采样, 来保证数据在两个设备之间是同步传输的.</li>
<li>数据交换(Data Exchanges)<br>       SPI 设备间的数据传输之所以又被称为数据交换, 是因为 SPI 协议规定一个 SPI 设备不能在数据通信过程中仅仅只充当一个 &quot;发送者(Transmitter)&quot; 或者 &quot;接收者(Receiver)&quot;. 也就是说是全双工的，在每个 Clock 周期内, SPI 设备都会发送并接收一个 bit 大小的数据, 相当于该设备有一个 bit 大小的数据被交换了.<br>       一个 Slave 设备要想能够接收到 Master 发过来的控制信号, 必须在此之前能够被 Master 设备进行访问 (Access). 所以, Master 设备必须首先通过 SS/CS pin 对 Slave 设备进行片选, 把想要访问的 Slave 设备选上.<br>       在数据传输的过程中,  每次接收到的数据必须在下一次数据传输之前被采样. 如果之前接收到的数据没有被读取, 那么这些已经接收完成的数据将有可能会被丢弃,  导致 SPI 物理模块最终失效. 因此, 在程序中一般都会在 SPI 传输完数据后, 去读取 SPI 设备里的数据, 即使这些数据(Dummy Data)在我们的程序里是无用的.</li>
</ol>
<p>具体spi工作原理可以看博客另外一篇文章</p>
<p>SPI和IIC是2种不同的通信协议，现在已经广泛的应用在IC之间的通信中。并且不少单片机已经整和了SPI和IIC的借口。但像51这种不支持SPI和IIC的单片机，也可以用模拟时钟的工作方式进行SPI和IIC的通信的。</p>
<p>下面主要总结一下2种总线的异同点：</p>
<p>1 iic总线不是全双工，2根线SCL SDA。spi总线实现全双工，4根线SCK CS MOSI MISO</p>
<p>2 iic总线是多主机总线，通过SDA上的地址信息来锁定从设备。spi总线只有一个主设备，主设备通过CS片选来确定从设备</p>
<p>3 iic总线传输速度在100kbps-4Mbps。spi总线传输速度更快，可以达到30MHZ以上。</p>
<p>4 iic总线空闲状态下SDA SCL都是高电平。spi总线空闲状态MOSI MISO也都是 SCK是有CPOL决定的</p>
<p>5 iic总线scl高电平时sda下降沿标志传输开始，上升沿标志传输结束。spi总线cs拉低标志传输开始，cs拉高标志传输结束</p>
<p>6 iic总线是SCL高电平采样。spi总线因为是全双工，因此是沿采样，具体要根据CPHA决定。一般情况下master device是SCK的上升沿发送，下降沿采集</p>
<p>7 iic总线和spi总线数据传输都是MSB在前，LSB在后（串口是LSB在前）</p>
<p>8 iic总线和spi总线时钟都是由主设备产生，并且只在数据传输时发出时钟</p>
<p>9 iic总线读写时序比较固定统一，设备驱动编写方便。spi总线不同从设备读写时序差别比较大，因此必须根据具体的设备datasheet来实现读写，相对复杂一些。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>I2C总线知识</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/I2C%E6%80%BB%E7%BA%BF%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>1.1 I2C总线知识</p>
<p>1.1.1  I2C总线物理拓扑结构</p>
<p>    I2C 总线在物理连接上非常简单，分别由SDA(串行数据线)和SCL(串行时钟线)及上拉电阻组成。通信原理是通过对SCL和SDA线高低电平时序的控制，来 产生I2C总线协议所需要的信号进行数据的传递。在总线空闲状态时，这两根线一般被上面所接的上拉电阻拉高，保持着高电平。</p>
<p>1.1.2  I2C总线特征<br>    I2C总线上的每一个设备都可以作为主设备或者从设备，而且每一个设备都会对应一个唯一的地址(可以从I2C器件的数据手册得知)，主从设备之间就通过这 个地址来确定与哪个器件进行通信，在通常的应用中，我们把CPU带I2C总线接口的模块作为主设备，把挂接在总线上的其他设备都作为从设备。<br>    I2C总线上可挂接的设备数量受总线的最大电容400pF 限制，如果所挂接的是相同型号的器件，则还受器件地址位的限制。<br>    I2C总线数据传输速率在标准模式下可达100kbit/s，快速模式下可达400kbit/s，高速模式下可达3.4Mbit/s。一般通过I2C总线接口可编程时钟来实现传输速率的调整，同时也跟所接的上拉电阻的阻值有关。<br>    I2C总线上的主设备与从设备之间以字节(8位)为单位进行双向的数据传输。</p>
<p>1.1.3  I2C总线协议<br>    I2C协议规定，总线上数据的传输必须以一个起始信号作为开始条件，以一个结束信号作为传输的停止条件。起始和结束信号总是由主设备产生。总线在空闲状态 时，SCL和SDA都保持着高电平，当SCL为高电平而SDA由高到低的跳变，表示产生一个起始条件；当SCL为高而SDA由低到高的跳变，表示产生一个 停止条件。在起始条件产生后，总线处于忙状态，由本次数据传输的主从设备独占，其他I2C器件无法访问总线；而在停止条件产生后，本次数据传输的主从设备 将释放总线，总线再次处于空闲状态。如图所示：</p>
<p>    在了解起始条件和停止条件后，我们再来看看在这个过程中数据的传输是如何进行的。前面我们已经提到过，数据传输以字节为单位。主设备在SCL线上产生每个 时钟脉冲的过程中将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着从设备将拉低SDA线，回传给主设备一个应答位， 此时才认为一个字节真正的被传输完成。当然，并不是所有的字节传输都必须有一个应答位，比如：当从设备不能再接收主设备发送的数据时，从设备将回传一个否 定应答位。数据传输的过程如图所示：</p>
<p>    在前面我们还提到过，I2C总线上的每一个设备都对应一个唯一的地址，主从设备之间的数据传输是建立在地址的基础上，也就是说，主设备在传输有效数据之前 要先指定从设备的地址，地址指定的过程和上面数据传输的过程一样，只不过大多数从设备的地址是7位的，然后协议规定再给地址添加一个最低位用来表示接下来 数据传输的方向，0表示主设备向从设备写数据，1表示主设备向从设备读数据。如图所示：</p>
<p>1.1.4  I2C总线操作<br>    对I2C总线的操作实际就是主从设备之间的读写操作。大致可分为以下三种操作情况：<br>    第一，主设备往从设备中写数据。数据传输格式如下：</p>
<p>    第二，主设备从从设备中读数据。数据传输格式如下：</p>
<p>    第三，主设备往从设备中写数据，然后重启起始条件，紧接着从从设备中读取数据；或者是主设备从从设备中读数据，然后重启起始条件，紧接着主设备往从设备中写数据。数据传输格式如下：</p>
<p>    第三种操作在单个主设备系统中，重复的开启起始条件机制要比用STOP终止传输后又再次开启总线更有效率。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>IOS Ramdisk drivedata</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/IOS%20Ramdisk%20drivedata/</url>
    <content><![CDATA[<p>#!/bin/bash<br>// 设置 ram disk 的名称<br>RAMDISK=”ramdisk”<br>// 设置 ram disk 的大小，这里是 1024 MB<br>SIZE=1024  <br>// 分配给 ramdisk 相应大小的空间<br>diskutil erasevolume HFS+ $RAMDISK <code>hdiutil attach -nomount ram://$[SIZE*2048]</code> <br>// 打开元数据索引，如果你使用 Xcode 内部的调试工具这是必须的。因为调试工具使用元数据索引来查询符号连接<br>mdutil -i on /Volumes/$RAMDISK</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>IOS 横竖屏切换</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/IOS%20%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<p>iOS 中横竖屏切换的功能，在开发iOS app中总能遇到。以前看过几次，感觉简单，但是没有敲过代码实现，最近又碰到了，demo尝试了几种情况，这里就做下总结。<br>注意</p>
<p>横屏两种情况是反的你知道吗？</p>
<p>UIInterfaceOrientationLandscapeRight与UIInterfaceOrientationMaskLandscapeRight都代表横屏，Home键在右侧的情况；UIDeviceOrientationLandscapeLeft则是Home键在左侧。</p>
<p>一般情形</p>
<p>所有界面都支持横竖屏切换<br>如果App的所有切面都要支持横竖屏的切换，那只需要勾选【General】 中的【Device Orientation】，选择希望支持的方向即可。</p>
<p>图中支持竖屏和Home在右侧</p>
<p>如上设置完之后，当设备竖屏的时候，所有的界面都是竖屏显示的；而当设备横屏Home在右侧时，所有的界面会横屏显示。其他方向不支持，界面不会改变。</p>
<p>这里有个坑：<br>在iOS 9 之后横屏时，状态栏会消失。<br>解决方法：确保plist 中的【View controller-based status bar appearance】为YES，然后重写ViewController的 - (BOOL)prefersStatusBarHidden ，返回值是NO。</p>
<p>- (BOOL)prefersStatusBarHidden<br>{<br>    return NO;<br>}</p>
<p>特殊情形</p>
<p>个别界面固定方向，其他所有界面都支持横竖屏切换<br>这种情况，在【General】–&gt;【Device Orientation】中设置好支持的方向后，只需要在这些特殊的视图控制器中重写两个方法：</p>
<p>// 支持设备自动旋转<br>- (BOOL)shouldAutorotate<br>{<br>    return YES;<br>}</p>
<p>/** <br>*  设置特殊的界面支持的方向,这里特殊界面只支持Home在右侧的情况<br>*/<br>- (UIInterfaceOrientationMask)supportedInterfaceOrientations <br>{<br>    return UIInterfaceOrientationMaskLandscapeRight;<br>}</p>
<p>个别界面支持横竖屏切换，其他所有界面都固定方向</p>
<p>可能大多数App会是这种需求，某些特殊界面只能横屏，如视频播放类App。<br>这里有两种处理方式：<br>方式一<br>在【General】–&gt;【Device Orientation】中设置好需要支持的所有方向。然后使用一个基类控制器，在基类控制器中重写两个控制横竖屏的方法：</p>
<p>// 支持设备自动旋转<br>- (BOOL)shouldAutorotate<br>{<br>    return YES;<br>}</p>
<p>// 支持竖屏显示<br>- (UIInterfaceOrientationMask)supportedInterfaceOrientations<br>{<br>    return UIInterfaceOrientationMaskPortrait;<br>}</p>
<p>再然后，特殊的界面上再重写这俩方法，让其可以自动切换方向。</p>
<p>// 如果需要横屏的时候，一定要重写这个方法并返回NO<br>- (BOOL)prefersStatusBarHidden<br>{<br>    return NO;<br>}</p>
<p>// 支持设备自动旋转<br>- (BOOL)shouldAutorotate<br>{<br>    return YES;<br>}</p>
<p>// 支持横屏显示<br>- (UIInterfaceOrientationMask)supportedInterfaceOrientations<br>{<br>    // 如果该界面需要支持横竖屏切换<br>    return UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortrait;<br>    // 如果该界面仅支持横屏<br>   // return UIInterfaceOrientationMaskLandscapeRight；<br>}</p>
<p>方式二<br>用方式一的方法，还需要借助一个基类，所有的控制器都要继承这个基类，太麻烦？<br>另一种方式，是借助通知来控制界面的横竖屏切换。<br>还是整个App中大部分界面都是竖屏，某个界面可以横竖屏切换的情况。</p>
<p>首先，在【General】–&gt;【Device Orientation】设置仅支持竖屏，like this:</p>
<p>Device Orientation</p>
<p>然后在特殊的视图控制器里的ViewDidLoad中注册通知：</p>
<p>    [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];<br>    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];</p>
<p>通知方法的实现过程：</p>
<p>- (void)deviceOrientationDidChange<br>{<br>    NSLog(@&quot;deviceOrientationDidChange:%ld&quot;,(long)[UIDevice currentDevice].orientation);<br>    if([UIDevice currentDevice].orientation == UIDeviceOrientationPortrait) {<br>        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];<br>        [self orientationChange:NO];<br>        //注意： UIDeviceOrientationLandscapeLeft 与 UIInterfaceOrientationLandscapeRight<br>    } else if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) {<br>        [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];<br>        [self orientationChange:YES];<br>    }<br>}</p>
<p>- (void)orientationChange:(BOOL)landscapeRight<br>{<br>    if (landscapeRight) {<br>        [UIView animateWithDuration:0.2f animations:^{<br>            self.view.transform = CGAffineTransformMakeRotation(M_PI_2);<br>            self.view.bounds = CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);<br>        }];<br>    } else {<br>        [UIView animateWithDuration:0.2f animations:^{<br>            self.view.transform = CGAffineTransformMakeRotation(0);<br>            self.view.bounds = CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);<br>        }];<br>    }<br>}<br>// 用到的两个宏：<br>    #define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)<br>    #define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height)</p>
<p>最重要的一点:<br>需要重写如下方法，并且返回NO。</p>
<p>- (BOOL)shouldAutorotate<br>{<br>    return NO;<br>}</p>
<p>这样，在设备出于横屏时，界面就会变成横屏，设备处于竖屏时，界面就会变成竖屏。</p>
<p>填坑</p>
<p>上面方式二，因为【General】–&gt;【Device Orientation】因为只设置了竖屏，所以当横屏时，如果有键盘弹出，键盘是竖屏时的样式。<br>解决办法：在【General】–&gt;【Device Orientation】中加上横屏时的方向。</p>
<p>如果VieController 是放在UINavigationController或者UITabBarController中，需要重写它们的方向控制方法。</p>
<p>// UINavigationController：<br>- (BOOL)shouldAutorotate<br>{<br>    return [self.topViewController shouldAutorotate];<br>}</p>
<p>- (UIInterfaceOrientationMask)supportedInterfaceOrientations<br>{<br>    return [self.topViewController supportedInterfaceOrientations];<br>}</p>
<p>// UITabBarController:<br>- (BOOL)shouldAutorotate<br>{<br>    return [self.selectedViewController shouldAutorotate];<br>}</p>
<p>- (UIInterfaceOrientationMask)supportedInterfaceOrientations<br>{<br>    return [self.selectedViewController supportedInterfaceOrientations];<br>}</p>
<p>如果想要点击某个按钮之后，强制将竖屏显示的界面变成横屏呢？<br>有人可能会想到这样写:</p>
<p>// 横屏<br>- (IBAction)landscapAction:(id)sender {<br>    [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];<br>    [self orientationChange:YES];<br>}</p>
<p>但是按照上面的写法，会导致返回到之前的界面时，视图方向错误，即使返回前执行如下代码：</p>
<p>[[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];<br>[self orientationChange:NO];</p>
<p>也没有作用，下面是在开源工程中无意看到的写法：</p>
<p>// 横屏<br>- (IBAction)landscapAction:(id)sender {<br>    [self interfaceOrientation:UIInterfaceOrientationLandscapeRight];<br>}</p>
<p>// 竖屏<br>- (IBAction)portraitAction:(id)sender {<br>    [self interfaceOrientation:UIInterfaceOrientationPortrait];<br>}</p>
<p>- (void)interfaceOrientation:(UIInterfaceOrientation)orientation<br>{<br>    if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {<br>        SEL selector             = NSSelectorFromString(@&quot;setOrientation:&quot;);<br>        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];<br>        [invocation setSelector:selector];<br>        [invocation setTarget:[UIDevice currentDevice]];<br>        int val                  = orientation;<br>        [invocation setArgument:&amp;val atIndex:2];<br>        [invocation invoke];<br>    }<br>}</p>
<p>上面的方法会将设备的方向强制设置为某个方向，然后再监控设备方向改变的通知，即可实现横竖屏切换。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>IP地址设置</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/IP%E5%9C%B0%E5%9D%80%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>Dynamic IP Address Assignment (DHCP Client)</p>
<p>                     To configure your server to use DHCP for dynamic address assignment, add the</p>
<p>                     dhcp method to the inet address family statement</p>
<p>                     for the appropriate interface in the file /etc/network/interfaces.</p>
<p>                     The example below assumes you are configuring your first Ethernet interface identified as</p>
<p>                     eth0.</p>
<p>auto eth0</p>
<p>iface eth0 inet dhcp</p>
<p>                     By adding an interface configuration as shown above, you can manually enable the</p>
<p>                     interface through the ifup command which initiates the</p>
<p>                     DHCP process via dhclient.</p>
<p>sudo ifup eth0</p>
<p>                     To manually disable the  interface, you can use the ifdown</p>
<p>                     command, which in turn will initiate the DHCP release process and shut down the</p>
<p>                     interface.</p>
<p>sudo ifdown eth0</p>
<p>Static IP Address Assignment</p>
<p>                     To configure your system to use a static IP address assignment, add the</p>
<p>                     static method to the inet address family statement</p>
<p>                     for the appropriate interface in the file /etc/network/interfaces.</p>
<p>                     The example below assumes you are configuring your first Ethernet interface identified as</p>
<p>                     eth0.  Change the address,</p>
<p>                     netmask, and gateway</p>
<p>                     values to meet the requirements of your network.</p>
<p>auto eth0</p>
<p>iface eth0 inet static</p>
<p>address 10.0.0.100</p>
<p>netmask 255.255.255.0</p>
<p>gateway 10.0.0.1</p>
<p>                     By adding an interface configuration as shown above, you can manually enable the</p>
<p>                     interface through the ifup command.</p>
<p>sudo ifup eth0</p>
<p>                     To manually disable the  interface, you can use the ifdown</p>
<p>                     command.</p>
<p>sudo ifdown eth0</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ISP DSP的不同</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ISP%20DSP%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<p>ISP DSP的不同<br>ISP 是Image Signal Processor 的简称，也就是图像信号处理器。而DSP是Digital Signal Processor 的缩写，也就是数字信号处理器。<br>ISP一般用来处理Image Sensor（图像传感器）的输出数据，如做AEC（自动曝光控制）、AGC（自动增益控制）、AWB（自动白平衡）、色彩校正、Lens Shading、Gamma 校正、祛除坏点、Auto Black Level、Auto White Level 等等功能的处理。<br>而DSP功能就比较多了，它可以做些拍照以及回显（JPEG的编解码）、录像以及回放（Video 的编解码）、H.264的编解码、还有很多其他方面的处理，总之是处理数字信号了。个人认为ISP是一类特殊的处理图像信号的DSP。<br>图像传感器<br>　　图像传感器是组成数字摄像机的重要组成部分。根据元件的不同，可分为CCD和CMOS两大类。如SONY的 ICX 445、ICX274、IMX035/036，Aptina的MT9M033、MT9D131、MT9T031，Omnivison的OV2715等等。图像传感器的作用是将光学图像采集并转换成后端ISP可用的电信号。<br>　　过去，我们常说CCD是应用在影像产品的高端技术元器件，而CMOS由于其低照性能、曝光模式等技术性能有限应用于低影像品质产品中。如今，CMOS技术快速发展，例如SONY推出了使用Exmor技术的IMX035/036图像传感器，其低照性能、图像分辨率及帧率、芯片处理速度有了很大程度的性能提升。<br>ISP图像信号处理器<br>　　ISP（Image Signal Processor）图像信号处理器的主要作用是对前端图像传感器输出的信号做后期的处理。不同的ISP用来匹配不同厂商的图像传感器。ISP的优异在整个摄像机产品中很重要，应当说它直接影响呈现给用户的影响画质的优劣。图像经过图像经过CCD或者CMOS的采集后，需要经过后期的处理才可以较好的适应不同的环境，在不同的光学条件下都能较好的还原出现场细节。在ISP中它会完成我们常常提及的2A（AWB/AE，自动白平衡/自动曝光）或者3A（AWB/AE/AF，自动白平衡/自动曝光/自动聚焦）。传统模式下一般采用一颗DSP或者一颗FPGA来完成对图像的后期处理。有些摄像机产品支持的3D降噪功能、宽动态、慢快门、帧累积、强光抑制等功能也都是ISP来完成的。<br>　　目前应用在高清摄像机产品中的ISP一般有以下几个来源：<br>　　厂商自行研发：高清摄像机设备厂商为了更好的配合后端压缩、功能开发，自行研发ISP处理算法，将算法集成至FPGA或DSP芯片中，接驳前端图像传感器。<br>　　第三方研发：2010年已经逐渐诞生了一批由非高清摄像机制造厂商推出的一些ISP解决方案，他们直接出售不同的ISP芯片给摄像机厂商配合不同厂商的Sensor。<br>　　套片模式：由Sensor厂商将自主开发的ISP结合自家Sensor形成图像采集处理解决方案推向客户，其中的图像处理算法及各种调试工作已经完成，摄像机厂商只需要做接口对接并后端压缩或转换成数字视频（HD-SDI）即可。这种模式我们称为Stand-Alone Devices或者Camera System Onchip。<br>压缩处理器或数字视频转换<br>　　首先我们来了解压缩处理和数字视频转换的概念。ISP将前端图像传感器信号处理后，一般会以MPTE296M/BT.1120/ YUV 4：2：2等数字接口格式传输到后端处理芯片中。压缩处理器（SoC或DSP）可以将视频信号以H.264/MPEG-4/MJPEG算法进行编码压缩，然后通过内建的网络服务以TCP/IP协议的网络信号进行传输给用户。数字视频转换则是非压缩方式，通过数字视频转换芯片将ISP输出的数字信号转换成SD-SDI/HD-SDI/3G-SDI信号，分别对应标准清晰度（VGA）、高清标准（1080P@30fps）、1080P@60fps甚至更高的分辨率。HD-SDI高清视频信号需要使用专用的传输周边设备，如SDI光端机、SDI矩阵等等。<br>低照度指的是当被摄景物的光亮度低到一定程度而使摄像机输出的视频信号电平低到某一规定值时的景物光亮度值。测定此参数时，还应特别注明镜头的最大相对孔径。 例如，使用F1. 2的镜头，当被景物的光亮度值低到0. 04lx时，摄像机输出的视频信号幅值为最大幅值的50%，即达到350mV （标准视频信号最大幅起来 700mV）， 则称此摄像机的最低照度为0. 04lx/F1. 2。被摄景物的光亮度值再低，摄像要输出的视频信号的幅值就达不到350mV了，反映在监视器的屏幕上， 将是一屏很难分辨出层次的、灰暗的图像</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>InputManager</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/InputManager/</url>
    <content><![CDATA[<p>SystemServer</p>
<p> –&gt; InputManager</p>
<p>            –&gt; nativeInit      （JNI调用）               </p>
<p>            –&gt; com_android_server_InputManager</p>
<p>                   –&gt;NativeInputManager </p>
<p>                        –&gt; EventHub  轮询读取内核的上报数据  （HAL）</p>
<p>                        –&gt; InputManager  管理 input event </p>
<p>                          –&gt; initialize inputReaderThread , InputDispatcherThread              </p>
<p>                            –&gt;InputReader 从EventHub读取事件</p>
<p>                             –&gt; InputDispatcher 分发事件</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>InputMethodSettingValuesWrapper</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/InputMethodSettingValuesWrapper.java/</url>
    <content><![CDATA[<p>/*</p>
<p> * Copyright (C) 2013 The Android Open Source Project</p>
<p> *</p>
<p> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</p>
<p> * you may not use this file except in compliance with the License.</p>
<p> * You may obtain a copy of the License at</p>
<p> *</p>
<p> *      <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p> *</p>
<p> * Unless required by applicable law or agreed to in writing, software</p>
<p> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</p>
<p> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>
<p> * See the License for the specific language governing permissions and</p>
<p> * limitations under the License.</p>
<p> */</p>
<p>package com.android.provision;</p>
<p>import com.android.internal.inputmethod.InputMethodUtils;</p>
<p>import com.android.internal.inputmethod.InputMethodUtils.InputMethodSettings;</p>
<p>import android.app.ActivityManagerNative;</p>
<p>import android.content.Context;</p>
<p>import android.os.RemoteException;</p>
<p>import android.util.Log;</p>
<p>import android.util.Slog;</p>
<p>import android.view.inputmethod.InputMethodInfo;</p>
<p>import android.view.inputmethod.InputMethodManager;</p>
<p>import android.view.inputmethod.InputMethodSubtype;</p>
<p>import java.util.ArrayList;</p>
<p>import java.util.HashMap;</p>
<p>import java.util.HashSet;</p>
<p>import java.util.List;</p>
<p>import java.util.Locale;</p>
<p>/**</p>
<p> * This class is a wrapper for InputMethodSettings. You need to refresh internal states</p>
<p> * manually on some events when &quot;InputMethodInfo&quot;s and &quot;InputMethodSubtype&quot;s can be</p>
<p> * changed.</p>
<p> */</p>
<p>public class InputMethodSettingValuesWrapper {</p>
<p>    private static final String TAG = InputMethodSettingValuesWrapper.class.getSimpleName();</p>
<p>    private static final Locale ENGLISH_LOCALE = new Locale(&quot;en&quot;);</p>
<p>    private static volatile InputMethodSettingValuesWrapper sInstance;</p>
<p>    private final ArrayList&lt;InputMethodInfo&gt; mMethodList = new ArrayList&lt;InputMethodInfo&gt;();</p>
<p>    private final HashMap&lt;String, InputMethodInfo&gt; mMethodMap =</p>
<p>            new HashMap&lt;String, InputMethodInfo&gt;();</p>
<p>    private final InputMethodSettings mSettings;</p>
<p>    private final InputMethodManager mImm;</p>
<p>    private final HashSet&lt;InputMethodInfo&gt; mAsciiCapableEnabledImis =</p>
<p>            new HashSet&lt;InputMethodInfo&gt;();</p>
<p>    public static InputMethodSettingValuesWrapper getInstance(Context context) {</p>
<p>        if (sInstance == null) {</p>
<p>            synchronized(TAG) {</p>
<p>                if (sInstance == null) {</p>
<p>                    sInstance = new InputMethodSettingValuesWrapper(context);</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>        return sInstance;</p>
<p>    }</p>
<p>    private static int getDefaultCurrentUserId() {</p>
<p>        try {</p>
<p>            return ActivityManagerNative.getDefault().getCurrentUser().id;</p>
<p>        } catch (RemoteException e) {</p>
<p>            Slog.w(TAG, &quot;Couldn’t get current user ID; guessing it’s 0&quot;, e);</p>
<p>        }</p>
<p>        return 0;</p>
<p>    }</p>
<p>    // Ensure singleton</p>
<p>    private InputMethodSettingValuesWrapper(Context context) {</p>
<p>        mSettings =</p>
<p>                new InputMethodSettings(context.getResources(), context.getContentResolver(),</p>
<p>                        mMethodMap, mMethodList, getDefaultCurrentUserId());</p>
<p>        mImm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);</p>
<p>        refreshAllInputMethodAndSubtypes();</p>
<p>    }</p>
<p>    public void refreshAllInputMethodAndSubtypes() {</p>
<p>        synchronized (mMethodMap) {</p>
<p>            mMethodList.clear();</p>
<p>            mMethodMap.clear();</p>
<p>            final List&lt;InputMethodInfo&gt; imms = mImm.getInputMethodList();</p>
<p>            mMethodList.addAll(imms);</p>
<p>            for (InputMethodInfo imi : imms) {</p>
<p>                mMethodMap.put(imi.getId(), imi);</p>
<p>            }</p>
<p>            updateAsciiCapableEnabledImis();</p>
<p>        }</p>
<p>    }</p>
<p>    // TODO: Add a cts to ensure at least one AsciiCapableSubtypeEnabledImis exist</p>
<p>    private void updateAsciiCapableEnabledImis() {</p>
<p>        synchronized (mMethodMap) {</p>
<p>            mAsciiCapableEnabledImis.clear();</p>
<p>            final List&lt;InputMethodInfo&gt; enabledImis = mSettings.getEnabledInputMethodListLocked();</p>
<p>            for (final InputMethodInfo imi : enabledImis) {</p>
<p>                final int subtypeCount = imi.getSubtypeCount();</p>
<p>                for (int i = 0; i &lt; subtypeCount; ++i) {</p>
<p>                    final InputMethodSubtype subtype = imi.getSubtypeAt(i);</p>
<p>                    if (InputMethodUtils.SUBTYPE_MODE_KEYBOARD.equalsIgnoreCase(subtype.getMode())</p>
<p>                            &amp;&amp; subtype.isAsciiCapable()) {</p>
<p>                        mAsciiCapableEnabledImis.add(imi);</p>
<p>                        break;</p>
<p>                    }</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    public List&lt;InputMethodInfo&gt; getInputMethodList() {</p>
<p>        synchronized (mMethodMap) {</p>
<p>            return mMethodList;</p>
<p>        }</p>
<p>    }</p>
<p>    public CharSequence getCurrentInputMethodName(Context context) {</p>
<p>        synchronized (mMethodMap) {</p>
<p>            final InputMethodInfo imi = mMethodMap.get(mSettings.getSelectedInputMethod());</p>
<p>            if (imi == null) {</p>
<p>                Log.w(TAG, &quot;Invalid selected imi: &quot; + mSettings.getSelectedInputMethod());</p>
<p>                return &quot;&quot;;</p>
<p>            }</p>
<p>            final InputMethodSubtype subtype = mImm.getCurrentInputMethodSubtype();</p>
<p>            return InputMethodUtils.getImeAndSubtypeDisplayName(context, imi, subtype);</p>
<p>        }</p>
<p>    }</p>
<p>    public boolean isAlwaysCheckedIme(InputMethodInfo imi, Context context) {</p>
<p>        final boolean isEnabled = isEnabledImi(imi);</p>
<p>        synchronized (mMethodMap) {</p>
<p>            if (mSettings.getEnabledInputMethodListLocked().size() &lt;= 1 &amp;&amp; isEnabled) {</p>
<p>                return true;</p>
<p>            }</p>
<p>        }</p>
<p>        final int enabledValidSystemNonAuxAsciiCapableImeCount =</p>
<p>                getEnabledValidSystemNonAuxAsciiCapableImeCount(context);</p>
<p>        if (enabledValidSystemNonAuxAsciiCapableImeCount &gt; 1) {</p>
<p>            return false;</p>
<p>        }</p>
<p>        if (enabledValidSystemNonAuxAsciiCapableImeCount == 1 &amp;&amp; !isEnabled) {</p>
<p>            return false;</p>
<p>        }</p>
<p>        if (!InputMethodUtils.isSystemIme(imi)) {</p>
<p>            return false;</p>
<p>        }</p>
<p>        return isValidSystemNonAuxAsciiCapableIme(imi, context);</p>
<p>    }</p>
<p>    private int getEnabledValidSystemNonAuxAsciiCapableImeCount(Context context) {</p>
<p>        int count = 0;</p>
<p>        final List&lt;InputMethodInfo&gt; enabledImis;</p>
<p>        synchronized(mMethodMap) {</p>
<p>            enabledImis = mSettings.getEnabledInputMethodListLocked();</p>
<p>        }</p>
<p>        for (final InputMethodInfo imi : enabledImis) {</p>
<p>            if (isValidSystemNonAuxAsciiCapableIme(imi, context)) {</p>
<p>                ++count;</p>
<p>            }</p>
<p>        }</p>
<p>        if (count == 0) {</p>
<p>            Log.w(TAG, &quot;No &amp;quot;enabledValidSystemNonAuxAsciiCapableIme&amp;quot;s found.&quot;);</p>
<p>        }</p>
<p>        return count;</p>
<p>    }</p>
<p>    private boolean isEnabledImi(InputMethodInfo imi) {</p>
<p>        final List&lt;InputMethodInfo&gt; enabledImis;</p>
<p>        synchronized(mMethodMap) {</p>
<p>            enabledImis = mSettings.getEnabledInputMethodListLocked();</p>
<p>        }</p>
<p>        for (final InputMethodInfo tempImi : enabledImis) {</p>
<p>            if (tempImi.getId().equals(imi.getId())) {</p>
<p>                return true;</p>
<p>            }</p>
<p>        }</p>
<p>        return false;</p>
<p>    }</p>
<p>    public boolean isValidSystemNonAuxAsciiCapableIme(InputMethodInfo imi,</p>
<p>            Context context) {</p>
<p>        if (imi.isAuxiliaryIme()) {</p>
<p>            return false;</p>
<p>        }</p>
<p>        if (InputMethodUtils.isValidSystemDefaultIme(true /* isSystemReady */, imi, context)) {</p>
<p>            return true;</p>
<p>        }</p>
<p>        if (mAsciiCapableEnabledImis.isEmpty()) {</p>
<p>            Log.w(TAG, &quot;ascii capable subtype enabled imi not found. Fall back to English&quot;</p>
<p>                    + &quot; Keyboard subtype.&quot;);</p>
<p>            return InputMethodUtils.containsSubtypeOf(imi, ENGLISH_LOCALE.getLanguage(),</p>
<p>                    InputMethodUtils.SUBTYPE_MODE_KEYBOARD);</p>
<p>        }</p>
<p>        return mAsciiCapableEnabledImis.contains(imi);</p>
<p>    }</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>InstalledAppDetails</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/InstalledAppDetails/</url>
    <content><![CDATA[<p>import android.content.Context;<br>import android.content.Intent;<br>import android.net.Uri;<br>import android.os.Build;<br>import android.provider.Settings;<br>public class APPInfoDetails {<br>   private static final String SCHEME = &quot;package&quot;;<br>   /**<br>    * 调用系统InstalledAppDetails界面所需的Extra名称(用于Android 2.1及之前版本)<br>    */<br>   private static final String APP_PKG_NAME_21 = &quot;com.android.settings.ApplicationPkgName&quot;;<br>   /**<br>    * 调用系统InstalledAppDetails界面所需的Extra名称(用于Android 2.2)<br>    */<br>   private static final String APP_PKG_NAME_22 = &quot;pkg&quot;;<br>   /**<br>    * InstalledAppDetails所在包名<br>    */<br>   private static final String APP_DETAILS_PACKAGE_NAME = &quot;com.android.settings&quot;;<br>   /**<br>    * InstalledAppDetails类名<br>    */<br>   private static final String APP_DETAILS_CLASS_NAME = &quot;com.android.settings.InstalledAppDetails&quot;;<br>   /**<br>    * 调用系统InstalledAppDetails界面显示已安装应用程序的详细信息。 对于Android 2.3（Api Level<br>    * 9）以上，使用SDK提供的接口； 2.3以下，使用非公开的接口（查看InstalledAppDetails源码）。<br>    *<br>    * @param context<br>    * @param packageName 应用程序的包名<br>    */<br>   public static void showInstalledAppDetails(Context context, String packageName) {<br>       Intent intent = new Intent();<br>       final int apiLevel = Build.VERSION.SDK_INT;<br>       if (apiLevel &gt;= 9) { // 2.3（ApiLevel 9）以上，使用SDK提供的接口<br>           intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);<br>           Uri uri = Uri.fromParts(SCHEME, packageName, null);<br>           intent.setData(uri);<br>       } else { // 2.3以下，使用非公开的接口（查看InstalledAppDetails源码）<br>           // 2.2和2.1中，InstalledAppDetails使用的APP_PKG_NAME不同。<br>           final String appPkgName = (apiLevel == 8 ? APP_PKG_NAME_22 : APP_PKG_NAME_21);<br>           intent.setAction(Intent.ACTION_VIEW);<br>           intent.setClassName(APP_DETAILS_PACKAGE_NAME, APP_DETAILS_CLASS_NAME);<br>           intent.putExtra(appPkgName, packageName);<br>       }<br>       context.startActivity(intent);<br>   }<br>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Instrumentation Testing</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Instrumentation%20Testing/</url>
    <content><![CDATA[<p>       Each Android application runs in its own process. Instrumentation kills the application process and restarts the process with Instrumentation. Instrumentation gives a handle to the application context used to poke around the application to validate test assertions, allowing you to write test cases to test applications at a much lower level than UI screen shot tests. Note that Instrumentation cannot catch UI bugs.</p>
<p>Instrumentation Framework</p>
<p>Classes</p>
<p>The following classes help glue together Instrumentation with JUnit testing.</p>
<p>ClassDescription</p>
<p>InstrumentationTestCase</p>
<p>This extends the standard JUnit TestCase and offers access to an Instrumentation class. Write tests inside your instrumentation class any way you see fit. For example, your test might launch activities and send key events. For this to work properly, the instrumentation needs to be injected into the test case.</p>
<p>InstrumentationTestRunnerThe instrumentation test runner is an instrumentation that runs instrumentation test cases and injects itself into each test case. Instrumentation test cases need to be grouped together with an instrumentation test runner with the appropriate target package.</p>
<p>InstrumentationTestSuiteThe instrumentation test suite is a simple extension of the standard JUnit TestSuite that keeps a member Instrumentation variable on hand to inject into each TestCase before running them. It is used by InstrumentationTestRunner.</p>
<p>Three additional base classes extend InstrumentationTestCase to allow you to test Activity and Provider classes:</p>
<p>ClassDescription</p>
<p>ActivityTestCase</p>
<p>This class can be used to write tests for a specific activity. An activity is launched in itssetUp() method and finished with tearDown. If you write a test case that extendsActivityTestCase, you can write tests that access the activity using getActivity() and assume it has been set up properly.</p>
<p>ServiceTestCaseThis test case provides a framework in which you can test Service classes in a controlled environment. It provides basic support for the lifecycle of a Service, and hooks by which you can inject various dependencies and control the environment in which your Service is tested.</p>
<p>SingleLaunchActivityTestCaseThis class is similar to ActivityTestCase except that the activity is launched once per class instead of every time the test case calls setup.</p>
<p>ProviderTestCaseThis class is similar to ActivityTestCase except that it will setup, tear down, and provide access to the Provider of your choice.</p>
<p>     A test suite containing all tests for ApiDemos.</p>
<p> *</p>
<p> * To run all suites found in this apk:</p>
<p> * $ adb shell am instrument -w \</p>
<p> *   com.example.android.apis.tests/android.test.InstrumentationTestRunner</p>
<p> *</p>
<p> * To run just this suite from the command line:</p>
<p> * $ adb shell am instrument -w \</p>
<p> *   -e class com.example.android.apis.AllTests \</p>
<p> *   com.example.android.apis.tests/android.test.InstrumentationTestRunner</p>
<p> *</p>
<p> * To run an individual test case, e.g. {@link com.example.android.apis.os.MorseCodeConverterTest}:</p>
<p> * $ adb shell am instrument -w \</p>
<p> *   -e class com.example.android.apis.os.MorseCodeConverterTest \</p>
<p> *   com.example.android.apis.tests/android.test.InstrumentationTestRunner</p>
<p> *</p>
<p> * To run an individual test, e.g. {@link com.example.android.apis.os.MorseCodeConverterTest#testCharacterS()}:</p>
<p> * $ adb shell am instrument -w \</p>
<p> *   -e class com.example.android.apis.os.MorseCodeConverterTest#testCharacterS \</p>
<p> *   com.example.android.apis.tests/android.test.InstrumentationTestRunner</p>
<p>AndroidManifest.xml</p>
<p>&lt;!– package name must be unique so suffix with &quot;tests&quot; so package loader doesn’t ignore us –&gt;</p>
<p>&lt;manifest xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;</p>
<p>    package=&quot;com.example.android.apis.tests&quot;&gt;</p>
<p>    &lt;!– We add an application tag here just so that we can indicate that</p>
<p>         this package needs to link against the android.test library,</p>
<p>         which is needed when building test cases. –&gt;    </p>
<p>    &lt;application&gt;</p>
<p>        &lt;uses-library android:name=&quot;android.test.runner&quot; /&gt;</p>
<p>    &lt;/application&gt;</p>
<p>    &lt;!–</p>
<p>    This declares that this app uses the instrumentation test runner targeting</p>
<p>    the package of com.example.android.apis.  To run the tests use the command:</p>
<p>    &quot;adb shell am instrument -w com.example.android.apis.tests/android.test.InstrumentationTestRunner&quot;</p>
<p>    –&gt;</p>
<p>    &lt;instrumentation android:name=&quot;android.test.InstrumentationTestRunner&quot;</p>
<p>                     android:targetPackage=&quot;com.example.android.apis&quot;</p>
<p>                     android:label=&quot;Tests for Api Demos.&quot;/&gt;</p>
<p>&lt;/manifest&gt;</p>
<p>A Small test equates neatly to a unit test, a Large test to an end-to-end or system test and a Medium test to tests that ensure that two tiers in an application can communicate properly (often called an integration test).</p>
<p>@SmallTest：测试代码中不与任何的文件系统或网络交互。<br>@MediumTest：测试代码中访问测试用例运行时所在的设备的文件系统。<br>@LargeTest：测试代码中访问外部的文件系统或网络。</p>
<p>FeatureSmallMediumLarge</p>
<p>Network accessNolocalhost onlyYes</p>
<p>DatabaseNoYesYes</p>
<p>File system accessNoYesYes</p>
<p>Use external systemsNoDiscouragedYes</p>
<p>Multiple threadsNoYesYes</p>
<p>Sleep statementsNoYesYes</p>
<p>System propertiesNoYesYes</p>
<p>Time limit (seconds)60300900+</p>
<ol>
<li>在测试函数的前面一行添加@SmallTest或@MedimuTest或@LargeTest</li>
<li>将测试代码的apk文件安装到设备后执行如下命令<br> adb shell am instrument -e size small/medium/large -w &lt;test_package_name&gt;/&lt;test_runner_class&gt;</li>
</ol>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Intent</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Intent/</url>
    <content><![CDATA[<p><a href="http://developer.android.com/guide/components/intents-common.html">http://developer.android.com/guide/components/intents-common.html</a></p>
<p>public void openWebPage(String url) {<br>Uri webpage = Uri.parse(url);<br>Intent intent = new Intent(Intent.ACTION_VIEW, webpage);<br>if (intent.resolveActivity(getPackageManager()) != null) {<br>        startActivity(intent);<br>}<br>}</p>
<p>public void createAlarm(String message, int hour, int minutes) {<br>Intent intent = new Intent(AlarmClock.ACTION_SET_ALARM)<br>.putExtra(AlarmClock.EXTRA_MESSAGE, message)<br>.putExtra(AlarmClock.EXTRA_HOUR, hour)<br>.putExtra(AlarmClock.EXTRA_MINUTES, minutes);<br>if (intent.resolveActivity(getPackageManager()) != null) {<br>        startActivity(intent);<br>}<br>}</p>
<p>&lt;uses-permission android:name=&quot;com.android.alarm.permission.SET_ALARM&quot; /&gt;</p>
<p>To create a countdown timer, use the ACTION_SET_TIMER action and specify timer details such as the duration using extras defined below.</p>
<p>public void startTimer(String message, int seconds) {<br>Intent intent = new Intent(AlarmClock.ACTION_SET_TIMER)<br>.putExtra(AlarmClock.EXTRA_MESSAGE, message)<br>.putExtra(AlarmClock.EXTRA_LENGTH, seconds)<br>.putExtra(AlarmClock.EXTRA_SKIP_UI, true);<br>if (intent.resolveActivity(getPackageManager()) != null) {<br>        startActivity(intent);<br>}<br>}</p>
<p>public void addEvent(String title, String location, Calendar begin, Calendar end) {<br>Intent intent = new Intent(Intent.ACTION_INSERT)<br>.setData(Events.CONTENT_URI)<br>.putExtra(Events.TITLE, title)<br>.putExtra(Events.EVENT_LOCATION, location)<br>.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, begin)<br>.putExtra(CalendarContract.EXTRA_EVENT_END_TIME, end);<br>if (intent.resolveActivity(getPackageManager()) != null) {<br>        startActivity(intent);<br>}<br>}</p>
<p>Capture a picture or video and return it</p>
<p>static final int REQUEST_IMAGE_CAPTURE = 1;<br>static final Uri mLocationForPhotos;<br>public void capturePhoto(String targetFilename) {<br>Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);<br>    intent.putExtra(MediaStore.EXTRA_OUTPUT,<br>Uri.withAppendedPath(mLocationForPhotos, targetFilename);<br>if (intent.resolveActivity(getPackageManager()) != null) {<br>        startActivityForResult(intent, REQUEST_IMAGE_CAPTURE);<br>}<br>}<br>@Override<br>protected void onActivityResult(int requestCode, int resultCode, Intent data) {<br>if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) {<br>Bitmap thumbnail = data.getParcelable(&quot;data&quot;);<br>// Do other work with full size photo saved in mLocationForPhotos<br>…<br>}<br>}</p>
<p>public void playMedia(Uri file) {<br>Intent intent = new Intent(Intent.ACTION_VIEW);<br>    intent.setData(file);<br>if (intent.resolveActivity(getPackageManager()) != null) {<br>        startActivity(intent);<br>}<br>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>I don&#39;t even know where to start</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/I%C2%A0don&#39;t%C2%A0even%C2%A0know%C2%A0where%C2%A0to%C2%A0start./</url>
    <content><![CDATA[<p> I don’t even know where to start.</p>
<p>我不知道该如何开始，<br>You make my heart pound so fast and I can’t even catch my breath.  </p>
<p>你使我的心跳加速，跳得很快，甚至喘不过气来。<br>You give me goose bumps all over my body and you’re all I think about. </p>
<p>你溶于我全身的每一个细胞，满脑子都是你。<br>I’ve never had a love like this before and I’ve never felt this way. I want to keep you forever.  </p>
<p>我从来就没如此般爱的感觉，我想一直拥有你。</p>
<p>Truthfully, and undoubtedly, I can fool anyone but I cannot fool myself. </p>
<p>实话说，无庸置疑的，我可以欺骗任何人，但是我却骗不了自己。</p>
<p>I would be a great liar if I uttered that I’m not in love with you. </p>
<p>我可以是一个伟大的说谎者，如果我说我不爱你的话。</p>
<p>No matter what you think or say, all I can say is : I really love you with all my heart and I will not hesitate if you will give me just a little time to prove my feelings of endearment and to prove to you that I’m deserving of your feelings, from your heart.</p>
<p>不管你怎么想，怎么说，我所能说的是：我真的全心全意地爱你。</p>
<p>如果你能给我一些时间去证明我对你的感觉和钟爱，我会毫不犹豫地去证明，我是值得你倾心，用心去爱的人。</p>
<p>Since I met you I felt I was living in a new and wonderful world, full of love. </p>
<p>自从我遇见了你，我感觉到自己生活在一个充满爱的，美好的新世界里。</p>
<p>And the sun is brighter, the pastures became greener and everything I do was magnificent. </p>
<p>太阳更明媚了，草地变得更绿了，感觉自己做什么事都是华丽的。</p>
<p>You should inculcate and instill in your mind that &quot;I cherish you so much&quot;. </p>
<p>你应该渐渐地、反复地在意识中告诉自己，我是多么地珍惜你。</p>
<p>Such love, like everything, deserves to be given much attention and care in order to grow more and more.</p>
<p>这份爱，就像是一切，应该值得给予更多的关注和爱护，让它更好的成长。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 垃圾回收机制和调优手段</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/JVM%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/</url>
    <content><![CDATA[<p>引言：</p>
<p>我们都知道JVM内存由几个部分组成：堆、方法区、栈、程序计数器、本地方法栈</p>
<p>JVM垃圾回收仅仅针对公共内存区域即：堆和方法区进行。</p>
<p>本文主要讨论两点，一是垃圾回收策略，二是调优的方法。</p>
<p>一、垃圾回收机制</p>
<p>1.1 分代管理</p>
<p>将堆和方法区按照对象不同年龄进行分代：</p>
<p>u  堆中会频繁创建对象，基于一种分代的思想，按照对象存活时间将堆划分为新生代和旧生代两部分，我们不能一次垃圾回收新生代存活的对象就放入旧生代，而是要经过几次GC后还存活的对象，我们才放入旧生代，所以我们又把新生代再次划分为Eden区和两个Survivor区，让对象创建在Eden区，然后在两个Survivor之间反复复制，最后仍然存活的对象才复制到旧生代中。</p>
<p>u  方法区存放的是常量、加载的字节码文件信息等，信息相对稳定。因为不会频繁创建对象，所以不需要分代，直接GC即可。</p>
<p>由此我们JVM垃圾回收要扫描的范围是：</p>
<p>新生代：</p>
<p>1.      所有新对象创建发生在Eden区，Eden区满后触发新生代上的minor GC，将Eden区和非空闲Survivor区存活对象复制到另一个空闲的Survivor区中。</p>
<p>2.      永远保证一个Survivor是空的，新生代minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。</p>
<p>旧生代：</p>
<p>1.      Eden区满后触发minor GC将存活对象复制到Survivor区，Survivor区满后触发minor GC将存活对象复制到旧生代。</p>
<p>2.      经过新生代的两个Survivor之间多次复制，仍然存活下来的对象就是年龄相对比较老的，就可以放入到旧生代了，随着时间推移，如果旧生代也满了，将触发Full GC，针对整个堆（包括新生代、旧生代和持久代）进行垃圾回收。</p>
<p>持久代：</p>
<p>持久代如果满，将触发Full GC</p>
<p>1.2 垃圾回收</p>
<p>要执行gc关键在于两点，一是检测出垃圾对象，二是释放垃圾对象所占用的空间。</p>
<p>1.2.1 检测垃圾对象</p>
<p>检测出垃圾对象一般有两种算法：</p>
<p>1、 引用计数法</p>
<p>2、 可达性分析</p>
<p>引用计数法因为无法检测对象之间相互循环引用的问题，基本没有被采用。现在主流的语言的垃圾收集中检测垃圾对象主要还是“可达性分析”方法，下面也主要介绍JVM可达性分析方法检测垃圾对象。</p>
<p>“可达性分析”算法描述？</p>
<p>通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。所以JVM判断对象需要存活的原则是：能够被一个根对象到达的对象。</p>
<p>什么是能够到达呢？</p>
<p>就是对象A中引用了对象B，那么就称A到B可达。</p>
<p>GCRoot对象集合？</p>
<p>a. java虚拟机栈(栈帧中的本地变量表)中的引用的对象。</p>
<p>b.方法区中的类静态属性引用的对象。</p>
<p>c.方法区中的常量引用的对象。</p>
<p>d.本地方法栈中JNI本地方法的引用对象。</p>
<p>1.2.2 释放空间</p>
<p>1、垃圾回收算法</p>
<p>前面已经介绍了如何检测出垃圾对象，在检测出垃圾对象之后，需要按照特定的垃圾回收算法进行内存回收，常见的垃圾回收算法包括：</p>
<p>u  复制(Copying)</p>
<p>u  标记-清除(Mark-Sweep)</p>
<p>u  标记-整理(Mark-Compact)</p>
<p>u  分代(Generational Collection)，借助前面三种算法实现</p>
<p>这里就不一一详述，感兴趣可以自行百度。</p>
<p>2、垃圾收集器实现</p>
<p>上面算法都是理论性的东西，Java虚拟机规范没有规定垃圾收集器具体如何实现，因此不同厂商、不同版本虚拟机提供的垃圾收集器可能有所差异。下面列举HotSpot(Sun JDK和Open JDK自带)虚拟机提供的六种垃圾收集器实现：</p>
<p>收集器名称</p>
<p>应用目标</p>
<p>采用算法</p>
<p>引入版本</p>
<p>运行方式</p>
<p>Serial</p>
<p>新生代</p>
<p>复制算法</p>
<p>Jdk1.3.1前</p>
<p>串行，单线程</p>
<p>ParNew</p>
<p>新生代</p>
<p>复制算法</p>
<p>并行，多线程</p>
<p>Parallel Scavenge</p>
<p>新生代</p>
<p>复制算法</p>
<p>Jdk1.4</p>
<p>并行，多线程</p>
<p>Serial Old</p>
<p>旧生代</p>
<p>标记-整理</p>
<p>串行，单线程</p>
<p>Parallel Old</p>
<p>旧生代</p>
<p>标记-整理</p>
<p>Jdk1.6</p>
<p>并行，多线程</p>
<p>CMS</p>
<p>旧生代</p>
<p>标记-清除</p>
<p>Jdk1.5</p>
<p>并发，多线程</p>
<p>并行(Parallel)：多条垃圾收集线程并行工作，而用户线程仍处于等待状态</p>
<p>并发(Concurrent)：垃圾收集线程与用户线程一段时间内同时工作(不是并行，而是交替执行)</p>
<p>总结：</p>
<p>1、  两个串行收集器、三个并行收集器、一个并发收集器。</p>
<p>2、  ParNew收集器是Serial的多线程版本，Parallel Scavenge收集器与ParNew的主要区别是目标不同，前者是注重尽可能缩短回收新生代垃圾时用户线程的停顿时间，后者以吞吐量为目标，适合在后台运算而不需要太多交互的任务。</p>
<p>3、  Serial Old收集器是Serial收集器的旧生代版本。</p>
<p>4、  Parallel Old收集器是Parallel Scavenge的旧生代版本。</p>
<p>5、  除CMS外，其他收集器工作时都需要暂停其他所有线程，CMS是第一款真正意义上的并发(Concurrent)收集器，第一次实现了让垃圾收集器线程与用户线程同时工作。</p>
<p>6、  Parallel Scavenge收集器和Parallel Old收集器是名副其实的“吞吐量优先”组合。</p>
<p>7、  新生代因为回收留下的对象少，所以采用标记-复制法。</p>
<p>8、  旧生代因为回收留下的对象多，所以采用标记-清除/标记-整理算法。</p>
<p>3、选择所需垃圾收集器</p>
<p>虚拟机提供了参数，以便用户根据自己的需求设置所需的垃圾收集器：</p>
<p>JVM运行参数</p>
<p>新生代</p>
<p>旧生代</p>
<p>-XX:+UseSerialGC（Client模式默认值）</p>
<p>Serial</p>
<p>Serial Old</p>
<p>-XX:+UseParNewGC</p>
<p>ParNew</p>
<p>Serial Old</p>
<p>-XX:+UseConcMarkSweepGC</p>
<p>ParNew</p>
<p>CMS(Serial Old备用)</p>
<p>-XX:+UseParallelGC（Server模式默认值）</p>
<p>Parallel Scavenge</p>
<p>Serial Old</p>
<p>-XX:+UseParallelOldGC</p>
<p>Parallel Scavenge</p>
<p>Parallel Old</p>
<p>二、性能调优</p>
<p>2.1 性能调优的目的</p>
<p>减少minor gc的频率、以及full gc的次数</p>
<p>2.2 性能调优的手段</p>
<p>1.使用JDK提供的内存查看工具，如JConsole和Java VisualVM</p>
<p>2.控制堆内存各个部分所占的比例</p>
<p>3.采用合适的垃圾收集器</p>
<p>手段1：内存查看工具和GC日志分析</p>
<p>n  -verbose.gc：显示GC的操作内容。打开它，可以显示最忙和最空闲收集行为发生的时间、收集前后的内存大小、收集需要的时间等。</p>
<p>n  -xx:+printGCdetails：详细了解GC中的变化。</p>
<p>n  -XX:+PrintGCTimeStamps：了解这些垃圾收集发生的时间，自JVM启动以后以秒计量。</p>
<p>n  -xx:+PrintHeapAtGC：了解堆的更详细的信息。</p>
<p>手段2：针对新生代和旧生代的比例</p>
<p>如果新生代太小，会导致频繁GC，而且大对象对直接进入旧生代引发full gc</p>
<p>如果新生代太大，会诱发旧生代full gc，而且新生代的gc耗时会延长</p>
<p>建议新生代占整个堆1/3合适，相关JVM参数如下：</p>
<p>n  -Xms:初始堆大小</p>
<p>n  -Xmx:最大堆大小</p>
<p>n  - Xmn:新生代大小</p>
<p>n  -XX:PermSize=n:持久代最大值</p>
<p>n  -XX:MaxPermSize=n:持久代最大值</p>
<p>n  -XX:NewRatio=n:设置新生代和旧生代的比值。如:为3，表示新生代与旧生代比值为1：3，新生代占整个新生代旧生代和的1/4</p>
<p>手段3：针对Eden和Survivor的比例</p>
<p>如果Eden太小，会导致频繁GC</p>
<p>如果Eden太大，会导致大对象直接进入旧生代，降低对象在新生代存活时间</p>
<p>n  -XX:SurvivorRatio=n:新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</p>
<p>n  -XX:PretenureSizeThreshold：直接进入旧生代中的对象大小，设置此值后，大于这个参数的对象将直接在旧生代中进行内存分配。</p>
<p>n  -XX:MaxTenuringThreshold：对象转移到旧生代中的年龄，每个对象经历过一次新生代GC（Minor GC）后，年龄就加1，到超过设置的值后，对象转移到旧生代。</p>
<p>手段4：采用正确的垃圾收集器</p>
<p>通过JVM参数设置所使用的垃圾收集器参考前面的介绍，这里关注其他一些设置。</p>
<p>并行收集器设置</p>
<p>n  -XX:ParallelGCThreads=n:设置并行收集器收集时并行收集线程数</p>
<p>n  -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间，仅对ParallelScavenge生效</p>
<p>n  -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比，仅对Parallel Scavenge生效</p>
<p>并发收集器设置</p>
<p>n  -XX:CMSInitiatingOccupancyFraction：默认设置下，CMS收集器在旧生代使用了68%的空间后就会被激活。此参数就是设置旧生代空间被使用多少后触发垃圾收集。注意要是CMS运行期间预留的内存无法满足程序需要，就会出现concurrent mode failure，这时候就会启用Serial Old收集器作为备用进行旧生代的垃圾收集。</p>
<p>n  -XX:+UseCMSCompactAtFullCollection：空间碎片过多是标记-清除算法的弊端，此参数设置在FULL GC后再进行一个碎片整理过程</p>
<p>n  -XX:CMSFullGCsBeforeCompaction：设置在若干次垃圾收集之后再启动一次内存碎片整理</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Java 注意点及socket</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Java%20%E6%B3%A8%E6%84%8F%E7%82%B9%E5%8F%8Asocket/</url>
    <content><![CDATA[<p>1.</p>
<p>变量在栈，对象在堆。</p>
<p>包装类 Interge foo = 10; 自动装箱  自动拆箱</p>
<p>string s=&quot;str&quot; + &quot;str2&quot;;</p>
<p>2.</p>
<p>父类动态绑定后可以调用子类方法</p>
<p>除static fianl 修饰外，其他都是动态绑定</p>
<p>JVM与DVM区别</p>
<p>DVM</p>
<p>1.基于寄存器</p>
<p>2.解释器可用汇编 arm java指令</p>
<p>3.java-&gt;.class-&gt;.dex</p>
<p>socket:</p>
<p>client </p>
<p>import java.net.Socket</p>
<p>1.Socket socket = new Socket(addr,port);</p>
<p>2.DataInputStream dis;</p>
<p>  DataOutputstream dos;</p>
<p>  dis = new DataInputStream(socket.getInputStream());</p>
<p>  dos = new DataOutputStream(socket.getOutputStream());</p>
<p>  dis.readUTF();</p>
<p>  dos.writeUTF();</p>
<p>3.close</p>
<p>server:</p>
<p>import java.net.ServerSocket;</p>
<p>import java.net.Socket</p>
<p>1.ServerSocker ss = new ServerSocker(port);</p>
<p>2.Socket socket = ss.accept();</p>
<p>3.DataInputStream dis;</p>
<p>  DataOutputstream dos;</p>
<p>  dis = new DataInputStream(socket.getInputStream());</p>
<p>  dos = new DataOutputStream(socket.getOutputStream());</p>
<p>  dis.readUTF();</p>
<p>  dos.writeUTF();</p>
<p>4.close</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>KeyguardServiceDelegate</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/KeyguardServiceDelegate/</url>
    <content><![CDATA[<p> import com.android.internal.policy.impl.keyguard.KeyguardServiceDelegate;</p>
<p>LOCAL_JAVA_LIBRARIES := telephony-common</p>
<p>/////include $(BUILD_JAVA_LIBRARY)</p>
<p> KeyguardServiceDelegate mKeyguardDelegate;</p>
<p> mKeyguardDelegate = new KeyguardServiceDelegate(mContext, null);</p>
<p>            mKeyguardDelegate.onSystemReady();</p>
<p>        } </p>
<p>if (mKeyguardDelegate != null) {</p>
<p>            mKeyguardDelegate.setKeyguardEnabled(enabled);</p>
<p>        }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>LCD 配置 OUT_FACE FORMAT</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/LCD%20%E9%85%8D%E7%BD%AE%20OUT_FACE%20FORMAT/</url>
    <content><![CDATA[<p>对于18BIT 的屏幕，这种屏幕的LVDS data format 一般如图（5）所示：</p>
<p>如果只使用主控的一个LCDC+RK610/RK616 的Scaler 实现双显，必须把</p>
<p>OUT_FACE 定义为OUT_P888_D666,LVDS_FORMAT 定义为LVDS_8BIT_2，否则在HDMI 模</p>
<p>式下，屏幕显示会异常。</p>
<p>上图说明在Y0 通道上传输的是R0<del>R5 和G0，在Y1 通道上传输的是G1</del>G5 和B0、</p>
<p>B1，在Y2 通道上传输的是B2~B5 和VSYNC、HSYNC 及DEN，在Y3 通道上传输的是各种</p>
<p>颜色的高两位。参考rk_screen.h 中的定义，我们知道，这个格式对应LVDS_8BIT_1。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>LCD</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/LCD/</url>
    <content><![CDATA[<p>1、概念</p>
<p>VSS(V Sync Start)是帧同步信号，每发出一个脉冲，都意味着新的一屏图像数据开始发送。</p>
<p>HSS(H Sync Start) 是行同步信号，每发出一个脉冲都表明新的一行图像资料开始发送。</p>
<p>HBP( Horizontal back porch )：前消隐所需要的周期</p>
<p>HFP( Horizontal front porch )：后消隐所需要的周期</p>
<p>2、帧同步以及行同步的头尾都必须留有回扫时间。这样的时序安排起源于 CRT 显示器电</p>
<p>子枪偏转所需要的时间，但后来成为实际上的工业标准，因此 TFT 屏也包含了回扫时<br>间，虽然对于 TFT 来说，这是不需要的。</p>
<p>3、正常的TFT一行的显示周期是 前消隐+实际点输出+后消隐</p>
<p>如果前消隐设置小了,后消隐设置大了,LCD控制器的实际输出就会被当做消隐而不会实际显示出来,看到的效果就是图像左移,反之图像右移 <br>如果前后消隐都设置小了,理论上第二行的图像可能会被当做第一行的图像显示,照成屏幕歪斜不同步,但是有些TFT中内部的时序电路会自动补上缺少的时钟,所以也不一定会看到不同步的画面<br>场的消隐同理<br>至于为什么要消隐是为了兼容CRT显示器的显示原理,CRT显示器每一个扫描行完成后,电子枪需要回扫,这段时间不能显示,所以这段时间的视频信号需要暂停一下,就是消隐. </p>
<p>4、一帧图像时间计算：</p>
<p>VSPW：帧同步信号的脉宽，单位为1行（Line）的时间。</p>
<p>VFPD: 帧同步信号的前肩，单位为1行（Line）的时间。</p>
<p>VBPD: 帧同步信号的后肩，单位为1行（Line）的时间。</p>
<p>LINEVAL ：帧显示尺寸-1，即屏行宽-1，对于800*480分配率的LCD屏，那么LINEVAL=480-1=479，请记住，是屏行宽，也就是LCD屏显示一帧数据所需要的行的数目。</p>
<p>HBPD：行同步信号的后肩，单位为1VCLK的时间。</p>
<p>HFPD：行同步信号的前肩，单位为1VCLK的时间。</p>
<p>HSPW：行同步信号的脉宽，单位为1VCLK的时间。</p>
<p>HOZVAL：行显示尺寸-1，即屏列宽-1,对于800*480分配率的LCD屏，那么HOZVAL=800-1=799，请记住，是屏列宽，也就是LCD屏显示一行数据所需要的像素(pixel)的数目。</p>
<p>由图可知：</p>
<p>扫描一帧所需的时间：</p>
<p>=((VSPW+1)+(VBPD+1)+( LINEVAL+1)+(VFPD+1))个行时间。</p>
<p>扫描一行所所需的时间：</p>
<p>= ((HSPW+1)+(HSPD+1)+(HFPD+1)+ (HOZVAL+1))个VCLK时间。</p>
<p>因此扫描一帧所需的时间：</p>
<p>T=[(VSPW+1)+(VBPD+1)+(LINEVAL+1)+(VFPD+1)]*[(HSPW+1)+(HSPD+1)+(HFPD+1)+ (HOZVAL+1)]*VCLK</p>
<p>并没有直接告诉 HFP、HSYNC、HBP、VFP、VSYNC、<br>VBP 这些参数，而给的是 Horizontal blank time 和 Vertical blank time，这时我们<br>只要保证如下关系即可：<br>HFB + HSYNC + HBP = Horizontal blank time<br>VFP + VSYNC + VBP = vertical blank time</p>
<p>实例：</p>
<p>在 LCD 驱动中，还有一个重要的参数—-点时钟，即 dot clock，在 LCD 的 data<br>sheet 里面一般是 MHZ，名称为 PCLK 或者 DCLK(RK dtsi代码中的clock-frequency)。例如，如果为 28.37516 MHz，那么画<br>1 个像素需要 35242 ps（皮秒）：<br>1/(28.37516E6 Hz) = 35.242E-9 s<br>如果屏幕的分辨率是 640×480，显示一行需要的时间是：<br>640*35.242E-9 s = 22.555E-6 s<br>每条扫描线是 640，但是水平回扫和水平同步也需要时间，假设水平回扫同步需<br>要 272 个像素时钟，因此，画一条扫描线完整的时间是：<br>(640+272)*35.242E-9 s = 32.141E-6 s<br>可以计算出水平扫描率大约是 31kHz：<br>1/(32.141E-6 s) = 31.113E3 Hz<br>完整的屏幕有 480 线，但是垂直回扫和垂直同步也需要时间，假设垂直回扫和垂<br>直同步需要 49 个象素时钟，因此，画一个完整的屏幕的时间是：<br>(480+49)*32.141E-6 s = 17.002E-3 s。</p>
<p>假设mipi phy有4个lane，每个像素3*8bit表示</p>
<p>17.002E-3 s=</p>
<p>ddr_clock*(xres+left_margin+right_margin+hsync)<em>(yres+upper_margin+low_margin+vsync)3</em>8/4</p>
<p>可以计算出ddr_clock。</p>
<p>可以计算出垂直扫描率大约是 59kHz：<br>1/(17.002E-3 s) = 58.815 Hz<br>这意味着屏幕数据每秒钟大约刷新 59 次。<br>由此可以得到如下公式：<br>刷新率 =dotclock/(（xres+left_margin+right_margin+hsync）<br>*(yres+upper_margin+low_margin+vsync))</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>LCDC刷新频率</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/LCDC%E5%88%B7%E6%96%B0%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<p>cat sys/class/graphics/fb*/fps</p>
<p>cat proc/clocks | busybox grep -r lcdc</p>
<p>Android 的最高刷新频率为60fps，所以我们最好保证LCDC 的刷新频率也为60fps，</p>
<p>根据文档第一部分介绍的LCDC 的刷新频率计算公式可以知道，</p>
<p>LCDC 的刷新频率和DCLK 成正比，和水平方向与垂直方向参数之和的乘积成反比。</p>
<p>写颜色：</p>
<p>cat sys/class/graphics/fb0/disp_info</p>
<p>YRGB buffer addr:0x9a800000</p>
<p>stop //停止刷新</p>
<p>io -w -4 -l 0x3e8000(数据长度1280<em>800</em>4)  0x9a800000  0x00ff0000 红色</p>
<p>io -w -4 -l 0x3e8000  0x9a800000  0x0000ff00 绿色</p>
<p>io -w -4 -l 0x3e8000  0x9a800000  0x000000ff 蓝色</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>LCD时序</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/LCD%E6%97%B6%E5%BA%8F/</url>
    <content><![CDATA[<p>kernel/drivers/video/display/screen/lcd_hdmi_1024x768.c</p>
<p>/* Base */</p>
<p>#define OUT_TYPE SCREEN_RGB//SCREEN_LVDS</p>
<p>#define OUT_FORMAT      LVDS_8BIT_2</p>
<p>#define OUT_FACE OUT_P888//OUT_D888_P666  </p>
<p>#define OUT_CLK 65000000 // LCD _DCLK</p>
<p>#define LCDC_ACLK        500000000//312000000           //29 lcdc axi DMA 频率</p>
<p>/* Timing */</p>
<p>#define H_PW 10              //同步信号宽度</p>
<p>#define H_BP 150//160     //同步信号后消隐</p>
<p>#define H_VD 1024          //可视区域</p>
<p>#define H_FP 160            //同步信号前清隐</p>
<p>#define V_PW 10</p>
<p>#define V_BP 13//25</p>
<p>#define V_VD 768</p>
<p>#define V_FP 15</p>
<p>#define LCD_WIDTH       162             //LCD可视区域物理宽度(mm)</p>
<p>#define LCD_HEIGHT      121　　　　//LCD可视区域物理高度(mm)</p>
<p>…</p>
<p>#define S_DCLK_POL       0   //双屏时 DCLK反向</p>
<p>/* Other */</p>
<p>#define DCLK_POL 0          // LCD DCLK 反向</p>
<p>#define SWAP_RB 0          // LCD　红绿颜色交换</p>
<p>调试scaler参数（lcd上显示有横线等时序出错的现象）</p>
<p>cd ./sys/devices/platform/rk29_i2c.1/i2c-1/1–40/</p>
<p>catreg_ctl</p>
<p>屏驱动中的S_V_ST={reg[0x14],reg[13]};</p>
<p>echo13xx&gt;reg_ctl(向0x13寄存器写入值xx);</p>
<p>echo14xx&gt;reg_ctl(向0x14寄存器写入值xx)</p>
<p>RGB屏定义：</p>
<p>#defineOUT_TYPE SCREEN_RGB</p>
<p>LVDS屏定义：</p>
<p>#defineOUT_TYPE SCREEN_LVDS //LVDS屏要配成SCREEN_LVDS</p>
<p>#defineOUT_FORMAT LVDS_8BIT_2 //LVDS的接线方式</p>
<p>Scaler时钟反向：</p>
<p>#defineDCLK_POL 0 //bypass显示时，画面抖动，可以尝试将这个取反</p>
<p>#defineS_DCLK_POL 0 //当双屏显示画面抖动时，可以尝试将这个取反</p>
<p>查看/sys/class/hdmi/hdmi-0/state</p>
<p>/sys/class/hdmi/hdmi-0/enable</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>LCD的接口类型详解</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/LCD%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>LCD的接口类型详解</p>
<p>          LCD的接口有多种，分类很细。主要看LCD的驱动方式和控制方式，目前手机上的彩色LCD的连接方式一般有这么几种：MCU模式，RGB模式，SPI模式，VSYNC模式，MDDI模式，DSI模式。MCU模式（也写成MPU模式的）。只有TFT模块才有RGB接口。</p>
<p>但应用比较多的就是MUC模式和RGB模式，区别有以下几点：</p>
<p>1.MCU接口:会解码命令，由timing generator产生时序信号，驱动COM和SEG驱器。</p>
<p>   RGB接口:在写LCD register setting时，和MCU接口没有区别。区别只在于图像的写入方式。 </p>
<p>2.用MCU模式时由于数据可以先存到IC内部GRAM后再往屏上写，所以这种模式LCD可以直接接在MEMORY的总线上。</p>
<p>   用RGB模式时就不同了，它没有内部RAM，HSYNC，VSYNC，ENABLE，CS，RESET，RS可以直接接在MEMORY的GPIO口上，用GPIO口来模拟波形. </p>
<p>3.MPU接口方式：显示数据写入DDRAM，常用于静止图片显示。</p>
<p>    RGB接口方式：显示数据不写入DDRAM，直接写屏，速度快，常用于显示视频或动画用。</p>
<p>MCU接口和RGB接口主要的区别是：</p>
<p>                          MCU接口方式：显示数据写入DDRAM，常用于静止图片显示。</p>
<p>                          RGB接口方式：显示数据不写入DDRAM，直接写屏，速度快，常用于显示视频或动画用。</p>
<p>          MCU模式</p>
<p>            因为主要针对单片机的领域在使用,因此得名.后在中低端手机大量使用,其主要特点是价格便宜的。MCU-LCD接口的标准术语是Intel提出的8080总线标准，因此在很多文档中用I80 来指MCU-LCD屏。主要又可以分为8080模式和6800模式，这两者之间主要是时序的区别。数据位传输有8位，9位，16位，18位，24位。连线分为：CS/，RS(寄存器选择），RD/，WR/，再就是数据线了。优点是：控制简单方便，无需时钟和同步信号。缺点是：要耗费GRAM，所以难以做到大屏（3.8以上）。对于MCU接口的LCM，其内部的芯片就叫LCD驱动器。主要功能是对主机发过的数据/命令，进行变换，变成每个象素的RGB数据，使之在屏上显示出来。这个过程不需要点、行、帧时钟。</p>
<p>         MCU接口的LCD的Driver IC都带GRAM，Driver IC作为MCU的一片协处理器，接受MCU发过来的Command/Data，可以相对独立的工作。对于MCU接口的LCM（LCD Module），其内部的芯片就叫LCD驱动器。主要功能是对主机发过的数据/命令，进行变换，变成每个象素的RGB数据，使之在屏上显示出来。这个过程不需要点、行、帧时钟。</p>
<p>           M6800模式</p>
<p>           M6800模式支持可选择的总线宽度8/9/16/18-bit（默认为8位），其实际设计思想是与I80的思想是一样的，主要区别就是该模式的总线控制读写信号组合在一个引脚上（/WR），而增加了一个锁存信号(E)数据位传输有8位，9位，16位和18位。</p>
<p>              I8080模式</p>
<p>              I80模式连线分为：CS/，RS(寄存器选择），RD/，WR/，再就是数据线了。优点是：控制简单方便，无需时钟和同步信号。缺点是：要耗费GRAM，所以难以做到大屏（QVGA以上）。</p>
<p>MCU接口标准名称是I80，管脚的控制脚有5个：</p>
<p>CS 片选信号 RS (置1为写数据,置0为写命令） /WR （为0表示写数据) 数据命令区分信号 /RD （为0表示读数据） RESET 复位LCD（ 用固定命令系列 0 1 0来复位)  </p>
<p>VSYNC模式</p>
<p>该模式其实就是就是在MCU模式上加了一个VSYNC信号，应用于运动画面更新，这样就与上述两个接口有很大的区别。该模式支持直接进行动画显示的功能，它提供了一个对MCU接口最小的改动，实现动画显示的解决方案。在这种模式下，内部的显示操作与外部VSYNC信号同步。可以实现比内部操作更高的速率的动画显示。但由于其操作方式的不同，该模式对速率有一个限制，那就是对内部SRAM的写速率一定要大于显示读内部SRAM的速率。</p>
<p>   RGB模式</p>
<p>          大屏采用较多的模式，数据位传输也有6位，16位和18位，24位之分。连线一般有：VSYNC，HSYNC，DOTCLK，CS，RESET，有的也需要RS，剩下就是数据线。它的优缺点正好和MCU模式相反。</p>
<p>          MCU-LCD屏它与RGB-LCD屏主要区别在于显存的位置。RGB-LCD的显存是由系统内存充当的，因此其大小只受限于系统内存的大小，这样RGB-LCD可以做出较大尺寸，象现在4.3&quot;只能算入门级，而MID中7&quot;,10&quot;的屏都开始大量使用。而MCU-LCD的设计之初只要考虑单片机的内存较小，因此都是把显存内置在LCD模块内部.然后软件通过专门显示命令来更新显存，因此MCU屏往往不能做得很大。同时显示更新速度也比RGB-LCD慢。显示数据传输模式也有差别。RGB屏只需显存组织好数据。启动显示后，LCD-DMA会自动把显存中的数据通过RGB接口送到LCM。而MCU屏则需要发送画点的命令来修改MCU内部的RAM（即不能直接写MCU屏的RAM）。所以RGB显示速度明显比MCU快，而且播放视频方面，MCU-LCD也比较慢。</p>
<p>         对于RGB接口的LCM，主机输出的直接是每个象素的RGB数据，不需要进行变换（GAMMA校正等除外），对于这种接口，需要在主机部分有个LCD控制器，以产生RGB数据和点、行、帧同步信号。</p>
<p>     彩色TFT液晶屏主要有2种接口：TTL接口（RGB颜色接口）， LVDS接口（将RGB颜色打包成差分信号传输）。TTL接口主要用于12.1寸一下的小尺寸TFT屏，LVDS接口主要用于8寸以上的大尺寸TFT屏。TTL接口线多，传输距离短；LVDS接口传输距离长，线的数量少。大屏采用较多的模式，控制脚是VSYNC，HSYNC，VDEN，VCLK， S3C2440最高支持24个数据脚，数据脚是VD[23-0]。</p>
<p>                 CPU或显卡发出的图像数据是TTL信号（0-5V、0-3.3V、0-2.5V、或0-1.8V），LCD本身接收的也是TTL信号，由于ＴＴＬ信号在高速率的长距离传输时性能不佳，抗干扰能力比较差，后来又提出了多种传输模式，比如LVDS、TDMS、GVIF、P&amp;D、DVI和DFP等。他们实际上只是将CPU或显卡发出的TTL信号编码成各种信号以传输，在LCD那边将接收到的信号进行解码得到ＴＴＬ信号。</p>
<p>                  但是不管采用何种传输模式，本质的TTL信号是一样的。</p>
<p>注意：TTL/LVDS分别是两种信号的传输模式，TTL是高电平表示1，低电平表示0的模式，LVDS是正负两个对应波形，用两个波形的差值来表示当前是1还是0</p>
<p>          SPI模式</p>
<p>             采用较少，有3线和4线的，连线为CS/，SLK，SDI，SDO四根线，连线少但是软件控制比较复杂。</p>
<p>          MDDI模式（MobileDisplayDigitalInterface）</p>
<p>             高通公司于2004年提出的接口MDDI，通过减少连线可提高移动电话的可靠性并降低功耗，这将取代SPI模式而成为移动领域的高速串行接口。 连线主要是host_data,host_strobe,client_data,client_strobe,power,GND几根线。</p>
<p>          DSI模式</p>
<p>             该模式串行的双向高速命令传输模式，连线有D0P，D0N，D1P，D1N，CLKP，CLKN。    </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>LVDS (Low Voltage Differential Signaling)</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/LVDS%20(Low%20Voltage%20Differential%20Signaling)/</url>
    <content><![CDATA[<p>LVDS ： Low-Voltage Differential Signaling 低压差分信号传输</p>
<p>　　1994年由美国国家半导体公司提出的一种信号传输模式，是一种电平标准，广泛应用于液晶屏接口。它在提供高数据传输率的同时会有很低的功耗，另外它还有许多其他的优势：</p>
<p>　　1、低电压电源的兼容性</p>
<p>　　2、低噪声</p>
<p>　　3、高噪声抑制能力</p>
<p>　　4、可靠的信号传输</p>
<p>　　5、能够集成到系统级IC内</p>
<p>　　使用LVDS技术的的产品数据速率可以从几百Mbps到2Gbps。</p>
<p>　　它是电流驱动的，通过在接收端放置一个负载而得到电压，当电流正向流动，接收端输出为1，反之为0</p>
<p>　　他的摆幅为250mv-450mv</p>
<p>液晶显示器驱动板输出的数字信号中，除了包括RGB数据信号外，还包括行同步、场同步、像素时钟等信号，其中像素时钟信号的最高频率可超过28MHz。采用TTL接口，数据传输速率不高，传输距离较短，且抗电磁干扰（EMI）能力也比较差，会对RGB数据造成一定的影响；另外，TTL多路数据信号采用排线的方式来传送，整个排线数量达几十路，不但连接不便，而且不适合超薄化的趋势。采用LVDS输出接口传输数据，可以使这些问题迎刃而解，实现数据的高速率、低噪声、远距离、高准确度的传输。</p>
<p>1．LVDS接口</p>
<p>　　那么，什么是LVDS输出接口呢？LVDS，即Low Voltage Differential Signaling，是一种低压差分信号技术接口。它是美国NS公司（美国国家半导体公司）为克服以TTL电平方式传输宽带高码率数据时功耗大、EMI电磁干扰大等缺点而研制的一种数字视频信号传输方式。</p>
<p>　　LVDS输出接口利用非常低的电压摆幅（约350mV）在两条PCB走线或一对平衡电缆上通过差分进行数据的传输，即低压差分信号传输。采用LVDS输出接口，可以使得信号在差分PCB线或平衡电缆上以几百Mbit/s的速率传输，由于采用低压和低电流驱动方式，因此，实现了低噪声和低功耗。目前，LVDS输出接口在17in及以上液晶显示器中得到了广泛的应用。</p>
<p>2．LVDS接口电路的组成</p>
<p>　　在液晶显示器中，LVDS接口电路包括两部分，即驱动板侧的LVDS输出接口电路（LVDS发送器）和液晶面板侧的LVDS输入接口电路（LVDS接收器）。LVDS发送器将驱动板主控芯片输出的TTL电平并行RGB数据信号和控制信号转换成低电压串行LVDS信号，然后通过驱动板与液晶面板之间的柔性电缆（排线）将信号传送到液晶面板侧的LVDS接收器，LVDS接收器再将串行信号转换为TTL电平的并行信号，送往液晶屏时序控制与行列驱动电路。图1所示为LVDS接口电路的组成示意图。</p>
<p>　　在数据传输过程中，还必须有时钟信号的参与，LVDS接口无论传输数据还是传输时钟，都采用差分信号对的形式进行传输。所谓信号对，是指LVDS接口电路中，每一个数据传输通道或时钟传输通道的输出都为两个信号（正输出端和负输出端）。</p>
<p>　　需要说明的是，不同的液晶显示器，其驱动板上的LVDS发送器不尽相同，有些LVDS发送器为一片或两片独立的芯片（如DS90C383），有些则集成在主控芯片中（如主控芯片gm5221内部就集成了LVDS发送器）。</p>
<p>3．LVDS输出接口电路类型</p>
<p>　　与TTL输出接口相同，LVDS输出接口也分为以下四种类型：</p>
<p>　　（l）单路6位LVDS输出接口</p>
<p>　　这种接口电路中，采用单路方式传输，每个基色信号采用6位数据，共18位RGB数据，因此，也称18位或18bit LVDS接口。</p>
<p>　　（2）双路6位LVDS输出接口</p>
<p>　　这种接口电路中，采用双路方式传输，每个基色信号采用6位数据，其中奇路数据为18位，偶路数据为18位，共36位RGB数据，因此，也称36位或36bit LVDS接口。</p>
<p>　　（3）单路8位1TL输出接口</p>
<p>　　这种接口电路中，采用单路方式传输，每个基色信号采用8位数据，共24位RGB数据，因此，也称24位或24bit LVDS接口。</p>
<p>　　（4）双路8位1TL输出位接口</p>
<p>　　这种接口电路中，采用双路方式传输，每个基色信号采用8位数据，其中奇路数据为24位，偶路数据为24位，共48位RGB数据，因此，也称48位或48bit LVDS接口</p>
<p>4．典型LVDS发送芯片介绍</p>
<p>　　典型的LVDS发送芯片分为四通道、五通道和十通道几种，下面简要进行介绍。</p>
<p>　　（1）四通道LVDS发送芯片</p>
<p>　　图2 所示为四通道LVDS发送芯片（DS90C365）内部框图。包含了三个数据信号（其中包括RGB、数据使能DE、行同步信号HS、场同步信号VS）通道和一个时钟信号发送通道。</p>
<p>　　4通道LVDS发送芯片主要用于驱动6bit液晶面板。使用四通道LVDS发送芯片可以构成单路6bit LVDS接自电路和奇/偶双路6bit LVDS接口电路。</p>
<p>　　（2）五通道LVDS发送芯片</p>
<p>　　图3 所示为五通道LVDS发送芯片（DS90C385）内部框图。包含了四个数据信号（其中包括RGB、数据使能DE、行同步信号HS、场同步信号vs）通道和一个时钟信号发送通道。</p>
<p>　　五通道LVDS发送芯片主要用于驱动8bit液晶面板。使用五通道LVDS发送芯片主要用来构成单路8bit LVDS接口电路和奇/偶双路8bit LVDS接口电路。</p>
<p>　　（3）十通道LVDS发送芯片</p>
<p>　　图4所示为十通道LVDS发送芯片（DS90C387）内部框图。包含了八个数据信号（其中包括RGB、数据使能DE、行同步信号HS、场同步信号VS）通道和两个时钟信号发送通道。</p>
<p>　　十通道LVDS发送芯片主要用于驱动8bit液晶面板。使用十通道LVDS发送芯片主要用来构成奇/偶双路8bit LVDS位接口电路。</p>
<p>　　在十通道LVDS发送芯片中，设置了两个时钟脉冲输出通道，这样做的目的是可以更加灵活的适应不同类型的LVDS接收芯片。当LVDS接收电路同样使用一片十通道LVDS接收芯片时，只需使用一个通道的时钟信号即可；当LVDS接收电路使用两片五通道LVDS接收芯片时，十通道LVDS发送芯片需要为每个LVDS接收芯片提供单独的时钟信号。</p>
<p>5．LVDS发送芯片的输入与输出信号</p>
<p>（1）LVDS发送芯片的输入信号</p>
<p>　　LVDS发送芯片的输入信号来自主控芯片，输入信号包含RGB数据信号、时钟信号和控制信号三大类。</p>
<p>　　①数据信号：为了说明的方便，将RGB信号以及数据选通DE和行场同步信号都算作数据信号。</p>
<p>　　在供6bit液晶面板使用的四通道LVDS发送芯片中，共有十八个RGB信号输入引脚，分别是R0～R5红基色数据（6bit红基色数据，R0为最低有效位，R5为最高有效位）六个，G0～G5绿基色数据六个，B0～B5蓝基色数据六个；一个显示数据使能信号DE（数据有效信号）输入引脚；一个行同步信号HS输入引脚；一个场同步信号VS输入引脚。也就是说，在四通道LVDS发送芯片中，共有二十一个数据信号输入引脚。</p>
<p>　　在供8bit液晶面板使用的五通道LVDS发送芯片中，共有二十四个RGB信号输入引脚，分别是红基色数据R0～R7（8bit红基色数据，R0为最低有效位，R7为最高有效位）八个，绿基色数据G0～G7八个，蓝基色数据B0～B7八个；一个有效显示数据使能信号DE（数据有效信号）输入引脚；一个行同步信号HS输入引脚；一个场同步信号VS输入引脚；一个各用输入引脚。也就是说，在五通道LVDS发送芯片中，共有二十八个数据信号输入引脚。</p>
<p>　　应该注意的是，液晶面板的输入信号中都必须要有DE信号，但有的液晶面板只使用单一的DE信号而不使用行场同步信号。因此，应用于不同的液晶面板时，有的LVDS发送芯片可能只需输入DE信号，而有的需要同时输入DE和行场同步信号。</p>
<p>　　②输入时钟信号：即像素时钟信号，也称为数据移位时钟（在LVDS发送芯片中，将输入的并行RGB数据转换成串行数据时要使用移位寄存器）。像素时钟信号是传输数据和对数据信号进行读取的基准。</p>
<p>　　③待机控制信号（POWER DOWN）：当此信号有效时（一般为低电平时），将关闭LVDS发送芯片中时钟PLL锁相环电路的供电，停止IC的输出。</p>
<p>　　④数据取样点选择信号：用来选择使用时钟脉冲的上升沿还是下降沿读取所输入的RGB数据。有的LVDS发送芯片可能并不设置待机控制信号和数据取样点选择信号，但也有的除了上述两个控制信号还设置有其他一些控制信号。</p>
<p>（2）LVDS发送芯片的输出信号</p>
<p>　　LVDS发送芯片将以并行方式输入的TTL电平RGB数据信号转换成串行的LVDS信号后，直接送往液晶面板侧的LVDS接收芯片。</p>
<p>　　LVDS发送芯片的输出是低摆幅差分对信号，一般包含一个通道的时钟信号和几个通道的串行数据信号。由于LVDS发送芯片是以差分信号的形式进行输出，因此，输出信号为两条线，一条线输出正信号，另一条线输出负信号。</p>
<p>　　①时钟信号输出：LVDS发送芯片输出的时钟信号频率与输入时钟信号（像素时钟信号）频率相同。时钟信号的输出常表示为：TXCLK+和TXCLK－，时钟信号占用LVDS发送芯片的一个通道。</p>
<p>　　②LVDS串行数据信号输出：对于四通道LVDS发送芯片，串行数据占用三个通道，其数据输出信号常表示为TXOUT0+、TXOUT0－，TXOUT1+、TXOUT1－，TXOUT2+、TXOUT2－。</p>
<p>　　对于五通道LVDS发送芯片，串行数据占用四个通道，其数据输出信号常表示为TXOUT0+、TXOUT0－，TXOUT1+、TXOUTI－，TXOUT2+、TXOUT2－，TXOUT3+、TXOUT3－。</p>
<p>　　对于十通道LVDS发送芯片，串行数据占用八个通道，其数据输出信号常表示为TXOUT0+、TXOUT0－，TXOUT1+、TXOUT1－，TXOUT2+、TXOUT2－，TXOUT3+、TXOUT3－，TXOUT4+、TXOUT4－，TXOUT5+、TXOUT5－，TXOUT6+、TXOUT6－，TXOUT7+、TXOLT7－。</p>
<p>　　如果只看电路图，是不能从LVDS发送芯片的输出信号TXOUT－、TXOUT0+中看出其内部到底包含哪些信号数据，以及这些数据是怎样排列的（或者说这些数据的格式是怎样的）。事实上，不同厂家生产的LVDS发送芯片，其输出数据排列方式可能是不同的。因此，液晶显示器驱动板上的LVDS发送芯片的输出数据格式必须与液晶面板LVDS接收芯片要求的数据格式相同，否则，驱动板与液晶面板不匹配。这也是更换液晶面板时必须考虑的一个问题。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Laucher3</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Laucher3/</url>
    <content><![CDATA[<p>src/com/android/launcher3/DynamicGrid.java</p>
<p>DynamicGrid()</p>
<p>//动态配置桌面</p>
<p>  deviceProfiles.add(new DeviceProfile(&quot;1024x600&quot;, 527, 960, 5, 6, 74, 14.4f, 7, 60));</p>
<p>        name = n;</p>
<p>        minWidthDps = w;</p>
<p>        minHeightDps = h;</p>
<p>        numRows = r;</p>
<p>        numColumns = c;</p>
<p>        iconSize = is;</p>
<p>        iconTextSize = its;</p>
<p>        numHotseatIcons = hs;</p>
<p>        hotseatIconSize = his;</p>
<p>//应用列表两边空隙</p>
<p>/res/layout/apps_customize_pane.xml</p>
<p>@@ -57,6 +57,8 @@</p>
<p>                 android:layout_width=&quot;match_parent&quot;</p>
<p>                 android:layout_height=&quot;match_parent&quot;</p>
<p>                 android:layout_marginBottom=&quot;@dimen/apps_customize_page_indicator_offset&quot;</p>
<ul>
<li><p>android:layout_marginLeft=&quot;@dimen/apps_customize_page_margin&quot;</p>
</li>
<li><p>android:layout_marginRight=&quot;@dimen/apps_customize_page_margin&quot;</p>
</li>
</ul>
<p>//不检查safeMode</p>
<p>framework/base</p>
<p>b/core/res/AndroidManifest.xml</p>
<p>@@ -2297,7 +2297,7 @@</p>
<p>         android:permissionGroup=&quot;android.permission-group.PERSONAL_INFO&quot;</p>
<p>         android:label=&quot;@string/permlab_bindGadget&quot;</p>
<p>         android:description=&quot;@string/permdesc_bindGadget&quot;</p>
<ul>
<li>android:protectionLevel=&quot;signature|system&quot; /&gt;</li>
</ul>
<ul>
<li>android:protectionLevel=&quot;normal&quot; /&gt;</li>
</ul>
<p>Laucher3</p>
<p>src/com/android/launcher3/LauncherModel.java</p>
<p>@@ -1830,7 +1830,7 @@ public class LauncherModel extends BroadcastReceiver {</p>
<p>                                 final AppWidgetProviderInfo provider =</p>
<p>                                         widgets.getAppWidgetInfo(appWidgetId);</p>
<ul>
<li>if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||</li>
</ul>
<ul>
<li>if ( (provider == null || provider.provider == null ||</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Laucher自定义文件夹addFolder</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Laucher%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E5%A4%B9addFolder/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Launcher2/res/values/strings.xml b/packages/apps/Launcher2/res/values/s</p>
<p>index 4aee339..1ecb747 100755</p>
<p>— a/packages/apps/Launcher2/res/values/strings.xml</p>
<p>+++ b/packages/apps/Launcher2/res/values/strings.xml</p>
<p>@@ -28,6 +28,7 @@</p>
<p>     &lt;string name=&quot;uid_name&quot;&gt;Android Core Apps&lt;/string&gt;</p>
<p>     &lt;!– Default folder name –&gt;</p>
<p>     &lt;string name=&quot;folder_name&quot;&gt;&lt;/string&gt;</p>
<ul>
<li>   &lt;string name=&quot;custom_folder_name&quot;&gt;Google&lt;/string&gt;</li>
</ul>
<p>     &lt;!– Title of dialog that appears after user selects Wallpaper from menu –&gt;</p>
<p>     &lt;string name=&quot;chooser_wallpaper&quot;&gt;Choose wallpaper from&lt;/string&gt;</p>
<p>     &lt;!– Button label on Wallpaper Gallery screen; user selects this button to set a specific wal</p>
<p>diff –git a/packages/apps/Launcher2/res/xml/default_workspace.xml b/packages/apps/Launcher2/res/x</p>
<p>index ff32ee7..7074beb 100755</p>
<p>— a/packages/apps/Launcher2/res/xml/default_workspace.xml</p>
<p>+++ b/packages/apps/Launcher2/res/xml/default_workspace.xml</p>
<p>+&lt;folder</p>
<ul>
<li><p>              launcher:title=&quot;@string/custom_folder_name&quot;</p>
</li>
<li><p>              launcher:screen=&quot;2&quot;</p>
</li>
<li><p>                      launcher:x=&quot;3&quot;</p>
</li>
<li><p>              launcher:y=&quot;2&quot;&gt;</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>              &lt;favorite</p>
</li>
<li><p>                      launcher:packageName=&quot;com.android.calculator2&quot;</p>
</li>
<li><p>                      launcher:className=&quot;com.android.calculator2.Calculator&quot; /&gt;</p>
</li>
<li><p>              &lt;favorite</p>
</li>
<li><p>                      launcher:packageName=&quot;android.rk.RockVideoPlayer&quot;</p>
</li>
<li><p>                      launcher:className=&quot;android.rk.RockVideoPlayer.RockVideoPlayer&quot; /&gt;</p>
</li>
</ul>
<p>+</p>
<ul>
<li>       &lt;/folder&gt;</li>
</ul>
<p> &lt;/favorites&gt;</p>
<p>diff –git a/packages/apps/Launcher2/src/com/android/launcher2/Folder.java b/packages/apps/Launche</p>
<p>index de2e435..8268931 100755</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/Folder.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/Folder.java</p>
<p>@@ -110,6 +110,7 @@ public class Folder extends LinearLayout implements DragSource, View.OnClickLi</p>
<p>     private static String sHintText;</p>
<p>     private ObjectAnimator mOpenCloseAnimator;</p>
<ul>
<li>      private static String coustomFolderName;</li>
</ul>
<p>     /**</p>
<p>      * Used to inflate the Workspace from XML.</p>
<p>      *</p>
<p>@@ -143,6 +144,7 @@ public class Folder extends LinearLayout implements DragSource, View.OnClickLi</p>
<p>         if (sHintText == null) {</p>
<p>             sHintText = res.getString(R.string.folder_hint_text);</p>
<p>         }</p>
<ul>
<li>              coustomFolderName = res.getString(R.string.custom_folder_name);</li>
</ul>
<p>         mLauncher = (Launcher) context;</p>
<p>         // We need this view to be focusable in touch mode so that when text editing of the folde</p>
<p>         // name is complete, we have something to focus on, thus hiding the cursor and giving</p>
<p>@@ -254,6 +256,7 @@ public class Folder extends LinearLayout implements DragSource, View.OnClickLi</p>
<p>         // Convert to a string here to ensure that no other state associated with the text field</p>
<p>         // gets saved.</p>
<p>         String newTitle = mFolderName.getText().toString();</p>
<ul>
<li>              if(!newTitle.equals(coustomFolderName))//edward</li>
</ul>
<p>         mInfo.setTitle(newTitle);</p>
<p>         LauncherModel.updateItemInDatabase(mLauncher, mInfo);</p>
<p>@@ -383,6 +386,8 @@ public class Folder extends LinearLayout implements DragSource, View.OnClickLi</p>
<p>         if (!sDefaultFolderName.contentEquals(mInfo.title)) {</p>
<p>             mFolderName.setText(mInfo.title);</p>
<ul>
<li><p>           if(mInfo.title.equals(coustomFolderName))</p>
</li>
<li><p>                      mFolderName.setInputType(InputType.TYPE_NULL);//edward ,forbid  input</p>
</li>
</ul>
<p>         } else {</p>
<p>             mFolderName.setText(&quot;&quot;);</p>
<p>         }</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/FolderIcon.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/FolderIcon.java</p>
<p>@@ -42,7 +42,7 @@ import android.widget.TextView;</p>
<p> import com.android.launcher.R;</p>
<p> import com.android.launcher2.DropTarget.DragObject;</p>
<p> import com.android.launcher2.FolderInfo.FolderListener;</p>
<p>-</p>
<p>+import android.util.Log;</p>
<p> import java.util.ArrayList;</p>
<p> /**</p>
<p>@@ -96,6 +96,7 @@ public class FolderIcon extends LinearLayout implements FolderListener {</p>
<p>     private PreviewItemDrawingParams mParams = new PreviewItemDrawingParams(0, 0, 0, 0);</p>
<p>     private PreviewItemDrawingParams mAnimParams = new PreviewItemDrawingParams(0, 0, 0, 0);</p>
<p>+private static String title= null;</p>
<p>     public FolderIcon(Context context, AttributeSet attrs) {</p>
<p>         super(context, attrs);</p>
<p>         init();</p>
<p>@@ -131,7 +132,12 @@ public class FolderIcon extends LinearLayout implements FolderListener {</p>
<p>         icon.mFolderName = (BubbleTextView) icon.findViewById(R.id.folder_icon_name);</p>
<p>         icon.mFolderName.setText(folderInfo.title);</p>
<ul>
<li>       icon.mPreviewBackground = (ImageView) icon.findViewById(R.id.preview_background);</li>
</ul>
<ul>
<li>        icon.mPreviewBackground = (ImageView) icon.findViewById(R.id.preview_background);</li>
</ul>
<p>+</p>
<ul>
<li><p>      title = launcher.getResources().getString(R.string.custom_folder_name);</p>
</li>
<li><p>      if(folderInfo.title.equals(title)){</p>
</li>
<li><p>      icon.mPreviewBackground.setImageResource(R.drawable.cling);</p>
</li>
<li><p>      }</p>
</li>
</ul>
<p>         icon.setTag(folderInfo);</p>
<p>         icon.setOnClickListener(launcher);</p>
<p>@@ -508,7 +514,10 @@ public class FolderIcon extends LinearLayout implements FolderListener {</p>
<p>         if (mFolder == null) return;</p>
<p>         if (mFolder.getItemCount() == 0 &amp;&amp; !mAnimating) return;</p>
<p>-</p>
<p>+</p>
<ul>
<li>      if(mInfo.title.equals(title)) return ;</li>
</ul>
<p>+//Log.d(&quot;AAA&quot;,&quot;FolderInfo.title=&quot;+mInfo.title);</p>
<p>+</p>
<p>         ArrayList&lt;View&gt; items = mFolder.getItemsInReadingOrder(false);</p>
<p>         Drawable d;</p>
<p>         TextView v;</p>
<p>@@ -535,6 +544,7 @@ public class FolderIcon extends LinearLayout implements FolderListener {</p>
<p>         } else {</p>
<p>             drawPreviewItem(canvas, mAnimParams);</p>
<p>         }</p>
<p>+</p>
<p>     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Launcher 桌面创建文件夹folder</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Launcher%20%E6%A1%8C%E9%9D%A2%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9folder/</url>
    <content><![CDATA[<p>packages/apps/Launcher2/res/xml/default_workspace.xml</p>
<p>        &lt;folder</p>
<p>launcher:title=&quot;@string/folder_name&quot;//默认名</p>
<p>launcher:screen=&quot;2&quot;</p>
<p>launcher:x=&quot;3&quot;</p>
<p>        launcher:y=&quot;2&quot;&gt;</p>
<p>&lt;favorite      //大于等于2个</p>
<p>        launcher:packageName=&quot;com.android.calculator2&quot;</p>
<p>        launcher:className=&quot;com.android.calculator2.Calculator&quot; /&gt;</p>
<p>        &lt;favorite       </p>
<p>        launcher:packageName=&quot;android.rk.RockVideoPlayer&quot;</p>
<p>        launcher:className=&quot;android.rk.RockVideoPlayer.RockVideoPlayer&quot; /&gt;</p>
<p>        &lt;/folder&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Launcher2桌面布局</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Launcher2%E6%A1%8C%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>1.手动设置桌面布局</p>
<p>2. adb pull /data/data/com.android.launcher/databases/launcher.db c:\ </p>
<ol start="3">
<li>用 SQLite 查看</li>
</ol>
<p>4.直接填入default_workspace.xml</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Launcher中更改apk名字</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Launcher%E4%B8%AD%E6%9B%B4%E6%94%B9apk%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Launcher2/src/com/android/launcher2/IconCache.java b/packages/apps/Launcher2/src/com/android/launcher2/IconCache.java</p>
<p>index aa19545..bc010d1 100644</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/IconCache.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/IconCache.java</p>
<p>@@ -154,7 +154,7 @@ public class IconCache {</p>
<p>         synchronized (mCache) {</p>
<p>             CacheEntry entry = cacheLocked(application.componentName, info, labelCache);</p>
<ul>
<li>           application.title = entry.title;</li>
</ul>
<ul>
<li>           application.title = application.componentName.getPackageName().equals(&quot;com.socialnmobile.dictapps.notepad.color.note&quot;)?&quot;Note&quot;: entry.title;</li>
</ul>
<p>             application.iconBitmap = entry.icon;</p>
<p>         }</p>
<p>     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Launcher横屏时强制加一列图标</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Launcher%E6%A8%AA%E5%B1%8F%E6%97%B6%E5%BC%BA%E5%88%B6%E5%8A%A0%E4%B8%80%E5%88%97%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<ol>
<li>这方法，桌面的布局也会多一列。</li>
</ol>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/Workspace.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/Workspace.java</p>
<p>@@ -54,7 +54,7 @@ import android.view.ViewGroup;</p>
<p> import android.view.animation.DecelerateInterpolator;</p>
<p> import android.widget.ImageView;</p>
<p> import android.widget.TextView;</p>
<p>-</p>
<p>+import android.content.res.Configuration;</p>
<p>@@ -337,6 +337,9 @@ public class Workspace extends SmoothPagedView</p>
<p>         mCameraDistance = res.getInteger(R.integer.config_cameraDistance);</p>
<p>         // if the value is manually specified, use that instead</p>
<ul>
<li><p>       Configuration newConfig = res.getConfiguration();</p>
</li>
<li><p>       if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE)</p>
</li>
<li><p>                    cellCountX ++ ;</p>
</li>
</ul>
<ol start="2">
<li> 这个方法只是应用列表多一列，4.2可能不适用</li>
</ol>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/PagedViewCellLayout.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/PagedViewCellLayout.java</p>
<p>@@ -25,6 +25,7 @@ import android.view.ViewDebug;</p>
<p> import android.view.ViewGroup;</p>
<p> import android.util.Log;</p>
<p> import com.android.launcher.R;</p>
<p>+import android.content.res.Configuration;</p>
<p> /**</p>
<p>  * An abstraction of the original CellLayout which supports laying out items</p>
<p>@@ -45,6 +46,7 @@ public class PagedViewCellLayout extends ViewGroup implements Page {</p>
<p>     private int mWidthGap;</p>
<p>     private int mHeightGap;</p>
<p>     private int mMaxGap;</p>
<ul>
<li>      private Context mmContext;</li>
</ul>
<p>     protected PagedViewCellLayoutChildren mChildren;</p>
<p>     public PagedViewCellLayout(Context context) {</p>
<p>@@ -57,7 +59,7 @@ public class PagedViewCellLayout extends ViewGroup implements Page {</p>
<p>     public PagedViewCellLayout(Context context, AttributeSet attrs, int defStyle) {</p>
<p>         super(context, attrs, defStyle);</p>
<p>-</p>
<ul>
<li>              mmContext = context;</li>
</ul>
<p>         setAlwaysDrawnWithCacheEnabled(false);</p>
<p>         // setup default cell parameters</p>
<p>@@ -170,7 +172,10 @@ public class PagedViewCellLayout extends ViewGroup implements Page {</p>
<p>         return mChildren.indexOfChild(v);</p>
<p>     }</p>
<ul>
<li>   public int getCellCountX() {</li>
</ul>
<ul>
<li><p>   public int getCellCountX() {</p>
</li>
<li><p>              Configuration newConfig = mmContext.getResources().getConfiguration();</p>
</li>
<li><p>              if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE)</p>
</li>
<li><p>                      mCellCountX++ ;</p>
</li>
</ul>
<p>         return mCellCountX;</p>
<p>     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux IO编程</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%20IO%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>2012-03-06:</p>
<p>1.标准I/O</p>
<p>缓冲  </p>
<p>标准IO打开文件时，创建FILE结构体缓冲，我们只需用到文件指针 *fp</p>
<p>*fp  (如：stdout(行缓冲),stderr(不缓中))</p>
<p>printf(&quot; &quot;); -&gt;&gt; 传递给标准IO缓冲-&gt;&gt; 内核  </p>
<p>sync 同步 把缓冲写到文件</p>
<p>fprintf(stdout,&quot;helloworld&quot;);  ==  printf(&quot;helloworld&quot;);</p>
<p>cache  缓存，延时读，提高CPU效率</p>
<p>buffer 缓冲，延时写，提高文件操作效率</p>
<p>标准IO三种类型缓冲：(数据何时刷新到内核)</p>
<p>全缓冲:填满缓冲后才刷新(默认)，</p>
<p>磁盘文件，典型全缓冲</p>
<p>行缓冲:当行缓冲满时，或遇到换行符’\n’，才刷新</p>
<p>stdout, 典型行缓冲</p>
<p>不带缓冲：标准出错(stderr)</p>
<p>int fflush(FILE *fp);</p>
<p>或fflush刷新，或fclose/正常退出，否则不刷新到内核。</p>
<p>fflush :任何时刻，可以强制刷新数据到内核</p>
<p>void setbuf(FILE *stream, char *buf);</p>
<p>//更改缓冲类型//原来buffer里面的全部刷新,改用当前设置的buffer</p>
<p>int setvbuf(FILE *stream, char *buf, int mode, size_t size);</p>
<p>标准I/O库函数：&gt;&gt;&gt;读到缓冲</p>
<p>fopen/fclose</p>
<p>fgets/fputs</p>
<p>fgetc/fputc</p>
<p>fwrite/fread</p>
<p>FILE *fopen(const char *path,const char *mode);</p>
<p>:mode:</p>
<p>r:读，文件必须存在</p>
<p>w:写，文件不存在自动创建</p>
<p>a:追加。</p>
<p>b:二进制方式打开</p>
<p>w+: …以这种方式打开，不能读取原来的值了，覆盖了</p>
<p>r+:文件必须存在,可读写，覆盖</p>
<p>strerror(errno) //把错误解析为错误字符串</p>
<p>int fclose(FILE *stream); //成功返回0，失败返回EOF 并设置errno</p>
<p>字符：</p>
<p>int getc(FILE *stream);//实现为宏</p>
<p>int fgetc(FILE *stream); </p>
<p>int getchar(void); </p>
<p>int putc(int c,FILE *stream);//实现为宏</p>
<p>int fputc(int c,FILE *stream);</p>
<p>int putchar(int c); </p>
<p>行：</p>
<p>char gets(char *s) //旧的，不将换行符存入缓冲</p>
<p>char fgets(char *s,int size,FILE *stream)//读size-1个字符 加NULL(‘\0’)</p>
<p>int puts(const char*s);//以null作为终止符写到标准输出,null不写出换新行</p>
<p>int fputs(const char*s,FILE *stream);</p>
<p>直接I/O：//每次读写指定长度//可以读写二进制数据   ///返回读到对象数  /size_t 字节</p>
<p>size_t fread(void *ptr,size_t size,size_t,nmemb,FILE *stream);//nmemb 希望读写对象数</p>
<p>size_t fwrite(const void *prt,size_t size,size_t nmemb,FILE *steam);</p>
<p>标准出错函数：</p>
<p>int feof(FILE *stream);//非0，表示结束</p>
<p>int ferror(FILE *stream);//非0,表示出错</p>
<p>int clearerr(FILE *stream);</p>
<p>定位流</p>
<p>int fseek(FILE *stream,long offset,int whence);//定位，whence:SEEK_SET/SEEK_CUR/SEEK_END </p>
<p>long ftell(FILE *stream);//返回当前位置</p>
<p>void rewind(FILE *steam);//指回文件开头</p>
<p>int fgetpos(FILE *stream,fpos_t *pos); //将当位指示器值存入pos对象到成功返回0 </p>
<p>int fsetpos(FILE *stream,fpos_t *pos); //fpot_t 为封装的long 便于移植</p>
<p>umask 022  </p>
<p>创建文件时 权限默认为666 &amp; 022 -&gt; 644</p>
<p>全局错误码errno //errno.h中定义</p>
<p>strerror(errno)//把错误码转化为字符串</p>
<p>perror(&quot; &quot;)//打印自定义+错误</p>
<p>2.文件I/O</p>
<p>//通过文件描述符来访问(数组下标)</p>
<p>//调用成功，返回文件描述符，失败返回-1，设置errno</p>
<p>int open(const char *pathanme,int flags); 可以打开设备文件，但不能创建设备文件 使用mknod()</p>
<p>int open(const char *pathname,int flags,mode_t mode);</p>
<p>flags:</p>
<p>O_RDONLY : 只读</p>
<p>O_WRONLY ：只写 这三个参数是互斥的</p>
<p>O_RDWR   ：读写</p>
<p>O_CREAT  ：如文件不存在，创建</p>
<p>O_EXCL   ：如创建时失败，返回错误信息</p>
<p>O_NOCTTY ：如文件为终端，不可作为调用open()系统调用的进程控制终端</p>
<p>O_TRUNC ：如文件存在，并以只读或只写成功打开，那么先删除原有数据。</p>
<p>O_APPEND ：以添加方式打开文件，打开文件同时，文件指针指向文件末尾。</p>
<p>mode: 如 0644  八进制表示法</p>
<p>int close(int fildes); 成功返回0,失败返回-1</p>
<p>ssize_t read(int fd,void *buf,size_t count) 成功返回读字节数 不成功返回-1</p>
<p>ssize_t write(int fd,const void *buf, size_t count);</p>
<p>off_t lseek(int fildes,off_t offset,int whence)//成功返回当前位置，失败返回-1</p>
<p>只对常规文件有效，对socket、管道、FIFO等操作失败</p>
<p>空洞文件，可以多线程、多进程来写</p>
<p>int dup(int oldfd)//返回最小未用的文件描述符</p>
<p>int dup2(int oldfd,int newfd)//复制文件描述符 old指向new</p>
<p>int fcntl(..argc)//复制 查询状态 控制等功能</p>
<p>3.文件及目录</p>
<p>获取文件/目录属性信息</p>
<p>int stat(const char *filename,struct stat *buf);//目标信息</p>
<p>int lstat(const char*filename,struct stat *buf)//本身信息</p>
<p>int fstat(int filedes,struct stat *buf);//在filedes打开的文件的信息</p>
<p>struct stat</p>
<p>{ </p>
<p>   dev_t    st_dev;    //设备号或文件所在的设备号</p>
<p>   ino_t    st_ino;    //inode</p>
<p>   mode_t   st_mode;   //类型 /权限</p>
<p>   nlink_t  st_nlink;  //引用计数</p>
<p>   uid_t    st_uid;    //user id of owner</p>
<p>   gid_t    st_gid;    //group id of owner</p>
<p>   dev_t    st_rdev;   //本身设备号//必须是设备文件才有效</p>
<p>   off_t    st_size    //total size,in bytes</p>
<p>  bklsize_t st_blksize;//blocksize for filesystem IO</p>
<p>   time_t   st_atime;  //time of last access</p>
<p>   time_t   st_mtime;  //time of last modifycation</p>
<p>   time_t   st_ctime;  //time of last status change</p>
<p>};</p>
<p>st_mode成员 </p>
<p>取得文件类型的检测宏</p>
<p>S_ISREG(m)  is it a regular file?</p>
<p>S_ISDIR(m)  dirrectory ?</p>
<p>S_ISCHR(m)  character device?</p>
<p>S_ISBLK(m)  block device?</p>
<p>S_ISFIFO(m) fifo?</p>
<p>S_ISLNK(m)  symbolic link?</p>
<p>S_ISSOCK(m) socket?</p>
<p>st_mode 16位</p>
<p>0 0 00000</p>
<p> 第二个0代表1位</p>
<p> 第三个起代表3位</p>
<p>st_mode  4位(第二第三个0)代表文件类型</p>
<p>3位(第四个0)临时权限            //1 2 4</p>
<p>3位(第五个0)rwx 属主对文件的权限</p>
<p>3位(第六个0)r– 属组对文件的权限</p>
<p>3位(第七个0)r– 其他对文件的权限</p>
<p>S_IFMT   0170000  bitmask for the file type bitfileds</p>
<p>S_IFSOCK 0140000  socket</p>
<p>S_IFLNK  0120000  symbolic link</p>
<p>S_IFREG  0100000  regular file</p>
<p>S_IFBLK  0060000  block device</p>
<p>S_IFDIR  0040000  dirrectory</p>
<p>S_IFCHR  0020000  character device</p>
<p>S_IFIFO  0010000  fifo</p>
<p>S_ISUID  0004000  set UID bit</p>
<p>S_ISGID  0002000  set GID bit</p>
<p>S_ISVTX  0001000  sticky bit</p>
<p>S_IRWXU  0000700  mask for file owner permission</p>
<p>S_IRUSR  0000400  owner has read permission</p>
<p>S_IWUSR  0000200  owner has write permission</p>
<p>S_IXUSR  0000100  owner has execute permission</p>
<p>S_IRWXG  0000070  mask for group permission</p>
<p>S_IRGRP  0000040  group has read permission</p>
<p>S_IWGRP  0000020  group has write permission</p>
<p>S_IXGRP  0000010  group has execute permission</p>
<p>S_IRWXO  0000007  mask for other permission</p>
<p>S_IROTH  0000004  others has read permission</p>
<p>S_IWOTH  0000002  others has write permission</p>
<p>S_IXOTH  0000001  others has execute permission</p>
<p>目录项(存放名字、索引号)放在数据域里面，其他元数据存放在inode组</p>
<p>空目录，硬链接为2</p>
<p>//#include&lt;unistd.h&gt; //测试权限 文件是否存在</p>
<p>int access(const char *path,int mode);</p>
<p>//&lt;sys/types.h&gt; &lt;sys/stat.h&gt;</p>
<p>mode_t umask(mode_t mask);</p>
<p>新创建文件权限为 permission &amp; ~umask </p>
<p>#include&lt;dirent.h&gt;</p>
<p>DIR *opendir(const char *dirname);</p>
<p>struct dirent *readdir(DIR *dirp);</p>
<p>struct dirent</p>
<p>{</p>
<p>  char d_name[l];//可变的</p>
<p>  int  d_fileno;</p>
<p>};//default size is 268 </p>
<p>静态库 xxx.a   archive          编译时写入代码  效率较高  代价 浪费空间</p>
<p>动态库 xxx.so  share object     运时行链接      效率较高       节省空间</p>
<p>//创建.o文件 目标文件(可重定位文件)</p>
<p>gcc -o sum.o sum.c -c </p>
<p>//创建静态库 *.o -&gt;.a</p>
<p>ar crs libxxx.a sum.o</p>
<p>//使用静态链接库 -L紧跟路径  -l紧路库名libxxx.a 中的xxx</p>
<p>gcc main.c -o main -L. -lxxx</p>
<p>gcc a.c -o a -ly -lx  y与x 顺序 被依赖的在前面</p>
<p>编译时，链接库文件的顺序是需要考虑</p>
<p>soname libxxx.so.0 只保留主版本号 方面库的维护与升级</p>
<p>//创建动态库 -fPIC 创建与地址无关的编译程序</p>
<p>gcc -fPIC -c hello.c -o hello.o</p>
<p>gcc -shared -fPIC -o libxxx.so hello.o</p>
<p>//使用动态库 方法</p>
<p>1.设置环境变量 LD_LIBRARY_PATH</p>
<p>2.可以直接把动态库libxxx.so放到 /lib 或 /usr/lib 目录下</p>
<p>3.修改/etc/ld.so.conf.d/libc.conf  运行ldconfig 重建/etc/ld.so.cashe</p>
<p>！！！动态库，是指运行时必须用到的。而编译时，必须指是定动态库的路径。</p>
<p>nm [object] 列出库中的符号 U调用其他库的  T库中定义的  W弱态符号可能被其他库覆盖的</p>
<p>ldd /lib/libxxx.so  查看依赖的库</p>
<p>gcc参数</p>
<p>-shared : 指定生成动态链接库</p>
<p>-static : 指定生成静态链接库</p>
<p>-fPIC   : 编译与地址无关共享库</p>
<p>-L.     : 表示要链接的库在当前目录</p>
<p>-lxxx : 指定链接库libxxx.so</p>
<p>-Wall   : 生成所有警告信息</p>
<p>-ggdb   : 尽可能生成gdb可以使用的调试信息</p>
<p>-g      : 编译时生成调试信息</p>
<p>-c      : 生成目标文件(.o)</p>
<p>-Wl,options  : 把options参数传递给链接器ld 多参以,隔开</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 文件创建读取</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%20%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E8%AF%BB%E5%8F%96/</url>
    <content><![CDATA[<p>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdio.h&gt;<br>#define LENGTH 100</p>
<pre><code>main()&#123;
    int fd,len;
    char str[LENGTH];
  fd = open(&amp;quot;hello.txt&amp;quot;,O_CREAT|O_RDWR,S_IRUSR|S_IWUSR);

  if(fd)&#123;
        write(fd, &amp;quot;Hell World&amp;quot;, strlen(&amp;quot;Hell World&amp;quot;));
        close(fd);
   &#125;
   fd = open(&amp;quot;hello.txt&amp;quot;,O_RDWR);
   len = read(fd,str,LENGTH);
   str[len] = &#39;\0&#39;;
   printf(&amp;quot;%s\n&amp;quot;,str);
   close(fd);
  &#125;</code></pre>
<p> 使用C库函数</p>
<p>#include &lt;stdio.h&gt;<br>#define LENGTH 100</p>
<pre><code>main()&#123;
    FILE *fd;
    char str[LENGTH];
  fd = fopen(&amp;quot;hello.txt&amp;quot;,&amp;quot;w+&amp;quot;);

  if(fd)&#123;
        fputs(&amp;quot;Hell World&amp;quot;, fd);
        fclose(fd);
   &#125;
   fd = fopen(&amp;quot;hello.txt&amp;quot;,&amp;quot;r&amp;quot;);
   fgets(str,LENGTH,fd);    
   printf(&amp;quot;%s\n&amp;quot;,str);
   fclose(fd);
  &#125;</code></pre>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 硬盘自动挂载- etc-fstab</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%20%E7%A1%AC%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-%20etc-fstab/</url>
    <content><![CDATA[<p>1.查看硬盘UUID号；</p>
<p>ll /dev/disk/by-uuid/</p>
<p>lrwxrwxrwx 1 root root  10 2012-09-04 09:50 25925fcd-6538-4b1d-9b34-e408d3ebf17b -&gt; ../../sdb1</p>
<p>lrwxrwxrwx 1 root root  10 2012-09-04 09:50 2b80f218-363d-4682-87fa-fbf0834997e1 -&gt; ../../sdb5</p>
<p>lrwxrwxrwx 1 root root  10 2012-09-04 09:50 3e38da27-1e77-426c-943d-64083ecab346 -&gt; ../../sda5</p>
<p>２.修改fstab</p>
<p> sudo vi /etc/fstab</p>
<p>UUID=12942b47-300c-4a11-8a1f-c336b4745d58  /home/edward/source  ext4 defaults        0   0</p>
<p>/dev/sdb1          /media/disk1             ext3          rw,nosuid,nodev,uhelper=udisks      0         0</p>
<p>根据已有的格式来修改 UUID和挂载的路径即可。</p>
<h1 id="etc-fstab-static-file-system-information"><a href="#etc-fstab-static-file-system-information" class="headerlink" title="/etc/fstab: static file system information."></a>/etc/fstab: static file system information.</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Use-‘blkid-o-value-s-UUID’-to-print-the-universally-unique-identifier"><a href="#Use-‘blkid-o-value-s-UUID’-to-print-the-universally-unique-identifier" class="headerlink" title="Use ‘blkid -o value -s UUID’ to print the universally unique identifier"></a>Use ‘blkid -o value -s UUID’ to print the universally unique identifier</h1><h1 id="for-a-device-this-may-be-used-with-UUID-as-a-more-robust-way-to-name"><a href="#for-a-device-this-may-be-used-with-UUID-as-a-more-robust-way-to-name" class="headerlink" title="for a device; this may be used with UUID= as a more robust way to name"></a>for a device; this may be used with UUID= as a more robust way to name</h1><h1 id="devices-that-works-even-if-disks-are-added-and-removed-See-fstab-5"><a href="#devices-that-works-even-if-disks-are-added-and-removed-See-fstab-5" class="headerlink" title="devices that works even if disks are added and removed. See fstab(5)."></a>devices that works even if disks are added and removed. See fstab(5).</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="lt-file-system-gt-lt-mount-point-gt-lt-type-gt-lt-options-gt-lt-dump-gt-lt-pass-gt"><a href="#lt-file-system-gt-lt-mount-point-gt-lt-type-gt-lt-options-gt-lt-dump-gt-lt-pass-gt" class="headerlink" title="&lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;"></a>&lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</h1><p>proc            /proc           proc    nodev,noexec,nosuid 0       0</p>
<h1 id="was-on-dev-sda1-during-installation"><a href="#was-on-dev-sda1-during-installation" class="headerlink" title="/ was on /dev/sda1 during installation"></a>/ was on /dev/sda1 during installation</h1><p>UUID=c28fa0d2-f877-4069-86fa-8c6fffb37b00 /               ext4    errors=remount-ro 0       1</p>
<h1 id="swap-was-on-dev-sda5-during-installation"><a href="#swap-was-on-dev-sda5-during-installation" class="headerlink" title="swap was on /dev/sda5 during installation"></a>swap was on /dev/sda5 during installation</h1><p>UUID=9eba5845-9e79-4fae-98bb-17b521197b61 none            swap    sw              0       0</p>
<p>#/dev/fd0        /media/floppy0  auto    rw,user,noauto,exec,utf8 0       0</p>
<p>UUID=12942b47-300c-4a11-8a1f-c336b4745d58 /home/edward/source  ext4defaults        0   0</p>
<p>UUID=1e6630c9-c2d3-4367-94fb-44690547dda2   /home/edward/work  ext4  defaults       0       2 //开机硬盘检查</p>
<h1 id="swap-was-on-dev-sdc5-during-installation"><a href="#swap-was-on-dev-sdc5-during-installation" class="headerlink" title="swap was on /dev/sdc5 during installation"></a>swap was on /dev/sdc5 during installation</h1><p>UUID=fdb59a51-0462-4f67-844f-be2e02ea0154 none            swap    sw              0       0</p>
<p>UUID=c278761b-874c-4319-84bc-330ab5a645da  /opt/disk1  ext4 defaults        0   0</p>
<p>UUID=4d4c91a1-6ad3-49fc-9f0d-54d31c50cab5  /opt/disk2  ext4 defaults        0   0</p>
<p>UUID=48f12d49-423a-49d2-87f7-4f43d905e360  /opt/disk3  ext4 defaults        0   0</p>
<p>UUID=9f510c5d-7669-4530-a568-b29276d262bd  /opt/disk4  ext4 defaults        0   0</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 网络编程</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>2012.03.19</p>
<p>OSI模型：(Open System Interconnect Reference Model)</p>
<p>应用层:FTP、E-mail、Telent</p>
<p>表示层:数据格式定义、数据转换/加密</p>
<p>会话层:建立通信进程的逻辑名字与物理名字之间的联系</p>
<p>传输层:差错处理恢复，流量控制，提供可靠的数据传输</p>
<p>网络层:数据分组、路由选择</p>
<p>数据链路层:数据组成可发送、接收的帧</p>
<p>物理层:传输物理信号、接口、信号形式、速率</p>
<p>TCP/IP:</p>
<p>应用层  Applicatioin</p>
<p>传输层  Transport</p>
<p>网络层  Network</p>
<p>物理接口层 </p>
<p>TCP是一种可靠的、面向连接的字节流服务。</p>
<p>UDP是一种不可靠的、无连接的数据报服务。</p>
<p>TCP/IP 三次握手</p>
<p>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。</p>
<p>第二次握手：服务器收到syn包，必须确认客户端的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态。</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>1.c-&gt;s:SYN=1,ACK=0,SEQ=x</p>
<p>2.s-&gt;c:SYN=1,ACK=1,SEQ=y,ACK=x+1</p>
<p>3.c-&gt;s:ACK=1,SEQ=x+1,ACK=y+1</p>
<p>四次握手：</p>
<p>a-&gt;b: FIN=1, SEQ=x</p>
<p>b-&gt;a: ACK=1, ACK=x+1</p>
<p>b-&gt;a: FIN=1, ACK=1, SEQ=y</p>
<p>a-&gt;b: ACK=1, ACK=y+1</p>
<p>SYN(synchronous)</p>
<p>ACK(acknowledgement)</p>
<p>PSH(push)</p>
<p>FIN(finish)</p>
<p>RST(reset)</p>
<p>URG(urgent)</p>
<p>TCP</p>
<p>client: socket()-&gt;connect()-&gt;write()/read()-&gt;colse();</p>
<p>server: socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;read()/write()-&gt;close();</p>
<p>UDP:</p>
<p>client: socket()-&gt;sendto()-&gt;recvfrom()-&gt;close();</p>
<p>server: socket()-&gt;bind()-&gt;recvfrom()-&gt;sendto()-&gt;close()</p>
<p>//TCP client</p>
<p>#include&lt;sys/types.h&gt;</p>
<p>#include&lt;sys/socket.h&gt;</p>
<ol>
<li>int socket(int domain,int type,int protocol);//返回文件描述符</li>
</ol>
<p>domain:AF_UNIX(AF_LOCAL) AF_INET  AF_INET6 …</p>
<p>type:SOCK_STREAM(TCP) SOCK_RAW(ping)  SOCK_DGRAM(UDP)</p>
<p>protocol:0 默认协议</p>
<p>2.int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);//成功0</p>
<p>//通用地址结构 //connect用这个</p>
<p>struct sockaddr</p>
<p>{</p>
<p>u_short sa_family;</p>
<p>char sa_data[14];</p>
<p>}</p>
<p>//Internet协议地址结构 </p>
<p>//一般先用这个初始化 再转为通用的(struct sockaddr)</p>
<p>struct sockaddr_in</p>
<p>{</p>
<p>  u_short sin_family;</p>
<p>  u_short sin_port;</p>
<p>  struct in_addr sin_addr;</p>
<p>  char sin_zero[8];</p>
<p>};</p>
<p>//IPv4地址结构</p>
<p>struct in_addr</p>
<p>{</p>
<p>  in_addr_t s_addr; //二进制网络格式</p>
<p>}</p>
<p>  1)定义   const struct sockaddr_in peer_addr;</p>
<p>  2)清零   bzero(&amp;peer_addr,sizeof peer_addr);</p>
<p>  3)协议簇 peer_addr.sin_family = PF_INET ;//ipv4</p>
<p>  4)端口   peer_addr.sin_port = htons(atoi(argv[2]));</p>
<p>  5)地址   peer_addr.sin_addr.s_addr = inet_addr(&quot;192.168.7.6&quot;);//除255.255.255.255</p>
<p>      htonl((192&lt;&lt;24)|(168&lt;&lt;16)|(7&lt;&lt;8)|6)</p>
<p>  inet_aton(&quot;192.168.7.6&quot;,&amp;peer_addr.sin_addr);//不能连续使用</p>
<p>  inet_pton(AF_INET,&quot;192.168.7.6&quot;,&amp;peer_addr.sin_addr);</p>
<p> #include &lt;arpa/inet.h&gt;</p>
<p>      //主机字节序到网络字节序</p>
<p>       uint32_t htonl(uint32_t hostlong); </p>
<p>       uint16_t htons(uint16_t hostshort);</p>
<p>//网络字节序到主机字节序</p>
<p>       uint32_t ntohl(uint32_t netlong);</p>
<p>       uint16_t ntohs(uint16_t netshort);</p>
<p> #include &lt;sys/socket.h&gt;</p>
<p> #include &lt;netinet/in.h&gt;</p>
<p> #include &lt;arpa/inet.h&gt;</p>
<p>       in_addr_t inet_addr(const char *cp);//返回地址 不识别255.255.255.255</p>
<p>       //str -&gt;网络字节序</p>
<p>       int inet_aton(const char *cp, struct in_addr *inp); //不能连续 </p>
<p>      //网络字节序–&gt;&gt;点分十进制字符串</p>
<p>char *inet_ntoa(struct in_addr in);//返回如:&quot;192.168.7.6&quot;</p>
<p>#include &lt;arpa/inet.h&gt;//IPv4 IPv6 –&gt;&gt;二进制</p>
<p>int inet_pton(int af, const char *src, void *dst);</p>
<p>af:AF_INET AF_INET6</p>
<p>3.连接(tcp)</p>
<p>int connect(int sockfd, const struct sockaddr *addr,</p>
<p>                   socklen_t addrlen);</p>
<p>4.发送与接收</p>
<p>#include &lt;unistd.h&gt;//当文件I/O操作</p>
<p>     ssize_t read(int fildes, void *buf, size_t nbyte);</p>
<p>     ssize_t write(int fildes, const void *buf, size_t nbyte);</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/socket.h&gt;// socket专用</p>
<p>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</p>
<p>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,                     const struct sockaddr *dest_addr, socklen_t addrlen);</p>
<p>ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</p>
<p>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</p>
<p>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</p>
<p>               struct sockaddr *src_addr, socklen_t *addrlen);</p>
<p>ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</p>
<p>5.关闭连接</p>
<p>int close(int sockfd) //关闭双向通讯</p>
<p>int shutdown(int socket, int how);</p>
<p>//TCP server</p>
<p> #include &lt;sys/types.h&gt;    </p>
<p> #include &lt;sys/socket.h&gt;</p>
<ol>
<li><p>int socket(int domain,int type,int protocol);//返回文件描述符</p>
</li>
<li><p>int bind(int sockfd, const struct sockaddr *addr,</p>
</li>
</ol>
<p>                socklen_t addrlen);</p>
<ol start="3">
<li><p>int listen(int sockfd, int backlog);//成功返回0 ，backlog为最大连接数</p>
</li>
<li><p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);//返回新连接</p>
</li>
</ol>
<p>struct sockaddr_in cli_addr;       //填充对方IP</p>
<p>bzero(&amp;cli_addr,sizeof cli_addr);</p>
<p>socklen_t len = sizeof(cli_addr);</p>
<p>5.read()/write()/send/recv()</p>
<p>6.close()</p>
<p>//UDP client</p>
<ol>
<li><p>sockfd = socket(AF_INET,SOCK_DGRAM,0)</p>
</li>
<li><p>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,                     const struct sockaddr *dest_addr, socklen_t addrlen);</p>
</li>
</ol>
<p>3.close(sockfd);</p>
<p>//UDP server</p>
<ol>
<li><p>sockfd = socket(AF_INET,SOCK_DGRAM,0)</p>
</li>
<li><p>int bind(int sockfd, const struct sockaddr *addr,</p>
</li>
</ol>
<p>                socklen_t addrlen);</p>
<ol start="3">
<li>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</li>
</ol>
<p>               struct sockaddr *src_addr, socklen_t *addrlen);</p>
<ol start="4">
<li>close(sockfd);</li>
</ol>
<p>2012.03.20</p>
<p>//同时监控多个对象</p>
<p> #include &lt;poll.h&gt;</p>
<p> int poll(struct pollfd *fds, nfds_t nfds, int timeout);</p>
<p>struct pollfd {</p>
<p>               int   fd;         /* file descriptor */</p>
<p>               short events;     /* requested events */</p>
<p>               short revents;    /* returned events */</p>
<p>           };</p>
<p>events:</p>
<p>POLLIN  有数据读</p>
<p>POLLPRI 有紧急数据读</p>
<p>POLLOUT  可以写(Writing now will not block)</p>
<p>POLLRDHUP 有连接关闭</p>
<p>POLLERR   Error condition (output only)</p>
<p>            POLLHUP   Hang up (output only).</p>
<p>            POLLNVAL  Invalid request: fd not open (output only).</p>
<p>//创建监控对象</p>
<p>struct pollfd master[3];</p>
<p>//初始化监控对象</p>
<p>master[0].fd = srv_fd;</p>
<p>master[0].events = POLLIN;</p>
<p>…</p>
<p>//开始监控</p>
<p>poll(master,5,10000);//次数/微秒timeout</p>
<p>//select </p>
<p>//同时监控多个对象分三组</p>
<p>#include &lt;sys/select.h&gt;</p>
<p>int select(int nfds, fd_set *readfds, fd_set *writefds,</p>
<p>                  fd_set *exceptfds, struct timeval *timeout);</p>
<p>nfds = maxfd + 1 ;</p>
<p>       void FD_CLR(int fd, fd_set *set);</p>
<p>       int  FD_ISSET(int fd, fd_set *set);</p>
<p>       void FD_SET(int fd, fd_set *set);</p>
<p>       void FD_ZERO(fd_set *set);</p>
<p>  struct timeval {</p>
<p>               long    tv_sec;         /* seconds */</p>
<p>               long    tv_usec;        /* microseconds */</p>
<p>           };</p>
<p>//example</p>
<p>   sockfd = socket(AF_INET,SOCK_STREAM,0);</p>
<p>  const int on = 1;</p>
<p>  setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;on,sizeof(on))</p>
<p> struct sockaddr_in srv_addr;</p>
<p> bzero(&amp;srv_addr,sizeof(srv_addr));</p>
<p> srv_addr.sin_family = AF_INET;</p>
<p> srv_addr.sin_port = htons(atoi(argv[1]));</p>
<p> srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</p>
<p>  bind(sockfd,(struct sockaddr*)&amp;srv_addr,sizeof(srv_addr));//bind</p>
<p>  listen(sockfd,3);//listen</p>
<p>  connfd = accept(sockfd,NULL,NULL);//new conn</p>
<p>    fd_set rset;//read fd_set</p>
<p>    int maxfd = -1;</p>
<p>    char buf[MAXSIZE];</p>
<p>    while(1){</p>
<p>        FD_ZERO(&amp;rset);</p>
<p>        FD_SET(STDIN_FILENO,&amp;rset);</p>
<p>        FD_SET(connfd,&amp;rset);</p>
<p>        maxfd = connfd; //max</p>
<p>        struct timeval tv;</p>
<p>        tv.tv_sec = 5;</p>
<p>tv.tv_usec =0;</p>
<p>        select(maxfd+1,&amp;rset,NULL,NULL,&amp;tv);</p>
<p>        if(FD_ISSET(STDIN_FILENO,&amp;rset)&gt;0){</p>
<p>            bzero(buf,MAXSIZE);</p>
<p>            read(STDIN_FILENO,buf,MAXSIZE);</p>
<p>            write(connfd,buf,strlen(buf));</p>
<p>…</p>
<p>2012.03.21</p>
<p>//socket 选项      </p>
<p>       int getsockopt(int sockfd, int level, int optname,</p>
<p>                      void *optval, socklen_t *optlen);</p>
<p>       int setsockopt(int sockfd, int level, int optname,</p>
<p>                      const void *optval, socklen_t optlen);</p>
<p>level:</p>
<p>SOL_SOCKET(API level)  </p>
<p>IPPROTO_TCP(interpreted by TCP) </p>
<p>IPPROTO_IP (interpreted by IP)</p>
<p>SOL_SOCKET level</p>
<p>SO_BROADCAST</p>
<p>SO_REUSEADDR</p>
<p>//重用地址</p>
<p>const int on = 1;</p>
<p>setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof on)</p>
<p>//广播</p>
<p>1.使用UDP</p>
<p>2.setsockopt()</p>
<p>3.ip: x.255</p>
<p>//组播</p>
<p>1.ip: 224.0.0.0 ~ 239.255.255.255</p>
<p>2.使用UDP</p>
<p>3.struct ip_mreq 加入组</p>
<p>struct ip_mreq</p>
<p>{</p>
<p>struct in_addr imr_multiaddr;  //组的地址</p>
<p>struct in_addr imr_interface; //成员的地址</p>
<p>};</p>
<p>setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq));</p>
<p>//Out Of Band(紧急数据、带外数据)</p>
<ol>
<li><p>send(sockfd,buf,size,MSG_OOB);//发送带外数据</p>
</li>
<li><p>fcntl(sockfd,F_SETOWN,getpid());//告诉内核，可以接收SIGURG</p>
</li>
<li><p>server: signal(SIGURG,catch_urg);//注册信号与处理函数</p>
</li>
</ol>
<p>4  cat_urg: recv(fd,buf,size,MSG_OOB);//接收带外数据</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux-dd命令详解</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux-dd%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Linux-dd命令详解 <br>dd 是 Linux/UNIX 下的一个非常有用的命令，作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。<br>名称: dd <br>使用权限: 所有使用者dd 这个指令在 manual 里的定义是 convert and copy a file <br>使用方式: <br>dd [option] <br>如果你想要在线看 manual, 可以试试: <br>dd –help <br>或是 <br>info dd <br>如果你想要看看这个版本如何: <br>dd –version <br>输入或输出 <br>dd if=[STDIN] of=[STDOUT] <br>强迫输入或输出的Size为多少Bytes <br>bs: dd -ibs=[BYTE] -obs=[SIZE] <br>强迫一次只做多少个 Bytes <br>cbs=BYTES <br>跳过一段以后才输出 <br>seek=BLOCKS <br>跳过一段以后才输入 <br>skip=BLOCKS <br>当然你可以拿这个来方便的拷贝光碟(注意，你的光碟是标准的 iso9660格式才可以这么做唷！) <br>dd if=/dev/cdrom of=cdrom.iso <br>其中 if 后面以及 of 后面的内容依你的需求调整。 <br>然后给系统这个指令就可以烧了: <br>cdrecord -v cdrom.iso <br>这篇不是在讲 cdrecord 的，所以上面的指令是最为简单但是不一定能符合您的硬件环境…<br>功能：把指定的输入文件拷贝到指定的输出文件中，并且在拷贝过程中可以进行格式转换。可以用该命令实现DOS下的diskcopy命令的作用。先用dd命令把软盘上的数据写成硬盘的一个寄存文件，再把这个寄存文件写入第二张软盘上，完成diskcopy的功能。需要注意的是，应该将硬盘上的寄存文件用rm命令删除掉。系统默认使用标准输入文件和标准输出文件。 <br>语法：dd [选项] <br>if =输入文件（或设备名称）。 <br>of =输出文件（或设备名称）。 <br>ibs = bytes 一次读取bytes字节，即读入缓冲区的字节数。 <br>skip = blocks 跳过读入缓冲区开头的ibs*blocks块。 <br>obs = bytes 一次写入bytes字节，即写入缓冲区的字节数。 <br>bs = bytes 同时设置读/写缓冲区的字节数（等于设置ibs和obs）。 <br>cbs = byte 一次转换bytes字节。 <br>count=blocks 只拷贝输入的blocks块。 <br>conv = ASCII 把EBCDIC码转换为ASCIl码。 <br>conv = ebcdic 把ASCIl码转换为EBCDIC码。 <br>conv = ibm 把ASCIl码转换为alternate EBCDIC码。 <br>conv = block 把变动位转换成固定字符。 <br>conv = ublock 把固定位转换成变动位。 <br>conv = ucase 把字母由小写转换为大写。 <br>conv = lcase 把字母由大写转换为小写。 <br>conv = notrunc 不截短输出文件。 <br>conv = swab 交换每一对输入字节。 <br>conv = noerror 出错时不停止处理。 <br>conv = sync 把每个输入记录的大小都调到ibs的大小（用NUL填充）。 <br>　 <br>例1：要把一张软盘的内容拷贝到另一张软盘上，利用/tmp作为临时存储区。把源盘插入驱动器中，输入下述命令： <br>$ dd if =/dev/fd0 of = /tmp/tmpfile <br>拷贝完成后，将源盘从驱动器中取出，把目标盘插入，输入命令： <br>$ dd if = /tmp/tmpfile of =/dev/fd0 <br>软盘拷贝完成后，应该将临时文件删除： <br>$ rm /tmp/tmpfile <br>　 <br>例2：把net.i这个文件写入软盘中，并设定读/写缓冲区的数目。 <br>（注意：软盘中的内容会被完全覆盖掉） <br>$ dd if = net.i of = /dev/fd0 bs = 16384 <br>　 <br>例3：将文件sfile拷贝到文件 dfile中。 <br>$ dd if=sfile of=dfile</p>
<p>例4：创建一个100M的空文件</p>
<p>dd if=/dev/zero of=hello.txt bs=100M count=1</p>
<p>=============================================</p>
<p>/dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！<br>/dev/zero,是一个输入设备，你可你用它来初始化文件。</p>
<p>/dev/null——它是空设备，也称为位桶（bit bucket）。任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶。<br>/dev/zero——该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0。<br>$ dd if=/dev/zero of=./test.txt bs=1k count=1<br>$ ls -l<br>total 4<br>-rw-r–r–     1 oracle    dba           1024 Jul 15 16:56 test.txt</p>
<p>eg:</p>
<p>$ find / -name access_log   2&gt;/dev/null</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下SPI和IIC驱动在设备树上添加设备信息的编写方法</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%E4%B8%8BSPI%E5%92%8CIIC%E9%A9%B1%E5%8A%A8%E5%9C%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8A%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p> 编写i2c或spi驱动时，一般需要往设备树上(或者板级文件)添加节点信息，这里提供一种直接在驱动中添加设备信息的方法，使驱动更方便移植。</p>
<p>i2c的驱动模板如下</p>
<p>[plain] view plain copy</p>
<p>#include &lt;linux/module.h&gt;  </p>
<p>#include &lt;linux/i2c.h&gt;  </p>
<p>#define SENSOR_BUS_NUM 0    //该设备在第几路iic上，根据硬件具体修改  </p>
<p>#define SENSOR_SLAVE_ADDRESS 0x3e//设备地址，注意是7位地址（非8位地址,linux中会自动添加读写位）  </p>
<p>#define SENSOR_NAME &quot;sensor&quot;  //设备的名字  </p>
<p>struct i2c_client *sensor_client=NULL;  </p>
<p>static int sensor_i2c_write(char *buf,int length)  </p>
<p>{  </p>
<p>#if 1  </p>
<p>    int ret;  </p>
<p>    ret=i2c_master_send(sensor_client, buf, length);  </p>
<p>    if(ret!=length)  </p>
<p>    {  </p>
<p>        pr_err(&quot;sensor_i2c_write: i2c_master_send error\n&quot;);  </p>
<p>        return -EIO;  </p>
<p>    }  </p>
<p>    else  </p>
<p>        return 0;  </p>
<p>#endif  </p>
<p>#if 0  </p>
<p>    struct i2c_msg msg=  </p>
<p>        {  </p>
<p>            .addr = sensor_client-&gt;addr,  </p>
<p>            .flags = 0,  </p>
<p>            .buf = buf,  </p>
<p>            .len = length  </p>
<p>        };  </p>
<p>    if(i2c_transfer(sensor_client-&gt;adapter, &amp;msg, 1)&lt;0)  </p>
<p>    {  </p>
<p>        pr_err(&quot;sensor_i2c_write: transfer error\n&quot;);  </p>
<p>        return -EIO;  </p>
<p>    }  </p>
<p>    else  </p>
<p>        return 0;  </p>
<p>#endif  </p>
<p>}  </p>
<p>static int sensor_i2c_read(char *buf,int length)  </p>
<p>{  </p>
<p>#if 1  </p>
<p>    int ret;  </p>
<p>    ret=i2c_master_recv(sensor_client,buf,length);  </p>
<p>    if(ret!=length)  </p>
<p>    {  </p>
<p>        pr_err(&quot;sensor_i2c_read: i2c_master_recv error\n&quot;);  </p>
<p>        return -EIO;  </p>
<p>    }  </p>
<p>    else  </p>
<p>        return 0;  </p>
<p>#endif  </p>
<p>#if 0  </p>
<p>    struct i2c_msg msg[] = {  </p>
<p>        {  </p>
<p>            .addr = sensor_client-&gt;addr,  </p>
<p>            .flags = 0,  </p>
<p>            .buf = buf,  </p>
<p>            .len = 1  </p>
<p>        },  </p>
<p>        {  </p>
<p>            .addr = sensor_client-&gt;addr,  </p>
<p>            .flags = I2C_M_RD,  </p>
<p>            .buf = buf,  </p>
<p>            .len = 1  </p>
<p>        }  </p>
<p>    };  </p>
<p>    if(i2c_transfer(sensor_client-&gt;adapter, msg, 2)&lt;0)  </p>
<p>    {  </p>
<p>        pr_err(&quot;sensor_i2c_read: transfer error\n&quot;);  </p>
<p>        return -EIO;  </p>
<p>    }  </p>
<p>    else  </p>
<p>        return 0;  </p>
<p>#endif  </p>
<p>}  </p>
<p>void sensor_config(void)  </p>
<p>{  </p>
<p>    char buf[10];  </p>
<p>    int ret;  </p>
<p>    buf[0]=0x28;  </p>
<p>    buf[1]=0x88;  </p>
<p>    ret=sensor_i2c_write(buf,1);  </p>
<p>    if(ret==0)  </p>
<p>        printk(&quot;write reg %d value %d ok.&quot;,buf[0],buf[1]);  </p>
<p>    buf[0]=0x28;  </p>
<p>    sensor_i2c_read(buf+1,1);  </p>
<p>        printk(&quot;reg 0x%x value is 0x%x&quot;,buf[0],buf[1]);  </p>
<p>}  </p>
<p>static int sensor_probe(struct i2c_client *client,const struct i2c_device_id *id)    </p>
<p>{    </p>
<p>    sensor_client=client;   </p>
<p>   sensor_config();  </p>
<p>    return 0;   </p>
<p>}    </p>
<p>static int sensor_remove(struct i2c_client *client)   </p>
<p>{    </p>
<p>    return 0;   </p>
<p>}    </p>
<p>static const struct i2c_device_id sensor_id[] = {   </p>
<p>    {SENSOR_NAME, 0},   </p>
<p>    { }   </p>
<p>};    </p>
<p>MODULE_DEVICE_TABLE(i2c, sensor_id);   </p>
<p>#ifdef CONFIG_PM  </p>
<p>static int sensor_suspend(struct device *dev)  </p>
<p>{  </p>
<p>    return 0;  </p>
<p>}  </p>
<p>static int sensor_resume(struct device *dev)  </p>
<p>{  </p>
<p>    return 0;  </p>
<p>}  </p>
<p>#endif  </p>
<p>static const struct dev_pm_ops sensor_ops = {  </p>
<p>    .suspend = sensor_suspend,  </p>
<p>    .resume  = sensor_resume,  </p>
<p>};  </p>
<p>static struct i2c_driver sensor_driver = {  </p>
<p>    .driver = {  </p>
<p>             .name = SENSOR_NAME,  </p>
<p>             .owner = THIS_MODULE,  </p>
<p>    #ifdef CONFIG_PM  </p>
<p>             .pm = &amp;sensor_ops,  </p>
<p>    #endif  </p>
<p>    },  </p>
<p>    .probe    = sensor_probe,  </p>
<p>    .remove   = sensor_remove,  </p>
<p>    .id_table = sensor_id,  </p>
<p>};  </p>
<p>static struct i2c_board_info sensor_device = {  </p>
<p>    I2C_BOARD_INFO(SENSOR_NAME, SENSOR_SLAVE_ADDRESS),  </p>
<p>};  </p>
<p>static int __init sensor_init(void)  </p>
<p>{  </p>
<p>    struct i2c_adapter *adap;  </p>
<p>    struct i2c_client *client;  </p>
<p>    adap = i2c_get_adapter(SENSOR_BUS_NUM);   </p>
<p>    if (!adap) {  </p>
<p>        printk(&quot;i2c adapter %d\n&quot;,SENSOR_BUS_NUM);    </p>
<p>        return -ENODEV;  </p>
<p>    } else {  </p>
<p>        printk(&quot;get i2c adapter %d ok\n&quot;, SENSOR_BUS_NUM);  </p>
<p>        client = i2c_new_device(adap, &amp;sensor_device);  </p>
<p>    }  </p>
<p>    if (!client) {  </p>
<p>        printk(&quot;get i2c client %s @ 0x%02x fail!\n&quot;, sensor_device.type,  </p>
<p>                sensor_device.addr);  </p>
<p>        return -ENODEV;  </p>
<p>    } else {  </p>
<p>        printk(&quot;get i2c client ok!\n&quot;);  </p>
<p>    }  </p>
<p>    i2c_put_adapter(adap);  </p>
<p>    i2c_add_driver(&amp;sensor_driver);  </p>
<p>    printk(&quot;sensor init success!\n&quot;);  </p>
<p>    return 0;  </p>
<p>}  </p>
<p>static void __exit sensor_exit(void)  </p>
<p>{  </p>
<p>    i2c_del_driver(&amp;sensor_driver);  </p>
<p>    if(sensor_client!=NULL)  </p>
<p>    i2c_unregister_device(sensor_client);  </p>
<p>    printk(&quot;Module removed\n&quot;);  </p>
<p>}  </p>
<p>module_init(sensor_init);    </p>
<p>module_exit(sensor_exit);    </p>
<p>MODULE_AUTHOR(&quot;GPL&quot;);    </p>
<p>MODULE_LICENSE(&quot;GPL&quot;);  </p>
<p>spi的驱动模板如下</p>
<p>[plain] view plain copy</p>
<p>#include &lt;linux/module.h&gt;  </p>
<p>#include &lt;linux/spi/spi.h&gt;  </p>
<p>#define SENSOR_NAME   &quot;sensor&quot;  </p>
<p>#define SENSOR_SPI_BUS 0  </p>
<p>#define SPI_MODE       0  </p>
<p>#define SENSOR_MAX_SPEED 2<em>1000</em>1000  </p>
<p>struct spi_device *sensor_spi=NULL;  </p>
<p>int sensor_spi_write(unsigned int addr, unsigned int val, size_t len)  </p>
<p>{  </p>
<p>    int status;  </p>
<p>    unsigned char write_buf[2];  </p>
<p>    write_buf[0] = addr;  </p>
<p>    write_buf[1] = val;  </p>
<p>    status = spi_write(sensor_spi, write_buf,2);  </p>
<p>    if (status)  </p>
<p>        dev_err(&amp;sensor_spi-&gt;dev, &quot;%s error %d\n&quot;, <strong>FUNCTION</strong>, status);  </p>
<p>    return status;  </p>
<p>}  </p>
<p>int sensor_spi_read(unsigned int addr, unsigned int *val, size_t len)  </p>
<p>{  </p>
<p>    struct spi_message message;  </p>
<p>    struct spi_transfer x[1];  </p>
<p>    int status;  </p>
<p>    unsigned char write_buf[10];  </p>
<p>    unsigned char read_buf[10];  </p>
<p>    write_buf[0] =addr;  </p>
<p>    spi_message_init(&amp;message);  </p>
<p>    memset(x, 0, sizeof(x));  </p>
<p>    x[0].len     = len;  </p>
<p>    x[0].tx_buf = write_buf;  </p>
<p>    x[0].rx_buf = read_buf;  </p>
<p>    spi_message_add_tail(&amp;x[0], &amp;message);  </p>
<p>    status = spi_sync(sensor_spi, &amp;message);  </p>
<p>    if(status!=0)  </p>
<p>        dev_err(&amp;sensor_spi-&gt;dev, &quot;%s error %d\n&quot;, <strong>FUNCTION</strong>, status);  </p>
<p>    else  </p>
<p>        *val =read_buf[4];  </p>
<p>    return status;  </p>
<p>}  </p>
<p>static const struct spi_device_id sensor_spi_id[] = {  </p>
<p>    { SENSOR_NAME, 0 },  </p>
<p>    { }  </p>
<p>};  </p>
<p>MODULE_DEVICE_TABLE(spi, sensor_spi_id);  </p>
<p>static int  sensor_probe(struct spi_device *spi)  </p>
<p>{  </p>
<p>    sensor_spi=spi;  </p>
<p>    return 0;  </p>
<p>}  </p>
<p>static int  sensor_remove(struct spi_device *spi)  </p>
<p>{  </p>
<p>    return 0;  </p>
<p>}  </p>
<p>#ifdef CONFIG_PM  </p>
<p>static int sensor_suspend(struct device *dev)  </p>
<p>{  </p>
<p>    return 0;  </p>
<p>}  </p>
<p>static int sensor_resume(struct device *dev)  </p>
<p>{  </p>
<p>    return 0;  </p>
<p>}  </p>
<p>static const struct dev_pm_ops sensor_ops = {  </p>
<p>    .suspend = sensor_suspend,  </p>
<p>    .resume  = sensor_resume,  </p>
<p>};  </p>
<p>#endif  </p>
<p>static struct spi_driver sensor_driver = {  </p>
<p>    .driver = {  </p>
<p>        .name  = SENSOR_NAME,  </p>
<p>        .owner = THIS_MODULE,  </p>
<p>    #ifdef CONFIG_PM  </p>
<p>        .pm   = &amp;sensor_ops,  </p>
<p>    #endif  </p>
<p>    },  </p>
<p>    .probe    =  sensor_probe,  </p>
<p>    .remove   =  sensor_remove,  </p>
<p>    .id_table =  sensor_spi_id,  </p>
<p>};  </p>
<p>static __init int sensor_spi_init(void)  </p>
<p>{  </p>
<p>    int status=-1;  </p>
<p>    struct spi_master *master;  </p>
<p>    struct spi_device *spi;  </p>
<p>    struct spi_board_info chip =  </p>
<p>    {  </p>
<p>        .modalias     = SENSOR_NAME,  </p>
<p>        .mode         = SPI_MODE,  </p>
<p>        .bus_num      = SENSOR_SPI_BUS,  </p>
<p>        .chip_select  = 0,  </p>
<p>        .max_speed_hz = SENSOR_MAX_SPEED,  </p>
<p>    };  </p>
<p>    spi_register_driver(&amp;sensor_driver);  </p>
<p>    if (status&lt;0)  </p>
<p>    {  </p>
<p>        pr_err(&quot;%s: spi_register_driver spi_driver failure. status = %d\n&quot;, <strong>func</strong>, status);  </p>
<p>　　　　 return status;  </p>
<p>     }  </p>
<p>    pr_err(&quot;%s: spi_register_driver spi_driver success. status = %d\n&quot;, <strong>func</strong>, status);  </p>
<p>    master = spi_busnum_to_master(SENSOR_SPI_BUS);  </p>
<p>    if (!master)  </p>
<p>    {  </p>
<p>        status = -ENODEV;  </p>
<p>        goto error_busnum;  </p>
<p>    }  </p>
<p>    spi = spi_new_device(master, &amp;chip);  </p>
<p>    if (!spi)  </p>
<p>    {  </p>
<p>        status = -EBUSY;  </p>
<p>        goto error_mem;  </p>
<p>    }  </p>
<p>    return status;  </p>
<p>error_mem:  </p>
<p>error_busnum:  </p>
<p>    printk(&quot;register spi device err!\n&quot;);  </p>
<p>    spi_unregister_driver(&amp;sensor_driver);  </p>
<p>    return status;  </p>
<p>}  </p>
<p>static __exit void sensor_spi_exit(void)  </p>
<p>{  </p>
<p>    spi_unregister_driver(&amp;sensor_driver);  </p>
<p>    if(sensor_spi!=NULL)  </p>
<p>    spi_unregister_device(sensor_spi);  </p>
<p>}  </p>
<p>module_init(sensor_spi_init);  </p>
<p>module_exit(sensor_spi_exit);  </p>
<p>MODULE_LICENSE(&quot;GPL v2&quot;);  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下添加adb 设备</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%E4%B8%8B%E6%B7%BB%E5%8A%A0adb%20%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<p>在RK平台下测试：</p>
<ol>
<li>在system/core/adb/usb_vendors.c 下添加VID</li>
</ol>
<p>例如：将Nvidia’s USB Vendor ID修改为Anydata的vid   (只需修改)</p>
<p>#define VENDOR_ID_NVIDIA        0x16D5</p>
<ol start="2">
<li>编译 mmm system/core/adb/ </li>
</ol>
<p>生成于out/host/linux-x86/bin/adb   若有，先删除原来的</p>
<p>3.拷贝到/sbin/下  并修改环境变量</p>
<p>export PATH=$PATH:/sbin/adb</p>
<p>4、在  /etc/udev/rules.d/70-android.rules  添加 VID &amp; PID  </p>
<h1 id="fastboot-protocol-on-grouper-anydata"><a href="#fastboot-protocol-on-grouper-anydata" class="headerlink" title="fastboot protocol on grouper (anydata)"></a>fastboot protocol on grouper (anydata)</h1><p>SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;16d5&quot;, ATTR{idProduct}==&quot;8041&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot;</p>
<p>SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;16d5&quot;, ATTR{idProduct}==&quot;8005&quot;, MODE=&quot;0600&quot;, OWNER=&quot;&lt;username&gt;&quot;</p>
<p>5 .   adb kill-server</p>
<p>       adb start-server</p>
<p>       adb devices</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下进程与线程</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>2012-03-12：</p>
<p>1.进程API</p>
<p>进程是资源管理的最小单位</p>
<p>线程是程序执行的最小单位</p>
<p>根据进程在内核中不同的表现分类：</p>
<p>交互进程：该类进程是由shell控制和运行的，交互进程既可以在前台运行，也可以在后台运行。</p>
<p>批处理进程：该类进程不属于某个终端，它被提交到一个队列中以便顺序执行。</p>
<p>守护进程：该类进程在后台运行，它一般在linux启动时开始执行，系统关闭时才结束。</p>
<p>进程的执行模式分为用户模式和内核模式</p>
<p>中断或系统调用可以使进程进入内核态。</p>
<p>#include&lt;sys/types.h&gt;</p>
<p>#include&lt;unistd.h&gt;</p>
<p>pid_t fork(void); //父进程子进程各返回一次</p>
<p>父：返回大于0的PID  子：返回0  出错返回-1</p>
<p>数据段写时才复制</p>
<p>exec 加载执行新的程序 执行完后替换原来进程的内容(除pid外)</p>
<p>excl l表示列表，参数逐一列举，传入</p>
<p>execvp p表示只给出文件名，系统查找环境变量PATH</p>
<p>        v(vector) 表示将所有参数构造成指针数组</p>
<p>excve   e表示当前进程使用环境变量</p>
<p>子进程退出时，给父进程(或init)发信号</p>
<p>.init 段代码：执行一遍就释放  –&gt;&gt; main</p>
<p>int execve(const char <em>path,char</em>const avgv[],char*const envp[])//最终都使用这个 envp新的环境变量</p>
<p>status 返回到僵尸态 //退出值 int 低8位有效</p>
<p>void exit(int status); //调用退出处理函数，清理I/O缓冲</p>
<p>void _exit(int status);//直接进入内核</p>
<p>atexit(fun);//注册退出处理函数//退出前清空缓冲后执行</p>
<p>//status 为null时，表示忽略子进程退出时的状态</p>
<p>pid_t wait(int *status) //exit(0)返回的值放到这里的status的低8位中</p>
<p>1.阻塞等待子进程退出  2.回收资源 </p>
<p>pid_t waitpid(pid_t pid,int *status,int options);//返回结束的子进程的进程号</p>
<p>pid&gt;0:  只等待进程为pid的子进程</p>
<p>pid=-1: 等待全部子进程</p>
<p>pid==0: 等待组ID为pid的子进程</p>
<p>pid&lt;-1: 等待组ID为|pid|的子进程</p>
<p>options: </p>
<p> WNOHANG   :不阻塞，若没子进程结束时返回0</p>
<p> WUNTRACED :若子进程暂停，返回其状态</p>
<p> 0         : 阻塞父进程，等待子进程</p>
<p>readelf -S xxx</p>
<p>进程组的意义在于方便发送信号</p>
<p>2012-03-13：</p>
<p>linux守护进程 </p>
<p>1.进程第1次fork,为进程调用setid作准备</p>
<p>2.进程调用setsid,进程成为新的会话过程的领头进程</p>
<p>3.忽略信号SIGHUP，第2次fork,使进程成为一个新的进程组的领导者。</p>
<p>4.关闭所有的文件描述符。</p>
<p>5.消除umask的影响</p>
<p>6.修改守护进程的当前目录。</p>
<p>7.重新定位标准I/O描述符。</p>
<p>8.保证服务器的互斥运行。</p>
<p>9.使用syslog来记录守护进程的错误信息</p>
<p>pid_t pid;</p>
<p>int max_fd, i;</p>
<p>        //fork一个子进程，为setid()作准备</p>
<p>pid = fork();</p>
<p>if(pid &gt; 0)</p>
<p>exit(0);</p>
<p>//忽略信号SIGHUP，防止进程因控制终端关闭而被杀死</p>
<p>signal(SIGHUP, SIG_IGN);</p>
<p>//调用setsid(),让第一个进程不依赖控制终端运行</p>
<p>setsid();</p>
<p>//fork()第二个子进程，保证此守护进程不能打开终端文件而成为其控制终端</p>
<p>pid = fork();</p>
<p>if(pid &gt; 0)</p>
<p>exit(0);</p>
<p>//将守护进程从原来的组分离，防止任何信号进来  </p>
<p>setpgrp();</p>
<p>        //关闭所有打开文件描述符</p>
<p>max_fd = sysconf(_SC_OPEN_MAX);</p>
<p>for(i=0; i&lt;max_fd; i++)</p>
<p>close(i);</p>
<p>  //把umask设为0,消除umask的影响</p>
<p>umask(0);</p>
<p>//变更目录，防止被缷载</p>
<p>chdir(&quot;/&quot;);</p>
<p>umask(0):清除旧有的文件掩码</p>
<p>最终的文件权限：mode &amp; ~umask</p>
<p>void openlog(const char*ident,int option,int facility);</p>
<p>ident:路径  option:LOG_PID LOG_CONS … facility:LOG_USER 指明进程类型</p>
<p>void syslog(int priority,chnst char *fromat…);</p>
<p>用户空间的守护进程 Klogd 用来从记录缓冲区获取内核消息</p>
<p>klogd 将内核消息保存到系统日志文件  /var/log/message 中</p>
<p>flock(int fd,int operation);//对整个文件锁定</p>
<p>operation:</p>
<p>LOCK_SH: 共享锁</p>
<p>LOCK_EX: 互斥锁</p>
<p>LOCK_UN: 解锁</p>
<p>LOCK_NB: 不能获取锁时睡眠</p>
<p>int fcntl(int fd,int cmd,struct flock *lock);//对文件部分锁定</p>
<p>struct flock{</p>
<p>…</p>
<p>short I_type;</p>
<p>short I_whence;</p>
<p>off_t I_start;</p>
<p>off_t I_len;</p>
<p>off_t I_pid;</p>
<p>…</p>
<p>};</p>
<p>I_type: F_RDLCK,F_WRLCK,F_UNLCK //分别为：共享锁、互斥锁、解锁</p>
<p>进程间通信</p>
<p>1.传统的进程间通信方式</p>
<p>无名管道(pipe)、有名管道(fifo)、信号(signal)</p>
<p>2.System V IPC</p>
<p>共享内存(share memory)、消息队列(message queue)、信号灯(semaphore)</p>
<p>3.BSD</p>
<p>套接字(socket)</p>
<p>读者写者模式：</p>
<p>1.有写者，无数据，读阻塞。</p>
<p>2.无写者，有数据，读，返回(有多少读多少)</p>
<p> 无数据，读，返回0</p>
<p>3.有读者，缓冲区满，写，阻塞。</p>
<p> 缓冲区未满，写，返回写的字节数</p>
<p>4.无读者，写操作会引发一个信号SIGPIPE</p>
<p>无名管道：</p>
<p>1.只能用于具有亲缘关系的进程间通信</p>
<p>2.半双工的通信模式，具有固定的读端和写端(小端读，大端写）；</p>
<p>3.管道是一种特殊的文件，可以使用文件IO如read、write</p>
<p>#include&lt;unistd.h&gt;</p>
<p>int pipe(int fd[2]); 成功0，出错-1    </p>
<p>#include&lt;unistd.h&gt;</p>
<p>#include&lt;fcntl.h&gt;</p>
<p>#include&lt;sys/types.h&gt;</p>
<p>int mkfifo(const char *filename,mode_t mode);</p>
<p>2012-03-14：</p>
<p>信号是软件层次上对中断机制的一种模拟，是一种异步通信的方式。</p>
<p>用户进程对信号的响应方式：</p>
<p>1.忽略信号：对信号不做任何处理(SIGKILL SIGSTOP 不可以忽略)</p>
<p>2.捕捉信号：定义处理函数，当信号发生时，执行signal(int,fun())</p>
<p>3.缺省操作：TERM CORE 一般为终止进程</p>
<p>kill -l  //列出所有信号</p>
<p>SIGHUP  1   终端结束时发出</p>
<p>SIGINT  2   Ctrl-C</p>
<p>SIGQUIT 3   Ctr-\</p>
<p>SIGILL   4   执行非法指令</p>
<p>SIGFPE  8   致命算术运算错误</p>
<p>SIGKILL 9   用来立即终止程序</p>
<p>SIGALRM 14  定时 alarm(2)</p>
<p>SIGSTOP 19  Ctrl_Z</p>
<p>SIGCHLD 17  子进程发变状态</p>
<p>SIGABRT 6   用来结束进程</p>
<p>void (*signal(int signum,void(*handler)(int)))(int);</p>
<p>void signal(SIG,fun)// 注册(捕捉) 返回之前处理方法</p>
<p>void fun(int) //处理方法</p>
<p>signal(SIGxxx,SIG_INO);//忽略信号</p>
<p>#include&lt;signal.h&gt;</p>
<p>#include&lt;sys/type.h&gt;</p>
<p>int kill(pid_t pid,int sig)//发送信号</p>
<p>kill -s SIGINT 3122</p>
<p>int raise(int sig) //向自己发信号</p>
<p>#include&lt;unistd.h&gt;</p>
<p>unsigned int alarm(uint seconds);</p>
<p>int pause(void);</p>
<p>//返回-1</p>
<p>//收到一个非致命信号返回</p>
<p>//收到一个已捕捉的致命信号返回</p>
<p>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);//可以阻塞信号</p>
<p>signal细节：</p>
<p>1.默认下，信号的响应会嵌套。</p>
<p>2.在未执行前收到多个信号，在进程恢复执行后依次响应这些信号。</p>
<p>3.在信号的挂起队列中不存在相同的信号，相同的会丢弃</p>
<p>4.挂起队列不被继承，但信号的阻塞掩码会被继承。</p>
<p>//带参数信号</p>
<p>sigaction()//注册</p>
<p>sigqueue()//发送信号</p>
<p>int sigaction(int signum, const struct sigaction *act,</p>
<p>                     struct sigaction *oldact);</p>
<p>struct sigaction {</p>
<p>               void     (*sa_handler)(int);</p>
<p>               void     (*sa_sigaction)(int, siginfo_t *, void *);</p>
<p>               sigset_t   sa_mask;</p>
<p>               int        sa_flags;</p>
<p>               void     (*sa_restorer)(void);</p>
<p>           };</p>
<p>int sigqueue(pid_t pid, int sig, const union sigval value);</p>
<p>    union sigval {</p>
<p>               int   sival_int;</p>
<p>               void *sival_ptr;</p>
<p>           };</p>
<p>2012-03-15：</p>
<p>共享内存是一种最为高效的进程间通信方式，直接读写内存。</p>
<p>步骤：</p>
<p>1.创建/打开共享内存 shmget</p>
<p>2.映射共享内存   shmat  //attaches</p>
<p>3.撤销共享内存映射 shmdt  //detaches</p>
<p>4.删除共享内存对象 shmctl //control  IPC_RMID(删除)</p>
<p>ipcs -a //查看IPC对象</p>
<p>-m : shared memory </p>
<p>-q : message queues</p>
<p>-s : semaphore arrays</p>
<p>ipcrm -M key //根据key删除共享内存</p>
<p>ipcrm -m id</p>
<p>      …</p>
<p>      -Q</p>
<p>      -q</p>
<p>#include&lt;sys/types.h&gt;</p>
<p>#include&lt;sys/ipc.h&gt;</p>
<p>#include&lt;sys/shm.h&gt;</p>
<p>//打开共享内存  //返回共享内存段标识符</p>
<p>int shmget(key_t key,int size ,int shmflg);</p>
<p>//shmflg 权限位 0666|IPC_CREAT</p>
<p>key:IPC_PRIVATE 或 ftok的返回值</p>
<p>key_t ftok(path,int);</p>
<p>system(&quot;ipcs -m&quot;);//在程序里执行shell命令</p>
<p>//映射共享内存 返回映射后的地址</p>
<p>void <em>shmat(int shmid,const void</em>shmaddr,int shmflg);</p>
<p>//shmaddr 共享内存映射地址，NULL表示自动</p>
<p>//shmflg SHM_RDONLY、  0 读写</p>
<p>//shmid 要映射的共享内存标识符</p>
<p>//撤销共享内存</p>
<p>int shmdt(const void*shmaddr);</p>
<p>//操作共享内存</p>
<p>int shmctl(int shmid,int cmd,struct shmid_ds *buf);</p>
<p>shmid:标识符 </p>
<p>cmd:IPC_STAT IPC_SET IPC_RMID</p>
<p>buf:指定IPC_STAT/IPC_SET时用以保存/设置属性</p>
<p>消息队列：Message Queues</p>
<p>int msgget(key_t key,int flag);//返回消息队列ID 错误-1</p>
<p>//flag ：权限</p>
<p>int msgsnd(int msqid,const void*msgp,size_t size,int flag);</p>
<p>//msgp:指向消息的指针</p>
<p>struct msgbuf{</p>
<p>   long mtype //消息类型</p>
<p>   char mtext[N] //消息正文</p>
<p>}</p>
<p>size :要发送消息正文字节数</p>
<p>flag: IPC_NOWAIT 没发送完成也立即返回</p>
<p>      0  发送完才返回</p>
<p>//成功返回接收消息的长度 出错-1</p>
<p>int mgsrcv(int msgid,void *msgp,size_t size,long msgtype,int flag);</p>
<p>msgp:接收消息的缓冲区</p>
<p>size:接收消息的字节数 </p>
<p>msgtype:</p>
<p>0: 接收消息队列中第一个消息</p>
<p>&gt;0:接收第一个类型为msgtype的消息</p>
<p>&lt;0:接收&gt;=msgtype绝对值的最小一个</p>
<p>flag:0 若无消息，一直阻塞</p>
<p>     IPC_NOWAIT：若没消息，立即返回ENOMSG</p>
<p>int msgctl(int msgqid,int cmd,struct msgid_ds *buf);</p>
<p>cmd:IPC_STAT 读取属性值，保存到buf</p>
<p>    IPC_SET  取buf的值，设置消息队列属性</p>
<p>    IPC_RMID: 删除消息队列</p>
<p>信号灯(semaphore)也叫信号量，</p>
<p>它是不同的进程间或一个给定进程内部不同线程间同步的机制。</p>
<p>System V 信号灯：</p>
<p>int semget(key_t key,int nsems,int semflg);</p>
<p>int semop(int semid,struct *sembuf,size_t nops);</p>
<p>semid:信号灯集ID</p>
<p>struct sembuf{</p>
<p>  short sem_num;  //要操作的信号灯ID</p>
<p>  short sem_op;   //0 等待  1释放  -1分配</p>
<p>  short sem_flg;  //0等待  IPC_NOWAIT(-1表示没资源) SEM_UNDO(撤消)</p>
<p>};</p>
<p>nops : 要操作的信号灯个数 多个时 定义为数组存储多个sembuf</p>
<p>//设置某个信号灯的值</p>
<p>int semctl(int semid,int semnum,int cmd …/<em>union semun arg</em>/);</p>
<p>semnum:要修改的信号灯值</p>
<p>cmd: GETVAL : 获取信号灯的值</p>
<p>     SETVAL : 设置</p>
<p>     IPC_RMID:删除</p>
<p>互斥：sem.val=1  P、V不能同时操作   </p>
<p>同步: sem.val=0  必须得V先操作P后操作</p>
<p>引用pthread动态库</p>
<p>gcc b.c -o b -lpthread</p>
<p>5.线程API</p>
<p>线程是指共享相同地址空间的多个任务</p>
<p>共享一个进程的地址空间</p>
<p>一个线程中多个线程共享资源：</p>
<p>1.可执行的指令</p>
<p>2.静态数据</p>
<p>3.进程中打开的文件描述符</p>
<p>4.信号处理函数</p>
<p>5.当前工作目录</p>
<p>6.用户ID</p>
<p>7.用户组ID</p>
<p>每个线程私有资源：</p>
<p>1.线程TID</p>
<p>2.PC和相关寄存器</p>
<p>3.堆栈(栈)(局部变量，返回地址) 进程内可以互相访问</p>
<p>4.错误号(errno)</p>
<p>5.信号掩码和优先级</p>
<p>6.执行状态和属性</p>
<p>#include&lt;pthread.h&gt;</p>
<p>int pthread_create(pthread_t <em>thread,const pthread_addr_t <em>attr,void</em>(<em>rountine)(void</em>),void</em>arg);</p>
<p>thread:&amp;tid 存放tid</p>
<p>attr:线程属性 NULL为缺省属性</p>
<p>routine:线程的执行函数 执行后不返回</p>
<p>arg:执行函数的参数</p>
<p>int pthread_join(pthread_t thread,void **value_ptr)</p>
<p>thread:要等待的线程</p>
<p>value_ptr:指向线程返回的参数</p>
<p>1.阻塞等待某个线程</p>
<p>2.回收资源</p>
<p>//退回当前线程</p>
<p>int pthread_exit(void *value_ptr)</p>
<p>value_ptr：线程退出时的返回值</p>
<p>int pthread_cancel(pthread_t thread)</p>
<p><strong><em>避免僵尸线程</em></strong></p>
<p>1.jion()</p>
<p>2.将线程分离，系统自动回收</p>
<p>  a.以分离的状态创建</p>
<p>  b.pthread_detach()</p>
<p>  分离线程</p>
<p>b. pthread_detach(pthread_t thread);</p>
<p>a. pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate)；</p>
<p>//detachstate:PTHREAD_CREATE_DETACHED  PTHREAD_CREATE_JOINABLE</p>
<p>Posix Semaphore API</p>
<p>#include&lt;semaphore.h&gt;</p>
<p>int sem_init(sem_t *sem,int pshared,uint value)</p>
<p>//sem:要初始化的信号量</p>
<p>//pshared:  0:线程间  非0:进程间</p>
<p>//value:信号量初值</p>
<p>int sem_wait(sem_t *sem); //P操作</p>
<p>int sem_post(sem_t *sem); //V操作</p>
<p>int sem_trywait(sem_t *sem);</p>
<p>int sem_getvalue(sem_t *sem,int *svalue);</p>
<p>Posix Mutex API</p>
<p>//初始化互斥锁</p>
<p>int pthread_mutex_init(pthread_mutex_t *mutex,pthread_mutexattr_t *attr);</p>
<p>//mutex:互斥锁</p>
<p>//attr:互斥锁属性 NULL表示缺省属性</p>
<p>int pthread_mutex_lock(pthread_mutex_t *mutex);</p>
<p>int pthread_mutex_trylock(pthread_mutex_t *mutex);</p>
<p>int pthread_mutex_unlock(pthread_mutex_t *mutex);</p>
<p>gcc -DXXX 编译时定义宏</p>
<p>while(condition)</p>
<p>   pthread_cond_wait();//不满足则挂起等待</p>
<p>int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);</p>
<p>1.进入时自动解锁</p>
<p>2.返回时加锁</p>
<p>唤醒挂起线程</p>
<p>pthread_cond_broadcast(pthread_cond_t *cond);</p>
<p>pthread_cond_signal(pthread_cond_t *cond);</p>
<p>读写锁</p>
<p>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</p>
<p>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</p>
<p>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</p>
<p>int pthread_rwlock_unlock(pthread_rmlock_t *rwlock);</p>
<p>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,</p>
<p>              const pthread_rwlockattr_t *restrict attr);</p>
<p>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</p>
<p>生产者/消费者 s1=0 s2=size</p>
<p>加锁后不能睡眠，先P、V再加锁操作</p>
<p>#include &lt;pthread.h&gt;</p>
<p>int pthread_once(pthread_once_t *once_control,</p>
<p>                 void (*init_routine)(void));</p>
<p>   pthread_once_t once_control = PTHREAD_ONCE_INIT;</p>
<p>exmaple:</p>
<p> static int random_is_initialized = 0;</p>
<p> extern int initialize_random();</p>
<p>              int random_function()</p>
<p>              {</p>
<p>                  if (random_is_initialized == 0) {</p>
<p>                      initialize_random();</p>
<p>                      random_is_initialized = 1;</p>
<p>                  }</p>
<p>                  … /* Operations performed after initialization. */</p>
<p>              }</p>
<p>#include &lt;pthread.h&gt;</p>
<p>static pthread_once_t random_is_initialized = PTHREAD_ONCE_INIT;</p>
<p>extern int initialize_random();</p>
<p>              int random_function()</p>
<p>              {</p>
<p>          (void) pthread_once(&amp;random_is_initialized, initialize_random);</p>
<p>                  … /* Operations performed after initialization. */</p>
<p>              }</p>
<p>线程池 </p>
<p>typedef struct </p>
<p>{ </p>
<p>pthread_mutex_t queue_lock; </p>
<p>pthread_cond_t queue_ready; </p>
<p>// all waiting tasks</p>
<p>CThread_worker *queue_head; //任务队列</p>
<p>bool shutdown; //pool state</p>
<p>// containning all threads’s tid</p>
<p>pthread_t *threadid; //等待线程</p>
<p>// max active taks</p>
<p>int max_thread_num;  //线程数</p>
<p>// current waitting tasks</p>
<p>int cur_queue_size; //任务数</p>
<p>}CThread_pool;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>2012.02.17:</p>
<p>vmware的安装 linux的介绍与安装，网络配置，vim使用</p>
<p>网络配置：</p>
<p>/etc/network/interfaces</p>
<p>DNS客户端配置</p>
<p>/etc/resolv.conf  </p>
<p>nameserver 202.96.128.166 //深圳DNS</p>
<p>nameserver 202.96.128.86  //中国</p>
<p>/etc/hostname   //设置主机名</p>
<p>/etc/hosts       //基于host列表实现命名解析</p>
<p>auto eth0</p>
<p>iface eth0 inet static //静态ip</p>
<p>address 192.168.7.104</p>
<p>gateway 192.168.7.1</p>
<p>netmash 255.255.255.0</p>
<p>auto eth0              //动态ip</p>
<p>iface eth0 inet dhcp //dhcp:Dynamic Host Configuration Protocol</p>
<p>auto lo                //loopback 回送地址 127.0.0.1 回环检测用</p>
<p>iface lo inet loopback</p>
<p>重启方式：</p>
<p>/etc/init.d/networking reload/restart</p>
<p>service networking restart</p>
<p>SSH  使用默认配置即可 </p>
<p>/etc/ssh/ssh_config</p>
<p>/etc/ssh/sshd_config</p>
<p>/etc/init.d/ssh reload/restart</p>
<p>service ssh restart</p>
<p>tftp</p>
<p>sudo apt-get install tftp-hpa</p>
<p>/etc/default/tftpd-hpa  </p>
<p>TFTP_DIRECTORY=&quot;/home/edward/tftpboot&quot;   //tftpboot 修改权限</p>
<p>TFTP_OPTIONS=&quot;-l -c -s&quot; //literal command/create secure ?</p>
<p>/etc/init.d/tftpd-hpa reload/restart</p>
<p>service tftpd restart</p>
<p>samba</p>
<p>/etc/samba/smb.conf</p>
<p>/etc/init.d/smbd reload/restart</p>
<p>service smbd restart</p>
<p>[edward’shares]</p>
<p>path=/home/edward/samba</p>
<p>valid users=edward</p>
<p>valid users = %S //表示smbpasswd创建的所有用户</p>
<p>available=yes</p>
<p>browseable=yes</p>
<p>public=no     //验证</p>
<p>writable=yes</p>
<p>NFS</p>
<p>sudo apt-get install nfs-kernel-server</p>
<p>/etc/exports</p>
<p>/rootfs  *(rw,sync,no_root_squash)</p>
<p>$sudo dpkg-reconfigure portmap   // -&gt;&gt; no  不将 portmap 绑定在 loopback 地址</p>
<p>/etc/default/portmap</p>
<p>#OPTIONS=&quot;-i 127.0.0.1&quot;  注释此项</p>
<p>$sudo /etc/init.d/portmap restart </p>
<p>$sudo /etc/init.d/nfs-kernel-server restart</p>
<p>2012.02.18:</p>
<p>2012.02.19:</p>
<p>2012.02.20:</p>
<p>环境变量的查看和设置</p>
<p>查看：export</p>
<p>设置  epxort HIST=30</p>
<p> export  PATH=$PATH:/usr/local/arm/4.2.2-eabi/usr/bin/</p>
<p>永久设置环境变量：</p>
<p>1，设置~/.bashrc,针对个人用户</p>
<p>   最后面加入：export  PATH=$PATH:/usr/local/arm/4.2.2-eabi/usr/bin/</p>
<p>   执行一次脚本</p>
<p>      source  ~/.bashrc</p>
<p>2,/etc/profile，针对所有用户</p>
<p>   最后面加入：export  PATH=$PATH:/usr/local/arm/4.2.2-eabi/usr/bin/</p>
<ol start="3">
<li>/etc/environment  系统变量   直接加入</li>
</ol>
<p>丢弃所有信息       黑洞</p>
<p>  ls abc 2&gt; /dev/null</p>
<p>  ls abc &amp;&gt; /dev/null</p>
<p>引号：</p>
<p>1，双引号</p>
<p>&quot;&quot;,里面的内容为普通字符串，同时保留shell里面的特殊符号，$</p>
<p>2，单引号</p>
<p>‘’,里面的内容全部当成字符串</p>
<p>3，反单引号</p>
<p>``：里面的字符串是个命令</p>
<p>sync：同步</p>
<p>用途：拨出u盘或者是硬盘的时候，先使用一下sync</p>
<p>shutdown： 发送信号给init进程</p>
<p>-h： halt</p>
<p>关机：poweroff  halt   init 0 </p>
<p>halt </p>
<p>runlevel</p>
<p>重启：reboot</p>
<p>date设置时间： sudo date -s &quot;2012/02/20 12:00:00&quot;</p>
<p>df： disk format， 磁盘格式，文件系统，查看硬盘大小和格式</p>
<p>mount： 设备文件和路径的关联</p>
<p>用法：sudo mount /dev/sda5 /opt/harddisk // 将/dev/sda5重新挂载到/opt这个点上</p>
<p>sudo mount -t ext4 /dev/sda5 /opt/harddisk</p>
<p>挂载iso文件</p>
<p>sudo mount -o loop ./netware.iso /opt/iso</p>
<p>-o option</p>
<p>loop，将文件模拟成块设备文件</p>
<p>-t iso9660</p>
<p>卸载挂载点：sudo umount /opt/harddisk</p>
<p>2，用户管理命令</p>
<p>增加用户</p>
<p>useradd(使用比较复杂)</p>
<p>adduser：（推荐）</p>
<p>用法： adduser peter</p>
<p>/etc/passwd  ==&gt;存放个人信息</p>
<p>/etc/shadow  ==》存放密码信息</p>
<p>增加某个用户的sudo的权限</p>
<p>sudo vim /etc/sudoers</p>
<p>增加：peter   ALL=(ALL) ALL</p>
<p>删除用户</p>
<p>sudo userdel -r peter </p>
<p>修改用户密码</p>
<p>sudo passwd peter</p>
<p>提示：为root设置一个密码</p>
<p>切换用户</p>
<p>su 用户名</p>
<p>用户退出：</p>
<p>exit</p>
<p>logout</p>
<p>3，进程管理命令</p>
<p>pid，ppid</p>
<p>程序和进程：</p>
<p>1，程序就是指令的集合，静态概念，占用的资源是硬盘空间</p>
<p>2，进程是程序在系统中运行后的结果，是一个动态的概念，占用cpu，内存，IO设备等等，</p>
<p>联系：程序执行一次，就会产生一个进程，执行多个就有多个进程</p>
<p>PCB：struct task_struct </p>
<p>init进程：（通过fork产生其他子进程）</p>
<p>查看init的家族树：pstree</p>
<p>1，查看进程状态（某一个时刻的，自拍）</p>
<p>七个中断： ctrl+alt+F1~F7</p>
<p>ps aux： </p>
<p>a：与终端相关的进程</p>
<p>u：进程用户名</p>
<p>x：所有的任务</p>
<p>ps -ef</p>
<p>e：所有任务</p>
<p>f：详细格式</p>
<p>2，动态查看进程状态</p>
<p>top</p>
<p>z：颜色显示</p>
<p>3，终止某个进程</p>
<p>kill给进程发送信号</p>
<p>kill -9 pid</p>
<p>cat:</p>
<p>ctrl+c:终止当前运行的进程</p>
<p>ctrl+z：让当前进程休眠</p>
<p>jobs显示被休眠的进程</p>
<p>fg %1：将第一个休眠的进程调到前台运行</p>
<p>2012.02.21:</p>
<p>1,dmesg 查看内核的调试信息（内核是用printk答应调试信息）</p>
<p>dmesg | grep sda</p>
<p>查看sda相关的信息</p>
<p>ls -l</p>
<p>查看文件夹的大小：</p>
<p>du：</p>
<p>用法： du -sh  src_s5pc 查看src_s5pc文件夹的大小</p>
<p>s： sum： 总数</p>
<p>h： human </p>
<p>如果没有权限，如何修改</p>
<p>chmod</p>
<p>用法：1，chmod 777 ~/src_s5pc</p>
<p> 2, chmod u+w,g+w,o-x  ~/src_s5pc</p>
<p> 777 ==&gt; rwxrwxrwx ==&gt; 111 111 111 (二进制)                             7   7   7  （十进制）</p>
<p> 755 ==&gt; rwxr-xr-x  ==&gt; 111 101 101</p>
<p>   7   5   5</p>
<p> u: user</p>
<p> g: group</p>
<p> o: other</p>
<p> a: all</p>
<p>chown：</p>
<p>用法： chown  root   ~/src_s5pc</p>
<p>chown  root:root   ~/src_s5pc 把用户名和组用户都改了</p>
<p>单独改用户组：</p>
<p> chgrp root ~/src_s5p</p>
<p>修改文件夹中所有的文件的权限</p>
<p>加上一个-R</p>
<p>chmod 777 ~/src_s5pc -R</p>
<p>chown  root:root   ~/src_s5pc -R</p>
<p>cd ../../ 上上目录</p>
<p>cd - 返回</p>
<p>文件操作</p>
<p>创建：</p>
<p>文件： touch </p>
<p>1，创建一个空的普通文件</p>
<p>touch  rtc</p>
<p>vim</p>
<p>2，更新文件的最后修改时间</p>
<p>11:11 export.log</p>
<p>touch  export.log</p>
<p>21:58 export.log</p>
<p>文件夹： mkdir</p>
<p>mkdir src</p>
<p> 创建多层目录</p>
<p>mkdir -p src/1/2/3</p>
<p>删除</p>
<p>文件： rm</p>
<p>rm  rtc</p>
<p>文件夹：rmdir  </p>
<p>rm  -rf abc   //强制删除</p>
<p>统一： rm  -rf abc zImage  </p>
<p>或者   rm  -rf  *  // 全部删除</p>
<p>复制，剪切和重命名</p>
<p>cp：</p>
<p>拷贝文件：</p>
<p>cp  源文件  目标文件</p>
<p>cp uImage abc/</p>
<p>cp uImage abc/uImage_35 //拷贝的同时命名</p>
<p>拷贝文件夹：</p>
<p>统一： cp  -rf  abc/   /opt</p>
<p>拷贝多个文件：</p>
<p>cp -rf export.log  zImage_net hello.c abc/  //以最后一个参数为目的地</p>
<p>mv</p>
<p>移动：</p>
<p>mv sym.sh abc/  //不需要粘贴</p>
<p>mv 文件夹的时候，不需要加-rf</p>
<p> 重命名：</p>
<p>  只要源文件的路径和目的地的路径是一样的，那么就是代表重命名</p>
<p>  mv uImage uImage_45</p>
<p>查看</p>
<p>cat, more , less, head, tail</p>
<p>cat 查看全文</p>
<p>more 和less：分页查看，  用到比较多的是less</p>
<p>less： 支持上下左右键，还有查找</p>
<p>一般的用法：和管道配合使用  |</p>
<p>dmesg | less</p>
<p>head和tail： 查看头部和尾部</p>
<p>head  -20 /etc/samba/smb.conf  //显示文件的前20行</p>
<p>tail -20 /etc/samba/smb.conf  //显示文件的后20行</p>
<p>find， grep ， locate</p>
<p>find：查找文件</p>
<p>find  路径 -name  ‘关键字’  //在路径下，按照名字的方式，搜索’关键字’</p>
<p>find  路径  -type  类型 //在路径下，按照文件类型的方式查找</p>
<p>grep：查找文件中字符串</p>
<p>grep  -rHn  ‘关键字’  路径</p>
<p> -r： 递归的找</p>
<p> -H： 显示关键字所在的文件名</p>
<p> -n： 显示关键字所在的行号</p>
<p>例子：grep -rHn ‘main’ test/</p>
<p>test/hello.c:3:int main(void)</p>
<p>test/abc/hello.c:3:int main(void)</p>
<p>locate：</p>
<p>locate  关键字</p>
<p>会查看数据库，收集了所有的文件的信息，每次开机的时候会去收集</p>
<p>updatedb  更新所有文件信息的数据库</p>
<p>sudo updatedb</p>
<p>locate wupikuaile</p>
<p>/home/ldswfun/test/wupikuaile</p>
<p>创建软连接：</p>
<p>ln </p>
<p>相对路径和路径的不同</p>
<p>相对路径：</p>
<p>ln  -s  目标文件   连接符号文件</p>
<p>ln -s hello.c  hello_sf_1</p>
<p>绝对路径：</p>
<p>ln -s /home/ldswfun/test/hello.c  hello_sf_</p>
<p>解压缩文件：</p>
<p>tar</p>
<p>归档： 打个包，不压缩</p>
<p>     归档并压缩：</p>
<p>    压缩：</p>
<p>    tar -czvf 压缩包名  压缩文件列表</p>
<p>    c： create 创建</p>
<p>    x： extract 解压</p>
<p>    z: 使用gzip的解压缩方式</p>
<p>    j：使用bzip2的解压缩方式</p>
<p>    v：显示压缩过程（可选）</p>
<p>    f：指定压缩包名，这个选项一定要在最后</p>
<p>    例子：</p>
<p>    tar -cjvf all.tar.bz2  uImage wupikuaile zImage_net ear export.log fs.c</p>
<p>    tar -czvf /home/all.tgz  uImage wupikuaile zImage_net ear export.log fs.c</p>
<p>    注意：压缩包的命名，原则就是能让解压的人知道该文件是什么类型的</p>
<p>    解压：</p>
<p>    tar -xzvf all.tgz //默认解压到当前目录</p>
<p>    tar -xzvf all.tgz -C  ./abc/    //解压到abc目录</p>
<p>网络</p>
<p>ifconfig</p>
<p>1,查看 ifconfig</p>
<p>2，禁用和激活网络接口：</p>
<p>sudo ifconfig eth0 down  //禁用</p>
<p>sudo ifconfig eth0 up   //激活</p>
<p>3，配置网路接口 sudo ifconfig  eth0 192.168.7.247 netmask 255.255.255.0 //临时为eth0配置一个ip地址</p>
<p>jobs 显示被休眠进程</p>
<p>fg %1  将第一个休眠进程调到前台</p>
<p>自动挂载</p>
<p>/etc/fstab</p>
<p>分区</p>
<p>fdisk /dev/sdb</p>
<p>n   new a partition</p>
<p>w   write …  </p>
<p>sudo fdisk -l /dev/sda</p>
<p>ll /dev/disk/by-uuid/  查看设备号</p>
<p>设置vim</p>
<p>/etc/vim/vimrc</p>
<p>/etc/vim/vimrc.local  </p>
<p>grep -n ‘main&amp;gt;’ test.c  精确匹配</p>
<p>-n 显示行号</p>
<p>-v 显示不包括目标行的所有行</p>
<p>-c 只输出匹配行计数</p>
<p>-i 不区分大小写(单字符)</p>
<p>-s 不显示错误信息</p>
<p>find path -options                           </p>
<p>          -name 指定文件名</p>
<p>          -perm 按权限 </p>
<p>          -user 按属主</p>
<p>          -type 按类型    </p>
<p>    type: b(块设备) d(目录)  f(普通文件)  p(管道)  l(链接文件)     </p>
<p>2012.02.22:</p>
<p>uboot命令</p>
<p>help；</p>
<p>printenv：查看uboot环境变量  ==》 pri缩写</p>
<p> uboot功能：</p>
<p> 下载内核：</p>
<p> 怎么下载： 用tftp下载</p>
<p>  服务器    ==》指定服务器：ubuntu ip   === serverip  </p>
<p>  ||</p>
<p>  客户端   ==》指定服务器 ： 开发板ip  === ipaddr</p>
<p>setenv : 设置uboot环境变量</p>
<p>setenv serverip 192.168.7.17         </p>
<p>setenv ipaddr  192.168.7.252</p>
<p>setenv bootcmd tftp 30800000 uImage ; bootm  //设置倒计时后的第一条命令，先看这个</p>
<p>==》 tftp 192.168.7.252:30800000  192.168.7.17:/tftpboot/uImage ; bootm 30800000</p>
<p>/tftpboot哪里来的</p>
<p>配置tftp服务的时候，设置的</p>
<p>setenv ethaddr 08:00:3e:26:0a:ab  //设置mac</p>
<p>save： 保存uboot环境变量</p>
<p>boot：重启</p>
<p>挂载文件系统</p>
<p>1，挂载哪个服务器</p>
<p>2，文件系统在哪里</p>
<p>bootargs ：uboot传递给内核参数</p>
<p>console=ttySAC0,115200   //控制台</p>
<p>root=/dev/nfs  //告诉内核，要用nfs的方式挂载文件系统</p>
<p>nfsroot=192.168.7.17:/opt/filesystem  //挂载哪个服务器:文件系统在哪里</p>
<p>ip=192.168.7.y:192.168.7.x:192.168.7.1:255.255.255.0:farsight_N:eth0:off //系统启动后，设置ip地址</p>
<p>ip=开发板ip：nfs服务器的ip：网关：子网掩码：计算机名：网络接口：杂项</p>
<p>init=/linuxrc //linux系统启动的第一进程</p>
<p>setenv bootargs console=ttySAC0,115200 init=/linuxrc root=/dev/nfs nfsroot=192.168.7.17:/opt/filesystem ip=192.168.7.241:192.168.7.17:192.168.7.1:255.255.255.0:farsight_99:eth0:off</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux字符设备驱动剖析</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>一、先看看设备应用程序</p>
<p>1.很简单，open设备文件，read、write、ioctl，最后close退出。如下：</p>
<p>int main(int argc ,char *argv[]){</p>
<p>unsigned char val[1] = 1;</p>
<p>int fd =open(&quot;/dev/LED&quot;,O_RDWR);//打开设备</p>
<p>write(fd,val,1);//写入设备，这里代表LED全亮</p>
<p>close(fd);//关闭设备</p>
<p>return 0;</p>
<p>}</p>
<p>二、/dev目录与文件系统</p>
<p>2./dev是根文件系统下的一个目录文件，/代表根目录，其挂载的是根文件系统的yaffs格式，通过读取/根目录这个文件，就能分析list出其包含的各个目录，其中就包括dev这个子目录。即在/根目录（也是一个文件，其真实存在于flash介质）中有一项这样的数据：</p>
<p>文件属性 文件偏移 文件大小 文件名称 等等</p>
<p>ls/ 命令即会使用/挂载的yaffs文件系统来读取出根目录文件的内容，然后list出dev（是一个目录）。即这时还不需要去读取dev这个目录文件的内容。Cd dev即会分析dev挂载的文件系统的超级块的信息,superblock，而不再理会在flash中的dev目录文件的数据。</p>
<p>3./dev在根文件系统构建的时候会挂载为tmpfs. Tmpfs是一个基于虚拟内存的文件系统，主要使用RAM和SWAP（Ramfs只是使用物理内存）。即以后读写dev这个目录的操作都转到tmpfs的操作，确切地讲都是针对RAM的操作，而不再是通过yaffs文件系统的读写函数去访问flash介质。Tmpfs基于RAM，所以在掉电后回消失。因此/dev目录下的设备文件都是每次linux启动后创建的。</p>
<p>挂载过程：/etc/init.d/rcS</p>
<p>Mount –a 会读取/etc/fstab的内容来挂载，其内容如下：</p>
<p>4./dev/NULL和/dev/console是在制作根文件系统的时候静态创建的，其他设备文件都是系统加载根文件系统和各种驱动初始化过程中自动创建的，当然也可以通过命令行手动mknod设备文件。</p>
<p>三、设备文件的创建</p>
<p>5./dev目录下的设备文件基本上都是通过mdev来动态创建的。mdev是一个用户态的应用程序，位于busybox工具箱中。其创建过程包括：</p>
<p>1）驱动初始化或者总线匹配后会调用驱动的probe接口，该接口会调用device_create(设备类, 设备号, 设备名);在/sys/class/设备类目录生成唯一的设备属性文件（包括设备号和设备名等信息），并且发送uvent事件（KOBJ_ADD和环境变量，如路径等信息）到用户空间（通过socket方式）。</p>
<p>2）mdev是一个work_thread线程，收到事件后会分析出/sys/class/设备类的对应文件，最终调用mknod动态来创建设备文件，而这个设备文件内容主要是设备号（这个设备文件对应的inode会记录文件的属性是一个设备（其他属性还包括目录，一般文件，符号链接等））。应用程序open(device_name,…)最重要的一步就是通过文件系统接口来获得该设备文件的内容—设备号。</p>
<p>6.如果初始化过程中没有调用device_create接口来创建设备文件，则需要手动通过命令行调用mknod接口来创建设备文件，方可在应用程序中访问。</p>
<p>7.mknod接口分析，通过系统调用后对应调用sys_mknod，其是vfs层的接口。</p>
<p>Sys_mknod(设备名, 设备号)</p>
<p>vfs通过逐一路径link_path_walk，分析出dev挂载了tmpfs，所以调用tmpfs-&gt;mknod=shmem_mknod</p>
<p>shmem_mknod(structinode *dir, struct dentry *dentry, int mode, dev_t dev)</p>
<p>inode = shmem_get_inode(dir-&gt;i_sb,dir, mode, dev, VM_NORESERVE);</p>
<p>inode = new_inode(sb);</p>
<p>switch (mode &amp; S_IFMT) {</p>
<p>default:</p>
<p>inode-&gt;i_op =&amp;shmem_special_inode_operations;</p>
<p>init_special_inode(inode,mode, dev);</p>
<p>break;</p>
<p>case S_IFREG://file</p>
<p>case S_IFDIR://DIR</p>
<p>case S_IFLNK:</p>
<p>//dentry填入inode信息，这时对应的dentry和inode都已经存在于内存中。</p>
<p>d_instantiate(dentry, inode);</p>
<ol start="8">
<li>可见，tmpfs的目录和文件都是像ramfs一样一般都存在于内存中。通过ls命令来获取目录的信息则由dentry数据结构的内容来获取，而文件的信息由inode数据结构的内容来提供。Inode包括设备文件的设备号i_rdev，文件属性(i_mode: S_ISCHR)，inode操作集i_fop（对于设备文件来说就是如何open这个inode）。</li>
</ol>
<p>四、open设备文件</p>
<ol start="9">
<li>open设备文件的最终目的是为了获取到该设备驱动的file_operations操作集，而该接口集是struct file的成员，open返回file数据结构指针：</li>
</ol>
<p>struct file {</p>
<p>conststruct file_operations *f_op;</p>
<p>unsignedint f_flags;//可读，可写等</p>
<p>…</p>
<p>};</p>
<p>以下是led设备驱动的操作接口。open(&quot;/dev/LED&quot;,O_RDWR)就是为了获得led_fops。</p>
<p>static conststruct file_operations led_fops = {</p>
<p>.owner =THIS_MODULE,</p>
<p>.open =led_open,</p>
<p>.write = led_write,</p>
<p>};</p>
<ol start="10">
<li><p>仔细看应用程序int fd =open(&quot;/dev/LED&quot;,O_RDWR)，open的返回值是int，并不是file，其实是为了操作系统和安全考虑。fd位于应用层，而file位于内核层，它们都同属进程相关概念。在Linux中，同一个文件（对应于唯一的inode）可以被不同的进程打开多次，而每次打开都会获得file数据结构。而每个进程都会维护一个已经打开的file数组，fd就是对应file结构的数组下标。因此，file和fd在进程范围内是一一对应的关系。</p>
</li>
<li><p>open接口分析，通过系统调用后对应调用sys_open，其是vfs层的接口</p>
</li>
</ol>
<p>Sys_open(/dev/led)</p>
<p>SYSCALL_DEFINE3(open,const char __user *, filename, int, flags, int, mode)</p>
<p>do_sys_open(AT_FDCWD,/dev/tty, flags, mode);</p>
<p>fd = get_unused_fd_flags(flags);</p>
<p>struct file *f = do_filp_open(dfd, tmp, flags, mode, 0);</p>
<p>//path_init返回时nd-&gt;dentry即为搜索路径文件名的起点</p>
<p>path_init(dfd, pathname, LOOKUP_PARENT, &amp;nd);</p>
<p>//link_path_walk一步步建立打开路径的各个目录的dentry和inode</p>
<p>link_path_walk(pathname, &amp;nd);</p>
<p>do_last(&amp;nd, &amp;path, open_flag, acc_mode, mode, pathname);</p>
<p>//先处理..父目录和.当前目录</p>
<p>//通过inode节点创建file</p>
<p>filp = nameidata_to_filp(nd);</p>
<p>__dentry_open()</p>
<p>//inode-&gt;i_fop=&amp;def_chr_fops</p>
<p>f-&gt;f_op =fops_get(inode-&gt;i_fop);</p>
<p>if (!open &amp;&amp; f-&gt;f_op)</p>
<p>open = f-&gt;f_op-&gt;open;</p>
<p>if (open) {</p>
<p>//调用def_chr_fops-&gt;open</p>
<p>error = open(inode, f);</p>
<p>其中inode-&gt;i_fop在mknod的init_special_inode调用中被赋值为def_chr_fops。以下该变量的定义，因此, open(inode, f)即调用到chrdev_open。其可以看出是字符设备所对应的文件系统接口，我们姑且称其为字符设备文件系统。</p>
<p>conststruct file_operations def_chr_fops = {</p>
<p>.open = chrdev_open,</p>
<p>};</p>
<p>继续分析chrdev_open：</p>
<p>Kobj_lookup(cdev_map,inode-&gt;i_rdev, &amp;idx)即是通过设备的设备号（inode-&gt;i_rdev）在cdev_map中查找设备对应的操作集file_operations.关于如何查找，我们在理解字符设备驱动如何注册自己的file_operations后再回头来分析这个问题。</p>
<p>五、字符设备驱动的注册</p>
<ol start="12">
<li>字符设备对应cdev数据结构：</li>
</ol>
<p>struct cdev {</p>
<p>struct kobject kobj; // 每个 cdev 都是一个 kobject</p>
<p>struct module*owner; // 指向实现驱动的模块</p>
<p>const structfile_operations *ops; // 操纵这个字符设备文件的方法</p>
<p>struct list_headlist; //对应的字符设备文件的inode-&gt;i_devices 的链表头</p>
<p>dev_t dev; // 起始设备编号</p>
<p>unsigned intcount; // 设备范围号大小</p>
<p>};</p>
<ol start="13">
<li>led设备驱动初始化和设备驱动注册</li>
</ol>
<p>cdev_init是初始化cdev结构体，并将led_fops填入该结构。</p>
<p>cdev_add</p>
<p>int cdev_add(struct cdev *p, dev_t dev, unsigned count)</p>
<p>{</p>
<p>p-&gt;dev = dev;</p>
<p>p-&gt;count = count;</p>
<p>return kobj_map(cdev_map, dev, count, NULL, exact_match, exact_lock, p);</p>
<p>}</p>
<p>cdev_map是一个全家指针变量，类型如下:</p>
<p>kobj_map使用hash散列表来存储cdev数据结构。通过注册设备的主设备号major来获得cdev_map-&gt;probes数组的索引值i（i = major % 255），然后把一个类型为struct probe的节点对象加入到probes[i]所管理的链表中，probes[i]-&gt;data即是cdev数据结构，而probes[i]-&gt;dev和range代表字符设备号和范围。</p>
<p>六、再述open设备文件</p>
<ol start="14">
<li><p>通过第五步的字符设备的注册过程，应该对Kobj_lookup查找led_ops是很容易理解的。至此，已经获得led设备驱动的led_ops。接着立刻调用file-&gt;f_ops-&gt;open即调用了led_open，在该函数中会对led用到的GPIO进行ioremap并设置GPIO方向、上下拉等硬件初始化。</p>
</li>
<li><p>最后，chrdev_open一步步返回，最后到</p>
</li>
</ol>
<p>do_sys_open的struct file *f = do_filp_open(dfd, tmp, flags, mode, 0);返回。</p>
<p>Fd_install(fd, f)即是在当前进程中将存有led_ops的file指针填入进程的file数组中，下标是fd。最后将fd返回给用户空间。而用户空间只要传入fd即可找到对应的file数据结构。</p>
<p>七、设备操作</p>
<ol start="15">
<li>这里以设备写为例，主要是控制led的亮和灭。</li>
</ol>
<p>write(fd,val,1)系统调用后对应sys_write，其对应所有的文件写，包括目录、一般文件和设备文件，一般文件有位置偏移的概念，即读写之后，当前位置会发生变化，所以如要跳着读写，就需要fseek。对于字符设备文件，没有位置的概念。所以我们重点跟踪vfs_write的过程。</p>
<p>1）fget_light在当前进程中通过fd来获得file指针</p>
<p>2）vfs_write</p>
<ol start="3">
<li>对于led设备，file-&gt;f_op-&gt;write即是led_write。</li>
</ol>
<p>在该接口中实现对led设备的控制。</p>
<p>八、再论字符设备驱动的初始化</p>
<p>综上所述，字符设备的初始化包括两个主要环节：</p>
<p>1）字符设备驱动的注册，即通过cdev_add向系统注册cdev数据结构，提供file_operations操作集和设备号等信息，最终file_operations存放在全局指针变量cdev_map指向的Hash表中，其可以通过设备号索引并遍历得到。</p>
<p>2）通过device_create(设备类, 设备号, 设备名)在sys/class/设备类中创建设备属性文件并发送uevent事件，而mdev利用该信息自动调用mknod在/dev目录下创建对应的设备文件，以便应用程序访问。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Mac 远程目录</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Mac%20%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>Homebrew</p>
<p><a href="https://brew.sh/index_zh-cn.html">https://brew.sh/index_zh-cn.html</a></p>
<p>/usr/bin/ruby -e &quot;$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)&quot;</p>
<p>brew install sshfs</p>
<p>按照提示，先安装osxfuse </p>
<p>brew cask install osxfuse</p>
<p>brew install sshfs</p>
<p>sshfs -C -o reconnect &lt;user&gt;@&lt;host&gt;:&lt;remote_dir&gt; &lt;local_dir&gt;</p>
<p>sshfs -C -o reconnect <a href="mailto:&#114;&#111;&#x6f;&#x74;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#46;&#49;&#x2e;&#x31;&#48;&#x31;">&#114;&#111;&#x6f;&#x74;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#46;&#49;&#x2e;&#x31;&#48;&#x31;</a>:/mnt/images/ ~/Desktop/images/</p>
<p>sshfs -C -o reconnect <a href="mailto:&#x41;&#100;&#109;&#x69;&#x6e;&#105;&#115;&#116;&#114;&#97;&#116;&#x6f;&#x72;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#46;&#49;&#x2e;&#49;&#x38;">&#x41;&#100;&#109;&#x69;&#x6e;&#105;&#115;&#116;&#114;&#97;&#116;&#x6f;&#x72;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#46;&#49;&#x2e;&#49;&#x38;</a>:E:\ssh ~/Desktop/remote  //to Windows</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>MediaActionSound</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/MediaActionSound/</url>
    <content><![CDATA[<p>import android.media.MediaActionSound;</p>
<p>MediaActionSound  mCameraSound = new MediaActionSound();<br>mCameraSound.load(MediaActionSound.SHUTTER_CLICK);</p>
<p>wait ..<br>mCameraSound.play(MediaActionSound.SHUTTER_CLICK);</p>
<p>    public static final int SHUTTER_CLICK         = 0; </p>
<p>    public static final int FOCUS_COMPLETE        = 1;</p>
<p>    public static final int START_VIDEO_RECORDING = 2;</p>
<p>    public static final int STOP_VIDEO_RECORDING  = 3;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Microsoft Html  索引停止 CHM文档</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Microsoft%20Html%20%20%E7%B4%A2%E5%BC%95%E5%81%9C%E6%AD%A2%20CHM%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>Microsoft Html 帮助执行程序 </p>
<p>regsvr32 hhctrl.ocx  <br>regsvr32 itss.dll  <br>regsvr32 itircl.dll </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Mstart Debug Tool</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Mstart%20Debug%20Tool/</url>
    <content><![CDATA[<p>调试工具 MSTV_Tool_mst70X.exe </p>
<p>Chip Select -&gt; MSD 2x10 Series</p>
<p>Addr Unit : 16 bit</p>
<p>Bank:0x1622 （行场同步调试）</p>
<p>833x行场同步调试，串口关闭 uartoff ，即bank0x101e_53h bit0=0</p>
<p>Panel Bank register 0x1622 (0x1F2C4400=0X1F000000+0x1622<em>0x200+x</em>4)</p>
<p>                m_PanelAttr.usHBPorch = 139;// REG_PNL_14 (0x1F2C4450)</p>
<p>m_PanelAttr.usHBlanking = 138;// REG_PNL_15 (0x1F2C4454）</p>
<p>m_PanelAttr.usHSyncW = 3; //REG_PNL_16[0:7]</p>
<p>m_PanelAttr.usVBPorch = 10;//REG_PNL_12  (0x1F2C4448)</p>
<p>m_PanelAttr.usVBlanking = 28;//REG_PNL_13 (0x1F2C444C)</p>
<p>m_PanelAttr.usVSyncW = 3; //REG_PNL_16[8:15] (0x1F2C4458)</p>
<p>                m_PanelAttr.ubBusCfg = LCD_YUV422_UY0VY1;// REG_PNL_19 (0:5)</p>
<p>                WIDTH : bank0x1622_24H</p>
<p>                 HEIGHT: bank0x1622_25H (0x1F2C4494)</p>
<p>                DClock : bank0x1622_11H[8:15] </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>OAUTH  2-legged 与 3-legged 的差別</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/OAUTH%20%202-legged%20%E4%B8%8E%203-legged%20%E7%9A%84%E5%B7%AE%E5%88%A5/</url>
    <content><![CDATA[<p>名词解释</p>
<p>在认证和授权的过程中涉及的三方包括：</p>
<p>服务提供方，用户使用服务提供方来存储受保护的资源，如照片，视频，联系人列表。</p>
<p>用户，存放在服务提供方的受保护的资源的拥有者。</p>
<p>客户端，要访问服务提供方资源的第三方应用，通常是网站，如提供照片打印服务的网站。在认证过程之前，客户端要向服务提供者申请客户端标识。</p>
<p>使用OAuth进行认证和授权的过程如下所示：</p>
<p>用户访问客户端的网站，想操作用户存放在服务提供方的资源。</p>
<p>客户端向服务提供方请求一个临时令牌。</p>
<p>服务提供方验证客户端的身份后，授予一个临时令牌。</p>
<p>客户端获得临时令牌后，将用户引导至服务提供方的授权页面请求用户授权。在这个过程中将临时令牌和客户端的回调连接发送给服务提供方。</p>
<p>用户在服务提供方的网页上输入用户名和密码，然后授权该客户端访问所请求的资源。</p>
<p>授权成功后，服务提供方引导用户返回客户端的网页。</p>
<p>客户端根据临时令牌从服务提供方那里获取访问令牌。</p>
<p>服务提供方根据临时令牌和用户的授权情况授予客户端访问令牌。</p>
<p>客户端使用获取的访问令牌访问存放在服务提供方上的受保护的资源。</p>
<p>        三条腿的OAuth（3-Legged OAuth），这也是OAuth的标准版本。这里所谓的“三条腿”，指的是授权过程中涉及前面提到的三种角色，也就是：客户端，服务提供方，用户。不过有些情况下，不需要用户的参与，此时就产生了一个变体，被称作两条腿的OAuth（2-Legged OAuth），一般来说，访问私有数据的应用需要三条腿的OAuth，访问公共数据的应用需要两条腿的OAuth。</p>
<p>两条腿的OAuth和三条腿的OAuth相比，因为没有用户的参与，所以在流程中就不会涉及用户授权的环节，也就不需要使用Token，而主要是通 过Consumer Key和Consumer Secret来完成签名的，此时的Consumer Key和Consumer Secret基本等价于账号和密码的作用。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>OSI七层协议模型、TCPIP四层模型</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B%E3%80%81TCPIP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<ol>
<li>OSI七层和TCP/IP四层的关系</li>
</ol>
<p>1.1 OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</p>
<p>1.2 OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。</p>
<p>1.3 OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。</p>
<p>TCP：transmission control protocol 传输控制协议</p>
<p>UDP：user data protocol 用户数据报协议</p>
<p>OSI七层网络模型</p>
<p>TCP/IP四层概念模型  </p>
<p>对应网络协议</p>
<p>应用层（Application）</p>
<p>应用层</p>
<p>HTTP、TFTP, FTP, NFS, WAIS、SMTP</p>
<p>表示层（Presentation）</p>
<p>Telnet, Rlogin, SNMP, Gopher</p>
<p>会话层（Session）</p>
<p>SMTP, DNS</p>
<p>传输层（Transport）</p>
<p>传输层</p>
<p>TCP, UDP</p>
<p>网络层（Network）</p>
<p>网络层</p>
<p>IP, ICMP, ARP, RARP, AKP, UUCP</p>
<p>数据链路层（Data Link）</p>
<p>数据链路层</p>
<p>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</p>
<p>物理层（Physical）</p>
<p>IEEE 802.1A, IEEE 802.2到IEEE 802.11</p>
<ol start="2">
<li>OSI七层协议模型</li>
</ol>
<p>七层结构记忆方法：应、表、会、传、网、数、物</p>
<p>应用层协议需要掌握的是：HTTP（Hyper text transfer protocol）、FTP（file transfer protocol）、SMTP（simple mail transfer rotocol）、POP3（post office protocol 3）、IMAP4（Internet mail access protocol）</p>
<ol start="3">
<li>TCP/IP四层模型</li>
</ol>
<p>3.1 应用层：对应OSI中的应用层、表示层、会话层</p>
<p>3.2 物理链路层：对应OSI中的数据链路层、物理层（也有叫网络接口层）</p>
<p>3.3 数据包说明：</p>
<p>IP层传输单位是IP分组，属于点到点的传输；TCP层传输单位是TCP段，属于端到端的传输</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>OneDrive</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/OneDrive/</url>
    <content><![CDATA[<p><a href="https://t.odmail.cn/">https://t.odmail.cn</a> 注册临时邮箱</p>
<p><a href="mailto:&#x6d;&#x61;&#x67;&#105;&#x63;&#101;&#x64;&#119;&#97;&#x72;&#100;&#64;&#116;&#46;&#x6f;&#100;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#110;">&#x6d;&#x61;&#x67;&#105;&#x63;&#101;&#x64;&#119;&#97;&#x72;&#100;&#64;&#116;&#46;&#x6f;&#100;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#110;</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>PHP WEB  API framework</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/PHP%20WEB%20%20API%20framework/</url>
    <content><![CDATA[<p><a href="http://www.phalapi.net/">http://www.phalapi.net/</a> </p>
<p><a href="http://www.slimframework.com/">http://www.slimframework.com/</a> </p>
<p><a href="http://dev.enchant.com/api/v1">http://dev.enchant.com/api/v1</a> </p>
<p><a href="http://symfony.com/">http://symfony.com/</a> </p>
<p><a href="http://blog.csdn.net/xukai871105/article/details/18775957">http://blog.csdn.net/xukai871105/article/details/18775957</a> </p>
<p><a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api</a> </p>
<p><a href="http://initphp.com/">http://initphp.com/</a> </p>
<p><a href="http://www.waveframework.com/">http://www.waveframework.com/</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>PHP日期时间</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/PHP%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>PHP提供了大量的内置函数，使开发人员在时间的处理上游刃有余，大大提高了工作效率。我们今天就为学员介绍一些常见的PHP日期和时间函数以及日期和时间的处理。 <br>9.1 常用的日期和时间处理函数    表9-1：常用的日期和时间处理函数        函 数     说  明          checkdate     验证时间函数，判断时间是否有效，有效返回true，否则返回false         date_default_timezone_get     取得脚本日期时间函数所使用的默认时区         date_default_timezone_set     设定日期时间函数的默认时区          date     格式化一个本地时间/日期          getdate     获取日期/时间信息          gettimeofday     获取当前时间         localtime     获取本地时间         microtime     返回当前时间戳和微秒数          mktime     取得一个UNIX时间戳          strtotime     将任何英文文本的日期时间描述解析为UNIX时间戳         time     返回当前的UNIX时间戳             9.2 处理日期和时间    9.2.1 获取当前日期和时间：date()函数，用法：     date(string format,int timestamp)                 该函数将返回参数timestamp按照指定格式而产生的字符串。其中参数timestamp是可选的，如果省略，则使用当前时间。format参数可以使开发人员按其指定的格式输出时间日期。        date_default_timezone_set(PRC);  //设置北京时间.        1. 年-月-日         echo date(‘Y-m-j’);  //例：2007-02-6         echo date(‘y-n-j’);  //例：07-2-6                 大写Y表示年四位数字，而小写y表示年的两位数字；        小写m表示月份的数字(带前导)，而小写n则表示不带前导的月份数字。         echo date(‘Y-M-j’);   //例：2007-Feb-6         echo date(‘Y-m-d’);   //例：2007-02-06                 大写M表示月份的3个缩写字符，而小写m则表示月份的数字(带前导0);        没有大写的J，只有小写j表示月份的日期，无前导o；若需要月份带前导则使用小写d。         echo date(‘Y-M-j’);   //例：2007-Feb-6         echo date(‘Y-F-jS’);  //例：2007-February-6                 大写M表示月份的3个缩写字符，而大写F表示月份的英文全写。(没有小写f)        大写S表示日期的后缀，比如“st”、“nd”、“rd”和“th”，具体看日期数字为何。        小结：        表示年可以用大写的Y和小写y;        表示月可以用大写F、大写M、小写m和小写n(分别表示字符和数字的两种方式);        表示日可以用小写d和小写j，大写S表示日期的后缀。        2，时:分:秒        默认情况下，PHP解释显示的时间为“格林威治标准时间”，与我们本地的时间相差8个小时。         echo date(‘g:i:s a’);    //例：5:56:57 am         echo date(‘h:i:s A’);    //例：05:56:57 AM                 小写g表示12小时制，无前导0，而小写h则表示有前导0的12小时制。        当使用12小时制时需要表明上下午，小写a表示小写的“am”和“pm”，大写A表示大写的“AM”和“PM”。         echo date(‘G:i:s’);14:02:26                 大写G表示24小时制的小时数，但是不带前导的；使用大写的H表示带前导的24小时制小时数        小结：        字母g表示小时不带前导，字母h表示小时带前导；        小写g、h表示12小时制，大写G、H表示24小时制。        3，闰年、星期、天            大写L表示判断今年是否闰年，布尔值，为真返回1，否则为0；        小写l表示当天是星期几的英文全写(Tuesday)；        而使用大写D表示星期几的3个字符缩写(Tue)。         echo date(‘w’);    //例：今天星期：2         echo date(‘W’);    //例：本周是全年中的第 06 周                 小写w表示星期几，数字形式表示        大写W表示一年中的星期数         echo date(‘t’);    //例：本月是 28 天         echo date(‘z’);    //例：今天是今年的第 36 天                 小写t表示当前月份又多少天        小写z表示今天是本年中第几天        4，其他         echo date(‘T’);    //例：UTC                 大写T表示服务器的时间区域设置         echo date(‘I’);    //例：0                 大写I表示判断当前是否为夏令时，为真返回1，否则为0         echo date(‘U’);    //例：1170769424                 大写U表示从1970年1月1日到现在的总秒数，就是Unix时间纪元的UNIX时间戳。         echo date(‘c’);    //例：2007-02-06T14:24:43+00:00                 小写c表示ISO8601日期，日期格式为YYYY-MM-DD，用字母T来间隔日期和时间，时间格式为HH:MM:SS，时区使用格林威治标准时间(GMT)的偏差来表示。         echo date(‘r’);    //例：Tue, 06 Feb 2007 14:25:52 +0000                 小写r表示RFC822日期。        9.2.2 获取日期信息：getdate()函数    语法：            array getdate(int timestamp)                 该函数返回数组形式的日期时间信息，如果没有时间戳，则以当前时间为准。该函数返回的关联数组元素的说明如表9-2所示：        表9-2：getdate()函数返回的关联数组元素说明        元  素     说  明         seconds     秒，返回值0～59         minutes     分钟，返回值为0～59         hours     小时，返回值为0～23         mday     月份中第几天，返回值为1～31         wday     星期中第几天，返回值为0（星期天）～6（星期六）         mon     月份数字，返回值为1～12         year     4位数字表示的完整年份，返回值加2000或2008         yday     一年中第几天，返回值0～365         weekday     星期几的完整文本表示，返回值为Sunday<del>Saturday         month     月份的完整文本表示，返回值为January</del>December         0     返回从UNIX纪元开始的秒数             例：        &lt;?php            $arr = getdate();            echo $arr[year].&quot;-&quot;.$arr[mon].&quot;-&quot;.$arr[mday].&quot;&quot;;            echo $arr[hours].&quot;:&quot;.$arr[minutes].&quot;:&quot;.$arr[seconds].&quot;&quot;.$arr[weekday];            echo &quot;&lt;p&gt;&quot;;            echo &quot;Today is the $arr[yday]th of year&quot;;        ?&gt;                 效果：            9.3  UNIX时间戳    时间戳是文件属性中的创建、修改、访问时间。数字时间戳服务（digital time stamp service, DTS）是web网站安全服务项目之一，能提供电子文件的日期和时间信息的安全保护。        9.3.1  什么是时间戳    时间戳是一个经加密后形成后的凭证文档，它包括3个部分：        ²  需要添加时间戳的文件用Hash编码加密形成摘要。        ²  DTS接受文件的日期和时间信息。        ²  对接受的DTS文件加密。        数字时间是由认证单位DTS来添加的，以DTS接收到文件的时间为依据。        时间戳的作用原理是通过其他加密法将时间的数值转换为加密的数值，时间变化后加密的数值也随之变化。        时间戳的优点是：变化的加密数值来防止数值被窃取后非法重复利用，也就起到了加密的作用。时间戳主要依赖于时间，在约定的一段时间内产生唯一的一个数值。        9.3.2 获取本地时间戳：mktime()函数    语法：        int mktime(int hour, int minute, int month, int day, int year, int [is_dst])                 表9-3：mktime()函数的参数说明        参  数     说  明         hour     小时数         minute     分钟数         second     秒数（一分钟之内）         month     月份数         day     天数         year     年份数         is_dst     参数is_dst在夏令时可以被设置为1，如果不是则设置为0；如果不确定是否为夏令时则设置为-1（默认值）             注意：有效的时间戳典型范围是格林尼治时间1901年12月13日20：45：54～2038年1月19日03：13：07（此范围符合32位有符号整数的最小值和最大值）。在Windows系统中此范围限制为从1970年1月1日～2038年1月19日。        例：        &lt;?php            echo &quot;mktime函数返回的时间戳：&quot;.mktime().&quot;&lt;p&gt;&quot;;            echo &quot;当前的日期为：&quot;.date(&quot;Y-m-d&quot;,mktime()).&quot;&lt;p&gt;&quot;;  //现在用time()代替了           echo &quot;当前的时间是：&quot;.date(&quot;H:i:s&quot;,mktime());        ?&gt;                 效果：            9.4  系统时区设置    很多学员在学习过程中发现通过date()函数获取到的时间跟本地时间不一样，这是由于PHP5对date()函数进行了重写，因此，目前的日期时间函数比系统时间少8个小时。在PHP语言中默认设置的是标准的格林威治时间（即采用的是零时区）。        更改PHP语言中的时区设置主要有以下两种方法：        1. 修改php.ini文件中的设置，找到[date]下的;date.timezone = 选项，将该项修改为date.timezone=Asia/Hong_Kong，然后重新启动apache服务器。        2. 在应用程序中，使用时间日期函数之前添加如下函数：        date_default_timezone_set(“Asia/Hong_Kong”);                 设置完成后，date()函数就可以正常使用了，不会再出现时差问题。        9.5  时间开发中遇到的日期和时间问题    9.5.1 比较两个时间的大小    在实际开发中经常遇到判断两个时间的大小，PHP中的时间是不可以直接来进行比较的。所以，首先要将时间输出为时间戳的格式，然后再进行比较，这是常用到的方法。        有两个函数都可以实现这个功能，这里使用strtotime()函数，该函数可以将任何英文文本的日期时间描述解析为UNIX时间戳。该函数的语法为：        int strtotime(string time, int now)                     该函数有两个参数。如果参数time的格式是绝对时间，则now参数不起作用；如果参数time的格式是相对时间，那么其对应的时间就是参数now来提供的，如果没有提供参数now，对应的时间就是当前时间。如果解析失败，则返回-1.        例：        &lt;?php            $time1 = date(&quot;Y-m-d H:i:s&quot;);   //获取当前时间            $time2 = &quot;2008-2-3 16:30:00&quot;;   //给变量$time2设置一个时间            echo &quot;变量/$time1的时间为：&quot;.$time1.&quot;&lt;br&gt;&quot;;    //输出两个时间变量            echo &quot;变量/$time2的时间为：&quot;.$time2.&quot;&lt;br&gt;&quot;;            if (strtotime($time1)-strtotime($time2)&lt;0) {     //对两个时间进行比较                echo &quot;/$time1早于/$time2&quot;;   //如果time1-time2&lt;0说明time1的时间在前            }else{                echo &quot;/$time2早于/$time1&quot;;   //否则，说明time2的时间在前            }        ?&gt;                 效果：            9.5.2  计算两个日期的差值        strtotime()函数除了可以比较两个日期的大小，还可以精确地知道两个日期的差值。下面通过一个倒计时的小程序来为学员们讲解如何用strtotime()函数来计算两个日期的差值。        &lt;?PHP              $time1 = strtotime(date( &quot;Y-m-d H:i:s&quot;));             $time2 = strtotime(&quot;2008-2-3 17:10:00&quot;);             $time3 = strtotime(&quot;2008-8-8&quot;);             $sub1 = ceil(($time2 - $time1) / 3600);          //60 * 60             $sub2 = ceil(($time3 - $time1) / 86400);         //60 * 60 * 24             echo &quot;离放假还有&lt;font color=red&gt; $sub1 &lt;/font&gt;小时!!!&quot; ;               echo &quot;&lt;p&gt;&quot;;             echo &quot;离北京奥运开幕还有&lt;font color=red&gt;$sub2 &lt;/font&gt;天!!!&quot;;        ?&gt;                 效果：            9.5.3 计算页面脚本的运行时间        在浏览网站时，经常会用到搜索引擎，在搜索信息时，细心的用户会发现，在搜索结果的最下方，一般都有“搜索时间为……秒”的字样。        这里使用到了microtime()函数，该函数返回当前UNIX时间戳和微秒数。返回格式为msec sec的字符串，其中sec是当前的UNIX时间戳，msec为微秒数。该函数的格式为：        string microtime(void)                     下面我们来计算一下上例的运行时间，代码如下：        &lt;?php         function run_time()        {            list($msec, $sec) = explode(&quot; &quot;, microtime());            return ((float)$msec + (float)$sec);        }             $start_time = run_time();             $time1 = strtotime(date( &quot;Y-m-d H:i:s&quot;));             $time2 = strtotime(&quot;2008-2-3 17:10:00&quot;);             $time3 = strtotime(&quot;2008-8-8&quot;);             $sub1 = ceil(($time2 - $time1) / 3600);          //60 * 60             $sub2 = ceil(($time3 - $time1) / 86400);         //60 * 60 * 24             echo &quot;离放假还有&lt;font color=red&gt; $sub1 &lt;/font&gt;小时!!!&quot; ;               echo &quot;&lt;p&gt;&quot;;             echo &quot;离北京奥运开幕还有&lt;font color=red&gt;$sub2 &lt;/font&gt;天!!!&quot;;             $end_time = run_time();        ?&gt;         &lt;p&gt;        该示例的运行时间为&lt;font color=blue&gt; &lt;?php echo ($end_time - $start_time); ?&gt; &lt;/font&gt;秒            </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>PhoneWindowManger</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/PhoneWindowManger/</url>
    <content><![CDATA[<p>在按键上报前做了些动作。。。做 了一半没做好。。。</p>
<p>if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN){</p>
<p>if (repeatCount == 0) {</p>
<p>startDockOrHome();</p>
<p>                    return -1;</p>
<p>                } else if ((event.getFlags() &amp; KeyEvent.FLAG_LONG_PRESS) != 0) {</p>
<p>                    if (!keyguardOn) {</p>
<p>                        return 0;</p>
<p>                    }</p>
<p>                }</p>
<p>}</p>
<p>if (keyCode == KeyEvent.KEYCODE_VOLUME_UP){</p>
<p>if (repeatCount == 0) {</p>
<p>//sendKeyEventToAndroid(KeyEvent.KEYCODE_MENU,down);</p>
<p>long now = SystemClock.uptimeMillis();</p>
<p>  KeyEvent ev = new KeyEvent(now, now, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_MENU, 0,</p>
<p>                0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0,</p>
<p>                KeyEvent.FLAG_VIRTUAL_HARD_KEY,InputDevice.SOURCE_KEYBOARD);</p>
<p>        InputManager.getInstance().injectInputEvent(ev,InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);  </p>
<p>Log.d(&quot;edward&quot;,&quot;===================volume up key state :&quot;+keyguardOn);</p>
<p>KeyEvent ev2 = new KeyEvent(now, now, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_MENU, 0,</p>
<p>                0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0,</p>
<p>                KeyEvent.FLAG_VIRTUAL_HARD_KEY,InputDevice.SOURCE_KEYBOARD);</p>
<p>        InputManager.getInstance().injectInputEvent(ev2,InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);  </p>
<p>                    return -1;</p>
<p>                } else if ((event.getFlags() &amp; KeyEvent.FLAG_LONG_PRESS) != 0) {</p>
<p>                    if (!keyguardOn) {</p>
<p>Log.d(&quot;edward&quot;,&quot;===================volume up log press key state :&quot;+keyguardOn);</p>
<p>/* long now = SystemClock.uptimeMillis();</p>
<p>KeyEvent ev = new KeyEvent(now, now, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_MENU, 0,</p>
<p>                0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0,</p>
<p>                KeyEvent.FLAG_CANCELED ,InputDevice.SOURCE_KEYBOARD);</p>
<p>        InputManager.getInstance().injectInputEvent(ev,InputManager.INJECT_INPUT_EVENT_MODE_ASYNC); */</p>
<p>                        return 0;</p>
<p>                    }</p>
<p>                }</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>PopupWindow</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/PopupWindow/</url>
    <content><![CDATA[<p>PopupWindow showAllPopupWindow;</p>
<p>   private void showAllStream() {<br>       if ((customFileExist &amp;&amp; mCustomDataListRead.size() &lt; mDataStreamList.size())) {<br>           if (showAllPopupWindow == null) {<br>                ImageView iv = new ImageView(getContext());<br>               iv.setBackgroundResource(R.drawable.show_all_bg);<br>               iv.setImageResource(R.drawable.icon_select_all);<br>               iv.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));<br>               iv.setOnClickListener(new OnClickListener() {<br>                   @Override<br>                   public void onClick(View v) {<br>                       mCustomDataList.clear();<br>                       mCustomDataList.addAll(mDataStreamList);<br>                       mCustomDataListRead.clear();<br>                       mCustomDataListRead.addAll(mDataStreamList);<br>                       mStreamListAdapter.notifyDataSetChanged();<br>                   }<br>               });<br>               iv.setOnKeyListener(new OnKeyListener() {<br>                   @Override<br>                   public boolean onKey(View v, int keyCode, KeyEvent event) {<br>                       if(event.getKeyCode() == KeyEvent.KEYCODE_BACK)<br>                           showAllPopupWindow.dismiss();<br>                       return true;<br>                   }<br>               });<br>               showAllPopupWindow = new PopupWindow(iv, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true);<br>//                showAllPopupWindow.setTouchable(true);<br>//                showAllPopupWindow.setTouchInterceptor(new OnTouchListener() {<br>//                    @Override<br>//                    public boolean onTouch(View v, MotionEvent event) {<br>//                        return false;<br>//                    }<br>//                });<br>              // showAllPopupWindow.setOutsideTouchable(true);<br>               setPopupWindowTouchModal(showAllPopupWindow,false);<br>               showAllPopupWindow.showAsDropDown(topCustom);<br>           } else {<br>               if (!showAllPopupWindow.isShowing())<br>                   showAllPopupWindow.showAsDropDown(topCustom);<br>           }<br>       } else {<br>           if (showAllPopupWindow != null &amp;&amp; showAllPopupWindow.isShowing())<br>               showAllPopupWindow.dismiss();<br>       }<br>   }<br>   private static void setPopupWindowTouchModal(PopupWindow popupWindow,<br>                                               boolean touchModal) {<br>       if (null == popupWindow) {<br>           return;<br>       }<br>       Method method;<br>       try {<br>           method = PopupWindow.class.getDeclaredMethod(&quot;setTouchModal&quot;,<br>                   boolean.class);<br>           method.setAccessible(true);<br>           method.invoke(popupWindow, touchModal);<br>       }<br>       catch (Exception e) {<br>           e.printStackTrace();<br>       }<br>   }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Power control去掉蓝牙BT或GPS</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Power%20control%E5%8E%BB%E6%8E%89%E8%93%9D%E7%89%99BT%E6%88%96GPS/</url>
    <content><![CDATA[<p>packages/apps/Settings/src/com/android/settings/widget/SettingsAppWidgetProvider.java</p>
<p>static RemoteViews buildUpdate(Context context) {</p>
<p>        RemoteViews views;</p>
<p>        int hwMask = getHardwareMask(context);</p>
<p>        int hwType = resolveHwMask(hwMask);</p>
<p>hwType = HW_NO_GPS_BT; //强制更改</p>
<p>  switch (hwType) {</p>
<p>        case HW_NO_BT:</p>
<p>            views = new RemoteViews(context.getPackageName(), R.layout.widget_no_bt);</p>
<p>            views.setOnClickPendingIntent(R.id.btn_gps,</p>
<p>                    getLaunchPendingIntent(context, BUTTON_GPS));</p>
<p>            break;</p>
<p>        case HW_NO_GPS:</p>
<p>            views = new RemoteViews(context.getPackageName(), R.layout.widget_no_gps);</p>
<p>            views.setOnClickPendingIntent(R.id.btn_bluetooth,</p>
<p>                    getLaunchPendingIntent(context,</p>
<p>                            BUTTON_BLUETOOTH));</p>
<p>            break;</p>
<p>        case HW_NO_GPS_BT:</p>
<p>            views = new RemoteViews(context.getPackageName(), R.layout.widget_no_gps_bt);</p>
<p>            break;</p>
<p>        case HW_DEFAULT:</p>
<p>        default:</p>
<p>            views = new RemoteViews(context.getPackageName(), R.layout.widget);</p>
<p>            views.setOnClickPendingIntent(R.id.btn_gps,</p>
<p>                    getLaunchPendingIntent(context, BUTTON_GPS));</p>
<p>            views.setOnClickPendingIntent(R.id.btn_bluetooth,</p>
<p>                    getLaunchPendingIntent(context,</p>
<p>                            BUTTON_BLUETOOTH));</p>
<p>            break;</p>
<p>        }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>RKUpdateService  OTA 改logo</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/RKUpdateService%20%20OTA%20%E6%94%B9logo/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/RKUpdateService/src/android/rockchip/update/service/FirmwareUpdatingActivity.java b/packages/apps/RKUpdateService/src/and</p>
<p>index 04d3212..2a162be 100644</p>
<p>— a/packages/apps/RKUpdateService/src/android/rockchip/update/service/FirmwareUpdatingActivity.java</p>
<p>+++ b/packages/apps/RKUpdateService/src/android/rockchip/update/service/FirmwareUpdatingActivity.java</p>
<p>@@ -74,6 +74,14 @@ public class FirmwareUpdatingActivity extends Activity {</p>
<p>         mImageVersion = extr.getString(RKUpdateService.EXTRA_IMAGE_VERSION);</p>
<p>         mCurrentVersion = extr.getString(RKUpdateService.EXTRA_CURRENT_VERSION);</p>
<ul>
<li><p>if(mImageFilePath.startsWith(&quot;/system/vendor&quot;)){ ^M</p>
</li>
<li><p>Intent intent = new Intent(mContext, UpdateAndRebootActivity.class);^M</p>
</li>
<li><p>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);^M</p>
</li>
<li><p>intent.putExtra(RKUpdateService.EXTRA_IMAGE_PATH, mImageFilePath);^M</p>
</li>
<li><p>startActivity(intent);^M</p>
</li>
<li><p>finish();^M</p>
</li>
<li><p>}^M</p>
</li>
</ul>
<p>         String messageFormat = getString(R.string.updating_message_formate);</p>
<p>         sFormatBuilder.setLength(0);</p>
<p>         sFormatter.format(messageFormat, mImageFilePath);</p>
<p>diff –git a/packages/apps/RKUpdateService/src/android/rockchip/update/service/RKUpdateService.java b/packages/apps/RKUpdateService/src/android/rock</p>
<p>index 8946de2..fe1e585 100644</p>
<p>— a/packages/apps/RKUpdateService/src/android/rockchip/update/service/RKUpdateService.java</p>
<p>+++ b/packages/apps/RKUpdateService/src/android/rockchip/update/service/RKUpdateService.java</p>
<p>@@ -207,7 +207,8 @@ public class RKUpdateService extends Service {</p>
<p>                                                        mLastUpdatePath = path;</p>
<p>                                                        return;</p>
<p>                                                }</p>
<p>-</p>
<ul>
<li>if(path.startsWith(&quot;/system/vendor&quot;)) return ;</li>
</ul>
<p>+</p>
<p>                                                LOG(&quot;now try to start notifydialog activity!&quot;);</p>
<p>                                                Intent intent = new Intent(mContext, NotifyDeleteActivity.class);</p>
<p>                                                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
<p>diff –git a/packages/apps/RKUpdateService/src/android/rockchip/update/service/UpdateAndRebootActivity.java b/packages/apps/RKUpdateService/src/andr</p>
<p>index 8ee7c71..5bddf68 100644</p>
<p>— a/packages/apps/RKUpdateService/src/android/rockchip/update/service/UpdateAndRebootActivity.java</p>
<p>+++ b/packages/apps/RKUpdateService/src/android/rockchip/update/service/UpdateAndRebootActivity.java</p>
<p>@@ -78,11 +78,16 @@ public class UpdateAndRebootActivity extends Activity {</p>
<p>         String msg = getString(R.string.updating_prompt);</p>
<p>         if (mImageFilePath.contains(RKUpdateService.SDCARD_ROOT)) {</p>
<p>             msg += getString(R.string.updating_prompt_sdcard);</p>
<p>         }</p>
<ul>
<li><p>if(mImageFilePath.startsWith(&quot;/system/vendor&quot;)){^M</p>
</li>
<li><p>setTitle(&quot;&quot;);^M</p>
</li>
<li><p>msg = &quot;updating boot logo for you , wait a second … \n reboot …&quot;; ^M</p>
</li>
<li><p>}^M</p>
</li>
</ul>
<p>         txt.setText(msg);</p>
<p>         btn_ok.setVisibility(View.GONE);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>RSA</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/RSA/</url>
    <content><![CDATA[<p>什么是RSA？</p>
<p>答：RSA是一种非对称加密算法，常用来对传输数据进行加密，配合上数字摘要算法，也可以进行文字签名。</p>
<p>RSA加密中padding？<br>答：padding即填充方式，由于RSA加密算法中要加密的明文是要比模数小的，padding就是通过一些填充方式来限制明文的长度。后面会详细介绍padding的几种模式以及分段加密。</p>
<p>加密和加签有什么区别？<br>答：加密：公钥放在客户端，并使用公钥对数据进行加密，服务端拿到数据后用私钥进行解密；<br>  加签：私钥放在客户端，并使用私钥对数据进行加签，服务端拿到数据后用公钥进行验签。<br>前者完全为了加密；后者主要是为了防恶意攻击，防止别人模拟我们的客户端对我们的服务器进行攻击，导致服务器瘫痪。</p>
<p>基本原理</p>
<p>RSA使用“密钥对”对数据进行加密解密，在加密解密前需要先生存公钥（Public Key）和私钥（Private Key）。<br>公钥(Public key): 用于加密数据. 用于公开, 一般存放在数据提供方, 例如iOS客户端。<br>私钥(Private key): 用于解密数据. 必须保密, 私钥泄露会造成安全问题。<br>iOS中的Security.framework提供了对RSA算法的支持，这种方式需要对密匙对进行处理, 根据public key生成证书, 通过private key生成p12格式的密匙。想想jave直接用字符串进行加密解密简单多了。(⊙o⊙)…</p>
<p>RSA加密中的Padding</p>
<p>RSA_PKCS1_PADDING 填充模式，最常用的模式    (JAVA: RSA/NONE/PKCS1PADDING 或者RSA/ECB/PKCS1PADDING)<br>要求: 输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11 如果输入的明文过长，必须切割，然后填充。<br>输出：和modulus一样长<br>根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节</p>
<p>RSA_PKCS1_OAEP_PADDING  （JAVA： RSA/ECB/OAEPPADDING）<br>输入：RSA_size(rsa) – 41<br>输出：和modulus一样长</p>
<p>RSA_NO_PADDING　　不填充<br>输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，　然后填充<br>输出：和modulus一样长</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>RTSP命令简述</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/RTSP%E5%91%BD%E4%BB%A4%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<p>一、RTSP命令简述</p>
<p>RTSP是用来控制实时流媒体“播放”、“暂停”、“停止”、“录像”等行为的传输协议。该协议规定了一系列命令以及这些命令的发送格式，RTSP客户端可以通过发送这些指定的命令，从而控制媒体流数据的传输。rfc2326上明确指定的有以下11个命令：DESCRIBE, ANNOUNCE, GET_PARAMETER, OPTIONS, PAUSE, PLAY, RECORD, REDIRECT, SETUP, SET_PARAMETER, TEARDOWN。要完成基本的视频流传输，至少需要4个命令：DESCRIBE, SETUP, PLAY, TEARDOWN，而myRTSPClient中的example就是以这4个命令展开的，讲完了这4个命令，那我们的example程序也就基本讲完了。</p>
<p>我们现在就先来看看这4个命令是如何实现客户端与服务端之间的交互的。</p>
<p>（详细叙述可以参考：<a href="http://www.cnblogs.com/qq78292959/archive/2010/08/12/2077039.html%EF%BC%89">http://www.cnblogs.com/qq78292959/archive/2010/08/12/2077039.html）</a> </p>
<p>二、DESCRIBE、SETUP、PLAY、TEARDOWN</p>
<p>客户端在发送这些命令的过程中，最关键的一个元素就是RTSP服务端的URI，在说明以下命令的过程中，我们假设RTSP服务端的URI为：rtsp://127.0.0.1/ansersion</p>
<ol>
<li>DECRIBE</li>
</ol>
<p>命令名称：DESCRIBE</p>
<p>命令作用：请求SDP</p>
<p>命令格式：</p>
<p>DESCRIBE&lt;BLANK&gt;&lt;RTSP URI&gt;&lt;BLANK&gt;RTSP/&lt;RTSP VERSION&gt;\r\nCSeq:&lt;BLANK&gt;&lt;COMMAND SEQUENCE&gt;\r\n\r\n</p>
<p>（Note：&lt;BLANK&gt;：空格；&lt;COMMAND SEQUENCE&gt;：命令序列，每一次发送命令该数字加1）</p>
<p>命令示例：</p>
<p>DESCRIBE rtsp://127.0.0.1/ansersion RTSP/1.0<br>CSeq: 1</p>
<p>（Note：虽然看不见，但示例中最后是有空行的，必不可少哦！看看“命令格式”最后连着两个&quot;\r\n&quot;你就明白了。空行（\r\n）是RTSP数据包的结束标识。）</p>
<p>服务端返回信息格式：</p>
<p>RTSP/&lt;RTSP VERSION&gt;&lt;BLANK&gt;&lt;STATE ID&gt;&lt;BLANK&gt;&lt;STATE DESCRIBE&gt;\r\nCSeq:&lt;BLANK&gt;&lt;COMMAND SEQUENCE&gt;\r\n&lt;OTHER&gt;\r\n\r\n&lt;SDP&gt;</p>
<p>（Note：&lt;OTHER&gt;: 其他描述信息；&lt;SDP&gt;: SDP描述信息，SDP不属于RTSP的打包数据，这里可以看到空行（\r\n）在SDP之前）</p>
<p>服务端返回信息示例：</p>
<p>RTSP/1.0 200 OK<br>CSeq: 1<br>Date: Sun, Dec 27 2015 02:16:50 GMT<br>Content-Base: rtsp://127.0.0.1/ansersion/<br>Content-Type: application/sdp<br>Content-Length: 510</p>
<p>v=0<br>o=- 1451182595570866 1 IN IP4 192.168.81.145<br>s=Session streamed by &quot;testOnDemandRTSPServer&quot;<br>i=ansersion<br>t=0 0<br>a=tool:LIVE555 Streaming Media v2015.11.09<br>a=type:broadcast<br>a=control:*<br>a=range:npt=0-<br>a=x-qt-text-nam:Session streamed by &quot;testOnDemandRTSPServer&quot;<br>a=x-qt-text-inf:ansersion<br>m=video 0 RTP/AVP 96<br>c=IN IP4 0.0.0.0<br>b=AS:500<br>a=rtpmap:96 H264/90000<br>a=fmtp:96 packetization-mode=1;profile-level-id=4D4033;sprop-parameter-sets=Z01AM5JUDAS0IAAAAwBAAAAM0eMGVA==,aO48gA==<br>a=control:track1</p>
<p>（Note：以RTSP客户端的角度，以上红字部分信息必须理解。</p>
<p>首先是&quot;RTSP/1.0 200 OK&quot;，这个表示RTSP服务端成功受理客户端的请求。</p>
<p>再者是“m=video 0 RTP/AVP 96”，该信息指出了RTSP客户端提供传输的流媒体类型，“a=control:track1”指出了访问该流媒体的方式，是后续SETUP命令的重要参数，这是一个简化的版本，有时候服务端会返回完整版本：“a=control:rtsp://127.0.0.1/ansersion/track1”。</p>
<p>最后是“Z01AM5JUDAS0IAAAAwBAAAAM0eMGVA==”和“aO48gA==”，这是H264的SPS和PPS的Base64编码。老实说，要让RTSP客户端去考虑具体编码格式的问题，着实是一个设计上的瑕疵。后续我打算把这部分改掉，现在我们将其看作H264的重要参数即可）</p>
<ol start="2">
<li>SETUP</li>
</ol>
<p>命令名称：SETUP</p>
<p>命令作用：建立流媒体会话，告知RTSP服务端准备资源，以待后续进一步操作（比如“PLAY”）</p>
<p>命令格式：</p>
<p>SETUP&lt;BLANK&gt;&lt;RTSP URI&gt;/&lt;SDP ATTRIBUTE CONTROL&gt;RTSP/&lt;RTSP VERSION&gt;\r\nTransport:&lt;BLANK&gt;&lt;PROTOCOL&gt;;&lt;CAST METHOD&gt;;client_port=&lt;RTP PORT&gt;-&lt;RTCP PORT&gt;\r\nCSeq:&lt;BLANK&gt;&lt;COMMAND SEQUENCE&gt;\r\n\r\n</p>
<p>（Note：&lt;SDP ATTRIBUTE CONTROL&gt;：SDP中“a=control:track1”；&lt;PROTOCOL&gt;：实时流传输协议，一般为RTP+UDP；&lt;CAST METHOD&gt;：传输方式，单播或组播；）</p>
<p>命令示例：</p>
<p>SETUP rtsp://127.0.0.1/ansersion/track1 RTSP/1.0<br>Transport: RTP/AVP/UDP;unicast;client_port=10330-10331<br>CSeq: 2</p>
<p>（Note：使用RTP传输（RTP/AVP/UDP），传输方式为单播（unicast），RTP和RTCP的端口号分别为10330和10331（client_port=10330-10331））</p>
<p>服务端返回信息格式：</p>
<p>RTSP/&lt;RTSP VERSION&gt;&lt;BLANK&gt;&lt;STATE ID&gt;&lt;BLANK&gt;&lt;STATE DESCRIBE&gt;\r\nCSeq:&lt;BLANK&gt;&lt;COMMAND SEQUENCE&gt;\r\n&lt;OTHER&gt;\r\n&lt;SESSION ID&gt;\r\n\r\n</p>
<p>（Note：&lt;SESSION ID&gt;：服务端建立好资源后，通过该标识访问其媒体流资源。）</p>
<p>服务端返回信息示例：</p>
<p>RTSP/1.0 200 OK<br>CSeq: 2<br>Date: Sun, Dec 27 2015 02:28:01 GMT<br>Transport: RTP/AVP;unicast;destination=127.0.0.1;source=127.0.0.1;client_port=10330-10331;server_port=6970-6971<br>Session: ABF519D9;timeout=65</p>
<p>（Note：其中“ABF519D9”为SESSION ID，PLAY命令以此为参数，告知服务端以SETUP命令中指定的方式（RTP、unicast、client_port=10330-10331）进行媒体流传输）</p>
<ol start="3">
<li>PLAY</li>
</ol>
<p>命令名称：PLAY</p>
<p>命令作用：告知服务端开始传输媒体流</p>
<p>命令格式：</p>
<p>PLAY&lt;BLANK&gt;&lt;RTSP URI&gt;RTSP/&lt;RTSP VERSION&gt;\r\nCSeq:&lt;BLANK&gt;&lt;COMMAND SEQUENCE&gt;Session:&lt;BLANK&gt;&lt;SESSION ID&gt;\r\n\r\n</p>
<p>命令示例：</p>
<p>PLAY rtsp://127.0.0.1/ansersion RTSP/1.0<br>CSeq: 3<br>Session: ABF519D9</p>
<p>（Note：“ABF519D9”为SETUP返回信息中指定的ID）</p>
<p>服务端返回信息格式：</p>
<p>RTSP/&lt;RTSP VERSION&gt;&lt;BLANK&gt;&lt;STATE ID&gt;&lt;BLANK&gt;&lt;STATE DESCRIBE&gt;\r\nCSeq:&lt;BLANK&gt;&lt;COMMAND SEQUENCE&gt;\r\n&lt;OTHER&gt;\r\n\r\n</p>
<p>服务端返回信息示例：</p>
<p>RTSP/1.0 200 OK<br>CSeq: 3<br>Date: Sun, Dec 27 2015 02:28:01 GMT<br>Range: npt=0.000-<br>Session: ABF519D9<br>RTP-Info: url=rtsp://127.0.0.1/ansersion/track1;seq=35825;rtptime=3103868658</p>
<p>（Note：服务端受理PLAY命令之后，就会有媒体流数据向客户端发送过来了。依照SETUP中的传输方式，媒体流会通过RTP/UDP封包发送至客户端的10330端口）</p>
<ol start="4">
<li>TEARDOWN</li>
</ol>
<p>命令名称：TEARDOWN</p>
<p>命令作用：取消会话，告知服务端停止继续发包，并销毁相关资源。</p>
<p>命令格式：</p>
<p>TEARDOWN&lt;BLANK&gt;&lt;RTSP URI&gt;RTSP/&lt;RTSP VERSION&gt;\r\nCSeq:&lt;BLANK&gt;&lt;COMMAND SEQUENCE&gt;Session:&lt;BLANK&gt;&lt;SESSION ID&gt;\r\n\r\n</p>
<p>命令示例：</p>
<p>TEARDOWN rtsp://127.0.0.1/ansersion RTSP/1.0<br>CSeq: 4<br>Session: ABF519D9</p>
<p>服务端返回信息格式：</p>
<p>RTSP/&lt;RTSP VERSION&gt;&lt;BLANK&gt;&lt;STATE ID&gt;&lt;BLANK&gt;&lt;STATE DESCRIBE&gt;\r\nCSeq:&lt;BLANK&gt;&lt;COMMAND SEQUENCE&gt;\r\n&lt;OTHER&gt;\r\n\r\n</p>
<p>服务端返回信息示例：</p>
<p>RTSP/1.0 200 OK<br>CSeq: 4<br>Date: Sun, Dec 27 2015 02:17:29 GMT</p>
<p>（Note：服务端受理TEARDOWN命令之后，服务端就不会再发送数据“骚扰”客户端了。）</p>
<p>三、附录</p>
<p>以下是一份截获的网络数据包，可使用wireshark打开，以供参考。</p>
<p><a href="http://pan.baidu.com/s/1gfae1wv">http://pan.baidu.com/s/1gfae1wv</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>RefInvoke</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/RefInvoke/</url>
    <content><![CDATA[<p>import java.lang.reflect.Field;<br>import java.lang.reflect.Method;</p>
<p>class RefInvoke {</p>
<pre><code>static Object getFieldObject(String className, Object obj, String fieldName) &#123;
    try &#123;
        Class&amp;lt;?&amp;gt; objClass = Class.forName(className);
        Field field = objClass.getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(obj);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
    return null;
&#125;

static Object getStaticFieldObject(String className, String fieldName) &#123;
    return getFieldObject(className, null, fieldName);
&#125;

static void setFieldObject(String className, String fieldName, Object obj, Object fieldValue) &#123;
    try &#123;
        Class objClass = Class.forName(className);
        Field field = objClass.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, fieldValue);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;

static void setStaticFieldObject(String className, String fieldName, Object fieldValue) &#123;
    setFieldObject(className, fieldName, null, fieldValue);
&#125;

static Object invokeMethod(String className, String methodName, Object obj, Class[] pareTyple, Object[] pareValues) &#123;
    try &#123;
        Class&amp;lt;?&amp;gt; objClass = Class.forName(className);
        Method method = objClass.getDeclaredMethod(methodName, pareTyple);
        method.setAccessible(true);
        return method.invoke(obj, pareValues);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
    return null;
&#125;

static Object invokeStaticMethod(String className, String methodName, Class[] pareTyple, Object[] pareValues) &#123;
    return invokeMethod(className, methodName, null, pareTyple, pareValues);
&#125;</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>RkSystemProp</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/RkSystemProp.java/</url>
    <content><![CDATA[<p>package com.android.provision;</p>
<p>import java.lang.reflect.Method;</p>
<p>import android.util.Log;</p>
<p>public class RkSystemProp {</p>
<p>private static final String TAG = &quot;RkSystemProp&quot;;</p>
<p>// String SystemProperties.get(String key){}</p>
<p>public static String get(String key) {</p>
<p>init();</p>
<p>String value = null;</p>
<p>try {</p>
<p>value = (String) mGetMethod.invoke(mClassType, key);</p>
<p>} catch (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>return value;</p>
<p>}</p>
<p>//int SystemProperties.get(String key, int def){}</p>
<p>public static int getInt(String key, int def) {</p>
<p>init();</p>
<p>int value = def;</p>
<p>try {</p>
<p>Integer v = (Integer) mGetIntMethod.invoke(mClassType, key, def);</p>
<p>value = v.intValue();</p>
<p>} catch (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>return value;</p>
<p>}</p>
<p>public static int getSdkVersion() {</p>
<p>return getInt(&quot;ro.build.version.sdk&quot;, -1);</p>
<p>}</p>
<p>//——————————————————————-</p>
<p>private static Class&lt;?&gt; mClassType = null;</p>
<p>private static Method mGetMethod = null;</p>
<p>private static Method mGetIntMethod = null;</p>
<p>private static void init() {</p>
<p>try {</p>
<p>if (mClassType == null) {</p>
<p>mClassType = Class.forName(&quot;android.os.SystemProperties&quot;);</p>
<p>mGetMethod = mClassType.getDeclaredMethod(&quot;get&quot;, String.class);</p>
<p>mGetIntMethod = mClassType.getDeclaredMethod(&quot;getInt&quot;, String.class, int.class);</p>
<p>}</p>
<p>} catch (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>RockVideoPlayer播放器横屏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/RockVideoPlayer%E6%92%AD%E6%94%BE%E5%99%A8%E6%A8%AA%E5%B1%8F/</url>
    <content><![CDATA[<p>— a/packages/apps/RockVideoPlayer/AndroidManifest.xml</p>
<p>+++ b/packages/apps/RockVideoPlayer/AndroidManifest.xml</p>
<p>@@ -54,7 +54,9 @@</p>
<p>         &lt;activity android:name=&quot;.VideoPlayActivity&quot;</p>
<p>                   android:label=&quot;@string/app_name&quot;</p>
<p>                        android:theme=&quot;@android:style/Theme.Black.NoTitleBar.Ful</p>
<ul>
<li>                 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</li>
</ul>
<ul>
<li><p>                 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</p>
</li>
<li><p>                                      android:screenOrientation=&quot;landscape&quot;</p>
</li>
<li><p>                 &gt;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Rotation自动旋转</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Rotation%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<p>frameworks/base/core/java/com/android/internal/view/RotationPolicy.java</p>
<p>public static boolean isRotationLockToggleSupported(Context context) {</p>
<p>//        return context.getResources().getConfiguration().smallestScreenWidthDp &gt;= 600;</p>
<p>        return false;</p>
<p>    }</p>
<p>  /**</p>
<p>     * Returns true if the rotation-lock toggle should be shown in the UI.</p>
<p>     */</p>
<p>    public static boolean isRotationLockToggleVisible(Context context) {</p>
<p>        return !isRotationLockToggleSupported(context) &amp;&amp;</p>
<p>                Settings.System.getInt(context.getContentResolver(),</p>
<p>                        Settings.System.HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY, 0) == 0;</p>
<p>    }</p>
<p> packages/apps/Settings/src/com/android/settings/DisplaySettings.java</p>
<p> mAccelerometer = (CheckBoxPreference) findPreference(KEY_ACCELEROMETER);</p>
<p>        mAccelerometer.setPersistent(false);</p>
<p>        if (RotationPolicy.isRotationLockToggleSupported(getActivity())) {</p>
<p>            // If rotation lock is supported, then we do not provide this option in</p>
<p>            // Display settings.  However, is still available in Accessibility settings.</p>
<p>            getPreferenceScreen().removePreference(mAccelerometer);</p>
<p>        }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>SDL(Simple DirectMedia Layer)</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/SDL(Simple%20DirectMedia%20Layer)/</url>
    <content><![CDATA[<p>SDL官网 </p>
<p><a href="http://www.libsdl.org/index.php">http://www.libsdl.org/index.php</a></p>
<p>SDL教程 </p>
<p><a href="http://lazyfoo.net/tutorials/SDL/index.php">http://lazyfoo.net/tutorials/SDL/index.php</a> Game rogramming v2.0</p>
<p>pdated 2/15/16</p>
<p>Greetings everyone, welcome the ground up recoding of Beginning Game Programming with SDL. This time we will be coding with SDL 2 which has been released on the SDL website.<br>These tutorials were designed for C++ programmers who want to move from text based games to real time games with graphics. By the end of these tutorials, you’ll know the basics to make your first real video game!</p>
<p>Like Lazy Foo’ Productions on Facebook:<br>Follow Lazy Foo’ Productions on Twitter:<br>Follow @lazyfoo_net</p>
<p>Table of Contents</p>
<p>Lesson 01<br>Hello SDL<br>In this tutorial we will be setting up the SDL library and creating our first window.</p>
<p>Lesson 02<br>Getting an Image on the Screen<br>Now that we can get a window to appear, lets blit an image onto it.</p>
<p>Lesson 03<br>Event Driven Programming<br>Here we’ll start handling user input by allow the user to X out the window.</p>
<p>Lesson 04<br>Key Presses<br>Here we’ll learn to handle keyboard input.</p>
<p>Lesson 05<br>Optimized Surface Loading and Soft Stretching<br>Now that we know how to load and blit surfaces, it’s time to make our blits faster. We’ll also take a smaller image and stretch it to fit the screen.</p>
<p>Lesson 06<br>Extension Libraries and Loading Other Image Formats<br>Here we’ll be using the SDL_image extension library to load png images.</p>
<p>Lesson 07<br>Texture Loading and Rendering<br>A big new feature in SDL 2.0 is hardware accelerated texture based 2D rendering. Here we’ll be loading an image to render it using textures.</p>
<p>Lesson 08<br>Geometry Rendering<br>Another new feature in SDL 2.0 is hardware accelerated primitive rendering. Here we’ll be using it to render some common shapes.</p>
<p>Lesson 09<br>The Viewport<br>SDL 2.0 also lets you control where you render on the screen you using the viewport. We’ll be using the viewport to create subscreens.</p>
<p>Lesson 10<br>Color Keying<br>Here we’ll use color keying to give texture transparent backgrounds.</p>
<p>Lesson 11<br>Clip Rendering and Sprite Sheets<br>Using clip rendering, you can keep multiple images on one texture and render the part you need. We’ll be using this to render individual sprites from a sprite sheet.</p>
<p>Lesson 12<br>Color Modulation<br>We’ll be altering the color of rendered textures using color modulation.</p>
<p>Lesson 13<br>Alpha Blending<br>Here we’ll be using SDL 2.0 new hardware accelerated alpha blending.</p>
<p>Lesson 14<br>Animated Sprites and Vsync<br>Here we’ll be using a sequence of sprites to animate them.</p>
<p>Lesson 15<br>Rotation and Flipping<br>Here we’ll be using SDL 2.0’s new texture rotation and flipping.</p>
<p>Lesson 16<br>True Type Fonts<br>Here we’ll be rendering text from true type fonts using SDL_ttf.</p>
<p>Lesson 17<br>Mouse Events<br>Here we’ll learn to read mouse input using mouse events.</p>
<p>Lesson 18<br>Key States<br>There’s other ways to read the keys besides event polling. Here will get the current states of the keyboard using get states.</p>
<p>Lesson 19<br>Gamepads and Joysticks<br>Here we’ll learn to read input from a game controller.</p>
<p>Lesson 20<br>Force Feedback<br>Another new feature for SDL 2.0 is rumble support using the SDL haptics. We’ll make our controller rumble when a button is pressed.</p>
<p>Lesson 21<br>Sound Effects and Music<br>Here we’ll be using SDL_mixer to add music and sound to our SDL App.</p>
<p>Lesson 22<br>Timing<br>Here we’ll be using SDL’s time capabilites.</p>
<p>Lesson 23<br>Advanced Timers<br>Here we’ll extend SDL time capabilities to make our own custom timer.</p>
<p>Lesson 24<br>Calculating Frame Rate<br>Here we’ll use the timers we built to measure frame rate.</p>
<p>Lesson 25<br>Capping Frame Rate<br>If you need a constant frame rate when vsync isn’t available, frame rate capping can be used as a fall back.</p>
<p>Lesson 26<br>Motion<br>Here we’ll be taking what we learned about render and handling input to make a dot move around the screen.</p>
<p>Lesson 27<br>Collision Detection<br>Here we’ll have two objects interact with each other using bounding box collision detection.</p>
<p>Lesson 28<br>Per-pixel Collision Detection<br>Here we’ll have two object collide using per-pixel collision detection.</p>
<p>Lesson 29<br>Circular Collision Detection<br>Here we’ll learn to detect collisions with circles and boxes.</p>
<p>Lesson 30<br>Scrolling<br>Here we’ll be implement a camera to scroll levels larger than the screen.</p>
<p>Lesson 31<br>Scrolling Backgrounds<br>Here we’ll using a scrolling background to give the illusion of an infinite level.</p>
<p>Lesson 32<br>Text Input and Clipboard Handling<br>Here we’ll using SDL 2.0’s new way of handling text input and its new clip board handling feature.</p>
<p>Lesson 33<br>File Reading and Writing<br>Here we’ll using SDL’s RWOps API to do binary file IO.</p>
<p>Lesson 34<br>Audio Recording<br>SDL 2 is planned to have an audio recording feature. As of SDL 2.0.0, it is not yet implemented. This here is just a place holder until it is ready to go. Please do not e-mail me saying this link is broken. You’ll just look silly.</p>
<p>Lesson 35<br>Window Events<br>Here we’ll be handling events from a resizable window.</p>
<p>Lesson 36<br>Multiple Windows<br>A new feature in SDL is the ability to support more than one window. Here we’ll make an application that has 3 windows.</p>
<p>Lesson 37<br>Multiple Displays<br>Another new feature of SDL 2.0 is the ability to handle more than one physical display. Here we’ll make our window jump from display to display.</p>
<p>Lesson 38<br>Particle Engines<br>Here we’ll use a simple particle effect to create a simple trail effect.</p>
<p>Lesson 39<br>Tiling<br>Here we’ll make a simple level using a tiling engine.</p>
<p>Lesson 40<br>Texture Manipulation<br>Here we’ll be directly accessing and manipulating a texture’s pixels.</p>
<p>Lesson 41<br>Bitmap Fonts<br>Here we’ll be using a texture as a font using bitmap font techniques.</p>
<p>Lesson 42<br>Texture Streaming<br>Here we’ll be rendering from a streaming data source using texture streaming.</p>
<p>Lesson 43<br>Render to Texture<br>Here we’ll be taking a scene and rendering it to a texture.</p>
<p>Lesson 44<br>Frame Independent Movement<br>Here we’ll be making the dot move independent of the current frame rate.</p>
<p>Lesson 45<br>Timer Callbacks<br>SDL has another timing mechanism called timer callbacks. Here we’ll be setting a function to be called back after a certain amount of time.</p>
<p>Lesson 46<br>Multithreading<br>Multithreading allows your program to do things simultaneously. Here we’ll make things print to the console from outside our main thread.</p>
<p>Lesson 47<br>Semaphores<br>A major issue in multithreaded applications is that you need to make sure that they don’t try to access the same data at the same time. Semaphores are a way to make sure only a certain amount of threads are performing an action at the same time.</p>
<p>Lesson 48<br>Atomic Operations<br>Atomic operations are another way to synchronize threads. Here we’ll be redoing the previous tutorial with atomic counters.</p>
<p>Lesson 49<br>Mutexes and Conditions<br>Mutexes and conditions are yet another way to synchronize threads. Here we’ll be using the added benefit that they allow threads to communicate with each other.</p>
<p>Lesson 50<br>SDL and OpenGL 2<br>SDL is a powerful tool when combined with OpenGL. If you’re just starting out with OpenGL or want to maximize compatibility, you can use SDL with OpenGL 2.1. In this tutorial we will make a minimalist OpenGL 2.1 program.</p>
<p>Lesson 51<br>SDL and Modern OpenGL<br>SDL 2.0 now has support for OpenGL 3.0+ with context controls. Here we’ll be making a minimalist OpenGL 3+ core program.</p>
<p>Lesson 52<br>Hello Mobile<br>Here we’ll be loading and displaying an image in our first mobile app!</p>
<p>Lesson 53<br>Extensions and Changing Orientation<br>Here we’ll be using SDL extension libraries and handling changing orientation.</p>
<p>Lesson 54<br>Touches<br>Here we’ll be handling single touch input.</p>
<p>Lesson 55<br>Multitouch<br>Here we’ll be handling multitouch events like pinches and rotation.</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>SSH (Secure Shell)协议介绍</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/SSH%20(Secure%20Shell)%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>SSH是英文Secure Shell的简写形式。通过使用SSH，你可以把所有传输的数据进行加密，这样&quot;中间人&quot;这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、Pop、甚至为PPP提供一个安全的&quot;通道&quot;。</p>
<p>二、SSH 基本框架</p>
<p>SSH协议框架中最主要的部分是三个协议：</p>
<p>* 传输层协议（The Transport Layer Protocol）提供服务器认证，数据机密性，信息完整性 等的支持；</p>
<p>* 用户认证协议（The User Authentication Protocol） 则为服务器提供客户端的身份鉴别；</p>
<p>* 连接协议（The Connection Protocol） 将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用； 各种高层应用协议可以相对地独立于SSH基本体系之外，并依靠这个基本框架，通过连接协议使用SSH的安全机制。</p>
<p>同时SSH协议框架中还为许多高层的网络安全应用协议提供扩展的支持。它们之间的层次关系可以用如下图来表示：</p>
<p>三、主机密钥机制</p>
<p>对于SSH这样以提供安全通讯为目标的协议，其中必不可少的就是一套完备的密钥机制。由于SSH协议是面向互联网网络中主机之间的互访与信息交换，所以主机密钥成为基本的密钥机制。也就是说，SSH协议要求每一个使用本协议的主机都必须至少有一个自己的主机密钥对，服务方通过对客户方主机密钥的认证之后，才能允许其连接请求。一个主机可以使用多个密钥，针对不同的密钥算法而拥有不同的密钥，但是至少有一种是必备的，即通过 DSS算法产生的密钥。关于DSS算法，请参考[FIPS-186]。</p>
<p>SSH协议关于主机密钥认证的管理方案有两种，如下图所示：</p>
<p>每一个主机都必须有自己的主机密钥，密钥可以有多对，每一对主机密钥对包括公开密钥和私有密钥。在实际应用过程中怎样使用这些密钥，并依赖它们来实现安全特性呢？如上图所示，SSH协议框架中提出了两种方案。</p>
<p>在第一种方案中，主机将自己的公用密钥分发给相关的客户机，客户机在访问主机时则使用该主机的公开密钥来加密数据，主机则使用自己的私有密钥来解密数据，从而实现主机密钥认证，确定客户机的可靠身份。在图2（a）中可以看到，用户从主机A上发起操作，去访问，主机B和主机C，此时，A成为客户机，它必须事先配置主机B和主机C的公开密钥，在访问的时候根据主机名来查找相应的公开密钥。对于被访问主机（也就是服务器端）来说则只要保证安全地存储自己的私有密钥就可以了。</p>
<p>在第二种方案中，存在一个密钥认证中心，所有系统中提供服务的主机都将自己的公开密钥提交给认证中心，而任何作为客户机的主机则只要保存一份认证中心的公开密钥就可以了。在这种模式下，客户机在访问服务器主机之前，还必须向密钥认证中心请求认证，认证之后才能够正确地连接到目的主机上。</p>
<p>很显然，第一种方式比较容易实现，但是客户机关于密钥的维护却是个麻烦事，因为每次变更都必须在客户机上有所体现；第二种方式比较完美地解决管理维护问题，然而这样的模式对认证中心的要求很高，在互联网络上要实现这样的集中认证，单单是权威机构的确定就是个大麻烦，有谁能够什么都能说了算呢？但是从长远的发展来看，在企业应用和商业应用领域，采用中心认证的方案是必要的。</p>
<p>另外，SSH协议框架中还允许对主机密钥的一个折中处理，那就是首次访问免认证。首次访问免认证是指，在某客户机第一次访问主机时，主机不检查主机密钥，而向该客户都发放一个公开密钥的拷贝，这样在以后的访问中则必须使用该密钥，否则会被认为非法而拒绝其访问。</p>
<p>四、SSH 的工作过程</p>
<p>在整个通讯过程中，为实现 SSH的安全连接，服务器端与客户端要经历如下五个阶段：</p>
<p>    * 版本号协商阶段，SSH目前包括 SSH1和SSH2两个版本， 双方通过版本协商确定使用的版本</p>
<p>    * 密钥和算法协商阶段，SSH支持多种加密算法， 双方根据本端和对端支持的算法，协商出最终使用的算法</p>
<p>    * 认证阶段，SSH客户端向服务器端发起认证请求， 服务器端对客户端进行认证</p>
<p>    * 会话请求阶段， 认证通过后，客户端向服务器端发送会话请求</p>
<p>    * 交互会话阶段 ，会话请求通过后，服务器端和客户端进行信息的交互</p>
<p>1 . 版本号协商阶段</p>
<p>   1. 服务器打开端口 22，等待客户端连接。</p>
<p>   2. 客户端向服务器端发起 TCP初始连接请求，TCP连接建立后，服务器向客户端发送第一个报文，包括版本标志字符串，格式为“SSH－&lt;主协议版本号&gt;.&lt;次协议版本号&gt;－&lt;软件版本号&gt;”，协议版本号由主版本号和次版本号组成，软件版本号主要是为调试使用。</p>
<p>   3. 客户端收到报文后，解析该数据包，如果服务器端的协议版本号比自己的低，且客户端能支持服务器端的低版本，就使用服务器端的低版本协议号，否则使用自己的协议版本号。</p>
<p>   4. 客户端回应服务器一个报文，包含了客户端决定使用的协议版本号。服务器比较客户端发来的版本号，决定是否能同客户端一起工作。</p>
<p>   5. 如果协商成功，则进入密钥和算法协商阶段，否则服务器端断开 TCP连接。</p>
<p>Note： 版本号协商阶段报文都是采用明文方式传输的。</p>
<p>2. 密钥和算法协商阶段</p>
<p>   1. 服务器端和客户端分别发送算法协商报文给对端，报文中包含自己支持的公钥算法列表、加密算法列表、MAC（Message Authentication Code，消息验证码）算法列表、压缩算法列表等;</p>
<p>   2. 服务器端和客户端根据对端和本端支持的算法列表得出最终使用的算法。</p>
<p>   3. 服务器端和客户端利用 DH交换（Diffie-Hellman Exchange）算法、主机密钥对等参数，生成会话密钥和会话 ID。</p>
<p>通过以上步骤，服务器端和客户端就取得了相同的会话密钥和会话ID。</p>
<p>          * 对于后续传输的数据，两端都会使用会话密钥进行加密和解密，保证了数据传送的安全</p>
<p>          * 在认证阶段，两端会使用会话 ID用于认证过程。</p>
<p>      Note：</p>
<p>在协商阶段之前，服务器端已经生成 RSA或 DSA密钥对，他们主要用于参与会话密钥的生成。</p>
<p>3. 认证阶段</p>
<p>   1. 客户端向服务器端发送认证请求，认证请求中包含用户名、认证方法、与该认证方法相关的内容（如：password认证时，内容为密码）。</p>
<p>   2. 服务器端对客户端进行认证，如果认证失败，则向客户端发送认证失败消息，其中包含可以再次认证的方法列表。</p>
<p>   3. 客户端从认证方法列表中选取一种认证方法再次进行认证。</p>
<p>   4. 该过程反复进行， 直到认证成功或者认证次数达到上限， 服务器关闭连接为止。</p>
<p>SSH提供两种认证方式：</p>
<p>   1. password认证：客户端向服务器发出 password认证请求，将用户名和密码加密后发送给服务器；服务器将该信息解密后得到用户名和密码的明文，与设备上保存的用户名和密码进行比较，并返回认证成功或失败的消息。</p>
<p>   2. publickey 认证：采用数字签名的方法来认证客户端。目前，设备上可以利用RSA和 DSA两种公共密钥算法实现数字签名。客户端发送包含用户名、公共密钥和公共密钥算法的 publickey 认证请求给服务器端。服务器对公钥进行合法性检查，如果不合法，则直接发送失败消息；否则，服务器利用数字签名对客户端进行认证，并返回认证成功或失败的消息</p>
<p>SSH2.0还提供了 password-publickey 认证和 any 认证:</p>
<p>   1. password-publickey 认证：指定该用户的认证方式为 password 和 publickey认证同时满足。客户端版本为 SSH1的用户只要通过其中一种认证即可登录；客户端版本为 SSH2的用户必须两种认证都通过才能登录。</p>
<p>   2. any认证：指定该用户的认证方式可以是 password，也可以是 publickey。</p>
<p>4.会话请求阶段</p>
<p>   1. 服务器等待客户端的请求；</p>
<p>   2. 认证通过后，客户端向服务器发送会话请求；</p>
<p>   3. 服务器处理客户端的请求。请求被成功处理后， 服务器会向客户端回应 SSH_SMSG_SUCCESS包，SSH进入交互会话阶段；否则回应 SSH_SMSG_FAILURE包，表示服务器处理请求失败或者不能识别请求。</p>
<p>5.交互会话阶段</p>
<p>在这个模式下，数据被双向传送：</p>
<p>   1. 客户端将要执行的命令加密后传给服务器;</p>
<p>   2. 服务器接收到报文，解密后执行该命令,将执行的结果加密发还给客户端;</p>
<p>   3. 客户端将接收到的结果解密后显示到终端上.</p>
<p>五、SSH的应用</p>
<p>　　</p>
<p>　　　　首先，SSH最常见的应用就是，用它来取代传统的Telnet、FTP等网络应用程序，通过SSH登录到远方机器执行你想进行的工作与命令。在不安全的网路通讯环境中，它提供了很强的验证（authentication）机制与非常安全的通讯环境。实际上，SSH开发者的原意是设计它来取代原UNIX系统上的rcp、rlogin、rsh等指令程序的；但经过适当包装后，发现它在功能上完全可以取代传统的Telnet、FTP等应用程序。</p>
<p>　　　　传统 BSD 风格的 r 系列指令（如 rcp，rsh，rlogin）往往都被视为不安全的，很容易就被各种网络攻击手段所破解，几乎所有找得到有关UNIX安全的书或文件，都会一而再、再而三地警告系统管理者，留心r系列指令的设定，甚至要求系统管理者将r系列指令通通关闭。</p>
<p>　　　　而用来替代r系列指令的SSH，则在安全方面做了极大的强化，不但对通讯内容可以进行极为安全的加密保护，同时也强化了对身份验证的安全机制，它应用了在密码学（Cryptography）中已发展出来的数种安全加密机制，如 Symmetric Key Cryptography，Asymmetric Key Cryptography， One-way Hash Function，Random-number Generation等，来加强对于身份验证与通讯内容的安全保护。通讯时资料的加密有IDEA，three-key triple DES，DES，RC4-128，TSS，Blowfish 等数种多种安全加密算法可供选择，加密的key则是通过 RSA 进行交换的。资料的加密可以对抗IP spoofing，RSA这种非对称性的加密机制则可用来对抗DNS spoofing与IP routing spoofing，同时RSA也可以进行对主机身份的验证。</p>
<p>　　　　其次，通过使用用SSH可以在本地主机和远程服务器之间设置&quot;加密通道&quot;，并且这样设置的&quot;加密通道&quot;可以跟常见的Pop应用程序、X应用程序、Linuxconf应用程序相结合，提供安全保障。</p>
<p>　　　　SSH的&quot;加密通道&quot;是通过&quot;端口转发&quot;来实现的。你可以在本地端口（没有用到的）和在远程服务器上运行的某个服务的端口之间建立&quot;加密通道&quot;。然后只要连接到本地端口。所有对本地端口的请求都被SSH加密并且转发到远程服务器的端口。当然只有远程服务器上运行SSH服务器软件的时候&quot;加密通道&quot;才能工作。</p>
<p>六、SSH Q&amp;A</p>
<p>    Q1: SSH的版本和区别。</p>
<p>    SSH2避免了RSA的专利问题，并修补了CRC的缺陷。SSH2用数字签名算法（DSA）和Diffie-Hellman（DH）算法代替RSA来完成对称密钥的交换，用HMAC来代替CRC。同时SSH2增加了AES和Twofish等对称加密算法。</p>
<p>    A1: SSH(Secure SHell)到目前为止有两个不兼容的版本——SSH1和SSH2。SSH1又分为1.3和1.5两个版本。SSH1采用DES、3DES、 Blowfish和RC4等对称加密算法保护数据安全传输，而对称加密算法的密钥是通过非对称加密算法（RSA）来完成交换的。SSH1使用循环冗余校验码（CRC）来保证数据的完整性，但是后来发现这种方法有缺陷。</p>
<p>更多内容请参考The SSHv1 Protocol &amp; The SSHv2 Protocol</p>
<p>     Q2: 什么是HMAC？</p>
<p>    A2: HMAC(Hash Message Authentication Code) ，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。</p>
<p>    Q3: 什么是X11 forwarding？</p>
<p>    A3: sh的X11 forwarding特性可以使X client和X server安全地通讯。使用X11 forwarding后，从X client到X Server方向的数据先被送至ssh server，ssh server利用和ssh client的安全通道转发给ssh client，再由ssh client转发给X server，从X server到X client的数据流同理。这里ssh server和ssh client充当了X client和X server间数据的转发器，由于ssh server和X client、ssh client和X server一般在同一台机器上，它们之间是一种安全的进程间通讯，而ssh server和ssh client间的通讯也是安全的，所以X client和X server间的通讯就是安全的。</p>
<p>    Q4: 什么是TTY？</p>
<p>    A4: 终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。tty是 Teletype的缩写。Teletype是最早出现的一种终端设备，很象电传打字机，是由Teletype公司生产的。设备名放在特殊文件目录/dev/下。</p>
<p>    Q5: 简单描述下SSH运行的过程？</p>
<p>    A5:简要过程如下：</p>
<p>        * Client端向Server端发起SSH连接请求。</p>
<p>        * Server端向Client端发起版本协商。</p>
<p>        * 协商结束后Server端发送Host Key公钥 Server Key公钥，随机数等信息。到这里所有通信是不加密的。</p>
<p>        * Client端返回确认信息，同时附带用公钥加密过的一个随机数，用于双方计算Session Key。</p>
<p>        * 进入认证阶段。从此以后所有通信均加密。</p>
<p>        * 认证成功后，进入交互阶段。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Service</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Service/</url>
    <content><![CDATA[<p>Service </p>
<p> @Override  </p>
<p>    public int onStartCommand(Intent intent, int flags, int startId) {  </p>
<p>        Log.d(TAG, &quot;onStartCommand() executed&quot;);  </p>
<p>        return super.onStartCommand(intent, flags, startId);  </p>
<p>    }  </p>
<p>startId</p>
<p>START_NOT_STICKY：当Service因为内存不足而被系统kill后，接下来未来的某个时间内，即使系统内存足够可用，系统也不会尝试重新创建此Service。除非程序中Client明确再次调用startService(…)启动此Service。</p>
<p>START_STICKY：当Service因为内存不足而被系统kill后，接下来未来的某个时间内，当系统内存足够可用的情况下，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand(…)方法，但其中的Intent将是null，pendingintent除外。</p>
<p>START_REDELIVER_INTENT：与START_STICKY唯一不同的是，回调onStartCommand(…)方法时，其中的Intent将是非空，将是最后一次调用startService(…)中的intent。</p>
<p>Intent startIntent = new Intent(this, MyService.class);  </p>
<p>startService(startIntent);</p>
<p>Intent stopIntent = new Intent(this, MyService.class);  </p>
<p>stopService(stopIntent);  </p>
<p> @Override  </p>
<p>    public IBinder onBind(Intent intent) {         </p>
<p>        return binder;</p>
<p>    }  </p>
<p>//ServiceConnection 中返回binder</p>
<p>Intent bindIntent = new Intent(this, MyService.class);  </p>
<p>bindService(bindIntent, connection, BIND_AUTO_CREATE);  </p>
<p>unbindService(connection);  </p>
<p> 提高优先级</p>
<p>Service.startForeground (int id, Notification notification)</p>
<p>android:priority = &quot;1000&quot;这个属性设置最高优先级</p>
<p>&lt;application android:name=&quot;PhoneApp&quot;</p>
<p>  android:persistent=&quot;true</p>
<p>利用的系统广播是Intent.ACTION_TIME_TICK，这个广播每分钟发送一次</p>
<p>将service设置为前台service，这样的做会在前端弹出一个notification切是一直存在</p>
<p>        Notification notification = new Notification(R.drawable.ic_lancher, &quot;上传数据&quot;, System.currentTimeMillis());  </p>
<p>        Intent notificationIntent = new Intent(this, MainActivity.class);  </p>
<p>        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);  </p>
<p>             notification.setLatestEventInfo(this, &quot;前端service&quot;, &quot;前端service&quot;, pendingIntent);  </p>
<p>startForeground(1, notification); </p>
<p>//在新进程中运行 不会给UI线程造成ANR</p>
<p>android:process=&quot;remote&quot;</p>
<p>MyAIDLService.aidl</p>
<p>interface MyAIDLService { </p>
<p>    void test();</p>
<p>}</p>
<p>myService</p>
<p>MyAIDLService.Stub mBinder = new Stub(){</p>
<p>    void test(){};</p>
<p>}</p>
<p>        public void onServiceConnected(ComponentName name, IBinder service) {  </p>
<p>            myAIDLService = MyAIDLService.Stub.asInterface(service);  </p>
<p>            myAIDLService.test();</p>
<p>Intent intent = new Intent(&quot;com.example.servicetest.MyAIDLService&quot;);  </p>
<p>bindService(intent, connection, BIND_AUTO_CREATE);  </p>
<p>Using a Messenger</p>
<p>Messenger，在此可以理解成”信使“，通过Messenger方式返回Binder对象可以不用考虑Clinet - Service是否属于同一个进程的问题，并且，可以实现Client - Service之间的双向通信。</p>
<p>   @Override     public IBinder onBind(Intent intent) {         Log.w(TAG, &quot;in onBind&quot;);         return mServerMessenger.getBinder();</p>
<p>    }</p>
<p>IntentService</p>
<p>onHandlerIntent(..)主要就是用来处于相应的”长期“任务的，并且已经自动在新的线程中 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Session</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Session/</url>
    <content><![CDATA[<p>1.启动会话</p>
<p>bool session_start(void)           //函数前浏览器不能有任何输出</p>
<p>session_register()  //启动会话的另一种方式，需要php.ini中 register_globals == on </p>
<p>2.使用会话</p>
<p>if(!empty($_SESSION[‘name’]))</p>
<p>    $value = $_SESSION[‘name’];</p>
<p>3.删除会话</p>
<p>1）unset($_SESSION[‘name’]);</p>
<p>2）$_SESSION = array(); //删除所有会话变量</p>
<p>3）session_destroy(); //结束当前会话</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Setting</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Setting/</url>
    <content><![CDATA[<p>packages\apps\Settings\src\com\android\settings\RingerVolumePreference.java //  sound/volume</p>
<p>  // These arrays must all match in length and order</p>
<p>    private static final int[] SEEKBAR_ID = new int[] {</p>
<p>        R.id.media_volume_seekbar,</p>
<p>      R.id.ringer_volume_seekbar,</p>
<p>        R.id.notification_volume_seekbar,</p>
<p>        R.id.alarm_volume_seekbar</p>
<p>    };</p>
<p> // 二选一</p>
<p>      if (!Utils.isVoiceCapable(getContext())) {</p>
<p>  id = R.id.ringer_section;</p>
<p>        } else {</p>
<p>  id = R.id.notification_section;</p>
<p>        }</p>
<p>        View hideSection = view.findViewById(id);</p>
<p>        hideSection.setVisibility(View.GONE);  </p>
<p>    }</p>
<p>packages\apps\Settings\src\com\android\settings\WirelessSettings.java</p>
<p>    private static final String KEY_TOGGLE_AIRPLANE = &quot;toggle_airplane&quot;;  //飞行模式</p>
<p>    private static final String KEY_TOGGLE_NFC = &quot;toggle_nfc&quot;;</p>
<p>    private static final String KEY_WIMAX_SETTINGS = &quot;wimax_settings&quot;;</p>
<p>    private static final String KEY_ANDROID_BEAM_SETTINGS = &quot;android_beam_settings&quot;;</p>
<p>    private static final String KEY_VPN_SETTINGS = &quot;vpn_settings&quot;;</p>
<p>    private static final String KEY_TETHER_SETTINGS = &quot;tether_settings&quot;;</p>
<p>    private static final String KEY_PROXY_SETTINGS = &quot;proxy_settings&quot;;</p>
<p>    private static final String KEY_MOBILE_NETWORK_SETTINGS = &quot;mobile_network_settings&quot;;//移动网络</p>
<p>    private static final String KEY_TOGGLE_NSD = &quot;toggle_nsd&quot;; //network service discovery</p>
<p>    private static final String KEY_CELL_BROADCAST_SETTINGS = &quot;cell_broadcast_settings&quot;;</p>
<p>    private static final String KEY_ETHERNET_SETTINGS = &quot;ethernet_settings&quot;;</p>
<p> packages\apps\Settings\res\values\config.xml</p>
<p>            &lt;bool name=&quot;config_airplane_capable&quot;&gt;true&lt;/bool&gt;</p>
<p> mHasAirplane = getResources().getBoolean(R.bool.config_airplane_capable); //在values/bool.xml 或overlay设置了</p>
<p>mAirplaneModePreference = (CheckBoxPreference) findPreference(KEY_TOGGLE_AIRPLANE);</p>
<p>        if(mHasAirplane) {</p>
<p>            findPreference(KEY_MOBILE_NETWORK_SETTINGS).setDependency(KEY_TOGGLE_AIRPLANE);</p>
<p>        } else {            </p>
<p>            getPreferenceScreen().removePreference(mAirplaneModePreference);</p>
<p>        }</p>
<p>packages\apps\Settings\src\com\android\settings\SoundSettings.java</p>
<p> private static final String KEY_VIBRATE = &quot;vibrate_when_ringing&quot;;</p>
<p>    private static final String KEY_RING_VOLUME = &quot;ring_volume&quot;;</p>
<p>    private static final String KEY_MUSICFX = &quot;musicfx&quot;;</p>
<p>    private static final String KEY_DTMF_TONE = &quot;dtmf_tone&quot;;</p>
<p>    private static final String KEY_SOUND_EFFECTS = &quot;sound_effects&quot;;</p>
<p>    private static final String KEY_HAPTIC_FEEDBACK = &quot;haptic_feedback&quot;;</p>
<p>    private static final String KEY_EMERGENCY_TONE = &quot;emergency_tone&quot;;</p>
<p>    private static final String KEY_SOUND_SETTINGS = &quot;sound_settings&quot;;</p>
<p>    private static final String KEY_LOCK_SOUNDS = &quot;lock_sounds&quot;;</p>
<p>    private static final String KEY_RINGTONE = &quot;ringtone&quot;;</p>
<p>    private static final String KEY_NOTIFICATION_SOUND = &quot;notification_sound&quot;;</p>
<p>    private static final String KEY_CATEGORY_CALLS = &quot;category_calls_and_notification&quot;;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>SettingProvider  全局变量 控制事件</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/SettingProvider%20%20%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%20%E6%8E%A7%E5%88%B6%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>// phone , 禁止systemUI 通知栏和设置栏(quicksetting)</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelBar.java</p>
<p>+import android.provider.Settings;</p>
<p>     @Override</p>
<p>     public boolean onTouchEvent(MotionEvent event) {</p>
<p>+</p>
<ul>
<li><p>               if(Settings.System.getInt(mContext.getContentResolver(),&quot;system_ui_panel_hide&quot;, 0)==1){//by edward</p>
</li>
<li><p>                       onAllPanelsCollapsed();</p>
</li>
<li><p>                       return true ;</p>
</li>
<li><p>                      }</p>
</li>
</ul>
<p> Settings.System.putInt(getContentResolver(),&quot;system_ui_panel_hide&quot;, 1);</p>
<p>// 禁止上报物理按键事件</p>
<p>+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>interceptKeyBeforeDispatching</p>
<ul>
<li><p>              if(keyCode != KeyEvent.KEYCODE_POWER &amp;&amp; event.getDeviceId() &gt;=0){ //by edward</p>
</li>
<li><p>              boolean hided =Settings.System.getInt(mContext.getContentResolver(),</p>
</li>
<li><p>                       &quot;key_event_hided&quot;, 0)==1;</p>
</li>
<li><p>                      if(hided)</p>
</li>
<li><p>                      return -1 ;</p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>interceptKeyBeforeQueueing</p>
<ul>
<li><p>              if(keyCode != KeyEvent.KEYCODE_POWER &amp;&amp; event.getDeviceId() &gt;=0){//by edward</p>
</li>
<li><p>                      boolean hided =Settings.System.getInt(mContext.getContentResolver(),</p>
</li>
<li><p>                       &quot;key_event_hided&quot;, 0)==1;</p>
</li>
<li><p>                      if(hided)</p>
</li>
<li><p>                      return 0 ;</p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>Settings.System.putInt(getContentResolver(),&quot;key_event_hided&quot;, 1);</p>
<p>只禁止右边状态栏</p>
<p> –git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelView<br>index 4b2c3e1..b3e568f 100644<br>— a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelView.java<br>+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelView.java<br>@@ -366,7 +366,7 @@ public class PanelView extends FrameLayout {<br>     // Pass all touches along to the handle, allowing the user to drag the panel closed from its interior<br>     @Override<br>     public boolean onTouchEvent(MotionEvent event) {<br>-        return mHandleView.dispatchTouchEvent(event);<br>+        return false;//mHandleView.dispatchTouchEvent(event);<br>     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>SettingProvider添加系统默认设置</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/SettingProvider%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>framework/base/core/java/android/provider/Settings.java</p>
<p>  /**  系统及应用 可读写 可以在这添加系统默认设置</p>
<p>     * System settings, containing miscellaneous system preferences.  This</p>
<p>     * table holds simple name/value pairs.  There are convenience</p>
<p>     * functions for accessing individual settings entries.</p>
<p>     */</p>
<p>    public static final class System extends NameValueTable {</p>
<p>    /**  一般只用于系统设置</p>
<p>     * Secure system settings, containing system preferences that applications</p>
<p>     * can read but are not allowed to write.  These are for preferences that</p>
<p>     * the user must explicitly modify through the system UI or specialized</p>
<p>     * APIs for those values, not modified directly by applications.</p>
<p>     */</p>
<p>    public static final class Secure extends NameValueTable {</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>SimpleJNI native</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/SimpleJNI%20native.cpp/</url>
    <content><![CDATA[<p>/*</p>
<p> * Copyright (C) 2008 The Android Open Source Project</p>
<p> *</p>
<p> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</p>
<p> * you may not use this file except in compliance with the License.</p>
<p> * You may obtain a copy of the License at</p>
<p> *</p>
<p> * <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p> *</p>
<p> * Unless required by applicable law or agreed to in writing, software</p>
<p> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</p>
<p> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>
<p> * See the License for the specific language governing permissions and</p>
<p> * limitations under the License.</p>
<p> */</p>
<p>#define LOG_TAG &quot;simplejni native.cpp&quot;</p>
<p>#include &lt;utils/Log.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &quot;jni.h&quot;</p>
<p>static jint</p>
<p>add(JNIEnv *env, jobject thiz, jint a, jint b) {</p>
<p>int result = a + b;</p>
<p>    ALOGI(&quot;%d + %d = %d&quot;, a, b, result);</p>
<p>    return result;</p>
<p>}</p>
<p>static const char *classPathName = &quot;com/example/android/simplejni/Native&quot;;</p>
<p>static JNINativeMethod methods[] = {</p>
<p>  {&quot;add&quot;, &quot;(II)I&quot;, (void*)add },</p>
<p>};</p>
<p>/*</p>
<p> * Register several native methods for one class.</p>
<p> */</p>
<p>static int registerNativeMethods(JNIEnv* env, const char* className,</p>
<p>    JNINativeMethod* gMethods, int numMethods)</p>
<p>{</p>
<p>    jclass clazz;</p>
<p>    clazz = env-&gt;FindClass(className);</p>
<p>    if (clazz == NULL) {</p>
<p>        ALOGE(&quot;Native registration unable to find class ‘%s’&quot;, className);</p>
<p>        return JNI_FALSE;</p>
<p>    }</p>
<p>    if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) {</p>
<p>        ALOGE(&quot;RegisterNatives failed for ‘%s’&quot;, className);</p>
<p>        return JNI_FALSE;</p>
<p>    }</p>
<p>    return JNI_TRUE;</p>
<p>}</p>
<p>/*</p>
<p> * Register native methods for all classes we know about.</p>
<p> *</p>
<p> * returns JNI_TRUE on success.</p>
<p> */</p>
<p>static int registerNatives(JNIEnv* env)</p>
<p>{</p>
<p>  if (!registerNativeMethods(env, classPathName,</p>
<p>                 methods, sizeof(methods) / sizeof(methods[0]))) {</p>
<p>    return JNI_FALSE;</p>
<p>  }</p>
<p>  return JNI_TRUE;</p>
<p>}</p>
<p>// —————————————————————————-</p>
<p>/*</p>
<p> * This is called by the VM when the shared library is first loaded.</p>
<p> */</p>
<p>typedef union {</p>
<p>    JNIEnv* env;</p>
<p>    void* venv;</p>
<p>} UnionJNIEnvToVoid;</p>
<p>jint JNI_OnLoad(JavaVM* vm, void* reserved)</p>
<p>{</p>
<p>    UnionJNIEnvToVoid uenv;</p>
<p>    uenv.venv = NULL;</p>
<p>    jint result = -1;</p>
<p>    JNIEnv* env = NULL;</p>
<p>    ALOGI(&quot;JNI_OnLoad&quot;);</p>
<p>    if (vm-&gt;GetEnv(&amp;uenv.venv, JNI_VERSION_1_4) != JNI_OK) {</p>
<p>        ALOGE(&quot;ERROR: GetEnv failed&quot;);</p>
<p>        goto bail;</p>
<p>    }</p>
<p>    env = uenv.env;</p>
<p>    if (registerNatives(env) != JNI_TRUE) {</p>
<p>        ALOGE(&quot;ERROR: registerNatives failed&quot;);</p>
<p>        goto bail;</p>
<p>    }</p>
<p>    result = JNI_VERSION_1_4;</p>
<p>bail:</p>
<p>    return result;</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Smali语法简单介绍</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Smali%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Smali语法简单介绍如下：</p>
<p>       Davlik字节码中，寄存器都是32位的，能够支持任何类型，64位类型（Long/Double）用2个寄存器表示；</p>
<p>       Dalvik字节码有两种类型：原始类型；引用类型（包括对象和数组）</p>
<p>原始类型：v   void  只能用于返回值类型</p>
<p>                                Z   boolean</p>
<p>                                B   byte</p>
<p>                                S   short</p>
<p>                                C   char</p>
<p>                                 I    int</p>
<p>                                J    long（64位）</p>
<p>                                F   float</p>
<p>                                D   double（64位）</p>
<p>对象类型：Lpackage/name/ObjectName;  相当于java中的package.name.ObjectName;解释如下：</p>
<p>                                 L：表示这是一个对象类型</p>
<p>                                 package/name:该对象所在的包</p>
<p>                                 ；：表示对象名称的结束</p>
<p>数组的表示形式：</p>
<p> [I  :表示一个整形的一维数组，相当于java的int[];</p>
<p>对于多维数组，只要增加[ 就行了，[[I = int[][];注：每一维最多255个； </p>
<p>对象数组的表示形式：</p>
<p>[Ljava/lang/String    表示一个String的对象数组；</p>
<p>方法的表示形式：</p>
<p>Lpackage/name/ObjectName;——&gt;methodName(III)Z  详解如下：</p>
<p>                                   Lpackage/name/ObjectName  表示类型</p>
<p>                                   methodName   表示方法名</p>
<p>                                   III   表示参数（这里表示为3个整型参数）</p>
<p>                                   说明：方法的参数是一个接一个的，中间没有隔开；</p>
<p>字段的表示形式：</p>
<p>Lpackage/name/ObjectName;——&gt;FieldName:Ljava/lang/String;</p>
<p>                                    即表示： 包名，字段名和各字段类型</p>
<p>有两种方式指定一个方法中有多少寄存器是可用的：</p>
<p>                                     .registers  指令指定了方法中寄存器的总数</p>
<p>                                     .locals        指令表明了方法中非参寄存器的总数，出现在方法中的第一行</p>
<p>方法的传参：</p>
<p>                当一个方法被调用的时候，方法的参数被置于最后N个寄存器中；</p>
<p>                          例如，一个方法有2个参数，5个寄存器（v0~v4）</p>
<p>                                      那么，参数将置于最后2个寄存器（v3和v4）</p>
<p>                 非静态方法中的第一个参数总是调用该方法的对象；</p>
<p>  说明：对于静态方法除了没有隐含的this参数外，其他都一样</p>
<p>寄存器的命名方式：</p>
<p>                  V命名</p>
<p>                  P命名  第一个寄存器就是方法中的第一个参数寄存器</p>
<p>                  比较：使用P命名是为了防止以后如果在方法中增加寄存器，需要对参数寄存器重新进行编号的缺点</p>
<p>                  特别说明一下：Long和Double类型是64位的，需要2个寄存器</p>
<p>                           例如：对于非静态方法</p>
<p>                                       LMyObject——&gt;myMethod(IJZ)V;</p>
<p>                                       有4个参数：LMyObject,int,long,bool;   需要5个寄存器来存储参数；</p>
<p>P0    this</p>
<p>                                                            P1    I (int)</p>
<p>                                                            P2，P3  J (long)</p>
<p>                                                            P4    Z(bool)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Support 4 share files</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Support%204%20share%20files/</url>
    <content><![CDATA[<p>+++SD_CARD_IN+++</p>
<p>AHC_WMSG_Draw WMSG_INFO:0</p>
<p>AHC_WMSG_Draw WMSG_INFO:16</p>
<p>STATE_VIDEO_REC_MODE_EVENT_SD_DETECT_LCDremount MMC</p>
<p>byMediaID: 0, 7</p>
<p>Unmount P Success </p>
<p>Unmount SD0 OK</p>
<p>AHC_DisMountStorageMediaEx:800: reset m_ulLockFileNum to 0</p>
<p>SDHC</p>
<p>Get OCR success.  x0078 times</p>
<p>High Speed Mode Switch done.</p>
<p>Mount P Success </p>
<p>j_end: x00001D2C</p>
<p>pVolume-&gt;FCInfo.ulLastFATSectorOffset: x0000012C</p>
<p>Create sem pDB-&gt;smLock : 119</p>
<p>Create sem pDB-&gt;smLock : 120</p>
<p>Create sem pDB-&gt;smLock : 121</p>
<p>Create sem pDB-&gt;smLock : 122</p>
<p>Create sem pDB-&gt;smLock : 123</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[0].ulMaxSizeThresholdInCluster=328484</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[1].ulMaxSizeThresholdInCluster=4830</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[2].ulMaxSizeThresholdInCluster=96613</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[3].ulMaxSizeThresholdInCluster=4830</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[4].ulMaxSizeThresholdInCluster=48306</p>
<p>Support 4 share files</p>
<p>Format Free File Num satisfy DCF_SHARE_FOLDER_FILE_NUM 4</p>
<p>RTC Set Time:  xA9491BD0</p>
<p>AHC_HostUVCResetTime,L:3395 Err:0x0!</p>
<p> reset_RTCbyFileName reset rtc by filename !!!! dtLastFileDateTime = 3155759951 </p>
<p>Mount SD0 OK.</p>
<p>Media Path: 0</p>
<p>Root Name: SD:\</p>
<p>Mount Status: 1</p>
<p>SDMMC Status: 1</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>SystemProperties</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/SystemProperties/</url>
    <content><![CDATA[<p>SystemProperties 4.1</p>
<p>/system/build.prop</p>
<p>ro.build.display.id</p>
<p>ro.product.locale.language=en</p>
<p>ro.product.locale.region=US</p>
<p>persist.sys.timezone=Atlantic/Azores</p>
<p>ro.sf.lcd_density=160</p>
<p>persist.sys.usb.config=mtp /mass_storage</p>
<p>ro.com.android.dataroaming=true</p>
<p>ro.com.android.dateformat=MM-dd-yyyy</p>
<p>ro.product.device  //simulator</p>
<p>ro.rk.MassStorage   //isEnableUsbMassStorage</p>
<p>//description</p>
<p>ro.rk.sdcard_volume</p>
<p>ro.rk.external_volume</p>
<p>ro.rk.usb_host_volume</p>
<p>//串口标识 默认1234567890ABCDEF</p>
<p>ro.serialno</p>
<p>ro.rk.ethernet_enable //true</p>
<p>ro.rk.bt_enable=false</p>
<p>system_init.startaudioservice  //1</p>
<p>ro.build.characteristics  //tablet/phone</p>
<p>ro.rk.screenoff_time</p>
<p>ro.rk.def_brightness  </p>
<p>ro.com.android.dataroaming //是否允许漫游</p>
<p>ro.rk.install_non_market_apps</p>
<p>ro.rk.wifi_on</p>
<p>ro.allow.mock.location</p>
<p>ro.default.size  //默认字体大小</p>
<p>ro.rk.systembar.voiceicon //是否显示音量</p>
<p>&lt;timezones&gt;</p>
<p>    &lt;timezone id=&quot;Pacific/Majuro&quot;&gt;Marshall Islands&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Pacific/Midway&quot;&gt;Midway Island&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Pacific/Honolulu&quot;&gt;Hawaii&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Anchorage&quot;&gt;Alaska&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Los_Angeles&quot;&gt;Pacific Time&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Tijuana&quot;&gt;Tijuana&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Phoenix&quot;&gt;Arizona&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Chihuahua&quot;&gt;Chihuahua&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Denver&quot;&gt;Mountain Time&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Costa_Rica&quot;&gt;Central America&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Chicago&quot;&gt;Central Time&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Mexico_City&quot;&gt;Mexico City&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Regina&quot;&gt;Saskatchewan&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Bogota&quot;&gt;Bogota&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/New_York&quot;&gt;Eastern Time&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Caracas&quot;&gt;Venezuela&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Barbados&quot;&gt;Atlantic Time (Barbados)&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Halifax&quot;&gt;Atlantic Time (Canada)&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Manaus&quot;&gt;Manaus&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Santiago&quot;&gt;Santiago&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/St_Johns&quot;&gt;Newfoundland&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Sao_Paulo&quot;&gt;Brasilia&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Argentina/Buenos_Aires&quot;&gt;Buenos Aires&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Godthab&quot;&gt;Greenland&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;America/Montevideo&quot;&gt;Montevideo&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Atlantic/South_Georgia&quot;&gt;Mid-Atlantic&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Atlantic/Azores&quot;&gt;Azores&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Atlantic/Cape_Verde&quot;&gt;Cape Verde Islands&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Africa/Casablanca&quot;&gt;Casablanca&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Europe/London&quot;&gt;London, Dublin&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Europe/Amsterdam&quot;&gt;Amsterdam, Berlin&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Europe/Belgrade&quot;&gt;Belgrade&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Europe/Brussels&quot;&gt;Brussels&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Europe/Sarajevo&quot;&gt;Sarajevo&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Africa/Windhoek&quot;&gt;Windhoek&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Africa/Brazzaville&quot;&gt;W. Africa Time&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Amman&quot;&gt;Amman, Jordan&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Europe/Athens&quot;&gt;Athens, Istanbul&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Beirut&quot;&gt;Beirut, Lebanon&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Africa/Cairo&quot;&gt;Cairo&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Europe/Helsinki&quot;&gt;Helsinki&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Jerusalem&quot;&gt;Jerusalem&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Europe/Minsk&quot;&gt;Minsk&lt;/timezone&gt;</p>
<p>     &lt;timezone id=&quot;Africa/Harare&quot;&gt;Harare&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Baghdad&quot;&gt;Baghdad&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Europe/Moscow&quot;&gt;Moscow&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Kuwait&quot;&gt;Kuwait&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Africa/Nairobi&quot;&gt;Nairobi&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Tehran&quot;&gt;Tehran&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Baku&quot;&gt;Baku&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Tbilisi&quot;&gt;Tbilisi&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Yerevan&quot;&gt;Yerevan&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Dubai&quot;&gt;Dubai&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Kabul&quot;&gt;Kabul&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Karachi&quot;&gt;Islamabad, Karachi&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Oral&quot;&gt;Ural’sk&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Yekaterinburg&quot;&gt;Yekaterinburg&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Calcutta&quot;&gt;Kolkata&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Colombo&quot;&gt;Sri Lanka&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Katmandu&quot;&gt;Kathmandu&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Almaty&quot;&gt;Astana&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Rangoon&quot;&gt;Yangon&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Krasnoyarsk&quot;&gt;Krasnoyarsk&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Bangkok&quot;&gt;Bangkok&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Shanghai&quot;&gt;Beijing&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Hong_Kong&quot;&gt;Hong Kong&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Irkutsk&quot;&gt;Irkutsk&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Kuala_Lumpur&quot;&gt;Kuala Lumpur&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Australia/Perth&quot;&gt;Perth&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Taipei&quot;&gt;Taipei&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Seoul&quot;&gt;Seoul&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Tokyo&quot;&gt;Tokyo, Osaka&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Yakutsk&quot;&gt;Yakutsk&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Australia/Adelaide&quot;&gt;Adelaide&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Australia/Darwin&quot;&gt;Darwin&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Australia/Brisbane&quot;&gt;Brisbane&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Australia/Hobart&quot;&gt;Hobart&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Australia/Sydney&quot;&gt;Sydney, Canberra&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Vladivostok&quot;&gt;Vladivostok&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Pacific/Guam&quot;&gt;Guam&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Asia/Magadan&quot;&gt;Magadan&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Pacific/Auckland&quot;&gt;Auckland&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Pacific/Fiji&quot;&gt;Fiji&lt;/timezone&gt;</p>
<p>    &lt;timezone id=&quot;Pacific/Tongatapu&quot;&gt;Tonga&lt;/timezone&gt;</p>
<p>&lt;/timezones&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>TP 触摸点位置</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/TP%20%E8%A7%A6%E6%91%B8%E7%82%B9%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>services/jni/com_android_server_input_InputManagerService.cpp</p>
<p>@@ -138,8 +138,8 @@ static void loadSystemIconAsSprite(JNIEnv* env, jobject contextObj, int32_t styl</p>
<p>             contextObj, style, &amp;pointerIcon);</p>
<p>     if (!status) {</p>
<p>         pointerIcon.bitmap.copyTo(&amp;outSpriteIcon-&gt;bitmap, SkBitmap::kARGB_8888_Config);</p>
<ul>
<li><p>outSpriteIcon-&gt;hotSpotX = pointerIcon.hotSpotX;</p>
</li>
<li><p>outSpriteIcon-&gt;hotSpotY = pointerIcon.hotSpotY;</p>
</li>
</ul>
<ul>
<li><p>outSpriteIcon-&gt;hotSpotX = pointerIcon.hotSpotX-8;</p>
</li>
<li><p>outSpriteIcon-&gt;hotSpotY = pointerIcon.hotSpotY-8;</p>
</li>
</ul>
<p>     }</p>
<p> }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>TTL（Transistor Transistor Logic）</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/TTL%EF%BC%88Transistor%20Transistor%20Logic%EF%BC%89/</url>
    <content><![CDATA[<p>TTL接口的定义，分类以及输出信号的介绍。</p>
<p>　　TTL接口</p>
<p>　　1．TTL接口概述</p>
<p>　　TTL（Transistor Transistor Logic）即晶体管-晶体管逻辑，TTL电平信号由TTL器件产生。TTL器件是数字集成电路的一大门类，它采用双极型工艺制造，具有高速度、低功耗和品种多等特点。</p>
<p>　　TTL接口属于并行方式传输数据的接口，采用这种接口时，不必在液晶显示器的驱动板端和液晶面板端使用专用的接口电路，而是由驱动板主控芯片输出的TTL数据信号经电缆线直接传送到液晶面板的输人接口。由于TTL接口信号电压高、连线多、传输电缆长，因此，电路的抗干扰能力比较差，而且容易产生电磁干扰（EMI）。</p>
<p>　　在实际应用中，TTL接口电路多用来驱动小尺寸（15in以下）或低分辨率的液晶面板。另外，在笔记本电脑中也常使用1TL接口形式。</p>
<p>　　2．TTL接口的分类</p>
<p>　　TTL输出接口可分为以下几类：</p>
<p>　　（1）单路（或单通道）6bit TTL输出接口</p>
<p>　　这种接口电路中，采用单路方式传输，每个基色信号采用6bit数据（R0～R5，G0～G5，B0～B5）。由于基色RGB数据为18bit，因此，也称18位或18bit TTL接口。</p>
<p>　　（2）双路6bit TTL输出接口</p>
<p>　　这种接口电路中，采用双路方式传输，每个基色信号采用6bit数据（奇路为0RO～OR5，OG0～OG5，OB0～OB5；偶路为BRO～ER5，EG0～EG5，EB0～EB5）。由于基色ROB数据为36bit，因此，也称36位或36bit rrL接口。</p>
<p>　　（3）单路8bit TTL输出接口</p>
<p>　　这种接口电路中，采用单路方式传输，每个基色信号采用8bit数据（R0～R7，G0～G7，B0～B7）。由于基色RGB数据为24bit，因此，也称24位或24bit 1TL接口。</p>
<p>　　（4）双路8bit TTL输出位接口</p>
<p>　　这种接口电路中，采用双路方式传输，每个基色信号采用8bit数据（奇路为OR0～OR7，OG0～0G7，OB0～OB7；偶路为ER0～ER7，EG0～EG7，EB0～EB7），由于基色RGB数据为48bit，因此，也称48位或48bit TTL接口。</p>
<p>　　3．TTL输出接口中的信号</p>
<p>　　驱动板TTL输出接口中一般包含RGB数据信号、时钟信号和控制信号这三大类信号。</p>
<p>　　（1）RGB数据信号</p>
<p>　　对于6bit单路TTL输出接口，共有18条RGB数据线，分别是R0～R5红基色数据6条，G0～G5绿基色数据6条，B0～B5蓝基色数据6条。</p>
<p>　　对于8bit单路TTI，输出接口，共有24条RGB数据线，分别是R0～R7红基色数据8条，B0～B7绿基色数据8</p>
<p>　　条，BO～B7蓝基色数据8条。</p>
<p>　　对于6bit双路TTL，输出接口，共有36条RGB数据线，分别是奇路RGB数据线18条，偶路RGB数据线18条。</p>
<p>　　对于8bit双路TTL输出接口，共有48条RGB数据线，分别是奇路RGB数据线24条，偶路RGB数据线24条。</p>
<p>　　（2）时钟信号 </p>
<p>　　时钟信号是指像素时钟信号，是传输数据和对数据信号进行读取的基准。像素时钟常用DCLK表示。在使用奇/偶像素双路方式传输RGB数据时，不同的输出接口使用像素时钟的方法有所不同。有的输出接口奇/偶像素双路数据共用一个像素时钟信号，有的输出接口奇/偶两路分别设置奇数像素数据时钟和偶数像素两个时钟信号，以适应不同液晶面板的需要。</p>
<p>　　（3）控制信号 </p>
<p>　　控制信号包括数据使能信号（或有效显示数据选通信号）DE、行同步信号HS、场同步信号VS。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>UART简介</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/UART%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>UART使用的是 异步，串行通信。<br>    串行通信是指利用一条传输线将资料一位位地顺序传送。特点是通信线路简单，利用简单的线缆就可实现通信，降低成本，适用于远距离通信，但传输速度慢的应用场合。<br>    异步通信以一个字符为传输单位，通信中两个字符间的时间间隔多少是不固定的，然而在同一个字符中的两个相邻位间的时间间隔是固定的。 <br>    数据传送速率用波特率来表示，即每秒钟传送的二进制位数。例如数据传送速率为120字符/秒，而每一个字符为10位（1个起始位，7个数据位，1个校验位，1个结束位），则其传送的波特率为10×120＝1200字符/秒＝1200波特。<br>    数据通信格式如下图：<br>其中各位的意义如下：<br>起始位：先发出一个逻辑”0”信号，表示传输字符的开始。<br>数据位：可以是5~8位逻辑”0”或”1”。如ASCII码（7位），扩展BCD码（8位）。小端传输<br>校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)<br>停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。<br>空闲位：处于逻辑“1”状态，表示当前线路上没有资料传送。<br>    注：异步通信是按字符传输的，接收设备在收到起始信号之后只要在一个字符的传输时间内能和发送设备保持同步就能正确接收。下一个字符起始位的到来又使同步重新校准（依靠检测起始位来实现发送与接收方的时钟自同步的）</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>UPX 加固</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/UPX%20%E5%8A%A0%E5%9B%BA/</url>
    <content><![CDATA[<p>git clone <a href="https://github.com/upx/upx.git">https://github.com/upx/upx.git</a></p>
<p>git clone <a href="https://github.com/upx/upx-lzma-sdk.git">https://github.com/upx/upx-lzma-sdk.git</a> lzma-sdk</p>
<p>wget <a href="http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz">http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz</a></p>
<p>tar -xzvf ucl-1.03.tar.gz</p>
<p>cd ucl-1.03</p>
<p>./configure –prefix=/home/edward/upx CC=clang</p>
<p>make </p>
<p>make all UPX_UCLDIR=/home/edward/upx/ucl-1.03 UPX_LZMADIR=/home/edward/upx/lzma-sdk</p>
<p>2.1、在native代码中定义全局变量用于增加生成的二进制的体积，例如：</p>
<p>C：int const dummy_to_make_this_compressible[100000] = {1,2,3};</p>
<p>C++：extern &quot;C&quot; int const dummy_to_make_this_compressible[100000] = {1,2,3};</p>
<p>注意：如果编译出来的库本身足够大，则此步骤可省略。</p>
<p>2.2、在native代码中声明_init()函数，用于在编译时生成_init段，例如：</p>
<p>C：void _init(void){}</p>
<p>C++：extern &quot;C&quot; {void _init(void){}}</p>
<p>2.3、在native代码中使用宏定义混淆函数名，用于增加静态反汇编分析难度，例如：</p>
<p>#define startSimpleWifi sSW</p>
<p>#define sendData sD</p>
<p>注意：C和C++代码定义或声明的方式是有所区别的，在C++中必须使用extern “C”关键          字进行修饰，被extern &quot;C&quot;修饰的变量和函数是按照C语言方式编译和连接的</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>USB2</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/USB2.0%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>VBUS_DET：输入信号，用于USB DEVICE检测VBUS电平， </p>
<p>0：低电平约0V，1：高电平约3V。默认无连接时电平为低，连接至PC或充电器时电平为高。 </p>
<p>USB_ID：输入信号，由USB  OTG协议定义，用于识别USB口所接设备的默认角色(host  or </p>
<p>device)。USB_ID默认上拉，处于device状况，如果要控制器进入host状态，需外接mini-A口或</p>
<p>micro-A口将USB_ID短接到地。 </p>
<p>RKELVIN：参考电阻默认44.2欧到地，可通过调节该电阻阻值来调整USB信号质量。 </p>
<p>OTG_DRVVBUS：该信号由USB控制器的host寄存器控制，硬件上通过该信号来控制host所</p>
<p>需5V VBUS输出，高电平输出有效。 </p>
<p>DP/DM：即Data+, Data-，USB的两根差分信号线。 </p>
<p>控制器如果只作为host，  需要信号DP/DM，DRV_VBUS(可选)。 </p>
<p>控制器如果只作为device，需要信号DP/DM, VBUS_DET。 </p>
<p>控制器作为OTG使用，需要信号DP/DM, USB_ID, DRV_VBUS, VBUS_DET。 </p>
<p>控制器作为device功能时，一直通过VBUS_DET信号监控VBUS状态，VBUS如果为高，一</p>
<p>般是设备通过USB线连接到PC。Kernel函数调用接口为int dwc_vbus_status( void )。 </p>
<p>VBUS状态查询节点： </p>
<p>/sys/bus/platform/drivers/usb20_otg/vbus_status    (read only) </p>
<p>vbus_status可能的值为： </p>
<p>0  VBUS为低电平(约0V)； </p>
<p>1  VBUS为高电平(约5V)； </p>
<p>2  VBUS为高，且DP/DM信号均为高电平(用于国标充电器判断)。</p>
<p>设备主动连接PC使能 </p>
<p>对应2.3节的控制器选项，用于使能控制器检测到VBUS后连接PC。 </p>
<p>/sys/bus/platform/drivers/usb20_otg/dwc_otg_conn_en  (read&amp;write) </p>
<p>dwc_otg_conn_en可能的值为： </p>
<p>0  设备检测到VBUS后不发起USB连接； </p>
<p> 1   设备检测到VBUS后会发起USB连接。 </p>
<p>OTG控制器角色强制切换 </p>
<p>2.3节提到OTG控制器可以作为HOST，也能作为device，控制器的角色一般由USB ID电平决</p>
<p>定(参考1.1节USB_ID信号)，也可以由软件进行强制切换，接口如下： </p>
<p>/sys/bus/platform/drivers/usb20_otg/force_usb_mode </p>
<p>force_usb_mode 可能的值为：  </p>
<p>0  depends on USB ID </p>
<p>1  force host </p>
<p>2  force device </p>
<p>查询OTG控制器当前角色 </p>
<p>USB2.0 HOST和USB1.1 HOST都只能作为host使用，而USB2.0 OTG可以作为host，也能作</p>
<p>为device功能使用，查询当前工作的角色接口如下： </p>
<p>/sys/devices/platform/usb20_otg/mode </p>
<p>Mode:  </p>
<p>0  device mode </p>
<p>1   host mode</p>
<p>四 USB充电器检测 </p>
<p>USB-IF发布battery  charge1.2标准作为移动设备充电检测标准，其他一些组织也有发布类似标</p>
<p>准，其中中国工信部标准要求USB充电器的DP, DM短接。 </p>
<p>RK的USB控制器不支持battery charge1.2标准，但是可以检测出国标充电器的DP,DM短接。 </p>
<p>由于PC的USB  host口默认只提供500mA的供电，而一般充电器可以达到800mA或者1A以</p>
<p>上的电流充电，所以需要识别并做不同处理。 </p>
<p>USB模块提供的VBUS状态和PC连接状态变化情况如下，充电模块如需使用请务必了解状态</p>
<p>的变化过程： </p>
<p>1 无连接，VBUS状态为0，gadget连接状态为0； </p>
<p>2 刚连接到PC或充电器，VBUS状态为1，gadget连接状态为0； </p>
<p>3  device会发起连接，如果是信号较好的PC，可以很快连上(1,2s 内)，如果信号较差，设备会</p>
<p>retry 3次，每次时间约为1S，连上后VBUS状态为1，gadget连接状态为1； </p>
<p>4 如果外接不是PC，那么3次连接超时后，会给出DP, DM的状态，如果是标准充电器VBUS</p>
<p>状态为2，gadget连接状态为0；如果非标准充电器，VBUS状态为1，gadget连接状态为0。 </p>
<p>MSC外设(U盘)挂载 </p>
<p>已发布的SDK默认只支持在USB2.0  HOST控制器上挂载U盘等MSC外设，配置位于</p>
<p>/device/rockchip/rk30sdk/vold.fstab，如果需要增加其他控制器的支持，如USB2.0 OTG，需要修改如</p>
<p>下代码: </p>
<p>dev_mount udisk /mnt/usb_storage auto /devices/platform/usb20_host/usb </p>
<p>修改为 </p>
<p>dev_mount udisk /mnt/usb_storage auto /devices/platform/usb20_host/usb /devices/platform/usb20_otg/usb </p>
<p>系统起来后可以使用cat /system/etc/vold.fstab 命令查看实际配置。</p>
<p>VID/PID规则及修改 </p>
<p>USB  gadget在不同配置下，必须使用不同的PID，否则会导致PC(windows)驱动识别混乱，常用</p>
<p>的gadget为MSC, MTP及跟ADB的组合。Google在2011年提出AOA(Android Open Accessory)，在gadget</p>
<p>中增加一个accessory模式，对于ID强制要求为： </p>
<p>Accessory：VID/PID = 0x18d1, 0x2d00 </p>
<p>Accessory,adb: VID/PID = 0x18d1, 0x2d01 </p>
<p>其他ID 可以使用vendor自己的ID，SDK默认使用rockchip的VID(0x2207),  PID(depends  on  config)，</p>
<p>如果需要使用rockchip的ID，请使用默认值，请勿做任何修改，如果需要使用自己的VID/PID，请自</p>
<p>行规划。VID/PID修改位于/device/rockchip/rk30sdk/init.rk30board.usb.rc 文件</p>
<p>HOST典型供电电路及信号连接如下图，实际使用可能比下图复杂：</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>adb shell进去后显示shell@xxxx的标识</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/adb%20shell%E8%BF%9B%E5%8E%BB%E5%90%8E%E6%98%BE%E7%A4%BAshell@xxxx%E7%9A%84%E6%A0%87%E8%AF%86/</url>
    <content><![CDATA[<p>首先，找到源代码，在external/mksh/mkshrc,打开这个文件后会看到开头有如下脚本：</p>
<p>android4.2源码内容如下： </p>
<p>: ${TERM:=vt100} ${HOME:=/data} ${MKSH:=/system/bin/sh} ${HOSTNAME:=android}  </p>
<p>: ${SHELL:=$MKSH} ${USER:=$(typeset x=$(id); x=${x#<em>}; print -r – ${x%%</em>})}  </p>
<p>if (( USER_ID )); then PS1=’$’; else PS1=’#’; fi  </p>
<p>android5.0源码内容如下：</p>
<p>: ${TERM:=vt100} ${HOME:=/data} ${MKSH:=/system/bin/sh} ${HOSTNAME:=$(getprop ro.product.device)}  </p>
<p>: ${SHELL:=$MKSH} ${USER:=$(typeset x=$(id); x=${x#<em>}; print -r – ${x%%</em>})} ${HOSTNAME:=android}  </p>
<p>android6.0源码内容如下：</p>
<p>: ${HOME:=/data}  </p>
<p>: ${HOSTNAME:=$(getprop ro.product.device)}  </p>
<p>: ${HOSTNAME:=android}  </p>
<p>: ${MKSH:=/system/bin/sh}  </p>
<p>: ${SHELL:=$MKSH}  </p>
<p>: ${TERM:=xterm}  </p>
<p>: ${TMPDIR:=/data/local/tmp}  </p>
<p>: ${USER:=$(id -un)}  </p>
<p>找到第一个HOSTNAME=$(getprop ro.product.device)，将后面的$(getprop ro.product.device)这个变量的值改成自己的名称就可以了。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>adb 升级 OTA 包</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/adb%20%E5%8D%87%E7%BA%A7%20OTA%20%E5%8C%85/</url>
    <content><![CDATA[<p>adb shell &quot;echo &amp;quot;–update_package=/sdcard/update.zip&amp;quot; &gt; /cache/recovery/command&quot;</p>
<p>adb reboot recovery</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>adb 重新编译 windowslinux</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/adb%20%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%20windowslinux/</url>
    <content><![CDATA[<p>方法一（临时方法）</p>
<p>一，先搞清现在的 PID ，VID 为多少，例如分别为 aaaa、bbbb（十六进制）</p>
<p>      对于 linux 如 ubuntu, 插入 设备，再查询 /sys/bus/usb/ 下的相应设备，如 &quot;1-1&quot; 下的 idVender, idProduct 获得。</p>
<p>      对于 windows, 可从相应设备的属性中获得</p>
<p>二，对于windows:</p>
<ol>
<li>修改 adb 驱动中的 android_winusb.inf 文件。对照着别的项目加就可以了。</li>
</ol>
<p>例如：</p>
<p>; My product<br>%CompositeAdbInterface% = USB_Install, USB\VID_AAAA&amp;PID_BBBB </p>
<p>%SingleBootLoaderInterface% = USB_Install, USB\VID_AAAA&amp;PID_BBBB&amp;MI_01</p>
<ol start="2">
<li><p>右击我的电脑-&gt;属性-&gt;高级-&gt;环境变量，添加 ANROID_SDK_HOME 环境变量。如果你有 android SDK, 就设成 SDK 的路径；如果没有，那也没关系，设为你觉得方便的任何路径。</p>
</li>
<li><p>在前面设置的 ANDROID_SDK_HOME 对应的路径下，寻找 .android 目录，如果没有就创建一个；在 .android 目录下新建一个文件，叫adb_usb.ini, 记住，后缀是 &quot;ini&quot; 哦；添加前面获得的 VID 到 adb_usb.ini 中，如 0xAAAA。</p>
</li>
<li><p>然后安装 adb 驱动</p>
</li>
<li><p>进入 DOS cmd, 分别输入 adb kill-server, adb start-server, adb devices；若能看到 devices 列出，那么就成功了。</p>
</li>
</ol>
<p>三，对于linux</p>
<ol>
<li><p>在用户的 home 目录下，寻找 .android 目录，如果没有就创建。在 .android 目录下新建一个文件，叫adb_usb.ini, 记住，后缀是 &quot;ini&quot; 哦；添加前面获得的 VID 到 adb_usb.ini 中，如 0xAAAA。</p>
</li>
<li><p>在 shell 中 分别输入 adb kill-server, adb start-server, adb devices；若能看到 devices 列出，那么就成功了。</p>
</li>
</ol>
<p>这里 kill-server，是 kill 掉 adb 的 daemon，否则，adb 还是保留着先前的 Vender 信息。start-server 就加载了新的 Vender 信息。</p>
<p>注意：有些人可能用 adb 需要超级用户权限，这时第一步中的home 目录应该为 /root，不想麻烦，直接两个 Home 目录都加上得了。</p>
<p>方法二(终极方法）</p>
<p>在linux中重新编译windows版本的adb，添加VID,PID支持</p>
<p>在myandroid/system/core/adb/usb_vendors.c中添加所需要的VID</p>
<ol>
<li>执行：apt-get install mingw32</li>
</ol>
<p>            安装了linux-windows交叉编译环境mingwin</p>
<ol start="2">
<li><p>执行：. build/envsetup.sh</p>
</li>
<li><p>执行choosecombo，选择各个参数</p>
</li>
</ol>
<p>            这两步设置了一些编译参数和环境变量，按照你正常编译android的设置即可。</p>
<ol start="4">
<li><p>执行：make USE_MINGW=y adb</p>
</li>
<li><p>执行：make USE_MINGW=y fastboot</p>
</li>
</ol>
<p>最后到out/host/windows-x86/bin目录下就能找到你刚刚编译的东西了。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>androi VOLUME_MUTE 的处理</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/androi%20VOLUME_MUTE%20%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>getevent </p>
<p>找到input设备</p>
<p>getevent /dev/input/eventn  n = 0 ,1,2. …</p>
<p>0001 0071 00000001       16进制</p>
<p>adb shell sendevent [device] [type] [code] [value]</p>
<p>diff –git a/frameworks/base/media/java/android/media/AudioManager.java b/frameworks/base/media/java/android/media/AudioManager.java</p>
<p>index 315051c..8335395 100755</p>
<p>— a/frameworks/base/media/java/android/media/AudioManager.java</p>
<p>+++ b/frameworks/base/media/java/android/media/AudioManager.java</p>
<p>@@ -496,8 +496,19 @@ public class AudioManager {</p>
<p>                         setMasterMute(!isMasterMute());</p>
<p>                     } else {</p>
<p>                         // TODO: Actually handle MUTE.</p>
<ul>
<li><p>Log.d(&quot;edward&quot;,&quot; mute one time&quot;);</p>
</li>
<li><p>this.setRingerMode(AudioManager.RINGER_MODE_SILENT);</p>
</li>
<li><p>adjustStreamVolume(AudioManager.STREAM_MUSIC,</p>
</li>
<li><p>AudioManager.ADJUST_SAME,</p>
</li>
<li><p>AudioManager.FLAG_SHOW_UI);</p>
</li>
</ul>
<p>                     }</p>
<ul>
<li>}</li>
</ul>
<ul>
<li><p>}else{</p>
</li>
<li><p>Log.d(&quot;edward&quot;,&quot; mute more time&quot;);</p>
</li>
<li><p>this.setRingerMode(AudioManager.RINGER_MODE_SILENT);</p>
</li>
<li><p>adjustStreamVolume(AudioManager.STREAM_MUSIC,</p>
</li>
<li><p>AudioManager.ADJUST_SAME,</p>
</li>
<li><p>AudioManager.FLAG_SHOW_UI);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>                 break;</p>
<p>         }</p>
<p>     }</p>
<p>加un mute 功能  </p>
<p>diff –git a/frameworks/base/media/java/android/media/AudioManager.java b/frameworks/base/media/java/android/media/AudioManager.</p>
<p>index 315051c..b0c1a25 100755</p>
<p>— a/frameworks/base/media/java/android/media/AudioManager.java</p>
<p>+++ b/frameworks/base/media/java/android/media/AudioManager.java</p>
<p>@@ -459,7 +459,7 @@ public class AudioManager {</p>
<p>             }</p>
<p>         }</p>
<p>     }</p>
<p>-</p>
<ul>
<li>private static boolean mute_vol = true;</li>
</ul>
<p>     /**</p>
<p>      * @hide</p>
<p>      */</p>
<p>@@ -496,8 +496,25 @@ public class AudioManager {</p>
<p>                         setMasterMute(!isMasterMute());</p>
<p>                     } else {</p>
<p>                         // TODO: Actually handle MUTE.</p>
<p> if(mute_vol) {</p>
<p> this.setRingerMode(AudioManager.RINGER_MODE_SILENT);</p>
<p> mute_vol = false;</p>
<p> }</p>
<p> else{</p>
<p> this.setRingerMode(AudioManager.RINGER_MODE_NORMAL);</p>
<p> mute_vol = true;</p>
<p> }</p>
<p> adjustStreamVolume(AudioManager.STREAM_MUSIC,</p>
<p> AudioManager.ADJUST_SAME,</p>
<p> AudioManager.FLAG_SHOW_UI);</p>
<p>                     }</p>
<ul>
<li>}</li>
</ul>
<ul>
<li><p>}else{</p>
</li>
<li><p>this.setRingerMode(AudioManager.RINGER_MODE_SILENT);</p>
</li>
<li><p>adjustStreamVolume(AudioManager.STREAM_MUSIC,</p>
</li>
<li><p>AudioManager.ADJUST_SAME,</p>
</li>
<li><p>AudioManager.FLAG_SHOW_UI);</p>
</li>
<li><p>mute_vol = false;</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>                 break;</p>
<p>         }</p>
<p>     }</p>
<p>音量处理，不改变原来的音量</p>
<p>===================================================</p>
<p>case KeyEvent.KEYCODE_VOLUME_MUTE:</p>
<p>                if (event.getRepeatCount() == 0) {</p>
<p>                    if (mUseMasterVolume) {</p>
<p>                        setMasterMute(!isMasterMute());</p>
<p>                    } else {</p>
<p>                        // TODO: Actually handle MUTE.</p>
<p>                         if(mute_vol) {</p>
<p>                         adjustStreamVolume(AudioManager.STREAM_MUSIC, AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);</p>
<p>                         setRingerMode(AudioManager.RINGER_MODE_SILENT);</p>
<p>                         mute_vol = false;</p>
<p>                         }</p>
<p>                        else{</p>
<p>                                setRingerMode(AudioManager.RINGER_MODE_NORMAL);</p>
<p>                                 mute_vol = true;</p>
<p>                                adjustStreamVolume(AudioManager.STREAM_MUSIC, AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);</p>
<p>                         }</p>
<p>                    }</p>
<p>                }else{</p>
<p>                // adjustStreamVolume(AudioManager.STREAM_MUSIC, AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);</p>
<p>                        setRingerMode(AudioManager.RINGER_MODE_SILENT);</p>
<p>                        mute_vol = false;</p>
<p>                }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android Home 之前启动</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20Home%20%E4%B9%8B%E5%89%8D%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>diff –git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java</p>
<p>index a289649..66c2ac6 100644</p>
<p>— a/core/java/android/content/Intent.java</p>
<p>+++ b/core/java/android/content/Intent.java</p>
<p>@@ -2777,6 +2777,7 @@ public class Intent implements Parcelable, Cloneable {</p>
<p>      */</p>
<p>     @SdkConstant(SdkConstantType.INTENT_CATEGORY)</p>
<p>     public static final String CATEGORY_HOME = &quot;android.intent.category.HOME&quot;;</p>
<ul>
<li>   public static final String CATEGORY_HOME_FIRST = &quot;android.intent.category.HOME_FIRST&quot;;</li>
</ul>
<p>     /**</p>
<p>      * This activity is a preference panel.</p>
<p>      */</p>
<p>diff –git a/services/java/com/android/server/am/ActivityManagerService.java b/services/java/com/android/server/am/ActivityManagerService.java</p>
<p>index b17af80..7245c1f 100755</p>
<p>— a/services/java/com/android/server/am/ActivityManagerService.java</p>
<p>+++ b/services/java/com/android/server/am/ActivityManagerService.java</p>
<p>@@ -2858,7 +2858,8 @@ public final class ActivityManagerService extends ActivityManagerNative</p>
<p>         Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);</p>
<p>         intent.setComponent(mTopComponent);</p>
<p>         if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {</p>
<ul>
<li>           intent.addCategory(Intent.CATEGORY_HOME);</li>
</ul>
<ul>
<li><p>           //intent.addCategory(Intent.CATEGORY_HOME);</p>
</li>
<li><p>                      intent.addCategory(Intent.CATEGORY_HOME_FIRST);</p>
</li>
</ul>
<p>         }</p>
<p>         return intent;</p>
<p>     }</p>
<p>&lt;intent-filter android:priority=&quot;100&quot;&gt;  //默认0 ，数字越大，优先级越高</p>
<p>                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</p>
<p>                &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;</p>
<p>                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</p>
<p>  &lt;/intent-filter&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android dialog</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20dialog/</url>
    <content><![CDATA[<p><a href="http://www.eoeandroid.com/thread-184888-1-1.html">http://www.eoeandroid.com/thread-184888-1-1.html</a> </p>
<p>try <br>{<br>    Field field = dialog.getClass()<br>            .getSuperclass().getDeclaredField(<br>                     &quot;mShowing&quot; );<br>    field.setAccessible( true );<br>     //   将mShowing变量设为false，表示对话框已关闭 <br>    field.set(dialog, false );<br>    dialog.dismiss();<br>}<br>catch (Exception e)<br>{<br>}</p>
<p>  try <br>        {<br>            Field field = alertDialog1.getClass().getDeclaredField( &quot; mAlert &quot; );<br>            field.setAccessible( true );<br>            //   获得mAlert变量的值 <br>            Object obj = field.get(alertDialog1);<br>            field = obj.getClass().getDeclaredField( &quot; mHandler &quot; );<br>            field.setAccessible( true );<br>            //   修改mHandler变量的值，使用新的ButtonHandler类 <br>            field.set(obj, new ButtonHandler(alertDialog1));<br>        }<br>         catch (Exception e)<br>        {<br>        }<br>       //   显示对话框 <br>      alertDialog.show();     </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android initlogo</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20initlogo.rle%20%E5%9C%A832%E4%BD%8DLCD%E4%B8%8A%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>在S5PV210 ANDROID2.3 平台上做了一个initlogo.rle 显示不正常。</p>
<p>原因是initlogo.rle是16位数据，而我们的LCD是32位的，需要将initlogo.rle转换位32位的。    </p>
<p>源码路径：android_source/system/core/init/logo.c</p>
<p>#define fb_size(fb) ((fb)-&gt;vi.xres * (fb)-&gt;vi.yres * 2) </p>
<p>是用于16位的，修改如下：</p>
<p>#define fb_size(fb) ((fb)-&gt;vi.xres * (fb)-&gt;vi.yres * ((fb)-&gt;vi.bits_per_pixel/8))</p>
<p>添加 </p>
<p>#define fb_bpp(fb) ((fb)-&gt;vi.bits_per_pixel) //帧缓冲设备的每像素位数    </p>
<p>在函数 int load_565rle_image(char *fn) 之前定义16 bits to 32 bits 转换函数如下：<br>    void convert_565rle_to_32(unsigned short val,unsigned short ** pbits,unsigned int *pn)<br>    {<br>        uint32_t rgb32, red, green, blue, alpha;<br>        red = ((val &gt;&gt; 11) &amp; 0x1F);<br>        red = (red &lt;&lt; 3) | (red &gt;&gt; 2);   <br>        green = ((val &gt;&gt; 5) &amp; 0x3F);<br>        green = (green &lt;&lt; 2) | (green &gt;&gt; 4);    <br>        blue = ((val) &amp; 0x1F);<br>        blue = (blue &lt;&lt; 3) | (blue &gt;&gt; 2);    <br>        alpha = 0xff;<br>        rgb32 = (alpha &lt;&lt; 24) | (red &lt;&lt; 16) | (green &lt;&lt; 8) | (blue &lt;&lt; 0);<br>        android_memset32((uint32_t *)(*pbits), rgb32, (*pn) &lt;&lt; 2);<br>        *pbits += ((*pn) * 2);<br>    }<br>然后在int load_565rle_image(char *fn)函数中，将<br>        android_memset16(bits, ptr[1], n &lt;&lt; 1);<br>        bits += n;<br>修改如下：<br>        if (fb_bpp(&amp;fb) == 16) { //16位<br>            android_memset16(bits, ptr[1], n &lt;&lt; 1);<br>            bits += n;<br>        } else if(32 == fb_bpp(&amp;fb)){ // 32位<br>            convert_565rle_to_32(ptr[1],&amp;bits,&amp;n);<br>        }</p>
<p>这样，即可正常显示了。</p>
<p>不过烧入系统首次启动能够看到图片，重新启动就看不到了，提示没有initlogo.rle：</p>
<p>init: cannot open ‘/initlogo.rle’</p>
<p>在网上搜索到了如下解决办法：</p>
<p>在system/core/init/init.c[load_565rle_image]–&gt;logo.c中，显示完毕initlogo.rle之后作了 unlink 操作。该操作对于android默认的只读型system.img是没问题,但对于自定义的yaffs格式的可读写型的system.img时就有问题了。会造成将initlogo.rle删除，下次启动时读取不到该文件。可以通过注释掉logo.c的load_565rle_image（）中的    unlink（fn）语句来解决该问题。</p>
<p>向解决该问题的前辈鞠躬！   </p>
<p>initlogo.rle 制作方法：<br>    1. 制作与LCD尺寸相同的png图片logo.png<br>    2. 将图片转换为raw格式<br>    # convert -depth 8 logo.png rgb:logo.raw<br>    3. 将raw格式转化为rle文件<br>    # android_source/out/host/linux-x86/bin/rgb2565 -rle &lt;logo.raw&gt; initlogo.rle </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android kernel version</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20kernel%20version/</url>
    <content><![CDATA[<p>android kernel version 显示dirty</p>
<p>(2012-03-15 13:09:39) </p>
<p>转载▼</p>
<p>标签：  </p>
<p>杂谈</p>
<p>分类： linux </p>
<p>１.cat /proc/version的实现:</p>
<p>平时的时候我们都在用cat /proc/version来获得我们内核的版本号，代码在:kernel/fs/proc/version.c。</p>
<p>[cpp] view plaincopy</p>
<p>static int version_proc_show(struct seq_file *m, void *v)    {        seq_printf(m, linux_proc_banner,            utsname()-&gt;sysname,            utsname()-&gt;release,            utsname()-&gt;version);        return 0;    }            static int version_proc_open(struct inode *inode, struct file *file)    {        return single_open(file, version_proc_show, NULL);    }            static const struct file_operations version_proc_fops = {        .open       = version_proc_open,        .read       = seq_read,        .llseek     = seq_lseek,        .release    = single_release,    };            static int __init proc_version_init(void)    {        proc_create(&quot;version&quot;, 0, NULL, &amp;version_proc_fops);        return 0;    }    module_init(proc_version_init);     </p>
<p>这里看到show，是不是紧张了，现在就看看这些值是哪里赋值的。来看include/linux/utsname.h</p>
<p>[cpp] view plaincopy</p>
<p>static inline struct new_utsname *utsname(void)    {        return ¤t-&gt;nsproxy-&gt;uts_ns-&gt;name;    }     </p>
<p>在utsname中有一个nsproxy。这个在kernel/nsproxy中定义了uts_ns</p>
<p>[cpp] view plaincopy</p>
<p>struct nsproxy init_nsproxy = {        .count  = ATOMIC_INIT(1),        .uts_ns = &amp;init_uts_ns,    #if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)        .ipc_ns = &amp;init_ipc_ns,    #endif        .mnt_ns = NULL,        .pid_ns = &amp;init_pid_ns,    #ifdef CONFIG_NET        .net_ns = &amp;init_net,    #endif    };     </p>
<p>看到了所使用的uts_ns了吧，在init/version.c中</p>
<p>[cpp] view plaincopy</p>
<p>struct uts_namespace init_uts_ns = {        .kref = {            .refcount   = ATOMIC_INIT(2),        },        .name = {            .sysname    = UTS_SYSNAME,            .nodename   = UTS_NODENAME,            .release    = UTS_RELEASE,            .version    = UTS_VERSION,            .machine    = UTS_MACHINE,            .domainname = UTS_DOMAINNAME,        },    }; </p>
<p>EXPORT_SYMBOL_GPL(init_uts_ns);<br>const char linux_banner[] =<br> &quot;Linux version &quot; UTS_RELEASE &quot; (&quot; LINUX_COMPILE_BY &quot;@&quot;<br> LINUX_COMPILE_HOST &quot;) (&quot; LINUX_COMPILER &quot;) &quot; UTS_VERSION &quot;\n&quot;;<br>const char linux_proc_banner[] =<br> &quot;%s version %s\n&quot;;<br> &quot; (&quot; LINUX_COMPILE_BY &quot;@&quot; LINUX_COMPILE_HOST &quot;)&quot;<br> &quot; (&quot; LINUX_COMPILER &quot;) %s\n&quot;;<br>所以我们在version_proc_show中看到的utsname中使用了version等等。<br>言归正传，看看init_uts_ns中的UTS_VERSION的定义，where？<br>在kernel/include/generated/compile.h中，看到这里去找文件，( ⊙ o ⊙ )啊！，怎么没有你说的？？稍等，继续往下看。<br>在kernel/scripts/mkcompile_h文件中呢，这里都是用脚本来生成的compile.h这个文件。<br>等编译完后会成/out/debug/target/product/qaj30/obj/KERNEL/include/linux下生成<br>autoconf.h  bounds.h  compile.h  utsrelease.h  version.h<br>cat utstrelease.h :<br>#define UTS_RELEASE &quot;2.6.32.9-g571ece4-dirty&quot;<br>2. utstrelease.h的生成:<br>　kernel/Makefile:<br>uts_len := 64<br>define filechk_utsrelease.h<br> if [ <code>echo -n &amp;quot;$(KERNELRELEASE)&amp;quot; | wc -c </code> -gt $(uts_len) ]; then <br> echo ‘&quot;$(KERNELRELEASE)&quot; exceeds $(uts_len) characters’ &gt;&amp;2;    <br> exit 1;                                                         <br> fi;                                                               <br> (echo #define UTS_RELEASE &amp;quot;$(KERNELRELEASE)&amp;quot;;)<br>endef<br>define filechk_version.h<br> (echo #define LINUX_VERSION_CODE $(shell                             <br> expr $(VERSION) * 65536 + $(PATCHLEVEL) * 256 + $(SUBLEVEL));     <br> echo ‘#define KERNEL_VERSION(a,b,c) (((a) &lt;&lt; 16) + ((b) &lt;&lt; 8) + (c))’;)<br>endef<br>include/linux/version.h: $(srctree)/Makefile FORCE　　　　　　　　//version.h的生成<br> $(call filechk,version.h)<br>include/linux/utsrelease.h: include/config/kernel.release FORCE          //utstrelease.h的生成<br> $(call filechk,utsrelease.h)<br>可以看出UTS_RELEASE 是由KERNELRELEASE生成:</p>
<h1 id="Read-KERNELRELEASE-from-include-config-kernel-release-if-it-exists"><a href="#Read-KERNELRELEASE-from-include-config-kernel-release-if-it-exists" class="headerlink" title="Read KERNELRELEASE from include/config/kernel.release (if it exists)"></a>Read KERNELRELEASE from include/config/kernel.release (if it exists)</h1><p>KERNELRELEASE = $(shell cat include/config/kernel.release 2&gt; /dev/null)<br>KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)<br>３.kernel.release 的生成:</p>
<h1 id="Build-the-kernel-release-string"><a href="#Build-the-kernel-release-string" class="headerlink" title="Build the kernel release string"></a>Build the kernel release string</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="The-KERNELRELEASE-value-built-here-is-stored-in-the-file"><a href="#The-KERNELRELEASE-value-built-here-is-stored-in-the-file" class="headerlink" title="The KERNELRELEASE value built here is stored in the file"></a>The KERNELRELEASE value built here is stored in the file</h1><h1 id="include-config-kernel-release-and-is-used-when-executing-several"><a href="#include-config-kernel-release-and-is-used-when-executing-several" class="headerlink" title="include/config/kernel.release, and is used when executing several"></a>include/config/kernel.release, and is used when executing several</h1><h1 id="make-targets-such-as-quot-make-install-quot-or-quot-make-modules-install-quot"><a href="#make-targets-such-as-quot-make-install-quot-or-quot-make-modules-install-quot" class="headerlink" title="make targets, such as &quot;make install&quot; or &quot;make modules_install.&quot;"></a>make targets, such as &quot;make install&quot; or &quot;make modules_install.&quot;</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="The-eventual-kernel-release-string-consists-of-the-following-fields"><a href="#The-eventual-kernel-release-string-consists-of-the-following-fields" class="headerlink" title="The eventual kernel release string consists of the following fields,"></a>The eventual kernel release string consists of the following fields,</h1><h1 id="shown-in-a-hierarchical-format-to-show-how-smaller-parts-are-concatenated"><a href="#shown-in-a-hierarchical-format-to-show-how-smaller-parts-are-concatenated" class="headerlink" title="shown in a hierarchical format to show how smaller parts are concatenated"></a>shown in a hierarchical format to show how smaller parts are concatenated</h1><h1 id="to-form-the-larger-and-final-value-with-values-coming-from-places-like"><a href="#to-form-the-larger-and-final-value-with-values-coming-from-places-like" class="headerlink" title="to form the larger and final value, with values coming from places like"></a>to form the larger and final value, with values coming from places like</h1><h1 id="the-Makefile-kernel-config-options-make-command-line-options-and-or"><a href="#the-Makefile-kernel-config-options-make-command-line-options-and-or" class="headerlink" title="the Makefile, kernel config options, make command line options and/or"></a>the Makefile, kernel config options, make command line options and/or</h1><h1 id="SCM-tag-information"><a href="#SCM-tag-information" class="headerlink" title="SCM tag information."></a>SCM tag information.</h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="KERNELVERSION"><a href="#KERNELVERSION" class="headerlink" title="$(KERNELVERSION)"></a>$(KERNELVERSION)</h1><h1 id="VERSION-eg-2"><a href="#VERSION-eg-2" class="headerlink" title="$(VERSION)                    eg, 2"></a>$(VERSION)                    eg, 2</h1><h1 id="PATCHLEVEL-eg-6"><a href="#PATCHLEVEL-eg-6" class="headerlink" title="$(PATCHLEVEL)                 eg, 6"></a>$(PATCHLEVEL)                 eg, 6</h1><h1 id="SUBLEVEL-eg-18"><a href="#SUBLEVEL-eg-18" class="headerlink" title="$(SUBLEVEL)                   eg, 18"></a>$(SUBLEVEL)                   eg, 18</h1><h1 id="EXTRAVERSION-eg-rc6"><a href="#EXTRAVERSION-eg-rc6" class="headerlink" title="$(EXTRAVERSION)               eg, -rc6"></a>$(EXTRAVERSION)               eg, -rc6</h1><h1 id="localver-full"><a href="#localver-full" class="headerlink" title="$(localver-full)"></a>$(localver-full)</h1><h1 id="localver"><a href="#localver" class="headerlink" title="$(localver)"></a>$(localver)</h1><h1 id="localversion-files-without-backups-containing-‘-’"><a href="#localversion-files-without-backups-containing-‘-’" class="headerlink" title="localversion*               (files without backups, containing ‘~’)"></a>localversion*               (files without backups, containing ‘~’)</h1><h1 id="CONFIG-LOCALVERSION-from-kernel-config-setting"><a href="#CONFIG-LOCALVERSION-from-kernel-config-setting" class="headerlink" title="$(CONFIG_LOCALVERSION)      (from kernel config setting)"></a>$(CONFIG_LOCALVERSION)      (from kernel config setting)</h1><h1 id="localver-auto-only-if-CONFIG-LOCALVERSION-AUTO-is-set"><a href="#localver-auto-only-if-CONFIG-LOCALVERSION-AUTO-is-set" class="headerlink" title="$(localver-auto)              (only if CONFIG_LOCALVERSION_AUTO is set)"></a>$(localver-auto)              (only if CONFIG_LOCALVERSION_AUTO is set)</h1><h1 id="scripts-setlocalversion-SCM-tag-if-one-exists"><a href="#scripts-setlocalversion-SCM-tag-if-one-exists" class="headerlink" title="./scripts/setlocalversion   (SCM tag, if one exists)"></a>./scripts/setlocalversion   (SCM tag, if one exists)</h1><h1 id="LOCALVERSION-from-make-command-line-if-provided"><a href="#LOCALVERSION-from-make-command-line-if-provided" class="headerlink" title="$(LOCALVERSION)             (from make command line if provided)"></a>$(LOCALVERSION)             (from make command line if provided)</h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="Note-how-the-final-localver-auto-string-is-included-only-if-the"><a href="#Note-how-the-final-localver-auto-string-is-included-only-if-the" class="headerlink" title="Note how the final $(localver-auto) string is included only if the"></a>Note how the final $(localver-auto) string is included <em>only</em> if the</h1><h1 id="kernel-config-option-CONFIG-LOCALVERSION-AUTO-is-selected-Also-at-the"><a href="#kernel-config-option-CONFIG-LOCALVERSION-AUTO-is-selected-Also-at-the" class="headerlink" title="kernel config option CONFIG_LOCALVERSION_AUTO is selected.  Also, at the"></a>kernel config option CONFIG_LOCALVERSION_AUTO is selected.  Also, at the</h1><h1 id="moment-only-git-is-supported-but-other-SCMs-can-edit-the-script"><a href="#moment-only-git-is-supported-but-other-SCMs-can-edit-the-script" class="headerlink" title="moment, only git is supported but other SCMs can edit the script"></a>moment, only git is supported but other SCMs can edit the script</h1><h1 id="scripts-setlocalversion-and-add-the-appropriate-checks-as-needed"><a href="#scripts-setlocalversion-and-add-the-appropriate-checks-as-needed" class="headerlink" title="scripts/setlocalversion and add the appropriate checks as needed."></a>scripts/setlocalversion and add the appropriate checks as needed.</h1><p>pattern = &quot;.<em>/localversion[^~]</em>&quot;<br>string  = $(shell cat /dev/null <br> <code>find $(objtree) $(srctree) -maxdepth 1 -regex $(pattern) | sort -u</code>)<br>localver = $(subst $(space),, $(string) <br> $(patsubst &quot;%&quot;,%,$(CONFIG_LOCALVERSION)))</p>
<h1 id="If-CONFIG-LOCALVERSION-AUTO-is-set-scripts-setlocalversion-is-called"><a href="#If-CONFIG-LOCALVERSION-AUTO-is-set-scripts-setlocalversion-is-called" class="headerlink" title="If CONFIG_LOCALVERSION_AUTO is set scripts/setlocalversion is called"></a>If CONFIG_LOCALVERSION_AUTO is set scripts/setlocalversion is called</h1><h1 id="and-if-the-SCM-is-know-a-tag-from-the-SCM-is-appended"><a href="#and-if-the-SCM-is-know-a-tag-from-the-SCM-is-appended" class="headerlink" title="and if the SCM is know a tag from the SCM is appended."></a>and if the SCM is know a tag from the SCM is appended.</h1><h1 id="The-appended-tag-is-determined-by-the-SCM-used"><a href="#The-appended-tag-is-determined-by-the-SCM-used" class="headerlink" title="The appended tag is determined by the SCM used."></a>The appended tag is determined by the SCM used.</h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="scmversion-is-used-when-generating-rpm-packages-so-we-do-not-loose"><a href="#scmversion-is-used-when-generating-rpm-packages-so-we-do-not-loose" class="headerlink" title=".scmversion is used when generating rpm packages so we do not loose"></a>.scmversion is used when generating rpm packages so we do not loose</h1><h1 id="the-version-information-from-the-SCM-when-we-do-the-build-of-the-kernel"><a href="#the-version-information-from-the-SCM-when-we-do-the-build-of-the-kernel" class="headerlink" title="the version information from the SCM when we do the build of the kernel"></a>the version information from the SCM when we do the build of the kernel</h1><h1 id="from-the-copied-source"><a href="#from-the-copied-source" class="headerlink" title="from the copied source"></a>from the copied source</h1><p>ifdef CONFIG_LOCALVERSION_AUTO       //yes<br>ifeq ($(wildcard .scmversion),)                 //don,t have .scmversion<br> _localver-auto = $(shell $(CONFIG_SHELL) <br> $(srctree)/scripts/setlocalversion $(srctree))   //如果带–save-scmversion参数就会生成.scmversion,但是脚本没有带,所以不会有.scmversion<br>else<br> _localver-auto = $(shell cat .scmversion 2&gt; /dev/null)<br>endif<br> localver-auto  = $(LOCALVERSION)$(_localver-auto)<br>endif<br>localver-full = $(localver)$(localver-auto)</p>
<h1 id="Store-new-KERNELRELASE-string-in-include-config-kernel-release"><a href="#Store-new-KERNELRELASE-string-in-include-config-kernel-release" class="headerlink" title="Store (new) KERNELRELASE string in include/config/kernel.release"></a>Store (new) KERNELRELASE string in include/config/kernel.release</h1><p>kernelrelease = $(KERNELVERSION)$(localver-full)<br>include/config/kernel.release: include/config/auto.conf FORCE<br> $(Q)rm -f $@<br> $(Q)echo $(kernelrelease) &gt; $@<br>/kernel/scripts/setlocalversion:<br>#!/bin/sh<br>#</p>
<h1 id="This-scripts-adds-local-version-information-from-the-version"><a href="#This-scripts-adds-local-version-information-from-the-version" class="headerlink" title="This scripts adds local version information from the version"></a>This scripts adds local version information from the version</h1><h1 id="control-systems-git-mercurial-hg-and-subversion-svn"><a href="#control-systems-git-mercurial-hg-and-subversion-svn" class="headerlink" title="control systems git, mercurial (hg) and subversion (svn)."></a>control systems git, mercurial (hg) and subversion (svn).</h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><h1 id="If-something-goes-wrong-send-a-mail-the-kernel-build-mailinglist"><a href="#If-something-goes-wrong-send-a-mail-the-kernel-build-mailinglist" class="headerlink" title="If something goes wrong, send a mail the kernel build mailinglist"></a>If something goes wrong, send a mail the kernel build mailinglist</h1><h1 id="see-MAINTAINERS-and-CC-Nico-Schottelius"><a href="#see-MAINTAINERS-and-CC-Nico-Schottelius" class="headerlink" title="(see MAINTAINERS) and CC Nico Schottelius"></a>(see MAINTAINERS) and CC Nico Schottelius</h1><h1 id="lt-nico-linuxsetlocalversion-at-schottelius-org-gt"><a href="#lt-nico-linuxsetlocalversion-at-schottelius-org-gt" class="headerlink" title="&lt;nico-linuxsetlocalversion -at- schottelius.org&gt;."></a>&lt;nico-linuxsetlocalversion -at- schottelius.org&gt;.</h1><h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><p>usage() {<br> echo &quot;Usage: $0 [–save-scmversion] [srctree]&quot; &gt;&amp;2<br> exit 1<br>}<br>scm_only=false<br>srctree=.<br>if test &quot;$1&quot; = &quot;–save-scmversion&quot;; then<br> scm_only=true<br> shift<br>fi<br>if test $# -gt 0; then<br> srctree=$1<br> shift<br>fi<br>if test $# -gt 0 -o ! -d &quot;$srctree&quot;; then<br> usage<br>fi</p>
<h1 id="Check-for-git-and-a-git-repo"><a href="#Check-for-git-and-a-git-repo" class="headerlink" title="Check for git and a git repo."></a>Check for git and a git repo.</h1><p>if head=<code>git rev-parse --verify --short HEAD 2&amp;gt;/dev/null</code>; then<br> # If we are at a tagged commit (like &quot;v2.6.30-rc6&quot;), we ignore it,<br> # because this version is defined in the top level Makefile.<br> if [ -z &quot;<code>git describe --exact-match 2&amp;gt;/dev/null</code>&quot; ]; then<br> # If we are past a tagged commit (like &quot;v2.6.30-rc5-302-g72357d5&quot;),<br> # we pretty print it.<br> if atag=&quot;<code>git describe 2&amp;gt;/dev/null</code>&quot;; then<br> echo &quot;$atag&quot; | awk -F- ‘{printf(&quot;-d-%s&quot;, $(NF-1),$(NF))}’<br> # If we don’t have a tag at all we print -g{commitish}.<br> else<br> printf ‘%s%s’ -g $head<br> fi<br> fi<br> # Is this git on svn?<br> if git config –get svn-remote.svn.url &gt;/dev/null; then<br> printf – ‘-svn%s’ &quot;<code>git svn find-rev $head</code>&quot;<br> fi<br> # Update index only on r/w media<br> [ -w . ] &amp;&amp; git update-index –refresh –unmerged &gt; /dev/null<br> # Check for uncommitted changes　//如果kernel code有修改并且没有git commit,就会生成-dirty<br>if git diff-index –name-only HEAD | grep -v &quot;^scripts/package&quot; <br> | read dummy; then<br> printf ‘%s’ -dirty<br>fi<br> # All done with git<br> exit<br>fi</p>
<h1 id="Check-for-mercurial-and-a-mercurial-repo"><a href="#Check-for-mercurial-and-a-mercurial-repo" class="headerlink" title="Check for mercurial and a mercurial repo."></a>Check for mercurial and a mercurial repo.</h1><p>if hgid=<code>hg id 2&amp;gt;/dev/null</code>; then<br> tag=<code>printf &#39;%s&#39; &amp;quot;$hgid&amp;quot; | cut -d&#39; &#39; -f2</code><br> # Do we have an untagged version?<br> if [ -z &quot;$tag&quot; -o &quot;$tag&quot; = tip ]; then<br> id=<code>printf &#39;%s&#39; &amp;quot;$hgid&amp;quot; | sed &#39;s/[+ ].*//&#39;</code><br> printf ‘%s%s’ -hg &quot;$id&quot;<br> fi<br> # Are there uncommitted changes?<br> # These are represented by + after the changeset id.<br> case &quot;$hgid&quot; in<br> <em>+|</em>+\ *) printf ‘%s’ -dirty ;;<br> esac<br> # All done with mercurial<br> exit<br>fi</p>
<h1 id="Check-for-svn-and-a-svn-repo"><a href="#Check-for-svn-and-a-svn-repo" class="headerlink" title="Check for svn and a svn repo."></a>Check for svn and a svn repo.</h1><p>if rev=<code>svn info 2&amp;gt;/dev/null | grep &#39;^Last Changed Rev&#39;</code>; then<br> rev=<code>echo $rev | awk &#39;&#123;print $NF&#125;&#39;</code><br> printf – ‘-svn%s’ &quot;$rev&quot;<br> # All done with svn<br> exit<br>fi  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android keyevent 模拟按键</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20keyevent%20%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<p>1 . 延迟发送模拟的KeyEvent</p>
<p>private void sendVKeyDelay(int key) {</p>
<p>  final int keyCode = key;</p>
<p>  Thread sendKeyDelay = new Thread(){</p>
<p>   public void run() {</p>
<p>    try {</p>
<p>     Thread.sleep(100);</p>
<p>     long now = SystemClock.uptimeMillis();</p>
<p>     KeyEvent keyDown = new KeyEvent(now, now, KeyEvent.ACTION_DOWN,</p>
<p>       keyCode, 0);</p>
<p>     IWindowManager wm = IWindowManager.Stub.asInterface(</p>
<p>       ServiceManager.getService(&quot;window&quot;));</p>
<p>     wm.injectKeyEvent(keyDown, false);</p>
<p>     KeyEvent keyUp = new KeyEvent(now, now, KeyEvent.ACTION_UP,</p>
<p>       keyCode, 0);</p>
<p>     wm.injectKeyEvent(keyUp, false);</p>
<p>    } catch (InterruptedException e) {</p>
<p>     e.printStackTrace();</p>
<p>    } catch (RemoteException e) {</p>
<p>     e.printStackTrace();</p>
<p>    }</p>
<p>   }</p>
<p>  };</p>
<p>  sendKeyDelay.start();</p>
<p> }</p>
<p>2.用sendKeyDownUpSync</p>
<p>public static void simulateKeystroke(final int KeyCode) {</p>
<p>        new Thread(new Runnable() {</p>
<p>            public void run() {</p>
<p>                // TODO Auto-generated method stub</p>
<p>                try {                   </p>
<p>                    Instrumentation inst=new Instrumentation();</p>
<p>                    inst.sendKeyDownUpSync(KeyCode);</p>
<p>                } catch (Exception e) {</p>
<p>                    // TODO: handle exception</p>
<p>                }</p>
<p>            }</p>
<p>        }).start();</p>
<p>    }</p>
<p>android:sharedUserId=&quot;android.uid.system&quot;</p>
<p>LOCAL_CERTIFICATE := platform</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android note</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20note/</url>
    <content><![CDATA[<p>设置android:layout_width=&quot;0dp&quot;，按weight比例分配大小。</p>
<p>bindService(i, conn, Context.BIND_AUTO_CREATE);</p>
<p>android.support.v4.app.Fragment;变红，删除下面的缓存重新编译即可C:\Users\Administrator.android\build-cache</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android sdk address</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20sdk%20address/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/bjzhanghao/archive/2012/11/14/android-platform-sdk-download-mirror.html">http://www.cnblogs.com/bjzhanghao/archive/2012/11/14/android-platform-sdk-download-mirror.html</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android svc</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20svc/</url>
    <content><![CDATA[<p>Available commands:</p>
<p>    help     Show information about the subcommands</p>
<p>    power    Control the power manager</p>
<p>    data     Control mobile data connectivity</p>
<p>    wifi     Control the Wi-Fi manager</p>
<p>    usb      Control Usb state</p>
<p>    nfc      Control NFC functions</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android uses-features</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20uses-features/</url>
    <content><![CDATA[<p>adb shell pm list features</p>
<p>feature:reqGlEsVersion=0x20000</p>
<p>feature:android.hardware.audio.low_latency   //低延迟音频设备</p>
<p>feature:android.hardware.bluetooth</p>
<p>feature:android.hardware.camera</p>
<p>feature:android.hardware.camera.autofocus</p>
<p>feature:android.hardware.camera.flash</p>
<p>feature:android.hardware.camera.front</p>
<p>feature:android.hardware.ethernet</p>
<p>feature:android.hardware.faketouch</p>
<p>feature:android.hardware.faketouch.multitouch</p>
<p>feature:android.hardware.faketouch.multitouch.distinct    </p>
<p>feature:android.hardware.faketouch.multitouch.jazzhand </p>
<p>feature:android.hardware.location</p>
<p>feature:android.hardware.location.gps</p>
<p>feature:android.hardware.location.network</p>
<p>feature:android.hardware.microphone</p>
<p>feature:android.hardware.nfc</p>
<p>feature:android.hardware.screen.landscape</p>
<p>feature:android.hardware.screen.portrait</p>
<p>feature:android.hardware.sensor.accelerometer</p>
<p>feature:android.hardware.sensor.barometer   //压力传感器</p>
<p>feature:android.hardware.sensor.compass     //罗盘传感器</p>
<p>feature:android.hardware.sensor.gyroscope  //陀螺仪</p>
<p>feature:android.hardware.sensor.light</p>
<p>feature:android.hardware.sensor.proximity    //距离传感器</p>
<p>feature:android.hardware.telephony</p>
<p>feature:android.hardware.telephony.cdma</p>
<p>feature:android.hardware.telephony.gsm</p>
<p>feature:android.hardware.touchscreen</p>
<p>feature:android.hardware.touchscreen.multitouch</p>
<p>feature:android.hardware.touchscreen.multitouch.distinct     //2点</p>
<p>feature:android.hardware.touchscreen.multitouch.jazzhand   //5点</p>
<p>feature:android.hardware.usb.accessory</p>
<p>feature:android.hardware.usb.host</p>
<p>feature:android.hardware.wifi</p>
<p>feature:android.hardware.wifi.direct</p>
<p>feature:android.software.live_wallpaper</p>
<p>feature:android.software.pppoe</p>
<p>feature:android.software.sip           //</p>
<p>feature:android.software.sip.voip   //网络电话</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android wifi工作流程</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20wifi%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>android wifi工作流程</p>
<p>WIFI 核心模块</p>
<p>n  WifiService</p>
<p>frameworks/base/services/java/com/android/server/WifiService.java</p>
<p>由SystemServer启动的时候生成的ConnecttivityService创建，负责启动关闭wpa_supplicant,启动和关闭WifiMonitor线程，把命令下发给wpa_supplicant以及跟新WIFI的状态</p>
<p>n  WifiMonitor （调用WifiStateMachine发送信息）</p>
<p>frameworks/base/wifi/java/android/net/wifi/WifiMonitor.java </p>
<p>  负责从wpa_supplicant接收事件通知</p>
<p>n  Wpa_supplicant</p>
<p>1、读取配置文件</p>
<p>2、初始化配置参数，驱动函数</p>
<p>3、让驱动scan当前所有的bssid</p>
<p>4、检查扫描的参数是否和用户设置的想否</p>
<p>5、如果相符，通知驱动进行权限 认证操作</p>
<p>6、连上AP</p>
<p>n  Wifi驱动模块</p>
<p>厂商提供的source,主要进行load firmware和kernel的wireless进行通信</p>
<p>n  Wifi电源管理模块</p>
<p>主要控制硬件的GPIO和上下电，让CPU和Wifi模组之间通过sdio接口通信</p>
<p>Wifi工作步骤</p>
<p>n  Wifi模块初期化</p>
<p>n  Wifi启动</p>
<p>n  查找热点（AP）</p>
<p>n  配置AP</p>
<p>n  配置AP参数</p>
<p>n  Wifi连接</p>
<p>n  IP地址配置</p>
<p>Wifi模块代码总结</p>
<p>n  Wifi Application代码</p>
<p>packages/apps/Settings/src/com/android/settings/wifi</p>
<p>n  Wifi Framework</p>
<p>frameworks/base/wifi/java/android/net/wifi</p>
<p>frameworks/base/services/java/com/android/server</p>
<p>n  Wifi JNI</p>
<p>frameworks/base/core/jni/android_net_wifi_Wifi.cpp</p>
<p>n  Wifi Hardware</p>
<p>hardware/libhardware_legacy/wifi/wifi.c</p>
<p>n  Wifi tool</p>
<p>external/wpa_supplicant</p>
<p>n  Wifi kernel</p>
<p>net/wireless     drivers/wlan_sd8688       arch/arm/mach-pxa/wlan_pm.c</p>
<p>Wifi模块的初始化:</p>
<p>在 SystemServer 启动的时候，会生成一个ConnectivityService 的实例, ConnectivityService 的构造函数会创建WifiService，WifiStateTracker 会创建WifiMonitor 接收来自底层的事件，WifiService 和WifiMonitor 是整个模块的核心。WifiService 负责启动关闭wpa_supplicant、启动关闭WifiMonitor 监视线程和把命令下发给wpa_supplicant，而WifiMonitor 则负责从wpa_supplicant 接收事件通知。</p>
<p>Wifi模块的启动:</p>
<p>WirelessSettings 在初始化的时候配置了由WifiEnabler 来处理Wifi 按钮，</p>
<p>当用户按下Wifi 按钮后，Android 会调用WifiEnabler 的onPreferenceChange，再由WifiEnabler调用WifiManager 的setWifiEnabled 接口函数，通过AIDL，实际调用的是WifiService 的setWifiEnabled 函数，WifiService 接着向自身发送一条MESSAGE_ENABLE_WIFI 消息，在处理该消息的代码中做真正的使能工作：首先装载WIFI 内核模块（该模块的位置硬编码为&quot;/system/lib/modules/wlan.ko&quot; ）， 然后启动wpa_supplicant （ 配置文件硬编码为&quot;/data/misc/wifi/wpa_supplicant.conf&quot;），再通过WifiStateTracker 来启动WifiMonitor 中的监视线程。</p>
<p>查找热点（AP）:</p>
<p>（Wifi开启）中讲到Wifi模块开启后会对外发送WIFI_STATE_CHANGED_ACTION。WifiLayer中注册了Action的Receiver。当WifiLayer收到此Action后开始scan的流程，具体如下</p>
<p>当wpa_supplicant 处理完SCAN 命令后，它会向控制通道发送事件通知扫描完成，从wifi_wait_for_event 函数会接收到该事件，由此WifiMonitor 中的MonitorThread 会被执行来出来这个事件：</p>
<p>配置 AP 参数:</p>
<p>当用户在 WifiSettings 界面上选择了一个AP 后，会显示配置AP 参数的一个对话框：</p>
<p>Wifi连接:</p>
<p>IP地址的配置:</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android 利用socket 发送Json数据demo</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20%E5%88%A9%E7%94%A8socket%20%E5%8F%91%E9%80%81Json%E6%95%B0%E6%8D%AEdemo/</url>
    <content><![CDATA[<p>android 利用socket 发送Json数据demo</p>
<p>2015-04-29      0 个评论    来源：Coder_android  </p>
<p>收藏    我要投稿</p>
<p>客户端代码：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>59</p>
<p>60</p>
<p>61</p>
<p>62</p>
<p>63</p>
<p>64</p>
<p>65</p>
<p>66</p>
<p>67</p>
<p>68</p>
<p>69</p>
<p>70</p>
<p>71</p>
<p>72</p>
<p>73</p>
<p>74</p>
<p>75</p>
<p>76</p>
<p>77</p>
<p>78</p>
<p>79</p>
<p>80</p>
<p>81</p>
<p>82</p>
<p>package com.yqq.jsonclienttest;</p>
<p>import java.io.IOException;</p>
<p>import java.io.OutputStream;</p>
<p>import java.net.InetAddress;</p>
<p>import java.net.Socket;</p>
<p>import java.net.UnknownHostException;</p>
<p>import org.json.JSONException;</p>
<p>import org.json.JSONObject;</p>
<p>import android.app.Activity;</p>
<p>import android.os.Bundle;</p>
<p>import android.text.TextUtils;</p>
<p>import android.util.Log;</p>
<p>import android.view.View;</p>
<p>import android.widget.EditText;</p>
<p>import android.widget.Toast;</p>
<p>/**</p>
<ul>
<li><p>套接字客户端，</p>
</li>
<li><p>1、先生成JSON对象</p>
</li>
<li><p>2、将JSON对象转成JSON字符串</p>
</li>
<li><p>3、将JSON字符串转成字节数组写入套接字输出流</p>
</li>
<li><p>@author yqq_coder</p>
</li>
</ul>
<p>*</p>
<p>*/</p>
<p>public class MainActivity extends Activity {</p>
<p>private EditText et_name;</p>
<p>private EditText et_age;</p>
<p>private EditText et_sex;</p>
<p>private String host=172.21.133.15;//同一个局域网内作为服务端的手机的IP，使用端口8155</p>
<p>@Override</p>
<p>protected void onCreate(Bundle savedInstanceState) {</p>
<p>super.onCreate(savedInstanceState);</p>
<p>setContentView(R.layout.activity_main);</p>
<p>et_name=(EditText) findViewById(R.id.et_name);</p>
<p>et_age=(EditText) findViewById(R.id.et_age);</p>
<p>et_sex=(EditText) findViewById(R.id.et_sex);</p>
<p>}</p>
<p>public void submit(View v) throws JSONException{</p>
<p>if(TextUtils.isEmpty(et_name.getText().toString().trim())||TextUtils.isEmpty(et_age.getText().toString().trim())||TextUtils.isEmpty(et_sex.getText().toString().trim())){</p>
<p>Toast.makeText(MainActivity.this, 信息不能为空!!!, 0).show();</p>
<p>return;</p>
<p>}</p>
<p>JSONObject jsonObject=new JSONObject();</p>
<p>jsonObject.put(name, et_name.getText().toString().trim());</p>
<p>jsonObject.put(age, et_age.getText().toString().trim());</p>
<p>jsonObject.put(sex, et_sex.getText().toString().trim());</p>
<p>final String  result=jsonObject.toString();</p>
<p>Log.i(jSON字符串, result);</p>
<p>new Thread(new  Runnable() {</p>
<p>@Override</p>
<p>public void run() {</p>
<p>try {</p>
<p>Socket socket=new Socket(InetAddress.getByName(host), 8155);</p>
<p>OutputStream os=socket.getOutputStream();</p>
<p>os.write(result.getBytes());</p>
<p>os.flush();</p>
<p>//防止服务端read方法读阻塞</p>
<p>socket.shutdownOutput();</p>
<p>} catch (UnknownHostException e) {</p>
<p>// TODO Auto-generated catch block</p>
<p>e.printStackTrace();</p>
<p>} catch (IOException e) {</p>
<p>// TODO Auto-generated catch block</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}).start();</p>
<p>}</p>
<p>}</p>
<p>服务端代码：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>59</p>
<p>60</p>
<p>61</p>
<p>62</p>
<p>63</p>
<p>64</p>
<p>65</p>
<p>66</p>
<p>67</p>
<p>68</p>
<p>69</p>
<p>70</p>
<p>71</p>
<p>72</p>
<p>73</p>
<p>74</p>
<p>75</p>
<p>76</p>
<p>77</p>
<p>78</p>
<p>79</p>
<p>80</p>
<p>81</p>
<p>82</p>
<p>83</p>
<p>84</p>
<p>85</p>
<p>86</p>
<p>87</p>
<p>88</p>
<p>89</p>
<p>90</p>
<p>91</p>
<p>92</p>
<p>93</p>
<p>94</p>
<p>95</p>
<p>96</p>
<p>97</p>
<p>98</p>
<p>99</p>
<p>100</p>
<p>101</p>
<p>102</p>
<p>103</p>
<p>104</p>
<p>105</p>
<p>106</p>
<p>107</p>
<p>108</p>
<p>109</p>
<p>110</p>
<p>111</p>
<p>112</p>
<p>113</p>
<p>114</p>
<p>115</p>
<p>116</p>
<p>117</p>
<p>118</p>
<p>119</p>
<p>120</p>
<p>121</p>
<p>122</p>
<p>123</p>
<p>124</p>
<p>125</p>
<p>126</p>
<p>127</p>
<p>128</p>
<p>129</p>
<p>130</p>
<p>131</p>
<p>132</p>
<p>133</p>
<p>134</p>
<p>135</p>
<p>136</p>
<p>137</p>
<p>138</p>
<p>139</p>
<p>140</p>
<p>141</p>
<p>142</p>
<p>143</p>
<p>144</p>
<p>145</p>
<p>146</p>
<p>147</p>
<p>148</p>
<p>149</p>
<p>150</p>
<p>151</p>
<p>152</p>
<p>153</p>
<p>154</p>
<p>package com.yqq.jsonclienttest1;</p>
<p>import java.io.ByteArrayOutputStream;</p>
<p>import java.io.IOException;</p>
<p>import java.io.InputStream;</p>
<p>import java.io.OutputStream;</p>
<p>import java.net.InetAddress;</p>
<p>import java.net.ServerSocket;</p>
<p>import java.net.Socket;</p>
<p>import java.net.UnknownHostException;</p>
<p>import org.json.JSONException;</p>
<p>import org.json.JSONObject;</p>
<p>import com.yqq.jsonclienttest1.R;</p>
<p>import android.app.Activity;</p>
<p>import android.os.Bundle;</p>
<p>import android.os.Handler;</p>
<p>import android.os.Looper;</p>
<p>import android.os.Message;</p>
<p>import android.text.TextUtils;</p>
<p>import android.util.Log;</p>
<p>import android.view.View;</p>
<p>import android.widget.Button;</p>
<p>import android.widget.EditText;</p>
<p>import android.widget.Toast;</p>
<p>/**</p>
<ul>
<li><p>套接字服务端</p>
</li>
<li><p>@author yqq_coder</p>
</li>
</ul>
<p>*</p>
<p>*/</p>
<p>public class MainActivity extends Activity {</p>
<p>private Button btn;</p>
<p>volatile Socket   mSocket;</p>
<p>ServerSocket server;</p>
<p>private Handler mHandler=new Handler(){</p>
<p>@Override</p>
<p>public void handleMessage(Message msg) {</p>
<p>// TODO Auto-generated method stub</p>
<p>super.handleMessage(msg);</p>
<p>if(msg.what==0x01){</p>
<p>Toast.makeText(MainActivity.this,(String) msg.obj, 500).show();</p>
<p>btn.setEnabled(true);</p>
<p>}</p>
<p>if(msg.what==0x02){</p>
<p>new Thread(new  Runnable() {</p>
<p>@Override</p>
<p>public void run() {</p>
<p>try {</p>
<p>Log.i(客户端连接, 读取客户端发来的数据);</p>
<p>InputStream ins=mSocket.getInputStream();</p>
<p>ByteArrayOutputStream os=new ByteArrayOutputStream();</p>
<p>int len=0;</p>
<p>byte[] buffer=new byte[1024];</p>
<p>while((len=ins.read(buffer))!=-1){</p>
<p>os.write(buffer);</p>
<p>}</p>
<p>//第一步，生成Json字符串格式的JSON对象</p>
<p>JSONObject jsonObject=new JSONObject(os.toString());</p>
<p>//第二步，从JSON对象中取值如果JSON 对象较多，可以用json数组</p>
<p>String name=姓名：+jsonObject.getString(name);</p>
<p>String age=年龄：+jsonObject.getString(age);</p>
<p>String sex=性别：+jsonObject.getString(sex);</p>
<p>StringBuffer sb=new StringBuffer();</p>
<p>sb.append(name);</p>
<p>sb.append(age);</p>
<p>sb.append(sex);</p>
<p>Looper.prepare();</p>
<p>Message message=Message.obtain();</p>
<p>message.what=0X01;</p>
<p>message.obj=sb.toString();</p>
<p>mHandler.sendMessage(message);</p>
<p>Looper.loop();</p>
<p>} catch (Exception e) {</p>
<p>// TODO Auto-generated catch block</p>
<p>e.printStackTrace();</p>
<p>}finally{</p>
<p>if(mSocket!=null){</p>
<p>try {</p>
<p>mSocket.close();</p>
<p>mSocket=null;</p>
<p>} catch (IOException e) {</p>
<p>// TODO Auto-generated catch block</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}).start();</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>@Override</p>
<p>protected void onCreate(Bundle savedInstanceState) {</p>
<p>super.onCreate(savedInstanceState);</p>
<p>setContentView(R.layout.activity_main);</p>
<p>btn=(Button) findViewById(R.id.btn);</p>
<p>}</p>
<p>public void submit(View v) throws JSONException, IOException{</p>
<p>btn.setEnabled(false);</p>
<p>new Thread(new  Runnable() {</p>
<p>@Override</p>
<p>public void run() {</p>
<p>try {</p>
<p>Log.i(阻塞，等待客户端连接, &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;);</p>
<p>if(server==null){</p>
<p>server=new ServerSocket(8155);</p>
<p>}</p>
<p>mSocket=server.accept();</p>
<p>Log.i(客户端连接成功, &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;客户端连接成功);</p>
<p>Looper.prepare();</p>
<p>Message message=Message.obtain();</p>
<p>message.what=0X02;</p>
<p>mHandler.sendMessage(message);</p>
<p>Looper.loop();</p>
<p>} catch (Exception e) {</p>
<p>// TODO Auto-generated catch block</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}).start();</p>
<p>}</p>
<p>}</p>
<p>第二次监听时候报错：</p>
<p>04-28 12:55:52.841: W/System.err(8761): java.net.BindException: bind failed:</p>
<p>解决办法：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>if(server==null){</p>
<p>server=new ServerSocket(8155);</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android 多媒体</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20%E5%A4%9A%E5%AA%92%E4%BD%93/</url>
    <content><![CDATA[<p>stagefriaght omax asomeplayer<br><a href="https://www.cnblogs.com/shakin/p/4463639.html">https://www.cnblogs.com/shakin/p/4463639.html</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android 编译问题 locale</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%20locale/</url>
    <content><![CDATA[<p>#locale</p>
<p>export LC_ALL=C</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android 获取屏幕的方向</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%20%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E7%9A%84%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p>Configuration newConfig = getResources().getConfiguration();  </p>
<p>        if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE){  </p>
<p>            //横屏  </p>
<p>        }else if(newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){  </p>
<p>            //竖屏  </p>
<p>        }else if(newConfig.hardKeyboardHidden == Configuration.KEYBOARDHIDDEN_NO){  </p>
<p>            //键盘没关闭。屏幕方向为横屏  </p>
<p>        }else if(newConfig.hardKeyboardHidden == Configuration.KEYBOARDHIDDEN_YES){  </p>
<p>            //键盘关闭。屏幕方向为竖屏  </p>
<p>        }  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android4.0%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84sharedPreferences%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>修改第三方的国笔输入法的手写默认显示方式，原先是全屏模式，我要改为非全屏模式。</p>
<p>首先把国笔输入法生成的sharedPreferences文件拷贝出来，查看显示全屏与非全屏的关键字。</p>
<p>但是2.3系统使用</p>
<p> try {<br>otherAppsContext=createPackageContext(&quot;com.guobi.gbime&quot;, CONTEXT_IGNORE_SECURITY );<br>} catch (NameNotFoundException e) {<br>// TODO Auto-generated catch block<br>Log.i(&quot;guobi&quot;, e.getMessage());<br>}<br>        SharedPreferences sharedPreferences = otherAppsContext.getSharedPreferences(&quot;com.guobi.gbime_preferences&quot;, Context.MODE_WORLD_READABLE);</p>
<p>String name2 = sharedPreferences.getString(&quot;HandwriteFrameType&quot;, &quot;&quot;);是可以获取到数据，而4.0就不行，打印的是空。</p>
<p>最终发现主要是权限问题。</p>
<p>国笔输入法生成的sharedPreferences文件是rw- rw- —,，所以我们必须改变它的权限进行操作,其实目录也要改权限，都改为777。我在launcher的oncreate()方法中加入以下代码</p>
<p>//修改国笔输入法的显示模式，把全屏改为非全屏模式</p>
<p>       xmlFile = new File(&quot;/data/data/com.guobi.gbime/shared_prefs/com.guobi.gbime_preferences.xml&quot;);</p>
<p>       if(xmlFile.exists())</p>
<p>       {</p>
<p>       try {</p>
<p>               Runtime.getRuntime().exec(new String[]{&quot;su&quot;,&quot;-c&quot;,&quot;chmod  777 /data/data/com.guobi.gbime/shared_prefs/com.guobi.gbime_preferences.xml&quot;});</p>
<p>               Log.i(&quot;guobi&quot;, &quot;chmod 777&quot;);</p>
<p>               Runtime.getRuntime().exec(new String[]{&quot;su&quot;,&quot;-c&quot;,&quot;rm /data/data/com.guobi.gbime/shared_prefs/com.guobi.gbime_preferences.xml&quot;});</p>
<p>                Log.i(&quot;guobi&quot;, &quot; rm&quot;);</p>
<p>               Runtime.getRuntime().exec(new String[]{&quot;su&quot;,&quot;-c&quot;,&quot;touch /data/data/com.guobi.gbime/shared_prefs/com.guobi.gbime_preferences.xml&quot;});</p>
<p>                Log.i(&quot;guobi&quot;, &quot; touch&quot;);</p>
<p>               Runtime.getRuntime().exec(new String[]{&quot;su&quot;,&quot;-c&quot;,&quot;chmod  777 /data/data/com.guobi.gbime/shared_prefs/com.guobi.gbime_preferences.xml&quot;});</p>
<p>                Log.i(&quot;guobi&quot;, &quot; chomd&quot;);</p>
<p>       } catch (IOException e) {</p>
<p>              // TODO Auto-generated catch block</p>
<p>               e.printStackTrace();</p>
<p>        }</p>
<p>}</p>
<p>        else </p>
<p>        {</p>
<p>               if(!xmlFile.getParentFile().exists())</p>
<p>               {</p>
<p>                try {</p>
<p>                       Runtime.getRuntime().exec(new String[]{&quot;su&quot;,&quot;-c&quot;,&quot;mkdir /data/data/com.guobi.gbime/shared_prefs&quot;});</p>
<p>               Log.i(&quot;guobi&quot;, &quot;mkdir&quot;);</p>
<p>Runtime.getRuntime().exec(new String[]{&quot;su&quot;,&quot;-c&quot;,&quot;chmod  777 /data/data/com.guobi.gbime/shared_prefs&quot;});</p>
<p>                Log.i(&quot;guobi&quot;, &quot; chomd&quot;);</p>
<p>              } catch (IOException e) {</p>
<p>                       // TODO Auto-generated catch block</p>
<p>                     e.printStackTrace();</p>
<p>               }</p>
<p>                }</p>
<p>      try {</p>
<p>               Runtime.getRuntime().exec(new String[]{&quot;su&quot;,&quot;-c&quot;,&quot;touch /data/data/com.guobi.gbime/shared_prefs/com.guobi.gbime_preferences.xml&quot;});</p>
<p>               Log.i(&quot;guobi&quot;, &quot;touch&quot;);</p>
<p>              Log.i(&quot;guobi&quot;, &quot;chmod  777&quot;);</p>
<p>              Runtime.getRuntime().exec(new String[]{&quot;su&quot;,&quot;-c&quot;,&quot;chmod  777 /data/data/com.guobi.gbime/shared_prefs/com.guobi.gbime_preferences.xml&quot;});</p>
<p>       } catch (IOException e) {</p>
<p>               // TODO Auto-generated catch block</p>
<p>               e.printStackTrace();</p>
<p>       }</p>
<p>       }</p>
<p>      try {</p>
<p>               otherAppsContext=mContext.createPackageContext(&quot;com.guobi.gbime&quot;,mContext. CONTEXT_IGNORE_SECURITY );</p>
<p>       } catch (NameNotFoundException e) {</p>
<p>               // TODO Auto-generated catch block</p>
<p>              Log.i(&quot;guobi&quot;, e.getMessage());</p>
<p>       }</p>
<p>       SharedPreferences sharedPreferences = otherAppsContext.getSharedPreferences(&quot;com.guobi.gbime_preferences&quot;, Context.MODE_WORLD_READABLE);</p>
<p>       {</p>
<p>        SharedPreferences.Editor guobieditor=sharedPreferences.edit();</p>
<p>           guobieditor.putString(&quot;HandwriteLang&quot;, &quot;china&quot;);</p>
<p>          guobieditor.putString(&quot;HandwriteFrameType&quot;, &quot;box&quot;);</p>
<p>          guobieditor.putString(&quot;IMType&quot;, &quot;pinyin&quot;);</p>
<p>          guobieditor.putString(&quot;KeyboardType&quot;, &quot;26&quot;);</p>
<p>          guobieditor.putString(&quot;HandwriteStrokeMask&quot;, &quot;normal&quot;);</p>
<p>          guobieditor.putString(&quot;SkinType&quot;, &quot;default&quot;);</p>
<p>          guobieditor.commit();</p>
<p>          String name2 = sharedPreferences.getString(&quot;HandwriteFrameType&quot;, &quot;&quot;);</p>
<p>           Log.i(&quot;guobi&quot;, &quot;HandwriteFrameType–&quot;+name2);</p>
<p>       }</p>
<p>不要高兴太早，这只是成功了一半，你如果加在launcher中，会发现，每次设置为全屏模式后，要重启两次才能变成非全屏，后了我发现了，原来这是默认的输入法，他每次都是在launcher启动完之前就启动了，所以我们需要放在Launcher应用启动之前去把数据写进去才能成功。这就要考验我们对android的启动流程有所了解。</p>
<p>android4.0/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java中有个方法叫startHomeActivityLocked()，这个方法是条用启动launcher的方法，我们在最前面加入上面的代码，launcher中的不需要。OK大功告成。每次启动都是默认为非全屏模式。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android4.0%E8%B0%83%E6%95%B4launcher%E5%BA%94%E7%94%A8%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>//lancher</p>
<p>— a/packages/apps/Launcher2/res/values-land/config.xml</p>
<p>+++ b/packages/apps/Launcher2/res/values-land/config.xml</p>
<p>@@ -19,7 +19,7 @@</p>
<p>     &lt;!– Whether or not the drop targets drop down as opposed to fade in –&gt;</p>
<p>     &lt;bool name=&quot;config_useDropTargetDownTransition&quot;&gt;false&lt;/bool&gt;</p>
<p>     &lt;!– Whether or not to fade the side pages –&gt;</p>
<ul>
<li>   &lt;bool name=&quot;config_workspaceFadeAdjacentScreens&quot;&gt;false&lt;/bool&gt;</li>
</ul>
<ul>
<li>   &lt;bool name=&quot;config_workspaceFadeAdjacentScreens&quot;&gt;true&lt;/bool&gt;</li>
</ul>
<p>— a/packages/apps/Launcher2/res/values-land/dimens.xml</p>
<p>+++ b/packages/apps/Launcher2/res/values-land/dimens.xml</p>
<p>@@ -52,7 +52,7 @@</p>
<p>     &lt;dimen name=&quot;button_bar_height_plus_padding&quot;&gt;76dp&lt;/dimen&gt;</p>
<p> &lt;!– AppsCustomize –&gt;</p>
<ul>
<li>   &lt;dimen name=&quot;apps_customize_cell_width&quot;&gt;80dp&lt;/dimen&gt;</li>
</ul>
<ul>
<li>   &lt;dimen name=&quot;apps_customize_cell_width&quot;&gt;115dp&lt;/dimen</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android4.2%20%E6%9C%80%E8%BF%91%E5%BA%94%E7%94%A8%20%E9%94%81%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>buid.prop定义ro.bx.showrecent=true 即可显示最近0-5个最近应用于锁界面。</p>
<p>diff –git a/frameworks/base/core/java/com/android/internal/widget/multiwaveview/GlowPadView.java b/frameworks/base/core/java/com/android/internal/widget/multiwaveview/GlowP</p>
<p>index 94dea2e..aa53ea1 100644</p>
<p>— a/frameworks/base/core/java/com/android/internal/widget/multiwaveview/GlowPadView.java</p>
<p>+++ b/frameworks/base/core/java/com/android/internal/widget/multiwaveview/GlowPadView.java</p>
<p>@@ -44,8 +44,12 @@ import android.view.View;</p>
<p> import android.view.accessibility.AccessibilityManager;</p>
<p> import com.android.internal.R;</p>
<p>-</p>
<p>+import android.content.Intent;</p>
<p> import java.util.ArrayList;</p>
<p>+import java.util.List;</p>
<p>+import android.app.ActivityManager;</p>
<p>+import android.content.pm.PackageManager;</p>
<p>+import android.os.SystemProperties;</p>
<p> /**</p>
<p>  * A re-usable widget containing a center, outer ring and wave animation.</p>
<p>@@ -579,9 +583,41 @@ public class GlowPadView extends View {</p>
<p>             drawables.add(target);</p>
<p>         }</p>
<p>         array.recycle();</p>
<p>+</p>
<p>+</p>
<ul>
<li>if(SystemProperties.get(&quot;ro.bx.showrecent&quot;, &quot;false&quot;).equals(&quot;true&quot;)) {</li>
</ul>
<p>+</p>
<ul>
<li>final ActivityManager am = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);</li>
</ul>
<p>+</p>
<ul>
<li>final PackageManager pm = getContext().getPackageManager();</li>
</ul>
<p>+</p>
<ul>
<li>List&lt;ActivityManager.RecentTaskInfo&gt; recentLs = am.getRecentTasks(6, ActivityManager.RECENT_IGNORE_UNAVAILABLE);</li>
</ul>
<p>+</p>
<ul>
<li>for(int i=0;i&lt;recentLs.size();i++)</li>
</ul>
<p>+</p>
<ul>
<li><p>{</p>
</li>
<li><p>try</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>{</p>
</li>
<li><p>if(recentLs.get(i).baseIntent.getComponent().getPackageName().equals(&quot;com.android.launcher&quot;)) continue;</p>
</li>
</ul>
<p>+</p>
<ul>
<li>drawables.add(new TargetDrawable(pm.getActivityIcon(recentLs.get(i).baseIntent),recentLs.get(i).baseIntent));</li>
</ul>
<p>+</p>
<ul>
<li>}</li>
</ul>
<p>+</p>
<ul>
<li><p>catch(Exception e)</p>
</li>
<li><p>{</p>
</li>
<li><p>Log.v(TAG,&quot;Catch Exception&quot;);</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p>         return drawables;</p>
<p>     }</p>
<p>+</p>
<p>+</p>
<p>+</p>
<p>     private void internalSetTargetResources(int resourceId) {</p>
<p>         final ArrayList&lt;TargetDrawable&gt; targets = loadDrawableArray(resourceId);</p>
<p>         mTargetDrawables = targets;</p>
<p>@@ -1284,6 +1320,11 @@ public class GlowPadView extends View {</p>
<p>         final TargetDrawable drawable = mTargetDrawables.get(index);</p>
<p>         return drawable == null ? 0 : drawable.getResourceId();</p>
<p>     }</p>
<p>+</p>
<ul>
<li><p>public Intent getResourceIntentForTarget(int index) {</p>
</li>
<li><p>final TargetDrawable drawable = mTargetDrawables.get(index);</p>
</li>
<li><p>return drawable == null ? null : drawable.getResourceIntent();</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>     public void setEnableTarget(int resourceId, boolean enabled) {</p>
<p>         for (int i = 0; i &lt; mTargetDrawables.size(); i++) {</p>
<p>diff –git a/frameworks/base/core/java/com/android/internal/widget/multiwaveview/TargetDrawable.java b/frameworks/base/core/java/com/android/internal/widget/multiwaveview/Ta</p>
<p>index 30f5f2f..9d70000 100644</p>
<p>— a/frameworks/base/core/java/com/android/internal/widget/multiwaveview/TargetDrawable.java</p>
<p>+++ b/frameworks/base/core/java/com/android/internal/widget/multiwaveview/TargetDrawable.java</p>
<p>@@ -22,6 +22,7 @@ import android.graphics.ColorFilter;</p>
<p> import android.graphics.drawable.Drawable;</p>
<p> import android.graphics.drawable.StateListDrawable;</p>
<p> import android.util.Log;</p>
<p>+import android.content.Intent;</p>
<p> public class TargetDrawable {</p>
<p>     private static final String TAG = &quot;TargetDrawable&quot;;</p>
<p>@@ -45,6 +46,7 @@ public class TargetDrawable {</p>
<p>     private Drawable mDrawable;</p>
<p>     private boolean mEnabled = true;</p>
<p>     private final int mResourceId;</p>
<ul>
<li>private Intent mResourceIntent = null;</li>
</ul>
<p>     /* package */ static class DrawableWithAlpha extends Drawable {</p>
<p>         private float mAlpha = 1.0f;</p>
<p>@@ -81,6 +83,14 @@ public class TargetDrawable {</p>
<p>         setDrawable(res, resId);</p>
<p>     }</p>
<ul>
<li><p>public TargetDrawable(Drawable drawable, Intent intent) {</p>
</li>
<li><p>mResourceId = 0;//not use in the mode</p>
</li>
<li><p>mResourceIntent = intent ;</p>
</li>
<li><p>mDrawable = drawable ;</p>
</li>
<li><p>resizeDrawables();</p>
</li>
<li><p>setState(STATE_INACTIVE);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p>     public void setDrawable(Resources res, int resId) {</p>
<p>         // Note we explicitly don’t set mResourceId to resId since we allow the drawable to be</p>
<p>         // swapped at runtime and want to re-use the existing resource id for identification.</p>
<p>@@ -257,4 +267,7 @@ public class TargetDrawable {</p>
<p>     public int getResourceId() {</p>
<p>         return mResourceId;</p>
<p>     }</p>
<ul>
<li><p>public Intent getResourceIntent() {</p>
</li>
<li><p>return mResourceIntent;</p>
</li>
<li><p>}</p>
</li>
</ul>
<p> }</p>
<p>diff –git a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSelectorView.java b/frameworks/base/policy/src/com/android/internal/policy/impl/key</p>
<p>index 76cbbd5..333acbb 100644</p>
<p>— a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSelectorView.java</p>
<p>+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSelectorView.java</p>
<p>@@ -52,11 +52,15 @@ public class KeyguardSelectorView extends LinearLayout implements KeyguardSecuri</p>
<p>     private LockPatternUtils mLockPatternUtils;</p>
<p>     private SecurityMessageDisplay mSecurityMessageDisplay;</p>
<p>     private Drawable mBouncerFrame;</p>
<ul>
<li>private Intent myIntent;</li>
</ul>
<p>     OnTriggerListener mOnTriggerListener = new OnTriggerListener() {</p>
<p>         public void onTrigger(View v, int target) {</p>
<ul>
<li>final int resId = mGlowPadView.getResourceIdForTarget(target);</li>
</ul>
<ul>
<li>final int resId = mGlowPadView.getResourceIdForTarget(target);</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li>Log.d(&quot;edward&quot;,&quot;tagetid:=&quot;+target);</li>
</ul>
<p>             switch (resId) {</p>
<p>                 case com.android.internal.R.drawable.ic_action_assist_generic:</p>
<p>                     Intent assistIntent =</p>
<p>@@ -80,6 +84,17 @@ public class KeyguardSelectorView extends LinearLayout implements KeyguardSecuri</p>
<p>                     mCallback.userActivity(0);</p>
<p>                     mCallback.dismiss(false);</p>
<p>                 break;</p>
<p>+</p>
<ul>
<li><p>case 0:</p>
</li>
<li><p>myIntent = mGlowPadView.getResourceIntentForTarget(target);</p>
</li>
<li><p>if(myIntent != null){</p>
</li>
<li><p>mContext.startActivity(myIntent);</p>
</li>
<li><p>mCallback.userActivity(0);</p>
</li>
<li><p>mCallback.dismiss(false);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<ul>
<li>break;</li>
</ul>
<p>+</p>
<p>             }</p>
<p>         }</p>
<p>(END)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android亮度调节</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82/</url>
    <content><![CDATA[<p>int brightness = Settings.System.getInt(getContext().getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, 100);</p>
<p>brightness++;</p>
<p>if(brightness&gt;255)</p>
<p>brightness–;</p>
<p>IPowerManager mPower;</p>
<p>mPower = IPowerManager.Stub.asInterface(ServiceManager.getService(&quot;power&quot;));</p>
<p>try {</p>
<p>            mPower.setBacklightBrightness(brightness);</p>
<p>        } catch (RemoteException ex) {</p>
<p>        } </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android调试工具</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<ol>
<li>dmesg 内核信息</li>
</ol>
<p>adb shell dmesg</p>
<p>2.netstat / netcfg  网络信息</p>
<ol start="3">
<li>am </li>
</ol>
<p>adb shell am start -n packagename/.name </p>
<p>…</p>
<p>4.dumpsys 信息</p>
<p>可以观察activity、package、alarm等信息</p>
<p>dumpsys activity </p>
<p>dumpsys activity broadcasts</p>
<p>dumpsys activity services</p>
<p>dumpsys package/meminfo/alarm/power/window/SurfaceFlinger/batteryinfo 等</p>
<p>dumpsys /data/anr/traces.txt </p>
<p>5.pm</p>
<p>pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [FILTER]</p>
<p>pm list permission-groups</p>
<p>pm list permissions [-g] [-f] [-d] [-u] [GROUP]</p>
<p>pm list instrumentation [-f] [TARGET-PACKAGE]</p>
<p>pm list features</p>
<p>pm list libraries</p>
<p>pm path PACKAGE</p>
<p>pm install [-l] [-r] [-t] [-i INSTALLER_PACKAGE_NAME] [-s] [-f]</p>
<p>           [–algo &lt;algorithm name&gt; –key &lt;key-in-hex&gt; –iv &lt;IV-in-hex&gt;] PATH</p>
<p>pm uninstall [-k] PACKAGE</p>
<p>pm clear PACKAGE</p>
<p>pm enable PACKAGE_OR_COMPONENT</p>
<p>pm disable PACKAGE_OR_COMPONENT</p>
<p>pm disable-user PACKAGE_OR_COMPONENT</p>
<p>pm grant PACKAGE PERMISSION</p>
<p>pm revoke PACKAGE PERMISSION</p>
<p>pm set-install-location [0/auto] [1/internal] [2/external]</p>
<p>pm get-install-location</p>
<p>pm set-permission-enforced PERMISSION [true|false]</p>
<ol start="6">
<li>adb shell getprop</li>
</ol>
<p>setprop &lt;key&gt; &lt;value&gt;</p>
<p>watchprops</p>
<ol start="5">
<li>getevent/sendevent</li>
</ol>
<p>sendevent [device] [type] [code] [value]</p>
<p>6 .</p>
<p>fd</p>
<p>mount</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>apk 反编译工具</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/apk%20%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>android-apktool ：解压 </p>
<p><a href="http://code.google.com/p/android-apktool/">http://code.google.com/p/android-apktool/</a></p>
<p><a href="http://ibotpeaches.github.io/Apktool/">http://ibotpeaches.github.io/Apktool/</a></p>
<p>apktool.jar 放在C:\Windows 或指定的地方</p>
<p>然后可以在apktool的目录，执行apktool的命令</p>
<p>decode</p>
<p>apktool d xxx.apk</p>
<p>rebuild</p>
<p>apktool b files_path xxx.apk</p>
<p>用系统签名：</p>
<p>java -jar signapk.jar -w platform.x509.pem platform.pk8 note.apk note_signed.apk</p>
<p><a href="https://sourceforge.net/projects/dex2jar/">https://sourceforge.net/projects/dex2jar/</a></p>
<p>You must pull HTC resources from your device and install them:</p>
<p>$ apktool if com.htc.resources.apk<br>I: Framework installed to: /home/brutall/apktool/framework/2.apk</p>
<p>You could tag frameworks by:</p>
<p>$ apktool if com.htc.resources.apk hero<br>I: Framework installed to: /home/brutall/apktool/framework/2-hero.apk<br>$ apktool if com.htc.resources.apk desire<br>I: Framework installed to: /home/brutall/apktool/framework/2-desire.apk</p>
<p>dex2jar   ： dex 转为 jar </p>
<p><a href="http://code.google.com/p/dex2jar/">http://code.google.com/p/dex2jar/</a></p>
<p>dex2jar file1.dexORapk file2.dexORapk …</p>
<p>JD-GUI</p>
<p><a href="http://jd.benow.ca/">http://jd.benow.ca/</a></p>
<p>smali/baksmali is an assembler/disassembler for the dex format used<br>by dalvik, Android’s Java VM implementation. </p>
<p><a href="http://code.google.com/p/smali/">http://code.google.com/p/smali/</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>apk包名，类名，Launcher, app列表不显示 隐藏apk</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/apk%E5%8C%85%E5%90%8D%EF%BC%8C%E7%B1%BB%E5%90%8D%EF%BC%8CLauncher,%20app%E5%88%97%E8%A1%A8%E4%B8%8D%E6%98%BE%E7%A4%BA%20%E9%9A%90%E8%97%8Fapk/</url>
    <content><![CDATA[<p>packages/apps/Launcher2/src/com/android/launcher2/LauncherModel.java</p>
<p>final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</p>
<p>                startIndex = i;</p>
<p>                for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {</p>
<p>                    // This builds the icon bitmaps.</p>
<p>        //       Log.d(&quot;TAGG&quot;,&quot;packagesname:=&quot;+apps.get(i).activityInfo.packageName);</p>
<p>        //      Log.d(&quot;TAGG&quot;,&quot;classname:=&quot;+apps.get(i).activityInfo.name);</p>
<p>                    if(&quot;com.adobe.flashplayer&quot;.equals(apps.get(i).activityInfo.packageName)){</p>
<p>                //      &quot;com.android.gallery3d.app.Gallery&quot;.equals(apps.get(i).activityInfo.name)){</p>
<p>                                i++;</p>
<p>                                continue ;}</p>
<p>                    mAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),</p>
<p>                            mIconCache, mLabelCache));</p>
<p>                    i++;</p>
<p>packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java</p>
<p>  public void add(ApplicationInfo info) {</p>
<p>        if (findActivity(data, info.componentName)) {</p>
<p>            return;       }</p>
<p> //return 后就不会再显示到app列表 了</p>
<p>       if(&quot;com.bx.test&quot;.equals(info.componentName.getPackageName())</p>
<p>        {</p>
<p>               return;</p>
<p>        }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>apk安装timeout时间</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/apk%E5%AE%89%E8%A3%85timeout%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p> — a/frameworks/base/services/java/com/android/server/NativeDaemonConnector.java<br>+++ b/frameworks/base/services/java/com/android/server/NativeDaemonConnector.java<br>@@ -61,7 +61,7 @@ final class NativeDaemonConnector implements Runnable, Handler.Callback, Watchdo<br>     private AtomicInteger mSequenceNumber;<br>-    private static final int DEFAULT_TIMEOUT = 1 * 60 * 1000; /* 1 minute <em>/<br>+    private static final int DEFAULT_TIMEOUT = 2 * 60 * 1000; /</em> 1 minute <em>/<br>     private static final long WARN_EXECUTE_DELAY_MS = 500; /</em> .5 sec */   </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>at_test</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/at_test/</url>
    <content><![CDATA[<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/stat.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys/poll.h&gt;</p>
<p>#include &lt;sys/ioctl.h&gt;</p>
<p>#include &lt;termios.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;assert.h&gt;</p>
<p>#define DEBUG_SINCE</p>
<p>#ifdef DEBUG_SINCE</p>
<p>#define PRINTF(format, args…) printf(&quot;%s %d %s() &quot; format, <strong>FILE</strong>, <strong>LINE</strong>, <strong>func</strong>, ## args)</p>
<p>#else</p>
<p>#define PRINTF(format, args…) do{}while(0)</p>
<p>#endif</p>
<p>typedef unsigned int CSMI_PORT;</p>
<p>//#define AT_O8K_UART_DEVICE_NAME &quot;/dev/ttyS0&quot;</p>
<p>//#define AT_O8K_UART_DEVICE_NAME &quot;/dev/s3c2410_serial1&quot;</p>
<p>#define AT_O8K_UART_DEVICE_NAME &quot;/dev/ttyUSB0&quot;</p>
<p>#define BUF_LEN 2048*2</p>
<p>static char buf[BUF_LEN];</p>
<p>static char buf_1[BUF_LEN];</p>
<p>static char buf_5[BUF_LEN];</p>
<p>static char buf_6[BUF_LEN];</p>
<p>static int fd1 = -1;</p>
<p>static int fd5 = -1;</p>
<p>static int fd6 = -1; </p>
<p>static at_open_dev(char *dev_name)</p>
<p>{</p>
<p>    int fd = -1;</p>
<p>    struct termios newtio; </p>
<p>    fd = open(dev_name, O_RDWR | O_NOCTTY | O_NONBLOCK);</p>
<p>    if (fd &lt; 0)</p>
<p>    {</p>
<p>        return fd;</p>
<p>    }</p>
<p>    bzero(&amp;newtio, sizeof(struct termios));     /* clear struct for new port settings */</p>
<p>    tcgetattr(fd, &amp;newtio);</p>
<p>    /* step 1 : control mode flags */</p>
<p>    // No parity (8N1): 8bit word length, no parity, 1bit stop bit</p>
<p>    newtio.c_cflag = 0;         /* This is neccessary */</p>
<p>    newtio.c_cflag &amp;= ~CSIZE;     </p>
<p>    newtio.c_cflag |= CS8;        /* uart word length : 8bit */</p>
<p>    newtio.c_cflag &amp;= ~CSTOPB;      /* stop bit : 1 bit */</p>
<p>    newtio.c_cflag &amp;= ~PARENB;      /* no parity */</p>
<p>    // 115200 baudrate : </p>
<p>    newtio.c_cflag |= B115200;      /* 115200 baud rate */</p>
<p>    newtio.c_cflag |= CREAD;      /* care all characters =&gt; ignore all characters if CREAD is not set */</p>
<p>    // omap3530: enable or disable flow control both are ok</p>
<p>    /* If non-blocking mode is set, or CLOCAL mode is set,</p>
<p>     * we don’t want to wait for the modem status lines to</p>
<p>     * indicate that the port is ready.</p>
<p>     */</p>
<p>#if 1 /* 2010-07-08 : Always enable this,but need to disable this if hardware flow control is not enabled  */</p>
<p>    // special set when one uart is used as a modem connector : </p>
<p>    printf(&quot;Hardware flow control enabled\n&quot;);</p>
<p>    newtio.c_cflag &amp;= ~CLOCAL;    /* 不忽略MODEM控制线 */</p>
<p>    newtio.c_cflag |= HUPCL;      /* 在最后一个进程关闭设备后，降低MODEM控制线(挂断) */</p>
<p>    newtio.c_cflag |= CRTSCTS;    /* enable hardware flow control when the uart is used as a modem connector */ </p>
<p>#else</p>
<p>    printf(&quot;Hardware flow control disabled\n&quot;);</p>
<p>#endif</p>
<p>    /* step 2 : input mode flags */</p>
<p>    newtio.c_iflag &amp;= ~IGNPAR;      /* ignore Parity error and Frame error */ </p>
<p>    newtio.c_iflag &amp;= ~IGNBRK;      /* ignore Break interrupt */</p>
<p>    newtio.c_iflag &amp;= ~IGNPAR;      /* ignore overrun error */</p>
<p>    /* step 3 : output mode flags */</p>
<p>    newtio.c_oflag &amp;= ~OPOST;         /* raw output : 不要对输出做任何预处理 */ </p>
<p>    /* step 4 : local mode flags */</p>
<p>    newtio.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  /* raw input */ </p>
<p>    /* step 5 : line discipline */</p>
<p>    newtio.c_line = 0;          /* use line dicipline 0 */</p>
<p>#if 0</p>
<p>/* step 6 : control characters <em>/     /</em> set control chars */</p>
<p>newtio.c_cc[VINTR] = 3;   /* C-c */</p>
<p>newtio.c_cc[VQUIT] = 28;  /* C-\ */</p>
<p>newtio.c_cc[VERASE] = 127;  /* C-? */</p>
<p>newtio.c_cc[VKILL] = 21;  /* C-u */</p>
<p>newtio.c_cc[VEOF] = 4;    /* C-d */</p>
<p>newtio.c_cc[VSTART] = 17; /* C-q */</p>
<p>newtio.c_cc[VSTOP] = 19;  /* C-s */</p>
<p>newtio.c_cc[VSUSP] = 26;  /* C-z */ </p>
<p>#endif  </p>
<p>    tcflush(fd, TCIFLUSH);        /* clear input buffer */</p>
<p>    tcsetattr(fd, TCSANOW, &amp;newtio);</p>
<p>    return fd;</p>
<p>}</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>    int len;</p>
<p>    int iRet = 0;</p>
<p>    int i;</p>
<p>    char AtBuf[BUF_LEN];</p>
<p>    struct termios newtio;  </p>
<p>    assert(2 == argc);</p>
<p>    //<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></p>
<p>    //* Open and configure channel 5</p>
<p>    //fd5 = at_open_dev(AT_O8K_UART_DEVICE_NAME);</p>
<p>    fd5 = at_open_dev(argv[1]);</p>
<p>    if(fd5&gt;0)</p>
<p>    {</p>
<p>        //printf(&quot;Open %s success\n&quot;, AT_O8K_UART_DEVICE_NAME);</p>
<p>        printf(&quot;Open %s success\n&quot;, argv[1]);</p>
<p>    }</p>
<p>    while (1)</p>
<p>    {</p>
<p>        memset(AtBuf, 0, BUF_LEN);</p>
<p>        memset(buf, 0, BUF_LEN);</p>
<p>        memset(buf_1, 0, BUF_LEN);</p>
<p>        memset(buf_5, 0, BUF_LEN);</p>
<p>        memset(buf_6, 0, BUF_LEN);</p>
<p>        len = 0;    </p>
<p>        struct pollfd read_poll[2];</p>
<p>        read_poll[0].fd = fd5;      /* fd5 */</p>
<p>        read_poll[0].events = POLLIN;</p>
<p>        read_poll[0].revents = 0;</p>
<p>        read_poll[1].fd = 0;      /* 0 */</p>
<p>        read_poll[1].events = POLLIN;</p>
<p>        read_poll[1].revents = 0;</p>
<p>        //sleep(2);</p>
<p>        iRet = poll(read_poll, 4, -1);       </p>
<p>        if (read_poll[0].revents &amp; POLLIN)        /* port 5 */</p>
<p>        {</p>
<p>            len = read(fd5, buf_5, BUF_LEN - 10);</p>
<p>            if (len &lt;= 0)</p>
<p>            {</p>
<p>                printf(&quot;read nothing \n&quot;);</p>
<p>                continue;</p>
<p>            }</p>
<p>            buf_5[len] = 0;</p>
<p>            for (i = 0; i &lt; len; i++)</p>
<p>                printf(&quot;%02x &quot;, buf_5[i]);</p>
<p>            printf(&quot;\nThe read buf is: %s \n&quot;, buf_5);</p>
<p>        }</p>
<p>        if (read_poll[1].revents &amp; POLLIN)        /* standard input */</p>
<p>        {</p>
<p>            len = 0;</p>
<p>            len = read(0, AtBuf, BUF_LEN - 10);</p>
<p>            //*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>            //  Because the standart input(tty) will add a &quot;\n&quot; after reading.So we must cut it.</p>
<p>            //  while scanf() will not add a &quot;\n&quot; after reading.</p>
<p>            AtBuf[–len] = 0;         </p>
<p>            if (len)</p>
<p>            {             </p>
<p>                sprintf(AtBuf, &quot;%s\r&quot;, AtBuf);</p>
<p>                len = strlen(AtBuf);</p>
<p>                if (strncmp(AtBuf, &quot;kke&quot;, 3) == 0)</p>
<p>                    goto kk_exit;</p>
<p>                usleep(100 * 1000);</p>
<p>                len = write(fd5, AtBuf, len);   </p>
<p>                memset(AtBuf, 0, BUF_LEN);  </p>
<p>                printf(&quot;\n&quot;);</p>
<p>                len = 0;</p>
<p>            }</p>
<p>        }</p>
<p>}</p>
<p>    kk_exit : close(fd1);</p>
<p>    close(fd5);</p>
<p>    close(fd6);   </p>
<p>    return 0;</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>axp调试节点</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/axp%E8%B0%83%E8%AF%95%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>/sys/class/axppower</p>
<p>axpdebug</p>
<p>axpreg</p>
<p>axpregs</p>
<p>echo 0x9002 &gt; axpreg  //往90H 写0x02</p>
<p>echo 0x90 &gt; axpreg </p>
<p>cat axpreg 读</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>bat 修改文件名 时间戳</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/bat%20%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D%20%E6%97%B6%E9%97%B4%E6%88%B3/</url>
    <content><![CDATA[<p>ren update.img &quot;%date:<del>0,2%%date:</del>5,2%%date:<del>8,2%_%time:</del>0,2%%time:<del>3,2%%time:</del>6,2%.img&quot;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>batarry</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/batarry/</url>
    <content><![CDATA[<p>每分钟记录一次电压</p>
<p>#!/system/bin/sh</p>
<p>j=1</p>
<p>k=2</p>
<p>echo &quot; Battery Test V1.0 by Edward !&quot;</p>
<p>rm  /mnt/sdcard/batarray.txt</p>
<p>while [ $j -lt $k ];</p>
<p>do</p>
<p>cat /sys/class/power_supply/battery/voltage_now </p>
<p>cat /sys/class/power_supply/battery/voltage_now &gt;&gt; /mnt/sdcard/batarray.txt</p>
<p>#echo &quot;,&quot; &gt;&gt; /mnt/sdcard/batarray.txt</p>
<p>sleep 60</p>
<p>done</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>blob</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/blob.png/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>bmp logo</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/bmp%20logo/</url>
    <content><![CDATA[<p> sudo apt-get install imagemagick</p>
<p>convert -compress rle -colors 256 logo.bmp logo_rle8.bmp</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>bootloader （Little Kernel）</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/bootloader%20%EF%BC%88Little%20Kernel%EF%BC%89/</url>
    <content><![CDATA[<p>LK是什么</p>
<p>LK 是 Little Kernel 它是 appsbl （Applications ARM Boot Loader）流程代码  ，little kernel 是小内核小操作系统。</p>
<p>           LK 代码 在 bootable/bootloadler/lk 目录下</p>
<p>           LK 代码结构</p>
<p>           +app            // 应用相关</p>
<p>           +arch           // arm 体系 </p>
<p>           +dev            // 设备相关</p>
<p>           +include      // 头文件</p>
<p>           +kernel        // lk系统相关   </p>
<p>           +platform    // 相关驱动</p>
<p>           +projiect     // makefile文件</p>
<p>           +scripts      // Jtag 脚本</p>
<p>           +target        // 具体板子相关</p>
<p>LK 流程分析</p>
<p>       在 bootable/bootloadler/lk/arch/arm/ssystem-onesegment.ld 连接文件中 ENTRY（_start）指定 LK 从_start 函数开始，_start 在 lk/arch/crt0.S中 。</p>
<p>crt0.S 主要做一些基本的 CPU 的初始化再通过 bl  kmain ；跳转到 C 代码中。</p>
<p>          kmain 在 lk/kernel/main.c 中</p>
<p>kmain()</p>
<p>         kmain 主要做两件事：1、本身 lk 这个系统模块的初始化；2、boot 的启动初始化动作。</p>
<p>         kmain 源码分析：</p>
<p>   void kmain（）</p>
<p>          {</p>
<p>1.初始化进程（lk 中的简单进程）相关结构体。</p>
<p>             thread_init_early();</p>
<p>2.做一些如 关闭 cache，使能 mmu 的 arm 相关工作。</p>
<p>            arch_early_init();</p>
<p>  3.相关平台的早期初始化</p>
<p>      platform_early_init();</p>
<p> 4.现在就一个函数跳转，初始化UART（板子相关）</p>
<p>            target_early_init();</p>
<p> 5.构造函数相关初始化</p>
<p>            call_constructors();</p>
<p>6.lk系统相关的堆栈初始化</p>
<p>            heap_init();</p>
<p>    7.简短的初始化定时器对象</p>
<p>            thread_init();</p>
<p>8.lk系统控制器初始化（相关事件初始化）</p>
<p>            dpc_init();</p>
<p>9.初始化lk中的定时器</p>
<p>            timer_init();<br>10.新建线程入口函数 bootstrap2 用于boot 工作（重点）<br>           thread_resume(thread_create(&quot;bootstrap2&quot;, &amp;bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE));</p>
<p> }</p>
<p>以上与 boot 启动初始化相关函数是 arch_early_init、  platform_early_init 、bootstrap2，这些是启动的重点，我们下面慢慢来看。</p>
<p>arch_early_init()</p>
<p>体系架构相关的初始化我们一般用的 ARM 体系</p>
<p>1.关闭cache</p>
<p>         arch_disable_cache(UCACHE);</p>
<p>2.设置向量基地址（中断相关）</p>
<p>         set_vector_base(MEMBASE);</p>
<p>3.初始化MMU</p>
<p>         arm_mmu_init();</p>
<p>4.初始化MMU映射__平台相关</p>
<p>         platform_init_mmu_mappings();</p>
<p>5.开启cache         </p>
<p>         arch_enable_cache(UCACHE)</p>
<p>6.使能 cp10 和 cp11</p>
<p>         <strong>asm</strong> volatile(&quot;mrc    p15, 0, %0, c1, c0, 2&quot; : &quot;=r&quot; (val));</p>
<p>         val |= (3&lt;&lt;22)|(3&lt;&lt;20);</p>
<p>         <strong>asm</strong> volatile(&quot;mcr    p15, 0, %0, c1, c0, 2&quot; :: &quot;r&quot; (val));</p>
<p>7.设置使能 fpexc 位 （中断相关）</p>
<p>        <strong>asm</strong> volatile(&quot;mrc  p10, 7, %0, c8, c0, 0&quot; : &quot;=r&quot; (val));</p>
<p>        val |= (1&lt;&lt;30);</p>
<p>        <strong>asm</strong> volatile(&quot;mcr  p10, 7, %0, c8, c0, 0&quot; :: &quot;r&quot; (val));</p>
<p>8.使能循环计数寄存器</p>
<p>        <strong>asm</strong> volatile(&quot;mrc    p15, 0, %0, c9, c12, 0&quot; : &quot;=r&quot; (en));</p>
<p>        en &amp;= ~(1&lt;&lt;3); /<em>循环计算每个周期</em>/</p>
<p>        en |= 1; </p>
<p>        <strong>asm</strong> volatile(&quot;mcr    p15, 0, %0, c9, c12, 0&quot; :: &quot;r&quot; (en));</p>
<p>9.使能循环计数器</p>
<p>       en = (1&lt;&lt;31);<br>       <strong>asm</strong> volatile(&quot;mcr    p15, 0, %0, c9, c12, 1&quot; :: &quot;r&quot; (en));</p>
<p>platform_early_init()</p>
<p>平台相关初始化不同平台不同的初始化下面是msm7x30</p>
<p>1.初始化中断</p>
<p>platform_init_interrupts();</p>
<p>2.初始化定时器</p>
<p>platform_init_timer();</p>
<p>bootstrap2 </p>
<p>bootstrap2 在kmain的末尾以线程方式开启。主要分三步：platform_init、target_init、apps_init。</p>
<p>1.platform_init</p>
<p>platform_init 中主要是函数 acpu_clock_init。</p>
<p>               在 acpu_clock_init 对 arm11 进行系统时钟设置，超频 </p>
<p>2.target_init</p>
<p>              针对硬件平台进行设置。主要对 arm9 和 arm11 的分区表进行整合，初始化flash和读取FLASH信息</p>
<p>3.apps_init  </p>
<p>             apps_init 是关键，对 LK 中所谓 app 初始化并运行起来，而 aboot_init 就将在这里开始被运行，android linux 内核的加载工作就在 aboot_init 中完成的 。</p>
<p>aboot_init</p>
<p>1.设置NAND/ EMMC读取信息页面大小<br>if (target_is_emmc_boot())</p>
<p>        {</p>
<p>                  page_size = 2048;</p>
<p>                  page_mask = page_size - 1;</p>
<p>        }</p>
<p>       else</p>
<p>       {</p>
<p>                 page_size = flash_page_size();</p>
<p>                 page_mask = page_size - 1;</p>
<p>        }</p>
<p>      2.读取按键信息，判断是正常开机，还是进入 fastboot ,还是进入recovery 模式</p>
<p>       。。。。。。。。。</p>
<p>通过一系列的 if (keys_get_state() == XXX) 判断</p>
<p>       。。。。。。。。。</p>
<p>      3.从 nand 中加载 内核</p>
<p>boot_linux_from_flash();</p>
<p>      partition_dump();</p>
<p>      sz = target_get_max_flash_size();</p>
<p>      fastboot_init(target_get_scratch_address(), sz);</p>
<p>      udc_start(); // 开始 USB 协议</p>
<p>boot_linux_from_flash</p>
<p>  主要是内核的加载过程，我们的 boot.img 包含：kernel 头、kernel、ramdisk、second stage（可以没有）。</p>
<p>1.读取boot 头部</p>
<p>           flash_read(p, offset, raw_header, 2048) </p>
<p>           offset += 2048;<br>2.读取 内核    <br>           memcmp(hdr-&gt;magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)<br>           n = (hdr-&gt;kernel_size + (FLASH_PAGE_SIZE - 1)) &amp; (~(FLASH_PAGE_SIZE - 1));</p>
<p>           flash_read(p, offset, (void*) hdr-&gt;kernel_addr, n)</p>
<p>           offset += n;<br>3.读取 ramdisk<br>           n = (hdr-&gt;ramdisk_size + (FLASH_PAGE_SIZE - 1)) &amp; (~(FLASH_PAGE_SIZE - 1));</p>
<p>           flash_read(p, offset, (void*) hdr-&gt;ramdisk_addr, n)</p>
<p>           offset += n;</p>
<p>4.启动内核，</p>
<p>boot_linux()；//在boot_linux 中entry(0,machtype,tags);从kernel加载在内核中的地址开始运行了。</p>
<p>到这里LK的启动过程就结束了。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>cURL-GETPOST</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/cURL-GETPOST/</url>
    <content><![CDATA[<p>Just in case anyone is looking for a a couple of simple functions [to help automate cURL processes for POST and GET queries] I thought I’d post these.<br>&lt;?php<br>/**</p>
<ul>
<li>Send a POST requst using cURL</li>
<li>@param string $url to request</li>
<li>@param array $post values to send</li>
<li>@param array $options for cURL</li>
<li>@return string</li>
<li>/<br>function curl_post($url, array $post = NULL, array $options = array())<br>{<br>$defaults = array(<br>CURLOPT_POST =&gt; 1,<br>CURLOPT_HEADER =&gt; 0,<br>CURLOPT_URL =&gt; $url,<br>CURLOPT_FRESH_CONNECT =&gt; 1,<br>CURLOPT_RETURNTRANSFER =&gt; 1,<br>CURLOPT_FORBID_REUSE =&gt; 1,<br>CURLOPT_TIMEOUT =&gt; 4,<br>CURLOPT_POSTFIELDS =&gt; http_build_query($post)<br>);<br>$ch = curl_init();<br>curl_setopt_array($ch, ($options + $defaults));<br>if( ! $result = curl_exec($ch))<br>{<br>trigger_error(curl_error($ch));<br>}<br>curl_close($ch);<br>return $result;<br>}<br>/**</li>
<li>Send a GET requst using cURL</li>
<li>@param string $url to request</li>
<li>@param array $get values to send</li>
<li>@param array $options for cURL</li>
<li>@return string</li>
<li>/<br>function curl_get($url, array $get = NULL, array $options = array())<br>{<br>$defaults = array(<br>CURLOPT_URL =&gt; $url. (strpos($url, ‘?’) === FALSE ? ‘?’ : ‘’). http_build_query($get),<br>CURLOPT_HEADER =&gt; 0,<br>CURLOPT_RETURNTRANSFER =&gt; TRUE,<br>CURLOPT_TIMEOUT =&gt; 4<br>);<br>$ch = curl_init();<br>curl_setopt_array($ch, ($options + $defaults));<br>if( ! $result = curl_exec($ch))<br>{<br>trigger_error(curl_error($ch));<br>}<br>curl_close($ch);<br>return $result;<br>}<br>?&gt; </li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>camera 去掉全景 4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/camera%20%E5%8E%BB%E6%8E%89%E5%85%A8%E6%99%AF%204.1/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Camera/src/com/android/camera/ModePicker.java b/packages/apps/Camera/src/com/android/camera/ModePicker</p>
<p>index 662a2c1..b060946 100755</p>
<p>— a/packages/apps/Camera/src/com/android/camera/ModePicker.java</p>
<p>+++ b/packages/apps/Camera/src/com/android/camera/ModePicker.java</p>
<p>@@ -43,7 +43,7 @@ public class ModePicker extends RelativeLayout implements View.OnClickListener,</p>
<p>     public static final int MODE_PANORAMA = 2;</p>
<p>     // Total mode number</p>
<ul>
<li>   private static final int MODE_NUM = 3;</li>
</ul>
<ul>
<li>   private static final int MODE_NUM = 2;</li>
</ul>
<p>     /** A callback to be called when the user wants to switch activity. */</p>
<p>     public interface OnModeChangeListener {</p>
<p>@@ -78,13 +78,13 @@ public class ModePicker extends RelativeLayout implements View.OnClickListener,</p>
<p>        /* <a href="mailto:&#122;&#x79;&#99;&#x40;&#x72;&#x6f;&#99;&#x6b;&#x2d;&#99;&#x68;&#x69;&#112;&#x73;&#x2e;&#99;&#111;&#109;">&#122;&#x79;&#99;&#x40;&#x72;&#x6f;&#99;&#x6b;&#x2d;&#99;&#x68;&#x69;&#112;&#x73;&#x2e;&#99;&#111;&#109;</a> : Invalidate MODE_PANORAMA */</p>
<p>        public void setPanaromaIsVisible(boolean visible){</p>
<ul>
<li>              if(visible == false){</li>
</ul>
<ul>
<li>              /*if(visible == false){</li>
</ul>
<p>                        mModeSelectionIcon[MODE_PANORAMA].setVisibility(View.GONE);</p>
<p>                        if (mCurrentModeFrame != null) {</p>
<p>                                mCurrentModeIcon[2].setVisibility(View.GONE);</p>
<p>                        }</p>
<ul>
<li>              }</li>
</ul>
<ul>
<li>              }*/</li>
</ul>
<p>        }</p>
<p>     @Override</p>
<p>@@ -93,8 +93,10 @@ public class ModePicker extends RelativeLayout implements View.OnClickListener,</p>
<p>         mModeSelectionFrame = findViewById(R.id.mode_selection);</p>
<p>         mModeSelectionIcon = new RotateImageView[MODE_NUM];</p>
<ul>
<li><p>       mModeSelectionIcon[MODE_PANORAMA] =</p>
</li>
<li><p>               (RotateImageView) findViewById(R.id.mode_panorama);</p>
</li>
</ul>
<ul>
<li><p>       //mModeSelectionIcon[MODE_PANORAMA] =</p>
</li>
<li><p>        //       (RotateImageView) findViewById(R.id.mode_panorama);</p>
</li>
<li><p>              RotateImageView temp = (RotateImageView) findViewById(R.id.mode_panorama);</p>
</li>
<li><p>              temp.setVisibility(View.GONE);</p>
</li>
</ul>
<p>         mModeSelectionIcon[MODE_VIDEO] =</p>
<p>                 (RotateImageView) findViewById(R.id.mode_video);</p>
<p>         mModeSelectionIcon[MODE_CAMERA] =</p>
<p>:</p>
<p>     // Total mode number</p>
<ul>
<li>   private static final int MODE_NUM = 3;</li>
</ul>
<ul>
<li>   private static final int MODE_NUM = 2;</li>
</ul>
<p>     /** A callback to be called when the user wants to switch activity. */</p>
<p>     public interface OnModeChangeListener {</p>
<p>@@ -78,13 +78,13 @@ public class ModePicker extends RelativeLayout implements View.OnClickListener,</p>
<p>        /* <a href="mailto:&#122;&#121;&#99;&#x40;&#114;&#111;&#x63;&#107;&#45;&#x63;&#104;&#105;&#112;&#x73;&#x2e;&#x63;&#111;&#109;">&#122;&#121;&#99;&#x40;&#114;&#111;&#x63;&#107;&#45;&#x63;&#104;&#105;&#112;&#x73;&#x2e;&#x63;&#111;&#109;</a> : Invalidate MODE_PANORAMA */</p>
<p>        public void setPanaromaIsVisible(boolean visible){</p>
<ul>
<li>              if(visible == false){</li>
</ul>
<ul>
<li>              /*if(visible == false){</li>
</ul>
<p>                        mModeSelectionIcon[MODE_PANORAMA].setVisibility(View.GONE);</p>
<p>                        if (mCurrentModeFrame != null) {</p>
<p>                                mCurrentModeIcon[2].setVisibility(View.GONE);</p>
<p>                        }</p>
<ul>
<li>              }</li>
</ul>
<ul>
<li>              }*/</li>
</ul>
<p>        }</p>
<p>     @Override</p>
<p>@@ -93,8 +93,10 @@ public class ModePicker extends RelativeLayout implements View.OnClickListener,</p>
<p>         mModeSelectionFrame = findViewById(R.id.mode_selection);</p>
<p>         mModeSelectionIcon = new RotateImageView[MODE_NUM];</p>
<ul>
<li><p>       mModeSelectionIcon[MODE_PANORAMA] =</p>
</li>
<li><p>               (RotateImageView) findViewById(R.id.mode_panorama);</p>
</li>
</ul>
<ul>
<li><p>       //mModeSelectionIcon[MODE_PANORAMA] =</p>
</li>
<li><p>        //       (RotateImageView) findViewById(R.id.mode_panorama);</p>
</li>
<li><p>              RotateImageView temp = (RotateImageView) findViewById(R.id.mode_panorama);</p>
</li>
<li><p>              temp.setVisibility(View.GONE);</p>
</li>
</ul>
<p>         mModeSelectionIcon[MODE_VIDEO] =</p>
<p>                 (RotateImageView) findViewById(R.id.mode_video);</p>
<p>         mModeSelectionIcon[MODE_CAMERA] =</p>
<p>@@ -106,7 +108,9 @@ public class ModePicker extends RelativeLayout implements View.OnClickListener,</p>
<p>             mCurrentModeIcon = new RotateImageView[MODE_NUM];</p>
<p>             mCurrentModeIcon[0] = (RotateImageView) findViewById(R.id.mode_0);</p>
<p>             mCurrentModeIcon[1] = (RotateImageView) findViewById(R.id.mode_1);</p>
<ul>
<li>           mCurrentModeIcon[2] = (RotateImageView) findViewById(R.id.mode_2);</li>
</ul>
<ul>
<li><p>          // mCurrentModeIcon[2] = (RotateImageView) findViewById(R.id.mode_2);</p>
</li>
<li><p>                RotateImageView temp2 = (RotateImageView) findViewById(R.id.mode_2);</p>
</li>
<li><p>                temp2.setVisibility(View.GONE);</p>
</li>
</ul>
<p>         } else {</p>
<p>             // current_mode_bar is only for tablet.</p>
<p>             mCurrentModeBar = findViewById(R.id.current_mode_bar);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>camera2 布局</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/camera2%20%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>edward/packages/apps/Camera2$ git diff</p>
<p>diff –git a/res/values/dimens.xml b/res/values/dimens.xml</p>
<p>index e2d4246..6711819 100644</p>
<p>— a/res/values/dimens.xml</p>
<p>+++ b/res/values/dimens.xml</p>
<p>@@ -84,7 +84,7 @@</p>
<p>     &lt;dimen name=&quot;pie_arc_offset&quot;&gt;48dp&lt;/dimen&gt;</p>
<p>     &lt;dimen name=&quot;pie_item_radius&quot;&gt;370dp&lt;/dimen&gt;</p>
<p>     &lt;dimen name=&quot;pie_arc_radius&quot;&gt;214dp&lt;/dimen&gt;</p>
<ul>
<li>   &lt;dimen name=&quot;pie_deadzone_width&quot;&gt;36dp&lt;/dimen&gt;</li>
</ul>
<ul>
<li>   &lt;dimen name=&quot;pie_deadzone_width&quot;&gt;56dp&lt;/dimen&gt;</li>
</ul>
<p>     &lt;dimen name=&quot;pie_anglezone_width&quot;&gt;92dp&lt;/dimen&gt;</p>
<p>     &lt;dimen name=&quot;focus_radius_offset&quot;&gt;8dp&lt;/dimen&gt;</p>
<p>     &lt;dimen name=&quot;focus_inner_offset&quot;&gt;24dp&lt;/dimen&gt;</p>
<p>diff –git a/src/com/android/camera/ui/CameraControls.java b/src/com/android/camera/ui/CameraControls.java</p>
<p>index d211f4e..7087641 100644</p>
<p>— a/src/com/android/camera/ui/CameraControls.java</p>
<p>+++ b/src/com/android/camera/ui/CameraControls.java</p>
<p>@@ -61,7 +61,12 @@ public class CameraControls extends RotatableLayout {</p>
<p>         int orientation = getResources().getConfiguration().orientation;</p>
<p>         int size = getResources().getDimensionPixelSize(R.dimen.camera_controls_size);</p>
<p>         int rotation = getUnifiedRotation();</p>
<ul>
<li>       adjustBackground();</li>
</ul>
<ul>
<li><p>              if(rotation &lt; 180) </p>
</li>
<li><p>                      rotation +=180;</p>
</li>
<li><p>              else</p>
</li>
<li><p>                      rotation -=180;</p>
</li>
<li><p>       </p>
</li>
<li><p>      // adjustBackground();</p>
</li>
</ul>
<p>         // As l,t,r,b are positions relative to parents, we need to convert them</p>
<p>         // to child’s coordinates</p>
<p>         r = r - l;</p>
<p>diff –git a/src/com/android/camera/ui/ModuleSwitcher.java b/src/com/android/camera/ui/ModuleSwitcher.java</p>
<p>index 164c58e..32d8014 100644</p>
<p>— a/src/com/android/camera/ui/ModuleSwitcher.java</p>
<p>+++ b/src/com/android/camera/ui/ModuleSwitcher.java</p>
<p>@@ -313,6 +313,10 @@ public class ModuleSwitcher extends RotateImageView</p>
<p>     private void layoutPopup() {</p>
<p>         int orientation = CameraUtil.getDisplayRotation((Activity) getContext());</p>
<ul>
<li><p>              if(orientation &lt; 180) </p>
</li>
<li><p>                      orientation +=180;</p>
</li>
<li><p>              else</p>
</li>
<li><p>                      orientation -=180;</p>
</li>
</ul>
<p>         int w = mPopup.getMeasuredWidth();</p>
<p>         int h = mPopup.getMeasuredHeight();</p>
<p>         if (orientation == 0) {</p>
<p>diff –git a/tests/Android.mk b/tests/Android.mk</p>
<p>index 9f33322..b67acb5 100644</p>
<p>— a/tests/Android.mk</p>
<p>+++ b/tests/Android.mk</p>
<p>@@ -6,7 +6,7 @@ LOCAL_MODULE_TAGS := tests</p>
<p> LOCAL_SDK_VERSION := 16</p>
<p>-LOCAL_STATIC_JAVA_LIBRARIES := littlemock dexmaker</p>
<p>+#LOCAL_STATIC_JAVA_LIBRARIES := littlemock dexmaker</p>
<p> # Include all test java files.</p>
<p> LOCAL_SRC_FILES := $(call all-java-files-under, src)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>chrome 不显示红框</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/chrome%20%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%BA%A2%E6%A1%86/</url>
    <content><![CDATA[<p>services/java/com/android/server/wm/WindowManagerService.java</p>
<p>@@ -5544,7 +5544,7 @@ public class WindowManagerService extends IWindowManager.Stub</p>
<p>                     mStrictModeFlash = new StrictModeFlash(</p>
<p>                             getDefaultDisplayContentLocked().getDisplay(), mFxSession);</p>
<p>                 }</p>
<ul>
<li>               mStrictModeFlash.setVisibility(on);</li>
</ul>
<ul>
<li>               //mStrictModeFlash.setVisibility(on);</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>const关键字</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/const%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>很多人都认为被const 修饰的值是常量。这是不精确的，精确的说应该是只读的变量，其值在编译时不能被使用，</p>
<p>因为编译器在编译时不知道其存储的内容。或许当初这个关键字应该被替换为readonly</p>
<p>const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。我们看看它与define 宏的区别</p>
<p>(1) 节省空间，避免不必要的内存分配，同时提高效率</p>
<p>编译器通常不为普通const 只读变量分配存储空间，而将它们保存在</p>
<p>符号表中，这使得它成为一个编译期间的值，没有了存储与读内存的操作，使得它的效率也很高。例如：</p>
<p>#define M 3 //宏常量<br>const int N=5; //此时并未将N 放入内存中<br>……<br>int i=N; //此时为N 分配内存，以后不再分配！<br>int I=M; //预编译期间进行宏替换，分配内存<br>int j=N; //没有内存分配<br>int J=M; //再进行宏替换，又一次分配内存！ </p>
<p>const 定义的只读变量从汇编的角度来看，只是给出了对应的内存地址，而</p>
<p>不是象#define一样给出的是立即数，所以，const 定义的只读变量在程序运行过程中只有一份拷贝（因为它是全局的只读变量，存放在静态区），而#define 定义的宏常量在内存中有若干个拷贝。</p>
<p>#define 宏是在预编译阶段进行替换，而const 修饰的只读变量是在编译的时候确定其值。<br>    #define 宏没有类型，而const 修饰的只读变量具有特定的类型。 </p>
<p>(2)修饰一般变量</p>
<p>一般常 量是指简单类型的只读变量。这种只读变量在定义时，修饰符const</p>
<p>可以用在类型说明符前，也可以用在类型说明符后</p>
<p>（3）修饰数组</p>
<p>定义或说明一个只读数组可采用如下格式：<br>int const a[5]={1, 2, 3, 4, 5};或<br>const int a[5]={1, 2, 3, 4, 5}; </p>
<p>（4）修饰指针</p>
<p> const int *p; // p 可变，p 指向的对象不可变</p>
<p>                    int const *p; // p 可变，p 指向的对象不可变</p>
<p>int *const p; // p 不可变，p 指向的对象可变</p>
<p>                    const int *const p; //指针p 和p 指向的对象都不可变</p>
<p>在平时的授课中发现学生很难记住这几种情况。这里给出一个</p>
<p>记忆和理解的方法：</p>
<p>            先忽略类型名（编译器解析的时候也是忽略类型名），我们看const 离</p>
<p>哪个近。“近水楼台先得月”，离谁近就修饰谁。<br>const int <em>p; //const 修饰</em>p,p 是指针，<em>p 是指针指向的对象，不可变<br>int const <em>p; //const修饰</em>p,p 是指针，</em>p 是指针指向的对象，不可变<br>int *const p; //const修饰p，p 不可变，p 指向的对象可变<br>const int <em>const p; //前一个const 修饰</em>p,后一个const 修饰p，指针p和p 指向的对象都不可变 </p>
<p>（5）修饰函数的参数</p>
<p>      const 修饰符也可以修饰函数的参数，当不希望这个参数值被函数体</p>
<p>内意外改变时使用。例如：</p>
<p>    void Fun(const int i);</p>
<p>告诉编译器i 在函数体中的不能改变，从而防止了使用者的一些无意的或错误的修改。</p>
<p>（6）修饰函数的返回值</p>
<p>const 修饰符也可以修饰函数的返回值，返回值不可被改变</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>could not write bytes broken pipe</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/could%20not%20write%20bytes%20broken%20pipe/</url>
    <content><![CDATA[<p>could not write bytes broken pipe</p>
<p>startx 进不了</p>
<p>可以安装这个试试</p>
<p>sudo apt-get install xserver-xorg</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>count — Count all elements in an array, or something in an object</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/count%20%E2%80%94%20Count%20all%20elements%20in%20an%20array,%20or%20something%20in%20an%20object/</url>
    <content><![CDATA[<p>int count ( mixed $var [, int $mode = COUNT_NORMAL ] )</p>
<p>&lt;?php<br>$a[0] = 1;<br>$a[1] = 3;<br>$a[2] = 5;<br>$result = count($a);<br>// $result == 3<br>$b[0] = 7;<br>$b[5] = 9;<br>$b[10] = 11;<br>$result = count($b);<br>// $result == 3<br>$result = count(null);<br>// $result == 0<br>$result = count(false);<br>// $result == 1<br>?&gt; </p>
<p>&lt;?php<br>$food = array(‘fruits’ =&gt; array(‘orange’, ‘banana’, ‘apple’),<br>‘veggie’ =&gt; array(‘carrot’, ‘collard’, ‘pea’));<br>// recursive count<br>echo count($food, COUNT_RECURSIVE); // output 8<br>// normal count<br>echo count($food); // output 2<br>?&gt; </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>cpu 主频</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/cpu%20%E4%B8%BB%E9%A2%91/</url>
    <content><![CDATA[<p> cat sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq</p>
<p>cpuinfo_cur_freq</p>
<p>cpuinfo_max_freq</p>
<p>cpuinfo_min_freq</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>cpu温度频率设置 9820e</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/cpu%E6%B8%A9%E5%BA%A6%E9%A2%91%E7%8E%87%E8%AE%BE%E7%BD%AE%209820e/</url>
    <content><![CDATA[<p>通过以下命令可以查看CPU温度</p>
<p>cat /sys/class/thermal/thermal_zone0/temp</p>
<p>cat /sys/class/thermal/thermal_zone1/temp</p>
<p>#########################################################################################</p>
<p>在调试功耗的时候，往往需要将CPU锁定到某一频率再测量电流值。</p>
<p>但是CPU的频率并不是可以随便设置的，它一般只支持有限的几种频率。</p>
<p>通过以下命令可以知道CPU支持的所有频率。</p>
<p>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies</p>
<p>#########################################################################################</p>
<p>DVFS概念 </p>
<p>DVFS全称为Dynamic Voltage and Frequency Scaling, 主要原理是, 根据cpu各个核的实时负载, 来调节其电压和频率. 负载高时, 将频率提升, 以满足性能要求; 负载低时, 将频率降低, 以节省功耗. </p>
<p>进入adb shell命令行 </p>
<p>打开cmd窗口，输入以下指令 </p>
<ol>
<li><p>adb root </p>
</li>
<li><p>adb shell </p>
</li>
</ol>
<p>查看DVFS节点信息 </p>
<p>首先进入adb shell命令行 </p>
<p>1.查看online/offline CPU </p>
<p>online: cat /sys/devices/system/cpu/online </p>
<p>offline: cat /sys/devices/system/cpu/offline </p>
<p>2.查看当前运行的频率 </p>
<p>cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq </p>
<p>3.查看可以设置的频点 </p>
<p>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies </p>
<p>4.查看当前支持的策略(governor) </p>
<p>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors </p>
<p>5.查看当前使用的策略(governor) </p>
<p>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor </p>
<p>设置CPU DVFS运行在固定频率 </p>
<p>首先进入adb shell命令行 </p>
<p>1.设置手动插拔核(hotplug) </p>
<p>echo 1 &gt; /sys/devices/system/cpu/cpuhotplug/cpu_hotplug_disable </p>
<p>注意:这步操作只针对有hotplug策略的手机，目前只针对四核项目，其他手机可以跳过这步 </p>
<p>2.设置dvfs governor为userspace </p>
<p>echo userspace &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor </p>
<p>3.设置相应的核offline </p>
<p>echo 0 &gt; /sys/devices/system/cpu/cpuN/online </p>
<p>注意:上述cpuN中的N代表0~3, 使对应的cpu offline，如无需要可以跳过这步</p>
<p>4.设置需要运行的频率 </p>
<p>echo xxx &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed </p>
<p>(xxx为你要设置的频点，参考上面查询可以设置的频点，另外当设置cpu0后，由于其他3个cpu都指向cpu0，其他cpu都会跟着改变，所以无需设置其他cpu）</p>
<p>5.查询是否生效 </p>
<p>cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq </p>
<p>如设置没有生效，怀疑操作有问题，请重启手机，并重复以上操作。 </p>
<p>恢复原来CPU状态。 </p>
<p>1.设置dvfs governor为interactive </p>
<p>echo interactive &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor </p>
<ol start="2">
<li>设置自动插拔核(hotplug) </li>
</ol>
<p>echo 0 &gt; /sys/devices/system/cpu/cpuhotplug/cpu_hotplug_disable</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>crash_report</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/crash_report.c/</url>
    <content><![CDATA[<p>//<br>// Created by Edward on 2017/1/22.<br>//<br>#include &lt;signal.h&gt;<br>#include &lt;stdlib.h&gt;<br>struct sigaction old_sa[NSIG];<br>void android_sigaction(int signal, siginfo_t *info, void *reserved);<br>void InitCrashReport()<br>{<br>//D_Log(&quot;InitCrashReport&quot;);<br>    // Try to catch crashes…<br>struct sigaction handler;<br>memset(&amp;handler, 0, sizeof(struct sigaction));<br>handler.sa_sigaction = android_sigaction;<br>handler.sa_flags = SA_RESETHAND;<br>#define CATCHSIG(X) sigaction(X, &amp;handler, &amp;old_sa[X])<br>    CATCHSIG(SIGILL);<br>CATCHSIG(SIGABRT);<br>CATCHSIG(SIGBUS);<br>CATCHSIG(SIGFPE);<br>CATCHSIG(SIGSEGV);<br>CATCHSIG(SIGSTKFLT);<br>CATCHSIG(SIGPIPE);<br>}<br>//void android_sigaction(int signal, siginfo_t *info, void *reserved)<br>//{<br>//    if (!g_env) {<br>//        return;<br>//    }<br>//<br>//    jclass classID = g_env-&gt;FindClass(CLASS_NAME);<br>//    if (!classID) {<br>//        return;<br>//    }<br>//<br>//    jmethodID methodID = g_env-&gt;GetStaticMethodID(classID, &quot;onNativeCrashed&quot;, &quot;()V&quot;);<br>//    if (!methodID) {<br>//        return;<br>//    }<br>//<br>//    g_env-&gt;CallStaticVoidMethod(classID, methodID);<br>//<br>//    old_sa[signal].sa_handler(signal);<br>//}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>crontab（内容副本）</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/crontab%EF%BC%88%E5%86%85%E5%AE%B9%E5%89%AF%E6%9C%AC%EF%BC%89/</url>
    <content><![CDATA[<p>sudo crontab -e</p>
<p>  0 12 *   *   5    7z a /opt/data/zsvn_backups.7z /opt/svn -r -mx9</p>
<p>  0 18 *   *   *     /sbin/shutdown -h now</p>
<p>sudo crontab -l</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>dd 命令</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/dd%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>dd是Linux/UNIX 下的一个非常有用的命令，作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>
<p>1.if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt;if=inputfile&gt;</p>
<p>2.of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt;of=outputfile&gt;</p>
<p>3.ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</p>
<p>obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</p>
<p>bs=bytes：同时设置读入/输出的块大小为bytes个字节。</p>
<p>4.cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</p>
<p>5.skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</p>
<p>6.seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</p>
<p>注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</p>
<p>7.count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</p>
<p>8.conv=conversion：用指定的参数转换文件。</p>
<p>ascii：转换ebcdic为ascii</p>
<p>ebcdic：转换ascii为ebcdic</p>
<p>ibm：转换ascii为alternateebcdic</p>
<p>block：把每一行转换为长度为cbs，不足部分用空格填充</p>
<p>unblock：使每一行的长度都为cbs，不足部分用空格填充</p>
<p>lcase：把大写字符转换为小写字符</p>
<p>ucase：把小写字符转换为大写字符</p>
<p>swab：交换输入的每对字节</p>
<p>noerror：出错时不停止</p>
<p>notrunc：不截短输出文件</p>
<p>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</p>
<p>1.将本地的/dev/hdb整盘备份到/dev/hdd</p>
<p>dd if=/dev/hdb of=/dev/hdd</p>
<p>2.将/dev/hdb全盘数据备份到指定路径的image文件</p>
<p>dd if=/dev/hdb of=/root/image</p>
<p>3.将备份文件恢复到指定盘</p>
<p>dd if=/root/image of=/dev/hdb</p>
<p>4.备份/dev/hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径</p>
<p>dd if=/dev/hdb | gzip &gt; /root/image.gz</p>
<p>5.将压缩的备份文件恢复到指定盘</p>
<p>gzip -dc /root/image.gz | dd of=/dev/hdb</p>
<p>6.备份磁盘开始的512个字节大小的MBR信息到指定文件</p>
<p>dd if=/dev/hda of=/root/image count=1 bs=512</p>
<p>count=1指仅拷贝一个块；bs=512指块大小为512个字节。</p>
<p>恢复：</p>
<p>dd if=/root/image of=/dev/hda</p>
<p>7.备份软盘</p>
<p>dd if=/dev/fd0 of=disk.img count=1 bs=1440k</p>
<p>(即块大小为1.44M)</p>
<p>8.拷贝内存内容到硬盘</p>
<p>dd if=/dev/mem of=/root/mem.bin bs=1024</p>
<p>(指定块大小为1k)</p>
<p>9.拷贝光盘内容到指定文件夹，并保存为cd.iso文件</p>
<p>dd if=/dev/cdrom(hdc) of=/root/cd.iso</p>
<p>10.增加swap分区文件大小</p>
<p>第一步：创建一个大小为256M的文件：</p>
<p>dd if=/dev/zero of=/swapfile bs=1024 count=262144</p>
<p>第二步：把这个文件变成swap文件：</p>
<p>mkswap /swapfile</p>
<p>第三步：启用这个swap文件：</p>
<p>swapon /swapfile</p>
<p>第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件：</p>
<p>/swapfile swap swap default 0 0</p>
<p>11.销毁磁盘数据</p>
<p>dd if=/dev/urandom of=/dev/hda1</p>
<p>注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。</p>
<p>12.测试硬盘的读写速度</p>
<p>dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.filedd if=/root/1Gb.file bs=64k | dd of=/dev/null</p>
<p>通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度。</p>
<p>13.确定硬盘的最佳块大小：</p>
<p>dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.filedd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.filedd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.filedd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file</p>
<p>通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小。</p>
<p>14.修复硬盘</p>
<p>dd if=/dev/sda of=/dev/sda</p>
<p>当硬盘较长时间（比如1，2年）放置不使用后，磁盘上会产生magnetic fluxpoint。当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数据起死回生。且这个过程是安全，高效的。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>del Google in Home button</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/del%20Google%20in%20Home%20button/</url>
    <content><![CDATA[<p>  del Google in Home button</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/DelegateViewHelper.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/status</p>
<p>index 3ac1bcf..1bf0b86 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/DelegateViewHelper.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/DelegateViewHelper.java</p>
<p>@@ -78,8 +78,8 @@ public class DelegateViewHelper {</p>
<p>                 float y = k &lt; historySize ? event.getHistoricalY(k) : event.getY();</p>
<p>                 final float distance = mSwapXY ? (mDownPoint[0] - x) : (mDownPoint[1] - y);</p>
<p>                 if (distance &gt; mTriggerThreshhold) {</p>
<ul>
<li><p>                   mBar.showSearchPanel();</p>
</li>
<li><p>                   mPanelShowing = true;</p>
</li>
</ul>
<ul>
<li><p>                  // mBar.showSearchPanel();</p>
</li>
<li><p>                   mPanelShowing = false;</p>
</li>
</ul>
<p>                     break;</p>
<p>                 }</p>
<p>             }</p>
<p>@@ -92,7 +92,7 @@ public class DelegateViewHelper {</p>
<p>         float deltaX = sourceX - delegateX;</p>
<p>         float deltaY = sourceY - delegateY;</p>
<p>         event.offsetLocation(deltaX, deltaY);</p>
<ul>
<li>       mDelegateView.dispatchTouchEvent(event);</li>
</ul>
<ul>
<li>       //mDelegateView.dispatchTouchEvent(event);</li>
</ul>
<p>         event.offsetLocation(-deltaX, -deltaY);</p>
<p>         return mPanelShowing;</p>
<p>     }</p>
<p>@@ -135,4 +135,4 @@ public class DelegateViewHelper {</p>
<p>     public void setSwapXY(boolean swap) {</p>
<p>         mSwapXY = swap;</p>
<p>     }</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/st</p>
<p>index e7367b7..d843551 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>@@ -214,7 +214,7 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>                 case MotionEvent.ACTION_DOWN:</p>
<p>                     if (!shouldDisableNavbarGestures() &amp;&amp; !inKeyguardRestrictedInputMode()) {</p>
<p>                         mHandler.removeCallbacks(mShowSearchPanel);</p>
<ul>
<li>                       mHandler.postDelayed(mShowSearchPanel, mShowSearchHoldoff);</li>
</ul>
<ul>
<li>                      // mHandler.postDelayed(mShowSearchPanel, mShowSearchHoldoff);</li>
</ul>
<p>                     }</p>
<p>                 break;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>disable forword  iptables</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/disable%20forword%20%20iptables/</url>
    <content><![CDATA[<p>#!/system/bin/sh</p>
<p>tag=&quot;iptables&quot;</p>
<p>log -p d -t $tag &quot;disable forword !!!&quot;</p>
<p>#iptables -L white_list </p>
<p>#if [[ $? == 1 ]]</p>
<p>#then</p>
<h1 id="log-p-d-t-tag-quot-script-running-quot"><a href="#log-p-d-t-tag-quot-script-running-quot" class="headerlink" title="log -p d -t $tag &quot;script running !!!&quot;"></a>log -p d -t $tag &quot;script running !!!&quot;</h1><h1 id="iptables-P-FORWARD-DROP"><a href="#iptables-P-FORWARD-DROP" class="headerlink" title="iptables -P FORWARD DROP"></a>iptables -P FORWARD DROP</h1><h1 id="iptables-N-white-list"><a href="#iptables-N-white-list" class="headerlink" title="iptables -N white_list"></a>iptables -N white_list</h1><h1 id="iptables-I-FORWARD-j-white-list"><a href="#iptables-I-FORWARD-j-white-list" class="headerlink" title="iptables -I FORWARD -j white_list"></a>iptables -I FORWARD -j white_list</h1><h1 id="iptables-I-white-list-d-m-baidu-com-j-ACCEPT"><a href="#iptables-I-white-list-d-m-baidu-com-j-ACCEPT" class="headerlink" title="iptables -I white_list -d m.baidu.com -j ACCEPT"></a>iptables -I white_list -d m.baidu.com -j ACCEPT</h1><h1 id="iptables-I-white-list-s-m-baidu-com-j-ACCEPT"><a href="#iptables-I-white-list-s-m-baidu-com-j-ACCEPT" class="headerlink" title="iptables -I white_list -s m.baidu.com -j ACCEPT"></a>iptables -I white_list -s m.baidu.com -j ACCEPT</h1><h1 id="log-p-d-t-tag-quot-script-finish-quot"><a href="#log-p-d-t-tag-quot-script-finish-quot" class="headerlink" title="log -p d -t $tag &quot;script finish !!!&quot;"></a>log -p d -t $tag &quot;script finish !!!&quot;</h1><p>#fi </p>
<p>#!/system/bin/sh</p>
<p>tag=&quot;iptables&quot;</p>
<p>log -p d -t $tag &quot;disable forword !!!&quot;</p>
<p>white_list=(&quot;baidu.com&quot; &quot;m.baidu.com&quot; &quot;120.55.30.7&quot; &quot;120.79.64.221&quot; &quot;119.29.100.211&quot;)</p>
<p> iptables -P FORWARD DROP</p>
<p> for var in ${white_list[@]} </p>
<p>do</p>
<p>    iptables -C FORWARD -d $var -j ACCEPT</p>
<p>if [[ $? == 1 ]]</p>
<p>then </p>
<p>iptables -A FORWARD -d $var -j ACCEPT</p>
<p>log -p d -t $tag &quot;add -d $var !!!&quot;</p>
<p>fi</p>
<p>iptables -C FORWARD -s $var -j ACCEPT</p>
<p>if [[ $? == 1 ]]</p>
<p>then </p>
<p>iptables -A FORWARD -s $var -j ACCEPT</p>
<p>log -p d -t $tag &quot;add -s $var !!!&quot;</p>
<p>fi</p>
<p>done</p>
<p>  log -p d -t $tag &quot;add white list done !!!&quot;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/docker/</url>
    <content><![CDATA[<p>sudo apt install docker-ce</p>
<p>   60  sudo docker run hello-world</p>
<p>   61  sudo groupadd docker</p>
<p>   62  sudo usermod -aG docker hz</p>
<p>   63  docker run hello-world</p>
<p>   64  docker images</p>
<p>$ docker ps -a指令查询刚才的容器编号为1a61adfb1953</p>
<p>$ sudo docker commit -m &quot;xxx&quot; &lt;CONTAINER ID&gt; &lt;TEPO:TAG&gt;</p>
<p>$ sudo docker commit -m &quot;android-build&quot; 1a61adfb1953 local:v1.0</p>
<p>docker run -it -v /opt:/opt wtanaka/ubuntu-1604 /bin/bash</p>
<p>docker run -it -v /opt:/opt local /bin/bash</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>email背景  windowBackground</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/email%E8%83%8C%E6%99%AF%20%20windowBackground/</url>
    <content><![CDATA[<ol>
<li> packages/apps/Email/AndroidManifest.xml</li>
</ol>
<p> &lt;application</p>
<p>        android:icon=&quot;@mipmap/ic_launcher_email&quot;</p>
<p>        android:label=&quot;@string/app_name&quot;</p>
<p>        android:name=&quot;Email&quot;</p>
<p>        android:theme=&quot;@style/EmailTheme&quot;</p>
<ol start="2">
<li> packages/apps/Email/res/values/styles.xml</li>
</ol>
<p>&lt;style name=&quot;EmailTheme&quot; parent=&quot;@android:style/Theme.Holo.Light&quot;&gt;</p>
<ol start="3">
<li>frameworks/base/core/res/res/values/themes.xml</li>
</ol>
<p> &lt;style name=&quot;Theme.Holo.Light&quot; parent=&quot;Theme.Light&quot;&gt;</p>
<p>  &lt;style name=&quot;Theme.Light&quot;&gt;</p>
<p>        &lt;item name=&quot;windowBackground&quot;&gt;@android:drawable/screen_background_selector_light&lt;/item&gt;</p>
<ol start="4">
<li>res/drawable/screen_background_selector_light.xml</li>
</ol>
<p>&lt;selector xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;&gt;</p>
<p>    &lt;item android:state_accelerated=&quot;false&quot;</p>
<p>            android:drawable=&quot;@android:drawable/screen_background_light&quot; /&gt;</p>
<p>    &lt;item android:drawable=&quot;@android:drawable/background_holo_light&quot; /&gt;</p>
<p>&lt;/selector&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>epoll DEMO</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/epoll%20DEMO/</url>
    <content><![CDATA[<p>#include &lt;stdio.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#define MAX_EVENT 20#define READ_BUF_LEN 256/**</p>
<ul>
<li><p>设置 file describe 为非阻塞模式</p>
</li>
<li><p>@param fd 文件描述</p>
</li>
<li><p>@return 返回0成功，返回-1失败</p>
</li>
<li><p>/static int make_socket_non_blocking (int fd) {<br>   int flags, s;<br>   // 获取当前flag<br>   flags = fcntl(fd, F_GETFL, 0);<br>   if (-1 == flags) {<br>       perror(&quot;Get fd status&quot;);<br>       return -1;<br>   }</p>
<p>   flags |= O_NONBLOCK;</p>
<p>   // 设置flag<br>   s = fcntl(fd, F_SETFL, flags);<br>   if (-1 == s) {<br>       perror(&quot;Set fd status&quot;);<br>       return -1;<br>   }<br>   return 0;<br>}int main() {<br>   // epoll 实例 file describe<br>   int epfd = 0;<br>   int listenfd = 0;<br>   int result = 0;<br>   struct epoll_event ev, event[MAX_EVENT];<br>   // 绑定的地址<br>   const char * const local_addr = &quot;192.168.0.45&quot;;<br>   struct sockaddr_in server_addr = { 0 };</p>
<p>   listenfd = socket(AF_INET, SOCK_STREAM, 0);<br>   if (-1 == listenfd) {<br>       perror(&quot;Open listen socket&quot;);<br>       return -1;<br>   }<br>   /* Enable address reuse */<br>   int on = 1;<br>   // 打开 socket 端口复用, 防止测试的时候出现 Address already in use<br>   result = setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on) );<br>   if (-1 == result) {<br>       perror (&quot;Set socket&quot;);<br>       return 0;<br>   }</p>
<p>   server_addr.sin_family = AF_INET;<br>   inet_aton (local_addr, &amp;(server_addr.sin_addr));<br>   server_addr.sin_port = htons(8080);<br>   result = bind(listenfd, (const struct sockaddr *)&amp;server_addr, sizeof (server_addr));<br>   if (-1 == result) {<br>       perror(&quot;Bind port&quot;);<br>       return 0;<br>   }<br>   result = make_socket_non_blocking(listenfd);<br>   if (-1 == result) {<br>       return 0;<br>   }</p>
<p>   result = listen(listenfd, 200);<br>   if (-1 == result) {<br>       perror(&quot;Start listen&quot;);<br>       return 0;<br>   }</p>
<p>   // 创建epoll实例<br>   epfd = epoll_create1(0);<br>   if (1 == epfd) {<br>       perror(&quot;Create epoll instance&quot;);<br>       return 0;<br>   }</p>
<p>   ev.data.fd = listenfd;<br>   ev.events = EPOLLIN | EPOLLET /* 边缘触发选项。 */;<br>   // 设置epoll的事件<br>   result = epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);</p>
<p>   if(-1 == result) {<br>       perror(&quot;Set epoll_ctl&quot;);<br>       return 0;<br>   }</p>
<p>   for ( ; ; ) {<br>       int wait_count;<br>       // 等待事件<br>       wait_count = epoll_wait(epfd, event, MAX_EVENT, -1);</p>
<p>       for (int i = 0 ; i &lt; wait_count; i++) {<br>           uint32_t events = event[i].events;<br>           // IP地址缓存<br>           char host_buf[NI_MAXHOST];<br>           // PORT缓存<br>           char port_buf[NI_MAXSERV];</p>
<p>           int __result;<br>           // 判断epoll是否发生错误<br>           if ( events &amp; EPOLLERR || events &amp; EPOLLHUP || (! events &amp; EPOLLIN)) {<br>               printf(&quot;Epoll has error\n&quot;);<br>               close (event[i].data.fd);<br>               continue;<br>           } else if (listenfd == event[i].data.fd) {<br>               // listen的 file describe 事件触发， accpet事件</p>
<p>               for ( ; ; ) { // 由于采用了边缘触发模式，这里需要使用循环<br>                   struct sockaddr in_addr = { 0 };<br>                   socklen_t in_addr_len = sizeof (in_addr);<br>                   int accp_fd = accept(listenfd, &amp;in_addr, &amp;in_addr_len);<br>                   if (-1 == accp_fd) {<br>                       perror(&quot;Accept&quot;);<br>                       break;<br>                   }<br>                   __result = getnameinfo(&amp;in_addr, sizeof (in_addr),<br>                                          host_buf, sizeof (host_buf) / sizeof (host_buf[0]),<br>                                          port_buf, sizeof (port_buf) / sizeof (port_buf[0]),<br>                                          NI_NUMERICHOST | NI_NUMERICSERV);</p>
<p>                   if (! __result) {<br>                       printf(&quot;New connection: host = %s, port = %s\n&quot;, host_buf, port_buf);<br>                   }</p>
<p>                   __result = make_socket_non_blocking(accp_fd);<br>                   if (-1 == __result) {<br>                       return 0;<br>                   }</p>
<p>                   ev.data.fd = accp_fd;<br>                   ev.events = EPOLLIN | EPOLLET;<br>                   // 为新accept的 file describe 设置epoll事件<br>                   __result = epoll_ctl(epfd, EPOLL_CTL_ADD, accp_fd, &amp;ev);</p>
<p>                   if (-1 == __result) {<br>                       perror(&quot;epoll_ctl&quot;);<br>                       return 0;<br>                   }<br>               }<br>               continue;<br>           } else {<br>               // 其余事件为 file describe 可以读取<br>               int done = 0;<br>               // 因为采用边缘触发，所以这里需要使用循环。如果不使用循环，程序并不能完全读取到缓存区里面的数据。<br>               for ( ; ;) {<br>                   ssize_t result_len = 0;<br>                   char buf[READ_BUF_LEN] = { 0 };</p>
<p>                   result_len = read(event[i].data.fd, buf, sizeof (buf) / sizeof (buf[0]));</p>
<p>                   if (-1 == result_len) {<br>                       if (EAGAIN != errno) {<br>                           perror (&quot;Read data&quot;);<br>                           done = 1;<br>                       }<br>                       break;<br>                   } else if (! result_len) {<br>                       done = 1;<br>                       break;<br>                   }</p>
<p>                   write(STDOUT_FILENO, buf, result_len);<br>               }<br>               if (done) {<br>                   printf(&quot;Closed connection\n&quot;);<br>                   close (event[i].data.fd);<br>               }<br>           }<br>       }</p>
<p>   }<br>   close (epfd);<br>   return 0;<br>}</p>
</li>
</ul>
<p>官方demo</p>
<p>#define MAX_EVENTS 10struct epoll_event  ev, events[MAX_EVENTS];int         listen_sock, conn_sock, nfds, epollfd;/* Code to set up listening socket, ‘listen_sock’,</p>
<ul>
<li>(socket(), bind(), listen()) omitted */epollfd = epoll_create1( 0 );if ( epollfd == -1 )<br>{<br>   perror( &quot;epoll_create1&quot; );<br>   exit( EXIT_FAILURE );<br>}</li>
</ul>
<p>ev.events   = EPOLLIN;<br>ev.data.fd  = listen_sock;if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev ) == -1 )<br>{<br>    perror( &quot;epoll_ctl: listen_sock&quot; );<br>    exit( EXIT_FAILURE );<br>}for (;; )<br>{<br>    nfds = epoll_wait( epollfd, events, MAX_EVENTS, -1 );<br>    if ( nfds == -1 )<br>    {<br>        perror( &quot;epoll_wait&quot; );<br>        exit( EXIT_FAILURE );<br>    }</p>
<p>    for ( n = 0; n &lt; nfds; ++n )<br>    {<br>        if ( events[n].data.fd == listen_sock )<br>        {<br>            conn_sock = accept( listen_sock,<br>                        (struct sockaddr *) &amp;local, &amp;addrlen );<br>            if ( conn_sock == -1 )<br>            {<br>                perror( &quot;accept&quot; );<br>                exit( EXIT_FAILURE );<br>            }<br>            setnonblocking( conn_sock );<br>            ev.events   = EPOLLIN | EPOLLET;<br>            ev.data.fd  = conn_sock;<br>            if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, conn_sock,<br>                    &amp;ev ) == -1 )<br>            {<br>                perror( &quot;epoll_ctl: conn_sock&quot; );<br>                exit( EXIT_FAILURE );<br>            }<br>        } else {<br>            do_use_fd( events[n].data.fd );<br>        }<br>    }<br>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>epoll_wait</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/epoll_wait/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/wuyepeng/p/9726771.html">https://www.cnblogs.com/wuyepeng/p/9726771.html</a></p>
<p>#include&lt;stdio.h&gt;   </p>
<p>#include&lt;stdlib.h&gt;   </p>
<p>#include&lt;netinet/in.h&gt;   </p>
<p>#include&lt;sys/socket.h&gt;   </p>
<p>#include&lt;arpa/inet.h&gt;   </p>
<p>#include&lt;string.h&gt;   </p>
<p>#include&lt;unistd.h&gt;   </p>
<p>#include &lt;sys/epoll.h&gt;</p>
<p>#include &lt;errno.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#define BUFFER_SIZE 1024   </p>
<p>int main(int argc, const char * argv[])   </p>
<p>{  </p>
<p>int i,n;</p>
<p>int connfd,sockfd;</p>
<p>struct epoll_event ev,events[20]; //ev用于注册事件,数组用于回传要处理的事件</p>
<p>int epfd=epoll_create(256);//创建一个epoll的句柄，其中256为你epoll所支持的最大句柄数</p>
<p>struct sockaddr_in client_addr;</p>
<p>struct sockaddr_in server_addr;   </p>
<p>server_addr.sin_family = AF_INET;   </p>
<p>server_addr.sin_port = htons(11277);   </p>
<p>server_addr.sin_addr.s_addr =INADDR_ANY;   </p>
<p>bzero(&amp;(server_addr.sin_zero), 8);   </p>
<p>int server_sock_fd = socket(AF_INET, SOCK_STREAM, 0); </p>
<p>ev.data.fd=server_sock_fd;//设置与要处理的事件相关的文件描述符</p>
<p>ev.events=EPOLLIN|EPOLLET;//设置要处理的事件类型</p>
<p>epoll_ctl(epfd,EPOLL_CTL_ADD,server_sock_fd,&amp;ev);//注册epoll事件</p>
<p>if(server_sock_fd == -1)   </p>
<p>{   </p>
<p>perror(&quot;socket error&quot;);   </p>
<p>return 1;   </p>
<p>}   </p>
<p>char recv_msg[BUFFER_SIZE];   </p>
<p>char input_msg[BUFFER_SIZE];   </p>
<p>if(connect(server_sock_fd, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr_in)) == 0)   </p>
<p>{   </p>
<p>for(;;)</p>
<p>{</p>
<p>int nfds=epoll_wait(epfd,events,20,500);//等待epoll事件的发生</p>
<p>for(i=0;i&lt;nfds;++i)</p>
<p>{   </p>
<p>if(events[i].events&amp;EPOLLOUT) //有数据发送，写socket</p>
<p>{</p>
<p>bzero(input_msg, BUFFER_SIZE);   </p>
<p>fgets(input_msg, BUFFER_SIZE, stdin);   </p>
<p>sockfd = events[i].data.fd;</p>
<p>write(sockfd, recv_msg, n);</p>
<p>ev.data.fd=sockfd;</p>
<p>ev.events=EPOLLIN|EPOLLET;</p>
<p>epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,&amp;ev);</p>
<p>}  </p>
<p>else if(events[i].events&amp;EPOLLIN)//有数据到来，读socket</p>
<p>{</p>
<p>bzero(recv_msg, BUFFER_SIZE);</p>
<p>if((n = read(server_sock_fd, recv_msg, BUFFER_SIZE)) &lt;0 )</p>
<p>{</p>
<p>printf(&quot;read error!&quot;);</p>
<p>}</p>
<p>ev.data.fd=server_sock_fd;</p>
<p>ev.events=EPOLLOUT|EPOLLET;</p>
<p>printf(&quot;%s\n&quot;,recv_msg);</p>
<p>}</p>
<p>}       </p>
<p>}</p>
<p>}   </p>
<p>return 0;   </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>explodeimplode</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/explodeimplode/</url>
    <content><![CDATA[<p>explode — Split a string by string</p>
<p>array explode ( string $delimiter , string $string [, int $limit ] )</p>
<p>&lt;?php<br>// Example 1<br>$pizza = &quot;piece1 piece2 piece3 piece4 piece5 piece6&quot;;<br>$pieces = explode(&quot; &quot;, $pizza);<br>echo $pieces[0]; // piece1<br>echo $pieces[1]; // piece2<br>// Example 2<br>$data = &quot;foo:*:1023:1000::/home/foo:/bin/sh&quot;;<br>list($user, $pass, $uid, $gid, $gecos, $home, $shell) = explode(&quot;:&quot;, $data);<br>echo $user; // foo<br>echo $pass; // *<br>?&gt; </p>
<p>implode — Join array elements with a string</p>
<p>string implode ( string $glue , array $pieces )</p>
<p>string implode ( array $pieces )</p>
<p>&lt;?php<br>$array = array(‘lastname’, ‘email’, ‘phone’);<br>$comma_separated = implode(&quot;,&quot;, $array);<br>echo $comma_separated; // lastname,email,phone<br>// Empty string when using an empty array:<br>var_dump(implode(‘hello’, array())); // string(0) &quot;&quot;<br>?&gt;  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ffmpeg 编译</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ffmpeg%20%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>alsa/asoundlib.h: No such file or directory</p>
<p>apt-get install libasound2-dev</p>
<p>failed: dlopen failed: could not load library &quot;libavformat.so&quot; needed by &quot;libnative-lib.so&quot;; caused by cannot locate symbol &quot;atof&quot; referenced by &quot;libavformat.so&quot;</p>
<p>/platforms/android-16/arch-arm/</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>foreach</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/foreach/</url>
    <content><![CDATA[<p>The foreach construct provides an easy way to iterate over arrays. foreach works only on arrays and objects, and will issue an error when you try to use it on a variable with a different data type or an uninitialized variable. There are two syntaxes:</p>
<p>foreach (array_expression as $value)<br>    statement<br>foreach (array_expression as $key =&gt; $value)<br>    statement</p>
<p>Reference of a $value and the last array element   remain even after the foreach loop. It is recommended   to destroy it by unset().</p>
<p>&lt;?php<br>$arr = array(1, 2, 3, 4);<br>foreach ($arr as &amp;$value) {<br>$value = $value * 2;<br>}<br>// $arr is now array(2, 4, 6, 8)<br>unset($value); // break the reference with the last element<br>?&gt;</p>
<p>&lt;?php<br>/* foreach example 1: value only <em>/<br>$a = array(1, 2, 3, 17);<br>foreach ($a as $v) {<br>    echo &quot;Current value of $a: $v.\n&quot;;<br>}<br>/</em> foreach example 2: value (with its manual access notation printed for illustration) <em>/<br>$a = array(1, 2, 3, 17);<br>$i = 0; /</em> for illustrative purposes only <em>/<br>foreach ($a as $v) {<br>    echo &quot;$a[$i] =&gt; $v.\n&quot;;<br>$i++;<br>}<br>/</em> foreach example 3: key and value <em>/<br>$a = array(<br>&quot;one&quot; =&gt; 1,<br>&quot;two&quot; =&gt; 2,<br>&quot;three&quot; =&gt; 3,<br>&quot;seventeen&quot; =&gt; 17<br>);<br>foreach ($a as $k =&gt; $v) {<br>    echo &quot;$a[$k] =&gt; $v.\n&quot;;<br>}<br>/</em> foreach example 4: multi-dimensional arrays <em>/<br>$a = array();<br>$a[0][0] = &quot;a&quot;;<br>$a[0][1] = &quot;b&quot;;<br>$a[1][0] = &quot;y&quot;;<br>$a[1][1] = &quot;z&quot;;<br>foreach ($a as $v1) {<br>    foreach ($v1 as $v2) {<br>        echo &quot;$v2\n&quot;;<br>    }<br>}<br>/</em> foreach example 5: dynamic arrays */<br>foreach (array(1, 2, 3, 4, 5) as $v) {<br>    echo &quot;$v\n&quot;;<br>}<br>?&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>frameworksbasecoreresresvalues-landarrays</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/frameworksbasecoreresresvalues-landarrays.xml/</url>
    <content><![CDATA[<p>frameworks/base/core/res/res/values-land/arrays.xml</p>
<p>&lt;array name=&quot;lockscreen_target_descriptions_with_camera&quot;&gt;</p>
<p>        &lt;item&gt;@null&lt;/item&gt;</p>
<p>        &lt;item&gt;@string/description_target_unlock&lt;/item&gt;</p>
<p>        &lt;item&gt;@string/description_target_search&lt;/item&gt;</p>
<p>        &lt;item&gt;@string/description_target_camera&lt;/item&gt;</p>
<p>    &lt;/array&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>gitolite 权限丢失</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/gitolite%20%E6%9D%83%E9%99%90%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<p>1.修改</p>
<p>vi ~/.gitolite/conf/gitolite.conf</p>
<p>2.执行gitolite compile 即可</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>h264基础概念</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/h264%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>一、 h264基础概念</p>
<p>SODB:　数据比特串－－＞最原始的编码数据</p>
<p>RBSP:　原始字节序列载荷－－＞在SODB的后面填加了结尾比特（RBSP trailing bits　一个bit“1”）若干比特“0”,以便字节对齐。</p>
<p>EBSP:　扩展字节序列载荷– &gt;在RBSP基础上填加了仿校验字节（0X03）它的原因是：　在NALU加到Annexb上时，需要填加每组NALU之前的开始码 StartCodePrefix,如果该NALU对应的slice为一帧的开始则用4位字节表示，ox00000001,否则用3位字节表示 ox000001.<br>为了使NALU主体中不包括与开始码相冲突的，在编码时，每遇到两个字节连续为0，就插入一个字节的0x03。解码时将0x03去掉。 也称为脱壳操作。</p>
<p>H.264的功能分为两层，视频编码层（VCL）和网络提取层（NAL） <br>VCL数据即被压缩编码后的视频数据序列。把VCL数据要封装到NAL单元中之后，才可以用来传输或存储。NAL单元格式如下图： </p>
<p>H.264 的编码视频序列包括一系列的NAL 单元，每个NAL 单元包含一个RBSP，见表1。编码片（包括数据分割片IDR 片）和序列RBSP 结束符被定义为VCL NAL 单元，其余为NAL 单元。典型的RBSP 单元序列如图2 所示。每个单元都按独立的NAL 单元传送。单元的信息头（一个字节）定义了RBSP 单元的类型，NAL 单元的其余部分为RBSP 数据。</p>
<p>NAL单元</p>
<p>每个NAL单元是一个一定语法元素的可变长字节字符串，包括包含一个字节的头信息（用来表示数据类型），以及若干整数字节的负荷数据。一个NAL单元可以携带一个编码片、A/B/C型数据分割或一个序列或图像参数集。</p>
<p>NALU 头由一个字节组成, 它的语法如下: </p>
<p>　　NAL单元按RTP序列号按序传送。其中，T为负荷数据类型，占5bit；R为重要性指示位，占2个bit；最后的F为禁止位，占1bit。具体如下： <br>　　（1）NALU类型位 <br>　　可以表示NALU的32种不同类型特征，类型1～12是H.264定义的，类型24～31是用于H.264以外的，RTP负荷规范使用这其中的一些值来定义包聚合和分裂，其他值为H.264保留。<br>　　（2）重要性指示位 <br>　　用于在重构过程中标记一个NAL单元的重要性，值越大，越重要。值为0表示这个NAL单元没有用于预测，因此可被解码器抛弃而不会有错误扩散；值高于0表示此NAL单元要用于无漂移重构，且值越高，对此NAL单元丢失的影响越大。<br>　　（3）禁止位 <br>编码中默认值为0，当网络识别此单元中存在比特错误时，可将其设为1，以便接收方丢掉该单元，主要 用于适应不同种类的网络环境（比如有线无线相结合的环境）。</p>
<p>264常见的帧头数据为：</p>
<p>00 00 00 01 67 (SPS)</p>
<p>00 00 00 01 68 (PPS)</p>
<p>00 00 00 01 65 ( IDR 帧)</p>
<p>00 00 00 01 61 (P帧)</p>
<p>等等，那么他们代表的意思是什么呢？</p>
<p>上述的67,68,65,61，还有41等，都是该NALU的识别级别。</p>
<p>F：禁止为，0表示正常，1表示错误，一般都是0</p>
<p>NRI：重要级别，11表示非常重要。</p>
<p>TYPE：表示该NALU的类型是什么，</p>
<p>见下表，由此可知7为序列参数集(SPS)，8为图像参数集(PPS)，5代表I帧。1代表非I帧。</p>
<p>由此可知，61和41其实都是P帧（type值为1），只是重要级别不一样（它们的NRI一个是11BIN，一个是10BIN）</p>
<p>NALU类型是我们判断帧类型的利器，从官方文档中得出如下图：</p>
<p>H264(NAL简介与I帧判断)</p>
<p>我们还是接着看最上面图的码流对应的数据来层层分析，以00 00 00 01分割之后的下一个字节就是NALU类型，将其转为二进制数据后，</p>
<p>解读顺序为从左往右算，如下:</p>
<p>（1）第1位禁止位，值为1表示语法出错</p>
<p>（2）第2~3位为参考级别</p>
<p>（3）第4~8为是nal单元类型</p>
<p>例如上面00000001后有67,68以及65</p>
<p>其中0x67的二进制码为：</p>
<p>0110 0111</p>
<p>4-8为00111，转为十进制7，参考第二幅图：7对应序列参数集SPS</p>
<p>其中0x68的二进制码为：</p>
<p>0110 1000 <br>4-8为01000，转为十进制8，参考第二幅图：8对应图像参数集PPS</p>
<p>其中0x65的二进制码为：</p>
<p>011 00101</p>
<p>4-8位为00101，转为十进制5，参考第二幅图：5对应IDR图像中的片(I帧)</p>
<p>所以判断是否为I帧的算法为：</p>
<p>（NALU类型 &amp; 0001 1111） = 5 即 (NALU类型 &amp; 31) = 5 <br>比如0x65 &amp; 31 = 5</p>
<p>二、RTP Header解析</p>
<p>1)        V：RTP协议的版本号，占2位，当前协议版本号为2</p>
<p>2)        P：填充标志，占1位，如果P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。</p>
<p>3)        X：扩展标志，占1位，如果X=1，则在RTP报头后跟有一个扩展报头</p>
<p>4)        CC：CSRC计数器，占4位，指示CSRC 标识符的个数</p>
<p>5)        M: 标记，占1位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。</p>
<p>6)        PT: 有效荷载类型，占7位，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等,在流媒体中大部分是用来区分音频流和视频流的，这样便于客户端进行解析。</p>
<p>7)        序列号：占16位，用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。这个字段当下层的承载协议用UDP的时候，网络状况不好的时候可以用来检查丢包。同时出现网络抖动的情况可以用来对数据进行重新排序，序列号的初始值是随机的，同时音频包和视频包的sequence是分别记数的。</p>
<p>8)        时戳(Timestamp)：占32位，必须使用90 kHz 时钟频率。时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。</p>
<p>9)        同步信源(SSRC)标识符：占32位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。</p>
<p>10)    特约信源(CSRC)标识符：每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源。</p>
<p>注：基本的RTP说明并不定义任何头扩展本身，如果遇到X=1，需要特殊处理</p>
<p>使用Wireshark抓一段码流进行分析</p>
<p>其中，</p>
<p>80                    是V_P_X_CC</p>
<p>60                    是M_PT</p>
<p>00 01              是SequenceNum</p>
<p>00 00  00 00  是Timestamp<br>39 6e d3 46  是SSRC</p>
<p>把前两字节换成二进制如下</p>
<p>1000 0000 0110 0000</p>
<p>按顺序解释如下：</p>
<p>10               是V；</p>
<p>0                 是P；</p>
<p>0                 是X；</p>
<p>0000          是CC；</p>
<p>0                 是M；</p>
<p>110 0000   是PT；</p>
<p>三、RTP荷载H264码流</p>
<p>+—————+</p>
<p>|0|1|2|3|4|5|6|7|</p>
<p>  +-+-+-+-+-+-+-+-+</p>
<p>  |F|NRI|  Type   |</p>
<p>  +—————+</p>
<p>荷载格式定义三个不同的基本荷载结构，接收者可以通过RTP荷载的第一个字节后5位（如上图参考RFC3984）识别荷载结构。</p>
<ol>
<li><p>  单个NAL单元包：荷载中只包含一个NAL单元。NAL头类型域等于原始 NAL单元类型,即在范围1到23之间</p>
</li>
<li><p>  聚合包：本类型用于聚合多个NAL单元到单个RTP荷载中。本包有四种版本,单时间聚合包类型A (STAP-A)，单时间聚合包类型B (STAP-B)，多时间聚合包类型(MTAP)16位位移(MTAP16), 多时间聚合包类型(MTAP)24位位移(MTAP24)。赋予STAP-A, STAP-B, MTAP16, MTAP24的NAL单元类型号分别是 24,25, 26, 27</p>
</li>
<li><p>  分片单元：用于分片单个NAL单元到多个RTP包。现存两个版本FU-A，FU-B,用NAL单元类型 28，29标识</p>
</li>
</ol>
<p>常用的打包时的分包规则是：如果小于MTU采用单个NAL单元包，如果大于MTU就采用FUs分片方式。因为常用的打包方式就是单个NAL包和FU-A方式，所以我们只解析这两种。</p>
<p>3.1 单个NAL单元包</p>
<p>0                   1                   2                   3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<p>|F|NRI|  type   |                                               |</p>
<p>  +-+-+-+-+-+-+-+-+                                               |</p>
<p>|                                                               |</p>
<p>|               Bytes 2..n of a Single NAL unit                 |</p>
<p>|                                                               |</p>
<p>|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<p>  |                               :…OPTIONAL RTP padding        |</p>
<p>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<p>定义在此的NAL单元包必须只包含一个。这意味聚合包和分片单元不可以用在单个NAL 单元包中。并且RTP序号必须符合NAL单元的解码顺序。NAL单元的第一字节和RTP荷载头第一个字节重合。（如上图参考RFC3984）打包H264码流时，只需在帧前面加上12字节的RTP头即可。</p>
<p>3.2 分片单元（FU-A）</p>
<p>0                   1                   2                   3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<p>| FU indicator  |   FU header  |                               |</p>
<p> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</p>
<p>  |                                                               |</p>
<p>  |                         FU payload                            |</p>
<p>  |                                                               |</p>
<p>  |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<p>|                               :…OPTIONAL RTP padding        |</p>
<p> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<p>                                图 1</p>
<p>分片只定义于单个NAL单元不用于任何聚合包。NAL单元的一个分片由整数个连续NAL单元字节组成。每个NAL单元字节必须正好是该NAL单元一个分片的一部分。相同NAL单元的分片必须使用递增的RTP序号连续顺序发送(第一和最后分片之间没有其他的RTP包）。相似，NAL单元必须按照RTP顺序号的顺序装配。</p>
<p>   当一个NAL单元被分片运送在分片单元(FUs)中时，被引用为分片NAL单元。STAPs,MTAPs不可以被分片。 FUs不可以嵌套。 即, 一个FU 不可以包含另一个FU。运送FU的RTP时戳被设置成分片NAL单元的NALU时刻。</p>
<p>图 1表示FU-A的RTP荷载格式。FU-A由1字节的分片单元指示（如图2），1字节的分片单元头（如图3），和分片单元荷载组成。</p>
<p> +—————+</p>
<p>|0|1|2|3|4|5|6|7|</p>
<p>  +-+-+-+-+-+-+-+-+</p>
<p>  |F|NRI|  Type   |</p>
<p>  +—————+</p>
<p>        图 2</p>
<p>FU指示字节的类型域Type=28表示FU-A。。NRI域的值必须根据分片NAL单元的NRI域的值设置。</p>
<p>+—————+</p>
<p>|0|1|2|3|4|5|6|7|</p>
<p>  +-+-+-+-+-+-+-+-+</p>
<p>  |S|E|R|  Type   |</p>
<p> +—————+</p>
<p>        图 3</p>
<p>S: 1 bit 当设置成1,开始位指示分片NAL单元的开始。当跟随的FU荷载不是分片NAL单元荷载的开始，开始位设为0。</p>
<p>E: 1 bit 当设置成1, 结束位指示分片NAL单元的结束，即, 荷载的最后字节也是分片NAL单元的最后一个字节。当跟随的 FU荷载不是分片NAL单元的最后分片,结束位设置为0。</p>
<p>R: 1 bit 保留位必须设置为0，接收者必须忽略该位</p>
<p>打包时，原始的NAL头的前三位为FU indicator的前三位，原始的NAL头的后五位为FU header的后五位。</p>
<p>使用Wireshark抓一段码流进行分析</p>
<p>前12字节是RTP Header<br>7c是FU indicator<br>85是FU Header<br>FU indicator（0x7C）和FU Header（0x85）换成二进制如下<br>0111 1100 1000 0101</p>
<p>按顺序解析如下：</p>
<p>0                            是F</p>
<p>11                          是NRI</p>
<p>11100                    是FU Type，这里是28，即FU-A</p>
<p>1                            是S，Start，说明是分片的第一包</p>
<p>0                            是E，End，如果是分片的最后一包，设置为1，这里不是</p>
<p>0                            是R，Remain，保留位，总是0</p>
<p>00101                   是NAl Type，这里是5，说明是关键帧（不知道为什么是关键帧请自行谷歌）</p>
<p>打包时，FUindicator的F、NRI是NAL Header中的NRI，Type是28；FU Header的S、E、R分别按照分片起始位置设置，Type是NAL Header中的Type。</p>
<p>解包时，取FU indicator的前三位和FU Header的后五位，即0110 0101（0x65）为NAL类型（即I帧）。</p>
<p>Refrences:</p>
<p><a href="http://blog.csdn.net/machh/article/details/52165292">http://blog.csdn.net/machh/article/details/52165292</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>header</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/header/</url>
    <content><![CDATA[<p>header(‘Content-Type: text/plain; charset=utf-8’);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>hide Google apps by Settings</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/hide%20Google%20apps%20by%20Settings/</url>
    <content><![CDATA[<p>diff –git a/res/values/strings.xml b/res/values/strings.xml</p>
<p>index c2da3df..5c54597 100755</p>
<p>— a/res/values/strings.xml</p>
<p>+++ b/res/values/strings.xml</p>
<p>@@ -5010,4 +5010,6 @@</p>
<p>                 &lt;string name=&quot;set_resolution_failed_message&quot;&gt;Failed to change display mode.&lt;/string&gt;</p>
<p>                 &lt;string name=&quot;dlg_confirm_reboot_title&quot;&gt;Reboot&lt;/string&gt;</p>
<p>                 &lt;string name=&quot;dlg_confirm_reboot_text&quot;&gt;System will reboot to change display mode.&lt;/string&gt;</p>
<p>+</p>
<ul>
<li>               &lt;string name=&quot;hide_goolge_apps_title&quot;&gt;Hidden Google application&lt;/string&gt;</li>
</ul>
<p> &lt;/resources&gt;</p>
<p>diff –git a/res/xml/display_settings.xml b/res/xml/display_settings.xml</p>
<p>index 639c758..768c46d 100644</p>
<p>— a/res/xml/display_settings.xml</p>
<p>+++ b/res/xml/display_settings.xml</p>
<p>@@ -56,7 +56,12 @@</p>
<p>             android:key=&quot;notification_pulse&quot;</p>
<p>             android:title=&quot;@string/notification_pulse_title&quot;</p>
<p>             android:persistent=&quot;false&quot; /&gt;</p>
<p>-</p>
<p>+</p>
<ul>
<li><p>              &lt;CheckBoxPreference</p>
</li>
<li><p>           android:key=&quot;hide_google_apps&quot;</p>
</li>
<li><p>           android:title=&quot;@string/hide_goolge_apps_title&quot;</p>
</li>
<li><p>           android:persistent=&quot;true&quot; /&gt;</p>
</li>
</ul>
<p>+</p>
<p>         &lt;PreferenceScreen</p>
<p>                 android:key=&quot;wifi_display&quot;</p>
<p>                 android:title=&quot;@string/wifi_display_settings_title&quot;</p>
<p>diff –git a/src/com/android/settings/DisplaySettings.java b/src/com/android/settings/DisplaySettings.java</p>
<p>index 5875bf5..e76e8f3 100644</p>
<p>— a/src/com/android/settings/DisplaySettings.java</p>
<p>+++ b/src/com/android/settings/DisplaySettings.java</p>
<p>@@ -35,7 +35,7 @@ import android.preference.PreferenceScreen;</p>
<p> import android.provider.Settings;</p>
<p> import android.provider.Settings.SettingNotFoundException;</p>
<p> import android.util.Log;</p>
<p>-</p>
<p>+import java.util.List;</p>
<p> import com.android.internal.view.RotationPolicy;</p>
<p> import com.android.settings.DreamSettings;</p>
<p>@@ -52,12 +52,14 @@ import java.io.InputStreamReader;</p>
<p> import java.util.Scanner;</p>
<p> import java.util.LinkedList;</p>
<p> import android.os.SystemProperties;</p>
<p>-</p>
<p>+import android.content.pm.PackageManager;</p>
<p> import android.widget.Toast;</p>
<p> import android.os.PowerManager;</p>
<p> import android.app.AlertDialog;</p>
<p> import android.app.Dialog;</p>
<p> import android.content.DialogInterface;</p>
<p>+import android.content.pm.PackageInfo;</p>
<p>+</p>
<p> public class DisplaySettings extends SettingsPreferenceFragment implements</p>
<p>         Preference.OnPreferenceChangeListener, OnPreferenceClickListener {</p>
<p>     private static final String TAG = &quot;DisplaySettings&quot;;</p>
<p>@@ -70,13 +72,15 @@ public class DisplaySettings extends SettingsPreferenceFragment implements</p>
<p>     private static final String KEY_FONT_SIZE = &quot;font_size&quot;;</p>
<p>     private static final String KEY_NOTIFICATION_PULSE = &quot;notification_pulse&quot;;</p>
<p>     private static final String KEY_SCREEN_SAVER = &quot;screensaver&quot;;</p>
<ul>
<li>      private static final String KEY_HIDE_GOOGLE_APPS = &quot;hide_google_apps&quot;;</li>
</ul>
<p>     private static final int DLG_GLOBAL_CHANGE_WARNING = 1;</p>
<p>     private CheckBoxPreference mAccelerometer;</p>
<p>     private WarnedListPreference mFontSizePref;</p>
<p>     private CheckBoxPreference mNotificationPulse;</p>
<p>-</p>
<ul>
<li>      private CheckBoxPreference mHideGoogleApps;</li>
</ul>
<p>+</p>
<p>     private final Configuration mCurConfig = new Configuration();</p>
<p>     private ListPreference mScreenTimeoutPreference;</p>
<p>@@ -242,6 +246,9 @@ public class DisplaySettings extends SettingsPreferenceFragment implements</p>
<p>         mAccelerometer = (CheckBoxPreference) findPreference(KEY_ACCELEROMETER);</p>
<p>         mAccelerometer.setPersistent(false);</p>
<p>+</p>
<ul>
<li>              mHideGoogleApps = (CheckBoxPreference) findPreference(KEY_HIDE_GOOGLE_APPS);</li>
</ul>
<p>+</p>
<p>         if (!RotationPolicy.isRotationSupported(getActivity())</p>
<p>                 || RotationPolicy.isRotationLockToggleSupported(getActivity())) {</p>
<p>             // If rotation lock is supported, then we do not provide this option in</p>
<p>@@ -465,10 +472,44 @@ public class DisplaySettings extends SettingsPreferenceFragment implements</p>
<p>             Settings.System.putInt(getContentResolver(), Settings.System.NOTIFICATION_LIGHT_PULSE,</p>
<p>                     value ? 1 : 0);</p>
<p>             return true;</p>
<ul>
<li>       }</li>
</ul>
<ul>
<li><p>       }else if(preference == mHideGoogleApps){</p>
</li>
<li><p>                      PackageManager pm = getPackageManager();</p>
</li>
<li><p>                      boolean isHidden = mHideGoogleApps.isChecked();</p>
</li>
<li><p>                      setApplicationEnabled( new String []</p>
</li>
<li><p>                      {&quot;com.android.vending&quot;,</p>
</li>
<li><p>                      &quot;com.google.android.gm&quot;},</p>
</li>
<li><p>                      !isHidden,pm);</p>
</li>
</ul>
<p>+</p>
<ul>
<li>              }</li>
</ul>
<p>         return super.onPreferenceTreeClick(preferenceScreen, preference);</p>
<p>     }</p>
<p>-</p>
<p>+</p>
<ul>
<li><p>       private void setApplicationEnabled(String packageName[], boolean enable,</p>
</li>
<li><p>             PackageManager pm) {</p>
</li>
<li><p>                        for (int i = 0, j = packageName.length; i &lt; j; i++) {</p>
</li>
<li><p>                                if (isPackageInstalled(packageName[i], pm)) {</p>
</li>
<li><p>                                        pm.setApplicationEnabledSetting(</p>
</li>
<li><p>                                                        packageName[i],</p>
</li>
<li><p>                                                        enable ? PackageManager.COMPONENT_ENABLED_STATE_DEFAULT</p>
</li>
<li><p>                                                        : PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER,</p>
</li>
<li><p>                                                        PackageManager.DONT_KILL_APP);</p>
</li>
<li><p>                                }</p>
</li>
<li><p>                        }</p>
</li>
<li><p>       }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>        private boolean isPackageInstalled(String packageName, PackageManager pm) {</p>
</li>
<li><p>                       List&lt;PackageInfo&gt; installedList = pm</p>
</li>
<li><p>                               .getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);</p>
</li>
<li><p>                       int installedListSize = installedList.size();</p>
</li>
<li><p>                      for (int i = 0; i &lt; installedListSize; i++) {</p>
</li>
<li><p>                                           PackageInfo tmp = installedList.get(i);</p>
</li>
<li><p>                                           if (packageName.equalsIgnoreCase(tmp.packageName)) {</p>
</li>
<li><p>                                                               return true;</p>
</li>
<li><p>                                                           }</p>
</li>
<li><p>                      }</p>
</li>
<li><p>                      return false;</p>
</li>
<li><p>       }</p>
</li>
</ul>
<p>+</p>
<p>     @Override</p>
<p>     public boolean onPreferenceChange(Preference preference, Object objValue) {</p>
<p>         final String key = preference.getKey();</p>
<p>(END)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>hz4g 服务器配置</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/hz4g%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>home/program/carassist</p>
<p>mydata/golanglog/forum.log</p>
<p> /mydata/golanglog/forum.err</p>
<p>sudo supervisorctl restart forum</p>
<p>mydata/golanglog/forumserver/carassist.INFO</p>
<p>mysqldump -ucarassist -pcarassist –all-databases &gt; /home/ftptest/db.sql</p>
<p>/etc/supervisor/conf.d/carassist.conf</p>
<p>/etc/supervisor/supervisord.conf</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>iPhone各种机型尺寸、屏幕分辨率</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/iPhone%E5%90%84%E7%A7%8D%E6%9C%BA%E5%9E%8B%E5%B0%BA%E5%AF%B8%E3%80%81%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87/</url>
    <content><![CDATA[<p>px与pt区别</p>
<p>字体大小的设置单位，常用的有2种：px、pt。这两个有什么区别呢？</p>
<p>先搞清基本概念：</p>
<p>px就是表示pixel，像素，是屏幕上显示数据的最基本的点；</p>
<p>pt就是point，是印刷行业常用单位，等于1/72英寸。</p>
<p>px全称为pixel，是一个点，它不是自然界的长度单位，谁能说出一个“点”有多长多大么？可以画的很小，也可以很大。如果点很小，那画面就清晰，我们称它为“分辨率高”，反之，就是“分辨率低”。所以，“点”的大小是会“变”的，也称为“相对长度”。</p>
<p>pt全称为point，但中文不叫“点”，查金山词霸可以看到，确切的说法是一个专用的印刷单位“磅”，大小为1/72英寸。所以它是一个自然界标准的长度单位，也称为“绝对长度”。</p>
<p>因此就有这样的说法:</p>
<p>pixel是相对大小，</p>
<p>point是绝对大小。</p>
<p>iPhone各种屏幕分辨率</p>
<p>设备屏幕尺寸分辨率（pt）Reader分辨率（px）渲染后PPI</p>
<p>iPhone 3GS3.5吋320x480@1x320x480<br>163</p>
<p>iPhone 4/4s3.5吋320x480@2x640x960<br>330</p>
<p>iPhone 5/5s/5c4.0吋320x568@2x640x1136<br>326</p>
<p>iPhone 64.7吋375x667@2x750x1334<br>326</p>
<p>iPhone 6Plus5.5吋414x736@3x1242x22081080x1920401</p>
<p>iPhone 6s4.7吋375x667@2x750x1334<br>326</p>
<p>iPhone 6sPlus5.5吋414x736@3x1242x22081080x1920401</p>
<p>iPhone 74.7吋375x667@2x750x1334<br>326</p>
<p>iPhone 7Plus5.5吋414x736@3x1242x22081080x1920401</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>input button链接方法</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/input%20button%E9%93%BE%E6%8E%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>input /button链接方法</p>
<p>自己总结了一下常用到的Button链接,代码如下:</p>
<p>1.链接到某页<br>&lt;input type=&quot;button&quot; name=&quot;Submit&quot; value=&quot;确 定&quot; class=&quot;btn&quot; onclick=&quot;location.href=’filename.html’&quot; /&gt;<br>2.返回(等同后退) <br>&lt;input name=&quot;Submit2&quot; type=&quot;button&quot; class=&quot;btn&quot; onclick=&quot;location.href=’javascript:history.go(-1);’&quot; value=&quot;返 回&quot; /&gt;<br>3.打开新网页<br>&lt;input type=&quot;button&quot; name=&quot;Submit2&quot; value=&quot;确 定&quot; class=&quot;btn&quot; onclick=&quot;window.open(‘filename.html’)&quot; /&gt;<br>4.打开无边框的新窗口<br>&lt;input type=&quot;button&quot; name=&quot;Submit2&quot; value=&quot;确 定&quot; class=&quot;btn&quot; onclick=&quot;javascript:window.open(‘filename.html’,’’,’width=720,height=500,resizable=yes,scrollbars=yes,status=no’)&quot; /&gt;<br>5.打开新网页同时指向另一页<br>&lt;input type=&quot;button&quot; name=&quot;Submit2&quot; value=&quot;确 定&quot; class=&quot;btn&quot; onclick=&quot;window.open(‘filename.html’);location.href=’<a href="http://hi.baidu.com/harryxue&#39;">http://hi.baidu.com/harryxue&#39;</a>&quot; /&gt;<br>6.打开无边框的新窗口同时指向另一页<br>&lt;input type=&quot;button&quot; name=&quot;Submit2&quot; value=&quot;确 定&quot; class=&quot;btn&quot; onclick=&quot;javascript:window.open(‘<a href="http://hi.baidu.com/harryxue&#39;,&#39;&#39;,&#39;width=720,height=500,resizable=yes,scrollbars=yes,status=no&#39;">http://hi.baidu.com/harryxue&#39;,&#39;&#39;,&#39;width=720,height=500,resizable=yes,scrollbars=yes,status=no&#39;</a>); window.location=’filename.html’;&quot; /&gt; </p>
<p>7.点击按钮弹出确认alert窗口<br>方式一：<br>&lt;input type=&quot;button&quot; name=&quot;Submit1&quot; value=&quot;确定&quot; class=&quot;btn&quot; <br>onClick=&quot;alert(‘是否确认提交？’);location.href= ‘filename.html’;return false;&quot; &gt;<br>方式二：<br>&lt;input type=&quot;button&quot; name=&quot;Submit2&quot; value=&quot;确定&quot; class=&quot;btn&quot; <br>onClick=&quot;if (confirm(‘是否确认提交？’))location.href= ‘filename.html’;return false;&quot; &gt;   </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>jarsigner 查看签名信息</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/jarsigner%20%E6%9F%A5%E7%9C%8B%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>jarsigner.exe -verify -verbose -certs filename.xx</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>java -jar baksmali-2</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/java%20-jar%20baksmali-2.2.1.jar%20x%20android.p/</url>
    <content><![CDATA[<p>java -jar baksmali-2.2.1.jar x android.policy.odex -d classpath</p>
<p>java -jar smali-2.1.2.jar out -o pclasses.dex</p>
<p>dexopt-wrapper /system/framework/android.policy.jar /system/framework/new_android.policy.odex $BOOTCLASSPATH</p>
<p>busybox dd if=/system/framework/android.policy.odex of=/system/framework/new_android.policy.odex bs=1 count=20 skip=52 seek=52 conv=notrunc</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>java 读取文件</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/java%20%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>public class ReadFromFile {</p>
<p>    /**</p>
<p>     * 以字节为单位读取文件，常用于读二进制文件，如图片、声音、影像等文件。</p>
<p>     */</p>
<p>    public static void readFileByBytes(String fileName) {</p>
<p>        File file = new File(fileName);</p>
<p>        InputStream in = null;</p>
<p>        try {</p>
<p>            System.out.println(&quot;以字节为单位读取文件内容，一次读一个字节：&quot;);</p>
<p>            // 一次读一个字节</p>
<p>            in = new FileInputStream(file);</p>
<p>            int tempbyte;</p>
<p>            while ((tempbyte = in.read()) != -1) {</p>
<p>                System.out.write(tempbyte);</p>
<p>            }</p>
<p>            in.close();</p>
<p>        } catch (IOException e) {</p>
<p>            e.printStackTrace();</p>
<p>            return;</p>
<p>        }</p>
<p>        try {</p>
<p>            System.out.println(&quot;以字节为单位读取文件内容，一次读多个字节：&quot;);</p>
<p>            // 一次读多个字节</p>
<p>            byte[] tempbytes = new byte[100];</p>
<p>            int byteread = 0;</p>
<p>            in = new FileInputStream(fileName);</p>
<p>            ReadFromFile.showAvailableBytes(in);</p>
<p>            // 读入多个字节到字节数组中，byteread为一次读入的字节数</p>
<p>            while ((byteread = in.read(tempbytes)) != -1) {</p>
<p>                System.out.write(tempbytes, 0, byteread);</p>
<p>            }</p>
<p>        } catch (Exception e1) {</p>
<p>            e1.printStackTrace();</p>
<p>        } finally {</p>
<p>            if (in != null) {</p>
<p>                try {</p>
<p>                    in.close();</p>
<p>                } catch (IOException e1) {</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    /**</p>
<p>     * 以字符为单位读取文件，常用于读文本，数字等类型的文件</p>
<p>     */</p>
<p>    public static void readFileByChars(String fileName) {</p>
<p>        File file = new File(fileName);</p>
<p>        Reader reader = null;</p>
<p>        try {</p>
<p>            System.out.println(&quot;以字符为单位读取文件内容，一次读一个字节：&quot;);</p>
<p>            // 一次读一个字符</p>
<p>            reader = new InputStreamReader(new FileInputStream(file));</p>
<p>            int tempchar;</p>
<p>            while ((tempchar = reader.read()) != -1) {</p>
<p>                // 对于windows下，\r\n这两个字符在一起时，表示一个换行。</p>
<p>                // 但如果这两个字符分开显示时，会换两次行。</p>
<p>                // 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。</p>
<p>                if (((char) tempchar) != ‘\r’) {</p>
<p>                    System.out.print((char) tempchar);</p>
<p>                }</p>
<p>            }</p>
<p>            reader.close();</p>
<p>        } catch (Exception e) {</p>
<p>            e.printStackTrace();</p>
<p>        }</p>
<p>        try {</p>
<p>            System.out.println(&quot;以字符为单位读取文件内容，一次读多个字节：&quot;);</p>
<p>            // 一次读多个字符</p>
<p>            char[] tempchars = new char[30];</p>
<p>            int charread = 0;</p>
<p>            reader = new InputStreamReader(new FileInputStream(fileName));</p>
<p>            // 读入多个字符到字符数组中，charread为一次读取字符数</p>
<p>            while ((charread = reader.read(tempchars)) != -1) {</p>
<p>                // 同样屏蔽掉\r不显示</p>
<p>                if ((charread == tempchars.length)</p>
<p>                        &amp;&amp; (tempchars[tempchars.length - 1] != ‘\r’)) {</p>
<p>                    System.out.print(tempchars);</p>
<p>                } else {</p>
<p>                    for (int i = 0; i &lt; charread; i++) {</p>
<p>                        if (tempchars[i] == ‘\r’) {</p>
<p>                            continue;</p>
<p>                        } else {</p>
<p>                            System.out.print(tempchars[i]);</p>
<p>                        }</p>
<p>                    }</p>
<p>                }</p>
<p>            }</p>
<p>        } catch (Exception e1) {</p>
<p>            e1.printStackTrace();</p>
<p>        } finally {</p>
<p>            if (reader != null) {</p>
<p>                try {</p>
<p>                    reader.close();</p>
<p>                } catch (IOException e1) {</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    /**</p>
<p>     * 以行为单位读取文件，常用于读面向行的格式化文件</p>
<p>     */</p>
<p>    public static void readFileByLines(String fileName) {</p>
<p>        File file = new File(fileName);</p>
<p>        BufferedReader reader = null;</p>
<p>        try {</p>
<p>            System.out.println(&quot;以行为单位读取文件内容，一次读一整行：&quot;);</p>
<p>            reader = new BufferedReader(new FileReader(file));</p>
<p>            String tempString = null;</p>
<p>            int line = 1;</p>
<p>            // 一次读入一行，直到读入null为文件结束</p>
<p>            while ((tempString = reader.readLine()) != null) {</p>
<p>                // 显示行号</p>
<p>                System.out.println(&quot;line &quot; + line + &quot;: &quot; + tempString);</p>
<p>                line++;</p>
<p>            }</p>
<p>            reader.close();</p>
<p>        } catch (IOException e) {</p>
<p>            e.printStackTrace();</p>
<p>        } finally {</p>
<p>            if (reader != null) {</p>
<p>                try {</p>
<p>                    reader.close();</p>
<p>                } catch (IOException e1) {</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    /**</p>
<p>     * 随机读取文件内容</p>
<p>     */</p>
<p>    public static void readFileByRandomAccess(String fileName) {</p>
<p>        RandomAccessFile randomFile = null;</p>
<p>        try {</p>
<p>            System.out.println(&quot;随机读取一段文件内容：&quot;);</p>
<p>            // 打开一个随机访问文件流，按只读方式</p>
<p>            randomFile = new RandomAccessFile(fileName, &quot;r&quot;);</p>
<p>            // 文件长度，字节数</p>
<p>            long fileLength = randomFile.length();</p>
<p>            // 读文件的起始位置</p>
<p>            int beginIndex = (fileLength &gt; 4) ? 4 : 0;</p>
<p>            // 将读文件的开始位置移到beginIndex位置。</p>
<p>            randomFile.seek(beginIndex);</p>
<p>            byte[] bytes = new byte[10];</p>
<p>            int byteread = 0;</p>
<p>            // 一次读10个字节，如果文件内容不足10个字节，则读剩下的字节。</p>
<p>            // 将一次读取的字节数赋给byteread</p>
<p>            while ((byteread = randomFile.read(bytes)) != -1) {</p>
<p>                System.out.write(bytes, 0, byteread);</p>
<p>            }</p>
<p>        } catch (IOException e) {</p>
<p>            e.printStackTrace();</p>
<p>        } finally {</p>
<p>            if (randomFile != null) {</p>
<p>                try {</p>
<p>                    randomFile.close();</p>
<p>                } catch (IOException e1) {</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    /**</p>
<p>     * 显示输入流中还剩的字节数</p>
<p>     */</p>
<p>    private static void showAvailableBytes(InputStream in) {</p>
<p>        try {</p>
<p>            System.out.println(&quot;当前字节输入流中的字节数为:&quot; + in.available());</p>
<p>        } catch (IOException e) {</p>
<p>            e.printStackTrace();</p>
<p>        }</p>
<p>    }</p>
<p>    public static void main(String[] args) {</p>
<p>        String fileName = &quot;C:/temp/newTemp.txt&quot;;</p>
<p>        ReadFromFile.readFileByBytes(fileName);</p>
<p>        ReadFromFile.readFileByChars(fileName);</p>
<p>        ReadFromFile.readFileByLines(fileName);</p>
<p>        ReadFromFile.readFileByRandomAccess(fileName);</p>
<p>    }</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>kernel version 内核版本号</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/kernel%20version%20%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>/*</p>
<p> *  linux/init/version.c</p>
<p> *</p>
<p> *  Copyright (C) 1992  Theodore Ts’o</p>
<p> *</p>
<p> *  May be freely distributed as part of Linux.</p>
<p> */</p>
<p>#include &lt;generated/compile.h&gt;</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/uts.h&gt;</p>
<p>#include &lt;linux/utsname.h&gt;</p>
<p>#include &lt;generated/utsrelease.h&gt;</p>
<p>#include &lt;linux/version.h&gt;</p>
<p>#ifndef CONFIG_KALLSYMS</p>
<p>#define version(a) Version_ ## a</p>
<p>#define version_string(a) version(a)</p>
<p>extern int version_string(LINUX_VERSION_CODE);</p>
<p>int version_string(LINUX_VERSION_CODE);</p>
<p>#endif</p>
<p>#define UTS_VERSION1 &quot;#1 Thu Apr 11 13:43:52 CST 2013&quot;</p>
<p>#define LINUX_COMPILE_BY1 &quot;builder&quot;</p>
<p>#define LINUX_COMPILE_HOST1 &quot;server&quot;</p>
<p>struct uts_namespace init_uts_ns = {</p>
<p>.kref = {</p>
<p>.refcount = ATOMIC_INIT(2),</p>
<p>},</p>
<p>.name = {</p>
<p>.sysname = UTS_SYSNAME,</p>
<p>.nodename = UTS_NODENAME,</p>
<p>.release = UTS_RELEASE,</p>
<p>.version = UTS_VERSION1,</p>
<p>.machine = UTS_MACHINE,</p>
<p>.domainname = UTS_DOMAINNAME,</p>
<p>},</p>
<p>.user_ns = &amp;init_user_ns,</p>
<p>};</p>
<p>EXPORT_SYMBOL_GPL(init_uts_ns);</p>
<p>/* FIXED STRINGS! Don’t touch! */</p>
<p>const char linux_banner[] =</p>
<p>&quot;Linux version &quot; UTS_RELEASE &quot; (&quot; LINUX_COMPILE_BY1 &quot;@&quot;</p>
<p>LINUX_COMPILE_HOST1 &quot;) (&quot; LINUX_COMPILER &quot;) &quot; UTS_VERSION1 &quot;\n&quot;;</p>
<p>const char linux_proc_banner[] =</p>
<p>&quot;%s version %s&quot;</p>
<p>&quot; (&quot; LINUX_COMPILE_BY1 &quot;@&quot; LINUX_COMPILE_HOST1 &quot;)&quot;</p>
<p>&quot; (&quot; LINUX_COMPILER &quot;) %s\n&quot;;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>keychain</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/keychain/</url>
    <content><![CDATA[<p>1.什么是keychain ?<br>简单说，keychain就是一个脚本，可以自动的帮你找到你上回登陆时候启动的ssh-agent进程，从而可以继续使用已经存在该agent里的key，去登陆其他的机器。<br>多说一句ssh-agent就是存你passphrase的后台进程。<br>如果你使用有passphrase的key，自然就不会用到ssh-agent,也就不会用到keychain了。<br>如果你想要深入了解keychain的工作原理，你可以找找ssh-agent的文档和keychain的文档看看，如果你只想快速的达到无需口令的使用ssh，那么就直接装上keychain，用就是了。<br>keychain的主页：<br><a href="http://www.gentoo.org/proj/en/keychain/">http://www.gentoo.org/proj/en/keychain/</a> </p>
<p>sudo apt-get install keychain</p>
<p>eval <code>keychain --eval ~/.ssh/id_rsa</code></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>kitkat-x86 源码下载</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/kitkat-x86%20%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>mkdir ~/bin</p>
<p>PATH=~/bin:$PATH<br>curl <a href="https://storage.googleapis.com/git-repo-downloads/repo">https://storage.googleapis.com/git-repo-downloads/repo</a> &gt; ~/bin/repo</p>
<h2 id="如果上述-URL-不可访问，可以用下面的："><a href="#如果上述-URL-不可访问，可以用下面的：" class="headerlink" title="如果上述 URL 不可访问，可以用下面的："></a>如果上述 URL 不可访问，可以用下面的：</h2><h2 id="curl-https-storage-googleapis-proxy-ustclug-org-git-repo-downloads-repo-gt-bin-repo"><a href="#curl-https-storage-googleapis-proxy-ustclug-org-git-repo-downloads-repo-gt-bin-repo" class="headerlink" title="curl https://storage-googleapis.proxy.ustclug.org/git-repo-downloads/repo &gt; ~/bin/repo"></a>curl <a href="https://storage-googleapis.proxy.ustclug.org/git-repo-downloads/repo">https://storage-googleapis.proxy.ustclug.org/git-repo-downloads/repo</a> &gt; ~/bin/repo</h2><p>chmod a+x ~/bin/repo</p>
<p>$ mkdir android-x86<br>$ cd android-x86<br>$ repo init -u git://gitscm.sf.net/gitroot/android-x86/manifest -b kitkat-x86 <br>$ repo sync</p>
<p>**note：由于网络原因国内的访问不了google的仓库，所以上面的repo命令（一个Python脚本封装了git的命令）中的 <br>REPO_URL = ‘<a href="https://gerrit.googlesource.com/git-repo%E2%80%98%E6%94%B9%E4%B8%BA">https://gerrit.googlesource.com/git-repo‘改为</a> <br>REPO_URL = ‘git://git.omapzoom.org/git-repo.git’</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>lanucher2 workspace 行列分布</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/lanucher2%20workspace%20%E8%A1%8C%E5%88%97%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Launcher2/res/layout-sw720dp/workspace.xml b/packages/apps/Launcher2/res/layout-sw720dp/workspace.xml</p>
<p>index 5658a4b..56a30b8 100644</p>
<p>— a/packages/apps/Launcher2/res/layout-sw720dp/workspace.xml</p>
<p>+++ b/packages/apps/Launcher2/res/layout-sw720dp/workspace.xml</p>
<p>@@ -24,6 +24,8 @@</p>
<p>     android:paddingTop=&quot;@dimen/workspace_top_padding&quot;</p>
<p>     android:paddingBottom=&quot;@dimen/workspace_bottom_padding&quot;</p>
<p>     launcher:defaultScreen=&quot;2&quot;</p>
<ul>
<li><p>   launcher:cellCountX=&quot;@integer/cell_count_x&quot;</p>
</li>
<li><p>   launcher:cellCountY=&quot;@integer/cell_count_y&quot;</p>
</li>
</ul>
<p>     launcher:pageSpacing=&quot;@dimen/workspace_page_spacing&quot;&gt;</p>
<p>       &lt;include android:id=&quot;@+id/cell1&quot; layout=&quot;@layout/workspace_screen&quot; /&gt;</p>
<p>       &lt;include android:id=&quot;@+id/cell2&quot; layout=&quot;@layout/workspace_screen&quot; /&gt;</p>
<p>diff –git a/packages/apps/Launcher2/res/values-sw720dp-land/dimens.xml b/packages/apps/Launcher2/res/values-sw720dp-land/dimens.xml</p>
<p>index 8252450..5ddf9b3 100644</p>
<p>— a/packages/apps/Launcher2/res/values-sw720dp-land/dimens.xml</p>
<p>+++ b/packages/apps/Launcher2/res/values-sw720dp-land/dimens.xml</p>
<p>@@ -37,4 +37,6 @@</p>
<p>     &lt;!– The offset for the text in the cling –&gt;</p>
<p>     &lt;dimen name=&quot;cling_text_block_offset_x&quot;&gt;140dp&lt;/dimen&gt;</p>
<p>     &lt;dimen name=&quot;cling_text_block_offset_y&quot;&gt;80dp&lt;/dimen&gt;</p>
<ul>
<li><p>   &lt;integer name=&quot;cell_count_x&quot;&gt;8&lt;/integer&gt;</p>
</li>
<li><p>   &lt;integer name=&quot;cell_count_y&quot;&gt;6&lt;/integer&gt;</p>
</li>
</ul>
<p> &lt;/resources&gt;</p>
<p>diff –git a/packages/apps/Launcher2/res/values-sw720dp-port/dimens.xml b/packages/apps/Launcher2/res/values-sw720dp-port/dimens.xml</p>
<p>index fbc0799..cd24d02 100644</p>
<p>— a/packages/apps/Launcher2/res/values-sw720dp-port/dimens.xml</p>
<p>+++ b/packages/apps/Launcher2/res/values-sw720dp-port/dimens.xml</p>
<p>@@ -18,10 +18,10 @@</p>
<p> &lt;!– AppsCustomize –&gt;</p>
<p>     &lt;integer name=&quot;apps_customize_maxCellCountX&quot;&gt;-1&lt;/integer&gt;</p>
<p>     &lt;integer name=&quot;apps_customize_maxCellCountY&quot;&gt;7&lt;/integer&gt;</p>
<ul>
<li><p>   &lt;dimen name=&quot;apps_customize_pageLayoutWidthGap&quot;&gt;36dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;apps_customize_pageLayoutHeightGap&quot;&gt;36dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;apps_customize_pageLayoutPaddingLeft&quot;&gt;24dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;apps_customize_pageLayoutPaddingRight&quot;&gt;24dp&lt;/dimen&gt;</p>
</li>
</ul>
<ul>
<li><p>   &lt;dimen name=&quot;apps_customize_pageLayoutWidthGap&quot;&gt;15dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;apps_customize_pageLayoutHeightGap&quot;&gt;35dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;apps_customize_pageLayoutPaddingLeft&quot;&gt;0dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;apps_customize_pageLayoutPaddingRight&quot;&gt;0dp&lt;/dimen&gt;</p>
</li>
</ul>
<p>     &lt;!– We can also afford to have a slightly wider portrait layout in</p>
<p>          xlarge –&gt;</p>
<p>     &lt;integer name=&quot;apps_customize_widget_cell_count_x&quot;&gt;3&lt;/integer&gt;</p>
<p>@@ -57,4 +57,6 @@</p>
<p>     &lt;!– The offset for the text in the cling –&gt;</p>
<p>     &lt;dimen name=&quot;cling_text_block_offset_x&quot;&gt;80dp&lt;/dimen&gt;</p>
<p>     &lt;dimen name=&quot;cling_text_block_offset_y&quot;&gt;160dp&lt;/dimen&gt;</p>
<ul>
<li><p>   &lt;integer name=&quot;cell_count_x&quot;&gt;8&lt;/integer&gt;</p>
</li>
<li><p>   &lt;integer name=&quot;cell_count_y&quot;&gt;6&lt;/integer&gt;</p>
</li>
</ul>
<p> &lt;/resources&gt;</p>
<p>diff –git a/packages/apps/Launcher2/res/values-sw720dp/dimens.xml b/packages/apps/Launcher2/res/values-sw720dp/dimens.xml</p>
<p>index 439709a..148ee56 100755</p>
<p>— a/packages/apps/Launcher2/res/values-sw720dp/dimens.xml</p>
<p>+++ b/packages/apps/Launcher2/res/values-sw720dp/dimens.xml</p>
<p>@@ -43,8 +43,8 @@</p>
<p>     &lt;dimen name=&quot;search_bar_height&quot;&gt;52dp&lt;/dimen&gt;</p>
<p> &lt;!– AppsCustomize –&gt;</p>
<ul>
<li><p>   &lt;dimen name=&quot;apps_customize_cell_width&quot;&gt;96dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;apps_customize_cell_height&quot;&gt;96dp&lt;/dimen&gt;</p>
</li>
</ul>
<ul>
<li><p>   &lt;dimen name=&quot;apps_customize_cell_width&quot;&gt;106dp&lt;/dimen&gt;</p>
</li>
<li><p>   &lt;dimen name=&quot;apps_customize_cell_height&quot;&gt;106dp&lt;/dimen&gt;</p>
</li>
</ul>
<p>     &lt;integer name=&quot;apps_customize_maxCellCountX&quot;&gt;-1&lt;/integer&gt;</p>
<p>     &lt;integer name=&quot;apps_customize_maxCellCountY&quot;&gt;-1&lt;/integer&gt;</p>
<p>     &lt;dimen name=&quot;all_apps_button_vertical_padding&quot;&gt;4dip&lt;/dimen&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>latin subtypes 默认输入法 长按latin空格键默认显示</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/latin%20subtypes%20%E9%BB%98%E8%AE%A4%E8%BE%93%E5%85%A5%E6%B3%95%20%E9%95%BF%E6%8C%89latin%E7%A9%BA%E6%A0%BC%E9%94%AE%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>1.。。。</p>
<p>bug:</p>
<p> 1. 需要进入设置-》语言才生效</p>
<p> 2. 第一个不生效？english_us ?</p>
<p>enabledInputMethodsStr:=com.android.inputmethod.latin/.LatinIME;843948332;774684257;-2066550842:com.google.android.googlequicksearchbox/com.google.android.voicesearch.ime.VoiceInputMethodService</p>
<p>private void enableInputMethod() {</p>
<p>        String defaultInputMethod = SystemProperties.get(&quot;ro.bx.inputmethod&quot;, &quot;&quot;);</p>
<p>        if(!defaultInputMethod.equals(&quot;&quot;)){</p>
<p>                String enableMethod = Settings.Secure.getString(getContentResolver(),</p>
<p>                                Settings.Secure.ENABLED_INPUT_METHODS);</p>
<p>                Settings.Secure.putString(getContentResolver(),</p>
<p>                                Settings.Secure.ENABLED_INPUT_METHODS, enableMethod + &quot;:&quot; + defaultInputMethod);</p>
<p>                                        // + &quot;com.android.inputmethod.pinyin/.PinyinIME&quot;);</p>
<p>                }</p>
<p>        }</p>
<p>新的方法；终于解决了。</p>
<p>// 另外 InputMethodSettingValuesWrapper.java(从Settings中取出)</p>
<p>// 在 build.prop 中定义 如 ro.bx.latinsubtypes=es;en_US  即可</p>
<p>import java.util.HashMap;<br>import java.util.List;<br>import android.view.inputmethod.InputMethodInfo;<br>import android.content.ContentResolver;<br>import java.util.HashSet;<br>import android.util.Log;<br>import android.view.inputmethod.InputMethodSubtype;<br>import android.text.TextUtils;<br>import android.provider.Settings;<br>import android.os.SystemProperties;</p>
<pre><code>private InputMethodSettingValuesWrapper mInputMethodSettingValues;
static final String TAG = &amp;quot;edward&amp;quot;;
private static final char INPUT_METHOD_SEPARATER = &#39;:&#39;;
private static final char INPUT_METHOD_SUBTYPE_SEPARATER = &#39;;&#39;;
private static final int NOT_A_SUBTYPE_ID = -1;

private static final TextUtils.SimpleStringSplitter sStringInputMethodSplitter
        = new TextUtils.SimpleStringSplitter(INPUT_METHOD_SEPARATER);

private static final TextUtils.SimpleStringSplitter sStringInputMethodSubtypeSplitter
        = new TextUtils.SimpleStringSplitter(INPUT_METHOD_SUBTYPE_SEPARATER);</code></pre>
<p>/*  just for local below<br>    LatinLME Subtypes List: en_US,en_GB,af,ar,be,bg,bg,ca,cs,da,de,el,eo,es,es_US,et_EE,fa,fi,fr,fr_CA,<br>    hi,hr,hu,hy_AM,in,is,it,iw,ka_GE,km_KH,ky,lo_LA,lt,lv,mk,mn_MN,ms_MY,nb,nl,nl_BE,pl,pt_BR,pt_PT,ro,<br>    ru,sk,sl,sr,sv,sw,th,tl,tr,uk,vi,zu,zz,de,fr    */<br>    private void setLatinImeSubtypes(){</p>
<pre><code>    mInputMethodSettingValues = InputMethodSettingValuesWrapper.getInstance(this);
    // Refresh internal states in mInputMethodSettingValues to keep the latest
    // &amp;quot;InputMethodInfo&amp;quot;s and &amp;quot;InputMethodSubtype&amp;quot;s
    mInputMethodSettingValues.refreshAllInputMethodAndSubtypes();       

    HashMap&amp;lt;String, HashSet&amp;lt;String&amp;gt;&amp;gt; enabledIMEAndSubtypesMap = getEnabledInputMethodsAndSubtypeList(getContentResolver());     

    List&amp;lt;InputMethodInfo&amp;gt; inputMethodInfos = mInputMethodSettingValues.getInputMethodList();

    String subtypeStr = SystemProperties.get(&amp;quot;ro.bx.latinsubtypes&amp;quot;);
    Log.d(&amp;quot;edward&amp;quot;, &amp;quot;subtypeStr:&amp;quot;+subtypeStr);

        String [] subLocals = null;
       if(subtypeStr!=null &amp;amp;&amp;amp; !subtypeStr.trim().equals(&amp;quot;&amp;quot;))&#123;
                   subLocals = subtypeStr.split(&amp;quot;;&amp;quot;);
                   &#125;    

     if(subLocals != null)&#123;
    for (InputMethodInfo imi : inputMethodInfos) &#123;
        final String imiId = imi.getId();
        if(imiId.equals(&amp;quot;com.android.inputmethod.latin/.LatinIME&amp;quot;))&#123; /// Just for LatinIME          

         if (!enabledIMEAndSubtypesMap.containsKey(imiId)) &#123;
                // imiId has just been enabled
                enabledIMEAndSubtypesMap.put(imiId, new HashSet&amp;lt;String&amp;gt;());
                Log.d(&amp;quot;edward&amp;quot;,&amp;quot;  imiId has just been enabled&amp;quot;);
            &#125;
            HashSet&amp;lt;String&amp;gt; subtypesSet = enabledIMEAndSubtypesMap.get(imiId);

        // Because of system change, hashCode value could have been changed.
        // we reset it for the first time . //or not
        subtypesSet.clear();

         //String tmp = &amp;quot;LatinLME Subtypes List: &amp;quot;;
         final int subtypeCount = imi.getSubtypeCount();
            for (int i = 0; i &amp;lt; subtypeCount; ++i) &#123;

                InputMethodSubtype subtype = imi.getSubtypeAt(i);
                //Log.d(&amp;quot;edward&amp;quot;,&amp;quot;local:&amp;quot;+subtype.getLocale());
                //Log.d(&amp;quot;edward&amp;quot;,&amp;quot;Nameid:&amp;quot;+subtype.getNameResId());
                String local = subtype.getLocale(); 
                //tmp += local+&amp;quot;,&amp;quot; ;
                //if(local.equals(&amp;quot;en_US&amp;quot;) || local.equals(&amp;quot;es&amp;quot;))&#123;
                for(int k=0; k &amp;lt; subLocals.length ; k++)&#123;
                   if(subLocals[k].equals(local))&#123;
                    final String subtypeHashCodeStr = String.valueOf(subtype.hashCode());
                    subtypesSet.add(subtypeHashCodeStr);
                    Log.d(&amp;quot;edward&amp;quot;,&amp;quot;add subtypes by local:&amp;quot;+local);
                 &#125;
                &#125; 
             // &#125;
            &#125;
                //Log.d(&amp;quot;edward&amp;quot;, &amp;quot;List:&amp;quot;   + tmp);
        break;
        &#125;
    &#125;       
    StringBuilder builder = new StringBuilder();
    Log.d(&amp;quot;edward&amp;quot;,&amp;quot; build inputmethods subtype&amp;quot;);
    buildInputMethodsAndSubtypesString(builder, enabledIMEAndSubtypesMap);

    Settings.Secure.putString(getContentResolver(),
            Settings.Secure.ENABLED_INPUT_METHODS, builder.toString());

     final String enabledInputMethodsStr = Settings.Secure.getString(
            getContentResolver(), Settings.Secure.ENABLED_INPUT_METHODS);
      Log.d(&amp;quot;edward&amp;quot;,&amp;quot;ENABLED_INPUT_METHODS:=&amp;quot;+enabledInputMethodsStr);

 &#125;
&#125;


private static void buildEnabledInputMethodsString(
    StringBuilder builder, String imi, HashSet&amp;lt;String&amp;gt; subtypes) &#123;
    builder.append(imi);
    // Inputmethod and subtypes are saved in the settings as follows:
    // ime0;subtype0;subtype1:ime1;subtype0:ime2:ime3;subtype0;subtype1
    for (String subtypeId: subtypes) &#123;
        builder.append(INPUT_METHOD_SUBTYPE_SEPARATER).append(subtypeId);
    &#125;
&#125;

public static void buildInputMethodsAndSubtypesString(
        StringBuilder builder, HashMap&amp;lt;String, HashSet&amp;lt;String&amp;gt;&amp;gt; imsList) &#123;
    boolean needsAppendSeparator = false;
    for (String imi: imsList.keySet()) &#123;
        if (needsAppendSeparator) &#123;
            builder.append(INPUT_METHOD_SEPARATER);
        &#125; else &#123;
            needsAppendSeparator = true;
        &#125;
        buildEnabledInputMethodsString(builder, imi, imsList.get(imi));
    &#125;
&#125;

private static HashMap&amp;lt;String, HashSet&amp;lt;String&amp;gt;&amp;gt; getEnabledInputMethodsAndSubtypeList(ContentResolver resolver) &#123;
    final String enabledInputMethodsStr = Settings.Secure.getString(resolver, Settings.Secure.ENABLED_INPUT_METHODS);
    HashMap&amp;lt;String, HashSet&amp;lt;String&amp;gt;&amp;gt; imsList
            = new HashMap&amp;lt;String, HashSet&amp;lt;String&amp;gt;&amp;gt;();
    //if (DEBUG) &#123;
     //   Log.d(TAG, &amp;quot;--- Load enabled input methods: &amp;quot; + enabledInputMethodsStr);
   // &#125;

    if (TextUtils.isEmpty(enabledInputMethodsStr)) &#123;
        return imsList;
    &#125;
    sStringInputMethodSplitter.setString(enabledInputMethodsStr);
    while (sStringInputMethodSplitter.hasNext()) &#123;
        String nextImsStr = sStringInputMethodSplitter.next();
        sStringInputMethodSubtypeSplitter.setString(nextImsStr);
        if (sStringInputMethodSubtypeSplitter.hasNext()) &#123;
            HashSet&amp;lt;String&amp;gt; subtypeHashes = new HashSet&amp;lt;String&amp;gt;();
            // The first element is ime id.
            String imeId = sStringInputMethodSubtypeSplitter.next();
            while (sStringInputMethodSubtypeSplitter.hasNext()) &#123;
                subtypeHashes.add(sStringInputMethodSubtypeSplitter.next());
            &#125;
            imsList.put(imeId, subtypeHashes);
        &#125;
    &#125;
    return imsList;
&#125;</code></pre>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>laucher3 grb</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/laucher3%20grb/</url>
    <content><![CDATA[<p> b/src/com/android/launcher3/DynamicGrid.java</p>
<p>@@ -185,7 +185,7 @@ class DeviceProfile {</p>
<p>         searchBarSpaceMaxWidthPx = resources.getDimensionPixelSize(R.dimen.dynamic_grid_search_bar_max_width);</p>
<p>         searchBarHeightPx = resources.getDimensionPixelSize(R.dimen.dynamic_grid_search_bar_height);</p>
<p>         searchBarSpaceWidthPx = Math.min(searchBarSpaceMaxWidthPx, widthPx);</p>
<ul>
<li>searchBarSpaceHeightPx = searchBarHeightPx + 2 * edgeMarginPx;</li>
</ul>
<ul>
<li>searchBarSpaceHeightPx = searchBarHeightPx + 0 * edgeMarginPx;</li>
</ul>
<p>         // Calculate the actual text height</p>
<p>         Paint textPaint = new Paint();</p>
<p>@@ -211,7 +211,7 @@ class DeviceProfile {</p>
<p>         */</p>
<p>         // Hotseat</p>
<ul>
<li>hotseatBarHeightPx = iconSizePx + 4 * edgeMarginPx;</li>
</ul>
<ul>
<li>hotseatBarHeightPx = iconSizePx + 2 * edgeMarginPx;</li>
</ul>
<p>         hotseatCellWidthPx = iconSizePx;</p>
<p>         hotseatCellHeightPx = iconSizePx;</p>
<p>@@ -238,13 +238,16 @@ class DeviceProfile {</p>
<p>         int pageIndicatorOffset =</p>
<p>             resources.getDimensionPixelSize(R.dimen.apps_customize_page_indicator_offset);</p>
<p>         if (isLandscape) {</p>
<ul>
<li><p>allAppsNumRows = (availableHeightPx - pageIndicatorOffset - 4 * edgeMarginPx) /</p>
</li>
<li><p>(iconSizePx + iconTextSizePx + 2 * edgeMarginPx);</p>
</li>
</ul>
<ul>
<li><p>allAppsNumRows = 3;//(availableHeightPx - pageIndicatorOffset - 4 * edgeMarginPx) /</p>
</li>
<li><p>//(iconSizePx + iconTextSizePx + 2 * edgeMarginPx);</p>
</li>
</ul>
<p>         } else {</p>
<ul>
<li>allAppsNumRows = (int) numRows + 1;</li>
</ul>
<ul>
<li>allAppsNumRows = 6;//(int) numRows + 1;</li>
</ul>
<p>         }</p>
<p>         allAppsNumCols = (availableWidthPx - padding.left - padding.right - 2 * edgeMarginPx) /</p>
<p>                 (iconSizePx + 2 * edgeMarginPx);</p>
<ul>
<li><p>if(allAppsNumRows == 3) allAppsNumCols = 6;</p>
</li>
<li><p>if(allAppsNumRows == 6) allAppsNumCols = 3;</p>
</li>
</ul>
<p>+</p>
<p>     }</p>
<p>     private float dist(PointF p0, PointF p1) {</p>
<p>@@ -386,7 +389,7 @@ class DeviceProfile {</p>
<p>             lp.height = searchBarSpaceHeightPx;</p>
<p>             searchBar.setPadding(</p>
<p>                     2 * edgeMarginPx,</p>
<ul>
<li>2 * edgeMarginPx,</li>
</ul>
<ul>
<li>0 * edgeMarginPx,</li>
</ul>
<p>                     2 * edgeMarginPx, 0);</p>
<p>         }</p>
<p>         searchBar.setLayoutParams(lp);</p>
<p>@@ -447,7 +450,7 @@ class DeviceProfile {</p>
<p>             lp.height = hotseatBarHeightPx;</p>
<p>             hotseat.setPadding(2 * edgeMarginPx + gridGap + hotseatGap, 0,</p>
<p>                     2 * edgeMarginPx + gridGap + hotseatGap,</p>
<ul>
<li>2 * edgeMarginPx);</li>
</ul>
<ul>
<li>1 * edgeMarginPx);</li>
</ul>
<p>         } else {</p>
<p>             // For phones, layout the hotseat without any bottom margin</p>
<p>             // to ensure that we have space for the folders</p>
<p>@@ -525,7 +528,7 @@ public class DynamicGrid {</p>
<p>         deviceProfiles.add(new DeviceProfile(&quot;WVGA&quot;,</p>
<p>                 407, 727, 4, 5, 68, 13, (hasAA ? 5 : 4), 56));</p>
<p>         deviceProfiles.add(new DeviceProfile(&quot;1024x600&quot;,</p>
<ul>
<li>552, 960, 5, 6, 66, 15, 7, 60));</li>
</ul>
<ul>
<li>552, 960, 3, 6, 72, 16, 7, 60));</li>
</ul>
<p>                deviceProfiles.add(new DeviceProfile(&quot;1024x768&quot;,</p>
<p>                        720, 1000, 5, 7, 66, 15, 7, 60));</p>
<p>                deviceProfiles.add(new DeviceProfile(&quot;Nexus 7&quot;,</p>
<p>(END)</p>
<p>     private float dist(PointF p0, PointF p1) {</p>
<p>@@ -386,7 +389,7 @@ class DeviceProfile {</p>
<p>             lp.height = searchBarSpaceHeightPx;</p>
<p>             searchBar.setPadding(</p>
<p>                     2 * edgeMarginPx,</p>
<ul>
<li>2 * edgeMarginPx,</li>
</ul>
<ul>
<li>0 * edgeMarginPx,</li>
</ul>
<p>                     2 * edgeMarginPx, 0);</p>
<p>         }</p>
<p>         searchBar.setLayoutParams(lp);</p>
<p>@@ -447,7 +450,7 @@ class DeviceProfile {</p>
<p>             lp.height = hotseatBarHeightPx;</p>
<p>             hotseat.setPadding(2 * edgeMarginPx + gridGap + hotseatGap, 0,</p>
<p>                     2 * edgeMarginPx + gridGap + hotseatGap,</p>
<ul>
<li>2 * edgeMarginPx);</li>
</ul>
<ul>
<li>1 * edgeMarginPx);</li>
</ul>
<p>         } else {</p>
<p>             // For phones, layout the hotseat without any bottom margin</p>
<p>             // to ensure that we have space for the folders</p>
<p>@@ -525,7 +528,7 @@ public class DynamicGrid {</p>
<p>         deviceProfiles.add(new DeviceProfile(&quot;WVGA&quot;,</p>
<p>                 407, 727, 4, 5, 68, 13, (hasAA ? 5 : 4), 56));</p>
<p>         deviceProfiles.add(new DeviceProfile(&quot;1024x600&quot;,</p>
<ul>
<li>552, 960, 5, 6, 66, 15, 7, 60));</li>
</ul>
<ul>
<li>552, 960, 3, 6, 72, 16, 7, 60));</li>
</ul>
<p>                deviceProfiles.add(new DeviceProfile(&quot;1024x768&quot;,</p>
<p>                        720, 1000, 5, 7, 66, 15, 7, 60));</p>
<p>                deviceProfiles.add(new DeviceProfile(&quot;Nexus 7&quot;,</p>
<p> b/overlay/packages/apps/Launcher3/res/values-sw600dp/config.xml</p>
<p>@@ -0,0 +1,20 @@</p>
<p>+&lt;resources&gt;</p>
<ul>
<li><p>&lt;bool name=&quot;config_largeHeap&quot;&gt;true&lt;/bool&gt;</p>
</li>
<li><p>&lt;bool name=&quot;is_large_tablet&quot;&gt;true&lt;/bool&gt;</p>
</li>
</ul>
<p>+</p>
<p>+&lt;!– AllApps/Customize/AppsCustomize –&gt;</p>
<ul>
<li><p>&lt;!– Out of 100, the percent to shrink the workspace during spring loaded mode. –&gt;</p>
</li>
<li><p>&lt;integer name=&quot;config_workspaceSpringLoadShrinkPercentage&quot;&gt;90&lt;/integer&gt;</p>
</li>
</ul>
<p>+</p>
<p>+&lt;!– Workspace –&gt;</p>
<ul>
<li><p>&lt;!– Whether or not the drop targets drop down as opposed to fade in –&gt;</p>
</li>
<li><p>&lt;bool name=&quot;config_useDropTargetDownTransition&quot;&gt;false&lt;/bool&gt;</p>
</li>
<li><p>&lt;!– Whether or not to fade the side pages –&gt;</p>
</li>
<li><p>&lt;bool name=&quot;config_workspaceFadeAdjacentScreens&quot;&gt;true&lt;/bool&gt;</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>&lt;!– Camera distance for the overscroll effect –&gt;</p>
</li>
<li><p>&lt;integer name=&quot;config_cameraDistance&quot;&gt;18000&lt;/integer&gt;</p>
</li>
</ul>
<p>+</p>
<p>+&lt;!– Hotseat –&gt;</p>
<ul>
<li>&lt;bool name=&quot;hotseat_transpose_layout_with_orientation&quot;&gt;false&lt;/bool&gt;</li>
</ul>
<p>+&lt;/resources&gt;</p>
<p>  &lt;!– Dynamic Grid –&gt;</p>
<ul>
<li><p>&lt;dimen name=&quot;dynamic_grid_edge_margin&quot;&gt;15dp&lt;/dimen&gt;</p>
</li>
<li><p>&lt;dimen name=&quot;dynamic_grid_search_bar_max_width&quot;&gt;600dp&lt;/dimen&gt;</p>
</li>
<li><p>&lt;dimen name=&quot;dynamic_grid_search_bar_height&quot;&gt;40dp&lt;/dimen&gt;</p>
</li>
<li><p>&lt;dimen name=&quot;dynamic_grid_page_indicator_height&quot;&gt;24dp&lt;/dimen&gt;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher MENU 虚拟菜单</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher%20MENU%20%E8%99%9A%E6%8B%9F%E8%8F%9C%E5%8D%95/</url>
    <content><![CDATA[<p>在 9 以后，好像MENU就不在使用了</p>
<p>packages/apps/Launcher2/AndroidManifest.xml</p>
<p>&lt;uses-sdk android:minSdkVersion=&quot;8&quot; android:targetSdkVersion=&quot;9&quot;/&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher 屏蔽apk , package  class</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher%20%E5%B1%8F%E8%94%BDapk%20,%20package%20%20class/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java b/packages/apps/Launcher2/src/com/android/launcher2/All</p>
<p>index 051b0bd..cf93335 100644</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java</p>
<p>@@ -25,6 +25,7 @@ import android.content.Intent;</p>
<p> import android.content.pm.ActivityInfo;</p>
<p> import android.content.pm.PackageManager;</p>
<p> import android.content.pm.ResolveInfo;</p>
<p>+import android.os.SystemProperties;</p>
<p> /**</p>
<p>@@ -45,12 +46,13 @@ class AllAppsList {</p>
<p>     public ArrayList&lt;ApplicationInfo&gt; modified = new ArrayList&lt;ApplicationInfo&gt;();</p>
<p>     private IconCache mIconCache;</p>
<p>-</p>
<ul>
<li>      private final String hideapps;</li>
</ul>
<p>     /**</p>
<p>      * Boring constructor.</p>
<p>      */</p>
<p>     public AllAppsList(IconCache iconCache) {</p>
<p>         mIconCache = iconCache;</p>
<ul>
<li>              hideapps = SystemProperties.get(&quot;ro.bx.hidepackages&quot;,&quot;&quot;);</li>
</ul>
<p>     }</p>
<p>     /**</p>
<p>@@ -63,6 +65,21 @@ class AllAppsList {</p>
<p>         if (findActivity(data, info.componentName)) {</p>
<p>             return;</p>
<p>         }    /////####################在add前 ，前通过包名屏蔽apk  ######################</p>
<p>+</p>
<ul>
<li><p>              String [] hidedapps = null;</p>
</li>
<li><p>                       if(!hideapps.equals(&quot;&quot;)){</p>
</li>
<li><p>                       hidedapps =    hideapps.split(&quot;;&quot;);</p>
</li>
<li><p>                       }</p>
</li>
<li><p>              if(hidedapps!=null){</p>
</li>
<li><p>                      for(int i=0;i&lt;hidedapps.length;i++){</p>
</li>
<li><p>                              if(hidedapps[i].equals(&quot;&quot;)) continue;</p>
</li>
<li><p>                               if(hidedapps[i].equals(info.componentName.getPackageName()))</p>
</li>
<li><p>                                      return ;</p>
</li>
<li><p>                              }</p>
</li>
</ul>
<p>+</p>
<ul>
<li>              }</li>
</ul>
<p>+</p>
<p>+</p>
<p>         data.add(info);</p>
<p>         added.add(info);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher 桌面图标 背景</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher%20%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%20%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<p>    /**</p>
<p>     * Returns a bitmap suitable for the all apps view.</p>
<p>     */</p>
<p>    static Bitmap createIconBitmap(Drawable icon, Context context) {</p>
<p>        synchronized (sCanvas) { // we share the statics :-(</p>
<p>            if (sIconWidth == -1) {</p>
<p>                initStatics(context);</p>
<p>            }</p>
<p>            int width = sIconWidth;</p>
<p>            int height = sIconHeight;</p>
<p>            if (icon instanceof PaintDrawable) {</p>
<p>                PaintDrawable painter = (PaintDrawable) icon;</p>
<p>                painter.setIntrinsicWidth(width);</p>
<p>                painter.setIntrinsicHeight(height);</p>
<p>            } else if (icon instanceof BitmapDrawable) {</p>
<p>                // Ensure the bitmap has a density.</p>
<p>                BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;</p>
<p>                Bitmap bitmap = bitmapDrawable.getBitmap();</p>
<p>                if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {</p>
<p>                    bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());</p>
<p>                }</p>
<p>            }</p>
<p>            int sourceWidth = icon.getIntrinsicWidth();</p>
<p>            int sourceHeight = icon.getIntrinsicHeight();</p>
<p>            if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {</p>
<p>                // There are intrinsic sizes.</p>
<p>                if (width &lt; sourceWidth || height &lt; sourceHeight) {</p>
<p>                    // It’s too big, scale it down.</p>
<p>                    final float ratio = (float) sourceWidth / sourceHeight;</p>
<p>                    if (sourceWidth &gt; sourceHeight) {</p>
<p>                        height = (int) (width / ratio);</p>
<p>                    } else if (sourceHeight &gt; sourceWidth) {</p>
<p>                        width = (int) (height * ratio);</p>
<p>                    }</p>
<p>                } else if (sourceWidth &lt; width &amp;&amp; sourceHeight &lt; height) {</p>
<p>                    // Don’t scale up the icon</p>
<p>                    width = sourceWidth;</p>
<p>                    height = sourceHeight;</p>
<p>                }</p>
<p>            }</p>
<p>            // no intrinsic size –&gt; use default size</p>
<p>            int textureWidth = sIconTextureWidth;</p>
<p>            int textureHeight = sIconTextureHeight;</p>
<p>            final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,</p>
<p>                    Bitmap.Config.ARGB_8888);</p>
<p>            final Canvas canvas = sCanvas;</p>
<p>            canvas.setBitmap(bitmap);</p>
<p>            final int left = (textureWidth-width) / 2;</p>
<p>            final int top = (textureHeight-height) / 2;</p>
<p>            @SuppressWarnings(&quot;all&quot;) // suppress dead code warning</p>
<p>            final boolean debug = false;</p>
<p>            if (debug) {</p>
<p>                // draw a big box for the icon for debugging</p>
<p>                canvas.drawColor(sColors[sColorIndex]);</p>
<p>                if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;</p>
<p>                Paint debugPaint = new Paint();</p>
<p>                debugPaint.setColor(0xffcccc00);</p>
<p>                canvas.drawRect(left, top, left+width, top+height, debugPaint);</p>
<p>            }</p>
<p>            if (true) ////////////////////////////////////</p>
<p>            {</p>
<p>                Bitmap backBitmap = BitmapFactory.decodeResource(context.getResources(),</p>
<p>                        R.drawable.cling);</p>
<p>                int backWidth = backBitmap.getWidth();</p>
<p>                int backHeight = backBitmap.getHeight();</p>
<p>                if(backWidth != sIconWidth || backHeight != sIconHeight)</p>
<p>                {</p>
<p>                    Matrix matrix = new Matrix();</p>
<p>                    matrix.postScale((float)sIconWidth/backWidth, (float)sIconHeight/backHeight);</p>
<p>                    canvas.drawBitmap(Bitmap.createBitmap(backBitmap, 0, 0, backWidth, backHeight, matrix, true),0.0f, 0.0f, null);</p>
<p>                }else</p>
<p>                {</p>
<p>                    canvas.drawBitmap(backBitmap, 0.0f, 0.0f, null);</p>
<p>                }</p>
<p>            }</p>
<p>            sOldBounds.set(icon.getBounds());</p>
<p>            icon.setBounds(left, top, left+width, top+height);</p>
<p>            icon.draw(canvas);</p>
<p>            icon.setBounds(sOldBounds);</p>
<p>            canvas.setBitmap(null);</p>
<p>            return bitmap;</p>
<p>        }</p>
<p>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher 桌面进入allapps的时间</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher%20%E6%A1%8C%E9%9D%A2%E8%BF%9B%E5%85%A5allapps%E7%9A%84%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p> config_appsCustomizeZoomInTime  </p>
<p>config_appsCustomizeZoomOutTime </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher3 4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher3%204.4%20%20widget/</url>
    <content><![CDATA[<p>framework/base/core/res/AndroidManifest.xml</p>
<p>//1.修改保护级别</p>
<p>a/core/res/AndroidManifest.xml</p>
<p>+++ b/core/res/AndroidManifest.xml</p>
<p>@@ -2297,7 +2297,7 @@</p>
<p>         android:permissionGroup=&quot;android.permission-group.PERSONAL_INFO&quot;</p>
<p>         android:label=&quot;@string/permlab_bindGadget&quot;</p>
<p>         android:description=&quot;@string/permdesc_bindGadget&quot;</p>
<ul>
<li>android:protectionLevel=&quot;signature|system&quot; /&gt;</li>
</ul>
<ul>
<li>android:protectionLevel=&quot;normal&quot; /&gt;</li>
</ul>
<p>//2. 在isSafeMode   不要remove widget</p>
<p>— a/src/com/android/launcher3/LauncherModel.java</p>
<p>+++ b/src/com/android/launcher3/LauncherModel.java</p>
<p>@@ -1830,7 +1830,7 @@ public class LauncherModel extends BroadcastReceiver {</p>
<p>                                 final AppWidgetProviderInfo provider =</p>
<p>                                         widgets.getAppWidgetInfo(appWidgetId);</p>
<ul>
<li>if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||</li>
</ul>
<ul>
<li>if ( (provider == null || provider.provider == null ||</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher3 壁纸 居中 不滚动</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher3%20%E5%A3%81%E7%BA%B8%20%E5%B1%85%E4%B8%AD%20%E4%B8%8D%E6%BB%9A%E5%8A%A8/</url>
    <content><![CDATA[<p>diff –git a/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java b/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java</p>
<p>index 561c4bb..afbb985 100755</p>
<p>— a/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java</p>
<p>+++ b/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java</p>
<p>@@ -230,11 +230,19 @@ public class WallpaperCropActivity extends Activity {</p>
<p>             // for the intended parallax effects</p>
<p>             final int defaultWidth, defaultHeight;</p>
<p>             if (isScreenLarge(res)) {</p>
<ul>
<li><p>               defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));</p>
</li>
<li><p>               defaultHeight = maxDim;</p>
</li>
</ul>
<ul>
<li><p>              // defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));</p>
</li>
<li><p>              // defaultHeight = maxDim;</p>
</li>
<li><p>                          Log.e(LOGTAG, &quot;—–maxDim=&quot;+maxDim);</p>
</li>
<li><p>                       Log.e(LOGTAG, &quot;——minDim=&quot;+minDim);</p>
</li>
<li><p>                                        defaultWidth = maxDim;</p>
</li>
<li><p>              defaultHeight = minDim;</p>
</li>
</ul>
<p>             } else {</p>
<ul>
<li><p>               defaultWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);</p>
</li>
<li><p>               defaultHeight = maxDim;</p>
</li>
</ul>
<ul>
<li><p>             //  defaultWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);</p>
</li>
<li><p>            //   defaultHeight = maxDim;</p>
</li>
<li><p>                       Log.e(LOGTAG, &quot;maxDim=&quot;+maxDim);</p>
</li>
<li><p>                       Log.e(LOGTAG, &quot;minDim=&quot;+minDim);</p>
</li>
<li><p>                                      defaultWidth = maxDim;</p>
</li>
<li><p>              defaultHeight = minDim;</p>
</li>
</ul>
<p>             }</p>
<p>             sDefaultWallpaperSize = new Point(defaultWidth, defaultHeight);</p>
<p>         }</p>
<p>diff –git a/src/com/android/launcher3/Workspace.java b/src/com/android/launcher3/Workspace.java</p>
<p>old mode 100644</p>
<p>new mode 100755</p>
<p>index 567abfa..8a6c4b9</p>
<p>— a/src/com/android/launcher3/Workspace.java</p>
<p>+++ b/src/com/android/launcher3/Workspace.java</p>
<p>@@ -1295,7 +1295,7 @@ public class Workspace extends SmoothPagedView</p>
<p>                 if (computeScrollOffset() &amp;&amp; mWindowToken != null) {</p>
<p>                     try {</p>
<p>                         mWallpaperManager.setWallpaperOffsets(mWindowToken,</p>
<ul>
<li>                               mWallpaperOffset.getCurrX(), 0.5f);</li>
</ul>
<ul>
<li>                              /* mWallpaperOffset.getCurrX()*/0.5f, 0.5f);</li>
</ul>
<p>                         setWallpaperOffsetSteps();</p>
<p>                     } catch (IllegalArgumentException e) {</p>
<p>                         Log.e(TAG, &quot;Error updating wallpaper offset: &quot; + e);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher3 长按无效 禁止拖动 隐藏search</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher3%20%E9%95%BF%E6%8C%89%E6%97%A0%E6%95%88%20%E7%A6%81%E6%AD%A2%E6%8B%96%E5%8A%A8%20%E9%9A%90%E8%97%8Fsearch/</url>
    <content><![CDATA[<p>— a/src/com/android/launcher3/AppsCustomizePagedView.java</p>
<p>+++ b/src/com/android/launcher3/AppsCustomizePagedView.java</p>
<p>@@ -1051,7 +1051,7 @@ public class AppsCustomizePagedView extends PagedViewWithDraggableItems implemen</p>
<p>                     R.layout.apps_customize_application, layout, false);</p>
<p>             icon.applyFromApplicationInfo(info, true, this);</p>
<p>             icon.setOnClickListener(this);</p>
<ul>
<li>           icon.setOnLongClickListener(this);</li>
</ul>
<ul>
<li>           //icon.setOnLongClickListener(this);</li>
</ul>
<p>             icon.setOnTouchListener(this);</p>
<p>             icon.setOnKeyListener(this);</p>
<p>@@ -1233,7 +1233,7 @@ public class AppsCustomizePagedView extends PagedViewWithDraggableItems implemen</p>
<p>                 widget.setTag(createItemInfo);</p>
<p>             }</p>
<p>             widget.setOnClickListener(this);</p>
<ul>
<li>           widget.setOnLongClickListener(this);</li>
</ul>
<ul>
<li>           //widget.setOnLongClickListener(this);</li>
</ul>
<p>             widget.setOnTouchListener(this);</p>
<p>             widget.setOnKeyListener(this);</p>
<p>diff –git a/src/com/android/launcher3/InstallShortcutReceiver.java b/src/com/android/launcher3/InstallShortcutReceiver.java</p>
<p>index 28cef13..7bd5435 100644</p>
<p>— a/src/com/android/launcher3/InstallShortcutReceiver.java</p>
<p>+++ b/src/com/android/launcher3/InstallShortcutReceiver.java</p>
<p>@@ -214,7 +214,7 @@ public class InstallShortcutReceiver extends BroadcastReceiver {</p>
<p>     }</p>
<p>     public void onReceive(Context context, Intent data) {</p>
<ul>
<li>       if (!ACTION_INSTALL_SHORTCUT.equals(data.getAction())) {</li>
</ul>
<ul>
<li>       if (true){//!ACTION_INSTALL_SHORTCUT.equals(data.getAction())) {</li>
</ul>
<p>             return;</p>
<p>         }</p>
<p>diff –git a/src/com/android/launcher3/Launcher.java b/src/com/android/launcher3/Launcher.java</p>
<p>index 407fbb7..0e8fbcc 100755</p>
<p>— a/src/com/android/launcher3/Launcher.java</p>
<p>+++ b/src/com/android/launcher3/Launcher.java</p>
<p>@@ -1259,7 +1259,7 @@ public class Launcher extends Activity</p>
<p>         mHotseat = (Hotseat) findViewById(R.id.hotseat);</p>
<p>         if (mHotseat != null) {</p>
<p>             mHotseat.setup(this);</p>
<ul>
<li>           mHotseat.setOnLongClickListener(this);</li>
</ul>
<ul>
<li>           //mHotseat.setOnLongClickListener(this);</li>
</ul>
<p>         }</p>
<p>         mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);</p>
<p>@@ -2440,9 +2440,9 @@ public class Launcher extends Activity</p>
<p>      * @param v The view that was clicked.</p>
<p>      */</p>
<p>     public void onClickSearchButton(View v) {</p>
<ul>
<li>       v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</li>
</ul>
<ul>
<li>      // v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</li>
</ul>
<ul>
<li>       onSearchRequested();</li>
</ul>
<ul>
<li>       //onSearchRequested();</li>
</ul>
<p>     }</p>
<p>     /**</p>
<p>@@ -2451,9 +2451,9 @@ public class Launcher extends Activity</p>
<p>      * @param v The view that was clicked.</p>
<p>      */</p>
<p>     public void onClickVoiceButton(View v) {</p>
<ul>
<li>       v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</li>
</ul>
<ul>
<li>       //v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</li>
</ul>
<ul>
<li>       startVoice();</li>
</ul>
<ul>
<li>       //startVoice();</li>
</ul>
<p>     }</p>
<p>     public void startVoice() {</p>
<p>@@ -2809,6 +2809,7 @@ public class Launcher extends Activity</p>
<p>     }</p>
<p>     public boolean onLongClick(View v) {</p>
<ul>
<li>               </li>
</ul>
<p>         if (!isDraggingEnabled()) return false;</p>
<p>         if (isWorkspaceLocked()) return false;</p>
<p>         if (mState != State.WORKSPACE) return false;</p>
<p>@@ -2853,6 +2854,7 @@ public class Launcher extends Activity</p>
<p>                     mWorkspace.enterOverviewMode();</p>
<p>                 }</p>
<p>             } else {</p>
<ul>
<li>                              /*</li>
</ul>
<p>                 final boolean isAllAppsButton = inHotseat &amp;&amp; isAllAppsButtonRank(</p>
<p>                         mHotseat.getOrderInHotseat(</p>
<p>                                 longClickCellInfo.cellX,</p>
<p>@@ -2861,6 +2863,7 @@ public class Launcher extends Activity</p>
<p>                     // User long pressed on an item</p>
<p>                     mWorkspace.startDrag(longClickCellInfo);</p>
<p>                 }</p>
<ul>
<li>                              */</li>
</ul>
<p>             }</p>
<p>         }</p>
<p>         return true;</p>
<p>@@ -3557,7 +3560,7 @@ public class Launcher extends Activity</p>
<p>         final SearchManager searchManager =</p>
<p>                 (SearchManager) getSystemService(Context.SEARCH_SERVICE);</p>
<p>         ComponentName activityName = searchManager.getGlobalSearchActivity();</p>
<ul>
<li>       if (activityName != null) {</li>
</ul>
<ul>
<li>       if (false){//}activityName != null) {</li>
</ul>
<p>             int coi = getCurrentOrientationIndexForGlobalIcons();</p>
<p>             sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(</p>
<p>                     R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher3进入app列表输入密码</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher3%E8%BF%9B%E5%85%A5app%E5%88%97%E8%A1%A8%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>diff –git a/src/com/android/launcher3/Hotseat.java b/src/com/android/launcher3/Hotseat.java</p>
<p>index 59d60e3..0bde052 100644</p>
<p>— a/src/com/android/launcher3/Hotseat.java</p>
<p>+++ b/src/com/android/launcher3/Hotseat.java</p>
<p>@@ -32,6 +32,13 @@ import android.widget.TextView;</p>
<p> import java.util.ArrayList;</p>
<p>+import android.widget.EditText;</p>
<p>+import android.app.AlertDialog;</p>
<p>+import android.content.DialogInterface;</p>
<p>+import android.widget.Toast;</p>
<p>+import android.text.method.PasswordTransformationMethod;</p>
<p>+import android.provider.Settings;</p>
<p>+</p>
<p> public class Hotseat extends FrameLayout {</p>
<p>     private static final String TAG = &quot;Hotseat&quot;;</p>
<p>@@ -161,7 +168,38 @@ public class Hotseat extends FrameLayout {</p>
<p>                 @Override</p>
<p>                 public void onClick(android.view.View v) {</p>
<p>                     if (mLauncher != null) {</p>
<ul>
<li>                       mLauncher.onClickAllAppsButton(v);</li>
</ul>
<ul>
<li><p>                       //mLauncher.onClickAllAppsButton(v);</p>
</li>
<li><p>                                              </p>
</li>
<li><p>                                              final View view = v ;</p>
</li>
<li><p>                                              String psw = Settings.System.getString(getContext().getContentResolver(),&quot;launcher_password&quot;);</p>
</li>
<li><p>                                              if(null == psw) psw =&quot;123456&quot;;</p>
</li>
<li><p>                                              final String psws = psw ;</p>
</li>
<li><p>                                               AlertDialog.Builder alertDialog = new AlertDialog.Builder(getContext());</p>
</li>
<li><p>                      final EditText passwords = new EditText(getContext());</p>
</li>
<li><p>                       passwords.setTransformationMethod(PasswordTransformationMethod.getInstance());</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                       alertDialog.setTitle(getResources().getString(R.string.input_password))</p>
</li>
<li><p>                      .setIcon(android.R.drawable.ic_dialog_info)</p>
</li>
<li><p>                      .setView(passwords)</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                      .setPositiveButton(getResources().getString(R.string.yes_btn),</p>
</li>
<li><p>                        new DialogInterface.OnClickListener(){</p>
</li>
<li><p>                                public void onClick(DialogInterface dialoginterface, int i){</p>
</li>
<li><p>                                    if(passwords.getText().toString().equals(psws)){</p>
</li>
<li><p>                                                                mLauncher.onClickAllAppsButton(view);</p>
</li>
<li><p>                                                                      }else{</p>
</li>
<li><p>                                                      Toast.makeText(getContext(),getResources().getString(R.string.psw_err), Toast.LENGTH_LONG).show();</p>
</li>
</ul>
<p>+</p>
<ul>
<li>                                                                      }</li>
</ul>
<p>+</p>
<ul>
<li><p>                                }</p>
</li>
<li><p>                        })</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>                      .setNegativeButton(getResources().getString(R.string.cancel_btn), null )</p>
</li>
<li><p>                      .show();</p>
</li>
<li><p>                                              </p>
</li>
<li><p>                                              </p>
</li>
</ul>
<p>                     }</p>
<p>                 }</p>
<p>             });</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher中强制显示没有CATEGORY_LAUNCHER这种属性的应用</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher%E4%B8%AD%E5%BC%BA%E5%88%B6%E6%98%BE%E7%A4%BA%E6%B2%A1%E6%9C%89CATEGORY_LAUNCHER%E8%BF%99%E7%A7%8D%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>launcher中强制显示没有CATEGORY_LAUNCHER这种属性的应用</p>
<p>在packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java中</p>
<p>    private static List&lt;ResolveInfo&gt; findActivitiesForPackage(Context context, String packageName) {</p>
<p>        final PackageManager packageManager = context.getPackageManager();</p>
<p>        final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);</p>
<p>        if(packageName.equals(&quot;com.spreadwin.factorytest.JH&quot;)||packageName.equals(&quot;com.spreadwin.s.test&quot;))</p>
<p>        {</p>
<p>                mainIntent.setPackage(packageName);</p>
<p>                Log.i(&quot;zhou&quot;, &quot;findActivitiesForPackage–&quot;+packageName);</p>
<p>        }</p>
<p>        else</p>
<p>        {</p>
<p>                mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);</p>
<p>            mainIntent.setPackage(packageName);</p>
<p>        }</p>
<p>        final List&lt;ResolveInfo&gt; apps = packageManager.queryIntentActivities(mainIntent, 0);</p>
<p>        return apps != null ? apps : new ArrayList&lt;ResolveInfo&gt;();</p>
<p>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>launcher桌面边框</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/launcher%E6%A1%8C%E9%9D%A2%E8%BE%B9%E6%A1%86/</url>
    <content><![CDATA[<p>packages/apps/Launcher2/src/com/android/launcher2/Workspace.java</p>
<p>//大屏幕时</p>
<p>//  final float smallestScreenDim = res.getConfiguration().smallestScreenWidthDp *</p>
<p>            ///        displayMetrics.density;</p>
<p>                final float smallestScreenDim = 600 * displayMetrics.density;//edward</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>libncurses5-devi386</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/libncurses5-devi386/</url>
    <content><![CDATA[<p>libncurses5-dev:i386</p>
<p>E: Unable to locate package libx11-dev:i386</p>
<p>E: Unable to locate package libreadline6-dev:i386</p>
<p>E: Unable to locate package libgl1-mesa-dri:i386</p>
<p>ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1/usr/lib/i386-linux-gnu/libGL.so</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>libstagefright版本 视频库</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/libstagefright%E7%89%88%E6%9C%AC%20%E8%A7%86%E9%A2%91%E5%BA%93/</url>
    <content><![CDATA[<p>busybox strings /system/lib/libstagefright.so | busybox grep author</p>
<p>root@android:/ # busybox strings /system/lib/libstagefright.so | busybox grep author</p>
<p>stagefright.so | busybox grep author                                          &lt;</p>
<p>author:  csy time: Fri, 28 Dec 2012 19:00:33 +0800 version: 1743</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>linux 大硬盘 2T  GPT分区</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/linux%20%E5%A4%A7%E7%A1%AC%E7%9B%98%202T%20%20GPT%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<p>sudo fdisk -l   查看所有硬盘分区情况</p>
<p>sudo parted /dev/sdc</p>
<p>mklabel  gpt  //若不是GPT，转换为GPT </p>
<p>mkpart  </p>
<p>2048s //对齐 start</p>
<p>30%</p>
<p>mkpart disk1 ext4 0 1600000</p>
<p>mkpart disk2 ext4  1600000 -1</p>
<p>print </p>
<p>Partition Table: gpt</p>
<p>Number  Start   End     Size    File system  Name   Flags</p>
<p> 1      17.4kB  1600GB  1600GB  ext4         disk1</p>
<p> 2      1600GB  3001GB  1401GB               disk2</p>
<p>quit</p>
<p>sudo mkfs.ext4 /dev/sdc1      格式化</p>
<p> sudo mkfs.ext4 /dev/sdc2   </p>
<p>sudo mount /dev/sdc1 /media/disk1</p>
<p>sudo mount /dev/sdc2 /media/disk2</p>
<p>df -lh</p>
<p>help </p>
<p>Model: ATA ST3000DM001-1ER1 (scsi)</p>
<p>Disk /dev/sdc: 3001GB</p>
<p>Sector size (logical/physical): 512B/4096B</p>
<p>Partition Table: gpt</p>
<p>Number  Start  End  Size  File system  Name  Flags</p>
<p>(parted) help                                                             </p>
<p>  align-check TYPE N                        check partition N for TYPE(min|opt) alignment</p>
<p>  check NUMBER                             do a simple check on the file system</p>
<p>  cp [FROM-DEVICE] FROM-NUMBER TO-NUMBER   copy file system to another partition</p>
<p>  help [COMMAND]                           print general help, or help on COMMAND</p>
<p>  mklabel,mktable LABEL-TYPE               create a new disklabel (partition table)</p>
<p>  mkfs NUMBER FS-TYPE                      make a FS-TYPE file system on partition NUMBER</p>
<p>  mkpart PART-TYPE [FS-TYPE] START END     make a partition</p>
<p>  mkpartfs PART-TYPE FS-TYPE START END     make a partition with a file system</p>
<p>  move NUMBER START END                    move partition NUMBER</p>
<p>  name NUMBER NAME                         name partition NUMBER as NAME</p>
<p>  print [devices|free|list,all|NUMBER]     display the partition table, available devices, free space, all found partitions, or a particular partition</p>
<p>  quit                                     exit program</p>
<p>  rescue START END                         rescue a lost partition near START and END</p>
<p>  resize NUMBER START END                  resize partition NUMBER and its file system</p>
<p>  rm NUMBER                                delete partition NUMBER</p>
<p>  select DEVICE                            choose the device to edit</p>
<p>  set NUMBER FLAG STATE                    change the FLAG on partition NUMBER</p>
<p>  toggle [NUMBER [FLAG]]                   toggle the state of FLAG on partition NUMBER</p>
<p>  unit UNIT                                set the default unit to UNIT</p>
<p>  version                                  display the version number and copyright information of GNU Parted</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>linux jdk 安装</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/linux%20jdk%20%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>        mkdir -p /usr/lib/jvm</p>
<p>        tar zxvf jdk-7u71-linux-x64.tar.gz -C /usr/lib/jvm/</p>
<p>        mv /usr/lib/jvm/jdk1.7.0_71 /usr/lib/jvm/java-7-sun</p>
<p>1, 将jdk,解压到指定路径。</p>
<p>2.update-alternatives 配置</p>
<p>sudo update-alternatives –install /usr/bin/jar jar /usr/lib/jvm/java-7-sun/bin/jar 60</p>
<p>sudo update-alternatives –install /usr/bin/java java /usr/lib/jvm/java-7-sun/bin/java 60</p>
<p>sudo update-alternatives –install /usr/bin/javac javac /usr/lib/jvm/java-7-sun/bin/javac 60</p>
<p>sudo update-alternatives –install /usr/bin/javap javap /usr/lib/jvm/java-7-sun/bin/javap 60</p>
<p>sudo update-alternatives –config jar</p>
<p>sudo update-alternatives –config java</p>
<p>sudo update-alternatives –config javac</p>
<p>sudo update-alternatives –config javap</p>
<p>另一种方法，直接设置环境变量。</p>
<p> build.sh</p>
<p>#!/bin/bash</p>
<p>export JAVA_HOME=/usr/lib/jvm/java-7-sun</p>
<p>export PATH=$JAVA_HOME/bin:$PATH</p>
<p>export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar</p>
<p>直接执行   .   build.sh  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>linux内核SPI总线驱动简单编写测试</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/linux%E5%86%85%E6%A0%B8SPI%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8%E7%AE%80%E5%8D%95%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>linux内核SPI总线驱动简单编写测试</p>
<p>下面有两个大的模块：</p>
<p>一个是SPI总线驱动的分析            (研究了具体实现的过程)</p>
<p>另一个是SPI总线驱动的编写（不用研究具体的实现过程）</p>
<p>SPI总线驱动分析</p>
<p>1 SPI概述<br>      SPI是英语Serial Peripheral interface的缩写，顾名思义就是串行外围设备接口，是Motorola首先在其MC68HCXX系列处理器上定义的。SPI接口主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。SPI是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便。<br>      SPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多个从设备，需要4根线，事实上3根也可以。也是所有基于SPI的设备共有的，它们是SDI(数据输入)，SDO(数据输出)，SCLK(时钟)，CS(片选)。<br>      MOSI(SDO)：主器件数据输出，从器件数据输入。<br>      MISO(SDI)：主器件数据输入，从器件数据输出。<br>      SCLK ：时钟信号，由主器件产生。<br>      CS：从器件使能信号，由主器件控制。<br>其中CS是控制芯片是否被选中的，也就是说只有片选信号为预先规定的使能信号时（高电位或低电位），对此芯片的操作才有效，这就允许在同一总线上连接多个SPI设备成为可能。需要注意的是，在具体的应用中，当一条SPI总线上连接有多个设备时，SPI本身的CS有可能被其他的GPIO脚代替，即每个设备的CS脚被连接到处理器端不同的GPIO，通过操作不同的GPIO口来控制具体的需要操作的SPI设备，减少各个SPI设备间的干扰。<br>      SPI是串行通讯协议，也就是说数据是一位一位从MSB或者LSB开始传输的，这就是SCK时钟线存在的原因，由SCK提供时钟脉冲，MISO、MOSI则基于此脉冲完成数据传输。 SPI支持4-32bits的串行数据传输，支持MSB和LSB，每次数据传输时当从设备的大小端发生变化时需要重新设置SPI Master的大小端。</p>
<p>2 Linux SPI驱动总体架构<br>      在2.6的linux内核中，SPI的驱动架构可以分为如下三个层次：SPI 核心层、SPI控制器驱动层和SPI设备驱动层。<br>      Linux 中SPI驱动代码位于drivers/spi目录。<br>2.1 SPI核心层<br>      SPI核心层是Linux的SPI核心部分，提供了核心数据结构的定义、SPI控制器驱动和设备驱动的注册、注销管理等API。其为硬件平台无关层，向下屏蔽了物理总线控制器的差异，定义了统一的访问策略和接口；其向上提供了统一的接口，以便SPI设备驱动通过总线控制器进行数据收发。<br>      Linux中，SPI核心层的代码位于driver/spi/ spi.c。由于该层是平台无关层，本文将不再叙述，有兴趣可以查阅相关资料。<br>2.2 SPI控制器驱动层<br>      SPI控制器驱动层，每种处理器平台都有自己的控制器驱动，属于平台移植相关层。它的职责是为系统中每条SPI总线实现相应的读写方法。在物理上，每个SPI控制器可以连接若干个SPI从设备。<br>      在系统开机时，SPI控制器驱动被首先装载。一个控制器驱动用于支持一条特定的SPI总线的读写。一个控制器驱动可以用数据结构struct spi_master来描述。</p>
<p>   在include/liunx/spi/spi.h文件中，在数据结构struct spi_master定义如下：</p>
<p>struct spi_master { </p>
<p>struct device   dev; </p>
<p>    s16         bus_num; </p>
<p>    u16         num_chipselect; </p>
<p>int         (*setup)(struct spi_device *spi); </p>
<p>int         (*transfer)(struct spi_device *spi, struct spi_message *mesg); </p>
<p>void        (*cleanup)(struct spi_device *spi); </p>
<p>}; </p>
<p>     bus_num为该控制器对应的SPI总线号。<br>      num_chipselect 控制器支持的片选数量，即能支持多少个spi设备 <br>      setup函数是设置SPI总线的模式，时钟等的初始化函数， 针对设备设置SPI的工作时钟及数据传输模式等。在spi_add_device函数中调用。 <br>      transfer函数是实现SPI总线读写方法的函数。实现数据的双向传输，可能会睡眠</p>
<p>cleanup注销时候调用</p>
<p>2.3 SPI设备驱动层<br>      SPI设备驱动层为用户接口层，其为用户提供了通过SPI总线访问具体设备的接口。<br>      SPI设备驱动层可以用两个模块来描述，struct spi_driver和struct spi_device。<br>      相关的数据结构如下：</p>
<p>struct spi_driver { </p>
<p>int         (*probe)(struct spi_device *spi); </p>
<p>int         (*remove)(struct spi_device *spi); </p>
<p>void            (*shutdown)(struct spi_device *spi); </p>
<p>int         (*suspend)(struct spi_device *spi, pm_message_t mesg); </p>
<p>int         (*resume)(struct spi_device *spi); </p>
<p>struct device_driver    driver; </p>
<p>};</p>
<p>  Driver是为device服务的，spi_driver注册时会扫描SPI bus上的设备，进行驱动和设备的绑定，probe函数用于驱动和设备匹配时被调用。从上面的结构体注释中我们可以知道，SPI的通信是通过消息队列机制，而不是像I2C那样通过与从设备进行对话的方式。</p>
<p>struct spi_device { </p>
<p>struct device       dev; </p>
<p>struct spi_master   *master; </p>
<p>    u32         max_speed_hz; </p>
<p>    u8          chip_select; </p>
<p>    u8          mode;   </p>
<p>    u8          bits_per_word; </p>
<p>int         irq; </p>
<p>void            *controller_state; </p>
<p>void            *controller_data; </p>
<p>char            modalias[32];  </p>
<p>};</p>
<p>        .modalias   = &quot;m25p10&quot;,</p>
<p>        .mode   =SPI_MODE_0,   //CPOL=0, CPHA=0 此处选择具体数据传输模式</p>
<p>        .max_speed_hz    = 10000000, //最大的spi时钟频率</p>
<p>        /* Connected to SPI-0 as 1st Slave */</p>
<p>        .bus_num    = 0,   //设备连接在spi控制器0上</p>
<p>        .chip_select    = 0, //片选线号，在S5PC100的控制器驱动中没有使用它作为片选的依据，而是选择了下文controller_data里的方法。</p>
<p>        .controller_data = &amp;smdk_spi0_csi[0], </p>
<p>通常来说spi_device对应着SPI总线上某个特定的slave。并且spi_device封装了一个spi_master结构体。spi_device结构体包含了私有的特定的slave设备特性，包括它最大的频率，片选那个，输入输出模式等等</p>
<p>3 OMAP3630 SPI控制器<br>      OMAP3630上SPI是一个主/从的同步串行总线，这边有4个独立的SPI模块(SPI1，SPI2，SPI3，SPI4)，各个模块之间的区别在于SPI1支持多达4个SPI设备，SPI2和SPI3支持2个SPI设备，而SPI4只支持1个SPI设备。</p>
<p>SPI控制器具有以下特征：<br>?     1.可编程的串行时钟，包括频率，相位，极性。<br>?     2.支持4到32位数据传输<br>?     3.支持4通道或者单通道的从模式<br>?     4.支持主的多通道模式<br>?         4.1全双工/半双工<br>?         4.2只发送/只接收/收发都支持模式<br>?         4.3灵活的I/O端口控制<br>?         4.4每个通道都支持DMA读写<br>?     5.支持多个中断源的中断时间<br>?     6.支持wake-up的电源管理<br>?     7.内置64字节的FIFO</p>
<p>4 spi_device以下一系列的操作是在platform板文件中完成！</p>
<p>spi_device的板信息用spi_board_info结构体来描述：</p>
<p>struct spi_board_info {</p>
<p>charmodalias[SPI_NAME_SIZE];</p>
<p>const void*platform_data;</p>
<p>void*controller_data;</p>
<p>intirq;</p>
<p>u32max_speed_hz;</p>
<p>u16bus_num;</p>
<p>u16chip_select;</p>
<p>u8mode;</p>
<p>};</p>
<p>这个结构体记录了SPI外设使用的主机控制器序号、片选信号、数据比特率、SPI传输方式等</p>
<p>构建的操作是以下的两个步骤：</p>
<p>1.</p>
<p>static struct spi_board_info s3c_spi_devs[] __initdata = {</p>
<p>{</p>
<p>.modalias = &quot;m25p10a&quot;,</p>
<p>.mode = SPI_MODE_0,</p>
<p>.max_speed_hz = 1000000,</p>
<p>.bus_num = 0,</p>
<p>.chip_select = 0,</p>
<p>.controller_data = &amp;smdk_spi0_csi[SMDK_MMCSPI_CS],</p>
<p>},</p>
<p>};</p>
<p>2.</p>
<p>而这个info在init函数调用的时候会初始化：</p>
<p>spi_register_board_info(s3c_spi_devs,ARRAY_SIZE(s3c_spi_devs));</p>
<p>spi_register_board_info(s3c_spi_devs,ARRAY_SIZE(s3c_spi_devs));//注册spi_board_info。这个代码会把spi_board_info注册到链表board_list上。spi_device封装了一个spi_master结构体，事实上spi_master的注册会在spi_register_board_info之后，spi_master注册的过程中会调用scan_boardinfo扫描board_list，找到挂接在它上面的spi设备，然后创建并注册spi_device。</p>
<p>至此spi_device就构建并注册完成了！！！！！！！！！！！！！</p>
<p>5 spi_driver的构建与注册</p>
<p>driver有几个重要的结构体：spi_driver、spi_transfer、spi_message</p>
<p>driver有几个重要的函数    ：spi_message_init、spi_message_add_tail、spi_sync</p>
<p>   //spi_driver的构建</p>
<p>static struct spi_driver   m25p80_driver = {</p>
<p>.driver = {</p>
<p>        .name   =&quot;m25p80&quot;,</p>
<p>        .bus    =&amp;spi_bus_type,</p>
<p>        .owner  = THIS_MODULE,</p>
<p>    },</p>
<p>    .probe  = m25p_probe,</p>
<p>    .remove =__devexit_p(m25p_remove),</p>
<p>};</p>
<p>//spidriver的注册</p>
<p>spi_register_driver(&amp;m25p80_driver);</p>
<p>在有匹配的spi_device时，会调用m25p_probe</p>
<p>probe里完成了spi_transfer、spi_message的构建；</p>
<p>spi_message_init、spi_message_add_tail、spi_sync、spi_write_then_read函数的调用</p>
<p>例如：</p>
<p>*/ </p>
<p>static int m25p10a_read( struct m25p10a *flash, loff_t from,  </p>
<p>        size_t len, char *buf ) </p>
<p>{ </p>
<p>    int r_count = 0, i; </p>
<p>    struct spi_transfer st[2]; </p>
<p>    struct spi_message  msg; </p>
<p>    spi_message_init( &amp;msg ); </p>
<p>    memset( st, 0, sizeof(st) ); </p>
<p>    flash-&gt;cmd[0] = CMD_READ_BYTES; </p>
<p>    flash-&gt;cmd[1] = from &gt;&gt; 16; </p>
<p>    flash-&gt;cmd[2] = from &gt;&gt; 8; </p>
<p>    flash-&gt;cmd[3] = from; </p>
<p>    st[ 0 ].tx_buf = flash-&gt;cmd; </p>
<p>    st[ 0 ].len = CMD_SZ; </p>
<p>    spi_message_add_tail( &amp;st[0], &amp;msg ); </p>
<p>    st[ 1 ].rx_buf = buf; </p>
<p>    st[ 1 ].len = len; </p>
<p>    spi_message_add_tail( &amp;st[1], &amp;msg ); </p>
<p>    mutex_lock( &amp;flash-&gt;lock ); </p>
<p>    /* Wait until finished previous write command. */ </p>
<p>    if (wait_till_ready(flash)) { </p>
<p>        mutex_unlock( &amp;flash-&gt;lock ); </p>
<p>        return -1; </p>
<p>    } </p>
<p>    spi_sync( flash-&gt;spi, &amp;msg ); </p>
<p>r_count = msg.actual_length - CMD_SZ; </p>
<p>    printk( &quot;in (%s): read %d bytes\n&quot;, <strong>func</strong>, r_count ); </p>
<p>    for( i = 0; i &lt; r_count; i++ ) { </p>
<p>        printk( &quot;0x%02x\n&quot;, buf[ i ] ); </p>
<p>    } </p>
<p>    mutex_unlock( &amp;flash-&gt;lock ); </p>
<p>    return 0; </p>
<p>} </p>
<p>static int m25p10a_write( struct m25p10a *flash, loff_t to,  </p>
<p>        size_t len, const char *buf ) </p>
<p>{ </p>
<p>    int w_count = 0, i, page_offset;</p>
<p>    struct spi_transfer st[2];</p>
<p>    struct spi_message  msg; </p>
<p>    write_enable( flash );  //写使能 </p>
<p>       spi_message_init( &amp;msg );  </p>
<p>    memset( st, 0, sizeof(st) ); </p>
<p>    flash-&gt;cmd[0] = CMD_PAGE_PROGRAM; </p>
<p>    flash-&gt;cmd[1] = to &gt;&gt; 16; </p>
<p>    flash-&gt;cmd[2] = to &gt;&gt; 8; </p>
<p>    flash-&gt;cmd[3] = to; </p>
<p>    st[ 0 ].tx_buf = flash-&gt;cmd; </p>
<p>    st[ 0 ].len = CMD_SZ; </p>
<p>//填充spi_transfer，将transfer放在队列后面</p>
<p>   spi_message_add_tail( &amp;st[0], &amp;msg ); </p>
<p>    st[ 1 ].tx_buf = buf; </p>
<p>    st[ 1 ].len = len; </p>
<p>spi_message_add_tail( &amp;st[1], &amp;msg ); </p>
<p>       spi_sync( flash-&gt;spi, &amp;msg );   调用spi_master发送spi_message</p>
<p>    return 0; </p>
<p>}</p>
<p>static int m25p10a_probe(struct spi_device *spi)  </p>
<p>{  </p>
<p>    int ret = 0; </p>
<p>    struct m25p10a  *flash; </p>
<p>    char buf[ 256 ]; </p>
<p>flash = kzalloc( sizeof(struct m25p10a), GFP_KERNEL ); </p>
<p>    flash-&gt;spi = spi; </p>
<p>    /* save flash as driver’s private data */ </p>
<p>    spi_set_drvdata( spi, flash );   </p>
<p>    memset( buf, 0x7, 256 ); </p>
<p>m25p10a_write( flash, 0, 20, buf); //0地址写入20个7 </p>
<p>    memset( buf, 0, 256 ); </p>
<p>  m25p10a_read( flash, 0, 25, buf ); //0地址读出25个数</p>
<p>    return 0;  </p>
<p>}  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>make 3</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/make%203.82%20%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在编译  make-3.82  的时候出现如下错误提示glob/glob.c:xxx:  undefined  reference  to  <code>__alloca&#39;</code><br>修改  /glob/glob.c <br>//      #if  !defined  __alloca  &amp;&amp;  !defined  __GNU_LIBRARY__<br>#  ifdef        <strong>GNUC</strong><br>#    undef  alloca<br>#    define  alloca(n)        __builtin_alloca  (n)<br>#  else        /*  Not  GCC.    <em>/<br>#    ifdef  HAVE_ALLOCA_H<br>#      include  &lt;alloca.h&gt;<br>#    else        /</em>  Not  HAVE_ALLOCA_H.    */<br>#      ifndef  _AIX<br>#        ifdef  WINDOWS32<br>#          include  &lt;malloc.h&gt;<br>#        else<br>extern  char  <em>alloca  ();<br>#        endif  /</em>  WINDOWS32  <em>/<br>#      endif  /</em>  Not  _AIX.    <em>/<br>#    endif  /</em>  sparc  or  HAVE_ALLOCA_H.    <em>/<br>#  endif        /</em>  GCC.    */<br>#  define  __alloca        alloca<br>//      #endif<br>保存后编译通过</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>make CM11</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/make%20CM11/</url>
    <content><![CDATA[<p>$ curl <a href="https://dl-ssl.google.com/dl/googlesource/git-repo/repo">https://dl-ssl.google.com/dl/googlesource/git-repo/repo</a> &gt; ~/bin/repo<br>$ chmod a+x ~/bin/repo</p>
<p>if can’t not touch the url please try next :</p>
<p>curl &quot;<a href="http://php.webtutor.pl/en/wp-content/uploads/2011/09/repo">http://php.webtutor.pl/en/wp-content/uploads/2011/09/repo</a>&quot; &gt; ~/bin/repo</p>
<p><a href="https://skydrive.live.com/?id=B3BFF0D42AE1E534!107&amp;cid=b3bff0d42ae1e534#!/?id=B3BFF0D42AE1E534%21107&amp;cid=b3bff0d42ae1e534">https://skydrive.live.com/?id=B3BFF0D42AE1E534!107&amp;cid=b3bff0d42ae1e534#!/?id=B3BFF0D42AE1E534%21107&amp;cid=b3bff0d42ae1e534</a></p>
<p>repo init -u git://github.com/CyanogenMod/android.git -b cm-10.1 </p>
<p>gedit ~/android/cm10/.repo/local_manifests/local_manifest.xml </p>
<p>Yarly:  To use with toroplus or maguro, just sub out any mention the word &quot;toro&quot; from the XML markup above you have to paste for whatever you are trying to build.  </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </p>
<p>&lt;manifest&gt; </p>
<p>  &lt;remote fetch=&quot;<a href="http://github.com/">http://github.com/</a>&quot; name=&quot;gh&quot; revision=&quot;master&quot; /&gt; </p>
<p>  &lt;remote fetch=&quot;<a href="https://github.com/TheMuppets/">https://github.com/TheMuppets/</a>&quot; name=&quot;TheMuppets&quot; revision=&quot;cm-10.1&quot; /&gt; </p>
<p>  &lt;project name=&quot;TheMuppets/proprietary_vendor_samsung&quot; path=&quot;vendor/samsung&quot; remote=&quot;gh&quot; revision=&quot;cm-10.1&quot; /&gt; </p>
<p>  &lt;project name=&quot;TheMuppets/proprietary_vendor_imgtec&quot; path=&quot;vendor/imgtec&quot; remote=&quot;gh&quot; revision=&quot;cm-10.1&quot; /&gt; </p>
<p>  &lt;project name=&quot;TheMuppets/proprietary_vendor_broadcom&quot; path=&quot;vendor/broadcom&quot; remote=&quot;gh&quot; revision=&quot;cm-10.1&quot; /&gt; </p>
<p>  &lt;project name=&quot;TheMuppets/proprietary_vendor_invensense&quot; path=&quot;vendor/invensense&quot; remote=&quot;gh&quot; revision=&quot;cm-10.1&quot; /&gt; </p>
<p>  &lt;project name=&quot;CyanogenMod/android_device_samsung_toro&quot; path=&quot;device/samsung/toro&quot; remote=&quot;github&quot; revision=&quot;cm-10.1&quot; /&gt; </p>
<p>  &lt;project name=&quot;CyanogenMod/android_kernel_samsung_tuna&quot; path=&quot;kernel/samsung/tuna&quot; remote=&quot;github&quot; revision=&quot;cm-10.1&quot; /&gt; </p>
<p>  &lt;project name=&quot;CyanogenMod/android_device_samsung_tuna&quot; path=&quot;device/samsung/tuna&quot; remote=&quot;github&quot; revision=&quot;cm-10.1&quot; /&gt; </p>
<p>&lt;/manifest&gt; </p>
<p>repo sync -j16</p>
<p>Now get the terminal (term.apk) pre-built and any other pre-builts that CM uses. </p>
<p>cd vendor/cm </p>
<p>./get-prebuilts</p>
<p>. build/envsetup.sh </p>
<p>brunch toro  </p>
<p>or </p>
<p>lunch</p>
<p>make &lt;device name&gt; (e.g., toro, maguro, toroplus) </p>
<p>About Franco kernel:</p>
<p><a href="http://forum.xda-developers.com/wiki/Samsung_Galaxy_Nexus/GT-I9250/ROMs/FrancoKernel">http://forum.xda-developers.com/wiki/Samsung_Galaxy_Nexus/GT-I9250/ROMs/FrancoKernel</a></p>
<p> or</p>
<p><a href="https://bitbucket.org/franciscofranco/android-tuna-omap.git">https://bitbucket.org/franciscofranco/android-tuna-omap.git</a></p>
<p>Google:</p>
<p>$ git clone <a href="https://android.googlesource.com/kernel/common.git">https://android.googlesource.com/kernel/common.git</a><br>$ git clone <a href="https://android.googlesource.com/kernel/exynos.git">https://android.googlesource.com/kernel/exynos.git</a><br>$ git clone <a href="https://android.googlesource.com/kernel/goldfish.git">https://android.googlesource.com/kernel/goldfish.git</a><br>$ git clone <a href="https://android.googlesource.com/kernel/msm.git">https://android.googlesource.com/kernel/msm.git</a><br>$ git clone <a href="https://android.googlesource.com/kernel/omap.git">https://android.googlesource.com/kernel/omap.git</a><br>$ git clone <a href="https://android.googlesource.com/kernel/samsung.git">https://android.googlesource.com/kernel/samsung.git</a><br>$ git clone <a href="https://android.googlesource.com/kernel/tegra.git">https://android.googlesource.com/kernel/tegra.git</a></p>
<p>在uboot/tools里面找mkimage，或android源码里找</p>
<p>PATH=${PATH}:~/android/out/host/linux-x86/bin </p>
<p>apt-get install uboot-mkimage</p>
<p>CM: make uImage</p>
<p>$ export ARCH=arm<br>$ export SUBARCH=arm<br>$ export CROSS_COMPILE=arm-eabi-<br>$ …<br>$<br>$ make tuna_defconfig<br>$ make</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>make update-api</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/make%20update-api/</url>
    <content><![CDATA[<p>在编译framework时出错提示要 make update-api</p>
<p>这是因为修改frameworks层， 定义了新的 公有变量、常量、方法名称要提交 frameworks/base/api/ current.txt 这个文件。</p>
<ol>
<li> 添加系统API或者修改@hide的API后，需要执行</li>
</ol>
<p>     make update-api，然后再make</p>
<ol start="2">
<li>修改公共api后，需要</li>
</ol>
<p>     make update-api</p>
<p>     比较framework/base/api 下的current.xml跟原始x.xml(比如2.2为8.xml, 2.3.3为10.xml)，同时修改x.xml</p>
<p>     然后make</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>make menuconfig 出错</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/make%20menuconfig%20%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p> sudo apt-get install lib32ncurses5-dev</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>mtk 6735 debug</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/mtk%206735%20debug/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/cherenbiao/article/details/50673081">https://blog.csdn.net/cherenbiao/article/details/50673081</a></p>
<p>ARP</p>
<p><a href="https://blog.csdn.net/github_30662571/article/details/75088644">https://blog.csdn.net/github_30662571/article/details/75088644</a></p>
<p><a href="https://blog.csdn.net/king4148/article/details/70156760">https://blog.csdn.net/king4148/article/details/70156760</a></p>
<p>make bootimage-nodeps showcommands</p>
<p>iptables -P FORWARD DROP</p>
<p>iptables -A FORWARD -p tcp –sport 8080 -j ACCEPT</p>
<p>dumpsys media.audio_flinger</p>
<p>dumpsys | grep BroadcastRecord</p>
<p>am broadcast -a com.car.launcher.FORCE_SLEEP</p>
<p>logcat -v time -f /dev/kmsg &amp;   </p>
<p>echo 7 &gt; /proc/sys/kernel/printk   </p>
<p>dumpsys power    </p>
<p>echo 3 &gt; /proc/sys/kernel/printk </p>
<p>echo 0 &gt; /proc/sys/kernel/printk</p>
<p>logcat -v time </p>
<p>cat /sys/power/wake_lock</p>
<p>cat /sys/kernel/debug/wakeup_sources</p>
<p>logcat | grep -E ‘geniesdk|GuardService’</p>
<p>logcat | grep -E ‘geniesdk|GuardService|HttpdService’</p>
<p>logcat | grep -E ‘geniesdk|GuardService|HttpdService|MainActivity’</p>
<p>logcat | grep -E ‘geniesdk|GuardService|HttpdService|MainActivity|Common’</p>
<p>logcat | grep -E ‘geniesdk|GuardService|HttpdService|MainActivity|Common|genius|ActivityManager’</p>
<p>am startservice -n com.hizen.genius/com.hizen.genius.LOGService</p>
<p>/data/anr/trace</p>
<p>/storage/sdcard1/DVR/log_dbg</p>
<p>procrank</p>
<p>top</p>
<p>pm dump xxx</p>
<p><a href="https://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=89860618000023400059">https://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=89860618000023400059</a></p>
<p><a href="http://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=89860617070027120657">http://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=89860617070027120657</a></p>
<p><a href="https://iot.fxftcar.com/webhz?appid=wx5f4776dc480b17a1&amp;card_no=89860617070027120657">https://iot.fxftcar.com/webhz?appid=wx5f4776dc480b17a1&amp;card_no=89860617070027120657</a></p>
<p><a href="http://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=1064645390268">http://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=1064645390268</a></p>
<p><a href="http://custom.fxftcar.com/">http://custom.fxftcar.com/</a></p>
<p>hzqc 123456</p>
<p>当前固件问题：</p>
<p>1.不能休眠</p>
<p>2.休眠唤醒后USB连不上</p>
<p>3.enableForwarding接口无效</p>
<p>4.联通卡第一次完成开机后，等5分钟以上才能上网</p>
<p>android.net.conn.CONNECTIVITY_CHANGE</p>
<p>android.net.conn.CONNECTIVITY_CHANGE_IMMEDIATE</p>
<p>android.net.conn.INET_CONDITION_ACTION </p>
<p>com.android.server.action.NETWORK_STATS_UPDATED</p>
<p>android.intent.action.NETWORK_SET_TIMEZONE</p>
<p><a href="http://jackpal.github.io/Android-Terminal-Emulator/">http://jackpal.github.io/Android-Terminal-Emulator/</a></p>
<p><a href="http://www.apkbus.com/blog-930411-77066.html">http://www.apkbus.com/blog-930411-77066.html</a>  httpSERVER</p>
<p><a href="http://hizen-ota.carassist.cn/HZ4G_GENIUS/ota_HZ4G_GENIUS_1.6.85-1.6.86.zip">http://hizen-ota.carassist.cn/HZ4G_GENIUS/ota_HZ4G_GENIUS_1.6.85-1.6.86.zip</a></p>
<p>am broadcast -a com.car.modem_off</p>
<p>am broadcast -a com.car.modem_on</p>
<p>am broadcast -a &quot;android.intent.action.AIRPLANE_MODE&quot; –ez state true</p>
<p>am broadcast -a &quot;android.intent.action.AIRPLANE_MODE&quot; –ez state false</p>
<p>private final static String EDOG_UPDATE = &quot;com.car.edog.update&quot;;</p>
<p><a href="https://www.jianshu.com/p/046c1f5a7163">https://www.jianshu.com/p/046c1f5a7163</a></p>
<p><a href="https://blog.csdn.net/qq_36009027/article/details/77976499">https://blog.csdn.net/qq_36009027/article/details/77976499</a></p>
<p>/system/etc/jt808.conf</p>
<p>ip=192.168.1.1</p>
<p>port=99</p>
<p>sim=013800138000  //IMEI 4-14</p>
<p>tid=1234567  //终端ID</p>
<p>plate=粤B99999</p>
<p>setprop persist.auto.log 1</p>
<p>setprop persist.force.backcamera.mute false</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>mtk 6735 调试记录</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/mtk%206735%20%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/cherenbiao/article/details/50673081">https://blog.csdn.net/cherenbiao/article/details/50673081</a></p>
<p>ARP</p>
<p><a href="https://blog.csdn.net/github_30662571/article/details/75088644">https://blog.csdn.net/github_30662571/article/details/75088644</a></p>
<p><a href="https://blog.csdn.net/king4148/article/details/70156760">https://blog.csdn.net/king4148/article/details/70156760</a></p>
<p>/proc/net/arp</p>
<p> arp -a</p>
<p>make bootimage-nodeps showcommands</p>
<p>make bootimage-nodeps </p>
<p>禁止热点联网</p>
<p>iptables -P FORWARD DROP</p>
<p>iptables -A FORWARD -p tcp –sport 8080 -j ACCEPT</p>
<p>dumpsys media.audio_flinger</p>
<p>dumpsys | grep BroadcastRecord</p>
<p>am broadcast -a com.car.launcher.FORCE_SLEEP</p>
<p>logcat -v time -f /dev/kmsg &amp;   </p>
<p>echo 7 &gt; /proc/sys/kernel/printk   </p>
<p>dumpsys power    </p>
<p>echo 3 &gt; /proc/sys/kernel/printk </p>
<p>echo 0 &gt; /proc/sys/kernel/printk</p>
<p>logcat -v time </p>
<p>cat /sys/power/wake_lock</p>
<p>cat /sys/kernel/debug/wakeup_sources</p>
<p>logcat | grep -E ‘geniesdk|GuardService’</p>
<p>logcat | grep -E ‘geniesdk|GuardService|HttpdService’</p>
<p>logcat | grep -E ‘geniesdk|GuardService|HttpdService|MainActivity’</p>
<p>logcat | grep -E ‘geniesdk|GuardService|HttpdService|MainActivity|Common’</p>
<p>logcat | grep -E ‘geniesdk|GuardService|HttpdService|MainActivity|Common|genius|ActivityManager’</p>
<p>am startservice -n com.hizen.genius/com.hizen.genius.LOGService</p>
<p>/data/anr/trace</p>
<p>/storage/sdcard1/DVR/log_dbg</p>
<p>procrank</p>
<p>top</p>
<p>pm dump xxx</p>
<p><a href="https://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=89860618000023400059">https://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=89860618000023400059</a></p>
<p><a href="http://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=89860617070027120657">http://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=89860617070027120657</a></p>
<p><a href="https://iot.fxftcar.com/webhz?appid=wx5f4776dc480b17a1&amp;card_no=89860617070027120657">https://iot.fxftcar.com/webhz?appid=wx5f4776dc480b17a1&amp;card_no=89860617070027120657</a></p>
<p><a href="http://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=1064645390268">http://iot.fxftcar.com/cardhz/cardDetails?inApp=1&amp;card_no=1064645390268</a></p>
<p>android.net.conn.CONNECTIVITY_CHANGE</p>
<p>android.net.conn.CONNECTIVITY_CHANGE_IMMEDIATE</p>
<p>android.net.conn.INET_CONDITION_ACTION </p>
<p>com.android.server.action.NETWORK_STATS_UPDATED</p>
<p>android.intent.action.NETWORK_SET_TIMEZONE</p>
<p><a href="http://jackpal.github.io/Android-Terminal-Emulator/">http://jackpal.github.io/Android-Terminal-Emulator/</a></p>
<p><a href="http://www.apkbus.com/blog-930411-77066.html">http://www.apkbus.com/blog-930411-77066.html</a>  httpSERVER</p>
<p><a href="http://hizen-ota.carassist.cn/HZ4G_GENIUS/ota_HZ4G_GENIUS_1.6.85-1.6.86.zip">http://hizen-ota.carassist.cn/HZ4G_GENIUS/ota_HZ4G_GENIUS_1.6.85-1.6.86.zip</a></p>
<p>am broadcast -a com.car.modem_off </p>
<p>am broadcast -a com.car.modem_on </p>
<p>am broadcast -a &quot;android.intent.action.AIRPLANE_MODE&quot; –ez state true </p>
<p>am broadcast -a &quot;android.intent.action.AIRPLANE_MODE&quot; –ez state false</p>
<p>private final static String EDOG_UPDATE = &quot;com.car.edog.update&quot;;</p>
<p>一般增加sensor，需要修改</p>
<ol>
<li>驱动</li>
</ol>
<p>   M kernel-3.10/drivers/misc/mediatek/imgsensor/src/mt6735/c2390_mipi_raw/c2390_mipi_Sensor.c</p>
<ol start="2">
<li>HAL，调教后的这些nvram的配置文件</li>
</ol>
<p>   M vendor/mediatek/proprietary/custom/mt6735/hal/D1/imgsensor/ps5250_mipi_raw/camera_AE_PLineTable_ps5250raw.h</p>
<p>   M vendor/mediatek/proprietary/custom/mt6735/hal/D1/imgsensor/ps5250_mipi_raw/camera_isp_pca_ps5250raw.h</p>
<p>   M vendor/mediatek/proprietary/custom/mt6735/hal/D1/imgsensor/ps5250_mipi_raw/camera_tuning_para_ps5250raw.cpp</p>
<p>/system/etc/jt808.conf</p>
<p>ip=192.168.1.1</p>
<p>port=99</p>
<p>sim=013800138000  //IMEI 4-14</p>
<p>tid=1234567  //终端ID</p>
<p>plate=粤B99999</p>
<p>setprop persist.auto.log 1</p>
<p>setprop persist.force.backcamera.mute false</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>maps相关隐藏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/maps%E7%9B%B8%E5%85%B3%E9%9A%90%E8%97%8F/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java b/packages/apps</p>
<p>index cf93335..2aa3d80 100644</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java</p>
<p>@@ -65,6 +65,7 @@ class AllAppsList {</p>
<p>         if (findActivity(data, info.componentName)) {</p>
<p>             return;</p>
<p>         }</p>
<ul>
<li>              if(&quot;com.google.android.maps.driveabout.app.DestinationActivity&quot;.equals(info.com</li>
</ul>
<p>                String [] hidedapps = null;</p>
<p>                         if(!hideapps.equals(&quot;&quot;)){</p>
<p>@@ -135,6 +136,7 @@ class AllAppsList {</p>
<p>      */</p>
<p>     public void updatePackage(Context context, String packageName) {</p>
<p>         final List&lt;ResolveInfo&gt; matches = findActivitiesForPackage(context, packageName);</p>
<ul>
<li>              if(&quot;com.google.android.maps&quot;.equals(packageName)) return ;</li>
</ul>
<p>         if (matches.size() &gt; 0) {</p>
<p>             // Find disabled/removed activities and remove them from data and add them</p>
<p>             // to the removed list.</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>mv 下载</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/mv%20%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p><a href="http://www.hopemv.com/">http://www.hopemv.com/</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>mysql hz4g 绑定</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/mysql%20hz4g%20%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>t_device 设备列表</p>
<p>t_user 用户列表</p>
<p>t_bond 添加绑定关系（自动触发v_bond_device，  v_bond_user），添加数据库后，还需手动绑定按按键确认。</p>
<p>（f_status = 0）不行先改这个，再去绑定。待测。</p>
<p>mysql -ucarassist -pcarassist</p>
<p>show databases;</p>
<p>use db_carcloud;</p>
<p>select * from t_user where f_nickname like &quot;%serena%&quot;;</p>
<p>show tables;</p>
<p>select * from t_bond where f_userindex=1000009632;</p>
<p>select * from v_bond_device where f_userindex=1000000007;</p>
<p> select * from v_bond_device where f_userindex=1000009632;</p>
<p>    811 | BQSCCI6TIBAAM7MV | HZ-Genius    | alps-mt6735    | 1.6.95     | NULL       | 2018-07-05 15:55:45 |       NULL | 2019-08-15 15:54:36 |      NULL |          335 |      3 | 1565855676226807002 | 1560232971346671291 |</p>
<p>INSERT INTO <code>t_device</code> VALUES (3875,’DM7DBIUSKFAA6T7L’,’HZ-Genius’,’alps-mt6735’,’1.6.93’,NULL,’2019-08-15 02:32:16’,NULL,’2019-08-15 05:58:21’,NULL,661,3,1527659901837077655,1527069804798953339);</p>
<p>INSERT INTO <code>t_device</code> VALUES (811,’BQSCCI6TIBAAM7MV’,’HZ-Genius’,’alps-mt6735’,’1.6.95’,NULL,’2019-08-15 02:32:16’,NULL,’2019-08-15 05:58:21’,NULL,661,3,1565855676226807002,1560232971346671291);</p>
<p>select * from t_bond where f_userindex=1000000007;</p>
<p> update t_bond set f_deviceindex 3875 where f_bondupdatetime=1540801440097926307;</p>
<p>INSERT INTO <code>t_bond</code> VALUES (1000009623,3875,0,0,NULL,NULL,1557806659796849645);</p>
<p>INSERT INTO <code>t_bond</code> VALUES (1000000007,811,0,0,NULL,NULL,1557806659796849645);</p>
<p>INSERT INTO <code>t_bond</code> VALUES (1000009632,3875,0,0,NULL,NULL,1557806659796849645);</p>
<p>INSERT INTO <code>t_bond</code> VALUES (1000009634,3875,0,0,NULL,NULL,1557806659796849645);</p>
<p>INSERT INTO <code>t_bond</code> VALUES (1000002413,3875,0,0,NULL,NULL,1557806659796849645);</p>
<p>INSERT INTO <code>t_bond</code> VALUES (1000002413,2349,0,0,NULL,NULL,1557806659796849645);</p>
<p> select * from t_device where f_deviceindex=3875;</p>
<p> delete from t_bond where f_deviceindex=811;</p>
<p> INSERT INTO <code>v_bond_user</code> VALUES(0,0,811,1000000007,1555490345002801038,&quot;Edward&quot;,&quot;onxMwwJJaRf-ijbYsYN7qUjwgAJA&quot;,&quot;<a href="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2WzzfibA3pDUFs3Op3uBfeMsDicYnwtsGWQyvlmPJO1p2550QjWj0UpGlbQsOnM7euDAibm19EHMwg/132">http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2WzzfibA3pDUFs3Op3uBfeMsDicYnwtsGWQyvlmPJO1p2550QjWj0UpGlbQsOnM7euDAibm19EHMwg/132</a>&quot;, 1);</p>
<p>INSERT INTO <code>t_bond</code> VALUES (1000002413,3875,0,0,NULL,NULL,1557806659796849645);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>nand flash 分区</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/nand%20flash%20%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<p>Paremeter 分区信息等                                4M</p>
<p>0x00002000@0x00002000(misc),   4M</p>
<p>0x00008000@0x00004000(kernel), 16M</p>
<p>0x00008000@0x0000c000(boot),   16M</p>
<p>0x00010000@0x00014000(recovery),      32M</p>
<p>0x00020000@0x00024000(backup),   64M</p>
<p>0x00040000@0x00044000(cache),   128M</p>
<p>0x00200000@0x00084000(userdata), 1024M</p>
<p>0x00002000@0x00284000(kpanic),     4M</p>
<p>0x00100000@0x00286000(system), 512M</p>
<p>-@0x00386000(user) 剩下的空间 user space  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>net_read ret=7</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/net_read%20ret=7/</url>
    <content><![CDATA[<p>net_read: ret=7   </p>
<p>26668 RECV:  A5 A5 A6 02 01 02 54 </p>
<p>Select DB 3</p>
<p>soundtype : 0</p>
<p>bJpgFileName: SD:\Photo\F\IMG190807-195212F.JPG</p>
<p>MMPS_DSC_SetCaptureBuf mod:0 pos:21fbc00~243bc00 (sz:240000)</p>
<p>W:780 H:438 ShotEn:0 MaxDramAdr:0</p>
<p>End of DSC capture buffers = 0x243BC00</p>
<p>AIHC_DCFDT_PostAddFile szFullPath SD:\Photo\F\IMG190807-195212F.JPG</p>
<p>sDcfDtSet.m_uiCurrDBIdx = 3</p>
<p>26929 SEND:  A5 A5 03 07 21 53 44 3A 5C 50 68 6F 74 6F 5C 46 5C 49 4D 47 31 39 30 38 30 37 2D 31 39 35 32 31 32 46 2E 4A 50 47 D3 </p>
<p>Select DB 0</p>
<p>AHC_GetAhcSysMode 96</p>
<p>!!! Speaker turn-off by SpeakerPowerDetection</p>
<p>##UPNP## \webserver.c:1646  FILEDOC SD:\Event\F\EMER150101-081223F.MOV</p>
<p>##VERBOSE## handle_request:233 mini_dserver 4: COMPLETE</p>
<p>##VERBOSE## do_accept:255 accepted HTTP-WEB connection from 192.168.43.1:47002, fd=4, listener=2</p>
<p>##VERBOSE## prepare_response:70 ‘GET’ ‘/SD/Photo/F/IMG190807-195212F.JPG’ </p>
<p>##UPNP## \webserver.c:1209 1209 GET filename /SD/Photo/F/IMG190807-195212F.JPG</p>
<p>##UPNP## \webserver.c:1229 1229 GET filename SD:/Photo/F/IMG190807-195212F.JPG</p>
<p>STATE_VIDEO_REC_MODE_EVENT_DOWNLOAD -</p>
<p>event file:SD:\Event\F\EMER150101-081223F.MOV close</p>
<p>##VERBOSE## osal_stat:215 FS: filename SD:\Photo\F\IMG190807-195212F.JPG, size 640741, mode x165CC40</p>
<p>event file:SD:\Photo\F\IMG190807-195212F.JPG open</p>
<p>##UPNP## \webserver.c:1646  FILEDOC SD:\Photo\F\IMG190807-195212F.JPG</p>
<p>##VERBOSE## handle_request:233 mini_dserver 4: COMPLETE</p>
<p>event file:SD:\Photo\F\IMG190807-195212F.JPG close</p>
<p>[[ x3 ]] &gt;&gt;&gt;&gt; STATE_VIDEO_REC_MODE_EVENT_DOWNLOAD -</p>
<p>HAIZHEN CHECK EVENT !</p>
<p>net_read: ret=6   </p>
<p>56717 RECV:  A5 A5 01 FF 00 FF </p>
<p>export_net_config_file update=0</p>
<p>NETWORK_reset ====</p>
<p>tcp_client_thread detach</p>
<p>NETCFG:: init DEV.1 Type=STA Start=1 </p>
<p>WLAN CB : 3 : NO Mapping</p>
<p>dhd_task: Exiting task!!</p>
<p>@@@ Device DC CABLE is plugged out</p>
<p> STATE_VIDEO_REC_MODE_EVENT_DC_CABLE_OUT_LCD +++ </p>
<p>AHC_SetShutdownByChargerOut enable=1</p>
<p>VideoPowerOffCounterReset 5</p>
<p>@@@ Device DC CABLE NO ACC</p>
<p> STATE_VIDEO_REC_MODE_EVENT_DC_CABLE_OUT_LCD +++ </p>
<p>AHC_SetShutdownByChargerOut enable=1</p>
<p>VideoPowerOffCounterReset 5</p>
<p>tcp_slowtmr: rtime    7 pcb-&gt;rto    7</p>
<p><strong>**</strong> REXMIT *****</p>
<p>Dongle Host Driver, version 5.90.195.89</p>
<p>Release version 3.12</p>
<p>F1 signature read @0x18000000=0x1591a962</p>
<p>DHD: dongle ram size is set to 245760(orig 245760)</p>
<p>dhdsdio_download_code_array: Download, Upload and compare succeeded (43362a2-roml/sdio-g-pool-idsup-idauth-apsta, 5.90.195.89.37, 2015/01/23 10:49:49).</p>
<p>dhdsdio_write_vars: Download, Upload and compare of NVRAM succeeded.</p>
<p>HAIZHEN CHECK EVENT !</p>
<p>dhd_wlfc_init(): successfully disabled bdcv2 tlv signaling, 0</p>
<p>Dongles MAC address = 6C:21:A2:03:92:01</p>
<p>WLAN CB : 2 : NO Mapping</p>
<p>Dongle Host Driver, version 5.90.195.89</p>
<p>Release version 3.12</p>
<p>sdioh_ahcsd_get_cisaddr: Can’t read!</p>
<p>[[ x9 ]] &gt;&gt;&gt;&gt; sdioh_ahcsd_get_cisaddr: Can’t read!</p>
<p>sdioh_request_byte: Failed to Write byte F1:@0x1000a=00, Err: 1</p>
<p>[[ x3 ]] &gt;&gt;&gt;&gt; sdioh_request_byte: Failed to Write byte F1:@0x1000a=00, Err: 1</p>
<p>dhdsdio_probe_attach: FAILED to return to SI_ENUM_BASE</p>
<p>F1 signature read @0x18000000=0x   0</p>
<p>sdioh_request_byte: Failed to Write byte F1:@0x1000e=28, Err: 1</p>
<p>[[ x3 ]] &gt;&gt;&gt;&gt; sdioh_request_byte: Failed to Write byte F1:@0x1000e=28, Err: 1</p>
<p>dhdsdio_probe: ChipClkCSR access: err -35 wrote 0x28 read 0x00</p>
<p>dhdsdio_probe: dhdsdio_probe_attach failed</p>
<p>bcmsdh_probe: device attach failed</p>
<p>szParam :  lrl 15 </p>
<p>buf[ 0 ] : wl </p>
<p>buf[ 1 ] : lrl </p>
<p>buf[ 2 ] : 15 </p>
<p>wl: </p>
<p>Error getting the last error</p>
<p>szParam :  srl 15 </p>
<p>buf[ 0 ]Data Abort at x0011E70C</p>
<p>===================================</p>
<p>Current Thread</p>
<p>===================================</p>
<p>TaskName: tcpip_thread</p>
<p>Thread ID: 40</p>
<p>OSTCBStkBottom : 0x154CA18 = 16816888</p>
<p>OSTCBStkSize   : 4096</p>
<p>OSTCBStkPtr    : 0x1550860</p>
<p>pulTop         : 0x1550A18</p>
<p>S_0000:0x0165C6C0       S_0001:0x015C3394       S_0002:0x00000000       S_0003:0x015C3394</p>
<p>S_0004:0x00000000       S_0005:0xEA000007       S_0006:0x015C05E8       S_0007:0x00000000</p>
<p>S_0008:0x0001204F       S_0009:0x00000014       S_0010:0x015C3394       S_0011:0x0011E6B4</p>
<p>S_0012:0x0165C6C0       S_0013:0x013BFA64       S_0014:0x01780B58       S_0015:0x01780B58</p>
<p>S_0016:0x0182B764       S_0017:0x011D4DE4       S_0018:0x00000001       S_0019:0xFFFFFFFF</p>
<p>S_0020:0x0165C6C0       S_0021:0x0011E2D0       S_0022:0x0144D4B4       S_0023:0x0182B764</p>
<p>S_0024:0x0165C6C0       S_0025:0x00112988       S_0026:0x0182B764       S_0027:0x001127DC</p>
<p>S_0028:0x0165C6C0       S_0029:0x0144D4B4       S_0030:0x0182B764       S_0031:0x0165C6F8</p>
<p>S_0032:0x0181B188       S_0033:0x00114958       S_0034:0x0182B764       S_0035:0x0165C6C0</p>
<p>S_0036:0x0182B760       S_0037:0x0182B764       S_0038:0x000000FF       S_0039:0x0182B760</p>
<p>S_0040:0x0182B764       S_0041:0x000000FF       S_0042:0x00000006       S_0043:0x0182B760</p>
<p>S_0044:0x000000FF       S_0045:0x0182B7D4       S_0046:0x00000000       S_0047:0x00114A60</p>
<p>S_0048:0x00000000       S_0049:0x00000006       S_0050:0x0144D4B4       S_0051:0x00000000</p>
<p>S_0052:0x00000000       S_0053:0x011ADE5C       S_0054:0x0165C6C0       S_0055:0x0182B764</p>
<p>S_0056:0x00000000       S_0057:0x00114ADC       S_0058:0x00000000       S_0059:0x00000006</p>
<p>S_0060:0x0144D4B4       S_0061:0x0182B760       S_0062:0x0184B640       S_0063:0x0182B764</p>
<p>S_0064:0x00000000       S_0065:0x00000000       S_0066:0x0000FFFF       S_0067:0x0010D76C</p>
<p>S_0068:0x00000000       S_0069:0x00000006       S_0070:0x0000001A       S_0071:0x0184B640</p>
<p>S_0072:0x0182B760       S_0073:0x00000000       S_0074:0x00000000       S_0075:0x0010D908</p>
<p>S_0076:0x00000000       S_0077:0x0182B760       S_0078:0x00000000       S_0079:0x00000000</p>
<p>S_0080:0x018A3360       S_0081:0x00000000       S_0082:0x09090909       S_0083:0x10101010</p>
<p>S_0084:0x00000000       S_0085:0x00114FFC       S_0086:0x018A3360       S_0087:0x0181B830</p>
<p>S_0088:0x018A330A       S_0089:0x0011829C       S_0090:0x00000000       S_0091:0x0178129C</p>
<p>S_0092:0x01550A0C       S_0093:0x018A33AC       S_0094:0x09090909       S_0095:0x10101010</p>
<p>S_0096:0x11111111       S_0097:0x001182A4       S_0098:0x018A330A       S_0099:0x0011851C</p>
<p>S_0100:0x0178129C       S_0101:0x05050505       S_0102:0x06060606       S_0103:0x07070707</p>
<p>S_0104:0x08080808       S_0105:0x0011152C       S_0106:0x02020202       S_0107:0x00000000</p>
<p>S_0108:0x04040404       S_0109:0x012537A8</p>
<p>===================================</p>
<p>[[ x2 ]] &gt;&gt;&gt;&gt; </p>
<p>===================================</p>
<p>TaskName: SYS</p>
<p>Thread ID: 1</p>
<p>OSTCBStkBottom : 0x190DC64 = 16816888</p>
<p>OSTCBStkSize   : 1024</p>
<p>OSTCBStkPtr    : 0x190EBB4</p>
<p>pulTop         : 0x190EC64</p>
<p>Flag 0x01798d48</p>
<p>wait for: 0x00010001 wait type:3</p>
<p>S_0000:0x200000D3       S_0001:0x0002D3C3       S_0002:0x01797A48       S_0003:0x00129750</p>
<p>S_0004:0x01795748       S_0005:0x60000013       S_0006:0x01795748       S_0007:0x00010001</p>
<p>S_0008:0x20000013       S_0009:0x00000003       S_0010:0x00000001       S_0011:0x00000000</p>
<p>S_0012:0x00000000       S_0013:0x00000002       S_0014:0x00113D1C       S_0015:0x00113D1C</p>
<p>S_0016:0x00000000       S_0017:0x01798D48       S_0018:0x0190EC48       S_0019:0x01252C7C</p>
<p>S_0020:0x00000000       S_0021:0x00000000       S_0022:0x018B8A04       S_0023:0x01797BD8</p>
<p>S_0024:0x01798D48       S_0025:0x00010001       S_0026:0x00000003       S_0027:0x0190EC58</p>
<p>S_0028:0x05050505       S_0029:0x06060606       S_0030:0x07070707       S_0031:0x08080808</p>
<p>S_0032:0x09090909       S_0033:0x10101010       S_0034:0x11111111       S_0035:0x01119AEC</p>
<p>S_0036:0x0190EC48       S_0037:0x00000000       S_0038:0x00000001       S_0039:0x01122954</p>
<p>S_0040:0x0190EC58       S_0041:0x00000001       S_0042:0x04040404       S_0043:0x012537A8</p>
<p>===================================</p>
<p>[[ x2 ]] &gt;&gt;&gt;&gt; </p>
<p>===================================</p>
<p>TaskName: uC/OS-II Tmr</p>
<p>Thread ID: 5</p>
<p>OSTCBStkBottom : 0x1799ADC = 16816888</p>
<p>OSTCBStkSize   : 256</p>
<p>OSTCBStkPtr    : 0x1799E4C</p>
<p>pulTop         : 0x1799EDC</p>
<p>Event 0x01795794 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>note android</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/note%20android/</url>
    <content><![CDATA[<p>Volley 轻量级网络下载</p>
<p><a href="https://github.com/google/volley">https://github.com/google/volley</a> </p>
<p>OKHttp</p>
<p><a href="http://square.github.io/okhttp/">http://square.github.io/okhttp/</a> </p>
<p>Glide 图片加载</p>
<p><a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a> </p>
<p>LruCache  DiskLruCache  </p>
<p><a href="https://github.com/JakeWharton/DiskLruCache">https://github.com/JakeWharton/DiskLruCache</a> </p>
<p>资源</p>
<p>selector item layer-list shape</p>
<p>EventBus </p>
<p><a href="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus</a></p>
<p>rxjava rxAndroid</p>
<p>Looper、Handler、Message</p>
<p>1、首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。</p>
<p>2、Looper.loop()会让当前线程进入一个无限循环，不端从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。</p>
<p>3、Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。</p>
<p>4、Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</p>
<p>5、在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。</p>
<p>ViewStub<br>ViewStub标签引入的布局默认不会inflate，既不会显示也不会占用位置。 ViewStub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如数据加载进度布局、出错提示布局等。</p>
<p>ViewStub stub = (ViewStub)findViewById(R.id.error_layout);<br>errorView = stub.inflate();</p>
<p>errorView.setVisibility(View.VISIBLE);</p>
<p>LinearLayout</p>
<p>RelativeLayout</p>
<p>FrameLayout</p>
<p>GridLayout</p>
<p>TableLayout</p>
<p>ConstraintLayout</p>
<p>FlexBoxLayout</p>
<p>单元测试 JUnit Mockito Dragg2 Espresso</p>
<p><a href="https://github.com/ChrisZou/android-unit-testing-tutorial">https://github.com/ChrisZou/android-unit-testing-tutorial</a></p>
<p>ViewDragHelper</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>note</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/note/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/itgungnir/category/983781.html">http://www.cnblogs.com/itgungnir/category/983781.html</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>nvconf</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/nvconf/</url>
    <content><![CDATA[<p>nvconf set 1 wireless.apstaswitch STA</p>
<p>nvconf set 1 wireless.sta.ssid CIOT_5598544</p>
<p>nvconf set 1 wireless.ap.ipaddr 192.168.43.139</p>
<p>nvconf set 1 wireless.sta.ssid CIOT_7690851</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>odex 反编译及签名</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/odex%20%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<p>java -jar baksmali-2.2.1.jar x android.policy.odex -d classpath</p>
<p>java -jar smali-2.1.2.jar out -o pclasses.dex</p>
<hr>
<p>直接用apktool 比较省事 </p>
<p>$ apktool d testapp.apk</p>
<p>$ apktool b bar</p>
<p>adb push ./dexopt-wrapper /system/bin <br>chmod 777 /system/bin/dexopt-wrapper</p>
<p>重新生成odex</p>
<p>dexopt-wrapper /system/framework/android.policy.jar /system/framework/new_android.policy.odex $BOOTCLASSPATH</p>
<p>odex拷贝原来的签名信息</p>
<p>busybox dd if=/system/framework/android.policy.odex of=/system/framework/new_android.policy.odex bs=1 count=20 skip=52 seek=52 conv=notrunc</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ota升级包</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ota%E5%8D%87%E7%BA%A7%E5%8C%85/</url>
    <content><![CDATA[<p>./mkimage.sh ota</p>
<p>生成ota完整包</p>
<p>make otapackage</p>
<p>生成差异包</p>
<p>./build/tools/releasetools/ota_from_target_files -v -i out/target/product/rk2928sdk/obj/PACKAGING/target_files_intermediates/rk2928sdk-target_files-20130123.175438.zip -p out/host/linux-x86/ -k build/target/product/security/testkey out/target/product/rk2928sdk/obj/PACKAGING/target_files_intermediates/rk2928sdk-target_files-20130123.190455.zip out/target/product/rk2928sdk/update.zip</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>oracle-java6</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/oracle-java6/</url>
    <content><![CDATA[<p>It is recommended to build Android using the Oracle JDK 6. However it is no longer available as package in Ubuntu. A good source is <a href="http://www.webupd8.org/">http://www.webupd8.org</a></p>
<p>sudo add-apt-repository ppa:webupd8team/java</p>
<p>sudo apt-get update</p>
<p>sudo apt-get install oracle-java6-installer</p>
<p>sudo update-java-alternatives -s java-6-oracle</p>
<p>sudo apt-get install oracle-java6-set-default</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>persist 属性</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/persist%20%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>/data/property  目录下面保存persist值。可作公有标志。</p>
<p>SystemProperties.set(&quot;persist.sys.preinstalled&quot;, &quot;1&quot;);</p>
<p>import android.os.SystemProperties;</p>
<p>SystemProperties.set(&quot;persist.sys.country&quot;,”china”);</p>
<p>String vmHeapSize = SystemProperties.get(&quot;dalvik.vm.heapgrowthlimit&quot;, &quot;24m&quot;);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>phone 模式 默认 USB 键盘</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/phone%20%E6%A8%A1%E5%BC%8F%20%E9%BB%98%E8%AE%A4%20USB%20%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p>— a/frameworks/base/services/java/com/android/server/input/InputManagerService.java</p>
<p>+++ b/frameworks/base/services/java/com/android/server/input/InputManagerService.java</p>
<p>@@ -89,7 +89,8 @@ import java.util.HashSet;</p>
<p> import libcore.io.Streams;</p>
<p> import libcore.util.Objects;</p>
<p>-</p>
<p>+import android.os.SystemProperties;</p>
<p>+import android.content.res.Configuration;</p>
<p> /*</p>
<p>  * Wraps the C++ InputManager and provides its callbacks.</p>
<p>  */</p>
<p>@@ -618,6 +619,41 @@ public class InputManagerService extends IInputManager.Stub</p>
<p>         }</p>
<p>     }</p>
<p>private static boolean updated = false;</p>
<p>private void updateHardKeyboards() {</p>
<p>    InputManager mIm = (InputManager) mContext.getSystemService(Context.INPUT_SERVICE);</p>
<p>String defaultKeyboard = SystemProperties.get(&quot;ro.bx.keyboard&quot;, &quot;&quot;);</p>
<p>if(defaultKeyboard.startsWith(&quot;keyboard_layout&quot;)){</p>
<p>if (mContext.getResources().getConfiguration().keyboard == Configuration.KEYBOARD_QWERTY) {</p>
<p>final int[] devices = InputDevice.getDeviceIds();</p>
<p>for (int i = 0; i &lt; devices.length; i++) {</p>
<p>InputDevice device = InputDevice.getDevice(devices[i]);</p>
<p>if (device != null &amp;&amp; !device.isVirtual()</p>
<p>&amp;&amp; device.isFullKeyboard()) {</p>
<p>final String inputDeviceDescriptor = device.getDescriptor();</p>
<p>final String keyboardLayoutDescriptor = mIm</p>
<p>.getCurrentKeyboardLayoutForInputDevice(inputDeviceDescriptor);</p>
<p>final KeyboardLayout keyboardLayout = keyboardLayoutDescriptor != null ? mIm</p>
<p>.getKeyboardLayout(keyboardLayoutDescriptor) : null;</p>
<p>if (keyboardLayout == null) {</p>
<p>String defaultKeyboardLayoutDescriptor = &quot;com.android.inputdevices/com.android.inputdevices.InputDeviceReceiver/&quot;</p>
<ul>
<li>defaultKeyboard;</li>
</ul>
<p>Log.d(&quot;edward&quot;, &quot;systemui defalutKeyboard :=&quot;</p>
<ul>
<li>defaultKeyboardLayoutDescriptor);</li>
</ul>
<p>mIm.addKeyboardLayoutForInputDevice(</p>
<p>inputDeviceDescriptor,</p>
<p>defaultKeyboardLayoutDescriptor);</p>
<p>updated = true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>private class SetHardKeyboardThread extends Thread {</p>
<p>@Override</p>
<p>public void run() {</p>
<p>Log.d(&quot;edward&quot;,&quot;try to select keyboard layout …&quot;);  </p>
<p>while(!updated) {</p>
<p>try{  </p>
<p>updateHardKeyboards(); </p>
<p>Thread.sleep(100);</p>
<p>}catch (Exception ex) {</p>
<p>Log.e(&quot;edward&quot;, &quot;Exception: &quot; + ex.getMessage());</p>
<p>}</p>
<p>}  </p>
<p>}</p>
<p>}</p>
<p> if (missingLayoutForExternalKeyboard) {</p>
<p>                if (missingLayoutForExternalKeyboardAdded) {</p>
<p>                    showMissingKeyboardLayoutNotification();</p>
<p>String defaultKeyboard = SystemProperties.get(&quot;ro.bx.keyboard&quot;, &quot;&quot;);</p>
<p>if(defaultKeyboard.startsWith(&quot;keyboard_layout&quot;)){</p>
<p>new SetHardKeyboardThread().start(); </p>
<p>   } </p>
<p>                }</p>
<p>//////// 在 systemUI 不可取 , 必须找到相应的 notification id </p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/stat</p>
<p>index 7f92e75..0f07b49 100755</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java</p>
<p>@@ -113,6 +113,13 @@ import android.widget.Toast;</p>
<p> import android.os.SystemProperties;</p>
<p> import android.content.res.Configuration;</p>
<p>+</p>
<p>+import android.view.InputDevice;</p>
<p>+import android.hardware.input.InputManager;</p>
<p>+import android.hardware.input.KeyboardLayout;</p>
<p>+</p>
<p>+</p>
<p>+</p>
<p> public class PhoneStatusBar extends BaseStatusBar {</p>
<p>     static final String TAG = &quot;PhoneStatusBar&quot;;</p>
<p>     public static final boolean DEBUG = BaseStatusBar.DEBUG;</p>
<p>@@ -136,7 +143,7 @@ public class PhoneStatusBar extends BaseStatusBar {</p>
<p>     private static final int MSG_CLOSE_PANELS = 1001;</p>
<p>     private static final int MSG_OPEN_SETTINGS_PANEL = 1002;</p>
<p>     // 1020-1030 reserved for BaseStatusBar</p>
<p>-</p>
<p>+private InputManager mIm = null;</p>
<p>     // will likely move to a resource or other tunable param at some point</p>
<p>     private static final int INTRUDER_ALERT_DECAY_MS = 0; // disabled, was 10000;</p>
<p>@@ -1162,7 +1169,40 @@ public class PhoneStatusBar extends BaseStatusBar {</p>
<p>             mSettingsButton.setEnabled(isDeviceProvisioned());</p>
<p>         }</p>
<p>     }</p>
<p>-</p>
<ul>
<li><p>private void updateHardKeyboards() {</p>
</li>
<li><p>if (mIm == null)</p>
</li>
<li><p>mIm = (InputManager) mContext.getSystemService(Context.INPUT_SERVICE);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>String defaultKeyboard = SystemProperties.get(&quot;ro.bx.keyboard&quot;, &quot;&quot;);</p>
</li>
<li><p>if(defaultKeyboard.startsWith(&quot;keyboard_layout&quot;)){</p>
</li>
<li><p>if (mContext.getResources().getConfiguration().keyboard == Configuration.KEYBOARD_QWERTY) {</p>
</li>
<li><p>final int[] devices = InputDevice.getDeviceIds();</p>
</li>
<li><p>for (int i = 0; i &lt; devices.length; i++) {</p>
</li>
<li><p>InputDevice device = InputDevice.getDevice(devices[i]);</p>
</li>
<li><p>if (device != null &amp;&amp; !device.isVirtual()</p>
</li>
<li><p>&amp;&amp; device.isFullKeyboard()) {</p>
</li>
<li><p>final String inputDeviceDescriptor = device.getDescriptor();</p>
</li>
<li><p>final String keyboardLayoutDescriptor = mIm</p>
</li>
<li><p>.getCurrentKeyboardLayoutForInputDevice(inputDeviceDescriptor);</p>
</li>
<li><p>final KeyboardLayout keyboardLayout = keyboardLayoutDescriptor != null ? mIm</p>
</li>
<li><p>.getKeyboardLayout(keyboardLayoutDescriptor) : null;</p>
</li>
<li><p>if (keyboardLayout == null) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>String defaultKeyboardLayoutDescriptor = &quot;com.android.inputdevices/com.android.inputdevices.InputDeviceReceiver/&quot;</p>
</li>
<li><ul>
<li>defaultKeyboard;</li>
</ul>
</li>
<li><p>Log.d(&quot;edward&quot;, &quot;systemui defalutKeyboard :=&quot;</p>
</li>
<li><ul>
<li>defaultKeyboardLayoutDescriptor);</li>
</ul>
</li>
<li><p>mIm.addKeyboardLayoutForInputDevice(</p>
</li>
<li><p>inputDeviceDescriptor,</p>
</li>
<li><p>defaultKeyboardLayoutDescriptor);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p>     @Override</p>
<p>     protected void updateNotificationIcons() {</p>
<p>         if (mNotificationIcons == null) return;</p>
<p>@@ -1188,6 +1228,10 @@ public class PhoneStatusBar extends BaseStatusBar {</p>
<p>                     || showNotificationEvenIfUnprovisioned(ent.notification))) continue;</p>
<p>             if (!notificationIsForCurrentUser(ent.notification)) continue;</p>
<p>             toShow.add(ent.icon);</p>
<ul>
<li><p>if(ent.notification.id == 17040471){</p>
</li>
<li><p>Log.d(&quot;edward&quot;,&quot;========= usb keyboard =========??????&quot;);</p>
</li>
<li><p>updateHardKeyboards();</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>         }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>php验证码</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/php%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<p>&lt;?php</p>
<p>/**</p>
<p> * vCode(m,n,x,y) m个数字  显示大小为n   边宽x   边高y</p>
<p> * 自己改写记录session $code</p>
<p> */</p>
<p>session_start(); </p>
<p>vCode(4, 12); //4个数字，显示大小为15</p>
<p>function vCode($num = 4, $size = 20, $width = 0, $height = 0) {</p>
<p>!$width &amp;&amp; $width = $num * $size * 4 / 5 + 5;</p>
<p>!$height &amp;&amp; $height = $size + 10; </p>
<p>// 去掉了 0 1 O l 等</p>
<p>$str = &quot;23456789abcdefghijkmnpqrstuvwxyzABCDEFGHIJKLMNPQRSTUVW&quot;;</p>
<p>$code = ‘’;</p>
<p>for ($i = 0; $i &lt; $num; $i++) {</p>
<p>$code .= $str[mt_rand(0, strlen($str)-1)];</p>
<p>} </p>
<p>// 画图像</p>
<p>$im = imagecreatetruecolor($width, $height); </p>
<p>// 定义要用到的颜色</p>
<p>$back_color = imagecolorallocate($im, 235, 236, 237);</p>
<p>$boer_color = imagecolorallocate($im, 118, 151, 199);</p>
<p>$text_color = imagecolorallocate($im, mt_rand(0, 200), mt_rand(0, 120), mt_rand(0, 120)); </p>
<p>// 画背景</p>
<p>imagefilledrectangle($im, 0, 0, $width, $height, $back_color); </p>
<p>// 画边框</p>
<p>imagerectangle($im, 0, 0, $width-1, $height-1, $boer_color); </p>
<p>// 画干扰线</p>
<p>for($i = 0;$i &lt; 5;$i++) {</p>
<p>$font_color = imagecolorallocate($im, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));</p>
<p>imagearc($im, mt_rand(- $width, $width), mt_rand(- $height, $height), mt_rand(30, $width * 2), mt_rand(20, $height * 2), mt_rand(0, 360), mt_rand(0, 360), $font_color);</p>
<p>} </p>
<p>// 画干扰点</p>
<p>for($i = 0;$i &lt; 50;$i++) {</p>
<p>$font_color = imagecolorallocate($im, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));</p>
<p>imagesetpixel($im, mt_rand(0, $width), mt_rand(0, $height), $font_color);</p>
<p>} </p>
<p>// 画验证码</p>
<p>@imagefttext($im, $size , 0, 5, $size + 3, $text_color, ‘c:\WINDOWS\Fonts\simsun.ttc’, $code);</p>
<p>$_SESSION[&quot;VerifyCode&quot;]=$code; </p>
<p>header(&quot;Cache-Control: max-age=1, s-maxage=1, no-cache, must-revalidate&quot;);</p>
<p>header(&quot;Content-type: image/png;charset=gb2312&quot;);</p>
<p>imagepng($im);</p>
<p>imagedestroy($im);</p>
<p>} </p>
<p>?&gt; </p>
<p>&lt;img src=&quot;valcode.php&quot; onClick=&quot;this.src=’valcode.php’&quot;/&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>recent 状态栏 针对com</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/recent%20%E7%8A%B6%E6%80%81%E6%A0%8F%20%E9%92%88%E5%AF%B9com.mofing%20%E7%82%B9%E5%87%BB%E6%97%A0%E6%95%88/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/st</p>
<p>index 6951389..3490064 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>@@ -868,6 +868,12 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>                     mNotificationPeekKey = null;</p>
<p>                     break;</p>
<p>                 case MSG_OPEN_NOTIFICATION_PANEL:</p>
<p>+</p>
<ul>
<li><p>                                 ActivityManager am = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);</p>
</li>
<li><p>                                 ComponentName cn = am.getRunningTasks(1).get(0).topActivity;</p>
</li>
<li><p>                                 String topapp = cn.getPackageName();</p>
</li>
<li><p>                                 //Log.d(&quot;edward&quot;,topapp);</p>
</li>
<li><p>                                 if(&quot;com.mofing&quot;.equals(topapp)) break;</p>
</li>
</ul>
<p>                     if (DEBUG) Slog.d(TAG, &quot;opening notifications panel&quot;);</p>
<p>                     if (!mNotificationPanel.isShowing()) {</p>
<p>                         mNotificationPanel.show(true, true);</p>
<p>@@ -1439,9 +1445,15 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>         };</p>
<p>     public void onClickRecentButton() {</p>
<p>         if (DEBUG) Slog.d(TAG, &quot;clicked recent apps; disabled=&quot; + mDisabled);</p>
<p>+</p>
<ul>
<li><p>               ActivityManager am = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);</p>
</li>
<li><p>                                 ComponentName cn = am.getRunningTasks(1).get(0).topActivity;</p>
</li>
<li><p>                                 String topapp = cn.getPackageName();</p>
</li>
<li><p>                               //  Log.d(&quot;edward&quot;,topapp);</p>
</li>
<li><p>                                 if(&quot;com.mofing&quot;.equals(topapp)){}else{</p>
</li>
</ul>
<p>         if ((mDisabled &amp; StatusBarManager.DISABLE_EXPAND) == 0) {</p>
<p>             toggleRecentApps();</p>
<ul>
<li>       }</li>
</ul>
<ul>
<li>       }}</li>
</ul>
<p>     }</p>
<p>//在 RecentsActivity.java 中处理会有所不同。所以不必在此处理。</p>
<p>ActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</p>
<p>ComponentName cn = null ;</p>
<p>if(am.getRunningTasks(2).size() == 2){</p>
<p>   cn = am.getRunningTasks(2).get(1).topActivity;}</p>
<p>else if(am.getRunningTasks(2).size() == 1){</p>
<p>cn = am.getRunningTasks(2).get(0).topActivity;</p>
<p>}</p>
<p>String topapp =&quot;&quot;;</p>
<p>if(cn != null){</p>
<p>   topapp = cn.getPackageName();</p>
<p>  Log.d(&quot;edward&quot;,topapp);</p>
<p>  // if(&quot;com.mofing&quot;.equals(topapp)) return ;</p>
<p>  }</p>
<p>if(&quot;com.mofing&quot;.equals(topapp)) {}else{</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>recovery 反转</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/recovery%20%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>device/rockchip/rksdk/BoardConfig.mk</p>
<p>BOARD_HAS_FLIPPED_SCREEN = true </p>
<p>然后执行下面命令,重新生成recovery.img： </p>
<p>    （1）touch bootable/recovery/minui/graphics.c </p>
<p>    （2）make out/target/product/rk312x/recovery.img</p>
<p>    （3）./mkimage.sh </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>recovery 翻转</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/recovery%20%E7%BF%BB%E8%BD%AC/</url>
    <content><![CDATA[<p>BOARD_HAS_FLIPPED_SCREEN := false</p>
<p>touch bootable/recovery/minui/graphics.c</p>
<p> make out/target/product/rk312x/recovery.img</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>redfish VPN</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/redfish%20VPN/</url>
    <content><![CDATA[<p><a href="https://redfishnetworks.org/zh-cn/home">https://redfishnetworks.org/zh-cn/home</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>remove video in Gallery</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/remove%20video%20in%20Gallery/</url>
    <content><![CDATA[<p>diff –git a/AndroidManifest.xml b/AndroidManifest.xml</p>
<p>index 05cbff1..f2fcecd 100644</p>
<p>— a/AndroidManifest.xml</p>
<p>+++ b/AndroidManifest.xml</p>
<p>@@ -46,7 +46,7 @@</p>
<p>                 android:label=&quot;@string/movie_view_label&quot;</p>
<p>                 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</p>
<p>                 &gt;</p>
<ul>
<li>           &lt;intent-filter&gt;</li>
</ul>
<ul>
<li>     &lt;!–      &lt;intent-filter&gt;</li>
</ul>
<p>                 &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</p>
<p>                 &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</p>
<p>                 &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</p>
<p>@@ -69,9 +69,9 @@</p>
<p>                 &lt;data android:mimeType=&quot;video/avi&quot; /&gt;</p>
<p>                 &lt;data android:mimeType=&quot;application/sdp&quot; /&gt;</p>
<p>              &lt;/intent-filter&gt;</p>
<ul>
<li>            &lt;intent-filter&gt;</li>
</ul>
<ul>
<li>            &lt;intent-filter&gt;–&gt;</li>
</ul>
<p>                 !– HTTP live support –&gt;</p>
<ul>
<li>               &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</li>
</ul>
<ul>
<li>            &lt;!–   &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</li>
</ul>
<p>                 &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</p>
<p>                 &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</p>
<p>                 &lt;data android:scheme=&quot;http&quot; /&gt;</p>
<p>@@ -80,7 +80,7 @@</p>
<p>                 &lt;data android:mimeType=&quot;audio/mpegurl&quot; /&gt;</p>
<p>                 &lt;data android:mimeType=&quot;application/vnd.apple.mpegurl&quot; /&gt;</p>
<p>                 &lt;data android:mimeType=&quot;application/x-mpegurl&quot; /&gt;</p>
<ul>
<li>            &lt;/intent-filter&gt;</li>
</ul>
<ul>
<li>            &lt;/intent-filter&gt;–&gt;</li>
</ul>
<p>         &lt;/activity&gt;</p>
<p>         &lt;activity android:name=&quot;com.android.gallery3d.app.Gallery&quot; android:label=&quot;@string/app_name&quot;</p>
<p>diff –git a/src/com/android/gallery3d/app/Gallery.java b/src/com/android/gallery3d/app/Gallery.java</p>
<p>index d2ffbec..3abaf2e 100755</p>
<p>— a/src/com/android/gallery3d/app/Gallery.java</p>
<p>+++ b/src/com/android/gallery3d/app/Gallery.java</p>
<p>@@ -102,7 +102,7 @@ public final class Gallery extends AbstractGalleryActivity implements OnCancelLi</p>
<p>         PicasaSource.showSignInReminder(this);</p>
<p>         Bundle data = new Bundle();</p>
<p>         data.putString(AlbumSetPage.KEY_MEDIA_PATH,</p>
<ul>
<li>               getDataManager().getTopSetPath(DataManager.INCLUDE_ALL));</li>
</ul>
<ul>
<li>               getDataManager().getTopSetPath(DataManager.INCLUDE_IMAGE));</li>
</ul>
<p>         getStateManager().startState(AlbumSetPage.class, data);</p>
<p>         mVersionCheckDialog = PicasaSource.getVersionCheckDialog(this);</p>
<p>         if (mVersionCheckDialog != null) {</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>repo 使用方法</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/repo%20%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Repo是google用Python脚本写的调用git的一个脚本，主要是用来下载、管理Android项目的软件仓库。</p>
<p>下载repo</p>
<p>curl <a href="http://android.git.kernel.org/repo">http://android.git.kernel.org/repo</a> &gt; ~/bin/repo  </p>
<p>chmod a+x ~/bin/repo </p>
<p>$ repo init -u URL [OPTIONS]</p>
<p>-u 指定 manifest库的URL ,</p>
<p>-m 指定 manifest </p>
<p> -b 指定 branch</p>
<p>repo init -u git://android.git.kernel.org/platform/manifest.git -m dalvik-plus.xml   </p>
<p>repo init -u git://android.git.kernel.org/platform/manifest.git -b release-1.0        </p>
<p>$ repo sync [PROJECT_LIST]</p>
<p>repo sync  全部同步并checkout</p>
<p>repo sync project_path  同步某个GIT项目</p>
<p>在某个工程下 可以用repo sync . 进行部分更新。</p>
<p>或 git pull xxx ， git merge xxx 更新到远程分支上。</p>
<p>repo start BRANCH_NAME [PROJECT_LIST]</p>
<p>repo start public –all  所有工程建立public分支</p>
<p>repo start public .    本工程下建立pubic分支</p>
<p>git branch xxx 这样建的分支，repo同步有问题 </p>
<p>repo status [PROJECT_LIST]</p>
<p>In the first column, an uppercase letter indicates how the staging area differs from the last committed state.</p>
<p>lettermeaningdescription</p>
<p>-no changesame in HEAD and index</p>
<p>Aaddednot in HEAD, in index</p>
<p>Mmodifiedin HEAD, modified in index</p>
<p>Ddeletedin HEAD, not in index</p>
<p>Rrenamednot in HEAD, path changed in index</p>
<p>Ccopiednot in HEAD, copied from another in index</p>
<p>Tmode changedsame content in HEAD and index, mode changed</p>
<p>Uunmergedconflict between HEAD and index; resolution required</p>
<p>In the second column, a lowercase letter indicates how the working directory differs from the index.</p>
<p>lettermeaningdescription</p>
<p>-new/unknownnot in index, in work tree</p>
<p>mmodifiedin index, in work tree, modified</p>
<p>ddeletedin index, not in work tree</p>
<p>repo status  查看所有工程的状态</p>
<p>repo diff [PROJECT_LIST]</p>
<p>Shows outstanding changes between commit and working tree using git diff.</p>
<p>repo checkout branch [PROJECT_LIST]</p>
<p>repo checkout public 所有工程切换到public分支</p>
<p>repo forall [PROJECT_LIST] -c COMMAND</p>
<p>Options:</p>
<p>-c: command and arguments to execute. The command is evaluated through /bin/sh and any arguments after it are passed through as shell positional parameters.</p>
<p>-p: show project headers before output of the specified command. This is achieved by binding pipes to the command’s stdin, stdout, and sterr streams, and piping all output into a continuous stream that is displayed in a single pager session.</p>
<p>-v: show messages the command writes to stderr.</p>
<p>repo forall -c command     全部工程执行git 命令</p>
<p>repo  forall -p -c git branch </p>
<p> 保存manifest</p>
<p>repo manifest -r -o xxxx.xml</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>repo 反复执行</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/repo%20%E5%8F%8D%E5%A4%8D%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>#!/bin/bash</p>
<p>#repo init -u <a href="https://android.googlesource.com/platform/manifest">https://android.googlesource.com/platform/manifest</a> -b android-4.0.3_r1</p>
<p>#repo init -u git://github.com/CyanogenMod/android.git -b ics</p>
<p>repo sync -j16</p>
<p>while [ $? = 1 ]; do</p>
<p>echo &quot;–something wrong,re-sync again–&quot;</p>
<p>sleep 3</p>
<p>repo sync -j16</p>
<p>done</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>rk ScreenShot 默认打开</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk%20ScreenShot%20%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80/</url>
    <content><![CDATA[<p>frameworks/base/packages/SettingsProvider/res/values/defaults.xml </p>
<p>     &lt;!– should show the screenshot button default –&gt;</p>
<p>    &lt;bool name=&quot;def_screenshot_button_show&quot;&gt;true&lt;/bool&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>rk2928 声道取反</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk2928%20%E5%A3%B0%E9%81%93%E5%8F%96%E5%8F%8D/</url>
    <content><![CDATA[<p>diff –git a/hardware/rk29/audio/alsa_pcm.c b/hardware/rk29/audio/alsa_pcm.c</p>
<p>index 91029fd..7e8013b 100755</p>
<p>— a/hardware/rk29/audio/alsa_pcm.c</p>
<p>+++ b/hardware/rk29/audio/alsa_pcm.c</p>
<p>@@ -225,7 +225,7 @@ static int oops(struct pcm *pcm, int e, const char *fmt, …)</p>
<p>                  &quot;: %s&quot;, strerror(e));</p>
<p>     return -1;</p>
<p> }</p>
<p>-</p>
<p>+#define LR_TO_RL  1</p>
<p> int pcm_write(struct pcm *pcm, void *data, unsigned count)</p>
<p> {</p>
<p>     struct snd_xferi x;</p>
<p>@@ -236,6 +236,22 @@ int pcm_write(struct pcm *pcm, void *data, unsigned count)</p>
<p>     x.buf = data;</p>
<p>     x.frames = (pcm-&gt;flags &amp; PCM_MONO) ? (count / 2) : (count / 4);</p>
<ul>
<li><p>   #if LR_TO_RL</p>
</li>
<li><p>      if(!(pcm-&gt;flags &amp; PCM_MONO)){</p>
</li>
<li><p>      short *leftCh = (short *)data;</p>
</li>
<li><p>      short *rightCh = leftCh + 1;</p>
</li>
<li><p>      int index = 0;</p>
</li>
<li><p>      for( index = 0; index &lt; x.frames;index++)</p>
</li>
<li><p>      {</p>
</li>
<li><p>      *leftCh =  *leftCh ^ *rightCh;</p>
</li>
<li><p>      *rightCh = *leftCh ^ *rightCh;</p>
</li>
<li><p>      *leftCh = *leftCh ^ *rightCh;</p>
</li>
<li><p>      leftCh++;</p>
</li>
<li><p>      rightCh++;</p>
</li>
<li><p>      }</p>
</li>
<li><p>      }</p>
</li>
<li><p>   #endif</p>
</li>
</ul>
<p>+</p>
<p>     for (;;) {</p>
<p>         if (!pcm-&gt;running) {</p>
<p>             if (ioctl(pcm-&gt;fd, SNDRV_PCM_IOCTL_PREPARE))</p>
<p>(END)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>rk29_keys</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk29_keys.c%20%20%E4%BF%AE%E5%A4%8D%E9%95%BF%E6%8C%89/</url>
    <content><![CDATA[<p>diff –git a/kernel/drivers/input/keyboard/rk29_keys.c b/kernel/drivers/input/keyboard/rk29_keys.c</p>
<p>index 38663ab..62dd523 100755</p>
<p>— a/kernel/drivers/input/keyboard/rk29_keys.c</p>
<p>+++ b/kernel/drivers/input/keyboard/rk29_keys.c</p>
<p>@@ -185,13 +185,13 @@ static void keys_long_press_timer(unsigned long _data)</p>
<p>                state = !!button-&gt;adc_state;</p>
<p>        if(state) {</p>
<p>                if(bdata-&gt;long_press_count != 0) {</p>
<ul>
<li>                      if(bdata-&gt;long_press_count % (LONG_PRESS_COUNT+ONE_SEC_COUNT) == 0){</li>
</ul>
<ul>
<li>      /*              if(bdata-&gt;long_press_count % (LONG_PRESS_COUNT+ONE_SEC_COUNT) == 0){</li>
</ul>
<p>                                key_dbg(bdata, &quot;%skey[%s]: report ev[%d] state[0]\n&quot;,</p>
<p>                                        (button-&gt;gpio == INVALID_GPIO)?&quot;ad&quot;:&quot;io&quot;, button-&gt;desc, button-&gt;code_long_press);</p>
<p>                                input_event(input, type, button-&gt;code_long_press, 0);</p>
<p>                                input_sync(input);</p>
<p>                        }</p>
<ul>
<li>                      else if(bdata-&gt;long_press_count%LONG_PRESS_COUNT == 0) {</li>
</ul>
<ul>
<li>                      else*/ if(bdata-&gt;long_press_count%LONG_PRESS_COUNT == 0) {</li>
</ul>
<p>                                key_dbg(bdata, &quot;%skey[%s]: report ev[%d] state[1]\n&quot;,</p>
<p>                                        (button-&gt;gpio == INVALID_GPIO)?&quot;ad&quot;:&quot;io&quot;, button-&gt;desc, button-&gt;code_long_press);</p>
<p>                                input_event(input, type, button-&gt;code_long_press, 1);</p>
<p>@@ -217,6 +217,7 @@ static void keys_long_press_timer(unsigned long _data)</p>
<p>                        (button-&gt;gpio == INVALID_GPIO)?&quot;ad&quot;:&quot;io&quot;, button-&gt;desc, button-&gt;code_long_press);</p>
<p>                        input_event(input, type, button-&gt;code_long_press, 0);</p>
<p>                        input_sync(input);</p>
<ul>
<li>                      bdata-&gt;long_press_count = 0;</li>
</ul>
<p>                }</p>
<p>        }</p>
<p>        bdata-&gt;state = state;</p>
<p>@@ -410,6 +411,8 @@ static int __devinit keys_probe(struct platform_device *pdev)</p>
<p>                        wakeup = 1;</p>
<p>                input_set_capability(input, type, button-&gt;code);</p>
<ul>
<li><p>              if(button-&gt;code_long_press)</p>
</li>
<li><p>                      input_set_capability(input, EV_KEY, button-&gt;code_long_press);</p>
</li>
</ul>
<p>        }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>rotation = 270 横屏转竖屏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rotation%20=%20270%20%E6%A8%AA%E5%B1%8F%E8%BD%AC%E7%AB%96%E5%B1%8F/</url>
    <content><![CDATA[<p>UI问题</p>
<p>diff –git a/packages/SystemUI/res/layout-sw600dp/navigation_bar.xml b/packages/SystemUI/res/layout-sw600dp/navigation_bar.xml</p>
<p>index 6df5a19..497ca77 100644</p>
<p>— a/packages/SystemUI/res/layout-sw600dp/navigation_bar.xml</p>
<p>+++ b/packages/SystemUI/res/layout-sw600dp/navigation_bar.xml</p>
<p>@@ -25,7 +25,7 @@</p>
<p>     android:background=&quot;@drawable/system_bar_background&quot;</p>
<p>     &gt;</p>
<ul>
<li>   &lt;FrameLayout android:id=&quot;@+id/rot90&quot;</li>
</ul>
<ul>
<li>   &lt;FrameLayout android:id=&quot;@+id/rot0&quot;</li>
</ul>
<p>         android:layout_height=&quot;match_parent&quot;</p>
<p>         android:layout_width=&quot;match_parent&quot;</p>
<p>         &gt;</p>
<p>@@ -205,7 +205,7 @@</p>
<p>             /&gt;</p>
<p>     &lt;/FrameLayout&gt;</p>
<ul>
<li>   &lt;FrameLayout android:id=&quot;@+id/rot0&quot;</li>
</ul>
<ul>
<li>   &lt;FrameLayout android:id=&quot;@+id/rot90&quot;</li>
</ul>
<p>         android:layout_height=&quot;match_parent&quot;</p>
<p>         android:layout_width=&quot;match_parent&quot;</p>
<p>         android:visibility=&quot;gone&quot;</p>
<p>截图问题</p>
<p>diff –git a/packages/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java b/packages/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java</p>
<p>index ecfef00..2283da1 100644</p>
<p>— a/packages/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java</p>
<p>@@ -492,7 +492,8 @@ class GlobalScreenshot {</p>
<p>         mDisplay.getRealMetrics(mDisplayMetrics);</p>
<p>         float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels};</p>
<p>         float degrees = getDegreesForRotation(mDisplay.getRotation());</p>
<ul>
<li>       boolean requiresRotation = (degrees &gt; 0);</li>
</ul>
<ul>
<li><p>              Log.d(&quot;edward&quot;,&quot;degrees:=&quot;+degrees);</p>
</li>
<li><p>       boolean requiresRotation = true;//(degrees &gt; 0);</p>
</li>
</ul>
<p>         if (requiresRotation) {</p>
<p>             // Get the dimensions of the device in its native orientation</p>
<p>             mDisplayMatrix.reset();</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>rt3261 rt3324 调试节点</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rt3261%20rt3324%20%E8%B0%83%E8%AF%95%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>/sys/kernel/debug/asoc/RK_RT3224/rt3261.2-001c/codec_reg</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>rt5621寄存器值的参数对照表</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rt5621%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC%E7%9A%84%E5%8F%82%E6%95%B0%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>sound/soc/codecs/rt5621.c</p>
<p>rt5621_init_reg    </p>
<p>寄存器值的参数对照表</p>
<p>RT5621_ADC_REC_GAIN //增益</p>
<p>F58B=0DB</p>
<p>F78F=6DB</p>
<p>F891=9DB</p>
<p>F993=12DB</p>
<p>FA14=13.5DB</p>
<p>FA95=15DB</p>
<p>FB16=16.5DB</p>
<p>FB97=18DB</p>
<p>FC99=21DB</p>
<p>FD9B=24DB</p>
<p>FE9D=27DB</p>
<p>FF9F=30DB</p>
<p>RT5621_MIC_CTRL </p>
<p>reg22=</p>
<p>0000=0db</p>
<p>0500=20db</p>
<p>0a00=30db</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>rtsp rtmp推流</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rtsp%20rtmp%E6%8E%A8%E6%B5%81/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/eguid_1/article/details/52691707">https://blog.csdn.net/eguid_1/article/details/52691707</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>samba 权限控制</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/samba%20%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p> sudo pdbedit -a hz   //创建用户</p>
<p> sudo pdbedit -L        //查看用户列表</p>
<p>sudo pdbedit -c &quot;[D]&quot; -u hz  //禁止用户</p>
<p>sudo service smbd restart</p>
<p>sudo pdbedit -c &quot;[]&quot; -u hz  //取消禁止</p>
<p>sudo service smbd restart</p>
<p> sudo vi /etc/samba/smb.conf  </p>
<p>[server-share]</p>
<p>comment= Share</p>
<p>path = /opt/share</p>
<p>browseable = yes</p>
<p>writable=yes</p>
<p>public = no</p>
<p>valid users = hz</p>
<p>security = user</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>saving data  保存数据</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/saving%20data%20%20%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>1, Saving Key-Value Sets  – SharedPreferences</p>
<p>inside a Fragment</p>
<p>Context context = getActivity();<br>SharedPreferences sharedPref = context.getSharedPreferences(<br>        getString(R.string.preference_file_key), Context.MODE_PRIVATE);</p>
<p> just one shared preference file</p>
<p>SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</p>
<p>Write to Shared Preferences</p>
<p>SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);<br>SharedPreferences.Editor editor = sharedPref.edit();<br>editor.putInt(getString(R.string.saved_high_score), newHighScore);<br>editor.commit();</p>
<p>Read from Shared Preferences</p>
<p>SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);<br>int defaultValue = getResources().getInteger(R.string.saved_high_score_default);<br>long highScore = sharedPref.getInt(getString(R.string.saved_high_score), defaultValue);</p>
<p>2,Saving Files</p>
<p>Save a File on Internal Storage</p>
<p>File file = new File(context.getFilesDir(), filename);</p>
<p>String filename = &quot;myfile&quot;;<br>String string = &quot;Hello world!&quot;;<br>FileOutputStream outputStream;<br>try {<br>  outputStream = openFileOutput(filename, Context.MODE_PRIVATE);<br>  outputStream.write(string.getBytes());<br>  outputStream.close();<br>} catch (Exception e) {<br>  e.printStackTrace();<br>}</p>
<p> cache some files</p>
<p>public File getTempFile(Context context, String url) {<br>File file;<br>try {<br>String fileName = Uri.parse(url).getLastPathSegment();<br>        file = File.createTempFile(fileName, null, context.getCacheDir());<br>catch (IOException e) {<br>// Error while creating file<br>}<br>return file;<br>}</p>
<p>Save a File on External Storage</p>
<p>&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</p>
<p>&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</p>
<p> verify that the volume is available before accessing it</p>
<p>/* Checks if external storage is available for read and write <em>/<br>public boolean isExternalStorageWritable() {<br>String state = Environment.getExternalStorageState();<br>if (Environment.MEDIA_MOUNTED.equals(state)) {<br>return true;<br>}<br>return false;<br>}<br>/</em> Checks if external storage is available to at least read */<br>public boolean isExternalStorageReadable() {<br>String state = Environment.getExternalStorageState();<br>if (Environment.MEDIA_MOUNTED.equals(state) ||<br>Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {<br>return true;<br>}<br>return false;<br>}</p>
<p> save public files on the external storage</p>
<p>public File getAlbumStorageDir(String albumName) {<br>// Get the directory for the user’s public pictures directory.<br>File file = new File(Environment.getExternalStoragePublicDirectory(<br>Environment.DIRECTORY_PICTURES), albumName);<br>if (!file.mkdirs()) {<br>Log.e(LOG_TAG, &quot;Directory not created&quot;);<br>}<br>return file;<br>}</p>
<p>create a directory for an individual photo album</p>
<p>public File getAlbumStorageDir(Context context, String albumName) {<br>// Get the directory for the app’s private pictures directory.<br>File file = new File(context.getExternalFilesDir(<br>Environment.DIRECTORY_PICTURES), albumName);<br>if (!file.mkdirs()) {<br>Log.e(LOG_TAG, &quot;Directory not created&quot;);<br>}<br>return file;<br>}</p>
<p>Delete a File</p>
<p>myFile.delete();</p>
<p>If the file is saved on internal storage, you can also ask the Context to locate and delete a file by callingdeleteFile():</p>
<p>myContext.deleteFile(fileName);</p>
<p>3,Saving Data in SQL Databases</p>
<p><a href="http://developer.android.com/training/basics/data-storage/databases.html">http://developer.android.com/training/basics/data-storage/databases.html</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>sdtf  card  u 修复</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/sdtf%20%20card%20%20u%20%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p>chkdsk H:/F 　 (H:就是你的SD卡盘符，/F是修复参数。)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>scp 远程拷贝</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/scp%20%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>scp [可选参 数] file_source   file_target </p>
<p>从本地复制到远程</p>
<p>           scp local_file remote_username@remote_ip:remote_folder  </p>
<p>  scp rk312x_kernel201503.tar.bz2 <a href="mailto:&#98;&#x78;&#64;&#49;&#x39;&#x32;&#x2e;&#49;&#x36;&#56;&#46;&#49;&#x2e;&#x38;">&#98;&#x78;&#64;&#49;&#x39;&#x32;&#x2e;&#49;&#x36;&#56;&#46;&#49;&#x2e;&#x38;</a>:/opt/</p>
<p>从 远 程 复制到 本地</p>
<p>         scp  remote_username@remote_ip:remote_file  local_file  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>setcookie</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/setcookie/</url>
    <content><![CDATA[<p>setcookie — Send a cookie</p>
<p>bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] )</p>
<p>setcookie(&quot;TMCookie&quot;,’<a href="http://www.mrbccd.com&/#39;">www.mrbccd.com&#39;</a>);</p>
<p>setcookie(&quot;TMCookie&quot;, ‘<a href="http://www.mrbccd.com&/#39;">www.mrbccd.com&#39;</a>, time()+60);       //设置cookie有效时间为60秒</p>
<p>//设置有效时间为60秒，有效目录为“/tm/”,有效域名为“mrbccd.com”及其所有子域名</p>
<p>setcookie(&quot;TMCookie&quot;, $value, time()+3600, &quot;/mr/&quot;,&quot;. mrbccd.com&quot;, 1); </p>
<p>setcookie() send example</p>
<p>&lt;?php<br>$value = ‘something from somewhere’;<br>setcookie(&quot;TestCookie&quot;, $value);<br>setcookie(&quot;TestCookie&quot;, $value, time()+3600); /* expire in 1 hour */<br>setcookie(&quot;TestCookie&quot;, $value, time()+3600, &quot;/~rasmus/&quot;, &quot;example.com&quot;, 1);<br>?&gt; </p>
<p>setcookie() delete example</p>
<p>&lt;?php<br>// set the expiration date to one hour ago<br>setcookie (&quot;TestCookie&quot;, &quot;&quot;, time() - 3600);<br>setcookie (&quot;TestCookie&quot;, &quot;&quot;, time() - 3600, &quot;/~rasmus/&quot;, &quot;example.com&quot;, 1);<br>?&gt; </p>
<p>setcookie() and arrays</p>
<p>&lt;?php<br>// set the cookies<br>setcookie(&quot;cookie[three]&quot;, &quot;cookiethree&quot;);<br>setcookie(&quot;cookie[two]&quot;, &quot;cookietwo&quot;);<br>setcookie(&quot;cookie[one]&quot;, &quot;cookieone&quot;);<br>// after the page reloads, print them out<br>if (isset($_COOKIE[‘cookie’])) {<br>foreach ($_COOKIE[‘cookie’] as $name =&gt; $value) {<br>$name = htmlspecialchars($name);<br>$value = htmlspecialchars($value);<br>echo &quot;$name : $value &lt;br /&gt;\n&quot;;<br>}<br>}<br>?&gt; </p>
<p>name  </p>
<p>The name of the cookie.</p>
<p>value  </p>
<p>The value of the cookie. This value is stored on the clients computer; do not store sensitive information. Assuming the name is ‘cookiename’, this value is retrieved through $_COOKIE[‘cookiename’]</p>
<p>expire  </p>
<p>The time the cookie expires. This is a Unix timestamp so is in number of seconds since the epoch. In other words, you’ll most likely set this with the time() function plus the number of seconds before you want it to expire. Or you might use mktime(). time()+60<em>60</em>24*30 will set the cookie to expire in 30 days. If set to 0, or omitted, the cookie will expire at the end of the session (when the browser closes).</p>
<p>Note:</p>
<p>You may notice the expire parameter takes on a Unix timestamp, as opposed to the date format Wdy, DD-Mon-YYYY HH:MM:SS GMT, this is because PHP does this conversion internally.</p>
<p>path  </p>
<p>The path on the server in which the cookie will be available on. If set to ‘/‘, the cookie will be available within the entire domain. If set to ‘/foo/‘, the cookie will only be available within the /foo/ directory and all sub-directories such as /foo/bar/ of domain. The default value is the current directory that the cookie is being set in.</p>
<p>domain  </p>
<p>The domain that the cookie is available to. Setting the domain to ‘<a href="http://www.example.com&/#39;">www.example.com&#39;</a> will make the cookie available in the www subdomain and higher subdomains. Cookies available to a lower domain, such as ‘example.com’ will be available to higher subdomains, such as ‘<a href="http://www.example.com&/#39;">www.example.com&#39;</a>. Older browsers still implementing the deprecated » RFC 2109 may require a leading . to match all subdomains.</p>
<p>secure  </p>
<p>Indicates that the cookie should only be transmitted over a secure HTTPS connection from the client. When set to TRUE, the cookie will only be set if a secure connection exists. On the server-side, it’s on the programmer to send this kind of cookie only on secure connection (e.g. with respect to $_SERVER[&quot;HTTPS&quot;]).</p>
<p>httponly  </p>
<p>When TRUE the cookie will be made accessible only through the HTTP protocol. This means that the cookie won’t be accessible by scripting languages, such as JavaScript. It has been suggested that this setting can effectively help to reduce identity theft through XSS attacks (although it is not supported by all browsers), but that claim is often disputed. Added in PHP 5.2.0. TRUE or FALSE</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>setting Development 选项</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/setting%20Development%20%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<p>diff –git a/src/com/android/settings/DeviceInfoSettings.java b/src/com/android/settings/DeviceInfoSettings.java</p>
<p>index 82e4a3f..2763e74 100644</p>
<p>— a/src/com/android/settings/DeviceInfoSettings.java</p>
<p>+++ b/src/com/android/settings/DeviceInfoSettings.java</p>
<p>@@ -163,7 +163,7 @@ public class DeviceInfoSettings extends RestrictedSettingsFragment {</p>
<p>         super.onResume();</p>
<p>         mDevHitCountdown = getActivity().getSharedPreferences(DevelopmentSettings.PREF_FILE,</p>
<p>                 Context.MODE_PRIVATE).getBoolean(DevelopmentSettings.PREF_SHOW,</p>
<ul>
<li>                       android.os.Build.TYPE.equals(&quot;eng&quot;)) ? -1 : TAPS_TO_BE_A_DEVELOPER;</li>
</ul>
<ul>
<li>                       android.os.Build.TYPE.equals(&quot;eng&quot;)) ? TAPS_TO_BE_A_DEVELOPER : TAPS_TO_BE_A_DEVELOPER;</li>
</ul>
<p>         mDevHitToast = null;</p>
<p>     }</p>
<p>diff –git a/src/com/android/settings/Settings.java b/src/com/android/settings/Settings.java</p>
<p>index be0cd88..6c773dc 100755</p>
<p>— a/src/com/android/settings/Settings.java</p>
<p>+++ b/src/com/android/settings/Settings.java</p>
<p>@@ -551,8 +551,8 @@ public class Settings extends PreferenceActivity</p>
<p>         }</p>
<p>     private void updateHeaderList(List&lt;Header&gt; target) {</p>
<p>         final boolean showDev = mDevelopmentPreferences.getBoolean(</p>
<ul>
<li><p>               DevelopmentSettings.PREF_SHOW,</p>
</li>
<li><p>               android.os.Build.TYPE.equals(&quot;eng&quot;));</p>
</li>
</ul>
<ul>
<li><p>               DevelopmentSettings.PREF_SHOW,false);</p>
</li>
<li><p>              // android.os.Build.TYPE.equals(&quot;eng&quot;));</p>
</li>
</ul>
<p>         int i = 0;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>settings  容量显示</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/settings%20%20%E5%AE%B9%E9%87%8F%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>src/com/android/settings/deviceinfo/StorageVolumePreferenceCategory.java</p>
<p>@@ -45,6 +45,7 @@ import com.google.android.collect.Lists;</p>
<p> import java.util.HashMap;</p>
<p> import java.util.Iterator;</p>
<p> import java.util.List;</p>
<p>+import android.util.Log;</p>
<p> public class StorageVolumePreferenceCategory extends PreferenceCategory {</p>
<p>     public static final String KEY_CACHE = &quot;cache&quot;;</p>
<p>@@ -289,7 +290,20 @@ public class StorageVolumePreferenceCategory extends PreferenceCategory {</p>
<p>     }</p>
<p>     public void updateApproximate(long totalSize, long availSize) {</p>
<ul>
<li>mItemTotal.setSummary(formatSize(totalSize));</li>
</ul>
<ul>
<li><p>//mItemTotal.setSummary(formatSize(totalSize));</p>
</li>
<li><p>float tmp = (float)((float)totalSize/(1024<em>1024</em>1024)) ;</p>
</li>
<li><p>//Log.d(&quot;edward&quot;,&quot;size:=&quot;+tmp+&quot;GB&quot;);</p>
</li>
<li><p>if((tmp &gt; 1.3) &amp;&amp; (tmp &lt; 3.5))</p>
</li>
<li><p>mItemTotal.setSummary(&quot;4.00GB&quot;);</p>
</li>
<li><p>else if((tmp &gt; 3.5) &amp;&amp; (tmp &lt; 7.5))</p>
</li>
<li><p>mItemTotal.setSummary(&quot;8.00GB&quot;);</p>
</li>
<li><p>else if((tmp &gt; 7.5) &amp;&amp; (tmp &lt; 15.5))</p>
</li>
<li><p>mItemTotal.setSummary(&quot;16.00GB&quot;);</p>
</li>
<li><p>else if((tmp &gt; 15.5) &amp;&amp; (tmp &lt; 32))</p>
</li>
<li><p>mItemTotal.setSummary(&quot;32.00GB&quot;);</p>
</li>
<li><p>else</p>
</li>
<li><p>mItemTotal.setSummary(formatSize(totalSize));</p>
</li>
</ul>
<p>+</p>
<p>         mItemAvailable.setSummary(formatSize(availSize));</p>
<p>         mTotalSize = totalSize;</p>
<p>@@ -318,7 +332,22 @@ public class StorageVolumePreferenceCategory extends PreferenceCategory {</p>
<p>         if (!showDetails) return;</p>
<p>         // Count caches as available space, since system manages them</p>
<ul>
<li>mItemTotal.setSummary(formatSize(details.totalSize));</li>
</ul>
<ul>
<li>// mItemTotal.setSummary(formatSize(details.totalSize));</li>
</ul>
<p>+</p>
<ul>
<li><p>float tmp = (float)((float)details.totalSize/(1024<em>1024</em>1024)) ;</p>
</li>
<li><p>//Log.d(&quot;edward&quot;,&quot;size:=&quot;+tmp+&quot;GB&quot;);</p>
</li>
<li><p>if((tmp &gt; 1.3) &amp;&amp; (tmp &lt; 3.5))</p>
</li>
<li><p>mItemTotal.setSummary(&quot;4.00GB&quot;);</p>
</li>
<li><p>else if((tmp &gt; 3.5) &amp;&amp; (tmp &lt; 7.5))</p>
</li>
<li><p>mItemTotal.setSummary(&quot;8.00GB&quot;);</p>
</li>
<li><p>else if((tmp &gt; 7.5) &amp;&amp; (tmp &lt; 15.5))</p>
</li>
<li><p>mItemTotal.setSummary(&quot;16.00GB&quot;);</p>
</li>
<li><p>else if((tmp &gt; 15.5) &amp;&amp; (tmp &lt; 32))</p>
</li>
<li><p>mItemTotal.setSummary(&quot;32.00GB&quot;);</p>
</li>
<li><p>else</p>
</li>
<li><p>mItemTotal.setSummary(formatSize(details.totalSize));</p>
</li>
</ul>
<p>+</p>
<p>+</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>settings Storage 屏蔽internal</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/settings%20Storage%20%E5%B1%8F%E8%94%BDinternal/</url>
    <content><![CDATA[<p>diff –git a/src/com/android/settings/deviceinfo/Memory.java b/src/com/android/settings/deviceinfo/Memory.java</p>
<p>index d5a1d71..3769ee6 100644</p>
<p>— a/src/com/android/settings/deviceinfo/Memory.java</p>
<p>+++ b/src/com/android/settings/deviceinfo/Memory.java</p>
<p>@@ -94,7 +94,7 @@ public class Memory extends SettingsPreferenceFragment {</p>
<p>         addPreferencesFromResource(R.xml.device_info_memory);</p>
<ul>
<li>       addCategory(StorageVolumePreferenceCategory.buildForInternal(context));</li>
</ul>
<ul>
<li>       //addCategory(StorageVolumePreferenceCategory.buildForInternal(context));</li>
</ul>
<p>         final StorageVolume[] storageVolumes = mStorageManager.getVolumeList();</p>
<p>改容量</p>
<p>diff –git a/src/com/android/settings/deviceinfo/StorageVolumePreferenceCategory.java b/src/com/android/settings/deviceinfo/StorageVolumePreferenc</p>
<p>index ed5085a..a803824 100644</p>
<p>— a/src/com/android/settings/deviceinfo/StorageVolumePreferenceCategory.java</p>
<p>+++ b/src/com/android/settings/deviceinfo/StorageVolumePreferenceCategory.java</p>
<p>@@ -45,6 +45,7 @@ import com.google.android.collect.Lists;</p>
<p> import java.util.HashMap;</p>
<p> import java.util.Iterator;</p>
<p> import java.util.List;</p>
<p>+import android.util.Log;</p>
<p> public class StorageVolumePreferenceCategory extends PreferenceCategory {</p>
<p>     public static final String KEY_CACHE = &quot;cache&quot;;</p>
<p>@@ -289,7 +290,20 @@ public class StorageVolumePreferenceCategory extends PreferenceCategory {</p>
<p>     }</p>
<p>     public void updateApproximate(long totalSize, long availSize) {</p>
<ul>
<li>       mItemTotal.setSummary(formatSize(totalSize));</li>
</ul>
<ul>
<li><p>       //mItemTotal.setSummary(formatSize(totalSize));</p>
</li>
<li><p>               float tmp = (float)((float)totalSize/(1024<em>1024</em>1024)) ;</p>
</li>
<li><p>         //Log.d(&quot;edward&quot;,&quot;size:=&quot;+tmp+&quot;GB&quot;);</p>
</li>
<li><p>                      if((tmp &gt; 1.3) &amp;&amp; (tmp &lt; 3.5))</p>
</li>
<li><p>              mItemTotal.setSummary(&quot;4.00GB&quot;);</p>
</li>
<li><p>             else if((tmp &gt; 3.5) &amp;&amp; (tmp &lt; 7.5))</p>
</li>
<li><p>                         mItemTotal.setSummary(&quot;8.00GB&quot;);</p>
</li>
<li><p>                        else if((tmp &gt; 7.5) &amp;&amp; (tmp &lt; 15.5))</p>
</li>
<li><p>                         mItemTotal.setSummary(&quot;16.00GB&quot;);</p>
</li>
<li><p>                        else if((tmp &gt; 15.5) &amp;&amp; (tmp &lt; 32))</p>
</li>
<li><p>                         mItemTotal.setSummary(&quot;32.00GB&quot;);</p>
</li>
<li><p>                        else</p>
</li>
<li><p>              mItemTotal.setSummary(formatSize(totalSize));</p>
</li>
</ul>
<p>+</p>
<p>         mItemAvailable.setSummary(formatSize(availSize));</p>
<p>         mTotalSize = totalSize;</p>
<p>@@ -318,7 +332,22 @@ public class StorageVolumePreferenceCategory extends PreferenceCategory {</p>
<p>         if (!showDetails) return;</p>
<p>         // Count caches as available space, since system manages them</p>
<ul>
<li>       mItemTotal.setSummary(formatSize(details.totalSize));</li>
</ul>
<ul>
<li>      // mItemTotal.setSummary(formatSize(details.totalSize));</li>
</ul>
<p>+</p>
<ul>
<li><p>         float tmp = (float)((float)details.totalSize/(1024<em>1024</em>1024)) ;</p>
</li>
<li><p>         //Log.d(&quot;edward&quot;,&quot;size:=&quot;+tmp+&quot;GB&quot;);</p>
</li>
<li><p>                      if((tmp &gt; 1.3) &amp;&amp; (tmp &lt; 3.5))</p>
</li>
<li><p>              mItemTotal.setSummary(&quot;4.00GB&quot;);</p>
</li>
<li><p>             else if((tmp &gt; 3.5) &amp;&amp; (tmp &lt; 7.5))</p>
</li>
<li><p>                         mItemTotal.setSummary(&quot;8.00GB&quot;);</p>
</li>
<li><p>                        else if((tmp &gt; 7.5) &amp;&amp; (tmp &lt; 15.5))</p>
</li>
<li><p>                         mItemTotal.setSummary(&quot;16.00GB&quot;);</p>
</li>
<li><p>                        else if((tmp &gt; 15.5) &amp;&amp; (tmp &lt; 32))</p>
</li>
<li><p>                         mItemTotal.setSummary(&quot;32.00GB&quot;);</p>
</li>
<li><p>                        else</p>
</li>
<li><p>              mItemTotal.setSummary(formatSize(details.totalSize));</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<p>         mItemAvailable.setSummary(formatSize(details.availSize));</p>
<p>         mUsageBarPreference.clear();</p>
<p>(END)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>settings 左边距</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/settings%20%E5%B7%A6%E8%BE%B9%E8%B7%9D/</url>
    <content><![CDATA[<p>\packages\apps\Settings\res\values\styles.xml</p>
<p>    &lt;style name=&quot;PreferenceHeaderListSinglePane&quot; parent=&quot;@*android:style/PreferenceHeaderList&quot;&gt;</p>
<p>        &lt;item name=&quot;android:paddingStart&quot;&gt;5dp&lt;/item&gt;</p>
<p>        &lt;item name=&quot;android:paddingEnd&quot;&gt;5dp&lt;/item&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>setting加3g Dongle supportlist ,GMT+800 改为Philippine Time</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/setting%E5%8A%A03g%20Dongle%20supportlist%20,GMT+800%20%E6%94%B9%E4%B8%BAPhilippine%20Time/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Settings/res/values/strings.xml b/packages/apps/Settings/res/values/strings.xml</p>
<p>index c12d879..1f64cdb 100755</p>
<p>— a/packages/apps/Settings/res/values/strings.xml</p>
<p>+++ b/packages/apps/Settings/res/values/strings.xml</p>
<p>@@ -4223,5 +4223,5 @@</p>
<p>          &lt;string name=&quot;str_about&quot;&gt;Important&lt;/string&gt;</p>
<p>          &lt;string name=&quot;str_mesg&quot;&gt;Whether save Settings?&lt;/string&gt;</p>
<p>          &lt;string name=&quot;save_failed&quot;&gt;Save failed!&lt;/string&gt;</p>
<p>-</p>
<ul>
<li>        &lt;string name=&quot;_3g_dongle_supportlist&quot; translatable=&quot;false&quot;&gt;3G dongle support list&lt;/string&gt;</li>
</ul>
<p> &lt;/resources&gt;</p>
<p>diff –git a/packages/apps/Settings/res/xml-zh/timezones.xml b/packages/apps/Settings/res/xml-zh/timezones.xml</p>
<p>index be269d1..fa75963 100644</p>
<p>— a/packages/apps/Settings/res/xml-zh/timezones.xml</p>
<p>+++ b/packages/apps/Settings/res/xml-zh/timezones.xml</p>
<p>@@ -62,7 +62,7 @@</p>
<p>     &lt;timezone id=&quot;Asia/Rangoon&quot;&gt;缅甸时间 (仰光)&lt;/timezone&gt;</p>
<p>     &lt;timezone id=&quot;Asia/Krasnoyarsk&quot;&gt;克拉斯诺亚尔斯克&lt;/timezone&gt;</p>
<p>     &lt;timezone id=&quot;Asia/Bangkok&quot;&gt;曼谷&lt;/timezone&gt;</p>
<ul>
<li>   &lt;timezone id=&quot;Asia/Shanghai&quot;&gt;中国标准时间 (北京)&lt;/timezone&gt;</li>
</ul>
<ul>
<li>   &lt;timezone id=&quot;Asia/Shanghai&quot;&gt;菲律宾标准时间 (马尼拉)&lt;/timezone&gt;</li>
</ul>
<p>     &lt;timezone id=&quot;Asia/Hong_Kong&quot;&gt;香港时间 (香港)&lt;/timezone&gt;</p>
<p>     &lt;timezone id=&quot;Asia/Irkutsk&quot;&gt;伊尔库茨克时间 (伊尔库茨克)&lt;/timezone&gt;</p>
<p>     &lt;timezone id=&quot;Asia/Kuala_Lumpur&quot;&gt;吉隆坡&lt;/timezone&gt;</p>
<p>diff –git a/packages/apps/Settings/res/xml/timezones.xml b/packages/apps/Settings/res/xml/timezones.xml</p>
<p>index f9a36f3..0848c8b 100644</p>
<p>— a/packages/apps/Settings/res/xml/timezones.xml</p>
<p>+++ b/packages/apps/Settings/res/xml/timezones.xml</p>
<p>@@ -63,7 +63,7 @@</p>
<p>     &lt;timezone id=&quot;Asia/Rangoon&quot;&gt;Yangon&lt;/timezone&gt;</p>
<p>     &lt;timezone id=&quot;Asia/Krasnoyarsk&quot;&gt;Krasnoyarsk&lt;/timezone&gt;</p>
<p>     &lt;timezone id=&quot;Asia/Bangkok&quot;&gt;Bangkok&lt;/timezone&gt;</p>
<ul>
<li>   &lt;timezone id=&quot;Asia/Shanghai&quot;&gt;Beijing&lt;/timezone&gt;</li>
</ul>
<ul>
<li>   &lt;timezone id=&quot;Asia/Shanghai&quot;&gt;Philippine&lt;/timezone&gt;</li>
</ul>
<p>     &lt;timezone id=&quot;Asia/Hong_Kong&quot;&gt;Hong Kong&lt;/timezone&gt;</p>
<p>     &lt;timezone id=&quot;Asia/Irkutsk&quot;&gt;Irkutsk&lt;/timezone&gt;</p>
<p>     &lt;timezone id=&quot;Asia/Kuala_Lumpur&quot;&gt;Kuala Lumpur&lt;/timezone&gt;</p>
<p>diff –git a/packages/apps/Settings/res/xml/wireless_settings.xml b/packages/apps/Settings/res/xml/wireless_settings.xml</p>
<p>index e73dbad..da2f70b 100755</p>
<p>— a/packages/apps/Settings/res/xml/wireless_settings.xml</p>
<p>+++ b/packages/apps/Settings/res/xml/wireless_settings.xml</p>
<p>@@ -89,4 +89,13 @@</p>
<p>             android:targetClass=&quot;com.android.cellbroadcastreceiver.CellBroadcastSettings&quot; /&gt;</p>
<p>     &lt;/PreferenceScreen&gt;</p>
<ul>
<li><p>   &lt;PreferenceScreen</p>
</li>
<li><p>       android:key=&quot;_3g_dongle_supportlists&quot;</p>
</li>
<li><p>       android:title=&quot;@string/_3g_dongle_supportlist&quot;&gt;</p>
</li>
<li><p>       &lt;intent</p>
</li>
<li><p>           android:action=&quot;android.intent.action.MAIN&quot;</p>
</li>
<li><p>           android:targetPackage=&quot;com.example.mywork&quot;</p>
</li>
<li><p>           android:targetClass=&quot;com.example.mywork.MainActivity&quot; /&gt;</p>
</li>
<li><p>   &lt;/PreferenceScreen&gt;</p>
</li>
</ul>
<p>+</p>
<p> &lt;/PreferenceScreen&gt;</p>
<p>diff –git a/packages/apps/Settings/src/com/android/settings/DateTimeSettings.java b/packages/apps/Settings/src/com/android/settings/DateTimeSettings.java</p>
<p>index 1d8e341..a449e51 100644</p>
<p>— a/packages/apps/Settings/src/com/android/settings/DateTimeSettings.java</p>
<p>+++ b/packages/apps/Settings/src/com/android/settings/DateTimeSettings.java</p>
<p>@@ -367,10 +367,17 @@ public class DateTimeSettings extends SettingsPreferenceFragment</p>
<p>         boolean daylight = tz.inDaylightTime(new Date());</p>
<p>         StringBuilder sb = new StringBuilder();</p>
<ul>
<li>       sb.append(formatOffset(tz.getRawOffset() +</li>
</ul>
<ul>
<li><p>              String str1 = String.valueOf(formatOffset(tz.getRawOffset() + (daylight ? tz.getDSTSavings() : 0)));</p>
</li>
<li><p>              String str2 = tz.getDisplayName(daylight, TimeZone.LONG) ;</p>
</li>
<li><p>       if(str1.equals(&quot;GMT+08:00&quot;))</p>
</li>
<li><p>                      str2 = &quot;Philippine Time&quot;;</p>
</li>
</ul>
<p>+</p>
<ul>
<li>              sb.append(str1).append(&quot;,&quot;).append(str2);</li>
</ul>
<p>+</p>
<ul>
<li>              /*sb.append(formatOffset(tz.getRawOffset() +</li>
</ul>
<p>                                (daylight ? tz.getDSTSavings() : 0))).</p>
<p>             append(&quot;, &quot;).</p>
<ul>
<li>           append(tz.getDisplayName(daylight, TimeZone.LONG));</li>
</ul>
<ul>
<li>           append(tz.getDisplayName(daylight, TimeZone.LONG));*/</li>
</ul>
<p>         return sb.toString();</p>
<p>     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>shc</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/shc/</url>
    <content><![CDATA[<p><a href="http://pkgs.repoforge.org/shc/">http://pkgs.repoforge.org/shc/</a> </p>
<p><a href="http://www.net527.com/caozuoxitong/Linux/5979.html">http://www.net527.com/caozuoxitong/Linux/5979.html</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>sizeof不是函数，而是关键字</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/sizeof%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%8C%E8%80%8C%E6%98%AF%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>       sizeof 在计算变量所占空间大小时，括号可以省略，计算类型(模子)大小时不能省略</p>
<p>备注：所谓的模子就是数据类型，例如int，char，float等</p>
<p>例如：int a;</p>
<p>             sizeof（int）;  //值为4</p>
<p>             sizeof a;          //值为4</p>
<p>             sizeof(a);         //值为4</p>
<p>             sizeof int;        //错误，sizeof是关键字，int也是关键字</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>skype帐号</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/skype%E5%B8%90%E5%8F%B7/</url>
    <content><![CDATA[<p>edward12345695 </p>
<p><strong>**</strong>0908</p>
<p>edward76201</p>
<p>****520</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>slogctl 9820e</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/slogctl%209820e/</url>
    <content><![CDATA[<p>Usage: slogctl &lt;operation&gt; [arguments]</p>
<p>Operation:</p>
<p>        enable             update config file and enable slog</p>
<p>        disable            update config file and disable slog</p>
<p>        low_power          update config file and make slog in low_power state</p>
<p>        android [on/off]   update config file and enable/disable android log</p>
<p>        modem [on/off]     update config file and enable/disable modem log</p>
<p>        tcp [on/off]       update config file and enable/disable cap log</p>
<p>        bt  [on/off]       update config file and enable/disable bluetooth log</p>
<p>        reload             reboot slog and parse config file.</p>
<p>        snap [arg]         catch certain snapshot log, catch all snapshot without any arg</p>
<p>        exec &lt;arg&gt;         through the slogctl to run a command.</p>
<p>        on                 start slog.</p>
<p>        off                pause slog.</p>
<p>        clear              delete all log.</p>
<p>        dump [file]        dump all log to a tar file.</p>
<p>        screen [file]      screen shot, if no file given, will be put into misc dir</p>
<p>        sync               sync current android log to file.</p>
<p>        hook_modem         dump current modem log to /data/log</p>
<p>        query              print the current slog configuration.</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ssh key</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ssh%20key/</url>
    <content><![CDATA[<p>Generating SSH Keys</p>
<p><a href="https://help.github.com/articles/generating-ssh-keys#platform-linux">https://help.github.com/articles/generating-ssh-keys#platform-linux</a></p>
<ol>
<li>生成 ~/.ssh/id_rsa   id_rsa.pub</li>
</ol>
<p>ssh-keygen -t rsa -C &quot;<a href="mailto:&#x79;&#111;&#x75;&#114;&#95;&#x65;&#109;&#x61;&#x69;&#x6c;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#x79;&#111;&#x75;&#114;&#95;&#x65;&#109;&#x61;&#x69;&#x6c;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a>&quot;</p>
<ol start="2">
<li>添加 id_rsa</li>
</ol>
<p>ssh-add ~/.ssh/id_rsa</p>
<p>如果ssh-keygen没起来</p>
<p>ssh-keygen -lf ~/.ssh/id_rsa.pub</p>
<p>ssh-agent bash –login -i</p>
<p>或直接用</p>
<p>keychain –eval ~/.ssh/id_rsa_github</p>
<p>查看已添加的key</p>
<p>ssh-add -l </p>
<p>3.添加public key  </p>
<p>将 id_rsa.pub 加到github 上</p>
<p>Then add your new key to the ssh-agent:</p>
<h1 id="start-the-ssh-agent-in-the-backgroundeval-quot-ssh-agent-s-quot-Agent-pid-59566ssh-add-ssh-id-rsa"><a href="#start-the-ssh-agent-in-the-backgroundeval-quot-ssh-agent-s-quot-Agent-pid-59566ssh-add-ssh-id-rsa" class="headerlink" title="start the ssh-agent in the backgroundeval &quot;$(ssh-agent -s)&quot;# Agent pid 59566ssh-add ~/.ssh/id_rsa"></a>start the ssh-agent in the backgroundeval &quot;$(ssh-agent -s)&quot;# Agent pid 59566ssh-add ~/.ssh/id_rsa</h1><ol start="4">
<li>测试 </li>
</ol>
<p>ssh -T <a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;">&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;</a></p>
<p>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>Adding or changing a passphrase</p>
<p>ssh-keygen -p</p>
<p>Then add your new key to the ssh-agent:</p>
<h1 id="start-the-ssh-agent-in-the-backgroundeval-quot-ssh-agent-s-quot-Agent-pid-59566ssh-add-ssh-id-rsa-1"><a href="#start-the-ssh-agent-in-the-backgroundeval-quot-ssh-agent-s-quot-Agent-pid-59566ssh-add-ssh-id-rsa-1" class="headerlink" title="start the ssh-agent in the backgroundeval &quot;$(ssh-agent -s)&quot;# Agent pid 59566ssh-add ~/.ssh/id_rsa"></a>start the ssh-agent in the backgroundeval &quot;$(ssh-agent -s)&quot;# Agent pid 59566ssh-add ~/.ssh/id_rsa</h1>]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>sudo apt-getinstall git-core g</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/sudo%20apt-getinstall%20git-core%20g/</url>
    <content><![CDATA[<p>sudo apt-getinstall git-core gnupg flex bison gperf build-essential</p>
<p>sudo apt-getinstall zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev</p>
<p>sudo apt-getinstall libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dri:i386</p>
<p>sudo apt-getinstall libgl1-mesa-dev g++-multilib mingw32 tofrodos</p>
<p>sudo apt-getinstall python-markdown libxml2-utils xsltproc zlib1g-dev:i386</p>
<p>sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1/usr/lib/i386-linux-gnu/libGL.so</p>
<p>如果linux系统装的ubuntu16.04的系统，编译9820E（Android4.4）需要对make进行降级</p>
<p>tar  -zxvf make-3.81.tar.gz  #解压</p>
<p>cd make-3.82  #进入make目录</p>
<p>./configure</p>
<p>make</p>
<p>sudo make install</p>
<p>#重新进入终端</p>
<p>make -v #查看make版本，看到GNU Make3.82说明降级安装成功</p>
<p>make-3.81 </p>
<p>修改  /glob/glob.c <br>//      #if  !defined  __alloca  &amp;&amp;  !defined  __GNU_LIBRARY__<br>#  ifdef        <strong>GNUC</strong><br>#    undef  alloca<br>#    define  alloca(n)        __builtin_alloca  (n)<br>#  else        /*  Not  GCC.    <em>/<br>#    ifdef  HAVE_ALLOCA_H<br>#      include  &lt;alloca.h&gt;<br>#    else        /</em>  Not  HAVE_ALLOCA_H.    */<br>#      ifndef  _AIX<br>#        ifdef  WINDOWS32<br>#          include  &lt;malloc.h&gt;<br>#        else<br>extern  char  <em>alloca  ();<br>#        endif  /</em>  WINDOWS32  <em>/<br>#      endif  /</em>  Not  _AIX.    <em>/<br>#    endif  /</em>  sparc  or  HAVE_ALLOCA_H.    <em>/<br>#  endif        /</em>  GCC.    */<br>#  define  __alloca        alloca<br>//      #endif</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ssh  id_rsa</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ssh%20%20id_rsa/</url>
    <content><![CDATA[<p>2.添加公密到信任列表</p>
<p>~/.ssh$ cat 192.168.1.101 &gt;&gt; authorized_keys</p>
<p>~/.ssh$</p>
<p>3.启动ssh-agent (以前没有做过的步骤)</p>
<p>如果ssh localhost返回这样的提示</p>
<p>Agent admitted failure to sign using the key</p>
<p>ps -aux|grep agent查看有无ssh-agent有无运行，若没有</p>
<p>~/.ssh$ ssh-agent</p>
<p>4.添加id_rsa到ssh-agent</p>
<p>~/.ssh$ ssh-add id_rsa<br>如果提示：<br>“Could not open a connection to your authentication agent”<br>执行：ssh-agent bash<br>5.修改目录权限</p>
<p>sudo chmod 600 ~/.ssh/id_rsa sudo chmod 600 ~/.ssh/id_rsa.pub<br>sudo chmod 644 ~/.ssh/known_hosts<br>sudo chmod 755 ~/.ssh</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>statusbar背景 音量 截图</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/statusbar%E8%83%8C%E6%99%AF%20%E9%9F%B3%E9%87%8F%20%E6%88%AA%E5%9B%BE/</url>
    <content><![CDATA[<p>frameworks\base\packages\SystemUI\res\values\colors.xml</p>
<p>&lt;drawable name=&quot;status_bar_background&quot;&gt;#ff101010&lt;/drawable&gt;</p>
<p>  &lt;!– ==================== system bar only ==================== –&gt;</p>
<p>    &lt;drawable name=&quot;system_bar_background&quot;&gt;#ff101010&lt;/drawable&gt;</p>
<p>private String isEnableShowVoiceIcon = SystemProperties.get(&quot;ro.rk.systembar.voiceicon&quot;); //配置是否显示音量加减图标</p>
<p>private void setNavigationVisibility(int visibility) {  //锁屏时改变</p>
<p>        boolean disableHome = ((visibility &amp; StatusBarManager.DISABLE_HOME) != 0);</p>
<p>        boolean disableRecent = ((visibility &amp; StatusBarManager.DISABLE_RECENT) != 0);</p>
<p>        boolean disableBack = ((visibility &amp; StatusBarManager.DISABLE_BACK) != 0);</p>
<p>        mBackButton.setVisibility(disableBack ? View.INVISIBLE : View.VISIBLE);</p>
<p>        mHomeButton.setVisibility(disableHome ? View.INVISIBLE : View.VISIBLE);</p>
<p>        mRecentButton.setVisibility(disableRecent ? View.INVISIBLE : View.VISIBLE);</p>
<p>if((&quot;true&quot;.equals(isEnableShowVoiceIcon)) &amp;&amp; (mContext.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE)){</p>
<p>mVolumeUpButton.setVisibility(disableRecent ? View.INVISIBLE : View.VISIBLE);</p>
<p>mVolumeDownButton.setVisibility(disableRecent ? View.INVISIBLE : View.VISIBLE);</p>
<p>}</p>
<p>if(Settings.System.getInt(mContext.getContentResolver(),  // 使截屏随着隐藏或显示</p>
<p>                        Settings.System.SCREENSHOT_BUTTON_SHOW, 0)==1){</p>
<p>             mScreenshot.setVisibility(disableRecent ? View.INVISIBLE : View.VISIBLE);</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>sudo crontab -e 定时任务</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/sudo%20crontab%20-e%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>sudo crontab -e</p>
<p>  0 12 *   *   5    7z a /opt/data/zsvn_backups.7z /opt/svn -r -mx9</p>
<p>  0 18 *   *   *     /sbin/shutdown -h now</p>
<p> m h  dom mon dow   command</p>
<p>  0 12 *   *   5    7z a /opt/disk2/data_backups.7z /opt/disk2/git -r -mx9</p>
<p>  0 22 *   *   *     /sbin/shutdown -h now</p>
<p>  0 20 28  *   *    cp -rf /opt/disk2/data_backups.7z /opt/disk4/</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>supervisor</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/supervisor/</url>
    <content><![CDATA[<p>supervisor</p>
<p>sudo apt-get install supervisor</p>
<p>supervisorctl status　服务名</p>
<p>supervisorctl stop 服务名</p>
<p>supervisorctl restart 服务名</p>
<p>supervisorctl reload</p>
<p>supervisorctl update</p>
<p>/etc/supervisord.conf</p>
<p>修改 /etc/supervisord.conf <br>在其中添加:<br>[include]<br>files = /etc/supervisor/conf.d/*.conf</p>
<p>vim /etc/supervisor/conf.d/xx.conf</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>svn 基本命令</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/svn%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>SVN 基本命令</p>
<p>Available subcommands:</p>
<p>   add</p>
<p>   blame (praise, annotate, ann)</p>
<p>   cat</p>
<p>   changelist (cl)</p>
<p>   checkout (co)</p>
<p>   cleanup</p>
<p>   commit (ci)</p>
<p>   copy (cp)</p>
<p>   delete (del, remove, rm)</p>
<p>   diff (di)</p>
<p>   export</p>
<p>   help (?, h)</p>
<p>   import</p>
<p>   info</p>
<p>   list (ls)</p>
<p>   lock</p>
<p>   log</p>
<p>   merge</p>
<p>   mergeinfo</p>
<p>   mkdir</p>
<p>   move (mv, rename, ren)</p>
<p>   propdel (pdel, pd)</p>
<p>   propedit (pedit, pe)</p>
<p>   propget (pget, pg)</p>
<p>   proplist (plist, pl)</p>
<p>   propset (pset, ps)</p>
<p>   resolve</p>
<p>   resolved</p>
<p>   revert</p>
<p>   status (stat, st)</p>
<p>   switch (sw)</p>
<p>   unlock</p>
<p>   update (up)</p>
<p>Subversion is a tool for version control.</p>
<p>For additional information, see <a href="http://subversion.tigris.org/">http://subversion.tigris.org/</a></p>
<p>1、将文件checkout到本地目录</p>
<p>svn checkout path</p>
<p>svn checkout svn://192.168.1.1/pro/domain</p>
<p>svn checkout <a href="http://android-serialport-api.googlecode.com/svn/trunk/">http://android-serialport-api.googlecode.com/svn/trunk/</a> android-serialport-api-read-only</p>
<p>简写：svn co</p>
<p>2、往版本库中添加新的文件<br>svn add file<br>3、将改动的文件提交到版本库<br>svn commit -m “LogMessage” [-N] [–no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关)<br>简写：svn ci<br>4、加锁/解锁<br>svn lock -m “LockMessage” [–force] PATH<br>svn unlock PATH<br>5、更新到某个版本<br>svn update -r m path<br>简写：svn up<br>6、查看文件或者目录状态<br>1）svn status path（目录下的文件和子目录的状态，正常状态不显示）<br>2）svn status -v path(显示文件和子目录状态)<br>简写：svn st<br>7、删除文件<br>svn delete path -m “delete test fle”<br>简写：svn (del, remove, rm)<br>8、查看日志<br>svn log path<br>9、查看文件详细信息<br>svn info path<br>10、比较差异<br>svn diff path(将修改的文件与基础版本比较)<br>svn diff -r m:n path(对版本m和版本n比较差异)<br>简写：svn di<br>11、将两个版本之间的差异合并到当前文件<br>svn merge -r m:n path<br>12、SVN 帮助<br>svn help<br>svn help ci </p>
<p>二、 SVN不常用命令<br>13、版本库下的文件和目录列表<br>  svn list path    显示path目录下的所有属于版本库的文件和目录简写：svn ls<br>14、创建纳入版本控制下的新目录<br>svn mkdir: 创建纳入版本控制下的新目录。<br>用法: <br>1、mkdir PATH…<br>每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。<br>2、mkdir URL… 创建版本控制的目录。 <br>每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。<br>15、恢复本地修改<br>svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。<br>用法: revert PATH… 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录<br>16、代码库URL变更<br>svn switch (sw): 更新工作副本至不同的URL。<br>用法: <br>1、switch URL [PATH]        <br>更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将      服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。 <br>2、switch –relocate FROM TO [PATH…]   <br>改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动     (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用     这个命令更新工作副本与仓库的对应关系。<br>17、解决冲突<br>svn resolved: 移除工作副本的目录或文件的“冲突”状态。<br>用法: resolved PATH… 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的相关文件，然后让 PATH 可以再次提交。<br>18、输出指定文件或URL的内容。<br>svn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。 svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的）</p>
<p>三、 SVN其它命令</p>
<p>虽然不像本章先前讨论过的那些命令那么常用，但是有时你也需要这些命令。 <br>svn cleanup<br>当Subversion修改你的工作副本时（或者任何在.svn中的信息），它尝试尽可能做到安全。在改变一个工作副本前，Subversion把它的意 图写到一个日志文件中。接下来它执行日志文件中的命令来应用要求的修改。最后，Subversion删除日志文件。从架构上来说，这与一个日志文件系统 （journaled filesystem）类似。如果一个 Subversion操作被打断（例如，进程被杀掉了，或机器当掉了）了，日志文件仍在硬盘上。重新执行日志文件，Subversion可以完成先前开始 的操作，这样你的工作副本能回到一个可靠的状态。 <br>以下是svn cleanup所做的：它搜索你的工作副本并执行所有遗留的日志，在这过程中删除锁。如果Subversion曾告诉你你的工作副本的一部分被“锁定”了，那么你应该执行这个命令。另外， svn status会在锁定的项前显示L。 <br>$ svn status<br>L    somedir<br>M   somedir/foo.c <br>$ svn cleanup<br>$ svn status<br>M      somedir/foo.c<br>svn import<br>使用svn import是把未版本化的文件树复制到资料库的快速办法，它需要创建一个临时目录。 <br>$ svnadmin create /usr/local/svn/newrepos<br>$ svn import mytree file:///usr/local/svn/newrepos/some/project<br>Adding         mytree/foo.c<br>Adding         mytree/bar.c<br>Adding         mytree/subdir<br>Adding         mytree/subdir/quux.h<br>Committed revision 1.<br>上面的例子把在some/project目录下mytree目录的内容复制到资料库中。 <br>$ svn list file:///usr/local/svn/newrepos/some/project<br>bar.c<br>foo.c<br>subdir/  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>systemUI 音量控制条</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/systemUI%20%E9%9F%B3%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9D%A1/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/packages/SystemUI/res/drawable-mdpi/ic_sysbar_volume.png b/frameworks/base/packages/SystemUI/res/drawable-mdpi/ic_sysbar_volume.png</p>
<p>new file mode 100644</p>
<p>index 0000000..f647fea</p>
<p>Binary files /dev/null and b/frameworks/base/packages/SystemUI/res/drawable-mdpi/ic_sysbar_volume.png differ</p>
<p>diff –git a/frameworks/base/packages/SystemUI/res/values-sw600dp/styles.xml b/frameworks/base/packages/SystemUI/res/values-sw600dp/styles.xml</p>
<p>index b7becac..0961360 100644</p>
<p>— a/frameworks/base/packages/SystemUI/res/values-sw600dp/styles.xml</p>
<p>+++ b/frameworks/base/packages/SystemUI/res/values-sw600dp/styles.xml</p>
<p>@@ -18,4 +18,26 @@</p>
<p>     &lt;style name=&quot;BrightnessDialogContainer&quot; parent=&quot;@style/BaseBrightnessDialogContainer&quot;&gt;</p>
<p>         &lt;item name=&quot;android:layout_width&quot;&gt;480dp&lt;/item&gt;</p>
<p>     &lt;/style&gt;</p>
<p>+</p>
<ul>
<li><p>&lt;style name=&quot;StatusBarPanelSettingsRow&quot;&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:paddingRight&quot;&gt;16dp&lt;/item&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:layout_height&quot;&gt;56dp&lt;/item&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:layout_width&quot;&gt;match_parent&lt;/item&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:orientation&quot;&gt;horizontal&lt;/item&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:background&quot;&gt;?android:attr/listChoiceBackgroundIndicator&lt;/item&gt;</p>
</li>
<li><p>&lt;/style&gt;</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>&lt;style name=&quot;StatusBarPanelSettingsIcon&quot;&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:layout_height&quot;&gt;match_parent&lt;/item&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:layout_width&quot;&gt;64dp&lt;/item&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:scaleType&quot;&gt;center&lt;/item&gt;</p>
</li>
<li><p>&lt;/style&gt;</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<p>+&lt;style name=&quot;StatusBarPanelSettingsPanelSeparator&quot;&gt;</p>
<ul>
<li><p>&lt;item name=&quot;android:layout_marginRight&quot;&gt;0dp&lt;/item&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:layout_width&quot;&gt;match_parent&lt;/item&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:layout_height&quot;&gt;1dp&lt;/item&gt;</p>
</li>
<li><p>&lt;item name=&quot;android:background&quot;&gt;@android:drawable/divider_horizontal_dark&lt;/item&gt;</p>
</li>
<li><p>&lt;/style&gt;</p>
</li>
</ul>
<p> &lt;/resources&gt;</p>
<p>diff –git a/frameworks/base/packages/SystemUI/res/values/strings.xml b/frameworks/base/packages/SystemUI/res/values/strings.xml</p>
<p>index e12c899..1b26092 100644</p>
<p>— a/frameworks/base/packages/SystemUI/res/values/strings.xml</p>
<p>+++ b/frameworks/base/packages/SystemUI/res/values/strings.xml</p>
<p>@@ -521,4 +521,5 @@</p>
<p>     &lt;string name=&quot;sdcard_unmount&quot;&gt;internal storage is unmount&lt;/string&gt;</p>
<p>     &lt;string name=&quot;external_sd_unmount&quot;&gt;sd card is unmount&lt;/string&gt;</p>
<p>     &lt;string name=&quot;usb_storage_unmount&quot;&gt;usb storage is unmount&lt;/string&gt;</p>
<ul>
<li>&lt;string name=&quot;status_bar_settings_mute_volume_label&quot;&gt;Mute&lt;/string&gt;</li>
</ul>
<p> &lt;/resources&gt;</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/ToggleSlider.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/statu</p>
<p>index 8cbaa8a..8b2437b 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/ToggleSlider.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/ToggleSlider.java</p>
<p>@@ -59,8 +59,8 @@ public class ToggleSlider extends RelativeLayout</p>
<p>         super(context, attrs, defStyle);</p>
<p>         View.inflate(context, R.layout.status_bar_toggle_slider, this);</p>
<p>       //add</p>
<ul>
<li><p>mAutoAvailable = context.getResources().getBoolean(</p>
</li>
<li><p>com.android.internal.R.bool.config_automatic_brightness_available);</p>
</li>
</ul>
<ul>
<li><p>mAutoAvailable = true ;//context.getResources().getBoolean(</p>
</li>
<li><p>//com.android.internal.R.bool.config_automatic_brightness_available);</p>
</li>
</ul>
<p>         final Resources res = context.getResources();</p>
<p>         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ToggleSlider,</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/VolumeController.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/s</p>
<p>index 6fee432..5ae4e93 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/VolumeController.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/VolumeController.java</p>
<p>@@ -29,7 +29,10 @@ import android.widget.CompoundButton;</p>
<p> public class VolumeController implements ToggleSlider.Listener {</p>
<p>     private static final String TAG = &quot;StatusBar.VolumeController&quot;;</p>
<ul>
<li>private static final int STREAM = AudioManager.STREAM_NOTIFICATION;</li>
</ul>
<p>+</p>
<ul>
<li><p>//mod by cjf</p>
</li>
<li><p>//private static final int STREAM = AudioManager.STREAM_NOTIFICATION;</p>
</li>
<li><p>public static final int STREAM = AudioManager.STREAM_MUSIC;</p>
</li>
</ul>
<p>     private Context mContext;</p>
<p>     private ToggleSlider mControl;</p>
<p>@@ -51,15 +54,15 @@ public class VolumeController implements ToggleSlider.Listener {</p>
<p>         mMute = mAudioManager.getRingerMode() != AudioManager.RINGER_MODE_NORMAL;</p>
<p>         mVolume = mAudioManager.getStreamVolume(STREAM);</p>
<p>-</p>
<ul>
<li><p>control.setMax(mAudioManager.getStreamMaxVolume(STREAM));</p>
</li>
<li><p>control.setValue(mVolume);</p>
</li>
<li><p>control.setChecked(mMute);</p>
</li>
</ul>
<p>         control.setOnChangedListener(this);</p>
<p>     }</p>
<p>     @Override</p>
<p>     public void onInit(ToggleSlider control) {</p>
<ul>
<li><p>control.setMax(mAudioManager.getStreamMaxVolume(STREAM));</p>
</li>
<li><p>control.setValue(mVolume);</p>
</li>
<li><p>control.setChecked(mMute);</p>
</li>
</ul>
<p>+</p>
<p>     }</p>
<p>     public void onChanged(ToggleSlider view, boolean tracking, boolean mute, int level) {</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/SettingsView.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/statu</p>
<p>index f71842e..5826211 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/SettingsView.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/SettingsView.java</p>
<p>@@ -37,16 +37,45 @@ import com.android.systemui.statusbar.policy.DoNotDisturbController;</p>
<p> import com.android.systemui.statusbar.policy.ToggleSlider;</p>
<p> import com.android.systemui.statusbar.policy.VolumeController;</p>
<p>+import android.provider.Settings;</p>
<p>+import android.provider.Settings.System;</p>
<p>+import android.database.ContentObserver;</p>
<p>+import android.os.Handler;</p>
<p>+</p>
<p>+</p>
<p> public class SettingsView extends LinearLayout implements View.OnClickListener {</p>
<p>     static final String TAG = &quot;SettingsView&quot;;</p>
<p>     AirplaneModeController mAirplane;</p>
<p>     AutoRotateController mRotate;</p>
<p>     BrightnessController mBrightness;</p>
<p>+</p>
<ul>
<li><p>//add by cjf</p>
</li>
<li><p>VolumeController mVolume;</p>
</li>
</ul>
<p>+</p>
<p>     DoNotDisturbController mDoNotDisturb;</p>
<p>     View mRotationLockContainer;</p>
<p>     View mRotationLockSeparator;</p>
<ul>
<li><p>//add by cjf</p>
</li>
<li><p>private ContentObserver mVolumeObserver = new ContentObserver(new Handler()) {</p>
</li>
<li><p>@Override</p>
</li>
<li><p>public void onChange(boolean selfChange) {</p>
</li>
<li><p>super.onChange(selfChange);</p>
</li>
<li><p>ToggleSlider toggleSlider = ((ToggleSlider)findViewById(R.id.volume));</p>
</li>
<li><p>if (toggleSlider != null) {</p>
</li>
<li><p>int volume = System.getInt(getContext().getContentResolver(),</p>
</li>
<li><p>System.VOLUME_SETTINGS[VolumeController.STREAM], -1);</p>
</li>
<li><p>// Works around an atomicity problem with volume updates</p>
</li>
<li><p>// TODO: Fix the actual issue, probably in AudioService</p>
</li>
<li><p>if (volume &gt;= 0) {</p>
</li>
<li><p>toggleSlider.setValue(volume);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>};</p>
</li>
</ul>
<p>+</p>
<p>     public SettingsView(Context context, AttributeSet attrs) {</p>
<p>         this(context, attrs, 0);</p>
<p>     }</p>
<p>@@ -80,6 +109,15 @@ public class SettingsView extends LinearLayout implements View.OnClickListener {</p>
<p>         mBrightness = new BrightnessController(context,</p>
<p>                 (ImageView)findViewById(R.id.brightness_icon),</p>
<p>                 (ToggleSlider)findViewById(R.id.brightness));</p>
<p>+</p>
<ul>
<li><p>//add by cjf</p>
</li>
<li><p>mVolume = new VolumeController(context,</p>
</li>
<li><p>(ToggleSlider)findViewById(R.id.volume));</p>
</li>
<li><p>mContext.getContentResolver().registerContentObserver(</p>
</li>
<li><p>System.getUriFor(System.VOLUME_SETTINGS[VolumeController.STREAM]),</p>
</li>
<li><p>false, mVolumeObserver);</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<p>         mDoNotDisturb = new DoNotDisturbController(context,</p>
<p>                 (CompoundButton)findViewById(R.id.do_not_disturb_checkbox));</p>
<p>         findViewById(R.id.settings).setOnClickListener(this);</p>
<p>@@ -88,6 +126,10 @@ public class SettingsView extends LinearLayout implements View.OnClickListener {</p>
<p>     @Override</p>
<p>     protected void onDetachedFromWindow() {</p>
<p>         super.onDetachedFromWindow();</p>
<p>+</p>
<ul>
<li><p>//add by cjf</p>
</li>
<li><p>getContext().getContentResolver().unregisterContentObserver(mVolumeObserver);</p>
</li>
</ul>
<p>+</p>
<p>         mAirplane.release();</p>
<p>         mDoNotDisturb.release();</p>
<p>         mRotate.release();</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>tar命令</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/tar%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>tar czvf  sdk.tar.gz –exclude=.git sdk</p>
<p>用法: tar [选项…] [FILE]…</p>
<p>GNU ‘tar’</p>
<p>将许多文件一起保存至一个单独的磁带或磁盘归档，并能从归档中单独还原所需文件。</p>
<p>示例</p>
<p>  tar -cf archive.tar foo bar  # 从文件 foo 和 bar 创建归档文件</p>
<p>archive.tar。</p>
<p>  tar -tvf archive.tar         # 详细列举归档文件 archive.tar</p>
<p>中的所有文件。</p>
<p>  tar -xf archive.tar          # 展开归档文件 archive.tar</p>
<p>中的所有文件。</p>
<p> 主操作模式:</p>
<p>  -A, –catenate, –concatenate   追加 tar 文件至归档</p>
<p>  -c, –create               创建一个新归档</p>
<p>  -d, –diff, –compare      找出归档和文件系统的差异</p>
<p>      –delete               从归档(非磁带！)中删除</p>
<p>  -r, –append               追加文件至归档结尾</p>
<p>  -t, –list                 列出归档内容</p>
<p>      –test-label           测试归档卷标并退出</p>
<p>  -u, –update               仅追加比归档中副本更新的文件</p>
<p>  -x, –extract, –get       从归档中解出文件</p>
<p> 操作修饰符:</p>
<p>      –check-device         当创建增量归档时检查设备号(默认)</p>
<p>  -g, –listed-incremental=FILE   处理新式的 GNU 格式的增量备份</p>
<p>  -G, –incremental          处理老式的 GNU 格式的增量备份</p>
<p>      –ignore-failed-read</p>
<p>                             当遇上不可读文件时不要以非零值退出</p>
<p>  -n, –seek                 归档可检索</p>
<p>      –no-check-device      当创建增量归档时不要检查设备号</p>
<p>      –occurrence[=NUMBER]  仅处理归档中每个文件的第 NUMBER</p>
<p>                             个事件；仅当与以下子命令 –delete,</p>
<p>                             –diff, –extract 或是 –list</p>
<p>                             中的一个联合使用时，此选项才有效。而且不管文件列表是以命令行形式给出或是通过</p>
<p>                             -T 选项指定的；NUMBER 值默认为 1</p>
<p>      –sparse-version=MAJOR[.MINOR]</p>
<p>                             设置所用的离散格式版本(隐含</p>
<p>                             –sparse)</p>
<p>  -S, –sparse               高效处理离散文件</p>
<p> 重写控制:</p>
<p>  -k, –keep-old-files       解压时不要替换存在的文件</p>
<p>      –keep-newer-files</p>
<p>                             不要替换比归档中副本更新的已存在的文件</p>
<p>      –no-overwrite-dir     保留已存在目录的元数据</p>
<p>      –overwrite            解压时重写存在的文件</p>
<p>      –overwrite-dir        解压时重写已存在目录的元数据(默认)</p>
<p>      –recursive-unlink     解压目录之前先清除目录层次</p>
<p>      –remove-files         在添加文件至归档后删除它们</p>
<p>  -U, –unlink-first         在解压要重写的文件之前先删除它们</p>
<p>  -W, –verify               在写入以后尝试校验归档</p>
<p> 选择输出流:</p>
<p>      –ignore-command-error 忽略子进程的退出代码</p>
<p>      –no-ignore-command-error</p>
<p>                             将子进程的非零退出代码认为发生错误</p>
<p>  -O, –to-stdout            解压文件至标准输出</p>
<p>      –to-command=COMMAND</p>
<p>                             将解压的文件通过管道传送至另一个程序</p>
<p> 操作文件属性:</p>
<p>      –atime-preserve[=METHOD]</p>
<p>                             在输出的文件上保留访问时间，要么通过在读取(默认</p>
<p>                             METHOD=‘replace’)后还原时间，要不就不要在第一次(METHOD=‘system’)设置时间</p>
<p>      –delay-directory-restore</p>
<p>                             直到解压结束才设置修改时间和所解目录的权限</p>
<p>      –group=名称         强制将 NAME</p>
<p>                             作为所添加的文件的组所有者</p>
<p>      –mode=CHANGES         强制将所添加的文件(符号)更改为权限</p>
<p>                             CHANGES</p>
<p>      –mtime=DATE-OR-FILE   从 DATE-OR-FILE 中为添加的文件设置</p>
<p>                             mtime</p>
<p>  -m, –touch                不要解压文件的修改时间</p>
<p>      –no-delay-directory-restore</p>
<p>                             取消 –delay-directory-restore 选项的效果</p>
<p>      –no-same-owner        将文件解压为您所有</p>
<p>      –no-same-permissions</p>
<p>                             从归档中解压权限时使用用户的掩码位(默认为普通用户服务)</p>
<p>      –numeric-owner        总是以数字代表用户/组的名称</p>
<p>      –owner=名称         强制将 NAME</p>
<p>                             作为所添加的文件的所有者</p>
<p>  -p, –preserve-permissions, –same-permissions</p>
<p>                             解压文件权限信息(默认只为超级用户服务)</p>
<p>      –preserve             与 -p 和 -s 一样</p>
<p>      –same-owner           尝试解压时保持所有者关系一致</p>
<p>  -s, –preserve-order, –same-order</p>
<p>                             为解压至匹配归档排序名称</p>
<p> 设备选择和切换:</p>
<p>  -f, –file=ARCHIVE         使用归档文件或 ARCHIVE 设备</p>
<p>      –force-local</p>
<p>                             即使归档文件存在副本还是把它认为是本地归档</p>
<p>  -F, –info-script=名称, –new-volume-script=名称</p>
<p>                             在每卷磁带最后运行脚本(隐含 -M)</p>
<p>  -L, –tape-length=NUMBER   写入 NUMBER × 1024 字节后更换磁带</p>
<p>  -M, –multi-volume         创建/列出/解压多卷归档文件</p>
<p>      –rmt-command=COMMAND  使用指定的 rmt COMMAND 代替 rmt</p>
<p>      –rsh-command=COMMAND  使用远程 COMMAND 代替 rsh</p>
<p>      –volno-file=FILE      使用/更新 FILE 中的卷数</p>
<p> 设备分块:</p>
<p>  -b, –blocking-factor=BLOCKS   每个记录 BLOCKS x 512 字节</p>
<p>  -B, –read-full-records    读取时重新分块(只对 4.2BSD 管道有效)</p>
<p>  -i, –ignore-zeros         忽略归档中的零字节块(即文件结尾)</p>
<p>      –record-size=NUMBER   每个记录的字节数 NUMBER，乘以 512</p>
<p> 选择归档格式:</p>
<p>  -H, –format=FORMAT        创建指定格式的归档</p>
<p> FORMAT 是以下格式中的一种:</p>
<p>    gnu                      GNU tar 1.13.x 格式</p>
<p>    oldgnu                   GNU 格式 as per tar &lt;= 1.12</p>
<p>    pax                      POSIX 1003.1-2001 (pax) 格式</p>
<p>    posix                    等同于 pax</p>
<p>    ustar                    POSIX 1003.1-1988 (ustar) 格式</p>
<p>    v7                       old V7 tar 格式</p>
<p>      –old-archive, –portability</p>
<p>                             等同于 –format=v7</p>
<p>      –pax-option=关键字[[:]=值][,关键字[[:]=值]]…</p>
<p>                             控制 pax 关键字</p>
<p>      –posix                等同于 –format=posix</p>
<p>  -V, –label=TEXT           创建带有卷名 TEXT</p>
<p>                             的归档；在列出/解压时，使用 TEXT</p>
<p>                             作为卷名的模式串</p>
<p> 压缩选项:</p>
<p>  -a, –auto-compress        使用归档后缀名来决定压缩程序</p>
<p>  -I, –use-compress-program=PROG</p>
<p>                             通过 PROG 过滤(必须是能接受 -d</p>
<p>                             选项的程序)</p>
<p>  -j, –bzip2                通过 bzip2 过滤归档</p>
<p>      –lzma                 通过 lzma 过滤归档</p>
<p>      –no-auto-compress     不使用归档后缀名来决定压缩程序</p>
<p>  -z, –gzip, –gunzip, –ungzip   通过 gzip 过滤归档</p>
<p>  -Z, –compress, –uncompress   通过 compress 过滤归档</p>
<p>  -J, –xz                   filter the archive through xz</p>
<p>      –lzop                 通过 lzop 过滤归档</p>
<p> 本地文件选择:</p>
<p>      –add-file=FILE        添加指定的 FILE 至归档(如果名字以 -</p>
<p>                             开始会很有用的)</p>
<p>      –backup[=CONTROL]     在删除前备份，选择 CONTROL 版本</p>
<p>  -C, –directory=DIR        改变至目录 DIR</p>
<p>      –exclude=PATTERN      排除以 PATTERN 指定的文件</p>
<p>      –exclude-caches       除标识文件本身外，排除包含</p>
<p>                             CACHEDIR.TAG 的目录中的内容</p>
<p>      –exclude-caches-all   排除包含 CACHEDIR.TAG 的目录</p>
<p>      –exclude-caches-under 排除包含 CACHEDIR.TAG 的目录中所有内容</p>
<p>      –exclude-tag=FILE     除 FILE 自身外，排除包含 FILE</p>
<p>                             的目录中的内容</p>
<p>      –exclude-tag-all=FILE 排除包含 FILE 的目录</p>
<p>      –exclude-tag-under=FILE   排除包含 FILE 的目录中的所有内容</p>
<p>      –exclude-vcs          排除版本控制系统目录</p>
<p>  -h, –dereference</p>
<p>                             跟踪符号链接；将它们所指向的文件归档并输出</p>
<p>      –hard-dereference</p>
<p>                             跟踪硬链接；将它们所指向的文件归档并输出</p>
<p>  -K, –starting-file=MEMBER-NAME</p>
<p>                             从归档中的 MEMBER-NAME 成员处开始</p>
<p>      –newer-mtime=DATE     当只有数据改变时比较数据和时间</p>
<p>      –no-null              禁用上一次的效果 –null 选项</p>
<p>      –no-recursion         避免目录中的自动降级</p>
<p>      –no-unquote           不以 -T 读取的文件名作为引用结束</p>
<p>      –null                 -T 读取以空终止的名字，-C 禁用</p>
<p>  -N, –newer=DATE-OR-FILE, –after-date=DATE-OR-FILE</p>
<p>                             只保存比 DATE-OR-FILE 更新的文件</p>
<p>      –one-file-system      创建归档时保存在本地文件系统中</p>
<p>  -P, –absolute-names       不要从文件名中清除引导符‘/’</p>
<p>      –recursion            目录递归(默认)</p>
<p>      –suffix=STRING        在删除前备份，除非被环境变量</p>
<p>                             SIMPLE_BACKUP_SUFFIX</p>
<p>                             覆盖，否则覆盖常用后缀(‘’)</p>
<p>  -T, –files-from=FILE      从 FILE</p>
<p>                             中获取文件名来解压或创建文件</p>
<p>      –unquote              以 -T</p>
<p>                             读取的文件名作为引用结束(默认)</p>
<p>  -X, –exclude-from=FILE    排除 FILE 中列出的模式串</p>
<p> 文件名变换:</p>
<p>      –strip-components=NUMBER   解压时从文件名中清除 NUMBER</p>
<p>                             个引导部分</p>
<p>      –transform=EXPRESSION, –xform=EXPRESSION</p>
<p>                             使用 sed 代替 EXPRESSION</p>
<p>                             来进行文件名变换</p>
<p> 文件名匹配选项(同时影响排除和包括模式串):</p>
<p>      –anchored             模式串匹配文件名头部</p>
<p>      –ignore-case          忽略大小写</p>
<p>      –no-anchored          模式串匹配任意‘/’后字符(默认对</p>
<p>                             exclusion 有效)</p>
<p>      –no-ignore-case       匹配大小写(默认)</p>
<p>      –no-wildcards         逐字匹配字符串</p>
<p>      –no-wildcards-match-slash   通配符不匹配‘/’</p>
<p>      –wildcards            使用通配符(默认对 exclusion )</p>
<p>      –wildcards-match-slash</p>
<p>                             通配符匹配‘/’(默认对排除操作有效)</p>
<p> 提示性输出:</p>
<p>      –checkpoint[=NUMBER]  每隔 NUMBER</p>
<p>                             个记录显示进度信息(默认为 10 个)</p>
<p>      –checkpoint-action=ACTION   在每个检查点上执行 ACTION</p>
<p>      –index-file=FILE      将详细输出发送至 FILE</p>
<p>  -l, –check-links</p>
<p>                             只要不是所有链接都被输出就打印信息</p>
<p>      –no-quote-chars=STRING   禁用来自 STRING 的字符引用</p>
<p>      –quote-chars=STRING   来自 STRING 的额外的引用字符</p>
<p>      –quoting-style=STYLE  设置名称引用风格；有效的 STYLE</p>
<p>                             值请参阅以下说明</p>
<p>  -R, –block-number         每个信息都显示归档内的块数</p>
<p>      –show-defaults        显示 tar 默认选项</p>
<p>      –show-omitted-dirs</p>
<p>                             列表或解压时，列出每个不匹配查找标准的目录</p>
<p>      –show-transformed-names, –show-stored-names</p>
<p>                             显示变换后的文件名或归档名</p>
<p>      –totals[=SIGNAL]      处理归档后打印出总字节数；当此</p>
<p>                             SIGNAL 被触发时带参数 -</p>
<p>                             打印总字节数；允许的信号为:</p>
<p>                             SIGHUP，SIGQUIT，SIGINT，SIGUSR1 和</p>
<p>                             SIGUSR2；同时也接受不带 SIG</p>
<p>                             前缀的信号名称</p>
<p>      –utc                  以 UTC 格式打印文件修改信息</p>
<p>  -v, –verbose              详细地列出处理的文件</p>
<p>  -w, –interactive, –confirmation</p>
<p>                             每次操作都要求确认</p>
<p> 兼容性选项:</p>
<p>  -o                         创建归档时，相当于</p>
<p>                             –old-archive；展开归档时，相当于</p>
<p>                             –no-same-owner</p>
<p> 其它选项:</p>
<p>  -?, –help                 显示此帮助列表</p>
<p>      –restrict             禁用某些潜在的有危险的选项</p>
<p>      –usage                显示简短的用法说明</p>
<p>      –version              打印程序版本</p>
<p>长选项和相应短选项具有相同的强制参数或可选参数。</p>
<p>除非以 –suffix 或 SIMPLE_BACKUP_SUFFIX</p>
<p>设置备份后缀，否则备份后缀就是“~”。</p>
<p>可以用 –backup 或 VERSION_CONTROL 设置版本控制，可能的值为：</p>
<p>  none, off        从不做备份</p>
<p>  t, numbered     进行编号备份</p>
<p>  nil, existing</p>
<p>如果编号备份存在则进行编号备份，否则进行简单备份</p>
<p>  never, simple   总是使用简单备份</p>
<p>–quoting-style 选项的有效参数为:</p>
<p>  literal</p>
<p>  shell</p>
<p>  shell-always</p>
<p>  c</p>
<p>  c-maybe</p>
<p>  escape</p>
<p>  locale</p>
<p>  clocale</p>
<p>此 tar 默认为:</p>
<p>–format=gnu -f- -b20 –quoting-style=escape –rmt-command=/usr/sbin/rmt</p>
<p>–rsh-command=/usr/bin/rsh</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>tcp_client</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/tcp_client/</url>
    <content><![CDATA[<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;arpa/inet.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>    int sockfd = -1;</p>
<p>    sockfd = socket( AF_INET, SOCK_STREAM, 0 );</p>
<p>    if ( -1 == sockfd ) {</p>
<p>        perror( &quot;sock created&quot; );</p>
<p>        exit( -1 );</p>
<p>    }</p>
<p>    struct sockaddr_in server;    </p>
<p>    memset( &amp;server, 0, sizeof( struct sockaddr_in ) );</p>
<p>    server.sin_family = AF_INET;</p>
<p>    server.sin_port = 6666;</p>
<p>    server.sin_addr.s_addr = inet_addr( &quot;127.0.0.1&quot; );</p>
<p>    int res = -1;    </p>
<p>    res = connect( sockfd, (struct sockaddr*)&amp;server, sizeof( server ) );</p>
<p>    if( -1 == res ){</p>
<p>        perror( &quot;sock connect&quot; );</p>
<p>        exit( -1 );</p>
<p>    }</p>
<p>    char sendBuf[1024] = { 0 };</p>
<p>    char recvBuf[1024] = { 0 };</p>
<p>    while( fgets( sendBuf, sizeof( sendBuf ), stdin ) != NULL ) {</p>
<p>        write( sockfd, sendBuf, sizeof( sendBuf ) );</p>
<p>        read( sockfd, recvBuf, sizeof( recvBuf ) );</p>
<p>        fputs( recvBuf, stdout );</p>
<p>        memset( sendBuf, 0, sizeof( sendBuf ) );</p>
<p>        memset( recvBuf, 0, sizeof( recvBuf ) );</p>
<p>    }</p>
<p>    close( sockfd );</p>
<p>    return 0;</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/test/</url>
    <content><![CDATA[<p>package test;<br>import java.util.ArrayList;<br>import java.util.Random;</p>
<p>import java.util.List;<br>public class test {</p>
<pre><code>/**
 * @param args
 */
public static void main(String[] args) &#123;
    // TODO Auto-generated method stub

    byte[] buf = parse(&amp;quot;A5 A5 80 00 03 0D 0E FF 0E 01 60 F2 F2 01 60&amp;quot; +
            &amp;quot;A5 A5 00 04 00 02 02 03 05 &amp;quot; +
            &amp;quot;A5 A5 00 05 02 03 0d 0f EE FE &amp;quot; +
            &amp;quot;A5 A5 00 06 0d 0E 0F ff 03 0d 0F 01 60 A5 A5 00 0D&amp;quot;);

    System.out.println(&amp;quot;buf:&amp;quot;+toString(buf));

    //int a[] = mGetHeadIndexs(buf);
    //for(int i=0;i&amp;lt;a.length;i++)
    //System.out.println(&amp;quot;head:&amp;quot;+a[i]);

    //System.out.println(&amp;quot;error:&amp;quot;+mGetFirstErrorIndex(buf,a)[0]);

    //while(mGetFirstErrorIndex(buf,mGetHeadIndexs(buf)) != null)

    //mFilterErrorBytes(buf,mGetHeadIndexs(buf));   
    mFilterErrorBytes(buf); 
    //mFilterErrorBytes(buf);   
    //mFilterErrorBytes(buf);   


    System.out.println(&amp;quot;buf:&amp;quot;+toString(buf));

    byte[] buf2 = parse(&amp;quot;01 03 0D 04 05 0E 01 60 FF&amp;quot;);

    System.out.println(&amp;quot;crc:&amp;quot;+ (CRC8(buf2) &amp;amp; 0xFF));

&#125;

public static int[] mGetHeadIndexs(byte[] buf)&#123;
        //A5 A5 ... A5 A5 ... ... A5 A5 ...
        int[] head = null ;
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();

        for(int i = 0 ; i &amp;lt; buf.length ; i++)&#123;
            if(buf[i]==(byte)0xA5 &amp;amp;&amp;amp; buf[i+1]==(byte)0xA5)
                list.add(i);                
        &#125;

        if(!list.isEmpty())&#123;
        head = new int [list.size()];
        for(int i=0;i&amp;lt;list.size();i++)
            head[i] = list.get(i);  
        &#125;       

    return head ;
&#125;


public static int[] mGetFirstErrorIndex(byte[] buf,int []a)&#123;
    if(a == null) return null;
    for(int i=0; i&amp;lt; a.length-1;i++)&#123;
       if((buf[a[i]+2] * 0x100 + buf[a[i]+3] + 5) != (a[i+1]-a[i]))&#123;
           int[] b = new int[2];
           b[0] = a[i];
           b[1] = (a[i+1]-a[i]);
           System.out.println(&amp;quot;b0:&amp;quot;+b[0]);
           System.out.println(&amp;quot;b1:&amp;quot;+b[1]);
           return b ;
           &#125;
    &#125;
    return null;
&#125;

public static void mFilterErrorBytes(byte[] buf)&#123;   

    //A5 A5 00 03... A5 A5 ... ... A5 A5 ...
    //index of head             
    int[] head = new int[16];
    int err=-1,errlen=0;
    int hsize=0;

    for(int i = 0 ; i &amp;lt; buf.length ; i++)&#123;
        if(buf[i]==(byte)0xA5 &amp;amp;&amp;amp; buf[i+1]==(byte)0xA5)&#123;             
            head[hsize++]=i;
            if(hsize &amp;gt;=16) break;
        &#125;

    &#125;   

    if(hsize &amp;lt; 2) return;

    //find error first frame        
    for(int i=0; i &amp;lt; hsize-1;i++)&#123;
        if(((buf[head[i]+2] &amp;amp; 0xFF) * 0x100 + (buf[head[i]+3] &amp;amp; 0xFF) + 5) != (head[i+1]-head[i]))&#123;
              err = head[i];
              errlen = (head[i+1]-head[i]);
               System.out.println(&amp;quot;err:&amp;quot;+err);
               System.out.println(&amp;quot;errlen:&amp;quot;+errlen);
               break;
        &#125;
    &#125;        


    if(err &amp;lt; 0 || errlen == 0) return;       

        //filter head
        if((buf[err+2] &amp;amp; 0xFF) &amp;gt; 0x10)&#123;
            System.arraycopy(buf, err+3, buf, err+2, buf.length-err-3);
            errlen--;
        &#125;           


        if(errlen &amp;lt; 256)&#123;
        //filter 0x01 0x60           
         for(int i=err+errlen-1 ; i &amp;gt; err ; i--)&#123;
            if (buf[i-1]==(byte)0x01 &amp;amp;&amp;amp; buf[i]==(byte)0x60)&#123;                    
                byte[] tmp = new byte[errlen];
                System.arraycopy(buf,err, tmp, 0, errlen);//tmp error frame
                System.arraycopy(tmp, i-err+1, tmp, i-err-1, errlen-(i-err+1));//rid 0x01 0x60
                //test len ,crc ?
                if((tmp[2] &amp;amp; 0xFF)*0x100 + (tmp[3] &amp;amp; 0xFF) + 5 &amp;lt;= errlen-2)&#123;                 
                    System.arraycopy(buf, i+1, buf, i-1, buf.length-(i+1));
                    errlen-=2;
                &#125;
            &#125;                 
         &#125;          
        &#125;else&#123;


        &#125;

        //filter tail redundant
        int length = (buf[err+2] &amp;amp; 0xFF)*0x100 + (buf[err+3] &amp;amp; 0xFF) + 5 ;
        if(length &amp;lt; errlen)&#123;              
            System.arraycopy(buf, err+errlen, buf, err+length, buf.length-err-errlen);              
        &#125;

        //CRC

    //&#125;


&#125;


private static byte CRC8(byte[] buf)&#123;
    byte crc = 0;

    if(buf != null)&#123;
        for(int i=0;i&amp;lt;buf.length;i++)&#123;
            crc +=(buf[i] &amp;amp; 0xFF);
            crc &amp;amp;= 0xFF;
        &#125;

    &#125;

    return crc;
&#125;

//转换字符串到byte数组
//例如 parse(&amp;quot;5A 5A&amp;quot;) == &#123; 0x5A, 0x5A&#125;;
// parse(&amp;quot;5A,5A&amp;quot;) == &#123;0x5A, 0x5A&#125;;
// parse(&amp;quot;0x5a,0x5a&amp;quot;) == &#123;0x5A, 0x5A&#125;;
public static byte[] parse(String s)
&#123;
    byte[] res = new byte[s.length()/2];
    int c = 0;
    for(int i =0; i&amp;lt;s.length()-1; i++)
    &#123;
        if(isHex(s.charAt(i)) &amp;amp;&amp;amp; isHex(s.charAt(i+1)))
        &#123;
            res[c++] = parseByte(s.substring(i));
            i++;
        &#125;
        else if ((s.charAt(i) == &#39;?&#39;) &amp;amp;&amp;amp; (s.charAt(i+1) == &#39;?&#39;)) &#123;
            res[c++] = (byte) new Random().nextInt();
            i++;
        &#125;
    &#125;

    byte[] res2 = new byte[c];
    System.arraycopy(res, 0, res2, 0, c);
    return res2;
&#125;

public static boolean isHex(char c) &#123;
    return (c&amp;gt;=&#39;0&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;9&#39;) || (c&amp;gt;=&#39;a&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;f&#39;)|| (c&amp;gt;=&#39;A&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;F&#39;);
&#125;


//转换字符串到byte
//例如 parseByte(&amp;quot;5A&amp;quot;) == (byte)0x5A
public static byte parseByte(String s) &#123;
    if(s == null || s.isEmpty()) return 0;
    if(s.length() == 1)
        return parseChar(s.charAt(0));

    return (byte)(parseChar(s.charAt(0)) * 0x10 + parseChar(s.charAt(1)));
&#125;

public static byte parseChar(char c) &#123;
    if(c&amp;gt;=&#39;0&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;9&#39;) return (byte)(c - &#39;0&#39;);
    if(c&amp;gt;=&#39;a&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;f&#39;) return (byte)(c-&#39;a&#39;+10);
    if(c&amp;gt;=&#39;A&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;F&#39;) return (byte)(c-&#39;A&#39;+10);
    return 0;
&#125;


//转换byte数组到字符串
//例如: byte[] b = &#123;(byte)0xa5, (byte)0xa5&#125;;
// toString(b).equels == &amp;quot;A5 A5 &amp;quot;;
//@SuppressLint(&amp;quot;DefaultLocale&amp;quot;)
public static String toString(byte[] b)
&#123;
    return toString(b, 0, b.length);

&#125;

//@SuppressLint(&amp;quot;DefaultLocale&amp;quot;)
public static String toString(byte[] b, int len)
&#123;
    return toString(b, 0, len);
&#125;

//转换byte数组到字符串
//与上面函数不同的是指定了转换的个数
//@SuppressLint(&amp;quot;DefaultLocale&amp;quot;)
public static String toString(byte[] b, int from, int len)
&#123;
    String res = &amp;quot;&amp;quot;;

    for(int i = from; i&amp;lt;from+len; i++)
    &#123;
        String hex = Integer.toHexString(b[i] &amp;amp; 0xFF);
        if(hex.length() == 1) hex = &#39;0&#39; + hex;

        res += hex.toUpperCase();
        res += &amp;quot; &amp;quot;;
    &#125;

    return res;
&#125;</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ubnuntu 18</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ubnuntu%2018.04%E6%8F%90%E7%A4%BA%E6%97%A0libmpfr.so.4/</url>
    <content><![CDATA[<p>error while loading shared libraries:libmpfr.so.4: cannot open shared object file: No such file or directory.</p>
<p>解决：</p>
<p>sudo ln -s /usr/lib/x86_64-linux-gnu/libmpfr.so.6 /usr/lib/x86_64-linux-gnu/libmpfr.so.4</p>
<p> ———————————————— </p>
<p>版权声明：本文为CSDN博主「sosyuka」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://blog.csdn.net/ssj901217/article/details/88098304">https://blog.csdn.net/ssj901217/article/details/88098304</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu 16</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ubuntu%2016.04%20%E5%AE%89%E8%A3%85%20openjdk%201.7/</url>
    <content><![CDATA[<p>sources.list  用原来的list</p>
<p>sudo add-apt-repository ppa:openjdk-r/ppa  <br>sudo apt-get update  <br>sudo apt-get install openjdk-7-jdk </p>
<p>如果安装成功之后还是不能用可能不有多个版本，选的不对</p>
<p>sudo update-alternatives –config java</p>
<p>sudo update-alternatives –config javac</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu svn 服务器</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ubuntu%20svn%20%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>安装subversion</p>
<p>sudo apt-get install subversion</p>
<p>创建repository工程</p>
<p>sudo mkdir  /opt/svn/repository</p>
<p>sudo chmod -R 777 /opt/svn/repository</p>
<p>sudo svnadmin create /opt/svn/repository</p>
<p>sudo chmod -R 777 /opt/svn/repository/db</p>
<p>打开以下配置，所有的行都必须顶格，否则报错</p>
<p>sudo vim /opt/svn/repository/conf/svnserve.conf</p>
<p>anon-access = none</p>
<p>auth-access = wite</p>
<p>password-db = passwd</p>
<p>添加用户</p>
<p>sudo vim /opt/svn/repository/conf/passwd </p>
<p>lizl = 123456</p>
<p>添加权限</p>
<p>sudo vim /opt/svn/repository/conf/authz</p>
<p>admin = lizl       //用户王属于admin权限组</p>
<p>@admin = rw    //admin权限组的权限是读和写</p>
<ul>
<li>= r                   //所有的组都具有读权限</li>
</ul>
<p>启动svn服务器</p>
<p>-d：表示在后台运行</p>
<p>-r：指定服务器的根目录</p>
<p>svnserve -d -r /opt/svn</p>
<p>访问 ：  svn://服务器ip/repository</p>
<p>killall svnserve  //停止</p>
<p>ps aux | grep svnserve  //查看</p>
<p>svnserve -d -r /opt/svn</p>
<p>把启动服务命令添加到 /etc/rc.local，开机自动启动svn服务</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu 默认系统语言</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ubuntu%20%E9%BB%98%E8%AE%A4%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>vi /etc/default/locale</p>
<p>LANG=&quot;en_US.UTF-8&quot;</p>
<p>LANGUAGE=&quot;en_US:zh&quot;</p>
<p> cd /usr/share/locales</p>
<p>root@bx-desktop:/usr/share/locales# ls</p>
<p>install-language-pack  remove-language-pack</p>
<p>root@bx-desktop:/usr/share/locales# ./install-language-pack en_US</p>
<p>/bin/bash: warning: setlocale: LC_ALL: cannot change locale (en_US)</p>
<p>Generating locales…</p>
<p>  en_US.UTF-8… done</p>
<p>Generation complete.</p>
<p>dpkg-trigger: dpkg-trigger must be called from a maintainer script (or with a –by-package option)</p>
<p>root@bx-desktop:/usr/share/locales#</p>
<p>apt-get purge locales  ////导致相关的卸载</p>
<p>///apt-get autoclean</p>
<p>apt-get install locales</p>
<p>cd /usr/share/localescd </p>
<p>./install-language-pack en_US.UTF-8</p>
<p>dpkg-reconfigure locales</p>
<p>修复完成</p>
<p>运行locale</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>update</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/update.zip%20%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p>├── META-INF</p>
<p>│   ├── CERT.RSA</p>
<p>│   ├── CERT.SF</p>
<p>│   ├── com</p>
<p>│   │   ├── android</p>
<p>│   │   │   └── otacert</p>
<p>│   │   └── google</p>
<p>│   │   └── android</p>
<p>│   │   ├── update-binary</p>
<p>│   │   └── updater-script</p>
<p>│   └── MANIFEST.MF</p>
<p>├── system</p>
<p>│   ├── app</p>
<p>│   └── build.prop</p>
<p>├── boot.img</p>
<p> 通过脚本updater-script 将 system  boot.img 等 替换到系统中，再修改权限。</p>
<p>将这些文件以存储方式打包为update.zip , 再用 signapk.jar 来签名。</p>
<p>#!/bin/bash</p>
<p>rm -rvf update_raw.zip</p>
<p>rm -rvf update.zip</p>
<p>cp -rvf updater-script META-INF/com/google/android/</p>
<p>zip -r -Z store update_raw.zip META-INF/* system/* boot.img</p>
<p>#zip -r -Z store update_raw.zip META-INF/* system/*</p>
<p>echo &quot;signed update.zip …&quot;</p>
<p>java -jar signapk.jar -w testkey.x509.pem testkey.pk8 update_raw.zip update.zip   </p>
<p>echo &quot;done&quot;</p>
<p>signapk.jar </p>
<p>out/host/linux-x86/framework/signapk.jar</p>
<p>testkey.x509.pem    testkey.pk8   或 platform.pk8  platform.x509.pem</p>
<p>build/target/product/security/testkey.pk8</p>
<p>build/target/product/security/testkey.x509.pem</p>
<p>build/target/product/security/platform.pk8</p>
<p>build/target/product/security/platform.x509.pem</p>
<p>================================================================================</p>
<p>update.zip包的目录结构<br>          |—-boot.img<br>          |—-system/<br>          |—-recovery/<br>                <code>|----recovery-from-boot.p                 </code>|—-etc/<br>                        <code>|----install-recovery.sh           |---META-INF/               </code>|CERT.RSA<br>              <code>|CERT.SF               </code>|MANIFEST.MF<br>              <code>|----com/                      </code>|—-google/<br>                             <code>|----android/                                     </code>|—-update-binary<br>                                    <code>|----updater-script                              </code>|—-android/<br>                                    `|—-metadata </p>
<p>二、 update.zip包目录结构详解<br>         以上是我们用命令make otapackage 制作的update.zip包的标准目录结构。<br>1、boot.img是更新boot分区所需要的文件。这个boot.img主要包括kernel+ramdisk。</p>
<p>2、system/目录的内容在升级后会放在系统的system分区。主要用来更新系统的一些应用或则应用会用到的一些库等等。可以将Android源码编译out/target/product/tcc8800/system/中的所有文件拷贝到这个目录来代替。</p>
<p>3、recovery/目录中的recovery-from-boot.p是boot.img和recovery.img的补丁(patch),主要用来更新recovery分区，其中etc/目录下的install-recovery.sh是更新脚本。<br>4、update-binary是一个二进制文件，相当于一个脚本解释器，能够识别updater-script中描述的操作。该文件在Android源码编译后out/target/product/tcc8800/system bin/updater生成，可将updater重命名为update-binary得到。<br>               该文件在具体的更新包中的名字由源码中bootable/recovery/install.c中的宏ASSUMED_UPDATE_BINARY_NAME的值而定。<br>5、updater-script：此文件是一个脚本文件，具体描述了更新过程。我们可以根据具体情况编写该脚本来适应我们的具体需求。该文件的命名由源码中bootable/recovery/updater/updater.c文件中的宏SCRIPT_NAME的值而定。<br>6、 metadata文件是描述设备信息及环境变量的元数据。主要包括一些编译选项，签名公钥，时间戳以及设备型号等。<br>7、我们还可以在包中添加userdata目录，来更新系统中的用户数据部分。这部分内容在更新后会存放在系统的/data目录下。</p>
<p>8、update.zip包的签名：update.zip更新包在制作完成后需要对其签名，否则在升级时会出现认证失败的错误提示。而且签名要使用和目标板一致的加密公钥。加密公钥及加密需要的三个文件在Android源码编译后生成的具体路径为：</p>
<p>               out/host/linux-x86/framework/signapk.jar </p>
<p>               build/target/product/security/testkey.x509.pem         </p>
<p>               build/target/product/security/testkey.pk8 。</p>
<p>              我们用命令make otapackage制作生成的update.zip包是已签过名的，如果自己做update.zip包时必须手动对其签名。</p>
<p>              具体的加密方法：$ java –jar gingerbread/out/host/linux/framework/signapk.jar –w gingerbread/build/target/product/security/testkey.x509.pem                                      gingerbread/build/target/product/security/testkey.pk8 update.zip update_signed.zip<br>              以上命令在update.zip包所在的路径下执行，其中signapk.jar testkey.x509.pem以及testkey.pk8文件的引用使用绝对路径。update.zip 是我们已经打好的包，update_signed.zip包是命令执行完生成的已经签过名的包。<br>9、MANIFEST.MF：这个manifest文件定义了与包的组成结构相关的数据。类似Android应用的mainfest.xml文件。<br>10、CERT.RSA：与签名文件相关联的签名程序块文件，它存储了用于签名JAR文件的公共签名。<br>11、CERT.SF：这是JAR文件的签名文件，其中前缀CERT代表签名者。<br>        另外，在具体升级时，对update.zip包检查时大致会分三步：①检验SF文件与RSA文件是否匹配。②检验MANIFEST.MF与签名文件中的digest是否一致。③检验包中的文件与MANIFEST中所描述的是否一致。 </p>
<p>三、 Android升级包update.zip的生成过程分析</p>
<p>         1) 对于update.zip包的制作有两种方式，即手动制作和命令生成。</p>
<p>第一种手动制作：即按照update.zip的目录结构手动创建我们需要的目录。然后将对应的文件拷贝到相应的目录下，比如我们向系统中新加一个应用程序。可以将新增的应用拷贝到我们新建的update/system/app/下（system目录是事先拷贝编译源码后生成的system目录），打包并签名后，拷贝到SD卡就可以使用了。这种方式在实际的tcc8800开发板中未测试成功。签名部分未通过，可能与具体的开发板相关。</p>
<p>第二种制作方式：命令制作。Android源码系统中为我们提供了制作update.zip刷机包的命令，即make otapackage。该命令在编译源码完成后并在源码根目录下执行。 具体操作方式：在源码根目录下执行</p>
<p>                ①$ . build/envsetup.sh。 </p>
<p>                ②$ lunch 然后选择你需要的配置(如17)。</p>
<p>                ③$ make otapackage。</p>
<p>          在编译完源码后最好再执行一遍上面的①、②步防止执行③时出现未找到对应规则的错误提示。命令执行完成后生成的升级包所在位置在out/target/product/full_tcc8800_evm_target_files-eng.mumu.20120309.111059.zip将这个包重新命名为update.zip，并拷贝到SD卡中即可使用。</p>
<p>           这种方式(即完全升级)在tcc8800开发板中已测试成功。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>updater-script only rk 3168 8723</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/updater-script%20only%20rk%203168%208723/</url>
    <content><![CDATA[<p>#assert(!less_than_int(1386292850, getprop(&quot;ro.build.date.utc&quot;)));</p>
<p>#assert(getprop(&quot;ro.product.device&quot;) == &quot;rk30sdk&quot;);</p>
<p>mount(&quot;ext4&quot;, &quot;EMMC&quot;, &quot;/dev/block/mtd/by-name/system&quot;, &quot;/system&quot;);</p>
<p>show_progress(0.100000, 0);</p>
<h1 id="—-start-making-changes-here-—"><a href="#—-start-making-changes-here-—" class="headerlink" title="—- start making changes here —-"></a>—- start making changes here —-</h1><p>ui_print(&quot;Erasing user data…&quot;);</p>
<p>format(&quot;ext4&quot;, &quot;EMMC&quot;, &quot;/dev/block/mtd/by-name/userdata&quot;, &quot;0&quot;, &quot;/data&quot;);</p>
<p>ui_print(&quot;Removing unneeded files…&quot;);</p>
<p>delete(&quot;/system/app/FileExplore.apk&quot;);</p>
<p>ui_print(&quot;- Copying files…&quot;);</p>
<p>package_extract_dir(&quot;system&quot;, &quot;/system&quot;);</p>
<p>show_progress(0.400000, 0);</p>
<p>#package_extract_dir(&quot;recovery&quot;, &quot;/system&quot;);</p>
<p>#set_perm(0, 0, 0544, &quot;/system/etc/install-recovery.sh&quot;);</p>
<p>ui_print(&quot;Symlinks and permissions…&quot;);</p>
<p>set_perm_recursive(0, 0, 0755, 0644, &quot;/system&quot;);</p>
<p>set_perm_recursive(0, 2000, 0755, 0755, &quot;/system/bin&quot;);</p>
<p>set_perm(0, 3003, 02750, &quot;/system/bin/netcfg&quot;);</p>
<p>set_perm(0, 3004, 02755, &quot;/system/bin/ping&quot;);</p>
<p>set_perm(0, 2000, 06750, &quot;/system/bin/run-as&quot;);</p>
<p>set_perm(1002, 1002, 0440, &quot;/system/etc/dbus.conf&quot;);</p>
<p>set_perm(1014, 2000, 0550, &quot;/system/etc/dhcpcd/dhcpcd-run-hooks&quot;);</p>
<p>set_perm(0, 2000, 0550, &quot;/system/etc/init.goldfish.sh&quot;);</p>
<p>set_perm_recursive(0, 0, 0755, 0555, &quot;/system/etc/ppp&quot;);</p>
<p>set_perm(0, 2000, 0755, &quot;/system/vendor&quot;);</p>
<p>set_perm_recursive(0, 2000, 0755, 0755, &quot;/system/vendor/bin&quot;);</p>
<p>set_perm(0, 2000, 0755, &quot;/system/vendor/firmware&quot;);</p>
<p>set_perm(0, 2000, 0755, &quot;/system/vendor/lib&quot;);</p>
<p>set_perm(0, 2000, 0755, &quot;/system/vendor/lib/egl&quot;);</p>
<p>set_perm_recursive(0, 2000, 0755, 0644, &quot;/system/vendor/lib/hw&quot;);</p>
<p>set_perm(0, 0, 0644, &quot;/system/vendor/lib/hw/gralloc.rk30xxb.so&quot;);</p>
<p>set_perm_recursive(0, 2000, 0755, 0644, &quot;/system/vendor/pittpatt&quot;);</p>
<p>set_perm(0, 0, 0644, &quot;/system/vendor/pittpatt/models/detection/multi_pose_face_landmark_detectors.7/left_eye-y0-yi45-p0-pi45-r0-ri20.lg_32/full_model.bin&quot;);</p>
<p>set_perm(0, 0, 0644, &quot;/system/vendor/pittpatt/models/detection/multi_pose_face_landmark_detectors.7/nose_base-y0-yi45-p0-pi45-r0-ri20.lg_32/full_model.bin&quot;);</p>
<p>set_perm(0, 0, 0644, &quot;/system/vendor/pittpatt/models/detection/multi_pose_face_landmark_detectors.7/right_eye-y0-yi45-p0-pi45-r0-ri20.lg_32-2/full_model.bin&quot;);</p>
<p>set_perm(0, 0, 0644, &quot;/system/vendor/pittpatt/models/detection/yaw_roll_face_detectors.6/head-y0-yi45-p0-pi45-r0-ri30.4a-v24/full_model.bin&quot;);</p>
<p>set_perm(0, 0, 0644, &quot;/system/vendor/pittpatt/models/detection/yaw_roll_face_detectors.6/head-y0-yi45-p0-pi45-rn30-ri30.5-v24/full_model.bin&quot;);</p>
<p>set_perm(0, 0, 0644, &quot;/system/vendor/pittpatt/models/detection/yaw_roll_face_detectors.6/head-y0-yi45-p0-pi45-rp30-ri30.5-v24/full_model.bin&quot;);</p>
<p>set_perm(0, 0, 0644, &quot;/system/vendor/pittpatt/models/recognition/face.face.y0-y0-22-b-N/full_model.bin&quot;);</p>
<p>set_perm_recursive(0, 2000, 0755, 0755, &quot;/system/xbin&quot;);</p>
<p>set_perm(0, 0, 06755, &quot;/system/xbin/librank&quot;);</p>
<p>set_perm(0, 0, 06755, &quot;/system/xbin/procmem&quot;);</p>
<p>set_perm(0, 0, 06755, &quot;/system/xbin/procrank&quot;);</p>
<p>set_perm(0, 0, 06755, &quot;/system/xbin/su&quot;);</p>
<p>set_perm(0, 0, 06755, &quot;/system/xbin/tcpdump&quot;);</p>
<p>clear_misc_command();</p>
<p>set_perm(0, 0, 0644, &quot;/system/build.prop&quot;);</p>
<p>show_progress(0.500000, 0);</p>
<p>#ui_print(&quot;update boot…&quot;);</p>
<p>#write_raw_image(package_extract_file(&quot;boot.img&quot;), &quot;boot&quot;);</p>
<p>unmount(&quot;/system&quot;);</p>
<p>show_progress(0.600000, 0);</p>
<p>ui_print(&quot;- Installation complete!&quot;);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>updater-script</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/updater-script/</url>
    <content><![CDATA[<p>#assert(!less_than_int(1386292850, getprop(&quot;ro.build.date.utc&quot;)));</p>
<p>#assert(getprop(&quot;ro.product.device&quot;) == &quot;rk30sdk&quot;);</p>
<p>#run_program(&quot;/system/bin/busybox&quot;, &quot;mount&quot;, &quot;-o&quot;, &quot;rw,remount&quot;, &quot;/system&quot;, &quot;/system&quot;);</p>
<p>#run_program(&quot;/system/bin/busybox&quot;, &quot;mount&quot;, &quot;-o&quot;, &quot;rw,remount&quot;, &quot;/&quot;, &quot;/&quot;);</p>
<p>mount(&quot;ext4&quot;, &quot;EMMC&quot;, &quot;/dev/block/mtd/by-name/system&quot;, &quot;/system&quot;);</p>
<p>show_progress(0.100000, 0);</p>
<h1 id="—-start-making-changes-here-—"><a href="#—-start-making-changes-here-—" class="headerlink" title="—- start making changes here —-"></a>—- start making changes here —-</h1><p>#ui_print(&quot;Erasing user data…&quot;);</p>
<p>#format(&quot;ext4&quot;, &quot;EMMC&quot;, &quot;/dev/block/mtd/by-name/userdata&quot;, &quot;0&quot;, &quot;/data&quot;);</p>
<p>ui_print(&quot;Removing unneeded files…&quot;);</p>
<p>#delete(&quot;/system/app/FileExplore.apk&quot;);</p>
<p>ui_print(&quot;- Copying files…&quot;);</p>
<p>#package_extract_dir(&quot;system&quot;, &quot;/system&quot;);</p>
<p>package_extract_dir(&quot;system&quot;, &quot;/system/tmp&quot;);</p>
<p>run_program(&quot;/system/bin/busybox&quot;, &quot;cp&quot;, &quot;system/tmp/app/RKUpdateService.apk&quot;, &quot;/system/app/RKUpdateService.apk&quot;);</p>
<p>ui_print(&quot;delete temp files…&quot;);</p>
<p>run_program(&quot;/system/bin/busybox&quot;, &quot;rm&quot;, &quot;-rf&quot;, &quot;/system/tmp&quot;); </p>
<p>ui_print(&quot;fix permissions…&quot;);</p>
<p>set_perm(0, 0, 0644, &quot;/system/app/RKUpdateService.apk&quot;);</p>
<p>show_progress(0.400000, 0);</p>
<p>#package_extract_dir(&quot;recovery&quot;, &quot;/system&quot;);</p>
<p>#set_perm(0, 0, 0544, &quot;/system/etc/install-recovery.sh&quot;);</p>
<p>clear_misc_command();</p>
<p>set_perm(0, 0, 0644, &quot;/system/build.prop&quot;);</p>
<p>show_progress(0.500000, 0);</p>
<p>#ui_print(&quot;update boot…&quot;);</p>
<p>#write_raw_image(package_extract_file(&quot;boot.img&quot;), &quot;boot&quot;);</p>
<p>unmount(&quot;/system&quot;);</p>
<p>show_progress(0.600000, 0);</p>
<p>ui_print(&quot;- Installation complete!&quot;);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>usb device Usb Permission</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/usb%20device%20Usb%20Permission/</url>
    <content><![CDATA[<p>— a/packages/SystemUI/src/com/android/systemui/usb/UsbPermissionActivity.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/usb/UsbPermissionActivity.java</p>
<p>@@ -110,8 +110,9 @@ public class UsbPermissionActivity extends AlertActivity</p>
<p>                                                     com.android.internal.R.id.clearDefaultHint);</p>
<p>         mClearDefaultHint.setVisibility(View.GONE);</p>
<ul>
<li>       setupAlert();</li>
</ul>
<p>-</p>
<ul>
<li><p>       //setupAlert();</p>
</li>
<li><p>               mPermissionGranted = true;</p>
</li>
<li><p>               finish();</p>
</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>verify apps over usb</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/verify%20apps%20over%20usb/</url>
    <content><![CDATA[<p>— a/src/com/android/settings/DevelopmentSettings.java</p>
<p>+++ b/src/com/android/settings/DevelopmentSettings.java</p>
<p>@@ -651,7 +651,7 @@ public class DevelopmentSettings extends RestrictedSettingsFragment</p>
<p>     private void updateVerifyAppsOverUsbOptions() {</p>
<p>         updateCheckBox(mVerifyAppsOverUsb, Settings.Global.getInt(getActivity().getContentResolver(),</p>
<ul>
<li>               Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB, 1) != 0);</li>
</ul>
<ul>
<li>               Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB, 0) != 0);</li>
</ul>
<p>         mVerifyAppsOverUsb.setEnabled(enableVerifierSetting());</p>
<p>     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>vi etcsambasmb</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/vi%20etcsambasmb.conf/</url>
    <content><![CDATA[<p>[share]</p>
<p>path=/opt/disk1/share</p>
<p>available=yes</p>
<p>browseable=yes</p>
<p>writable=yes</p>
<p>public=yes</p>
<p>[9820e]</p>
<p>path=/opt/disk2/9820e</p>
<p>available=yes</p>
<p>browseable=yes</p>
<p>writable=yes</p>
<p>public=no</p>
<p>valid users = hz</p>
<p>security = user</p>
<p>[disk2]</p>
<p>path=/opt/disk2</p>
<p>available=yes</p>
<p>browseable=yes</p>
<p>writable=no</p>
<p>public=no</p>
<p>valid users = hz</p>
<p>security = user</p>
<p>[hz4g]</p>
<p>path=/opt/disk2/HZ4G</p>
<p>available=yes</p>
<p>browseable=yes</p>
<p>writable=yes</p>
<p>public=no</p>
<p>valid users = hz</p>
<p>security = user</p>
<p>[SSC8323]</p>
<p>path=/opt/disk2/ssc8323</p>
<p>available=yes</p>
<p>browseable=yes</p>
<p>writable=yes</p>
<p>public=no</p>
<p>valid users = hz</p>
<p>security = user</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>vim命令</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/vim%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>vim </p>
<p>删除空行 ： :%s/^\s*$\n//</p>
<p>是否有dos换行符： e ++ff=unix %</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>wake Browser forever 浏览器屏幕不休眠</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/wake%20Browser%20forever%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B1%8F%E5%B9%95%E4%B8%8D%E4%BC%91%E7%9C%A0/</url>
    <content><![CDATA[<p>// wake Browser forever</p>
<p>— a/packages/apps/Browser/src/com/android/browser/BrowserActivity.java</p>
<p>+++ b/packages/apps/Browser/src/com/android/browser/BrowserActivity.java</p>
<p>@@ -39,7 +39,8 @@ import android.view.View;</p>
<p> import android.view.Window;</p>
<p> import android.widget.Toast;</p>
<p> import android.graphics.PixelFormat;</p>
<p>-</p>
<p>+import android.os.PowerManager.WakeLock;</p>
<p>+import android.os.PowerManager;</p>
<p> import java.io.File;</p>
<p> import java.util.HashSet;</p>
<p> import java.util.List;</p>
<p>@@ -61,6 +62,8 @@ public class BrowserActivity extends Activity {</p>
<p>     private Controller mController;</p>
<p>     private UI mUi;</p>
<ul>
<li>      private WakeLock mWakeLock;</li>
</ul>
<p>+</p>
<p>     @Override</p>
<p>     public void onCreate(Bundle icicle) {</p>
<p>         if (LOGV_ENABLED) {</p>
<p>@@ -176,6 +179,14 @@ public class BrowserActivity extends Activity {</p>
<p>     @Override</p>
<p>     protected void onResume() {</p>
<p>         super.onResume();</p>
<p>+</p>
<ul>
<li><p>              if (mWakeLock == null) {//add by Edward</p>
</li>
<li><p>                   PowerManager pm = (PowerManager) this.getSystemService(Context.POWER_SERVICE);</p>
</li>
<li><p>                   mWakeLock = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, &quot;Browser2&quot;);</p>
</li>
<li><p>               }</p>
</li>
<li><p>               mWakeLock.acquire();//wake forever</p>
</li>
</ul>
<p>+</p>
<p>         if (LOGV_ENABLED) {</p>
<p>       Log.v(LOGTAG, &quot;BrowserActivity.onResume: this=&quot; + this);</p>
<p>         }</p>
<p>@@ -218,6 +229,11 @@ public class BrowserActivity extends Activity {</p>
<p>     @Override</p>
<p>     protected void onPause() {</p>
<p>+</p>
<ul>
<li><p>   if (mWakeLock != null) {//add by Edward</p>
</li>
<li><p>           mWakeLock.release();</p>
</li>
<li><p>       }</p>
</li>
</ul>
<p>+</p>
<p>  另外：：：下面方法 也可以keep the screen on </p>
<p>getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</p>
<p>getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>wake_lock</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/wake_lock/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/g_salamander/article/details/7978772">http://blog.csdn.net/g_salamander/article/details/7978772</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>wifi 休眠选项</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/wifi%20%E4%BC%91%E7%9C%A0%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<p>packages/apps/Settings/src/com/android/settings/wifi/AdvancedWifiSettings.java</p>
<ul>
<li>                   Settings.System.WIFI_SLEEP_POLICY_NEVER);</li>
</ul>
<ul>
<li>                   Settings.System.WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED);</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>wifi 密码</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/wifi%20%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>cat /data/misc/wifi/wpa_supplicant.conf</p>
<p>ctrl_interface=wlan0</p>
<p>update_config=1</p>
<p>device_name=rk30sdk</p>
<p>manufacturer=rockchip</p>
<p>model_name=rk30sdk</p>
<p>model_number=rk30sdk</p>
<p>serial_number=U33BXCAGFI</p>
<p>device_type=10-0050F204-5</p>
<p>config_methods=physical_display virtual_push_button keypad</p>
<p>network={</p>
<p>ssid=&quot;Apple&quot;</p>
<p>psk=&quot;13760221342&quot;</p>
<p>key_mgmt=WPA-PSK</p>
<p>priority=6</p>
<p>}</p>
<p>network={</p>
<p>ssid=&quot;HXX&quot;</p>
<p>psk=&quot;15099938393&quot;</p>
<p>key_mgmt=WPA-PSK</p>
<p>priority=8</p>
<p>}</p>
<p>network={</p>
<p>ssid=&quot;LENOVO&quot;</p>
<p>psk=&quot;27801511&quot;</p>
<p>key_mgmt=WPA-PSK</p>
<p>priority=10</p>
<p>}</p>
<p>network={</p>
<p>ssid=&quot;Mercury&quot;</p>
<p>psk=&quot;wade0718&quot;</p>
<p>key_mgmt=WPA-PSK</p>
<p>priority=20</p>
<p>}</p>
<p>network={</p>
<p>ssid=&quot;cc&quot;</p>
<p>psk=&quot;cc76091291&quot;</p>
<p>key_mgmt=WPA-PSK</p>
<p>priority=33</p>
<p>}</p>
<p>network={</p>
<p>ssid=&quot;DAN&quot;</p>
<p>psk=&quot;cc76091291&quot;</p>
<p>key_mgmt=WPA-PSK</p>
<p>priority=30</p>
<p>}</p>
<p>network={</p>
<p>ssid=&quot;MINI_WIFI&quot;</p>
<p>psk=&quot;13553958349&quot;</p>
<p>proto=WPA RSN</p>
<p>key_mgmt=WPA-PSK</p>
<p>pairwise=CCMP TKIP NONE</p>
<p>auth_alg=OPEN</p>
<p>}</p>
<p>network={</p>
<p>ssid=&quot;Tenda_704&quot;</p>
<p>psk=&quot;07637662228dzj&quot;</p>
<p>key_mgmt=WPA-PSK</p>
<p>priority=50</p>
<p>}</p>
<p>network={</p>
<p>ssid=&quot;szfcar&quot;</p>
<p>psk=&quot;fcar8888&quot;</p>
<p>key_mgmt=WPA-PSK</p>
<p>priority=56</p>
<p>}</p>
<p>network={i</p>
<p>        ssid=&quot;XGC&quot;</p>
<p>        psk=&quot;27793548&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;13530051346&quot;</p>
<p>        psk=&quot;13530051346&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>        priority=4</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;JSX7JZYKXLNC2L5_Network_1&quot;</p>
<p>        psk=&quot;88888888&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;ALS&quot;</p>
<p>        psk=&quot;27791981&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;TP-LINK_6F8FFC&quot;</p>
<p>        psk=&quot;07550755&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;myWiFi&quot;</p>
<p>        psk=&quot;shenzhen@metro&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;banshanghuang&quot;</p>
<p>        psk=&quot;23711916&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>        priority=7</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;ChinaNet-CHANG&quot;</p>
<p>        psk=&quot;88888888&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>        priority=8</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;HSY02&quot;</p>
<p>        psk=&quot;88888888&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>        priority=9</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;MobileWiFi-d376&quot;</p>
<p>        psk=&quot;13002030&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;chinanet&quot;</p>
<p>        psk=&quot;tingting&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;602&quot;</p>
<p>        psk=&quot;87654321&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;XGC&quot;</p>
<p>        psk=&quot;27793548&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;MNOPQ-PC_Network&quot;</p>
<p>        psk=&quot;pengyunqing15818694551&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>        priority=36</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;SAFER 02&quot;</p>
<p>        psk=&quot;%safer009%&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;ok168&quot;</p>
<p>        psk=&quot;987654321&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>        priority=35</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;HHHSY&quot;</p>
<p>        psk=&quot;88888888&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>        priority=52</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;ok16888&quot;</p>
<p>        psk=&quot;12345678&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>        disabled=1</p>
<p>}</p>
<p>network={</p>
<p>        ssid=&quot;ChinaNet-VKdC&quot;</p>
<p>        psk=&quot;12345678&quot;</p>
<p>        key_mgmt=WPA-PSK</p>
<p>        priority=67</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>wifi调试</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/wifi%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>lsmod</p>
<p>cd system/lib/modules</p>
<p>insmod 8723au.ko</p>
<p>netcfg</p>
<p>ifconfig wlan0 up</p>
<p>iwlist wlan0 scan</p>
<p>rmmod wlan</p>
<p>rm /data/misc/wifi/wifi_chip_type</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>wifi打开，settings switch 马上点亮</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/wifi%E6%89%93%E5%BC%80%EF%BC%8Csettings%20switch%20%E9%A9%AC%E4%B8%8A%E7%82%B9%E4%BA%AE/</url>
    <content><![CDATA[<p>packages/apps/Settings/src/com/android/settings/wifi/WifiEnabler.java</p>
<p>@@ -129,7 +129,8 @@ public class WifiEnabler implements CompoundButton.OnCheckedChangeListener  {</p>
<p>     private void handleWifiStateChanged(int state) {</p>
<p>         switch (state) {</p>
<p>             case WifiManager.WIFI_STATE_ENABLING:</p>
<ul>
<li>               mSwitch.setEnabled(false);</li>
</ul>
<ul>
<li><p>               setSwitchChecked(true);</p>
</li>
<li><p>               mSwitch.setEnabled(true);</p>
</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>windows下编译及使用libevent</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BD%BF%E7%94%A8libevent/</url>
    <content><![CDATA[<p>windows下编译及使用libevent</p>
<p>Libevent官网：<a href="http://libevent.org/">http://libevent.org/</a></p>
<p>windows 7下编译：</p>
<p>编译环境： windows 7 + VS2010</p>
<p>（1）解压libevent到F:\libevent\libevent-2.0.21-stable</p>
<p>（2）打开Microsoft visual studio 2010命令行工具</p>
<p>（3）修改以下三个文件，添加宏定义：</p>
<p>在以下3个文件开头添加“#define _WIN32_WINNT 0x0500”</p>
<p>libevent-2.0.21-stable\event_iocp.c</p>
<p>libevent-2.0.21-stable\evthread_win32.c</p>
<p>libevent-2.0.21-stable\listener.c</p>
<p>（4）使用VS命令提示工具编译：</p>
<p>cd/d F:\libevent\libevent-2.0.21-stable</p>
<p>nmake /f Makefile.nmake</p>
<p>（5）编译结果：</p>
<p>libevent_core.lib：All core event and buffer functionality. This library contains all the event_base, evbuffer, bufferevent, and utility functions.</p>
<p>libevent_extras.lib：This library defines protocol-specific functionality that you may or may not want for your application, including HTTP, DNS, and RPC.</p>
<p>libevent.lib：This library exists for historical reasons; it contains the contents of both libevent_core and libevent_extra. You shouldn’t use it; it may go away in a future version of Libevent.</p>
<p>（6）VS2010下使用lib</p>
<p>新建一个VC++控制台项目：</p>
<p>环境配置：</p>
<p>项目下建一个Lib目录，将上面三个lib文件copy到该目录下。</p>
<p>新建一个Include目录，将F:\libevent\libevent-2.0.21-stable\include下的文件和文件夹copy到该目录下，F:\libevent\libevent-2.0.21-stable\WIN32-Code下的文件copy到该目录下，2个event2目录下的文件可合并一起。</p>
<p>main代码：</p>
<p>// LibeventTest.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#ifndef WIN32<br>#include &lt;netinet/in.h&gt;# ifdef _XOPEN_SOURCE_EXTENDED</p>
<h1 id="include-lt-arpa-inet-h-gt-endif"><a href="#include-lt-arpa-inet-h-gt-endif" class="headerlink" title="include &lt;arpa/inet.h&gt;# endif"></a>include &lt;arpa/inet.h&gt;# endif</h1><p>#include &lt;sys/socket.h&gt;#endif#include &quot;event2/bufferevent.h&quot;#include &quot;event2/buffer.h&quot;#include &quot;event2/listener.h&quot;#include &quot;event2/util.h&quot;#include &quot;event2/event.h&quot;#include &lt;WinSock2.h&gt;static const char MESSAGE[] = &quot;Hello, World!\n&quot;;static const int PORT = 9995;static void conn_writecb(struct bufferevent <em>bev, void <em>user_data)<br>{<br>    struct evbuffer *output = bufferevent_get_output(bev);<br>    if (evbuffer_get_length(output) == 0)<br>    {<br>        printf(&quot;flushed answer\n&quot;);<br>        bufferevent_free(bev);<br>    }<br>}static void conn_eventcb(struct bufferevent *bev, short events, void *user_data)<br>{<br>    if (events &amp; BEV_EVENT_EOF)<br>    {<br>        printf(&quot;Connection closed.\n&quot;);<br>    }<br>    else if (events &amp; BEV_EVENT_ERROR)<br>    {<br>        printf(&quot;Got an error on the connection: %s\n&quot;,<br>            strerror(errno));/*XXX win32</em>/<br>    }<br>    /</em> None of the other events can happen here, since we haven’t enabled<br>     * timeouts */<br>    bufferevent_free(bev);<br>}static void signal_cb(evutil_socket_t sig, short events, void *user_data)<br>{<br>    struct event_base *base = (struct event_base *)user_data;<br>    struct timeval delay = { 2, 0 };</p>
<p>    printf(&quot;Caught an interrupt signal; exiting cleanly in two seconds.\n&quot;);</p>
<p>    event_base_loopexit(base, &amp;delay);<br>}static void listener_cb(struct evconnlistener *listener, evutil_socket_t fd,<br>    struct sockaddr *sa, int socklen, void *user_data)<br>{<br>    struct event_base *base = (struct event_base *)user_data;<br>    struct bufferevent *bev;</p>
<p>    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);<br>    if (!bev)<br>    {<br>        fprintf(stderr, &quot;Error constructing bufferevent!&quot;);<br>        event_base_loopbreak(base);<br>        return;<br>    }<br>    bufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL);<br>    bufferevent_enable(bev, EV_WRITE);<br>    bufferevent_disable(bev, EV_READ);</p>
<p>    bufferevent_write(bev, MESSAGE, strlen(MESSAGE));<br>}int main(int argc, char **argv)<br>{<br>    struct event_base *base;<br>    struct evconnlistener *listener;<br>    struct event *signal_event;</p>
<p>    struct sockaddr_in sin;</p>
<p>#ifdef WIN32<br>    WSADATA wsa_data;<br>    WSAStartup(0x0201, &amp;wsa_data);#endif</p>
<pre><code>base = event_base_new();</code></pre>
<p>    if (!base)<br>    {<br>        fprintf(stderr, &quot;Could not initialize libevent!\n&quot;);<br>        return 1;<br>    }</p>
<p>    memset(&amp;sin, 0, sizeof(sin));<br>    sin.sin_family = AF_INET;<br>    sin.sin_port = htons(PORT);</p>
<p>    listener = evconnlistener_new_bind(base, listener_cb, (void <em>)base,<br>        LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1,<br>        (struct sockaddr</em>)&amp;sin,<br>        sizeof(sin));</p>
<p>    if (!listener)<br>    {<br>        fprintf(stderr, &quot;Could not create a listener!\n&quot;);<br>        return 1;<br>    }</p>
<p>    signal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base);</p>
<p>    if (!signal_event || event_add(signal_event, NULL)&lt;0)<br>    {<br>        fprintf(stderr, &quot;Could not create/add a signal event!\n&quot;);<br>        return 1;<br>    }</p>
<p>    event_base_dispatch(base);</p>
<p>    evconnlistener_free(listener);<br>    event_free(signal_event);<br>    event_base_free(base);</p>
<p>    printf(&quot;done\n&quot;);<br>    return 0;<br>}</p>
<p>项目属性设置：</p>
<p>VC++目录：</p>
<p>包含目录，添加：F:\Projects\LibeventTest\LibeventTest\Include;</p>
<p>库目录，添加：F:\Projects\LibeventTest\LibeventTest\Lib;</p>
<p>C/C++：</p>
<p>代码生成–&gt;运行库：多线程调试 (/MTd)（Debug下），多线程 (/MT)（Release下）</p>
<p>连接器：</p>
<p>输入：ws2_32.lib;wsock32.lib;libevent.lib;libevent_core.lib;libevent_extras.lib;</p>
<p>ws2_32.lib;wsock32.lib;是用来编译Windows网络相关的程序库。</p>
<p>编译，生成！</p>
<p>编译好的libevent lib下载 Libevent2.0.21.rar</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>www</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/www.javaapk.comdemo/</url>
    <content><![CDATA[<p><a href="http://www.javaapk.com/demo">http://www.javaapk.com/demo</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>xampp mysql 重置密码</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/xampp%20mysql%20%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>安装使用xampp，装好后root默认没有密码，phpmyadmin是用config文件进行连接的，鉴于安全性我决定给root加个密码，在知道如何进入mysql后如何修改密码非常简单，在此不多废话，主要我是刚接触xampp，结果把密码搞乱了，无论如何进不去，无奈，在网上查阅各种资料，终于找到如何在不知道密码的情况下进入mysql数据修改root密码，其实网上的方法很多，但是主要都有那么一两点没说清楚，在此我把自己用的方法记录下来，一是方便以后查阅，而是希望可以帮助那些跟我有同样遭遇的同仁们。</p>
<p>详细步骤如下，其实也只是从别处拷过来稍作修改：</p>
<p>1.  停止mysql：用图形化工具或者在cmd命令下输入net stop mysql，在c盘根目录下输入</p>
<p>2.  打开cmd，切换目录到 /xampp/mysql/bin, 运行</p>
<p> mysqld –skip-grant-tables</p>
<p> 这条命令是跳过权限检查启动mysql服务</p>
<p>输完后enter这个窗口进入无法操作状态，保持这个窗口别关闭</p>
<ol start="3">
<li>打开另一个cmd，同样切换目录到 /xampp/mysql/bin，运行</li>
</ol>
<p> mysql –u root</p>
<p> 用root登录到数据库</p>
<ol start="4">
<li>修改root的密码</li>
</ol>
<p> &gt;use mysql<br> &gt;update user set password=PASSWORD(’新密码’) where user=’root’<br> &gt;flush privileges</p>
<p>完成修改，最好每一步都要严格这么做，几个注意问题：一定要先停止mysql在进行这一系列操作，二是注意命令的完整性，比如空格，几个-等细节，一定要用那个PASSWORD函数，否则你输入的是加密后的，原始密码不是你输入的，用这个函数你输入的密码就是为经过加密的原密码，就可以用你输入的密码登录，三是修改完密码后一定要输入flush privileges，否则修改不会被保存。</p>
<p>希望可以帮助到碰到同样问题的人。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>zip解压缩</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/zip%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>/**</p>
<p>     * 解压缩一个文件</p>
<p>     *</p>
<p>     * @param zipFile 压缩文件</p>
<p>     * @param folderPath 解压缩的目标目录</p>
<p>     * @throws IOException 当解压缩过程出错时抛出</p>
<p>     */</p>
<p>    public static void upZipFile(File zipFile, String folderPath) </p>
<p>throws ZipException, IOException {</p>
<p>        File desDir = new File(folderPath);</p>
<p>        if (!desDir.exists()) {</p>
<p>            desDir.mkdirs();</p>
<p>        }</p>
<p>        ZipFile zf = new ZipFile(zipFile);</p>
<p>        for (Enumeration&lt;?&gt; entries = zf.entries(); </p>
<p>entries.hasMoreElements();) {</p>
<p>            ZipEntry entry = ((ZipEntry)entries.nextElement());</p>
<p>            InputStream in = zf.getInputStream(entry);</p>
<p>            String str = folderPath + File.separator + entry.getName();</p>
<p>str = new String(str.getBytes(&quot;8859_1&quot;), &quot;utf-8&quot;);</p>
<p>            File desFile = new File(str);</p>
<p>            if (!desFile.exists()) {</p>
<p>                File fileParentDir = desFile.getParentFile();</p>
<p>                if (!fileParentDir.exists()) {</p>
<p>                    fileParentDir.mkdirs();</p>
<p>                }</p>
<p>                desFile.createNewFile();</p>
<p>            }</p>
<p>            OutputStream out = new FileOutputStream(desFile);</p>
<p>            byte buffer[] = new byte[1024*10];</p>
<p>            int realLength;</p>
<p>            while ((realLength = in.read(buffer)) &gt; 0) {</p>
<p>                out.write(buffer, 0, realLength);</p>
<p>            }</p>
<p>            in.close();</p>
<p>            out.close();</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>“+”号的优先级  移位</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E2%80%9C+%E2%80%9D%E5%8F%B7%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%20%20%E7%A7%BB%E4%BD%8D/</url>
    <content><![CDATA[<p>0x01&lt;&lt;2+3  的值为多少</p>
<p> 1）在位移运算符计算时应注意运算符的优先级</p>
<p>         0x01&lt;&lt;2+3；<br>结果为7 吗？测试一下。结果为32？别惊讶，32 才是正确答案。因 </p>
<p>为“+”号的优先级比移位运算符的优先级高</p>
<p>     2）左移和右移的位数不能大于数据的长度，不能小于0</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>下载Android 内核</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%B8%8B%E8%BD%BDAndroid%20%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<ol>
<li>git clone <a href="https://android.googlesource.com/kernel/samsung.git">https://android.googlesource.com/kernel/samsung.git</a>  生成samsung文件夹</li>
</ol>
<p>开源的内核</p>
<p>$ git clone <a href="https://android.googlesource.com/kernel/common.git">https://android.googlesource.com/kernel/common.git</a></p>
<p>$ git clone <a href="https://android.googlesource.com/kernel/goldfish.git">https://android.googlesource.com/kernel/goldfish.git</a></p>
<p>$ git clone <a href="https://android.googlesource.com/kernel/msm.git">https://android.googlesource.com/kernel/msm.git</a></p>
<p>$ git clone <a href="https://android.googlesource.com/kernel/omap.git">https://android.googlesource.com/kernel/omap.git</a></p>
<p>$ git clone <a href="https://android.googlesource.com/kernel/samsung.git">https://android.googlesource.com/kernel/samsung.git</a></p>
<p>$ git clone <a href="https://android.googlesource.com/kernel/tegra.git">https://android.googlesource.com/kernel/tegra.git</a></p>
<ol start="2">
<li>cd samsung </li>
</ol>
<p>   git branch -a  查看所有版本，包括远程版本</p>
<ul>
<li>master</li>
</ul>
<p>  remotes/origin/HEAD -&gt; origin/master</p>
<p>  remotes/origin/android-samsung-2.6.35-gingerbread</p>
<p>  remotes/origin/android-samsung-3.0-ics-mr1</p>
<p>  remotes/origin/android-samsung-3.0-jb</p>
<p>  remotes/origin/android-samsung-3.0-jb-mr0</p>
<p>  remotes/origin/master</p>
<p>git checkout -b samsung3.0_jb remotes/origin/android-samsung-3.0-jb-mr0  把需要的版本checkout出来</p>
<p>这样就在本地产生samsung3.0_jb  分支了</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>下载Android 源码</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%B8%8B%E8%BD%BDAndroid%20%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>1.初始化repo环境</p>
<p>$ mkdir ~/bin</p>
<p>$ PATH=~/bin:$PATH</p>
<p>$ curl <a href="https://dl-ssl.google.com/dl/googlesource/git-repo/repo">https://dl-ssl.google.com/dl/googlesource/git-repo/repo</a> &gt; ~/bin/repo</p>
<p>$ chmod a+x ~/bin/repo</p>
<ol start="2">
<li>同步repo工程</li>
</ol>
<p>$ mkdir WORKING_DIRECTORY</p>
<p>$ cd WORKING_DIRECTORY</p>
<p>$ repo init -u <a href="https://android.googlesource.com/platform/manifest">https://android.googlesource.com/platform/manifest</a> -b android-4.0.3_r1</p>
<p>// authentication</p>
<p>$ repo init -u <a href="https://android.googlesource.com/a/platform/manifest">https://android.googlesource.com/a/platform/manifest</a> -b android-4.0.3_r1</p>
<p>$ repo sync</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>世界语言列表 Language Code Table</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%B8%96%E7%95%8C%E8%AF%AD%E8%A8%80%E5%88%97%E8%A1%A8%20Language%20Code%20Table/</url>
    <content><![CDATA[<p> Language Code Table </p>
<p>    语言代码         语言名称 </p>
<p>    af           南非语 </p>
<p>    af-ZA        南非语 </p>
<p>    ar           阿拉伯语 </p>
<p>    ar-AE        阿拉伯语(阿联酋) </p>
<p>    ar-BH        阿拉伯语(巴林) </p>
<p>    ar-DZ        阿拉伯语(阿尔及利亚) </p>
<p>    ar-EG        阿拉伯语(埃及) </p>
<p>    ar-IQ        阿拉伯语(伊拉克) </p>
<p>    ar-JO        阿拉伯语(约旦) </p>
<p>    ar-KW        阿拉伯语(科威特) </p>
<p>    ar-LB        阿拉伯语(黎巴嫩) </p>
<p>    ar-LY        阿拉伯语(利比亚) </p>
<p>    ar-MA        阿拉伯语(摩洛哥) </p>
<p>    ar-OM        阿拉伯语(阿曼) </p>
<p>    ar-QA        阿拉伯语(卡塔尔) </p>
<p>    ar-SA        阿拉伯语(沙特阿拉伯) </p>
<p>    ar-SY        阿拉伯语(叙利亚) </p>
<p>    ar-TN        阿拉伯语(突尼斯) </p>
<p>    ar-YE        阿拉伯语(也门) </p>
<p>    az           阿塞拜疆语 </p>
<p>    az-AZ        阿塞拜疆语(拉丁文) </p>
<p>    az-AZ        阿塞拜疆语(西里尔文) </p>
<p>    be           比利时语 </p>
<p>    be-BY        比利时语 </p>
<p>    bg           保加利亚语 </p>
<p>    bg-BG        保加利亚语 </p>
<p>    bs-BA        波斯尼亚语(拉丁文，波斯尼亚和黑塞哥维那) </p>
<p>    ca           加泰隆语 </p>
<p>    ca-ES        加泰隆语 </p>
<p>    cs           捷克语 </p>
<p>    cs-CZ        捷克语 </p>
<p>    cy           威尔士语 </p>
<p>    cy-GB        威尔士语 </p>
<p>    da           丹麦语 </p>
<p>    da-DK        丹麦语 </p>
<p>    de           德语 </p>
<p>    de-AT        德语(奥地利) </p>
<p>    de-CH        德语(瑞士) </p>
<p>    de-DE        德语(德国) </p>
<p>    de-LI        德语(列支敦士登) </p>
<p>    de-LU        德语(卢森堡) </p>
<p>    dv           第维埃语 </p>
<p>    dv-MV        第维埃语 </p>
<p>    el           希腊语 </p>
<p>    el-GR        希腊语 </p>
<p>    en           英语 </p>
<p>    en-AU        英语(澳大利亚) </p>
<p>    en-BZ        英语(伯利兹) </p>
<p>    en-CA        英语(加拿大) </p>
<p>    en-CB        英语(加勒比海) </p>
<p>    en-GB        英语(英国) </p>
<p>    en-IE        英语(爱尔兰) </p>
<p>    en-JM        英语(牙买加) </p>
<p>    en-NZ        英语(新西兰) </p>
<p>    en-PH        英语(菲律宾) </p>
<p>    en-TT        英语(特立尼达) </p>
<p>    en-US        英语(美国) </p>
<p>    en-ZA        英语(南非) </p>
<p>    en-ZW        英语(津巴布韦) </p>
<p>    eo           世界语 </p>
<p>    es           西班牙语 </p>
<p>    es-AR        西班牙语(阿根廷) </p>
<p>    es-BO        西班牙语(玻利维亚) </p>
<p>    es-CL        西班牙语(智利) </p>
<p>    es-CO        西班牙语(哥伦比亚) </p>
<p>    es-CR        西班牙语(哥斯达黎加) </p>
<p>    es-DO        西班牙语(多米尼加共和国) </p>
<p>    es-EC        西班牙语(厄瓜多尔) </p>
<p>    es-ES        西班牙语(传统) </p>
<p>    es-ES        西班牙语(国际) </p>
<p>    es-GT        西班牙语(危地马拉) </p>
<p>    es-HN        西班牙语(洪都拉斯) </p>
<p>    es-MX        西班牙语(墨西哥) </p>
<p>    es-NI        西班牙语(尼加拉瓜) </p>
<p>    es-PA        西班牙语(巴拿马) </p>
<p>    es-PE        西班牙语(秘鲁) </p>
<p>    es-PR        西班牙语(波多黎各(美)) </p>
<p>    es-PY        西班牙语(巴拉圭) </p>
<p>    es-SV        西班牙语(萨尔瓦多) </p>
<p>    es-UY        西班牙语(乌拉圭) </p>
<p>    es-VE        西班牙语(委内瑞拉) </p>
<p>    et           爱沙尼亚语 </p>
<p>    et-EE        爱沙尼亚语 </p>
<p>    eu           巴士克语 </p>
<p>    eu-ES        巴士克语 </p>
<p>    fa           法斯语 </p>
<p>    fa-IR        法斯语 </p>
<p>    fi           芬兰语 </p>
<p>    fi-FI        芬兰语 </p>
<p>    fo           法罗语 </p>
<p>    fo-FO        法罗语 </p>
<p>    fr           法语 </p>
<p>    fr-BE        法语(比利时) </p>
<p>    fr-CA        法语(加拿大) </p>
<p>    fr-CH        法语(瑞士) </p>
<p>    fr-FR        法语(法国) </p>
<p>    fr-LU        法语(卢森堡) </p>
<p>    fr-MC        法语(摩纳哥) </p>
<p>    gl           加里西亚语 </p>
<p>    gl-ES        加里西亚语 </p>
<p>    gu           古吉拉特语 </p>
<p>    gu-IN        古吉拉特语 </p>
<p>    he           希伯来语 </p>
<p>    he-IL        希伯来语 </p>
<p>    hi           印地语 </p>
<p>    hi-IN        印地语 </p>
<p>    hr           克罗地亚语 </p>
<p>    hr-BA        克罗地亚语(波斯尼亚和黑塞哥维那) </p>
<p>    hr-HR        克罗地亚语 </p>
<p>    hu           匈牙利语 </p>
<p>    hu-HU        匈牙利语 </p>
<p>    hy           亚美尼亚语 </p>
<p>    hy-AM        亚美尼亚语 </p>
<p>    id           印度尼西亚语 </p>
<p>    id-ID        印度尼西亚语 </p>
<p>    is           冰岛语 </p>
<p>    is-IS        冰岛语 </p>
<p>    it           意大利语 </p>
<p>    it-CH        意大利语(瑞士) </p>
<p>    it-IT        意大利语(意大利) </p>
<p>    ja           日语 </p>
<p>    ja-JP        日语 </p>
<p>    ka           格鲁吉亚语 </p>
<p>    ka-GE        格鲁吉亚语 </p>
<p>    kk           哈萨克语 </p>
<p>    kk-KZ        哈萨克语 </p>
<p>    kn           卡纳拉语 </p>
<p>    kn-IN        卡纳拉语 </p>
<p>    ko           朝鲜语 </p>
<p>    ko-KR        朝鲜语 </p>
<p>    kok          孔卡尼语 </p>
<p>    kok-IN       孔卡尼语 </p>
<p>    ky           吉尔吉斯语 </p>
<p>    ky-KG        吉尔吉斯语(西里尔文) </p>
<p>    lt           立陶宛语 </p>
<p>    lt-LT        立陶宛语 </p>
<p>    lv           拉脱维亚语 </p>
<p>    lv-LV        拉脱维亚语 </p>
<p>    mi           毛利语 </p>
<p>    mi-NZ        毛利语 </p>
<p>    mk           马其顿语 </p>
<p>    mk-MK        马其顿语(FYROM) </p>
<p>    mn           蒙古语 </p>
<p>    mn-MN        蒙古语(西里尔文) </p>
<p>    mr           马拉地语 </p>
<p>    mr-IN        马拉地语 </p>
<p>    ms           马来语 </p>
<p>    ms-BN        马来语(文莱达鲁萨兰) </p>
<p>    ms-MY        马来语(马来西亚) </p>
<p>    mt           马耳他语 </p>
<p>    mt-MT        马耳他语 </p>
<p>    nb           挪威语(伯克梅尔) </p>
<p>    nb-NO        挪威语(伯克梅尔)(挪威) </p>
<p>    nl           荷兰语 </p>
<p>    nl-BE        荷兰语(比利时) </p>
<p>    nl-NL        荷兰语(荷兰) </p>
<p>    nn-NO        挪威语(尼诺斯克)(挪威) </p>
<p>    ns           北梭托语 </p>
<p>    ns-ZA        北梭托语 </p>
<p>    pa           旁遮普语 </p>
<p>    pa-IN        旁遮普语 </p>
<p>    pl           波兰语 </p>
<p>    pl-PL        波兰语 </p>
<p>    pt           葡萄牙语 </p>
<p>    pt-BR        葡萄牙语(巴西) </p>
<p>    pt-PT        葡萄牙语(葡萄牙) </p>
<p>    qu           克丘亚语 </p>
<p>    qu-BO        克丘亚语(玻利维亚) </p>
<p>    qu-EC        克丘亚语(厄瓜多尔) </p>
<p>    qu-PE        克丘亚语(秘鲁) </p>
<p>    ro           罗马尼亚语 </p>
<p>    ro-RO        罗马尼亚语 </p>
<p>    ru           俄语 </p>
<p>    ru-RU        俄语 </p>
<p>    sa           梵文 </p>
<p>    sa-IN        梵文 </p>
<p>    se           北萨摩斯语 </p>
<p>    se-FI        北萨摩斯语(芬兰) </p>
<p>    se-FI        斯科特萨摩斯语(芬兰) </p>
<p>    se-FI        伊那里萨摩斯语(芬兰) </p>
<p>    se-NO        北萨摩斯语(挪威) </p>
<p>    se-NO        律勒欧萨摩斯语(挪威) </p>
<p>    se-NO        南萨摩斯语(挪威) </p>
<p>    se-SE        北萨摩斯语(瑞典) </p>
<p>    se-SE        律勒欧萨摩斯语(瑞典) </p>
<p>    se-SE        南萨摩斯语(瑞典) </p>
<p>    sk           斯洛伐克语 </p>
<p>    sk-SK        斯洛伐克语 </p>
<p>    sl           斯洛文尼亚语 </p>
<p>    sl-SI        斯洛文尼亚语 </p>
<p>    sq           阿尔巴尼亚语 </p>
<p>    sq-AL        阿尔巴尼亚语 </p>
<p>    sr-BA        塞尔维亚语(拉丁文，波斯尼亚和黑塞哥维那) </p>
<p>    sr-BA        塞尔维亚语(西里尔文，波斯尼亚和黑塞哥维那) </p>
<p>    sr-SP        塞尔维亚(拉丁) </p>
<p>    sr-SP        塞尔维亚(西里尔文) </p>
<p>    sv           瑞典语 </p>
<p>    sv-FI        瑞典语(芬兰) </p>
<p>    sv-SE        瑞典语 </p>
<p>    sw           斯瓦希里语 </p>
<p>    sw-KE        斯瓦希里语 </p>
<p>    syr          叙利亚语 </p>
<p>    syr-SY       叙利亚语 </p>
<p>    ta           泰米尔语 </p>
<p>    ta-IN        泰米尔语 </p>
<p>    te           泰卢固语 </p>
<p>    te-IN        泰卢固语 </p>
<p>    th           泰语 </p>
<p>    th-TH        泰语 </p>
<p>    tl           塔加路语 </p>
<p>    tl-PH        塔加路语(菲律宾) </p>
<p>    tn           茨瓦纳语 </p>
<p>    tn-ZA        茨瓦纳语 </p>
<p>    tr           土耳其语 </p>
<p>    tr-TR        土耳其语 </p>
<p>    ts           宗加语 </p>
<p>    tt           鞑靼语 </p>
<p>    tt-RU        鞑靼语 </p>
<p>    uk           乌克兰语 </p>
<p>    uk-UA        乌克兰语 </p>
<p>    ur           乌都语 </p>
<p>    ur-PK        乌都语 </p>
<p>    uz           乌兹别克语 </p>
<p>    uz-UZ        乌兹别克语(拉丁文) </p>
<p>    uz-UZ        乌兹别克语(西里尔文) </p>
<p>    vi           越南语 </p>
<p>    vi-VN        越南语 </p>
<p>    xh           班图语 </p>
<p>    xh-ZA        班图语 </p>
<p>    zh           中文 </p>
<p>     zh-CN           中文(简体) </p>
<p>     zh-HK           中文(香港) </p>
<p>     zh-MO           中文(澳门) </p>
<p>     zh-SG           中文(新加坡) </p>
<p>     zh-TW           中文(繁体) </p>
<p>     zu              祖鲁语 </p>
<p>     zu-ZA           祖鲁语 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>中断apt-get  后</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%B8%AD%E6%96%ADapt-get%20%20%E5%90%8E/</url>
    <content><![CDATA[<p>Could not get lock /var/lib/dpkg/lock</p>
<p>关闭一切安装/卸载/更新软件的进程<br>sudo pkill dpkg<br>然后解锁<br>sudo rm  /var/lib/dpkg/lock</p>
<p>以下为操作 deb 包的常用 Dpkg 指令表<br>命令和作用<br>dpkg -i package.deb 安装包<br>dpkg -r package 删除包<br>dpkg -P package 删除包（包括配置文件）<br>dpkg -L package 列出与该包关联的文件<br>dpkg -l package 显示该包的版本<br>dpkg –unpack package.deb 解开 deb 包的内容<br>dpkg -S keyword 搜索所属的包内容<br>dpkg -l 列出当前已安装的包<br>dpkg -c package.deb 列出 deb 包的内容<br>dpkg –configure package 配置包</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>串口、COM口、TTL、RS-232、RS-485区别</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%B8%B2%E5%8F%A3%E3%80%81COM%E5%8F%A3%E3%80%81TTL%E3%80%81RS-232%E3%80%81RS-485%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>    1、串口、COM口是指的物理接口形式(硬件)。而TTL、RS-232、RS-485是指的电平标准(电信号)。<br>    2、接设备的时候，一般只接GND RX TX。不会接Vcc或者+3.3v的电源线，避免与目标设备上的供电冲突。<br>    3、PL2303、CP2102芯片是 USB 转 TTL串口 的芯片，用USB来扩展串口(TTL电平)。<br>    4、MAX232芯片是 TTL电平与RS232电平的专用双向转换芯片，可以TTL转RS-232，也可以RS-232转TTL。<br>    5、TTL标准是低电平为0，高电平为1(+5V电平)。RS-232标准是正电平为0，负电平为1(±15V电平)。<br>    6、RS-485与RS-232类似，但是采用差分信号负逻辑。这里略过不讲。</p>
<p>串口、COM口：<br>    COM口即串行通讯端口，简称串口。这里区别于USB的“通用串行总线”和硬盘的“SATA”。<br>    一般我们见到的是两种物理标准。D型9针插头，和 4针杜邦头两种。<br>    这是常见的4针串口，在电路板上常见，经常上边还带有杜邦插针。还有时候有第五根针，3.3V电源端。<br>    由于是预留在电路板上的，协议可以有很多种，要看具体设备。</p>
<p>    下面这个就是D型9针串口(通俗说法)。在台式电脑后边都可以看到。<br>    记住，这种接口的协议只有两种：RS-232和RS-485。不会是TTL电平的(除非特殊应用)。<br>    9针串口的定义可以参考这里：<a href="http://wenku.baidu.com/view/5c170c6925c52cc58bd6be6e.html">http://wenku.baidu.com/view/5c170c6925c52cc58bd6be6e.html</a><br>    我们一般只接出RXD TXD两针，外加GND。</p>
<p>    下图是个USB转TTL串口的小板，可以用USB扩展出一个串口。芯片为PL2303HX。<br>    网上经常混淆各种串口，但是这个确实是可以给STC单片机下载程序的。</p>
<p>    这是另一种，CP2102芯片的，也是USB转TTL串口。据说比PL2303的好，实际使用中没感觉出来。这个小板就多了+3.3V电源端，以适应不同的目标电路。</p>
<p>    上边介绍的都是USB转TTL串口，如果目标设备上是RS-232串口(D型9针接口)咋弄?<br>    再接一片MAX232转换一下就行。<br>    你也可以搭一个简单的比较器电路，来实现TTL转RS-232的功能，如下图。</p>
<p>    RS-232转TTL咋弄?这就需要你动点脑子咯。当然，早有人想到了做一款成品。仔细看下图，USB经过PL2303转成了TTL串口，中间四个窟窿可以引出，再经MAX232转换为RS-232电平，9针串口引出。</p>
<p>    下面这是另一款：电平转换依旧用的是MAX232。</p>
<p>    你或许会买到这种：看起来里边只有一个牛屎芯片的。<br>    但是记住一点，只要是 D型9针串口，不会是TTL电平的，没特殊说明就默认是RS-232。<br>    所以这根线，不管里边构造怎样的，是 USB转RS-232串口 的线。<br>    想要强调的是，一个设备的串口可以根据引出的串口线来判断是TTL还是RS-232，从而决定链接方式以及是否需要转换电路。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>优秀是一种习惯。</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%BC%98%E7%A7%80%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B9%A0%E6%83%AF%E3%80%82/</url>
    <content><![CDATA[<p>认真是一种态度，坚持是一种品格，优秀是一种习惯。 </p>
<p> 学无止境 。  冲动是魔鬼。  海纳百川，有容乃大。  态度决定一切。  逆水行舟，不进则退。 </p>
<hr>
<p>学习：</p>
<p><a href="http://www.cnblogs.com/leaven/p/3465783.html">http://www.cnblogs.com/leaven/p/3465783.html</a></p>
<p>input </p>
<p>OpenGL</p>
<p>repo server</p>
<p><a href="http://www.360doc.com/content/13/1217/10/14797374_337803876.shtml">http://www.360doc.com/content/13/1217/10/14797374_337803876.shtml</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>信号 基站</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%BF%A1%E5%8F%B7%20%E5%9F%BA%E7%AB%99/</url>
    <content><![CDATA[<p>通过TelephonyManager 获取lac:mcc:mnc:cell-id（基站信息）的解释：<br> MCC，Mobile Country Code，移动国家代码（中国的为460）；<br> MNC，Mobile Network Code，移动网络号码（中国移动为0，中国联通为1，中国电信为2）； <br> LAC，Location Area Code，位置区域码；<br> CID，Cell Identity，基站编号；<br> BSSS，Base station signal strength，基站信号强度。</p>
<p>二，获取手机卡基站信息（前提需要有手机卡，模拟器无法实现）：</p>
<p>[java] view plaincopy</p>
<p>/** </p>
<p> * 获取手机基站信息 </p>
<p> * @throws JSONException  </p>
<p> */  </p>
<p>public void getGSMCellLocationInfo() throws JSONException{  </p>
<p>    TelephonyManager manager = (TelephonyManager) mAppMain.getSystemService(Context.TELEPHONY_SERVICE);  </p>
<p>    String operator = manager.getNetworkOperator();  </p>
<p>/**通过operator获取 MCC 和MNC */  </p>
<p>int mcc = Integer.parseInt(operator.substring(0, 3));  </p>
<p>int mnc = Integer.parseInt(operator.substring(3));  </p>
<p>    GsmCellLocation location = (GsmCellLocation) manager.getCellLocation();  </p>
<p>/**通过GsmCellLocation获取中国移动和联通 LAC 和cellID */  </p>
<p>int lac = location.getLac();  </p>
<p>int cellid = location.getCid();  </p>
<p>/**通过CdmaCellLocation获取中国电信 LAC 和cellID */  </p>
<p>      &lt;span style=&quot;white-space:pre&quot;&gt;        &lt;/span&gt; /*CdmaCellLocation location1 = (CdmaCellLocation) mTelephonyManager.getCellLocation();  </p>
<p>       &lt;span style=&quot;white-space:pre&quot;&gt;   &lt;/span&gt; lac = location1.getNetworkId();  </p>
<p>      &lt;span style=&quot;white-space:pre&quot;&gt;        &lt;/span&gt; cellId = location1.getBaseStationId();  </p>
<p>      &lt;span style=&quot;white-space:pre&quot;&gt;        &lt;/span&gt; cellId /= 16;*/    </p>
<p>int strength = 0;  </p>
<p>/**通过getNeighboringCellInfo获取BSSS */  </p>
<p>    List&lt;NeighboringCellInfo&gt; infoLists = manager.getNeighboringCellInfo();  </p>
<p>    System.out.println(&quot;infoLists:&quot;+infoLists+&quot;     size:&quot;+infoLists.size());  </p>
<p>for (NeighboringCellInfo info : infoLists) {  </p>
<p>        strength+=(-133+2*info.getRssi());// 获取邻区基站信号强度    </p>
<p>//info.getLac();// 取出当前邻区的LAC   </p>
<p>//info.getCid();// 取出当前邻区的CID   </p>
<p>        System.out.println(&quot;rssi:&quot;+info.getRssi()+&quot;   strength:&quot;+strength);  </p>
<p>    }  </p>
<p>//以下内容是把得到的信息组合成json体，然后发送给我的服务器，获取经纬度信息  </p>
<p>[java] view plaincopy</p>
<p>&lt;span style=&quot;white-space:pre&quot;&gt;      &lt;/span&gt;//如果你没有服务器支持，可以发送给BaiduMap，GoogleMap等地图服务商，具体看定位相关的API格式要求  </p>
<p>        JSONObject item = new JSONObject();  </p>
<p>        item.put(&quot;cid&quot;, cellid);  </p>
<p>        item.put(&quot;lac&quot;, lac);  </p>
<p>        item.put(&quot;mnc&quot;, mnc);  </p>
<p>        item.put(&quot;mcc&quot;, mcc);  </p>
<p>        item.put(&quot;strength&quot;, strength);  </p>
<p>        JSONArray cells = new JSONArray();  </p>
<p>        cells.put(0, item);  </p>
<p>        JSONObject json = new JSONObject();  </p>
<p>        json.put(&quot;cells&quot;, cells);  </p>
<p>        CellLocationTask task = new CellLocationTask(json);  </p>
<p>        task.execute();  </p>
<p>    }  </p>
<p>三，通过基站信息，请求获取经纬度<br>CellLocationTask</p>
<p>[java] view plaincopy</p>
<p>/** </p>
<p> * 异步请求，通过封装的手机基站信息json体 </p>
<p> * @author Administrator </p>
<p> * </p>
<p> */  </p>
<p>class CellLocationTask extends AsyncTask&lt;String, Void, String&gt;{  </p>
<p>private JSONObject mJson;  </p>
<p>private HttpClient mClient;  </p>
<p>private HttpResponse response;  </p>
<p>private String responseString;  </p>
<p>public CellLocationTask(JSONObject json) {  </p>
<p>this.mJson = json;  </p>
<p>    }  </p>
<p>@Override  </p>
<p>protected void onPreExecute() {  </p>
<p>super.onPreExecute();  </p>
<p>        mClient = new DefaultHttpClient();  </p>
<p>        mClient.getParams().setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 15000);  </p>
<p>        mClient.getParams().setParameter(CoreConnectionPNames.SO_TIMEOUT, 15000);  </p>
<p>    }  </p>
<p>@Override  </p>
<p>protected String doInBackground(String… params) {  </p>
<p>        String url = &quot;http://我的服务器地址&quot;;  </p>
<p>try {  </p>
<p>            HttpPost post = new HttpPost(url);  </p>
<p>            post.setEntity(new StringEntity(mJson.toString(), HTTP.UTF_8));  </p>
<p>            post.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);  </p>
<p>            response = mClient.execute(post);  </p>
<p>int statusCode = response.getStatusLine().getStatusCode();  </p>
<p>            System.out.println(&quot;doinbackground:&quot;+statusCode);  </p>
<p>if (statusCode == 200) {  </p>
<p>                responseString  = EntityUtils.toString(response.getEntity());  </p>
<p>                System.out.println(&quot;返回结果:&quot;+responseString);  </p>
<p>            }  </p>
<p>        } catch (ClientProtocolException e) {  </p>
<p>            e.printStackTrace();  </p>
<p>        } catch (IOException e) {  </p>
<p>            e.printStackTrace();  </p>
<p>        }  </p>
<p>return responseString;  </p>
<p>    }  </p>
<p>@Override  </p>
<p>protected void onPostExecute(String result) {  </p>
<p>super.onPostExecute(result);  </p>
<p>        System.out.println(&quot;onPostExecute:&quot;+result);  </p>
<p>        JSONObject json;  </p>
<p>try {  </p>
<p>            json = new JSONObject(result);  </p>
<p>            JSONObject mresult = json.getJSONObject(&quot;result&quot;);  </p>
<p>            JSONObject geo = mresult.getJSONObject(&quot;geo&quot;);  </p>
<p>double lat = geo.getDouble(&quot;lat&quot;);  </p>
<p>double lng = geo.getDouble(&quot;lng&quot;);  </p>
<p>            mLocationGeoPoint = new GeoPoint((int)(lat<em>1E6), (int)(lng</em>1E6));  </p>
<p>            CustomOverlay overlay = new CustomOverlay(mAppMain);  </p>
<p>            mMapView.getOverlays().add(overlay);  </p>
<p>            mMapController.animateTo(mLocationGeoPoint);  </p>
<p>        } catch (JSONException e) {  </p>
<p>            e.printStackTrace();  </p>
<p>        }  </p>
<p>    }  </p>
<p>}  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>修复launcher2横竖屏bug</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%BF%AE%E5%A4%8Dlauncher2%E6%A8%AA%E7%AB%96%E5%B1%8Fbug/</url>
    <content><![CDATA[<p>packages\apps\Launcher2\src\com\android\launcher2\DragLayer.java</p>
<p> public boolean onInterceptHoverEvent(MotionEvent ev) {</p>
<p>    if ((mLauncher != null) &amp;&amp; (mLauncher.getWorkspace() != null)) {</p>
<p>            Folder currentFolder = mLauncher.getWorkspace().getOpenFolder();</p>
<p>            if (currentFolder == null) {</p>
<p>                return false;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>修改卷标</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%BF%AE%E6%94%B9%E5%8D%B7%E6%A0%87/</url>
    <content><![CDATA[<p>有三个地方可以修改卷标的：</p>
<p>1.bootable/recovery/etc/init.rc</p>
<p>2.device/rockchip/rk29sdk/recovery/etc/init.rc</p>
<p>on boot</p>
<p>    setprop UserVolumeLabel &quot;XXX&quot;</p>
<ol start="3">
<li>system/vold/Volume.cpp //在格式化flash时可以修改</li>
</ol>
<p> property_get(&quot;UserVolumeLabel&quot;, label, &quot;&quot;);</p>
<p>…  </p>
<p>        sprintf(cmd,&quot;mkdosfs -L ‘%s’ /dev/block/vold/%d:%d&quot;, label,</p>
<p>            MAJOR(diskNode), MINOR(diskNode));</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>修改厂商信息及设备名称</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%BF%AE%E6%94%B9%E5%8E%82%E5%95%86%E4%BF%A1%E6%81%AF%E5%8F%8A%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<p> kernel\drivers\usb\gadget\f_mass_storage.c</p>
<p>            fsg-&gt;vendor = &quot;ONDA&quot;;</p>
<p>            fsg-&gt;product = &quot;MP4 PLAYER&quot;;</p>
<p>        kernel\arch\arm\mach-rockchip\rk28_devices.c</p>
<p>            .product_name   = &quot;Android ADB Device&quot;,</p>
<p>            .manufacturer_name = &quot;UNKNOWN&quot;,</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>修改锁屏时间显示 am  pm</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%BF%AE%E6%94%B9%E9%94%81%E5%B1%8F%E6%97%B6%E9%97%B4%E6%98%BE%E7%A4%BA%20am%20%20pm/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/ClockView.java b/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/</p>
<p>index 6c701c7..760b608 100755</p>
<p>— a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/ClockView.java</p>
<p>+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/ClockView.java</p>
<p>@@ -35,13 +35,15 @@ import java.lang.ref.WeakReference;</p>
<p> import java.text.DateFormatSymbols;</p>
<p> import java.util.Calendar;</p>
<p> import com.android.internal.R;</p>
<p>-</p>
<p>+import android.util.Log;</p>
<p> /**</p>
<p>  * Displays the time</p>
<p>  */</p>
<p> public class ClockView extends RelativeLayout {</p>
<ul>
<li><p>   private static final String ANDROID_CLOCK_FONT_FILE = &quot;/system/fonts/AndroidClock.ttf&quot;;</p>
</li>
<li><p>   private final static String M12 = &quot;h:mm&quot;;</p>
</li>
</ul>
<p>+//    private static final String ANDROID_CLOCK_FONT_FILE = &quot;/system/fonts/AndroidClock.ttf&quot;;</p>
<ul>
<li>private static final String ANDROID_CLOCK_FONT_FILE = &quot;/system/fonts/DroidSansFallback.ttf&quot;;</li>
</ul>
<p>+//    private final static String M12 = &quot;h:mm&quot;;</p>
<p>+private final static String M12 = &quot;h:mmaa&quot;;</p>
<p>     private final static String M24 = &quot;kk:mm&quot;;</p>
<p>     private Calendar mCalendar;</p>
<p>@@ -154,6 +156,9 @@ public class ClockView extends RelativeLayout {</p>
<p>     protected void onFinishInflate() {</p>
<p>         super.onFinishInflate();</p>
<p>         mTimeView = (TextView) findViewById(R.id.clock_text);</p>
<ul>
<li>       mTimeView.setTextSize(mTimeView.getTextSize()-120);   </li>
</ul>
<p>         mTimeView.setTypeface(Typeface.createFromFile(ANDROID_CLOCK_FONT_FILE));</p>
<p>         mAmPm = new AmPm(this, null);</p>
<p>         mCalendar = Calendar.getInstance();</p>
<p>@@ -209,12 +214,11 @@ public class ClockView extends RelativeLayout {</p>
<p>         updateTime();</p>
<p>     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>停止使能 apk</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%81%9C%E6%AD%A2%E4%BD%BF%E8%83%BD%20apk/</url>
    <content><![CDATA[<p>import android.content.pm.PackageInfo;</p>
<p>import android.content.pm.PackageManager;</p>
<p>import java.util.List;</p>
<p>PackageManager pm = null;</p>
<p>pm = getPackageManager();  </p>
<p> setApplicationEnabled( packageNameSettings, true, pm);</p>
<p>private static final String packageNameSettings[] = { &quot;com.android.settings&quot; };</p>
<p>private void setApplicationEnabled(String packageName[], boolean enable,</p>
<p>PackageManager pm) {</p>
<p>for (int i = 0, j = packageName.length; i &lt; j; i++) {</p>
<p>if (isPackageInstalled(packageName[i], pm)) {</p>
<p>pm.setApplicationEnabledSetting(</p>
<p>packageName[i],</p>
<p>enable ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED</p>
<p>: PackageManager.COMPONENT_ENABLED_STATE_DISABLED,</p>
<p>PackageManager.DONT_KILL_APP);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>private boolean isPackageInstalled(String packageName, PackageManager pm) {</p>
<p>List&lt;PackageInfo&gt; installedList = pm</p>
<p>.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);</p>
<p>int installedListSize = installedList.size();</p>
<p>for (int i = 0; i &lt; installedListSize; i++) {</p>
<p>PackageInfo tmp = installedList.get(i);</p>
<p>if (packageName.equalsIgnoreCase(tmp.packageName)) {</p>
<p>return true;</p>
<p>}</p>
<p>}</p>
<p>return false;</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>健健康康地活着</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%81%A5%E5%81%A5%E5%BA%B7%E5%BA%B7%E5%9C%B0%E6%B4%BB%E7%9D%80/</url>
    <content><![CDATA[<ol>
<li>多抬头，远望或看看天花板</li>
</ol>
<p>颈椎不得360，宜水平左右90旋转，不宜弄响颈椎。</p>
<ol start="2">
<li>肌肉的承受以40分钟为宜，不宜保持单一姿势或动作超过40分钟。</li>
</ol>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>充电99-100半小时</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%85%85%E7%94%B599-100%E5%8D%8A%E5%B0%8F%E6%97%B6/</url>
    <content><![CDATA[<p>kernel/drivers/power/rk30_factory_adc_battery.c</p>
<p>+static full_time = 0;</p>
<p> static int rk30_adc_battery_status_samples(struct rk30_adc_battery_data *bat)</p>
<p> {</p>
<p>        int charge_level;</p>
<p>@@ -728,12 +728,16 @@ static int rk30_adc_battery_status_samples(struct rk30_adc_battery_data *bat)</p>
<p>                                bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>                                if((bat-&gt;bat_capacity == 99)&amp;&amp;(bat-&gt;time_to_full == 0)){</p>
<p>                                        bat-&gt;time_to_full = get_seconds();</p>
<ul>
<li>full_time = 0;</li>
</ul>
<p>                                }else if(bat-&gt;bat_capacity == 99)</p>
<p>                                {</p>
<ul>
<li>if(get_seconds() - bat-&gt;time_to_full &gt; 1800)</li>
</ul>
<ul>
<li><p>//if(get_seconds() - bat-&gt;time_to_full &gt; 1800)</p>
</li>
<li><p>if(full_time++ &gt; 1800){</p>
</li>
</ul>
<p>                                                bat-&gt;bat_capacity = 100;</p>
<ul>
<li>bat-&gt;time_to_full = 0;</li>
</ul>
<p>-</p>
<ul>
<li><p>full_time = 0 ;</p>
</li>
<li><p>}</p>
</li>
<li><p>// bat-&gt;time_to_full = 0;</p>
</li>
<li><p>//printk(&quot;=======full time :%d\n&quot;,full_time);</p>
</li>
</ul>
<p>                                }</p>
<p>                                if(bat-&gt;pdata-&gt;ctrl_charge_led != NULL)</p>
<p>@@ -744,6 +748,18 @@ static int rk30_adc_battery_status_samples(struct rk30_adc_battery_data *bat)</p>
<p>                                bat-&gt;full_times = 0;</p>
<p>                                bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>+</p>
<ul>
<li><p>if(bat-&gt;bat_capacity == 99)</p>
</li>
<li><p>full_time ++ ;</p>
</li>
<li><p>else if(bat-&gt;bat_capacity &lt; 99)</p>
</li>
<li><p>full_time = 0 ;</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>if(full_time &gt; 1800){</p>
</li>
<li><p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
</li>
<li><p>bat-&gt;bat_capacity = 100;</p>
</li>
<li><p>full_time = 0 ;</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p>                        }else{</p>
<p>                                bat-&gt;full_times++;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>全景图象倒置</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%85%A8%E6%99%AF%E5%9B%BE%E8%B1%A1%E5%80%92%E7%BD%AE/</url>
    <content><![CDATA[<p>packages/apps/Camera/src/com/android/camera/panorama/PanoramaActivity.java</p>
<p>@@ -365,7 +365,8 @@ public class PanoramaActivity extends ActivityBase implement</p>
<p>     private void openCamera() throws CameraHardwareException, CameraDisabledExc</p>
<p>         int backCameraId = CameraHolder.instance().getBackCameraId();</p>
<p>         mCameraDevice = Util.openCamera(this, backCameraId);</p>
<ul>
<li>       mCameraOrientation = Util.getCameraOrientation(backCameraId);</li>
</ul>
<ul>
<li><p>       //mCameraOrientation = Util.getCameraOrientation(backCameraId);</p>
</li>
<li><p>                mCameraOrientation = 90 ; //一般不用强制改这里</p>
</li>
</ul>
<p>     }</p>
<p>     private boolean findBestPreviewSize(List&lt;Size&gt; supportedSizes, boolean need</p>
<p>@@ -1112,7 +1113,7 @@ public class PanoramaActivity extends ActivityBase impleme</p>
<p>         // Set the display orientation to 0, so that the underlying mosaic libr</p>
<p>         // can always get undistorted mPreviewWidth x mPreviewHeight image data</p>
<p>         // from SurfaceTexture.</p>
<ul>
<li>       mCameraDevice.setDisplayOrientation(0);</li>
</ul>
<ul>
<li>    mCameraDevice.setDisplayOrientation(180); //反转180</li>
</ul>
<p>         setPreviewTexture(mSurfaceTexture);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>几种视频信号的工作原理</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%87%A0%E7%A7%8D%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>几种视频信号的工作原理<br>碟机视频输出格式<br>DVD机输出接口有音频接口和视频接口，视频接口又 分CVBS（复合视频）、S-端子、色差分量（Y、Cr、Cb）、VGA等视频接口，在VCD机中还配有RF（射频）接口。那么多的视频接口它们怎样组 成、有什么优缺点呢？回答此问题前我们先看看这些视频信号是怎样与电视机连接的（见图）： <br>1、色差分量信号（Y、Cr、Cb）：<br>色差分 量信号是直接将图像信号以分量格式（Cr、Cb）经色差分量端子送入彩电。这时彩电中仅需经过矩阵电路（宽带的电阻相加减网络）后，经末级视放送到显像管 阴极去显示。这种接法信号传输路径短，加工少，电路带宽在10MHz以上，超过亮度和色度信号的带宽（6MHz），既无彩色制式差别，也没有高频副色度载 波干扰辐射存在，故图像质量最好。 <br>2、三基色信号（RGB）：<br>将色差信号（Y、Cr、Cb）经机内运算电路变为RGB三基色信号[例如 红色差分量与亮度信号相加，即（R-Y）+Y，则得出红基色信号R，这样得到没有亮度信号的三个基色信号R、G、B]从三基色端子（或VGA）输入彩电， 经末级视放到达显像管阴极，此方式经三基色运算环节，但在彩电中不再经矩阵电路，故其图像质量与分量方式同级。它具有分量信号格式的所有优点，如无串扰、 无制式差别，无相移影响等，合成彩色色彩真实，不易因线路损耗产生偏色，无论传输途多大差别，只要将三个基色幅度还原为相等则不会产生偏色。RGB三基色 常以15针插座（电脑VGA插座）来输出。在欧洲国家电器上多用此插座，称为SCART端子，其余各针包括L、R伴音信号和同步信号。 <br>3、S视频信号（S-Video）：<br>DVD 将分量信号经编码电路及4.43MHz副载波进行复合调制，将三路色差信号变为亮度信号Y和复合色度信号C，经S端子送入彩电，在彩电中Y信号经视放电路 送入矩阵，而C信号需要经彩色解码电路，将4.43MHz的色度信号进行U/V分离，再解码而得出R-Y、B-Y两个色差信号，再送入矩阵电路处理、显 示。显然这种接法信号传达室输路径长，反复处理多，信号损失和失真都会比色差分量方式大，图像质量不如前者，存在色度副载波干扰。 <br>4、复合视频信号（CVBS）：<br>DVD 机若将S视频中的Y和C信号再进行混合调幅，则成为单一的复合视频信号（CVBS），它是将色度信号的带宽限制后调幅在Y信号上，显然DVD将此信号接入 彩电视频图像（Video）端子后，在彩电中还要经过亮色分离、色度解调、矩阵处理才能显示，不仅传输路径长且重复地混合、编码、解码，重复加工过多，图 像质量比前二者更差，不仅有色度副载波网纹干扰，也存在亮度之间相互干扰，使彩色界面出现斑点干扰，色度波形前后沿也有失真，形成色彩界面混染等。 <br>5、射频信号（RF）：<br>若 DVD机与没有AV端子的老式球面彩电相连，则只能用调制高频输出方式，即射频（RF）连接。RF信号是将CVBS信号和音频（Audio）信号经高频调 制后输出（包括图像和声音）的高频信号。此信号与电视台发射的信号质量相似，图像质量在上述4种方式中最差。它除前述的各种干扰外，还需加上高频调制损失 和辐射干扰。在DVD机中没有配置RF输出</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>判断wifi是否可用</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%88%A4%E6%96%ADwifi%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p>public static boolean isWiFiActive(Context inContext) {            Context context = inContext.getApplicationContext();            ConnectivityManager connectivity = (ConnectivityManager) context                    .getSystemService(Context.CONNECTIVITY_SERVICE);            if (connectivity != null) {                NetworkInfo[] info = connectivity.getAllNetworkInfo();                if (info != null) {                    for (int i = 0; i &lt; info.length; i++) {                        if (info[i].getTypeName().equals(&quot;WIFI&quot;) &amp;&amp; info[i].isConnected()) {                            return true;                        }                    }                }            }            return false;        }    </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>判断手机当前上网用的是sim卡还是wifi</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%88%A4%E6%96%AD%E6%89%8B%E6%9C%BA%E5%BD%93%E5%89%8D%E4%B8%8A%E7%BD%91%E7%94%A8%E7%9A%84%E6%98%AFsim%E5%8D%A1%E8%BF%98%E6%98%AFwifi/</url>
    <content><![CDATA[<p>/**    * check the internet is   * mobile or wifi    * add by wangxianming    * in 2012-03-22    */    private boolean checkWifi() {       boolean isWifiConnect = true;       ConnectivityManager cm = (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);    </p>
<p>//check the networkInfos numbers   NetworkInfo[] networkInfos = cm.getAllNetworkInfo();    for (int i = 0; i&lt;networkInfos.length; i++) {       if (networkInfos[i].getState() == NetworkInfo.State.CONNECTED) {          if(networkInfos[i].getType() == cm.TYPE_MOBILE) {              isWifiConnect = false;          }          if(networkInfos[i].getType() == cm.TYPE_WIFI) {              isWifiConnect = true;          }       }   }    return isWifiConnect;    </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>去掉play_store不报错</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%8E%BB%E6%8E%89play_store%E4%B8%8D%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/services/java/com/android/server/pm/PackageManagerService.java b/frameworks/base/services/java/com/android/server/pm/PackageManagerService.java</p>
<p>index f6f584c..e3ac155 100644</p>
<p>— a/frameworks/base/services/java/com/android/server/pm/PackageManagerService.java</p>
<p>+++ b/frameworks/base/services/java/com/android/server/pm/PackageManagerService.java</p>
<p>@@ -2056,6 +2056,9 @@ public class PackageManagerService extends IPackageManager.Stub {</p>
<p>             Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));</p>
<p>             if (obj != null) {</p>
<p>                 GrantedPermissions gp = (GrantedPermissions)obj;</p>
<ul>
<li><p>              if (gp instanceof PackageSetting &amp;&amp; ((PackageSetting)gp).name.equals(&quot;com.android.vending&quot;)) {</p>
</li>
<li><p>                  return PackageManager.PERMISSION_GRANTED;</p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>                 if (gp.grantedPermissions.contains(permName)) {</p>
<p>                     return PackageManager.PERMISSION_GRANTED;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>去掉强制的红框？</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%8E%BB%E6%8E%89%E5%BC%BA%E5%88%B6%E7%9A%84%E7%BA%A2%E6%A1%86%EF%BC%9F/</url>
    <content><![CDATA[<p>— a/services/java/com/android/server/wm/WindowManagerService.java</p>
<p>+++ b/services/java/com/android/server/wm/WindowManagerService.java</p>
<p>@@ -5544,7 +5544,7 @@ public class WindowManagerService extends IWindowManager.Stub</p>
<p>                     mStrictModeFlash = new StrictModeFlash(</p>
<p>                             getDefaultDisplayContentLocked().getDisplay(), mFxSession);</p>
<p>                 }</p>
<ul>
<li>               mStrictModeFlash.setVisibility(on);</li>
</ul>
<ul>
<li>               //mStrictModeFlash.setVisibility(on);</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>去掉设置setting无法检测电池</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%8E%BB%E6%8E%89%E8%AE%BE%E7%BD%AEsetting%E6%97%A0%E6%B3%95%E6%A3%80%E6%B5%8B%E7%94%B5%E6%B1%A0/</url>
    <content><![CDATA[<p>// hide battery data usage not available title</p>
<p>— a/packages/apps/Settings/src/com/android/settings/fuelgauge/PowerUsageSummar</p>
<p>+++ b/packages/apps/Settings/src/com/android/settings/fuelgauge/PowerUsageSummar</p>
<p>@@ -369,7 +369,7 @@ public class PowerUsageSummary extends PreferenceFragment im</p>
<p>         mAppListGroup.addPreference(hist);</p>
<p>         if (mPowerProfile.getAveragePower(PowerProfile.POWER_SCREEN_FULL) &lt; 10)</p>
<ul>
<li>           addNotAvailableMessage();</li>
</ul>
<ul>
<li>              //addNotAvailableMessage();</li>
</ul>
<p>             return;</p>
<p>         }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>反射改变CountDownTimer类的私有字段mCountdownInterval</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%8F%8D%E5%B0%84%E6%94%B9%E5%8F%98CountDownTimer%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5mCountdownInterval/</url>
    <content><![CDATA[<p>倒计时CountDownTimer</p>
<p>new CountDownTimer(30000, 1000) {<br>public void onTick(long millisUntilFinished) {<br>         mTextField.setText(&quot;seconds remaining: &quot; + millisUntilFinished / 1000);<br>}<br>public void onFinish() {<br>         mTextField.setText(&quot;done!&quot;);<br>}<br>}.start();</p>
<p>反射，利用反射动态地改变CountDownTimer类的私有字段mCountdownInterval，这里我抽取成了一个方法，代码如下：</p>
<p>privatevoid changeCountdownInterval(long time) {<br>    try {<br>    // 反射父类CountDownTimer的mCountdownInterval字段，动态改变回调频率<br>    Class clazz = Class.forName(&quot;android.os.CountDownTimer&quot;);<br>    Field field = clazz.getDeclaredField(&quot;mCountdownInterval&quot;);<br>    field.setAccessible(true);<br>    field.set(this, time);<br>    } catch (Exception e) {<br>        Log.e(&quot;Ye&quot;, &quot;反射类android.os.CountDownTimer失败： &quot; + e);<br>    }<br>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>发送广播 未激活应用</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD%20%E6%9C%AA%E6%BF%80%E6%B4%BB%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>激活状态和停止状态的切换</p>
<p>当程序第一次安装并且没有启动,或者用户手动从程序管理将其停止后,程序都会处于停止状态.</p>
<p>如何变为停止状态</p>
<p>1.在设置应用管理中的应用详情页点击强制停止<br>2.使用adb shell adb shell am force-stop package-name<br>3.使用ActivityManager的隐藏方法forceStopPackages,并且向manifest加入申请权限&lt;uses-permission android:name=“android.permission.FORCE_STOP_PACKAGES”/&gt;</p>
<p>如何脱离停止状态</p>
<p>1.手动启动程序<br>2.使用adb激活应用组件,如activity或者receiver</p>
<p>发送广播intent给处于停止状态的应用</p>
<p>1.在Java代码发送Intent时,加入flag FLAG_INCLUDE_STOPPED_PACKAGES<br>2.如果使用adb,同样是加入FLAG_INCLUDE_STOPPED_PACKAGES(其具体值为32), 如adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -f 32</p>
<p>检查是否处于停止状态</p>
<p>1.进入设置—应用管理—某个应用的详细页,如果强制停止按钮不可用,则说明程序已经处于停止状态.<br>2.进入设备终端,查看系统文件cat /data/system/packages-stopped.xml</p>
<p>从Android 3.1开始，系统给Intent定义了两个新的Flag，</p>
<p>分别为FLAG_INCLUDE_STOPPED_PACKAGES（表示包含未启动的App）</p>
<p>       和FLAG_EXCLUDE_STOPPED_PACKAGES（表示不包含未启动的App），</p>
<p>用来控制Intent是否要对处于停止状态的App起作用，具体的操作方式如下：</p>
<p>在需要接收广播的应用中静态注册广播，并定义好action，并且需要指定android:exported=&quot;true&quot;；</p>
<p>&lt;receiver android:name=&quot;.receiver.UpdateWidgetReceiver&quot;<br>   android:exported=&quot;true&quot;&gt;<br>   &lt;intent-filter&gt;<br>        &lt;action android:name=&quot;com.uperone.widget.action&quot;/&gt;<br>   &lt;/intent-filter&gt;<br> &lt;/receiver&gt;</p>
<p>在发送广播的应用中添加如下代码段：</p>
<p>Intent intent = new Intent();<br>intent.setAction(&quot;com.uperone.widget.action&quot;);<br>intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);</p>
<p>sendBroadcast(intent);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>各种分辨率</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%90%84%E7%A7%8D%E5%88%86%E8%BE%A8%E7%8E%87/</url>
    <content><![CDATA[<p>通常区分这几种名词的重要技术指标是液晶屏(TFT LCD)的分辨率. </p>
<p>一般分辨率为1024<em>768或800</em>600的液晶屏被称为XGA, </p>
<p>分辨率为1400*1050的液晶屏被称为SXGA, </p>
<p>分辨率为1600*1200的液晶屏被称为UXGA, </p>
<p>分辨率为1024<em>480或1280</em>600的液晶屏被称为UWXGA(例如SONY 的C1系列), </p>
<p>分辨率为1024*512的液晶屏被称为WXGA 。 </p>
<p>TFT是英文Thin Film Transistor的缩写，中文意思是薄膜晶体管。 </p>
<p>VGA、SVGA、XGA、SXGA、UXGA是对就不同的分辨率的叫法，具体如下： </p>
<p>VGA 640 * 480 </p>
<p>SVGA 800 * 600 </p>
<p>XGA 1024 * 768 </p>
<p>SXGA 1280 * 1024 ＆ 1400 * 1050 </p>
<p>UXGA 1600 * 1200 </p>
<p>标准规格： </p>
<p>规格 分辨率 尺寸 </p>
<p>XGA 1024×768 15.1&quot;、14.1&quot;、13.3&quot;、12.1&quot;、11.3&quot;、10.4&quot; </p>
<p>TFT/SVGA 800×600 12.1&quot; </p>
<p>SXGA+(SXGA) 1400×1050 15&quot;、14.1&quot; </p>
<p>UXGA 1600×1200 15&quot; IBM A22P显示屏 </p>
<p>不标准规格： </p>
<p>UWXGA 1024×480 8.9&quot; SONY C1系列 </p>
<p>WXGA 1024×512 8.8&quot; FUJITSU P1000 . 1152×768 15.2&quot; Apple PowerBook G4</p>
<p>注： 投影机的分辨率，可分为VGA、SVGA、XGA、SXGA和UXGA。 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>启动第三方应用intent</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%90%AF%E5%8A%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8intent/</url>
    <content><![CDATA[<p>Intent i = new Intent();<br>ComponentName comp = new ComponentName(&quot;com.android.camera&quot;,&quot;com.android.camera.GalleryPicker&quot;);<br>i.setComponent(comp);<br>i.setAction(&quot;android.intent.action.VIEW&quot;);<br>startActivity(i);</p>
<p>Intent mIntent = new Intent();<br>ComponentName comp = new ComponentName(&quot;com.android.camera&quot;,&quot;com.android.camera.Camera&quot;);<br>mIntent.setComponent(comp);<br>mIntent.setAction(&quot;android.intent.action.VIEW&quot;);<br>startActivity(mIntent);</p>
<p>Intent intent = new Intent();<br>ComponentName cn = new ComponentName(&quot;com.android.htmlviewer&quot;, &quot;com.android.htmlviewer.HTMLViewerActivity&quot;);<br>intent.setComponent(cn);<br>Uri uri = Uri.fromFile(new File(&quot;/sdcard/demo.txt&quot;));<br>intent.setDataAndType(uri, &quot;text/plain&quot;);<br>startActivity(intent);</p>
<p>Intent intent = new Intent();
 </p>
<p>intent.setClassName(&lt;package name&gt;, &lt;class name&gt;);  </p>
<p>startActivity(intent);</p>
<p>Intent i=new Intent;</p>
<p>ComponentName com= new ComponentName(&lt;Package Name&gt; , &lt;Calss Name&gt;);  </p>
<p>i.setComponent(com);  </p>
<p>startActivity(i);  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>呼叫限制</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%91%BC%E5%8F%AB%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>（一）设置呼叫限制密码 </p>
<p>激活或取消各种呼叫限制业务时，客户需要使用4位的限制密码。系统预设给客户的限制密码为“0000”，客户在申请开通了呼叫限制业务后，应设置新的4位限制密码，以提高保密性，设置密码的操作请参见手机的说明书。客户也可以通过快捷方式修改：待机状态下，输入*<em>03</em>330<em>旧密码</em>新密码*新密码#发射键，即可修改呼叫限制密码。</p>
<p>（二）设置各项呼叫限制功能<br>客户可通过手机控制菜单进行所需的呼叫限制功能的设置和激活，各种机型详见手机使用说明书。客户也可使用各种机型通用的控制编码来设置呼叫限制功能。</p>
<p>功能 设置 取消 查询</p>
<p>限制所有呼出<em>33</em>密码##33<em>密码#</em>#33#</p>
<p>限制所有国际呼出<em>331</em>密码##331<em>密码#</em>#331#</p>
<p>限制所有电话呼入<em>35</em>密码##35<em>密码#</em>#35#</p>
<p>输入以上操作码后，按手机确认键即可激活、取消或查询该业务的状态。</p>
<p>申请开通了呼叫限制功能后，客户可根据需要在手机上设置各种呼出、呼入的限制，客户可随意激活或取消各种呼叫限制功能，灵活地控制手机的呼叫权限，防止被人误打、盗打电话（特别是国际长途电话），避免不必要的经济损失。</p>
<p>       目前，我司为全球通、神州行(免费) 客户提供了“限制所有呼出、限制所有国际呼出、限制所有电话呼入”三种个性化的呼叫限制功能。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>四象限法则 [2019-08-13]</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9B%9B%E8%B1%A1%E9%99%90%E6%B3%95%E5%88%99%20%5B2019-08-13%5D/</url>
    <content><![CDATA[<p>重要且紧急 —— 优先解决立即做            重要不紧急 —— 制定计划去做            </p>
<p>事项1                </p>
<p>事项2                </p>
<p>事项3                </p>
<p>……</p>
<p>事项1                 </p>
<p>事项2                </p>
<p>事项3                </p>
<p>……</p>
<p>紧急不重要 —— 有空再说            不重要不紧急 —— 交给别人去做            </p>
<p>事项1                </p>
<p>事项2                </p>
<p>事项3                </p>
<p>……</p>
<p>事项1                </p>
<p>事项2                </p>
<p>事项3                </p>
<p>……</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>四象限法则</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9B%9B%E8%B1%A1%E9%99%90%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<p>重要且紧急 —— 优先解决立即做            重要不紧急 —— 制定计划去做            </p>
<p>紧急不重要 —— 有空再说            不重要不紧急 —— 交给别人去做            </p>
<p>社保</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>因为CoreSimulator 而不能正常启动 Xcode</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9B%A0%E4%B8%BACoreSimulator%20%E8%80%8C%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%20Xcode/</url>
    <content><![CDATA[<p>如果因为CoreSimulator 而不能正常启动 Xcode 的用户，可以用下面的指令重新安装 CoreSimulator.framework 来解决：</p>
<p>installer -pkg /Applications/Xcode.app/Contents/Resources/Packages/XcodeSystemResources.pkg -target /</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>图书证</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9B%BE%E4%B9%A6%E8%AF%81/</url>
    <content><![CDATA[<p>深圳图书馆</p>
<p><a href="http://www.szlib.gov.cn/">http://www.szlib.gov.cn/</a></p>
<p>0440070091596</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>图库 Maker Gallery2</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9B%BE%E5%BA%93%20Maker%20Gallery2/</url>
    <content><![CDATA[<p>+++ b/packages/apps/Gallery2/src/com/android/gallery3d/ui/DialogDetailsView.java</p>
<p> import android.content.Context;</p>
<p>@@ -180,14 +180,17 @@ public class DialogDetailsView implements DetailsViewContainer {</p>
<p>                         value = valueObj.toString();</p>
<p>                     }</p>
<p>                 }</p>
<p>                 int key = detail.getKey();</p>
<p>                 if (details.hasUnit(key)) {</p>
<p>                     value = String.format(&quot;%s: %s %s&quot;, DetailsHelper.getDetailsName(</p>
<p>                             context, key), value, context.getString(details.getUnit(key)));</p>
<p>                 } else {</p>
<p>                          //  if( MediaDetails.INDEX_MAKE == key) value = &quot;KOOOOO&quot;;</p>
<p>                                    if(MediaDetails.INDEX_MAKE == key) {</p>
<p>String makerStr = &quot;bx&quot;;</p>
<p>makerStr = SystemProperties.get(&quot;ro.product.brand&quot;, makerStr); </p>
<p>value = makerStr;</p>
<p>}</p>
<p>camera2</p>
<p>b/src/com/android/camera/ui/DetailsDialog.java</p>
<p>@@ -188,6 +188,7 @@ public class DetailsDialog {</p>
<p>                     value = String.format(&quot;%s: %s %s&quot;, getDetailsName(</p>
<p>                             context, key), value, context.getString(details.getUnit(key)));</p>
<p>                 } else {</p>
<ul>
<li>                       if( MediaDetails.INDEX_MAKE == key) value = &quot;AD 07.01&quot;;</li>
</ul>
<p>                     value = String.format(&quot;%s: %s&quot;, getDetailsName(</p>
<p>                             context, key), value);</p>
<p>                 }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>图库Gallery2 循环播放</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9B%BE%E5%BA%93Gallery2%20%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE/</url>
    <content><![CDATA[<p>有些不支持格式会出现bug</p>
<p>diff –git a/packages/apps/Gallery2/src/com/android/gallery3d/app/MovieActivity.java b/packages/apps/Gallery2/src/com/android/gallery3d/app/MovieActivity.java</p>
<p>index 3123644..dc12715 100644</p>
<p>— a/packages/apps/Gallery2/src/com/android/gallery3d/app/MovieActivity.java</p>
<p>+++ b/packages/apps/Gallery2/src/com/android/gallery3d/app/MovieActivity.java</p>
<p>@@ -43,6 +43,11 @@ import android.widget.ShareActionProvider;</p>
<p> import com.android.gallery3d.R;</p>
<p> import com.android.gallery3d.common.ApiHelper;</p>
<p> import com.android.gallery3d.common.Utils;</p>
<p>+import android.database.Cursor;</p>
<p>+import android.provider.MediaStore;</p>
<p>+import android.content.Context;</p>
<p>+import android.content.ContentResolver;</p>
<p>+import android.content.ContentUris;</p>
<p> /**</p>
<p>  * This activity plays a video from a specified URI.</p>
<p>@@ -62,6 +67,16 @@ public class MovieActivity extends Activity {</p>
<p>     private Uri mUri;</p>
<p>     private boolean mTreatUpAsBack;</p>
<ul>
<li><p>public static String[] mCols = new String[] {</p>
</li>
<li><p>MediaStore.Video.Media.DISPLAY_NAME,</p>
</li>
<li><p>MediaStore.Video.Media.DURATION,</p>
</li>
<li><p>MediaStore.Video.Media.MIME_TYPE,</p>
</li>
<li><p>MediaStore.Video.Media.SIZE,</p>
</li>
<li><p>MediaStore.Video.Media._ID,</p>
</li>
<li><p>MediaStore.Video.Media.DATA,</p>
</li>
<li><p>MediaStore.Video.Media.BOOKMARK</p>
</li>
<li><p>};</p>
</li>
</ul>
<p>+</p>
<p>     @TargetApi(Build.VERSION_CODES.JELLY_BEAN)</p>
<p>     private void setSystemUiVisibility(View rootView) {</p>
<p>         if (ApiHelper.HAS_VIEW_SYSTEM_UI_FLAG_LAYOUT_STABLE) {</p>
<p>@@ -92,9 +107,17 @@ public class MovieActivity extends Activity {</p>
<p>                 !mFinishOnCompletion) {</p>
<p>             @Override</p>
<p>             public void onCompletion() {</p>
<ul>
<li><p>if (mFinishOnCompletion) {</p>
</li>
<li><p>finish();</p>
</li>
<li><p>}</p>
</li>
</ul>
<ul>
<li><p>finish();</p>
</li>
<li><p>Intent intent = new Intent(Intent.ACTION_VIEW)</p>
</li>
<li><p>.setDataAndType(nextUri(MovieActivity.this , mUri), &quot;video/*&quot;);</p>
</li>
<li><p>//.putExtra(Intent.EXTRA_TITLE, mUri.toString())</p>
</li>
<li><p>// .putExtra(MovieActivity.KEY_TREAT_UP_AS_BACK, true);</p>
</li>
<li><p>intent.setClass(MovieActivity.this, MovieActivity.class);</p>
</li>
<li><p>startActivity(intent);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>// if (mFinishOnCompletion) {</p>
</li>
<li><p>// finish();</p>
</li>
<li><p>// }</p>
</li>
</ul>
<p>             }</p>
<p>         };</p>
<p>         if (intent.hasExtra(MediaStore.EXTRA_SCREEN_ORIENTATION)) {</p>
<p>@@ -257,4 +280,76 @@ public class MovieActivity extends Activity {</p>
<p>         return mPlayer.onKeyUp(keyCode, event)</p>
<p>                 || super.onKeyUp(keyCode, event);</p>
<p>     }</p>
<p>+</p>
<p>+</p>
<p>+public static Cursor getCurrentCursor(Context context,Uri currenturi)</p>
<ul>
<li>{</li>
</ul>
<p>+</p>
<ul>
<li><p>Cursor cur = null;</p>
</li>
<li><p>ContentResolver resolver = context.getContentResolver();</p>
</li>
<li><p>Uri uri = MediaStore.Video.Media.getContentUri(&quot;external&quot;);</p>
</li>
<li><p>cur = resolver.query(uri,mCols,null,null,null);</p>
</li>
</ul>
<p>+</p>
<ul>
<li>if(cur != null){</li>
</ul>
<p>+</p>
<ul>
<li><p>if(cur.moveToFirst()){</p>
</li>
<li><p>while(!cur.isAfterLast()){</p>
</li>
<li><p>if(currenturi.equals(ContentUris.withAppendedId(uri,cur.getInt(cur.getColumnIndexOrThrow(MediaStore.Video.Media._ID))))){</p>
</li>
<li><p>return cur;</p>
</li>
<li><p>}else{</p>
</li>
<li><p>cur.moveToNext();</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>}</p>
</li>
<li><p>if(cur != null){</p>
</li>
<li><p>cur.close();</p>
</li>
<li><p>cur = null;</p>
</li>
<li><p>}</p>
</li>
<li><p>return null;</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>public static Cursor getNextCursor(Context context,Uri currenturi)</p>
</li>
<li><p>{</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>Cursor cur = getCurrentCursor(context,currenturi);</p>
</li>
<li><p>if(cur == null)</p>
</li>
<li><p>return null;</p>
</li>
<li><p>else</p>
</li>
<li><p>{</p>
</li>
<li><p>if(cur.isLast())</p>
</li>
<li><p>{</p>
</li>
<li><p>cur.moveToFirst();</p>
</li>
<li><p>return cur;</p>
</li>
<li><p>}</p>
</li>
<li><p>else</p>
</li>
<li><p>{</p>
</li>
<li><p>cur.moveToNext();</p>
</li>
<li><p>return cur;</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li>public Uri nextUri(Context mContext, Uri mUri){</li>
</ul>
<p>+</p>
<ul>
<li><p>Cursor cur = getNextCursor(mContext, mUri);</p>
</li>
<li><p>Uri AimUri = mUri ;</p>
</li>
<li><p>if((cur != null || mUri.toString().startsWith(&quot;file://&quot;))){</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>if(cur != null){</p>
</li>
<li><p>Uri uri = MediaStore.Video.Media.getContentUri(&quot;external&quot;);</p>
</li>
<li><p>AimUri = Uri.withAppendedPath(uri, cur.getString(cur.getColumnIndexOrThrow(MediaStore.Video.Media._ID)));</p>
</li>
<li><p>cur.close();</p>
</li>
<li><p>cur = null;</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>return AimUri;</p>
</li>
</ul>
<p>+</p>
<ul>
<li>}</li>
</ul>
<p>+</p>
<p>+</p>
<p>+</p>
<p> }</p>
<p>(END)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>在Ubuntu 18</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9C%A8Ubuntu%2018.04%20%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>Ubuntu18.04 不能像16.04 那样可以直接使用 /etc/rc.local 文件，需要设置</p>
<p>1.建立 rc-local.service 文件</p>
<p>sudo vim /etc/systemd/system/rc-local.service</p>
<p>2.复制下列内容到 rc-local.service 文件中</p>
<p>[Unit]</p>
<p>Description=/etc/rc.local Compatibility</p>
<p>ConditionPathExists=/etc/rc.local</p>
<p>[Service]</p>
<p>Type=forking</p>
<p>ExecStart=/etc/rc.local start</p>
<p>TimeoutSec=0</p>
<p>StandardOutput=tty</p>
<p>RemainAfterExit=yes</p>
<p>SysVStartPriority=99</p>
<p>[Install]</p>
<p>WantedBy=multi-user.target</p>
<p>3.创建文件 rc.local</p>
<p>sudo vim /etc/rc.local</p>
<p>4.复制下列内容到 rc.local 文件中</p>
<p>#!/bin/sh -e</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="rc-local"><a href="#rc-local" class="headerlink" title="rc.local"></a>rc.local</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="This-script-is-executed-at-the-end-of-each-multiuser-runlevel"><a href="#This-script-is-executed-at-the-end-of-each-multiuser-runlevel" class="headerlink" title="This script is executed at the end of each multiuser runlevel."></a>This script is executed at the end of each multiuser runlevel.</h1><h1 id="Make-sure-that-the-script-will-quot-exit-0-quot-on-success-or-any-other"><a href="#Make-sure-that-the-script-will-quot-exit-0-quot-on-success-or-any-other" class="headerlink" title="Make sure that the script will &quot;exit 0&quot; on success or any other"></a>Make sure that the script will &quot;exit 0&quot; on success or any other</h1><h1 id="value-on-error"><a href="#value-on-error" class="headerlink" title="value on error."></a>value on error.</h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="In-order-to-enable-or-disable-this-script-just-change-the-execution"><a href="#In-order-to-enable-or-disable-this-script-just-change-the-execution" class="headerlink" title="In order to enable or disable this script just change the execution"></a>In order to enable or disable this script just change the execution</h1><h1 id="bits"><a href="#bits" class="headerlink" title="bits."></a>bits.</h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="By-default-this-script-does-nothing"><a href="#By-default-this-script-does-nothing" class="headerlink" title="By default this script does nothing."></a>By default this script does nothing.</h1><p>echo &quot;测试脚本执行成功&quot; &gt; /usr/local/test.log</p>
<p>exit 0</p>
<p>5.给 rc.local 加上权限，启用服务</p>
<p>sudo chmod 755 /etc/rc.local</p>
<p>sudo systemctl enable rc-local</p>
<p>6.启动服务并检查状态</p>
<p>sudo systemctl start rc-local.service</p>
<p>sudo systemctl status rc-local.service</p>
<p>7.重启后检查test.log文件是否已经存在</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>在Ubuntu上使用LVM对ROOT进行在线扩容</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9C%A8Ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8LVM%E5%AF%B9ROOT%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<p>前提：在安装ubuntu的时候，是使用LVM进行分区管理的</p>
<p>背景：我在安装的时候，选择了500G大小，磁盘总大小1T，现在想扩成1T。</p>
<p>扩容前：</p>
<p>yang@master:~$ sudo vgdisplay<br>  — Volume group —<br>  VG Name               master-vg<br>  System ID            <br>  Format                lvm2<br>  Metadata Areas        1<br>  Metadata Sequence No  3<br>  VG Access             read/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                2<br>  Open LV               2<br>  Max PV                0<br>  Cur PV                1<br>  Act PV                1<br>  VG Size               931.03 GiB<br>  PE Size               4.00 MiB<br>  Total PE              238344<br>  Alloc PE / Size       119208 / 465.66 GiB<br>  Free  PE / Size       119136 / 465.38 GiB<br>  VG UUID               wAwukv-rEtE-X78B-IA1h-xhQL-SqfL-bCmXTx</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>你会发现，虽然VG的size是931GB，但可以分配及自由空间只有465GB，那是因为，我在装系统的时候，只用了500G空间，就是想着LVM这工具可以在今后很方便地扩容。</p>
<p>扩容命令：</p>
<p>yang@master:~$ sudo lvextend -l +100%FREE /dev/mapper/master–vg-root<br>  Size of logical volume master-vg/root changed from 449.79 GiB (115145 extents) to 915.16 GiB (234281 extents).<br>  Logical volume root successfully resized.</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>扩容之后，我们再使用显示命令查看VG情况，发现，可分配的size已经是931G了，我们成功扩容。</p>
<p>扩容后：</p>
<p>yang@master:~$ sudo vgdisplay<br>[sudo] password for yang:<br>  — Volume group —<br>  VG Name               master-vg<br>  System ID            <br>  Format                lvm2<br>  Metadata Areas        1<br>  Metadata Sequence No  4<br>  VG Access             read/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                2<br>  Open LV               2<br>  Max PV                0<br>  Cur PV                1<br>  Act PV                1<br>  VG Size               931.03 GiB<br>  PE Size               4.00 MiB<br>  Total PE              238344<br>  Alloc PE / Size       238344 / 931.03 GiB<br>  Free  PE / Size       0 / 0  <br>  VG UUID               wAwukv-rEtE-X78B-IA1h-xhQL-SqfL-bCmXTx</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>But， 当我们使用df命令查看文件系统的使用情况时，很明显，根目录下Avail的大小为405G，也就是，我的根目录还是只能使用405G大小，虽然我们刚才把VG的可用容量扩大了，但我们的文件系统的大小还没有配置。</p>
<p>yang@master:~$ df -hFilesystem                   Size  Used Avail Use% Mounted onudev                         7.8G     0  7.8G   0% /devtmpfs                        1.6G  9.4M  1.6G   1% /run/dev/mapper/master–vg-root  443G   16G  405G   4% /tmpfs                        7.8G  7.4M  7.8G   1% /dev/shmtmpfs                        5.0M  4.0K  5.0M   1% /run/locktmpfs                        7.8G     0  7.8G   0% /sys/fs/cgroup/dev/sda1                    472M  105M  344M  24% /boottmpfs                        1.6G   56K  1.6G   1% /run/user/1000</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>此时，我们可以使用resize2fs命令对文件系统进行重新调整。</p>
<p>yang@master:~$ sudo resize2fs /dev/mapper/master–vg-rootresize2fs 1.42.13 (17-May-2015)<br>Filesystem at /dev/mapper/master–vg-root is mounted on /; on-line resizing required<br>old_desc_blocks = 29, new_desc_blocks = 58The filesystem on /dev/mapper/master–vg-root is now 239903744 (4k) blocks long.</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>此时，我们再使用df命令查看时，结果显示，根目录下可能空间已为844G，我们成功扩容！</p>
<p>yang@master:~$ df -hFilesystem                   Size  Used Avail Use% Mounted onudev                         7.8G     0  7.8G   0% /devtmpfs                        1.6G  9.4M  1.6G   1% /run/dev/mapper/master–vg-root  901G   16G  844G   2% /tmpfs                        7.8G  7.4M  7.8G   1% /dev/shmtmpfs                        5.0M  4.0K  5.0M   1% /run/locktmpfs                        7.8G     0  7.8G   0% /sys/fs/cgroup/dev/sda1                    472M  105M  344M  24% /boottmpfs                        1.6G   56K  1.6G   1% /run/user/1000</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>在串口或adb模式下使用下面方式查看上次的按键adc值</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9C%A8%E4%B8%B2%E5%8F%A3%E6%88%96adb%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E6%96%B9%E5%BC%8F%E6%9F%A5%E7%9C%8B%E4%B8%8A%E6%AC%A1%E7%9A%84%E6%8C%89%E9%94%AEadc%E5%80%BC/</url>
    <content><![CDATA[<p>在串口或adb模式下使用下面方式查看上次的按键adc值</p>
<p>cat ./sys/devices/platform/rk29-keypad/get_adc_value</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>在图片中加入删除照片或者视频时，弹出对话框提示。</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9C%A8%E5%9B%BE%E7%89%87%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%88%A0%E9%99%A4%E7%85%A7%E7%89%87%E6%88%96%E8%80%85%E8%A7%86%E9%A2%91%E6%97%B6%EF%BC%8C%E5%BC%B9%E5%87%BA%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8F%90%E7%A4%BA%E3%80%82/</url>
    <content><![CDATA[<p>1、在图片中加入删除照片或者视频时，弹出对话框提示。</p>
<p>在packages/apps/Gallery2/src/com/android/gallery3d/ui/MenuExecutor.java中</p>
<p> private boolean execute(<br>            DataManager manager, JobContext jc, int cmd, Path path) { </p>
<p>。。。。省略<br>        switch (cmd) { </p>
<p>把每张需要删除的照片都加入都list中<br>case R.id.action_confirm_delete:<br>                Log.i(&quot;delete&quot;, &quot;action_confirm_delete&quot;);<br>                        mycount++;<br>                        mypath=path;<br>                        mypaths.add(mypath);<br>                        mypath=null;<br>                break;</p>
<p>。。。。省略</p>
<p>}</p>
<p>  public void startAction(int action, int title, ProgressListener listener) {<br>        ArrayList&lt;Path&gt; ids = mSelectionManager.getSelected(false);<br>        Activity activity = (Activity) mActivity;<br>  if(title == R.string.delete)<br>        {<br>                mypaths=null;<br>                mypaths=new ArrayList&lt;Path&gt;();<br>                mycount=0;<br>                dialoginit(activity);显示对话框的工程中，已经运行了“把每张需要删除的照片都加入都list中”这部分<br>        }<br>        MediaOperation operation = new MediaOperation(action, ids, listener);<br>        mTask = mActivity.getThreadPool().submit(operation, null);<br>    }</p>
<p>新创一个函数</p>
<p>  private void dialoginit(Context context)<br>    {<br>        AlertDialog.Builder  deletedialog=null;<br>        Log.i(&quot;delete&quot;, &quot;dialoginit&quot;);<br>        deletedialog=new AlertDialog.Builder(context);<br>                deletedialog.setMessage(context.getResources().getString(R.string.aler_context))<br>                .setTitle(context.getResources().getString(R.string.aler_title))<br>        .setIcon(android.R.drawable.ic_dialog_alert)<br>                .setPositiveButton(context.getResources().getString(R.string.aler_sure), new DialogInterface.OnClickListener() {<br>                        @Override<br>                        public void onClick(DialogInterface dialog, int which) {<br>                                // TODO Auto-generated method stub<br>                                DataManager manager = mActivity.getDataManager();<br>                                for(int i=0;i&lt;mycount;i++)<br>                                {<br>                                         manager.delete(mypaths.get(i));<br>                                         Log.i(&quot;delete&quot;, &quot;delete–&quot;+i);<br>                                }<br>                        }<br>                })<br>                .setNegativeButton(context.getResources().getString(R.string.aler_cancel), new DialogInterface.OnClickListener() {<br>                        @Override<br>                        public void onClick(DialogInterface dialog, int which) {<br>                                // TODO Auto-generated method stub<br>                                dialog.cancel();<br>                        }<br>                });<br>                AlertDialog alert = deletedialog.create();<br>                alert.show();<br>    }  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>域名服务器</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>FTP服务器 23.234.35.254  域名解析到23.234.35.218</p>
<p>FTP用户名 edward.org.cn</p>
<p>火网互联 主机 120</p>
<p><a href="http://www.fireinter.com/login.asp">http://www.fireinter.com/login.asp</a></p>
<p>magicedward</p>
<p>2018-06-22</p>
<p>华夏名网  域名 65</p>
<p><a href="http://www.sudu.cn/login.php">http://www.sudu.cn/login.php</a></p>
<p>magicedward2</p>
<p>2021-06-22</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>增加日期时间后修改默认值</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%A2%9E%E5%8A%A0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%8E%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    <content><![CDATA[<p>&lt;?php</p>
<p>   $db-&gt;Connect($dsn) || die(‘fail’);</p>
<p>$recordSet = $db-&gt;Execute(&quot;select * from passage&quot;);</p>
<p>if (!$recordSet) </p>
<p>print $db-&gt;ErrorMsg();</p>
<p>else</p>
<p>while (!$recordSet-&gt;EOF) {</p>
<p>$ctime = $recordSet-&gt;fields[4];</p>
<p>$mtime = $recordSet-&gt;fields[5];</p>
<p>if($ctime==&quot;&quot; &amp;&amp; $mtime==&quot;&quot;){//新增加的字段值为&quot;&quot;;</p>
<p>        $id = $recordSet-&gt;fields[0] ;</p>
<p>        //刚建站时，数据库中没有ctime,mtime，后来增加了这两个字段，现在要修改其默认值</p>
<p>$ctime =date(‘Y-m-j G:i:s’,strtotime(&quot;2012-6-12 12:30:00&quot;)) ;</p>
<p>//$mtime = date(‘Y-m-j G:i:s’,strtotime(&quot;2012-6-12 12:30:00&quot;)) ;</p>
<p>$stmt = $db-&gt;Prepare(&quot;update passage set [ctime]=?,[mtime]=? where [id]=&quot;.$id);</p>
<p>        if(!$db-&gt;Execute($stmt,array($ctime,$ctime)))</p>
<p>echo ‘error:’.$db-&gt;ErrorMsg();  </p>
<p>else </p>
<p>echo &quot;修改成功！&quot;;</p>
<p>}</p>
<p>$recordSet-&gt;MoveNext();</p>
<p>} </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>增加键盘快捷键</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%A2%9E%E5%8A%A0%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>— a/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>@@ -778,6 +778,11 @@ public final class Launcher extends Activity</p>
<p>         if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.isLongPress()) {</p>
<p>             return true;</p>
<p>         }</p>
<p>+</p>
<ul>
<li><p>              if(keyCode == KeyEvent.KEYCODE_F2){//F2 打开应用列表</p>
</li>
<li><p>                      showAllApps(true); </p>
</li>
<li><p>                      return true;</p>
</li>
<li><p>                      }</p>
</li>
</ul>
<p>         return handled;</p>
<p>     }</p>
<p>— a/packages/apps/Browser/src/com/android/browser/Controller.java</p>
<p>+++ b/packages/apps/Browser/src/com/android/browser/Controller.java</p>
<p>@@ -2785,6 +2785,13 @@ public class Controller</p>
<p>                     return true;</p>
<p>                 }</p>
<p>                 break;</p>
<p>+</p>
<ul>
<li><p>                      case KeyEvent.KEYCODE_F4:    //Browser添加快捷键</p>
</li>
<li><p>                              closeCurrentTab(true);</p>
</li>
<li><p>                              break;</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F5:</p>
</li>
<li><p>                              getCurrentTopWebView().reload();</p>
</li>
<li><p>                              break;</p>
</li>
</ul>
<p> b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java</p>
<p>@@ -1441,7 +1444,99 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {</p>
<p>                     dispatcher.startTracking(event, this);</p>
<p>                 }</p>
<p>                 return true;</p>
<ul>
<li>           }</li>
</ul>
<ul>
<li><p>              }</p>
</li>
<li><p>                  case KeyEvent.KEYCODE_F1: {</p>
</li>
<li><p>                              Intent startSetting  = new Intent();</p>
</li>
<li><p>                              startSetting.setClassName(&quot;com.android.settings&quot;,&quot;com.android.settings.Settings&quot;);</p>
</li>
<li><p>                              startSetting.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startSetting);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F2: {</p>
</li>
<li><p>                              if(!getContext().getPackageName ().equals(&quot;com.android.launcher&quot;))</p>
</li>
<li><p>                              {</p>
</li>
<li><p>                              Intent mHomeIntent =  new Intent(Intent.ACTION_MAIN, null);</p>
</li>
<li><p>                      mHomeIntent.addCategory(Intent.CATEGORY_HOME);</p>
</li>
<li><p>                      mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK</p>
</li>
<li><p>               | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</p>
</li>
<li><p>                              this.getContext().startActivity(mHomeIntent);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                              return true;</p>
</li>
<li><p>                              }</p>
</li>
<li><p>                              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F3: {</p>
</li>
<li><p>                              Intent startQSearch  = new Intent();</p>
</li>
<li><p>                              startQSearch.setClassName(&quot;com.android.quicksearchbox&quot;,&quot;com.android.quicksearchbox.SearchActivity&quot;);</p>
</li>
<li><p>                              startQSearch.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startQSearch);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F4: {</p>
</li>
<li><p>                              Intent startBrowser  = new Intent();</p>
</li>
<li><p>                              startBrowser.setClassName(&quot;com.android.browser&quot;,&quot;com.android.browser.BrowserActivity&quot;);</p>
</li>
<li><p>                              startBrowser.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startBrowser);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F5: {</p>
</li>
<li><p>              /*</p>
</li>
<li><p>                      final ActivityManager am = (ActivityManager)this.getContext().getSystemService(Context.ACTIVITY_SERVICE);</p>
</li>
<li><p>                      List&lt;ActivityManager.RecentTaskInfo&gt; recentLs = am.getRecentTasks(512, ActivityManager.RECENT_IGNORE_UNAVAILABLE);</p>
</li>
<li><p>                      for(int i=1;i&lt;recentLs.size();i++){</p>
</li>
<li><p>                      Log.d(&quot;edward&quot;,i+&quot;==&quot;+recentLs.get(i).baseIntent.toString());</p>
</li>
<li><p>                      }*/</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F6: {</p>
</li>
<li><p>                              Intent startFaceBook  = new Intent();</p>
</li>
<li><p>                              startFaceBook.setClassName(&quot;com.facebook.katana&quot;,&quot;com.facebook.katana.LoginActivity&quot;);</p>
</li>
<li><p>                              startFaceBook.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startFaceBook);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F7: {</p>
</li>
<li><p>                              Intent startAqualMaiil  = new Intent();</p>
</li>
<li><p>                              startAqualMaiil.setClassName(&quot;org.kman.AquaMail&quot;,&quot;org.kman.AquaMail.ui.AccountListActivity&quot;);</p>
</li>
<li><p>                              startAqualMaiil.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startAqualMaiil);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F9: {</p>
</li>
<li><p>                              Intent startSkype  = new Intent();</p>
</li>
<li><p>                              startSkype.setClassName(&quot;com.skype.raider&quot;,&quot;com.skype.raider.Main&quot;);</p>
</li>
<li><p>                              startSkype.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startSkype);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F8: {</p>
</li>
<li><p>                              Intent startStore  = new Intent();</p>
</li>
<li><p>                              startStore.setClassName(&quot;com.android.vending&quot;,&quot;com.android.vending.AssetBrowserActivity&quot;);</p>
</li>
<li><p>                              startStore.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startStore);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F10: {</p>
</li>
<li><p>                              Intent startExplorer  = new Intent();</p>
</li>
<li><p>                              startExplorer.setClassName(&quot;com.android.rk&quot;,&quot;com.android.rk.RockExplorer&quot;);</p>
</li>
<li><p>                              startExplorer.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startExplorer);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F11: {</p>
</li>
<li><p>                              Intent startVideoPlayer  = new Intent();</p>
</li>
<li><p>                              startVideoPlayer.setClassName(&quot;android.rk.RockVideoPlayer&quot;,&quot;android.rk.RockVideoPlayer.RockVideoPlayer&quot;);</p>
</li>
<li><p>                              startVideoPlayer.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startVideoPlayer);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
<li><p>                      case KeyEvent.KEYCODE_F12: {</p>
</li>
<li><p>                              Intent startGallery  = new Intent();</p>
</li>
<li><p>                              startGallery.setClassName(&quot;com.android.gallery3d&quot;,&quot;com.android.gallery3d.app.Gallery&quot;);</p>
</li>
<li><p>                              startGallery.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startGallery);</p>
</li>
<li><p>                              return true;</p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>  private boolean isAltDown = false;</p>
<p>  case 57 : { //press Alt</p>
<p>isAltDown = true ;</p>
<p>   return true ;</p>
<p>  }</p>
<p>                       case KeyEvent.KEYCODE_F4: {</p>
<p>if(isAltDown){ //Alt + F4  , go home seems killing the top app</p>
<p>Intent startLauncher  = new Intent();</p>
<p>                               startLauncher.setClassName(&quot;com.android.launcher&quot;,&quot;com.android.launcher2.Launcher&quot;);</p>
<p>                               startLauncher.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
<p>                               this.getContext().startActivity(startLauncher);</p>
<p>}else{</p>
<p>                               Intent startCalendar  = new Intent();</p>
<p>                               startCalendar.setClassName(&quot;com.google.android.calendar&quot;,&quot;com.android.calendar.AllInOneActivity&quot;);</p>
<p>                               startCalendar.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
<p>                               this.getContext().startActivity(startCalendar);</p>
<p>  }</p>
<p>                               return true;</p>
<p>               }</p>
<p>onKeyUp</p>
<p>       return true;</p>
<p>            }</p>
<p>case 57 :{ //Alt</p>
<p>isAltDown = false;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>多个会话同时执行命令后history记录不全的解决方案</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%A4%9A%E4%B8%AA%E4%BC%9A%E8%AF%9D%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%90%8Ehistory%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%85%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="format-history"><a href="#format-history" class="headerlink" title="format history"></a>format history</h1><h1 id="save-in-bashrc"><a href="#save-in-bashrc" class="headerlink" title="save in ~/.bashrc"></a>save in ~/.bashrc</h1><p>USER_IP=<code>who -u am i 2&amp;gt;/dev/null| awk &#39;&#123;print $NF&#125;&#39;|sed -e &#39;s/[()]//g&#39;</code> </p>
<p>export HISTTIMEFORMAT=&quot;%Y-%m-%d %H:%M:%S  <code>whoami</code>@${USER_IP}: &quot;</p>
<p>export HISTFILESIZE=1000000</p>
<p>export PROMPT_COMMAND=&quot;history -a; history -r;  $PROMPT_COMMAND&quot;</p>
<p>shopt -s histappend</p>
<p>#bind ‘&quot;\e[A&quot;: history-search-backward’</p>
<p>#bind ‘&quot;\e[B&quot;: history-search-forward’</p>
<p>第一行是获取USER_IP也就是会话的ip</p>
<p>第二行是设置history的时间格式，这里设置的格式为：history序号 2018-09-29 19:33:59  <a href="mailto:&#x72;&#111;&#x6f;&#x74;&#64;&#x31;&#x39;&#x32;&#x2e;&#x31;&#54;&#x38;&#x2e;&#50;&#x35;&#46;&#x31;">&#x72;&#111;&#x6f;&#x74;&#64;&#x31;&#x39;&#x32;&#x2e;&#x31;&#54;&#x38;&#x2e;&#50;&#x35;&#46;&#x31;</a>: history</p>
<p>第三行设置的是history可以存放的历史命令最多可以存放1000000行</p>
<p>第四行 history -a 追加本次会话新执行的命令到.bash_history中也就是内存中的命令写入到历史文件中，history -r 读取历史文件中的所有历史命令到内存中的历史列表，即使内存中的列表中已经存在这条历史</p>
<p>第五行 打开histappend选项，将其修改为on 意为，推出这个回话后，回想shell中发送一个sighup的信号，告诉他我退出了</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>如果你不确定手中iPhone是否被苹果官方“限速”，可以下载CPUDasherX</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%89%8B%E4%B8%ADiPhone%E6%98%AF%E5%90%A6%E8%A2%AB%E8%8B%B9%E6%9E%9C%E5%AE%98%E6%96%B9%E2%80%9C%E9%99%90%E9%80%9F%E2%80%9D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BDCPUDasherX/</url>
    <content><![CDATA[<p>如果你不确定手中iPhone是否被苹果官方“限速”，可以下载CPU DasherX这个APP自检（iPhone 6标准值1400MHz。iPhone 6S 1848MHz，iPhone7 2350MHz），由于最近iPhone“电池门”的不断发酵，这个能准确读出iPhone CPU频率的APP火速蹿红。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>字符串拷贝问题</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p> memmove 可以拷贝到自身某一段内容    </p>
<p>由src所指内存区域复制count个字节到dest所指内存区域。</p>
<p> strncpy 拷贝到自身随时会覆盖</p>
<p>把src所指向的字符串中以src地址开始的前n个字节复制到dest所指的数组中，并返回dest。</p>
<p>void *memcpy(void *dest, const void *src, size_t n);</p>
<p> 从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中</p>
<p>char <em>strcpy(char</em> dest, const char *src);</p>
<p>功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间</p>
<p>说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。</p>
<p> 空字符问题   </p>
<p>  char [] a = “” 空字符串，判断 a[0] == 0</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>字符设备驱动、平台设备驱动、设备驱动模型、sysfs的关系</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E3%80%81%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E3%80%81%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E3%80%81sysfs%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>学习Linux设备驱动开发的过程中自然会遇到字符设备驱动、平台设备驱动、设备驱动模型和sysfs等相关概念和技术。对于初学者来说会非常困惑，甚至对Linux有一定基础的工程师而言，能够较好理解这些相关技术也相对不错了。要深刻理解其中的原理需要非常熟悉设备驱动相关的框架和模型代码。网络上有关这些技术的文章不少，但多是对其中的某一点进行阐述，很难找到对这些技术进行比较和关联的分析。对于开发者而言，能够熟悉某一点并分享出来已很难得，但对于专注传授技术和经验给学习者而言，横向比较关联各个驱动相关的知识点和纵向剖析Linux整个驱动软件层次是非常有必要的，也非常有意义。</p>
<p>本文依然是从需求的角度去理解以上知识点，存在即是合理，以上技术知识能够存在，即代表其有一定的作用。我们着重去理解每一个技术点的作用，并明确其在驱动开发中的角色。</p>
<p>一、设备驱动</p>
<p>Linux设备驱动分三种，包括字符设备驱动、块设备驱动和网络设备驱动。字符设备只能按字节流先后顺序访问设备内存，不能随机访问。鼠标、触摸屏、LCD等是字符设备的代表。块设备可以随机访问设备内存的任意地址，硬盘、SD卡、NAND FLASH是块设备的代表。网络设备指的是网卡一类使用socket套接字进行通信的设备。本文以字符设备为例讲述相关知识。</p>
<p>二、字符设备驱动</p>
<p>字符设备驱动框架请参考嵌入式企鹅圈的两篇文章：</p>
<p> Linux字符设备驱动剖析</p>
<p>Linux 设备文件的创建和mdev</p>
<p>1.    字符设备驱动纵向关系</p>
<p>从&lt; Linux字符设备驱动剖析&gt;可以看出，应用层访问设备驱动非常简单，即是通过open接口来最终获得设备驱动的操作接口集struct file_opertions.而open接口传入的参数是/dev目录下的设备名。而从&lt;Linux 设备文件的创建和mdev&gt;可以知道，设备名对应的设备文件节点inode会存储设备号，而驱动框架中的全局数组cdev_map则维护设备号和file_opertions的关系。即应用层到底层的关系主要是（忽略VFS这一层）：</p>
<p>设备名–&gt;设备号–&gt;file_opertions</p>
<p>Open函数返回的局部fd和file_opertions的关系(忽略进程数据结构)如下：</p>
<p>fd–&gt;file(当前进程数据结构成员)-&gt; file_opertions</p>
<p>这样，通过fd即可以获得file_opertions，即可以通过read、write等接口来调用驱动的读操作函数和写操作函数、ioctl函数等。</p>
<p>2.    字符设备驱动的任务</p>
<p>1）字符设备驱动最本质的任务应该是提供file_opertions的各个open、read、write、ioctl等接口的实现。</p>
<p>另外从以上的描述中，为了让应用层能够调用到底层的file_opertions还涉及到以下任务：</p>
<p>2）申请设备号，并将设备号和file_opertions注册（cdev_add接口）到驱动框架中的cdev_map数组。这点应该在字符设备驱动中负责，涉及到其主动向系统报备自己的存在。</p>
<p>3）在/dev目录中创建设备文件，内容包括设备号。这一点是否由字符设备驱动来负责商榷。字符设备驱动位于内核层，如果由其负责这个任务，那么驱动就得知道它要创建的设备名。简单的字符驱动还好，如果是USB等可插拔的设备，驱动怎么知道自己要创建什么设备名呢？有人说可以写明一套规则。确实如此，但如果把这套规则放到应用层，由应用程序开发人员去明确这个规则（mdev正是这样做的），会不会更好？因为是应用程序直接编程访问这个设备名对应的设备驱动的。所以字符设备驱动不应该直接负责设备文件的创建。</p>
<ol start="3">
<li>谁来创建设备文件</li>
</ol>
<p>       总得有人出来做吧，否则应用层怎么访问啊？</p>
<p>       一种方法就是用户在shell中使用mknod命令创建设备文件，同时传入设备名和设备号。这是人工的做法，很不科学。但它是一种演示的方法。</p>
<p>       另外一种方法就是依赖设备模型来辅助创建设备文件。这也是设备模型的作用之一。</p>
<ol start="4">
<li>字符设备驱动编程流程</li>
</ol>
<p>       1）定义struct file_opertions my_fops并实现其中的各个接口，如open、read、write、ioctl等接口。</p>
<p>       2）实现驱动的入口函数，如chardev_init</p>
<p>              static int __init chardev_init(void){</p>
<p>                     alloc_chrdev_region(&amp;devno,…);//申请设备号</p>
<p>                     my_cdev=cdev_alloc();</p>
<p>                     cdev_init(my_cdev,&amp;my_fops);</p>
<p>                     cdev_add(my_fops,devno, 1);//注册设备号和file_opertions</p>
<p>              }</p>
<p>       3）module_init(chardev_init);//宏定义该初始化入口函数。卸载流程不做解释。</p>
<p>       4）insmod加载这个module后，可以人工在shell命令行利用mknod创建设备文件。</p>
<p>       5）应用层即可以用open来打开设备文件来进行访问了。</p>
<p>5.    总结</p>
<p>可以看出，字符设备驱动的核心框架跟设备模型、平台设备驱动没有直接关系，不用他们也一样能够正常工作。</p>
<p>三、设备驱动模型</p>
<p>我们主要谈及设备驱动模型在linux驱动中的作用和角色，有关设备模型的原理和实现我们另文再述。</p>
<ol>
<li>设备驱动模型的作用</li>
</ol>
<p>1）设备驱动模型实现uevent机制，调用应用层的medv来自动创建设备文件。这在上面已经论述过。</p>
<p>2）设备驱动模型通过sysfs文件系统向用户层提供设备驱动视图，如下。</p>
<p>上图只是可视化的一种表达，有助于大家去理解设备模型，类似于windows的设备管理程序，在嵌入式linux里面并没有相关应用通过图形的方式来展现这种关系。但是用户可以通过命令窗口利用ls命名逐级访问/sys文件夹来获得各种总线、设备、驱动的信息和关系。可以看出，在/sys顶级目录，有三个关键的子目录，就是设备类、设备和总线。</p>
<p>设备是具体的一个个设备，在/sys/devices/是创建了实际的文件节点。而其他目录，如设备类和总线以下的子目录中出现的设备都是用符号链接指向/sys/devices/目录下的文件。</p>
<p>设备类是对/sys/devices/下的各种设备进行归类，以体现一类设备的公共属性，如鼠标和触摸屏都是属于input设备类。</p>
<p>总线目录是总线、设备、驱动模型的核心目录。因为设备和驱动都是依附在某种总线上的，如USB、PCI和平台总线等。设备和驱动正是依靠总线的管理功能才能找到对方，如设备注册到总线时去寻找驱动，而驱动注册的时候去寻找其能够支持的设备。</p>
<p>最重要的是，如果没有设备模型，那应用层很难知晓驱动和设备的关系，因为字符设备驱动并没有提供这些信息，那对于设备驱动的管理者而言会非常麻烦。</p>
<p>事实上，内核中的总线class、设备device和驱动device_driver都不会将所有的信息暴露给用户层，例如这三个数据结构都有对应的private数据结构，它用于内核对上下级总线设备驱动的链表关系维护。如果暴露给用户层，那容易被用户层修改而使系统混乱。实际上，用户层只关心三者的视图关联，至于他们的关联在底层怎么实现则不需要关心。</p>
<p>3）设备驱动模型提供统一的电源管理机制。很明显，我们在字符设备驱动的file_operations接口中并没有看到电源管理方面的接口。而对于操作系统来说，电源功耗管理必不可少。电源管理其实不应该由应用开发人员来负责，而是应该由系统来负责，例如手机很久没有触摸了，那会进入休眠状态。这种状态的改变应该由系统来完成，而各种设备进入睡眠模式也应该由系统来完成。因此file_operations不提供电源管理的接口给应用程序是合理的。而设备模型作为系统管理的一种机制，由它来提供电源管理是非常合理的。</p>
<p>       如设备device数据结构有struct dev_pm_info    power功耗属性参数，驱动device_driver数据结构有struct dev_pm_ops *pm功耗操作接口。</p>
<p>       4）设备驱动模型提供各种对象实例的引用计数，防止对象被应用层误删。设备模型的所有数据结构均是继承kobject而来，而kobject就提供基础的计数功能。</p>
<p>       5）设备驱动模型提供多一种方式给应用层，用户和内核可以通过sysfs进行交互，如通过修改/sys目录下设备的文件内容，即可以直接修改设备对应的参数。</p>
<p>       总结，设备驱动模型侧重于内核对总线、设备和驱动的管理，并向应用层暴露这些管理的信息，而字符设备驱动则侧重于设备驱动的功能实现。</p>
<ol start="2">
<li>设备驱动模型的核心接口</li>
</ol>
<p>       bus_register(struct bus_type *bus) 注册总线</p>
<p>device_add(struct device *dev) 注册设备</p>
<p>       driver_register(struct device_driver*drv) 注册驱动</p>
<p>       class_create(owner, name) 创建设备类</p>
<p>       等等</p>
<p>3.    设备驱动模型和字符设备驱动区别</p>
<p>设备驱动模型侧重于内核对总线、设备和驱动的管理，并向应用层暴露这些管理的信息，而字符设备驱动则侧重于设备驱动的功能实现。</p>
<p>四、sysfs文件系统</p>
<p>1.sysfs文件系统和设备驱动模型的关系</p>
<p>Sysfs文件系统是设备驱动模型得以向用户暴露其管理信息的载体。它们之间的关系如下：</p>
<p>1）设备驱动模型的上下级关系（如子设备和所属父设备）通过sysfs文件系统的父目录和子目录来体现。</p>
<p>2）设备驱动模型的平级关系（如设备类管理的设备和具体的设备的关系）则通过sysfs文件系统的目录符号链接来实现。</p>
<p>3）设备驱动模型的属性（如设备的参数和设备名，设备号等）则通过sysfs文件系统的文件内容来记录实现。</p>
<p>       4）设备驱动模型数据结构中的kobject对应于sysfs文件系统中的目录，而数据结构中的struct attribute成员则对应于sysfs文件系统中的文件。对应的意思是指继续与kobject的device、device_driver和bus等在向系统注册的过程中会调用sysfs的create_dir接口来创建对应的目录，而含有struct attribute成员属性的device、device_driver和bus等在向系统注册的过程中则会调用sysfs的sysfs_create_file接口来创建文件。</p>
<p>2.sysfs核心接口</p>
<p>       sysfs_create_file(struct kobject * kobj,const struct attribute * attr)创建属性文件</p>
<p>       sysfs_create_dir(struct kobject * kobj)创建目录</p>
<p>       int sysfs_open_file(struct inode *inode,struct file *file)打开sysfs文件系统格式的文件</p>
<p>       sysfs_read_file(struct file *file, char__user *buf, size_t count, loff_t *ppos) 读操作</p>
<p>       sysfs_write_file(struct file *file, constchar __user *buf, size_t count, loff_t *ppos) 写操作</p>
<ol start="3">
<li>sysfs文件系统与属性文件读写</li>
</ol>
<p>       sysfs_read_file是sysfs文件系统的读写入口，但是驱动需要向系统提供真正的读写操作，也即是struct sysfs_ops数据结构中的show和store接口。</p>
<p>       Sysfs是基于内存的文件系统，掉电即消失，sysfs所有的操作接口均是对内存中的内核数据结构进行访问操作。假如用户用cat命令去读取一个属性文件(如dev)的内容，那么会产生以下流程：</p>
<p>       1）fd=open(“dev”)-&gt;vfs_open(“dev”)-&gt;sysfs_open(“dev”)获取该文件的句柄</p>
<p>       2）read()-&gt;vfs_read()-&gt;sysfs_read_file()-&gt;sysfs_ops-&gt;show()该show接口即是设备在注册时产生属性文件，并向系统提供该文件的读接口。而读接口的实现中自然是对该属性参数的读访问。</p>
<p>       /sys挂载了sysfs文件系统，因此所有对/sys目录下的文件或者目录的操作都会通过sysfs文件的接口进行访问。</p>
<p>五、平台设备驱动</p>
<p>平台设备驱动中的“平台”指的是平台总线，即platform_bus_type，是linux众多总线中的一种，如USB总线、PCI总线、I2C总线等等。只不过平台总线是一种虚拟的总线，专门用来管理SOC上的控制器（如看门狗、LCD、RTC等等），它们都是CPU的总线上直接取址访问设备的。而USB、PCI等设备都有通过特定的时序来访问SOC芯片以外的设备。平台设备驱动体现的关系是设备驱动模型上的一个子集，将平台视为一种总线的概念，那两者的关系就会容易理解。</p>
<p>1.    平台设备驱动和设备驱动模型的关系</p>
<p>1）平台设备驱动接口在设备驱动模型视图上创建了相关的平台设备类(/sys/class/platform_bus)、平台总线(/sys/bus/platform)、平台设备(/sys/devices/).</p>
<p>2）平台设备(platform_device)和平台设备驱动(platform_driver)均注册到平台总线上，即在/sys/bus/platform/目录下创建相应的设备和驱动目录。</p>
<p>3）平台总线负责匹配注册到其上面的设备和驱动，匹配成功后回调用驱动的probe接口。</p>
<p>4）平台设备驱动利用设备驱动模型接口来辅助创建对应的设备文件（位于/dev/目录下）。</p>
<p>相关的接口包括：</p>
<p>platform_device_register(structplatform_device *pdev) 注册平台设备</p>
<p>platform_driver_register(structplatform_driver *drv) 注册平台设备驱动</p>
<p>两个接口的实现里面都会对平台驱动和设备进行匹配，匹配成功会调用驱动的probe接口。</p>
<ol start="2">
<li>平台设备驱动和字符设备驱动的关系</li>
</ol>
<p>       我们假设这个平台设备是字符设备。</p>
<p>平台设备驱动和字符设备驱动的关系始于驱动的probe接口，即在probe接口中实现字符设备驱动所要完成的任务，即通过alloc_chrdev_region申请设备号和通过cdev_add注册驱动的struct file_opertions.另外为了自动创建应用层访问的设备文件，还要调用class_create和device_create接口在平台设备类下创建对应的设备类和设备，并发出uevent事件，调用mdev来创建设备文件。</p>
<ol start="3">
<li>平台设备驱动的开发流程</li>
</ol>
<p>       1）将字符设备驱动的char_init函数的实现搬到platform_driver的probe接口中。</p>
<p>       2）在char_init中调用platform_device_register和platform_driver_register分别注册设备和驱动。其实，对于移植好的系统，platform_device_register是在linux启动的过程中完成的。因此char_init一般只有platform_driver_register注册驱动。</p>
<p>       详细的平台设备驱动的实现原理和开发流程另文再述。本次的重点是为了阐述字符设备驱动、设备驱动模型、sysfs和平台设备驱动之间的关系。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>安全模式detectSafeMode</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8FdetectSafeMode/</url>
    <content><![CDATA[<p>frameworks/base/services/java/com/android/server/wm/WindowManagerService.java</p>
<p>public boolean detectSafeMode() {</p>
<p>        if (!mInputMonitor.waitForInputDevicesReady(</p>
<p>                INPUT_DEVICES_READY_FOR_SAFE_MODE_DETECTION_TIMEOUT_MILLIS)) {</p>
<p>            Slog.w(TAG, &quot;Devices still not ready after waiting &quot;</p>
<p>                   + INPUT_DEVICES_READY_FOR_SAFE_MODE_DETECTION_TIMEOUT_MILLIS</p>
<p>                   + &quot; milliseconds before attempting to detect safe mode.&quot;);</p>
<p>        }</p>
<p>//有5种方式可以进行安全模式</p>
<p>开机时按下下面的其中一键，便进入安全模式</p>
<p>menu   S   DPAD_CENTER  鼠标/轨迹球   V-</p>
<p>        int menuState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_ANY,</p>
<p>                KeyEvent.KEYCODE_MENU);</p>
<p>        int sState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_ANY, KeyEvent.KEYCODE_S);</p>
<p>        int dpadState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_DPAD,</p>
<p>                KeyEvent.KEYCODE_DPAD_CENTER);</p>
<p>        int trackballState = mInputManager.getScanCodeState(-1, InputDevice.SOURCE_TRACKBALL,</p>
<p>                InputManagerService.BTN_MOUSE);</p>
<p>        int volumeDownState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_ANY,</p>
<p>                KeyEvent.KEYCODE_VOLUME_DOWN);</p>
<p>        mSafeMode = menuState &gt; 0 || sState &gt; 0 || dpadState &gt; 0 || trackballState &gt; 0</p>
<p>                || volumeDownState &gt; 0;</p>
<p>        try {</p>
<p>            if (SystemProperties.getInt(ShutdownThread.REBOOT_SAFEMODE_PROPERTY, 0) != 0) {</p>
<p>                mSafeMode = true;</p>
<p>                SystemProperties.set(ShutdownThread.REBOOT_SAFEMODE_PROPERTY, &quot;&quot;);</p>
<p>            }</p>
<p>        } catch (IllegalArgumentException e) {</p>
<p>        }</p>
<p>        if (mSafeMode) {</p>
<p>            Log.i(TAG, &quot;SAFE MODE ENABLED (menu=&quot; + menuState + &quot; s=&quot; + sState</p>
<p>                    + &quot; dpad=&quot; + dpadState + &quot; trackball=&quot; + trackballState + &quot;)&quot;);</p>
<p>        } else {</p>
<p>            Log.i(TAG, &quot;SAFE MODE not enabled&quot;);</p>
<p>        }</p>
<p>        mPolicy.setSafeMode(mSafeMode);</p>
<p>        return mSafeMode;</p>
<p>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>安装apk,恢复出厂设置后消失</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%AE%89%E8%A3%85apk,%E6%81%A2%E5%A4%8D%E5%87%BA%E5%8E%82%E8%AE%BE%E7%BD%AE%E5%90%8E%E6%B6%88%E5%A4%B1/</url>
    <content><![CDATA[<p>PackageManagerService.java</p>
<p> final File mPreinstallAppDelDir;</p>
<p> mPreinstallAppDelDir = new File(Environment.getRootDirectory(), &quot;preinstall_del&quot;);</p>
<p>if (mPreinstallAppDelDir.exists()) {</p>
<p>                    copyPackagesToAppInstallDir(mPreinstallAppDelDir);</p>
<p>                    deletePreinstallDir();</p>
<p>                }</p>
<p>    private void copyPackagesToAppInstallDir(File srcDir) {</p>
<p>        String[] files = srcDir.list();</p>
<p>        if (files == null) {</p>
<p>            Log.d(TAG, &quot;No files in app dir &quot; + srcDir);</p>
<p>            return;</p>
<p>        }</p>
<p>        int i;</p>
<p>        for (i=0; i&lt;files.length; i++) {</p>
<p>            File srcFile = new File(srcDir, files[i]);</p>
<p>            File destFile = new File(mAppInstallDir, files[i]);</p>
<p>            Slog.d(TAG, &quot;Copy &quot; + srcFile.getPath() + &quot; to &quot; +</p>
<p>                    destFile.getPath());</p>
<p>            if (!isPackageFilename(files[i])) {</p>
<p>                // Ignore entries which are not apk’s</p>
<p>                continue;</p>
<p>            }</p>
<p>            if (!FileUtils.copyFile(srcFile, destFile)) {</p>
<p>                Slog.d(TAG, &quot;Copy &quot; + srcFile.getPath() + &quot; to &quot; +</p>
<p>                        destFile.getPath() + &quot; fail&quot;);</p>
<p>                continue;</p>
<p>            }</p>
<p>            FileUtils.setPermissions(destFile.getAbsolutePath(), FileUtils.S_IRUSR</p>
<p>                    | FileUtils.S_IWUSR | FileUtils.S_IRGRP | FileUtils.S_IROTH, -1, -1);</p>
<p>        }</p>
<p>    }</p>
<p>    private void deletePreinstallDir() {</p>
<p>        String[] files = mPreinstallAppDelDir.list();</p>
<p>        if (files != null) {</p>
<p>            Slog.d(TAG, &quot;Ready to cleanup preinstall&quot;);</p>
<p>            SystemProperties.set(&quot;ctl.start&quot;, &quot;preinst_clr&quot;);</p>
<p>        }</p>
<p>    }</p>
<p> // 在PackageManagerService  也可以拷文件</p>
<p> private void copyMediaFiles(String src,String dest) {</p>
<p>   File srcFile = new File(src);</p>
<p>            File destFile = new File(dest);</p>
<p>     if(srcFile.exists()){</p>
<p>   if (!FileUtils.copyFile(srcFile, destFile)) {</p>
<p>                Slog.d(TAG, &quot;Copy &quot; + srcFile.getPath() + &quot; to &quot; + destFile.getPath() + &quot; fail&quot;);               </p>
<p>            }else{   </p>
<p>    Slog.d(TAG,&quot;Copy &quot; + srcFile.getPath() + &quot; to &quot; + destFile.getPath()+&quot; Done&quot;);</p>
<p>    FileUtils.setPermissions(destFile.getAbsolutePath(), FileUtils.S_IRUSR</p>
<p>                    | FileUtils.S_IWUSR | FileUtils.S_IRGRP | FileUtils.S_IROTH, -1, -1);</p>
<p>   }</p>
<p>   }else{</p>
<p>    Slog.d(TAG,&quot; Copy Media SrcFiles not exists !&quot;);</p>
<p>   }</p>
<p>  }</p>
<p>//init.rc</p>
<p>chmod 777 /system/bin/preinstall_cleanup.sh</p>
<p>service preinst_clr /system/bin/preinstall_cleanup.sh</p>
<p>    disabled</p>
<p>    class main</p>
<p>    oneshot</p>
<p>//preinstall_cleanup.sh</p>
<p>#!/system/bin/sh</p>
<p>mkdir /data/preinstall_del_try</p>
<p>mount -o rw,remount -t ext4 /dev/block/mtdblock8 /system</p>
<p>sleep 2</p>
<p>busybox rm system/preinstall_del/* -rf</p>
<p>mkdir /data/preinstall_del_ok</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>对比度亮度gama值</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%AF%B9%E6%AF%94%E5%BA%A6%E4%BA%AE%E5%BA%A6gama%E5%80%BC/</url>
    <content><![CDATA[<p>sys/class/graphics/fb0/dsp_lut </p>
<p>改权限</p>
<p>chmod 0666 /sys/class/graphics/fb0/dsp_lut</p>
<p> apk 调节后保存在</p>
<p>/data/data/com.rockchip.graphics/files/dsp_lut_bkp </p>
<p>把dsp-lut 数组填上</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>定时开关机</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%AE%9A%E6%97%B6%E5%BC%80%E5%85%B3%E6%9C%BA/</url>
    <content><![CDATA[<p>bionic/libc/kernel/common/linux/android_alarm.h </p>
<p>#define ANDROID_RTC_ALARM_SET _IOW(‘a’, 7, struct timespec)</p>
<p>services/jni/com_android_server_AlarmManagerService.cpp</p>
<p>static void android_server_AlarmManagerService_setAlarm(JNIEnv* env, jobject obj, jint fd, jlong seconds, jlong nanoseconds)</p>
<p>{</p>
<p>    struct timespec ts;</p>
<p>    ts.tv_sec = seconds;</p>
<p>    ts.tv_nsec = nanoseconds;</p>
<p>ALOGE(&quot; android_server_AlarmManagerService_setAlarm %lld.%09lld \n&quot;, seconds, nanoseconds);</p>
<p>int result = ioctl(fd, ANDROID_RTC_ALARM_SET, &amp;ts);</p>
<p>if (result &lt; 0)</p>
<p>{</p>
<p>        ALOGE(&quot;Unable to set alarm to %lld.%09lld: %s\n&quot;, seconds, nanoseconds, strerror(errno));</p>
<p>    }</p>
<p>}</p>
<p> static JNINativeMethod sMethods[] = { 中添加映射</p>
<p> {&quot;setAlarm&quot;, &quot;(IJJ)V&quot;, (void*)android_server_AlarmManagerService_setAlarm},</p>
<p>JNI接口定义好后，要开放接口给应用调用。 app从 AlarmManager中调用setAlarm方法</p>
<p>core/java/android/app/IAlarmManager.aidl</p>
<p>void setAlarm(int type, long triggerAtTime, long windowLength,</p>
<p>            long interval, in PendingIntent operation, in WorkSource workSource);</p>
<p>core/java/android/app/AlarmManager.java</p>
<p>public void setAlarm(int type, long triggerAtMillis, PendingIntent operation) {       </p>
<p>  if (triggerAtMillis &lt; 0) {</p>
<p>            /* NOTYET</p>
<p>            if (mAlwaysExact) {</p>
<p>                // Fatal error for KLP+ apps to use negative trigger times</p>
<p>                throw new IllegalArgumentException(&quot;Invalid alarm trigger time &quot;</p>
<p>                        + triggerAtMillis);</p>
<p>            }</p>
<p>            */</p>
<p>            triggerAtMillis = 0;</p>
<p>        }</p>
<p>        try {</p>
<p>            mService.setAlarm(type, triggerAtMillis, legacyExactLength(), 0, operation,</p>
<p>                    null);</p>
<p>        } catch (RemoteException ex) {</p>
<p>        }</p>
<p>    }</p>
<p>services/java/com/android/server/AlarmManagerService.java</p>
<p>private native void setAlarm(int fd, long seconds, long nanoseconds);</p>
<p>  @Override</p>
<p>    public void setAlarm(int type, long triggerAtTime, long windowLength, long interval,</p>
<p>            PendingIntent operation, WorkSource workSource) {</p>
<p>        if (workSource != null) {</p>
<p>            mContext.enforceCallingPermission(</p>
<p>                    android.Manifest.permission.UPDATE_DEVICE_STATS,</p>
<p>                    &quot;AlarmManager.set&quot;);</p>
<p>        } </p>
<p>long when = triggerAtTime;</p>
<p>long alarmSeconds, alarmNanoseconds;</p>
<p>            if (when &lt; 0) {</p>
<p>                alarmSeconds = 0;</p>
<p>                alarmNanoseconds = 0;</p>
<p>            } else {</p>
<p>                alarmSeconds = when / 1000;</p>
<p>                alarmNanoseconds = (when % 1000) * 1000 * 1000;</p>
<p>            }                 </p>
<p>        setAlarm(mDescriptor, alarmSeconds, alarmNanoseconds);</p>
<p>    }</p>
<p>drivers/staging/android/alarm-dev.c</p>
<p>case ANDROID_RTC_ALARM_SET:</p>
<p>case ANDROID_ALARM_SET_RTC:</p>
<p>if (copy_from_user(&amp;ts, (void __user *)arg, sizeof(ts)))</p>
<p>return -EFAULT;</p>
<p>break;</p>
<p>}</p>
<p>case ANDROID_RTC_ALARM_SET:</p>
<p>struct rtc_time alarm_rtc_tm;  </p>
<p>struct rtc_wkalrm wkalrm ; </p>
<p>struct rtc_device *rtc_dev;</p>
<p>rtc_time_to_tm(ts-&gt;tv_sec, &amp;alarm_rtc_tm);</p>
<p>wkalrm.time = alarm_rtc_tm;</p>
<p>wkalrm.enabled = 1;</p>
<p>rtc_dev = alarmtimer_get_rtcdev();</p>
<p>// printk(&quot; %d %d %d %d %d %d %d \n&quot;,alarm_rtc_tm.tm_wday,alarm_rtc_tm.tm_year,alarm_rtc_tm.tm_mon,alarm_rtc_tm.tm_mday,</p>
<p>// alarm_rtc_tm.tm_hour,alarm_rtc_tm.tm_min,alarm_rtc_tm.tm_sec); </p>
<p>rv = rtc_set_alarm(rtc_dev,&amp;wkalrm);</p>
<p>break;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>导出所有修改文件</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%AF%BC%E5%87%BA%E6%89%80%E6%9C%89%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>git diff master mstar –name-only | xargs cp –parent -arv -t ../cmp/project</p>
<p>git diff master mstar –name-only |xargs cp –parent -arv -t ../cmp/sdk/</p>
<p>7z a sdk.diff.7z cmp/* -r -mx9 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>小儿感冒发烧常用药</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B0%8F%E5%84%BF%E6%84%9F%E5%86%92%E5%8F%91%E7%83%A7%E5%B8%B8%E7%94%A8%E8%8D%AF/</url>
    <content><![CDATA[<p>999 小儿氨酚黄那敏颗粒 （适用于缓解儿童普通感冒及流行性感冒引起的发热、头痛、四肢酸痛、打喷嚏、流鼻涕、鼻塞、咽痛等症状。）6g<em>10 8.5元<br>葵花  小儿柴桂退热颗粒（发汗解表清里退热）<br>5g</em>10  29.5元<br>迪尔诺  布洛芬混悬液 （38.5以上退热）<br>美林 布洛芬混悬液  35ml  14元<br>小儿板蓝根颗粒 （感冒时提高免疫力）<br>万通  板蓝根颗粒  5g*18  19.8元<br>健儿清解液 （清热解毒，祛痰止咳，消滞和中。口腔糜烂）120ml  22.5元<br>蛇胆川贝散（清肺，止咳，除痰）</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>屏刷新率 fps</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B1%8F%E5%88%B7%E6%96%B0%E7%8E%87%20fps/</url>
    <content><![CDATA[<p>logcat</p>
<p>I/<a href="145">Gralloc</a>: refresh rate = 60.00 Hz</p>
<p>D/hwcomposer(  145): fb_fps=60.000000</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>屏蔽快捷方式的蓝牙选项</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B1%8F%E8%94%BD%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E7%9A%84%E8%93%9D%E7%89%99%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<p>— a/packages/apps/Settings/AndroidManifest.xml</p>
<p>+++ b/packages/apps/Settings/AndroidManifest.xml</p>
<p>@@ -239,7 +239,7 @@</p>
<p>                 &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</p>
<p>                 &lt;action android:name=&quot;android.settings.BLUETOOTH_SETTINGS&quot; /&gt;</p>
<p>                 &lt;category android:name=&quot;android.intent.category.VOICE_LAUNCH&quot; /</p>
<ul>
<li>               &lt;category android:name=&quot;com.android.settings.SHORTCUT&quot; /&gt;</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>屏蔽某些语言</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B1%8F%E8%94%BD%E6%9F%90%E4%BA%9B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>屏蔽 西班牙语和葡萄牙语</p>
<p>frameworks/base/core/java/com/android/internal/app/LocalePicker.java中加入标记的这几行就可以把这两种语言去除</p>
<p>public static ArrayAdapter&lt;LocaleInfo&gt; constructAdapter(Context context,</p>
<p>            int layoutId, int fieldId) {</p>
<p>   for (int i = 0 ; i &lt; origSize; i++ ) {</p>
<p>            final String s = locales[i];</p>
<p>            final int len = s.length();</p>
<p>            if (len == 5) {</p>
<p>                String language = s.substring(0, 2);</p>
<p>                String country = s.substring(3, 5);</p>
<p>    if(language.equals(&quot;es&quot;))</p>
<p>                {</p>
<p>                        continue;</p>
<p>                }</p>
<p>                if(language.equals(&quot;pt&quot;))</p>
<p>                {</p>
<p>                        continue;</p>
<p>                }</p>
<p>                final Locale l = new Locale(language, country);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>屏蔽的包类</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B1%8F%E8%94%BD%E7%9A%84%E5%8C%85%E7%B1%BB/</url>
    <content><![CDATA[<p>屏蔽的包/类</p>
<p>com.google.android.maps.LatitudeActivity;</p>
<p>com.google.android.googlequicksearchbox.SearchActivity;</p>
<p>com.google.android.googlequicksearchbox.VoiceSearchActivity</p>
<p>com.android.contacts.activities.PeopleActivity</p>
<p>com.android.vending.AssetBrowserActivity</p>
<p>================================================================</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/AllAppsList.java</p>
<p>@@ -25,6 +25,7 @@ import android.content.Intent;</p>
<p> import android.content.pm.ActivityInfo;</p>
<p> import android.content.pm.PackageManager;</p>
<p> import android.content.pm.ResolveInfo;</p>
<p>+import android.os.SystemProperties;</p>
<p> /**</p>
<p>@@ -45,12 +46,13 @@ class AllAppsList {</p>
<p>     public ArrayList&lt;ApplicationInfo&gt; modified = new ArrayList&lt;ApplicationInfo&gt;();</p>
<p>     private IconCache mIconCache;</p>
<p>-</p>
<ul>
<li>      private final String hideapps;</li>
</ul>
<p>     /**</p>
<p>      * Boring constructor.</p>
<p>      */</p>
<p>     public AllAppsList(IconCache iconCache) {</p>
<p>         mIconCache = iconCache;</p>
<ul>
<li>              hideapps = SystemProperties.get(&quot;ro.bx.hidepackages&quot;,&quot;&quot;);   //在buid.prop 中设置需要屏蔽的包 以;号隔开</li>
</ul>
<p>     }</p>
<p>     /**</p>
<p>@@ -63,6 +65,26 @@ class AllAppsList {</p>
<p>         if (findActivity(data, info.componentName)) {</p>
<p>             return;</p>
<p>         }</p>
<p>+</p>
<ul>
<li><p>              if(&quot;com.google.android.maps.LatitudeActivity&quot;.equals(info.componentName.getClassName()))  //以类名来屏蔽图标</p>
</li>
<li><p>                      return ;</p>
</li>
<li><p>              if(&quot;com.google.android.googlequicksearchbox.VoiceSearchActivity&quot;.equals(info.componentName.getClassName()))</p>
</li>
<li><p>                      return;</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>              String [] hidedapps = null;</p>
</li>
<li><p>                       if(!hideapps.equals(&quot;&quot;)){</p>
</li>
<li><p>                       hidedapps =    hideapps.split(&quot;;&quot;);</p>
</li>
<li><p>                       }</p>
</li>
<li><p>              if(hidedapps!=null){</p>
</li>
<li><p>                      for(int i=0;i&lt;hidedapps.length;i++){</p>
</li>
<li><p>                              if(hidedapps[i].equals(&quot;&quot;)) continue;</p>
</li>
<li><p>                               if(hidedapps[i].equals(info.componentName.getPackageName()))</p>
</li>
<li><p>                                      return ;</p>
</li>
<li><p>                              }</p>
</li>
</ul>
<p>+</p>
<ul>
<li>              }</li>
</ul>
<p>+</p>
<p>+</p>
<p>         data.add(info);</p>
<p>         added.add(info);</p>
<p>     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>屏蔽通知栏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B1%8F%E8%94%BD%E9%80%9A%E7%9F%A5%E6%A0%8F/</url>
    <content><![CDATA[<p>屏蔽通知面板</p>
<p>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletTicker.java</p>
<p>@@ -179,10 +179,10 @@ public class TabletTicker</p>
<p>             if (mCurrentView != null) {</p>
<p>                 if (mWindow == null) {</p>
<p>                     mWindow = makeWindow();</p>
<ul>
<li>                   mWindowManager.addView(mWindow, mWindow.getLayoutParams());</li>
</ul>
<ul>
<li>                   //mWindowManager.addView(mWindow, mWindow.getLayoutParams());</li>
</ul>
<p>                 }</p>
<ul>
<li>               mWindow.addView(mCurrentView);</li>
</ul>
<ul>
<li>               //mWindow.addView(mCurrentView);</li>
</ul>
<p>                 sendEmptyMessageDelayed(MSG_ADVANCE, ADVANCE_DELAY);</p>
<p>                 break;</p>
<p>             }</p>
<p>屏蔽通知的图标</p>
<p>frameworks/base/packages/SystemUI/res/layout/system_bar_notification_area.xml</p>
<p>com.android.systemui.statusbar.tablet.NotificationIconArea</p>
<p>notificationIcons</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>展讯调试总结</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B1%95%E8%AE%AF%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>1.IO配置</p>
<p>u-boot15/board/spreadtrum/xxx/pinmap-xxx.c</p>
<p>{REG_PIN_SDA2,                          BITS_PIN_AF(0)},</p>
<p>{REG_MISC_PIN_SDA2,                     BITS_PIN_DS(1)|BIT_PIN_WPUS|BIT_PIN_WPU|BIT_PIN_SLP_AP|BIT_PIN_SLP_WPU|BIT_PIN_SLP_Z},</p>
<p>BITS_PIN_AF(n) n=0,1,2,3功能　　具体功能可参考SCxxxx_GPIO_Spec_Vxxx.xlsx</p>
<p>BITS_PIN_DS　　　　　　驱动能力(ata测试中导线长或者高速信号可以调整)</p>
<p>BIT_PIN_WPUS　　　　　强上拉（强是指电流，选择阻值较小的电阻）</p>
<p>BIT_PIN_NULL　　　　　  没强上拉</p>
<p>BIT_PIN_WPU　　　　　 上拉(初始电平为高)</p>
<p>BIT_PIN_WPD　　　　　 下拉(初始电平为低)</p>
<p>BIT_PIN_NUL　　　　　   既不上拉也不下拉</p>
<p>BIT_PIN_SLP_AP                  跟随AP休眠</p>
<p>BIT_PIN_SLP_ALL               可能是跟随BP休眠</p>
<p>BIT_PIN_SLP_NONE           不休眠</p>
<p>BIT_PIN_SLP_NUL　　      休眠时既不上拉也不下拉</p>
<p>BIT_PIN_SLP_WPD　　     休眠时下拉</p>
<p>BIT_PIN_SLP_WPU　　     休眠时上拉</p>
<p>BIT_PIN_SLP_OE　　　    休眠时输出</p>
<p>BIT_PIN_SLP_IE　　　      休眠时输入</p>
<p>BIT_PIN_SLP_Z　　　      休眠时高阻</p>
<p>2.按键</p>
<p>gpio作为按键</p>
<p>配置为BITS_PIN_DS(1)|BIT_PIN_NULL|BIT_PIN_WPU|BIT_PIN_SLP_AP|BIT_PIN_SLP_WPU|BIT_PIN_SLP_IE},这个配置出错可能导致低电流大</p>
<p>keypad模块的按键</p>
<p>KEYIN作为为列</p>
<p>KEYOUT作为行</p>
<p>如KEYOUT0,KEYIN2,那么</p>
<p>sprd,row = &lt;0&gt;;</p>
<p>sprd,column = &lt;2&gt;;</p>
<p>3.lcd</p>
<p>xxx-common.dtsi包含的使用的默认屏</p>
<p>u-boot15/drivers/video/sprdfb/lcd/Makefile</p>
<p>u-boot15/drivers/video/sprdfb/sprdfb_panel.c</p>
<p>u-boot15/drivers/video/sprdfb/sprdfb_spi.c(spi的可能需要修改这里的SPI_RS(选择发数据还是命令)脚)</p>
<p>u-boot15/include/configs/xxxx.h</p>
<p>如果使用spi类型的屏,spi这个展讯这里默认是收发用一根线的，当然也可配置成标准的SPI线</p>
<p>如果开启了te脚检测spi_te_gpio，屏也要开启te,否则会出现卡顿的情况</p>
<p>4.增大音量，工具Audiotester,可参考</p>
<p><a href="https://wenku.baidu.com/view/e454011a580216fc700afdf3.html">https://wenku.baidu.com/view/e454011a580216fc700afdf3.html</a></p>
<p>5.当按键不好用时，可安装应用Vysor来控制屏幕(ubuntu系统可以在谷歌浏览器安装Vysor插件)</p>
<p>6.分区大小更改</p>
<p>直接修改device/sprd/sharkle/xxx/xxx.xml中size的大小(这里单位是M)</p>
<p>7.编译与烧写</p>
<p>编译uboot  make bootloader</p>
<p>烧写uboot fastboot flash uboot u-boot-sign.bin</p>
<p>sudo fastboot -S 100M flash system system.img</p>
<p>8.gpio和ldo调试</p>
<p>cat /d/gpio可以查看引脚状态，包括gpio_request有没有申请成功，引脚现在的状态(输入或输出，高电平或低电平)</p>
<p>     gpio-49  (                   |xxxx1                )in(输入)  hi(高电平)</p>
<p>　 gpio-138 (                   |xxxx2                 )out(输出) lo(低电平)</p>
<p>/d/regulator可查看ldo的使用情况，以及配置的最大和最小电压</p>
<p>9.暗码</p>
<p><em>#</em>#83781#<em>#</em>,进入工程模式(EngineerMode.apk)</p>
<p><em>#</em>#83789#<em>#</em>,测试模式</p>
<p><em>#</em>#2266#<em>#</em>,进入sgps测试，选择INF,打开sgps switch,可在SA见到卫星信号。</p>
<p>10.cat /proc/meminfo只能看到部分内存容量(有部分没算在这)</p>
<p>11.展讯网站</p>
<p>提问题<a href="http://222.66.158.139:2008/cqweb/#">http://222.66.158.139:2008/cqweb/#</a></p>
<p>资料<a href="https://isupport.spreadtrum.com/iSupport/apply/faq_list#tab-">https://isupport.spreadtrum.com/iSupport/apply/faq_list#tab-</a></p>
<p>12.EXINT的管脚有硬件去抖的功能,如使用EXINT12,pinmap配置成EXINT12,</p>
<p>           gpios = &lt;&amp;ap_eic 12 1&gt;;</p>
<p>13.刚开机,串口打印一点就停止输出了,找到对应的dts文件,将loglevel=1改成loglevel=8或者adb shell,</p>
<p>echo 8 &gt;/proc/sys/kernel/printk</p>
<p>14.测试休眠底电流的时候，userdebug版本要关闭modem log,否则无法正常休眠。</p>
<p>15.展讯平台sysdump <a href="https://blog.csdn.net/mike8825/article/details/85039187">https://blog.csdn.net/mike8825/article/details/85039187</a></p>
<p>16.音频参数不用格式化升级</p>
<p>17.进入usb下载方式(这里的加号是短路的意思)</p>
<p>        1.KEYIN0+KEYOUT0;2.KEYIN0+GND;3.U1TXD+GND</p>
<p>18.spi串口屏可以读寄存器来实现esd protect，可以让展讯提供补丁 。</p>
<p>19.配置内核kuconfig/kmconfig/kdconfig</p>
<p>20.展讯工具介绍<a href="https://blog.csdn.net/qq_23922117/article/details/81144364">https://blog.csdn.net/qq_23922117/article/details/81144364</a></p>
<p>21.pwma,pwmb,pwm的基地址分别是0x40260000,0x40260020,0x40260040,dts默认只配置了一路</p>
<p>        pwma有多个引脚可以设置，但只能选其中一个作为pwma,pwmb,pwmc类似，要参考sprd背光pwm来使用，否认会出现休眠死机的情况。</p>
<p>——————— </p>
<p>作者：那颗流星的秘密 </p>
<p>来源：CSDN </p>
<p>原文：<a href="https://blog.csdn.net/mike8825/article/details/80977278">https://blog.csdn.net/mike8825/article/details/80977278</a> </p>
<p>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>工作四象限法则</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B7%A5%E4%BD%9C%E5%9B%9B%E8%B1%A1%E9%99%90%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<p>重要且紧急 —— 优先解决立即做            重要不紧急 —— 制定计划去做            </p>
<p>事项1                </p>
<p>事项2                </p>
<p>事项3                </p>
<p>……</p>
<p>事项1                </p>
<p>事项2                </p>
<p>事项3                </p>
<p>……</p>
<p>紧急不重要 —— 有空再说            不重要不紧急 —— 交给别人去做            </p>
<p>事项1                </p>
<p>事项2                </p>
<p>事项3                </p>
<p>……</p>
<p>事项1                </p>
<p>事项2                </p>
<p>事项3                </p>
<p>……</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>常见MIME类型</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B8%B8%E8%A7%81MIME%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>常见MIME类型</p>
<p>按照字母顺序排列的MIME_type扩展名</p>
<p>扩展名  类型/子类型 </p>
<ul>
<li> application/octet-stream </li>
</ul>
<p>323  text/h323 </p>
<p>acx  application/internet-property-stream </p>
<p>ai  application/postscript </p>
<p>aif  audio/x-aiff </p>
<p>aifc  audio/x-aiff </p>
<p>aiff  audio/x-aiff </p>
<p>asf  video/x-ms-asf </p>
<p>asr  video/x-ms-asf </p>
<p>asx  video/x-ms-asf </p>
<p>au  audio/basic </p>
<p>avi  video/x-msvideo </p>
<p>axs  application/olescript </p>
<p>bas  text/plain </p>
<p>bcpio  application/x-bcpio </p>
<p>bin  application/octet-stream </p>
<p>bmp  image/bmp </p>
<p>c  text/plain </p>
<p>cat  application/vnd.ms-pkiseccat </p>
<p>cdf  application/x-cdf </p>
<p>cer  application/x-x509-ca-cert </p>
<p>class  application/octet-stream </p>
<p>clp  application/x-msclip </p>
<p>cmx  image/x-cmx </p>
<p>cod  image/cis-cod </p>
<p>cpio  application/x-cpio </p>
<p>crd  application/x-mscardfile </p>
<p>crl  application/pkix-crl </p>
<p>crt  application/x-x509-ca-cert </p>
<p>csh  application/x-csh </p>
<p>css  text/css </p>
<p>dcr  application/x-director </p>
<p>der  application/x-x509-ca-cert </p>
<p>dir  application/x-director </p>
<p>dll  application/x-msdownload </p>
<p>dms  application/octet-stream </p>
<p>doc  application/msword </p>
<p>dot  application/msword </p>
<p>dvi  application/x-dvi </p>
<p>dxr  application/x-director </p>
<p>eps  application/postscript </p>
<p>etx  text/x-setext </p>
<p>evy  application/envoy </p>
<p>exe  application/octet-stream </p>
<p>fif  application/fractals </p>
<p>flr  x-world/x-vrml </p>
<p>gif  image/gif </p>
<p>gtar  application/x-gtar </p>
<p>gz  application/x-gzip </p>
<p>h  text/plain </p>
<p>hdf  application/x-hdf </p>
<p>hlp  application/winhlp </p>
<p>hqx  application/mac-binhex40 </p>
<p>hta  application/hta </p>
<p>htc  text/x-component </p>
<p>htm  text/html </p>
<p>html  text/html </p>
<p>htt  text/webviewhtml </p>
<p>ico  image/x-icon </p>
<p>ief  image/ief </p>
<p>iii  application/x-iphone </p>
<p>ins  application/x-internet-signup </p>
<p>isp  application/x-internet-signup </p>
<p>jfif  image/pipeg </p>
<p>jpe  image/jpeg </p>
<p>jpeg  image/jpeg </p>
<p>jpg  image/jpeg </p>
<p>js  application/x-javascript </p>
<p>latex  application/x-latex </p>
<p>lha  application/octet-stream </p>
<p>lsf  video/x-la-asf </p>
<p>lsx  video/x-la-asf </p>
<p>lzh  application/octet-stream </p>
<p>m13  application/x-msmediaview </p>
<p>m14  application/x-msmediaview </p>
<p>m3u  audio/x-mpegurl </p>
<p>man  application/x-troff-man </p>
<p>mdb  application/x-msaccess </p>
<p>me  application/x-troff-me </p>
<p>mht  message/rfc822 </p>
<p>mhtml  message/rfc822 </p>
<p>mid  audio/mid </p>
<p>mny  application/x-msmoney </p>
<p>mov  video/quicktime </p>
<p>movie  video/x-sgi-movie </p>
<p>mp2  video/mpeg </p>
<p>mp3  audio/mpeg </p>
<p>mpa  video/mpeg </p>
<p>mpe  video/mpeg </p>
<p>mpeg  video/mpeg </p>
<p>mpg  video/mpeg </p>
<p>mpp  application/vnd.ms-project </p>
<p>mpv2  video/mpeg </p>
<p>ms  application/x-troff-ms </p>
<p>mvb  application/x-msmediaview </p>
<p>nws  message/rfc822 </p>
<p>oda  application/oda </p>
<p>p10  application/pkcs10 </p>
<p>p12  application/x-pkcs12 </p>
<p>p7b  application/x-pkcs7-certificates </p>
<p>p7c  application/x-pkcs7-mime </p>
<p>p7m  application/x-pkcs7-mime </p>
<p>p7r  application/x-pkcs7-certreqresp </p>
<p>p7s  application/x-pkcs7-signature </p>
<p>pbm  image/x-portable-bitmap </p>
<p>pdf  application/pdf </p>
<p>pfx  application/x-pkcs12 </p>
<p>pgm  image/x-portable-graymap </p>
<p>pko  application/ynd.ms-pkipko </p>
<p>pma  application/x-perfmon </p>
<p>pmc  application/x-perfmon </p>
<p>pml  application/x-perfmon </p>
<p>pmr  application/x-perfmon </p>
<p>pmw  application/x-perfmon </p>
<p>pnm  image/x-portable-anymap </p>
<p>pot,  application/vnd.ms-powerpoint </p>
<p>ppm  image/x-portable-pixmap </p>
<p>pps  application/vnd.ms-powerpoint </p>
<p>ppt  application/vnd.ms-powerpoint </p>
<p>prf  application/pics-rules </p>
<p>ps  application/postscript </p>
<p>pub  application/x-mspublisher </p>
<p>qt  video/quicktime </p>
<p>ra  audio/x-pn-realaudio </p>
<p>ram  audio/x-pn-realaudio </p>
<p>ras  image/x-cmu-raster </p>
<p>rgb  image/x-rgb </p>
<p>rmi  audio/mid <a href="http://www.dreamdu.com/">http://www.dreamdu.com</a> </p>
<p>roff  application/x-troff </p>
<p>rtf  application/rtf </p>
<p>rtx  text/richtext </p>
<p>scd  application/x-msschedule </p>
<p>sct  text/scriptlet </p>
<p>setpay  application/set-payment-initiation </p>
<p>setreg  application/set-registration-initiation </p>
<p>sh  application/x-sh </p>
<p>shar  application/x-shar </p>
<p>sit  application/x-stuffit </p>
<p>snd  audio/basic </p>
<p>spc  application/x-pkcs7-certificates </p>
<p>spl  application/futuresplash </p>
<p>src  application/x-wais-source </p>
<p>sst  application/vnd.ms-pkicertstore </p>
<p>stl  application/vnd.ms-pkistl </p>
<p>stm  text/html </p>
<p>svg  image/svg+xml </p>
<p>sv4cpio  application/x-sv4cpio </p>
<p>sv4crc  application/x-sv4crc </p>
<p>swf  application/x-shockwave-flash </p>
<p>t  application/x-troff </p>
<p>tar  application/x-tar </p>
<p>tcl  application/x-tcl </p>
<p>tex  application/x-tex </p>
<p>texi  application/x-texinfo </p>
<p>texinfo  application/x-texinfo </p>
<p>tgz  application/x-compressed </p>
<p>tif  image/tiff </p>
<p>tiff  image/tiff </p>
<p>tr  application/x-troff </p>
<p>trm  application/x-msterminal </p>
<p>tsv  text/tab-separated-values </p>
<p>txt  text/plain </p>
<p>uls  text/iuls </p>
<p>ustar  application/x-ustar </p>
<p>vcf  text/x-vcard </p>
<p>vrml  x-world/x-vrml </p>
<p>wav  audio/x-wav </p>
<p>wcm  application/vnd.ms-works </p>
<p>wdb  application/vnd.ms-works </p>
<p>wks  application/vnd.ms-works </p>
<p>wmf  application/x-msmetafile </p>
<p>wps  application/vnd.ms-works </p>
<p>wri  application/x-mswrite </p>
<p>wrl  x-world/x-vrml </p>
<p>wrz  x-world/x-vrml </p>
<p>xaf  x-world/x-vrml </p>
<p>xbm  image/x-xbitmap </p>
<p>xla  application/vnd.ms-excel </p>
<p>xlc  application/vnd.ms-excel </p>
<p>xlm  application/vnd.ms-excel </p>
<p>xls  application/vnd.ms-excel </p>
<p>xlt  application/vnd.ms-excel </p>
<p>xlw  application/vnd.ms-excel </p>
<p>xof  x-world/x-vrml </p>
<p>xpm  image/x-xpixmap </p>
<p>xwd  image/x-xwindowdump </p>
<p>z  application/x-compress </p>
<p>zip  application/zip </p>
<p>按照功能排列的MIME_type类型</p>
<p>类型/子类型  扩展名 </p>
<p>application/envoy  evy </p>
<p>application/fractals  fif </p>
<p>application/futuresplash  spl </p>
<p>application/hta  hta </p>
<p>application/internet-property-stream  acx </p>
<p>application/mac-binhex40  hqx </p>
<p>application/msword  doc </p>
<p>application/msword  dot </p>
<p>application/octet-stream  * </p>
<p>application/octet-stream  bin </p>
<p>application/octet-stream  class </p>
<p>application/octet-stream  dms </p>
<p>application/octet-stream  exe </p>
<p>application/octet-stream  lha </p>
<p>application/octet-stream  lzh </p>
<p>application/oda  oda </p>
<p>application/olescript  axs </p>
<p>application/pdf  pdf </p>
<p>application/pics-rules  prf </p>
<p>application/pkcs10  p10 </p>
<p>application/pkix-crl  crl </p>
<p>application/postscript  ai </p>
<p>application/postscript  eps </p>
<p>application/postscript  ps </p>
<p>application/rtf  rtf </p>
<p>application/set-payment-initiation  setpay </p>
<p>application/set-registration-initiation  setreg </p>
<p>application/vnd.ms-excel  xla </p>
<p>application/vnd.ms-excel  xlc </p>
<p>application/vnd.ms-excel  xlm </p>
<p>application/vnd.ms-excel  xls </p>
<p>application/vnd.ms-excel  xlt </p>
<p>application/vnd.ms-excel  xlw </p>
<p>application/vnd.ms-outlook  msg </p>
<p>application/vnd.ms-pkicertstore  sst </p>
<p>application/vnd.ms-pkiseccat  cat </p>
<p>application/vnd.ms-pkistl  stl </p>
<p>application/vnd.ms-powerpoint  pot </p>
<p>application/vnd.ms-powerpoint  pps </p>
<p>application/vnd.ms-powerpoint  ppt </p>
<p>application/vnd.ms-project  mpp </p>
<p>application/vnd.ms-works  wcm </p>
<p>application/vnd.ms-works  wdb </p>
<p>application/vnd.ms-works  wks </p>
<p>application/vnd.ms-works  wps </p>
<p>application/winhlp  hlp </p>
<p>application/x-bcpio  bcpio </p>
<p>application/x-cdf  cdf </p>
<p>application/x-compress  z </p>
<p>application/x-compressed  tgz </p>
<p>application/x-cpio  cpio </p>
<p>application/x-csh  csh </p>
<p>application/x-director  dcr </p>
<p>application/x-director  dir </p>
<p>application/x-director  dxr </p>
<p>application/x-dvi  dvi </p>
<p>application/x-gtar  gtar </p>
<p>application/x-gzip  gz </p>
<p>application/x-hdf  hdf </p>
<p>application/x-internet-signup  ins </p>
<p>application/x-internet-signup  isp </p>
<p>application/x-iphone  iii </p>
<p>application/x-javascript  js </p>
<p>application/x-latex  latex </p>
<p>application/x-msaccess  mdb </p>
<p>application/x-mscardfile  crd </p>
<p>application/x-msclip  clp </p>
<p>application/x-msdownload  dll </p>
<p>application/x-msmediaview  m13 </p>
<p>application/x-msmediaview  m14 </p>
<p>application/x-msmediaview  mvb </p>
<p>application/x-msmetafile  wmf </p>
<p>application/x-msmoney  mny </p>
<p>application/x-mspublisher  pub </p>
<p>application/x-msschedule  scd </p>
<p>application/x-msterminal  trm </p>
<p>application/x-mswrite  wri </p>
<p>application/x-netcdf  cdf </p>
<p>application/x-netcdf  nc </p>
<p>application/x-perfmon  pma </p>
<p>application/x-perfmon  pmc </p>
<p>application/x-perfmon  pml </p>
<p>application/x-perfmon  pmr </p>
<p>application/x-perfmon  pmw </p>
<p>application/x-pkcs12  p12 </p>
<p>application/x-pkcs12  pfx </p>
<p>application/x-pkcs7-certificates  p7b </p>
<p>application/x-pkcs7-certificates  spc </p>
<p>application/x-pkcs7-certreqresp  p7r </p>
<p>application/x-pkcs7-mime  p7c </p>
<p>application/x-pkcs7-mime  p7m </p>
<p>application/x-pkcs7-signature  p7s </p>
<p>application/x-sh  sh </p>
<p>application/x-shar  shar </p>
<p>application/x-shockwave-flash  swf </p>
<p>application/x-stuffit  sit </p>
<p>application/x-sv4cpio  sv4cpio </p>
<p>application/x-sv4crc  sv4crc </p>
<p>application/x-tar  tar </p>
<p>application/x-tcl  tcl </p>
<p>application/x-tex  tex </p>
<p>application/x-texinfo  texi </p>
<p>application/x-texinfo  texinfo </p>
<p>application/x-troff  roff </p>
<p>application/x-troff  t </p>
<p>application/x-troff  tr </p>
<p>application/x-troff-man  man </p>
<p>application/x-troff-me  me </p>
<p>application/x-troff-ms  ms </p>
<p>application/x-ustar  ustar </p>
<p>application/x-wais-source  src </p>
<p>application/x-x509-ca-cert  cer </p>
<p>application/x-x509-ca-cert  crt </p>
<p>application/x-x509-ca-cert  der </p>
<p>application/ynd.ms-pkipko  pko </p>
<p>application/zip  zip </p>
<p>audio/basic  au </p>
<p>audio/basic  snd </p>
<p>audio/mid  mid </p>
<p>audio/mid  rmi </p>
<p>audio/mpeg  mp3 </p>
<p>audio/x-aiff  aif </p>
<p>audio/x-aiff  aifc </p>
<p>audio/x-aiff  aiff </p>
<p>audio/x-mpegurl  m3u </p>
<p>audio/x-pn-realaudio  ra </p>
<p>audio/x-pn-realaudio  ram </p>
<p>audio/x-wav  wav </p>
<p>image/bmp  bmp </p>
<p>image/cis-cod  cod </p>
<p>image/gif  gif </p>
<p>image/ief  ief </p>
<p>image/jpeg  jpe </p>
<p>image/jpeg  jpeg </p>
<p>image/jpeg  jpg </p>
<p>image/pipeg  jfif </p>
<p>image/svg+xml  svg </p>
<p>image/tiff  tif </p>
<p>image/tiff  tiff </p>
<p>image/x-cmu-raster  ras </p>
<p>image/x-cmx  cmx </p>
<p>image/x-icon  ico </p>
<p>image/x-portable-anymap  pnm </p>
<p>image/x-portable-bitmap  pbm </p>
<p>image/x-portable-graymap  pgm </p>
<p>image/x-portable-pixmap  ppm </p>
<p>image/x-rgb  rgb </p>
<p>image/x-xbitmap  xbm </p>
<p>image/x-xpixmap  xpm </p>
<p>image/x-xwindowdump  xwd </p>
<p>message/rfc822  mht </p>
<p>message/rfc822  mhtml </p>
<p>message/rfc822  nws </p>
<p>text/css <a href="http://www.dreamdu.com/">http://www.dreamdu.com</a>  css </p>
<p>text/h323  323 </p>
<p>text/html  htm </p>
<p>text/html  html </p>
<p>text/html  stm </p>
<p>text/iuls  uls </p>
<p>text/plain  bas </p>
<p>text/plain  c </p>
<p>text/plain  h </p>
<p>text/plain  txt </p>
<p>text/richtext  rtx </p>
<p>text/scriptlet  sct </p>
<p>text/tab-separated-values  tsv </p>
<p>text/webviewhtml  htt </p>
<p>text/x-component  htc </p>
<p>text/x-setext  etx </p>
<p>text/x-vcard  vcf </p>
<p>video/mpeg  mp2 </p>
<p>video/mpeg  mpa </p>
<p>video/mpeg  mpe </p>
<p>video/mpeg  mpeg </p>
<p>video/mpeg  mpg </p>
<p>video/mpeg  mpv2 </p>
<p>video/quicktime  mov </p>
<p>video/quicktime  qt </p>
<p>video/x-la-asf  lsf </p>
<p>video/x-la-asf  lsx </p>
<p>video/x-ms-asf  asf </p>
<p>video/x-ms-asf  asr </p>
<p>video/x-ms-asf  asx </p>
<p>video/x-msvideo  avi </p>
<p>video/x-sgi-movie  movie </p>
<p>x-world/x-vrml  flr </p>
<p>x-world/x-vrml  vrml </p>
<p>x-world/x-vrml  wrl </p>
<p>x-world/x-vrml  wrz </p>
<p>x-world/x-vrml  xaf </p>
<p>x-world/x-vrml  xof </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>常见的几种排序</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>常见的几种排序—必考</p>
<p> //直接插入排序</p>
<p>    private static void InsertSort(int[] r, int n)</p>
<p>    {  for (int i = 2; i &lt; n; i++)</p>
<p>        {</p>
<p>            r[0] = r[i];   //设置哨兵</p>
<p>            int j;</p>
<p>            for (j = i - 1; r[0] &lt; r[j]; j–)   //寻找插入位置</p>
<p>                r[j + 1] = r[j];                //记录后移</p>
<p>            r[j + 1] = r[0];</p>
<p>        }</p>
<p>    }</p>
<p>//希尔排序</p>
<p>void ShellSort(int r[], int n)</p>
<p>{       </p>
<p>         int i;</p>
<p>         int d;</p>
<p>         int j;</p>
<p>    for (d=n/2; d&gt;=1; d=d/2)            //以增量为d进行直接插入排序</p>
<p>         {</p>
<p>              for (i=d+1; i&lt;n; i++)  </p>
<p>                    {  </p>
<p>             r[0]=r[i];                 //暂存被插入记录</p>
<p>               for (j=i-d; j&gt;0 &amp;&amp; r[0]&lt;r[j]; j=j-d)</p>
<p>                     r[j+d]=r[j];       //记录后移d个位置</p>
<p>                          r[j+d]=r[0];</p>
<p>                    }</p>
<p>         }</p>
<p>}</p>
<p>    //冒泡排序</p>
<p>    private static void BubbleSort(int[] r, int n)</p>
<p>    {</p>
<p>        int temp;</p>
<p>        int exchange;</p>
<p>        int bound;</p>
<p>        exchange = n - 1;                       //第一趟起泡排序的范围是r[0]到r[n-1]</p>
<p>        while (exchange != 0)                    //仅当上一趟排序有记录交换才进行本趟排序</p>
<p>        {</p>
<p>            bound = exchange;</p>
<p>            exchange = 0;</p>
<p>            for (int j = 0; j &lt; bound; j++)     //一趟起泡排序</p>
<p>                if (r[j] &gt; r[j + 1])</p>
<p>                {</p>
<p>                    temp = r[j];</p>
<p>                    r[j] = r[j + 1];</p>
<p>                    r[j + 1] = temp;</p>
<p>                    exchange = j;                   //记录每一次发生记录交换的位置</p>
<p>                }</p>
<p>        }</p>
<p>    }</p>
<p>    //快速排序一次划分</p>
<p>    private static int Partition(int[] r, int first, int end)</p>
<p>    {</p>
<p>        int i = first;                        //初始化</p>
<p>        int j = end;</p>
<p>        int temp;</p>
<p>        while (i &lt; j)</p>
<p>        {</p>
<p>            while (i &lt; j &amp;&amp; r[i] &lt;= r[j])</p>
<p>                j–;                        //右侧扫描</p>
<p>            if (i &lt; j)</p>
<p>            {</p>
<p>                temp = r[i];                 //将较小记录交换到前面</p>
<p>                r[i] = r[j];</p>
<p>                r[j] = temp;</p>
<p>                i++;</p>
<p>            }</p>
<p>            while (i &lt; j &amp;&amp; r[i] &lt;= r[j])</p>
<p>                i++;                         //左侧扫描</p>
<p>            if (i &lt; j)</p>
<p>            {</p>
<p>                temp = r[j];</p>
<p>                r[j] = r[i];</p>
<p>                r[i] = temp;                //将较大记录交换到后面</p>
<p>                j–;</p>
<p>            }</p>
<p>        }</p>
<p>        return i;                           //i为轴值记录的最终位置</p>
<p>    }</p>
<p>    //快速排序</p>
<p>    private static void QuickSort(int[] r, int first, int end)</p>
<p>    {</p>
<p>        if (first &lt; end)</p>
<p>        {                                   //递归结束</p>
<p>            int pivot = Partition(r, first, end);  //一次划分</p>
<p>            QuickSort(r, first, pivot - 1);//递归地对左侧子序列进行快速排序</p>
<p>            QuickSort(r, pivot + 1, end);  //递归地对右侧子序列进行快速排序</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>应用总结</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>//显示fragment<br>getSupportFragmentManager()<br>       .beginTransaction()<br>       .add(getFragmentContainerId(), (Fragment) currFragment)<br>       .commitNowAllowingStateLoss();</p>
<p>//当activity实例存在，跳转回 singleTask的Activity时不执行Oncreate 而执行onNewIntent</p>
<p>protected void onNewIntent(Intent intent) {        </p>
<p>    super.onNewIntent(intent);  </p>
<p>setIntent(intent); //更新Intent</p>
<p>    //here we can use getIntent() to get the extra data.</p>
<p>}</p>
<p>startActivityForResult 不能用于启动 singleTask、singleInstance 修饰的Activity</p>
<p>不同task之间不能传递数据，onActivityResult会提前执行</p>
<p>//补间动画</p>
<p>  Animation alphaAnimation = AnimationUtils.loadAnimation(this, R.anim.anim_alpha);</p>
<p>  Animation alphaAnimation = new AlphaAnimation(1.0f, 0.0f);  </p>
<p> imageView.startAnimation(alphaAnimation);</p>
<p>//属性动画</p>
<p>Animator anim = AnimatorInflater.loadAnimator(this, R.animator.animator_alpha);<br>anim.setTarget(imageView);<br>anim.start();</p>
<p>ObjectAnimator alphaAnimation = ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 0f, 1f);alphaAnimation.start();</p>
<p>//自定义VIWE  开关按钮、等待动画、进度条 、 折线图 、 仪表</p>
<p>canvas.drawRoundRect、canvas.drawCircle  </p>
<p>ObjectAnimator.ofInt(WaitView.this, &quot;startPos&quot;, 0, 11); </p>
<p>canvas.drawLine(0, r/2, 0, r, paint);</p>
<p>canvas.rotate(30);</p>
<p>//网络数据下载</p>
<p>FinalHttp http = new FinalHttp();<br>   http.configCharset(&quot;iso-8859-1&quot;);</p>
<p>http.getSync(url)</p>
<p>http.download(uri, path, new AjaxCallBack&lt;File&gt;()    </p>
<p>USB 串口通讯</p>
<p>静态注册</p>
<p>&lt;activity …</p>
<p> &lt;intent-filter&gt;<br>   &lt;action android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot; /&gt;<br>&lt;/intent-filter&gt;<br>&lt;meta-data<br>   android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot;<br>   android:resource=&quot;@xml/device_filter&quot; /&gt; </p>
<p>/&gt;</p>
<p>   &lt;!– 0x0403 / 0x6001: FTDI FT232R UART –&gt;<br>   &lt;usb-device vendor-id=&quot;1027&quot; product-id=&quot;24577&quot; /&gt;   <br>   &lt;!– 0x0403 / 0x6015: FTDI FT231X –&gt;<br>   &lt;usb-device vendor-id=&quot;1027&quot; product-id=&quot;24597&quot; /&gt;</p>
<p>动态注册</p>
<p>IntentFilter usbFilter = new IntentFilter();<br>        usbFilter.addAction(UsbManager.ACTION_USB_DEVICE_ATTACHED);<br>        usbFilter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);<br>        registerReceiver(mUsbReceiver, usbFilter);</p>
<p>// 获取系统服务得到UsbManager实例UsbManager manager = (UsbManager) getSystemService(Context.USB_SERVICE);<br>//查找所有插入的设备<br>List&lt;UsbSerialDriver&gt; availableDrivers = UsbSerialProber.getDefaultProber().findAllDrivers(manager);<br>if (availableDrivers.isEmpty()) {<br>  return;<br>}</p>
<p>// 打开设备，建立通信连接UsbSerialDriver driver = availableDrivers.get(0);UsbDeviceConnection connection = manager.openDevice(driver.getDevice());<br>if (connection == null) {<br>  // You probably need to call UsbManager.requestPermission(driver.getDevice(), ..)<br>  return;<br>}</p>
<p>//打开端口，设置端口参数，读取数据<br>UsbSerialPort port = driver.getPorts().get(0);<br>try {<br>  port.open(connection);<br>//四个参数分别是：波特率，数据位，停止位，校验位<br>  port.setParameters(115200, 8, UsbSerialPort.STOPBITS_1, UsbSerialPort.PARITY_NONE);</p>
<p>  byte buffer[] = new byte[16];<br>  int numBytesRead = port.read(buffer, 1000);<br>  Log.d(TAG, &quot;Read &quot; + numBytesRead + &quot; bytes.&quot;);<br>} catch (IOException e) {<br>  // Deal with error.<br>} finally {<br>  port.close();<br>}</p>
<p>BT通讯</p>
<p>实现需要的权限：</p>
<p>由于安卓4.x以上的版本使用蓝牙，需要开启定位权限才能搜索到附近的蓝牙设备 </p>
<p>&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;  </p>
<p>&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt;    </p>
<p>&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;  </p>
<p>&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;  </p>
<p>打开BT</p>
<p>BTAdapter = BluetoothAdapter.getDefaultAdapter(); </p>
<p>if (!BTAdapter.isEnabled()) {  </p>
<p>                Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);  </p>
<p>                // 设置蓝牙可见性，最多300秒  </p>
<p>                intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);  </p>
<p>                context.startActivity(intent);  </p>
<p>            }             </p>
<p> 开启监听服务</p>
<p>BluetoothServerSocket mserverSocket = BTAdapter.listenUsingRfcommWithServiceRecord(&quot;btspp&quot;,  </p>
<p>                        UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));                  </p>
<p>                BTSocket = mserverSocket.accept();                  </p>
<p>                BTSocket.getInputStream();  //读取数据</p>
<p>public void registerBTReceiver() {  </p>
<p>    // 设置广播信息过滤  </p>
<p>    IntentFilter intentFilter = new IntentFilter();  </p>
<p>    intentFilter.addAction(BluetoothDevice.ACTION_FOUND);  </p>
<p>    intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED);  </p>
<p>    intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);  </p>
<p>    intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);  </p>
<p>    intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);  </p>
<p>    // 注册广播接收器，接收并处理搜索结果  </p>
<p>    registerReceiver(BTReceive, intentFilter);  </p>
<p>}                  </p>
<p>    搜索附近设备             </p>
<p>           BTAdapter.startDiscovery(); </p>
<p>   配对绑定      </p>
<p>           try {  </p>
<p>                    Method createBondMethod = BluetoothDevice.class.getMethod(&quot;createBond&quot;);  </p>
<p>                    createBondMethod.invoke(device);  </p>
<p>                } catch (Exception e) {  </p>
<p>                    e.printStackTrace();  </p>
<p>                }  </p>
<p>       客户端发起socket连接         </p>
<p>       BTSocket = device.createRfcommSocketToServiceRecord(UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));             </p>
<p>         BTSocket.connect();  </p>
<p>        BTSocket.getInputStream();//读取通讯数据        </p>
<p>         BTSocket.getOutputStream();  //发送数据</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>开机动画 bootanimation</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%20bootanimation/</url>
    <content><![CDATA[<p>开机动画文件：bootanimation.zip<br>路径 ：/system/media/ </p>
<p>bootanimation.zip文件是zip压缩文件，压缩方式要求是存储压缩，包含一个文件和两个目录：<br>    1.动画属性描述文件：desc.txt<br>    2.第一阶段动画图片目录：part0<br>    3.第二阶段动画图片目录：part1<br>desc.txt文件内容：<br>    480 427 30<br>    p 1 0 part0<br>    p 0 10 part1<br>desc.txt文件分析：<br>    480  427   30  <br>     宽   高    帧数（对应多少张图片）<br>      p         1              0                      part0<br>    标志符 循环次数 阶段切换间隔时间  对应目录名<br>      p         0             10                     part1 <br>    标志符 循环次数 阶段切换间隔时间  对应目录名<br>    ==================<br>    标志符：<br>        必须是: p<br>    循环次数：<br>        0 : 表示本阶段无限循环<br>    阶段切换间隔时间：<br>       &amp;nbs<br>zip -Z store bootanimation.zip part0/*png part1/*png desc.txt </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>开机默认解锁</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%BC%80%E6%9C%BA%E9%BB%98%E8%AE%A4%E8%A7%A3%E9%94%81/</url>
    <content><![CDATA[<p> b/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardViewMediator.java</p>
<p>@@ -551,7 +551,7 @@ public class KeyguardViewMediator {</p>
<p>                 mUpdateMonitor.setAlternateUnlockEnabled(true);</p>
<p>             }</p>
<ul>
<li>           doKeyguardLocked();</li>
</ul>
<ul>
<li>           //doKeyguardLocked();</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>弹出提示框</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA%E6%A1%86/</url>
    <content><![CDATA[<p>echo &quot;&lt;script&gt;alert(‘删除成功’);location=’&quot;.$_SERVER[‘HTTP_REFERER’].&quot;’;&lt;/script&gt;&quot;;</p>
<p>echo &quot;&lt;script&gt;alert(‘已删除’);location=’&quot;.$_SERVER[‘HTTP_REFERER’].&quot;’;&lt;/script&gt;&quot;;</p>
<p>echo &quot;&lt;script&gt;alert(‘回复成功’);location=’index.php’;&lt;/script&gt;&quot;;</p>
<p>echo &quot;&lt;script&gt;alert(‘有错误，请返回’);history.go(-1);&lt;/script&gt;&quot;;</p>
<p>exit();</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>开源库</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%BC%80%E6%BA%90%E5%BA%93/</url>
    <content><![CDATA[<p><a href="http://www.mob.com/">http://www.mob.com/</a>  SHARE SDK等免费API</p>
<p>compile ‘com.cleveroad:slidingtutorial:1.0.5’  滑动引导</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>强制修改smallestScreenWidthDp</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9smallestScreenWidthDp/</url>
    <content><![CDATA[<p>frameworks\base\services\java\com\android\server\wm\WindowManagerService.java</p>
<p>4.1 </p>
<p>computeSizeRangesAndScreenLayout</p>
<p>//RK</p>
<p>int sw = (int)(mSmallestDisplayWidth / density);</p>
<p>        if (SystemProperties.get(&quot;ro.build.characteristics&quot;,&quot;none&quot;).equals(&quot;tablet&quot;)</p>
<p>                &amp;&amp; sw &lt; 720 &amp;&amp; sw!=480) {</p>
<p>            sw = 720;</p>
<p>        }</p>
<p>        outConfig.smallestScreenWidthDp = sw;</p>
<p>4.2 </p>
<p>computeSizeRangesAndScreenLayout</p>
<p> outConfig.smallestScreenWidthDp = (int)(displayInfo.smallestNominalAppWidth / density);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>强制弹出 软键盘虚拟键盘</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%BC%BA%E5%88%B6%E5%BC%B9%E5%87%BA%20%E8%BD%AF%E9%94%AE%E7%9B%98%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p>+++ b/frameworks/base/core/java/android/inputmethodservice/InputMethodService.java</p>
<p>@@ -1106,9 +1106,10 @@ public class InputMethodService extends AbstractInputMethodService {</p>
<p>      * re-evaluated and applied.</p>
<p>      */</p>
<p>     public boolean onEvaluateInputViewShown() {</p>
<ul>
<li><p>Configuration config = getResources().getConfiguration();</p>
</li>
<li><p>return config.keyboard == Configuration.KEYBOARD_NOKEYS</p>
</li>
<li><p>|| config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES;</p>
</li>
</ul>
<ul>
<li><p>// Configuration config = getResources().getConfiguration();</p>
</li>
<li><p>// return config.keyboard == Configuration.KEYBOARD_NOKEYS</p>
</li>
<li><p>// || config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES;</p>
</li>
<li><p>return true ; //always show soft keyoutboard</p>
</li>
</ul>
<p>     }</p>
<p>frameworks/base/services/java/com/android/server/wm/WindowManagerService.java</p>
<p>   // Determine whether a hard keyboard is available and enabled.</p>
<p>            boolean hardKeyboardAvailable = config.keyboard != Configuration.KEYBOARD_NOKEYS;</p>
<p>            if (hardKeyboardAvailable != mHardKeyboardAvailable) {</p>
<p>                mHardKeyboardAvailable = hardKeyboardAvailable;</p>
<p>                mHardKeyboardEnabled = false; //hardKeyboardAvailable;</p>
<p>                mH.removeMessages(H.REPORT_HARD_KEYBOARD_STATUS_CHANGE);</p>
<p>                mH.sendEmptyMessage(H.REPORT_HARD_KEYBOARD_STATUS_CHANGE);</p>
<p>            }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>强制横屏 强制旋转方向</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%BC%BA%E5%88%B6%E6%A8%AA%E5%B1%8F%20%E5%BC%BA%E5%88%B6%E6%97%8B%E8%BD%AC%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p>diff –git a/services/java/com/android/server/wm/WindowManagerService.java b/services/java/com/android/server/wm/WindowManagerServ</p>
<p>index 7272c21..19f7f25 100755</p>
<p>— a/services/java/com/android/server/wm/WindowManagerService.java</p>
<p>+++ b/services/java/com/android/server/wm/WindowManagerService.java</p>
<p>@@ -3729,8 +3729,29 @@ public class WindowManagerService extends IWindowManager.Stub</p>
<p>             if (req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {</p>
<p>                 req = getOrientationFromAppTokensLocked();</p>
<p>             }</p>
<ul>
<li>             req = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;// add by edward</li>
</ul>
<p>-</p>
<ul>
<li><p>              if(isRotationFrozen()){         </p>
</li>
<li><p>              req = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;// add by edward                </p>
</li>
<li><p>              }else{</p>
</li>
<li><p>              final int rotation = Settings.System.getInt(mContext.getContentResolver(),Settings.System.ACCELEROMETER_ROTATION_A</p>
</li>
<li><p>              </p>
</li>
<li><p>                      switch(rotation){</p>
</li>
<li><p>                              case 0 :</p>
</li>
<li><p>                                      req = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;        </p>
</li>
<li><p>                                      break;</p>
</li>
<li><p>                              case 90 :</p>
</li>
<li><p>                                      req = ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT;    </p>
</li>
<li><p>                                      break;</p>
</li>
<li><p>                              case 180 :</p>
</li>
<li><p>                                      req = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;</p>
</li>
<li><p>                                      break;</p>
</li>
<li><p>                              case 270 :</p>
</li>
<li><p>                                      req = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;</p>
</li>
<li><p>                                      break;</p>
</li>
<li><p>                              default:                                                </p>
</li>
<li><p>                                      req = ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT;    </p>
</li>
<li><p>                      }</p>
</li>
<li><p>              </p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>             if (req != mForcedAppOrientation) {</p>
<p>                 mForcedAppOrientation = req;</p>
<p>diff –git a/src/com/android/settings/cyanogenmod/DisplayRotation.java b/src/com/android/settings/cyanogenmod/DisplayRotation.java</p>
<p>index e99aef2..1e549a6 100644</p>
<p>— a/src/com/android/settings/cyanogenmod/DisplayRotation.java</p>
<p>+++ b/src/com/android/settings/cyanogenmod/DisplayRotation.java</p>
<p>@@ -73,7 +73,8 @@ public class DisplayRotation extends SettingsPreferenceFragment implements</p>
<p>             mSetRotation.setSummary((String)newValue);</p>
<p>                        Settings.System.putInt(getActivity().getContentResolver(),</p>
<p>                        Settings.System.ACCELEROMETER_ROTATION_ANGLES, value);</p>
<ul>
<li>              }</li>
</ul>
<ul>
<li><p>                      getActivity().setRequestedOrientation(1);// =&gt; wm.updateOrientationFromAppTokensLocked</p>
</li>
<li><p>              }               </p>
</li>
</ul>
<p>                return true;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>怎么有效治疗2个月的婴儿便秘      有的2个</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%80%8E%E4%B9%88%E6%9C%89%E6%95%88%E6%B2%BB%E7%96%972%E4%B8%AA%E6%9C%88%E7%9A%84%E5%A9%B4%E5%84%BF%E4%BE%BF%E7%A7%98%20%20%20%20%20%20%E6%9C%89%E7%9A%842%E4%B8%AA/</url>
    <content><![CDATA[<p>怎么有效治疗2个月的婴儿便秘? <br>  有的2个月的婴儿经常2<del>3天或4</del>5天才排便一次，但粪便并不干结，仍呈软便或糊状便，排便时要用力屏气，脸涨得红红的好似排便困难，这其实并不属于便秘。  <br>  宝宝几天不拉,可能是宝宝根本没吃饱,所以你首先要保证宝宝每天吃饱了。  <br>  你还要看他拉出来的是软便还是硬 有的婴儿经常2<del>3天或4</del>5天才排便一次，但粪便并不干结，仍呈软便或糊状便，排便时要用力屏气，脸涨得红红的好似排便困难，这其实并不属于便秘。  <br>  宝宝几天不拉,可能是宝宝根本没吃饱,所以你首先要保证宝宝每天吃饱了。  <br>  你还要看他拉出来的是软便还是硬便。  <br>  燕燕的宝宝50天左右时也开始几天一次大便，最长的一次四天才拉，但是他拉出来的仍是糊状的软便，我就知道他不是便秘。便秘是指拉出来硬硬的条状或颗粒状的大便。你不用着急，这么小的宝宝是这样的，她还没养成每天定时拉大便的习惯，也就是说她还根本不会大便，这样你就更不能用开塞露了，越用越依赖，大便反射越麻木，越用越不知道自己拉。  <br>  这个时候，育儿专家告诉你需要每天帮宝宝按摩肚子，就是用你中间的三个手指，绕着宝宝的肚脐顺时针按摩，一次5分钟，每天早晚各一次，能帮助宝宝加快肠蠕动，使宝宝产生大便反射。  <br>  另外，从孩子两个月起就应该训练良好的排便习惯，使他按时排便，排便最好在清晨或晚上临睡前，早晨排便最好，晚上大便则可使孩子夜里睡得踏实。饭前大便可使孩子吃得好，但不要饭后大便。妈妈先观察孩子排便的情况，然后根据孩子的情况，有意识的定时排便，排便时妈妈要和他一起发出“恩恩恩”的声音。  <br>  另外,添加了奶粉的婴儿每两顿之间都需要喂水，每次喂水量约为每顿奶量的一半：出生第一星期30毫升；第二星期45毫升；1个月后50<del>60毫升；3个月时60</del>75毫升；4个月时70<del>80毫升；6个月时80</del>100毫升；8<del>12个月100</del>120毫升。夏天应适当增加水量。感冒、发烧及呕吐或腹泻脱水时更应频繁饮水。 记住，白开水就是白开水，水果和果汁不能代替水。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>我的保险</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%88%91%E7%9A%84%E4%BF%9D%E9%99%A9/</url>
    <content><![CDATA[<p>保单号险种保额现金保期承保公司</p>
<p>350421600141743全年综合意外医疗险伤害10W 医疗1W 住院补贴9K(50/d)3020160703-20170702太平洋人寿保险</p>
<p>350421600144429全年综合意外医疗险伤害10W 医疗1W 住院补贴9K(50/d)3020160705-20170704太平洋人寿保险</p>
<p>8600027002016235592电梯意外伤害50W 医疗1W620160702-20170701阳光财产保险</p>
<p>6029902114820160000213电梯意外伤害20W 医疗5K820160705-20170704富德财产保险</p>
<p>P000000037169147综合交通意外伤害10W 医疗5K520160702-20170701富德生命人寿</p>
<p>P000000034878474综合交通意外伤害10W 医疗5K520160425-20170424富德生命人寿</p>
<p>827403404938587000成年人重大疾病保险重症 10W16620160703-20170702众安在线财产保险</p>
<p>827443377789668022女性特定疾病保险2W1020160615-20170614众安在线财产保险</p>
<p>8270D3421048229534个人住院医疗保险30W 1W免30820160703-20170702众安在线财产保险</p>
<p>8270D1965909040165个人住院医疗保险30W 1W免26820160612-20170611众安在线财产保险</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>截图保存图片 GlobalScreenshot</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%88%AA%E5%9B%BE%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%20GlobalScreenshot.java/</url>
    <content><![CDATA[<p>public void saveMyBitmap(Bitmap mBitmap ,String savePath ) throws Exception {</p>
<p>            File f = new File(savePath);</p>
<p>            if(!f.exists())</p>
<p>             f.createNewFile();</p>
<p>            FileOutputStream fOut = null;</p>
<p>            try {</p>
<p>                    fOut = new FileOutputStream(f);</p>
<p>            } catch (FileNotFoundException e) {</p>
<p>                    e.printStackTrace();</p>
<p>            }</p>
<p>            mBitmap.compress(Bitmap.CompressFormat.PNG, 100, fOut);</p>
<p>            try {</p>
<p>                    fOut.flush();</p>
<p>            } catch (IOException e) {</p>
<p>                    e.printStackTrace();</p>
<p>            }</p>
<p>            try {</p>
<p>                    fOut.close();</p>
<p>            } catch (IOException e) {</p>
<p>                    e.printStackTrace();</p>
<p>            }</p>
<p>     }</p>
<p>    private static final String SCREENSHOT_FILE_PATH_TEMPLATE = &quot;%s/%s/%s/%s&quot;;</p>
<p>    private static final String SCREENSHOT_FILE_PATH_TEMPLATE_UMS = &quot;%s/%s/%s&quot;;</p>
<p> // 测试图片的大小</p>
<p> /<em>just for get pic size,because SystemUi can not access sdcard</em>/</p>
<p> String imageDir=Settings.System.getString(context.getContentResolver(), Settings.System.SCREENSHOT_LOCATION);</p>
<p> String path = String.format(&quot;%s/%s&quot;, imageDir,&quot;test&quot;);//mImageFilePath;</p>
<p> File f = new File(path);</p>
<p> f.createNewFile();</p>
<p> FileOutputStream test_out = new FileOutputStream(f);</p>
<p> image.compress(Bitmap.CompressFormat.PNG, 100, test_out);</p>
<p> test_out.flush();</p>
<p> test_out.close();</p>
<p> long len=f.length();</p>
<p> f.delete();</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>打开wifi时安装GooglePlay</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%89%93%E5%BC%80wifi%E6%97%B6%E5%AE%89%E8%A3%85GooglePlay/</url>
    <content><![CDATA[<p>— a/packages/apps/Settings/src/com/android/settings/wifi/WifiEnabler.java</p>
<p>+++ b/packages/apps/Settings/src/com/android/settings/wifi/WifiEnabler.java</p>
<p>@@ -28,12 +28,16 @@ import android.provider.Settings;</p>
<p> import android.widget.CompoundButton;</p>
<p>+import java.util.ArrayList;  </p>
<p>+import android.util.Log;</p>
<p>+import android.content.pm.PackageInfo;</p>
<p>+import android.content.pm.PackageManager;</p>
<p>+import java.util.List;</p>
<p>+import android.net.Uri;</p>
<p> public class WifiEnabler implements CompoundButton.OnCheckedChangeListener {</p>
<p>     private final Context mContext;</p>
<p>     private Switch mSwitch;</p>
<p>@@ -103,6 +107,14 @@ public class WifiEnabler implements CompoundButton.OnCheckedChangeListener {</p>
<p>         if (mStateMachineEvent) {</p>
<p>             return;</p>
<p>         }</p>
<p>+</p>
<ul>
<li><p>if(isChecked){</p>
</li>
<li><p>if(!hasGooglePay())</p>
</li>
<li><p>{</p>
</li>
<li><p>//Toast.makeText(mContext, &quot;You should install GooglePlay ?&quot;, Toast.LENGTH_SHORT).show();</p>
</li>
<li><p>installApp();</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>         // Show toast message if Wi-Fi is not allowed in airplane mode</p>
<p>         if (isChecked &amp;&amp; !WirelessSettings.isRadioAllowed(mContext, Settings.Global.RADIO_WIFI)) {</p>
<p>             Toast.makeText(mContext, R.string.wifi_in_airplane_mode, Toast.LENGTH_SHORT).show();</p>
<p>@@ -125,13 +137,40 @@ public class WifiEnabler implements CompoundButton.OnCheckedChangeListener {</p>
<p>             Toast.makeText(mContext, R.string.wifi_error, Toast.LENGTH_SHORT).show();</p>
<p>         }</p>
<p>     }</p>
<p>-</p>
<p>+</p>
<p>+</p>
<ul>
<li><p>public boolean hasGooglePay(){</p>
</li>
<li><p>boolean hasGPay = false ;</p>
</li>
<li><p>List&lt;PackageInfo&gt; apps = new ArrayList&lt;PackageInfo&gt;();</p>
</li>
<li><p>PackageManager pManager = mContext.getPackageManager();</p>
</li>
<li><p>List&lt;PackageInfo&gt; paklist = pManager.getInstalledPackages(PackageManager.GET_ACTIVITIES | PackageManager.GET_SIGNATURES);</p>
</li>
<li><p>for (int i = 0; i &lt; paklist.size(); i++) {</p>
</li>
<li><p>PackageInfo pakInfo = (PackageInfo) paklist.get(i);</p>
</li>
<li><p>if(&quot;com.android.vending&quot;.equals(pakInfo.packageName))</p>
</li>
<li><p>hasGPay = true ;</p>
</li>
<li><p>//Log.d(&quot;edward&quot;,pakInfo.packageName);</p>
</li>
<li><p>//Log.d(&quot;edward&quot;,pakInfo.toString());</p>
</li>
<li><p>}</p>
</li>
<li><p>return hasGPay;</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>public void installApp(){</p>
</li>
<li><p>Intent intent = new Intent(Intent.ACTION_VIEW);</p>
</li>
<li><p>intent.setDataAndType(Uri.parse(&quot;file://&quot;</p>
</li>
<li><ul>
<li>&quot;/sdcard/Phonesky.apk&quot;),</li>
</ul>
</li>
<li><p>&quot;application/vnd.android.package-archive&quot;);</p>
</li>
<li><p>mContext.startActivity(intent);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p>// 不弹出Unknown Apps …</p>
<p>packages/apps/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java</p>
<p>+++ b/packages/apps/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java</p>
<p>@@ -563,7 +563,7 @@ public class PackageInstallerActivity extends Activity implements OnCancelListen</p>
<p>         }</p>
<p>         // Check unknown sources.</p>
<ul>
<li>if (!isInstallingUnknownAppsAllowed()) {</li>
</ul>
<ul>
<li>if (!isInstallingUnknownAppsAllowed() &amp;&amp; (!(&quot;/system/media/Phonesky.apk&quot;.equals(mPackageURI.getPath())))) {</li>
</ul>
<p>================================================================================</p>
<p>onCheckedChanged</p>
<p> if(isChecked){</p>
<p>    if(!hasGooglePay())</p>
<p>     {</p>
<p>     //Toast.makeText(mContext, &quot;You should install GooglePlay ?&quot;, Toast.LENGTH_SHORT).show();</p>
<p>     installApp();</p>
<p>     }</p>
<p>  }</p>
<p> public boolean hasGooglePay(){</p>
<p>  boolean hasGPay = false ;  </p>
<p>  List&lt;PackageInfo&gt; apps = new ArrayList&lt;PackageInfo&gt;();  </p>
<p>  PackageManager pManager = mContext.getPackageManager();     </p>
<p>  List&lt;PackageInfo&gt; paklist = pManager.getInstalledPackages(PackageManager.GET_ACTIVITIES | PackageManager.GET_SIGNATURES);  </p>
<p>  for (int i = 0; i &lt; paklist.size(); i++) {  </p>
<p>     PackageInfo pakInfo = (PackageInfo) paklist.get(i); </p>
<p>     if(&quot;com.android.vending&quot;.equals(pakInfo.packageName))</p>
<p>       hasGPay = true ;</p>
<p>   //Log.d(&quot;edward&quot;,pakInfo.packageName);</p>
<p>   //Log.d(&quot;edward&quot;,pakInfo.toString());</p>
<p>  }     </p>
<p>  return hasGPay;</p>
<p> } </p>
<p> public void installApp(){</p>
<p>  Intent intent = new Intent(Intent.ACTION_VIEW);  </p>
<p>     intent.setDataAndType(Uri.parse(&quot;file://&quot;  </p>
<p>      + &quot;/sdcard/Phonesky.apk&quot;),  </p>
<p>       &quot;application/vnd.android.package-archive&quot;);  </p>
<p>     mContext.startActivity(intent); </p>
<p> }</p>
<p>// 也可以这样判断googleplay</p>
<p> public static boolean marketAvailable(Context ctx) {</p>
<p>        PackageManager pm = ctx.getPackageManager();</p>
<p>        try {</p>
<p>            pm.getPackageInfo(&quot;com.android.vending&quot;, 0);</p>
<p>        } catch (NameNotFoundException e) {</p>
<p>            return false;</p>
<p>        }</p>
<p>        return true;</p>
<p>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>打开成功的心门</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%89%93%E5%BC%80%E6%88%90%E5%8A%9F%E7%9A%84%E5%BF%83%E9%97%A8/</url>
    <content><![CDATA[<p>1、掌握生活大小事——通过掌握时间而掌握生活。</p>
<p>2、确立核心价值——核心价值是自我实现和个人成就的基础。</p>
<p>3、排定优先顺序——当日常生活反映了你的核心价值，你就能体验发自内心的平静。</p>
<p>4、设定明确可行的目标——为达成重要目标，必须远离安逸区。</p>
<p>5、规划每日工作——每日规划做得好，时间宽裕效率高。</p>
<p>6、检视行为与信仰一致——行为是真实信念的反射。</p>
<p>7、改变行为以符合要求——当信念与事实相符时，需求就自然得到满足。</p>
<p>8、重新开信仰之窗——改变错误想法，克服负面行为。</p>
<p>9、以个人价值为依据——自尊必须发自内心。</p>
<p>10、在奉献中成就自我——付出愈多，收获愈大。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>拨TF卡播放flash的音乐不停止</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%8B%A8TF%E5%8D%A1%E6%92%AD%E6%94%BEflash%E7%9A%84%E9%9F%B3%E4%B9%90%E4%B8%8D%E5%81%9C%E6%AD%A2/</url>
    <content><![CDATA[<p>— a/packages/apps/Music/src/com/android/music/MediaPlaybackActivity.java</p>
<p>+++ b/packages/apps/Music/src/com/android/music/MediaPlaybackActivity.java</p>
<p>@@ -64,7 +64,7 @@ import android.widget.SeekBar;</p>
<p> import android.widget.TextView;</p>
<p> import android.widget.Toast;</p>
<p> import android.widget.SeekBar.OnSeekBarChangeListener;</p>
<p>-</p>
<p>+import android.content.SharedPreferences;</p>
<p> import java.util.Arrays;</p>
<p> import java.util.ArrayList;</p>
<p> import java.util.List;</p>
<p>@@ -1092,6 +1092,31 @@ public class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,</p>
<p>                     // but also if the audio ID is valid but the service is paused.</p>
<p>                     if (mService.getAudioId() &gt;= 0 || mService.isPlaying() ||</p>
<p>                             mService.getPath() != null) {</p>
<p>+</p>
<ul>
<li><p>                              //get the current music ‘s real path</p>
</li>
<li><p>                              if(mService.getPath() != null){</p>
</li>
<li><p>                               Uri uri = Uri.parse(mService.getPath());</p>
</li>
<li><p>                        ContentResolver cr = getContentResolver();</p>
</li>
<li><p>                        Cursor c = cr.query(uri, null, null, null, null);</p>
</li>
<li><p>                        String strPath = null;</p>
</li>
<li><p>                        if(c != null)</p>
</li>
<li><p>                        {</p>
</li>
<li><p>                               while(c.moveToNext())</p>
</li>
<li><p>                                {</p>
</li>
<li><p>                                        strPath = c.getString(1);</p>
</li>
<li><p>                                        break;</p>
</li>
<li><p>                               }</p>
</li>
<li><p>                               c.close();</p>
</li>
<li><p>                       }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                                               if(strPath != null)</p>
</li>
<li><p>                        {</p>
</li>
<li><p>                                SharedPreferences pf = getSharedPreferences(&quot;current&quot;, 0);</p>
</li>
<li><p>                                SharedPreferences.Editor editor = pf.edit();</p>
</li>
<li><p>                                editor.putString(&quot;CurrentMusic&quot;, strPath);</p>
</li>
<li><p>                                editor.commit();</p>
</li>
<li><p>                        }</p>
</li>
<li><p>                                      }</p>
</li>
<li><p>               //   Log.d(&quot;edward&quot;,&quot;DisplayPath:=&quot;+strPath);</p>
</li>
</ul>
<p>                         // something is playing now, we’re done</p>
<p>                         mRepeatButton.setVisibility(View.VISIBLE);</p>
<p>                         mShuffleButton.setVisibility(View.VISIBLE);</p>
<p>diff –git a/packages/apps/Music/src/com/android/music/MediaPlaybackService.java b/packages/apps/Music/src/com/android/music/MediaPlaybackService.java</p>
<p>index ea895a8..0cb29ac 100755</p>
<p>— a/packages/apps/Music/src/com/android/music/MediaPlaybackService.java</p>
<p>+++ b/packages/apps/Music/src/com/android/music/MediaPlaybackService.java</p>
<p>@@ -59,6 +59,7 @@ import java.io.PrintWriter;</p>
<p> import java.lang.ref.WeakReference;</p>
<p> import java.util.Random;</p>
<p> import java.util.Vector;</p>
<p>+import android.content.SharedPreferences;</p>
<p> /**</p>
<p>  * Provides &quot;background&quot; audio playback capabilities, allowing the</p>
<p>@@ -739,6 +740,14 @@ public class MediaPlaybackService extends Service {</p>
<p>      */</p>
<p>     public void closeExternalStorageFiles(String storagePath) {</p>
<p>         // stop playback and clean up if the SD card is going to be unmounted.</p>
<ul>
<li>      // Log.d(&quot;edward&quot;,&quot;storagePath:=&quot;+storagePath);</li>
</ul>
<p>+</p>
<ul>
<li><p>       SharedPreferences spf = getSharedPreferences(&quot;current&quot;, 0);</p>
</li>
<li><p>             String music = spf.getString(&quot;CurrentMusic&quot;, &quot;null&quot;);</p>
</li>
<li><p>              if(!music.contains(storagePath))</p>
</li>
<li><p>              {</p>
</li>
<li><p>                      return;</p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>         stop(true);</p>
<p>         notifyChange(QUEUE_CHANGED);</p>
<p>         notifyChange(META_CHANGED);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>拷贝删除文件脚本 服务</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%8B%B7%E8%B4%9D%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC%20%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>在init.rc 定义服务 </p>
<p>service copyfile /system/bin/copyfile.sh</p>
<p>    class main</p>
<p>    #disabled</p>
<p>在开机时，不知道什么原因，会跑好多次。</p>
<p>所以，FILEDEST 目标文件一定要判断存在时，才把服务关掉！</p>
<p>#!/system/bin/sh</p>
<p>testfile1=/data/test_copyfiles_mark</p>
<p>FILESRC=/system/media/Specialforces2.mkv</p>
<p>FILEDEST=/mnt/sdcard/Specialforces2.mkv</p>
<p>SDCardDir=/mnt/sdcard/</p>
<p>if [ -d $testfile1 ];then</p>
<p>log -t edward &quot; kill copyfile service !&quot;</p>
<p>stop copyfile</p>
<p>fi</p>
<p>################### copy files to sdcard ##########################</p>
<p>if [ -f $FILEDEST ];then</p>
<p> mkdir $testfile1 </p>
<p> log -t edward &quot; dest file exsist !&quot;</p>
<p>else</p>
<p> if [ -f $FILESRC ];then</p>
<p> log -t edward &quot; copyfile service sunning &quot;</p>
<p> busybox cp -fa $FILESRC $SDCardDir </p>
<p> fi</p>
<p> fi</p>
<p>################copy files end ##########################</p>
<p>if [ -f $FILEDEST ];then </p>
<p> mkdir $testfile1</p>
<p> log -t edward &quot; copyfile service done !&quot;</p>
<p>   ########## delete one time file #########</p>
<p>    mount -o rw,remount -t ext4 /system</p>
<p> rm $FILESRC</p>
<p> mount -o ro,remount -t ext4 /system</p>
<p> log -t edward &quot; delete one time files !&quot;</p>
<p>fi</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>控制台UTF8编码 副本</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%8E%A7%E5%88%B6%E5%8F%B0UTF8%E7%BC%96%E7%A0%81%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>输入 regedit，打开注册表</p>
<p>找到</p>
<p>HKEY_CURRENT_USER\Console%SystemRoot%_system32_cmd.exe</p>
<p> CodePage的值修改为65001 十进制，UTF8编码</p>
<p>命令：chcp 65001</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>控制台UTF8编码</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%8E%A7%E5%88%B6%E5%8F%B0UTF8%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>输入 regedit，打开注册表</p>
<p>找到</p>
<p>HKEY_CURRENT_USER\Console%SystemRoot%_system32_cmd.exe</p>
<p> CodePage的值修改为65001 十进制，UTF8编码</p>
<p>数字65001代表的是utf-8格式的编码</p>
<p>默认编码为gbk，数字代码为936</p>
<p>chcp 65001</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>控制背光 bl_power</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%8E%A7%E5%88%B6%E8%83%8C%E5%85%89%20bl_power/</url>
    <content><![CDATA[<p>Android 层，可以通过sys 节点来控制背光：</p>
<p>1：灭</p>
<p>0：亮</p>
<p>File HdmiFile =new File(&quot;/sys/class/backlight/rk28_bl/bl_power&quot;);                       </p>
<p> RandomAccessFile rdf = null;</p>
<p> rdf = new RandomAccessFile(HdmiFile, &quot;rw&quot;);</p>
<p> rdf.writeBytes(sighDisplay);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>插HDMI，喇叭同时有声音</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%8F%92HDMI%EF%BC%8C%E5%96%87%E5%8F%AD%E5%90%8C%E6%97%B6%E6%9C%89%E5%A3%B0%E9%9F%B3/</url>
    <content><![CDATA[<p>iff –git a/services/java/com/android/server/WiredAccessoryManager.java b/services/java/com/android/server/WiredAccessoryManager.</p>
<p>index c8d3510..2fb231e 100644</p>
<p>— a/services/java/com/android/server/WiredAccessoryManager.java</p>
<p>+++ b/services/java/com/android/server/WiredAccessoryManager.java</p>
<p>@@ -374,7 +374,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {</p>
<p>             //</p>
<p>             // If the kernel does not have an &quot;hdmi_audio&quot; switch, just fall back on the older</p>
<p>             // &quot;hdmi&quot; switch instead.</p>
<ul>
<li>           uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, 0);</li>
</ul>
<p>+/*            uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, 0);</p>
<p>             if (uei.checkSwitchExists()) {</p>
<p>                 retVal.add(uei);</p>
<p>             } else {</p>
<p>@@ -385,7 +385,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {</p>
<p>                     Slog.w(TAG, &quot;This kernel does not have HDMI audio support&quot;);</p>
<p>                 }</p>
<p>             }</p>
<p>-</p>
<p>+*/</p>
<p>             return retVal;</p>
<p>         }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统镜像</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p><a href="http://msdn.itellyou.cn/">http://msdn.itellyou.cn/</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>数制转换</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>     十进制转二进制，除2取余逆序排列</p>
<p>789=1100010101</p>
<p>789/2=394.5 —-1 第10位</p>
<p>394/2=197 —-0 第9位</p>
<p>197/2=98.5 —–1 第8位</p>
<p>98/2=49 —-0 第7位</p>
<p>49/2=24.5—-1 第6位</p>
<p>24/2=12 —-0 第5位</p>
<p>12/2=6 —-0 第4位</p>
<p>6/2=3 —-0 第3位</p>
<p>3/2=1.5 —-1 第2位</p>
<p>1/2=0.5 —-1 第1位</p>
<p>十进制小数转二进制 ，乘2取整数，正序排列</p>
<p> 0.7=（0.1 0110 0110…）B</p>
<p>0.7*2=1.4========取出整数部分1</p>
<p>0.4*2=0.8========取出整数部分0</p>
<p>0.8*2=1.6========取出整数部分1</p>
<p>0.6*2=1.2========取出整数部分1</p>
<p>0.2*2=0.4========取出整数部分0</p>
<p>0.4*2=0.8========取出整数部分0</p>
<p>0.8*2=1.6========取出整数部分1</p>
<p>0.6*2=1.2========取出整数部分1</p>
<p>0.2*2=0.4========取出整数部分0</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>文件列表</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>&lt;?php</p>
<p>/* </p>
<p> function scanDirectories($rootDir, $allowext, $allData=array()) {</p>
<p>     $dirContent = scandir($rootDir);</p>
<p>     foreach($dirContent as $key =&gt; $content) {</p>
<p>         $path = $rootDir.’/‘.$content;</p>
<p>         $ext = substr($content, strrpos($content, ‘.’) + 1);</p>
<p>        if(in_array($ext, $allowext)) {</p>
<p>             if(is_file($path) &amp;&amp; is_readable($path)) {</p>
<p>                 $allData[] = $path;</p>
<p>             }elseif(is_dir($path) &amp;&amp; is_readable($path)) {</p>
<p>                 // recursive callback to open new directory</p>
<p>                 $allData = scanDirectories($path, $allData);</p>
<p>             }</p>
<p>         }</p>
<p>     }</p>
<p>     return $allData;</p>
<p> }</p>
<p> $rootDir = root_path.&quot;/userfiles/images&quot;;</p>
<p> $allowext = array(&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;);</p>
<p> $files_array = scanDirectories($rootDir,$allowext);</p>
<p> foreach($files_array as $value){</p>
<p>      $values =  explode(‘/‘,$value); </p>
<p> print $values[count($values)-1].&quot;\n&quot;;</p>
<p> }*/</p>
<p>function getFilesNames($rootDir, $allowext, $allData=array()) {</p>
<p>     $dirContent = scandir($rootDir);</p>
<p>     foreach($dirContent as $key =&gt; $content) {</p>
<p>         $path = $content;</p>
<p>         $ext = substr($content, strrpos($content, ‘.’) + 1);         </p>
<p>        if(in_array($ext, $allowext)) {             </p>
<p>                 $allData[] = $path;             </p>
<p>         }</p>
<p>     }</p>
<p>     return $allData;</p>
<p> } </p>
<p> $rootDir = root_path.&quot;/userfiles/images&quot;;</p>
<p> $allowext = array(&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;);</p>
<p> $files_array = scanDirectories($rootDir,$allowext);</p>
<p> ?&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>无摄象头锁界面，去掉面部解锁</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%97%A0%E6%91%84%E8%B1%A1%E5%A4%B4%E9%94%81%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%8E%BB%E6%8E%89%E9%9D%A2%E9%83%A8%E8%A7%A3%E9%94%81/</url>
    <content><![CDATA[<p>frameworks\base\policy\src\com\android\internal\policy\impl\LockScreen.java</p>
<p>final boolean cameraDisabled = mLockPatternUtils.getDevicePolicyManager()</p>
<p>                    .getCameraDisabled(null);</p>
<p>改成</p>
<p>final boolean cameraDisabled = false;</p>
<p>+++ b/packages/apps/Settings/res/xml/security_settings_picker.xml</p>
<p>+&lt;!– //注释面部解锁</p>
<p>     &lt;PreferenceScreen</p>
<p>             android:key=&quot;unlock_set_biometric_weak&quot;</p>
<p>             android:title=&quot;@string/unlock_set_unlock_biometric_weak_title&quot;</p>
<p>             android:persistent=&quot;false&quot;/&gt;</p>
<p>+–&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>是否显示于App列表，LAUNCHER属性</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%98%AF%E5%90%A6%E6%98%BE%E7%A4%BA%E4%BA%8EApp%E5%88%97%E8%A1%A8%EF%BC%8CLAUNCHER%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>AndroidManifest.xml</p>
<p>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>更改CPU显示频率</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%9B%B4%E6%94%B9CPU%E6%98%BE%E7%A4%BA%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<p>diff –git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c</p>
<p>index acbb447..634032a 100644</p>
<p>— a/arch/arm/kernel/setup.c</p>
<p>+++ b/arch/arm/kernel/setup.c</p>
<p>@@ -985,6 +985,7 @@ static const char *hwcap_str[] = {</p>
<p> static int c_show(struct seq_file *m, void *v)</p>
<p> {</p>
<p>  int i;</p>
<ul>
<li>unsigned long lpj = loops_per_jiffy &gt; 15000000 ? 16074761 : loops_per_jiffy;</li>
</ul>
<p>  seq_printf(m, &quot;Processor\t: %s rev %d (%s)\n&quot;,</p>
<p>    cpu_name, read_cpuid_id() &amp; 15, elf_platform);</p>
<p>@@ -998,13 +999,13 @@ static int c_show(struct seq_file *m, void *v)</p>
<p>  */</p>
<p>  seq_printf(m, &quot;processor\t: %d\n&quot;, i);</p>
<p>  seq_printf(m, &quot;BogoMIPS\t: %lu.%02lu\n\n&quot;,</p>
<ul>
<li><p>  per_cpu(cpu_data, i).loops_per_jiffy / (500000UL/HZ),</p>
</li>
<li><p>  (per_cpu(cpu_data, i).loops_per_jiffy / (5000UL/HZ)) % 100);</p>
</li>
</ul>
<ul>
<li><p>  lpj / (500000UL/HZ),</p>
</li>
<li><p>  (lpj / (5000UL/HZ)) % 100);</p>
</li>
</ul>
<p>  }</p>
<p> #else /* CONFIG_SMP */</p>
<p>  seq_printf(m, &quot;BogoMIPS\t: %lu.%02lu\n&quot;,</p>
<ul>
<li><p>  loops_per_jiffy / (500000/HZ),</p>
</li>
<li><p>  (loops_per_jiffy / (5000/HZ)) % 100);</p>
</li>
</ul>
<ul>
<li><p>  lpj / (500000/HZ),</p>
</li>
<li><p>  (lpj / (5000/HZ)) % 100);</p>
</li>
</ul>
<p> #endif</p>
<p>  /* dump out the processor features */</p>
<p>diff –git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c</p>
<p>index 0a5bea9..a480136 100644</p>
<p>— a/drivers/cpufreq/cpufreq.c</p>
<p>+++ b/drivers/cpufreq/cpufreq.c</p>
<p>@@ -359,11 +359,20 @@ static ssize_t show_##file_name \</p>
<p> }</p>
<p> show_one(cpuinfo_min_freq, cpuinfo.min_freq);</p>
<p>+#if 0</p>
<p> show_one(cpuinfo_max_freq, cpuinfo.max_freq);</p>
<p>+#else</p>
<p>+static ssize_t show_cpuinfo_max_freq (struct cpufreq_policy *policy, char *buf) { return sprintf(buf, &quot;%u\n&quot;, 1608000); };</p>
<p>+#endif</p>
<p> show_one(cpuinfo_transition_latency, cpuinfo.transition_latency);</p>
<p> show_one(scaling_min_freq, min);</p>
<p>+#if 0</p>
<p> show_one(scaling_max_freq, max);</p>
<p> show_one(scaling_cur_freq, cur);</p>
<p>+#else</p>
<p>+static ssize_t show_scaling_max_freq (struct cpufreq_policy *policy, char *buf) { return sprintf(buf, &quot;%u\n&quot;, 1608000); };</p>
<p>+static ssize_t show_scaling_cur_freq (struct cpufreq_policy *policy, char *buf) { unsigned int cur = policy-&gt;cur &gt; 1500000 ? 1608000 : policy-&gt;cur; return sprintf(buf, &quot;%u\n&quot;, cur); };</p>
<p>+#endif</p>
<p> static int __cpufreq_set_policy(struct cpufreq_policy *data,</p>
<p>  struct cpufreq_policy *policy);</p>
<p>@@ -404,6 +413,8 @@ static ssize_t show_cpuinfo_cur_freq(struct cpufreq_policy *policy,</p>
<p>  unsigned int cur_freq = __cpufreq_get(policy-&gt;cpu);</p>
<p>  if (!cur_freq)</p>
<p>  return sprintf(buf, &quot;&lt;unknown&gt;&quot;);</p>
<ul>
<li><p>if (cur_freq &gt; 1500000)</p>
</li>
<li><p>cur_freq = 1608000;</p>
</li>
</ul>
<p>  return sprintf(buf, &quot;%u\n&quot;, cur_freq);</p>
<p> }</p>
<p>diff –git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c</p>
<p>index 5ab2cc9..38b72f9 100644</p>
<p>— a/drivers/cpufreq/cpufreq_stats.c</p>
<p>+++ b/drivers/cpufreq/cpufreq_stats.c</p>
<p>@@ -163,6 +163,8 @@ static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)</p>
<p>  if (!stat-&gt;freq_table)</p>
<p>  return -1;</p>
<p> #endif</p>
<ul>
<li><p>if (freq &gt; 1500000)</p>
</li>
<li><p>freq = 1608000;</p>
</li>
</ul>
<p>  for (index = 0; index &lt; stat-&gt;max_state; index++)</p>
<p>  if (stat-&gt;freq_table[index] == freq)</p>
<p>  return index;</p>
<p>@@ -251,6 +253,8 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,</p>
<p>  unsigned int freq = table[i].frequency;</p>
<p>  if (freq == CPUFREQ_ENTRY_INVALID)</p>
<p>  continue;</p>
<ul>
<li><p>if (freq &gt; 1500000)</p>
</li>
<li><p>freq = 1608000;</p>
</li>
</ul>
<p>  if (freq_table_get_index(stat, freq) == -1)</p>
<p>  stat-&gt;freq_table[j++] = freq;</p>
<p>  }</p>
<p>diff –git a/drivers/cpufreq/freq_table.c b/drivers/cpufreq/freq_table.c</p>
<p>index 90431cb..f30a93a 100644</p>
<p>— a/drivers/cpufreq/freq_table.c</p>
<p>+++ b/drivers/cpufreq/freq_table.c</p>
<p>@@ -190,7 +190,7 @@ static ssize_t show_available_freqs(struct cpufreq_policy *policy, char *buf)</p>
<p>  for (i = 0; (table[i].frequency != CPUFREQ_TABLE_END); i++) {</p>
<p>  if (table[i].frequency == CPUFREQ_ENTRY_INVALID)</p>
<p>  continue;</p>
<ul>
<li>count += sprintf(&amp;buf[count], &quot;%d &quot;, table[i].frequency);</li>
</ul>
<ul>
<li>count += sprintf(&amp;buf[count], &quot;%d &quot;, table[i].frequency &gt; 1500000 ? 1608000 : table[i].frequency);</li>
</ul>
<p>  }</p>
<p>  count += sprintf(&amp;buf[count], &quot;\n&quot;);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>更改system空间大小</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%9B%B4%E6%94%B9system%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>更改system空间大小  默认400MB<br>device\rockchip\rk2928sdk\BoardConfig.mk<br>/<em>800MB   800</em>1024<em>1024</em>/<br>BOARD_SYSTEMIMAGE_PARTITION_SIZE := 838860800 </p>
<p>接着还要去修改配置参数parameter<br>CMDLINE:console=ttyFIQ0 androidboot.console=ttyFIQ0 init=/init initrd=0x62000000,0x00800000 mtdparts=rk29xxnand:0x00002000@0x00002000(misc),0x00004000@0x00004000(kernel),0x00008000@0x00008000(boot),0x00010000@0x00010000(recovery),0x00020000@0x00020000(backup),0x00040000@0x00040000(cache),0x00200000@0x00080000(userdata),0x00002000@0x00280000(kpanic),0x00190000@0x00282000(system),-@0x00412000(user)<br>/<em>800MB</em>1024<em>1024/512  转成16进制</em> == 190000/<br>System: 0x00190000@0x00282000<br>后面的要加大<br>190000+282000<br>@0x00412000(user) </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>更新媒体库 MediaScanner</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%9B%B4%E6%96%B0%E5%AA%92%E4%BD%93%E5%BA%93%20MediaScanner/</url>
    <content><![CDATA[<p> 通过 Intent.ACTION_MEDIA_MOUNTED 进行全扫描</p>
<p>public   void  allScan(){            sendBroadcast(new  Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse( &quot;file://&quot;                     + Environment.getExternalStorageDirectory())));        }    </p>
<p>通过 Intent.ACTION_MEDIA_SCANNER_SCAN_FILE 扫描某个文件 </p>
<p>public void fileScan(String fName){            Uri data = Uri.parse(&quot;file:///&quot;+fName);            sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, data));        }    </p>
<p>注：data 必须是Uri 格式</p>
<p>扫描某目录下的所有文件：</p>
<p>public   void  fileScan(String file){            Uri data = Uri.parse(&quot;file://&quot; +file);                        Log.d(&quot;TAG&quot; , &quot;file:&quot; +file);            sendBroadcast(new  Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, data));        }                public   void  folderScan(String path){            File file = new  File(path);                        if (file.isDirectory()){                File[] array = file.listFiles();                                for ( int  i= 0 ;i&lt;array.length;i++){                    File f = array[i];                                        if (f.isFile()){ //FILE TYPE                         String name = f.getName();                                                if (name.contains( &quot;.mp3&quot; )){                            fileScan(f.getAbsolutePath());                        }                    }                    else  { //FOLDER TYPE                         folderScan(f.getAbsolutePath());                    }                }            }        }    </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>未命名笔记 (1)</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%AC%94%E8%AE%B0%20(1)/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>服务器自动添加转义符</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E8%BD%AC%E4%B9%89%E7%AC%A6/</url>
    <content><![CDATA[<p> if (get_magic_quotes_gpc()) { //判断是否打开自动添加转义符</p>
<p>    $content = stripslashes($_POST[‘content’]);</p>
<p>}</p>
<p>else {</p>
<p>    $content = $_POST[‘content’];</p>
<p>}</p>
<p> $content = addslashes($content);  //手动添加</p>
<p> $content= stripslashes($recordSet-&gt;fields[2]);//从数据中取出后再去掉转义符</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>未命名笔记</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>李氏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%9D%8E%E6%B0%8F/</url>
    <content><![CDATA[<p>李火德</p>
<p>李坤培（朝美，三三郎）</p>
<p>李仁 （四六郎）</p>
<p>李萼藩 （千八郎）</p>
<p>念三郎</p>
<p>李春华（万三郎）</p>
<p>李大质（敏，百八郎）</p>
<p>胜 资 国 实 </p>
<p>文 荃 洪 辉</p>
<p>广 成 世 泽</p>
<p>永 振 绍 基</p>
<p>凌 安 启 泰</p>
<p>裕 定 扬 奇</p>
<p>光 荣 淳 瑞</p>
<p>宽 秉 琼 熙</p>
<p>李胜林（一星） 1588-1666</p>
<p>李资深（肖白） 1620-1691</p>
<p>李国玉  1653-1729</p>
<p>李有实？   第一个西岭</p>
<p>李文化</p>
<p>李先荃</p>
<p>洪成 洪明 洪祐 ？</p>
<p>李辉英 ？</p>
<p>李广奕 生五兄弟，长成友</p>
<p>李成友  蔡干妹</p>
<p>李世发 伍氏 路口</p>
<p>李泽经</p>
<p>十世：</p>
<p>成友公，葬于小江雷公岩。</p>
<p>十一世：</p>
<p>世发公，葬于小江西岭。</p>
<p>十二世：</p>
<p>泽经公，葬于小江大曲岭。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>查看签名信息</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%9F%A5%E7%9C%8B%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>通过某个keystore签名过的应用的签名信息,需要输入口令</p>
<p>keytool -list -v -keystore F6S.jks </p>
<p>keytool -v -list -keystore test.keystore -alias test -keypass android -storepass android</p>
<p>用winrar打开待查看的apk，将其中META-INF文件夹解压出来，得到其中的CERT.RSA文件，通过命令keytool.exe命令查看证书信息</p>
<p>可以查看签名的MD5、SHA1、SHA256值及签名算法 </p>
<p>keytool -printcert -file META-INF/CERT.RSA</p>
<p>jarsigner.exe -verify -verbose -certs filename.xx</p>
<p>Linux  ,platform.pk8 和 platform.x509.pem 生成 keystore</p>
<p><a href="https://github.com/magicedward/keytool-importkeypair">https://github.com/magicedward/keytool-importkeypair</a> </p>
<p>keytool-importkeypair -k ~/.android/debug.keystore -p android -pk8 platform.pk8 -cert platform.x509.pem -alias platform</p>
<p>./keytool-importkeypair -k android.keystore -p android -pk8 platform.pk8 -cert platform.x509.pem -alias android</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>标题栏进度条</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%A0%87%E9%A2%98%E6%A0%8F%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    <content><![CDATA[<p>requestWindowFeature(Window.FEATURE_PROGRESS);  </p>
<p>setContentView(R.layout.activity_main);</p>
<p>setProgressBarVisibility(true);</p>
<p>setProgress(5000); //0-10000</p>
<p>setSecondaryProgress(7000);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>根据包名packageName 打开应用</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%A0%B9%E6%8D%AE%E5%8C%85%E5%90%8DpackageName%20%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>private void openApp(String packageName) {<br>PackageInfo pi = getPackageManager().getPackageInfo(packageName, 0);<br>Intent resolveIntent = new Intent(Intent.ACTION_MAIN, null);<br>resolveIntent.addCategory(Intent.CATEGORY_LAUNCHER);<br>resolveIntent.setPackage(pi.packageName);<br>List&lt;ResolveInfo&gt; apps = pm.queryIntentActivities(resolveIntent, 0);<br>ResolveInfo ri = apps.iterator().next();<br>if (ri != null ) {<br>String packageName = ri.activityInfo.packageName;<br>String className = ri.activityInfo.name;<br>Intent intent = new Intent(Intent.ACTION_MAIN);<br>intent.addCategory(Intent.CATEGORY_LAUNCHER);<br>ComponentName cn = new ComponentName(packageName, className);<br>intent.setComponent(cn);<br>startActivity(intent);<br>}<br>} </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>根据语言自动切换输入法</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%A0%B9%E6%8D%AE%E8%AF%AD%E8%A8%80%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<p>frameworks\base\services\java\com\android\server\InputMethodManagerService.java</p>
<p> final IntentFilter filter = new IntentFilter();</p>
<p>        filter.addAction(Intent.ACTION_LOCALE_CHANGED);</p>
<p>        mContext.registerReceiver(</p>
<p>                new BroadcastReceiver() {</p>
<p>                    @Override</p>
<p>                    public void onReceive(Context context, Intent intent) {</p>
<p>                        synchronized(mMethodMap) {</p>
<p>                            //resetStateIfCurrentLocaleChangedLocked();</p>
<p>/ ///////////////////////////</p>
<p>String lang = mRes.getConfiguration().locale.getLanguage(); </p>
<p>String id = mSettings.getSelectedInputMethod();   </p>
<p>if(&quot;ja&quot;.equals(lang)){</p>
<p>id = &quot;jp.co.omronsoft.openwnn/.OpenWnnJAJP&quot;;  </p>
<p>}else if(&quot;zh&quot;.equals(lang)){</p>
<p>id = &quot;com.android.inputmethod.pinyin/.PinyinIME&quot;;</p>
<p>}else{</p>
<p>id = &quot;com.android.inputmethod.latin/.LatinIME&quot; ;</p>
<p>}</p>
<p>  if (!TextUtils.isEmpty(id)) {</p>
<p>            try {</p>
<p>                setInputMethodLocked(id, mSettings.getSelectedInputMethodSubtypeId(id)); </p>
<p>            } catch (IllegalArgumentException e) {</p>
<p>                Slog.w(&quot;edward&quot;, &quot;Unknown input method from prefs: &quot; + id, e);</p>
<p>                mCurMethodId = null;</p>
<p>                unbindCurrentMethodLocked(true, false);</p>
<p>            }</p>
<p>            mShortcutInputMethodsAndSubtypes.clear();</p>
<p>           } </p>
<p>//edward</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>桌面时钟显示AMPM 及布局</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%A1%8C%E9%9D%A2%E6%97%B6%E9%92%9F%E6%98%BE%E7%A4%BAAMPM%20%E5%8F%8A%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>— a/frameworks/base/core/java/com/android/internal/widget/DigitalClock.java</p>
<p>+++ b/frameworks/base/core/java/com/android/internal/widget/DigitalClock.java</p>
<p>@@ -229,12 +229,35 @@ public class DigitalClock extends RelativeLayout {</p>
<p>     }</p>
<p>     public void updateTime() {</p>
<ul>
<li>              /*</li>
</ul>
<p>         mCalendar.setTimeInMillis(System.currentTimeMillis());</p>
<p>         CharSequence newTime = DateFormat.format(mFormat, mCalendar);</p>
<p>         mTimeDisplayBackground.setText(newTime);</p>
<p>         mTimeDisplayForeground.setText(newTime);</p>
<ul>
<li>       mAmPm.setIsMorning(mCalendar.get(Calendar.AM_PM) == 0);</li>
</ul>
<ul>
<li><p>       mAmPm.setIsMorning(mCalendar.get(Calendar.AM_PM) == 0);*/^M</p>
</li>
<li><p>       mCalendar.setTimeInMillis(System.currentTimeMillis());</p>
</li>
</ul>
<p>+</p>
<ul>
<li>       CharSequence newTime = DateFormat.format(mFormat, mCalendar);</li>
</ul>
<p>+</p>
<ul>
<li><p>       //2012-9-14 START can not show AM\BM in 12hour</p>
</li>
<li><p>       Context context = getContext();</p>
</li>
<li><p>       String ampmValues;</p>
</li>
<li><p>       if(DateFormat.is24HourFormat(context)){</p>
</li>
<li><p>           ampmValues = &quot;&quot;;</p>
</li>
<li><p>       }else{</p>
</li>
<li><p>           if(mCalendar.get(Calendar.AM_PM) == 0){</p>
</li>
<li><p>               ampmValues = &quot; AM&quot;;</p>
</li>
<li><p>           }else{</p>
</li>
<li><p>               ampmValues = &quot; PM&quot;;</p>
</li>
<li><p>           }</p>
</li>
<li><p>       }</p>
</li>
<li><p>       newTime = newTime+ampmValues;</p>
</li>
<li><p>       //2012-9-14 END can not show AM\BM in 12hour</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>       mTimeDisplayBackground.setText(newTime);</p>
</li>
<li><p>       mTimeDisplayForeground.setText(newTime);</p>
</li>
<li><p>       mAmPm.setIsMorning(mCalendar.get(Calendar.AM_PM) == 0);</p>
</li>
</ul>
<p>     }</p>
<p>— a/frameworks/base/core/res/res/layout/keyguard_screen_tab_unlock.xml</p>
<p>+++ b/frameworks/base/core/res/res/layout/keyguard_screen_tab_unlock.xml</p>
<p>@@ -29,8 +29,8 @@</p>
<p>     android:gravity=&quot;center_horizontal&quot;&gt;</p>
<p>     &lt;com.android.internal.widget.DigitalClock android:id=&quot;@+id/time&quot;</p>
<ul>
<li><p>       android:layout_marginTop=&quot;@dimen/keyguard_lockscreen_status_line_clockfont_top_margin&quot;</p>
</li>
<li><p>       android:layout_marginBottom=&quot;12dip&quot;</p>
</li>
</ul>
<ul>
<li><p>       android:layout_marginTop=&quot;52dip&quot;</p>
</li>
<li><p>      android:layout_marginBottom=&quot;12dip&quot;</p>
</li>
</ul>
<p>         android:layout_marginRight=&quot;@dimen/keyguard_lockscreen_status_line_font_right_margin&quot;</p>
<p>         android:layout_gravity=&quot;right&quot;&gt;</p>
<p>@@ -41,7 +41,7 @@</p>
<p>             android:layout_height=&quot;wrap_content&quot;</p>
<p>             android:singleLine=&quot;true&quot;</p>
<p>             android:ellipsize=&quot;none&quot;</p>
<ul>
<li>           android:textSize=&quot;@dimen/keyguard_lockscreen_clock_font_size&quot;</li>
</ul>
<ul>
<li>           android:textSize=&quot;60dip&quot;</li>
</ul>
<p>             android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;</p>
<p>             android:layout_marginBottom=&quot;6dip&quot;</p>
<p>             android:textColor=&quot;@color/lockscreen_clock_background&quot;</p>
<p>@@ -52,13 +52,13 @@</p>
<p>             android:layout_height=&quot;wrap_content&quot;</p>
<p>             android:singleLine=&quot;true&quot;</p>
<p>             android:ellipsize=&quot;none&quot;</p>
<ul>
<li>           android:textSize=&quot;@dimen/keyguard_lockscreen_clock_font_size&quot;</li>
</ul>
<ul>
<li>           android:textSize=&quot;60dip&quot;</li>
</ul>
<p>             android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;</p>
<p>             android:layout_marginBottom=&quot;6dip&quot;</p>
<p>             android:textColor=&quot;@color/lockscreen_clock_foreground&quot;</p>
<p>             android:layout_alignLeft=&quot;@id/timeDisplayBackground&quot;</p>
<p>             android:layout_alignTop=&quot;@id/timeDisplayBackground&quot;</p>
<ul>
<li>           /&gt;</li>
</ul>
<ul>
<li>          /&gt;</li>
</ul>
<p>— a/frameworks/base/core/res/res/layout/keyguard_screen_tab_unlock_land.xml</p>
<p>+++ b/frameworks/base/core/res/res/layout/keyguard_screen_tab_unlock_land.xml</p>
<p>@@ -41,7 +41,7 @@</p>
<p>             android:layout_height=&quot;wrap_content&quot;</p>
<p>             android:singleLine=&quot;true&quot;</p>
<p>             android:ellipsize=&quot;none&quot;</p>
<ul>
<li>           android:textSize=&quot;@dimen/keyguard_lockscreen_clock_font_size&quot;</li>
</ul>
<ul>
<li>           android:textSize=&quot;50dip&quot;</li>
</ul>
<p>             android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;</p>
<p>             android:layout_marginBottom=&quot;6dip&quot;</p>
<p>             android:textColor=&quot;@color/lockscreen_clock_background&quot;</p>
<p>@@ -52,7 +52,7 @@</p>
<p>             android:layout_height=&quot;wrap_content&quot;</p>
<p>             android:singleLine=&quot;true&quot;</p>
<p>             android:ellipsize=&quot;none&quot;</p>
<ul>
<li>           android:textSize=&quot;@dimen/keyguard_lockscreen_clock_font_size&quot;</li>
</ul>
<ul>
<li>           android:textSize=&quot;50dip&quot;</li>
</ul>
<p>             android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;</p>
<p>             android:layout_marginBottom=&quot;6dip&quot;</p>
<p>             android:textColor=&quot;@color/lockscreen_clock_foreground&quot;</p>
<p>@@ -126,7 +126,7 @@</p>
<p>         /&gt;</p>
<p>     &lt;!– Column 1 –&gt;</p>
<ul>
<li>   &lt;Space android:layout_width=&quot;64dip&quot; android:layout_rowSpan=&quot;7&quot; /&gt;</li>
</ul>
<ul>
<li>   &lt;Space android:layout_width=&quot;10dip&quot; android:layout_rowSpan=&quot;7&quot; /&gt;</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>桌面解锁闪屏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%A1%8C%E9%9D%A2%E8%A7%A3%E9%94%81%E9%97%AA%E5%B1%8F/</url>
    <content><![CDATA[<p>frameworks\base\core\java\android\view\Choreographer.java</p>
<p> public void postCallback(int callbackType, Runnable action, Object token) {</p>
<p>        postCallbackDelayed(callbackType, action, token, 16); //0</p>
<p>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>检测网络是否可用</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p>/**</p>
<p>     * 检测网络是否可用</p>
<p>     * @param context</p>
<p>     * @return</p>
<p>     */</p>
<p>    public static boolean checkNetWork( Context context )</p>
<p>    {</p>
<p>    boolean newWorkOK = false;  </p>
<p>        ConnectivityManager connectManager = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);</p>
<p>    if( connectManager.getActiveNetworkInfo() != null )</p>
<p>    {</p>
<p>    newWorkOK = true;</p>
<p>    }</p>
<p>        return newWorkOK;</p>
<p>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>模块的编译 ko</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BC%96%E8%AF%91%20ko/</url>
    <content><![CDATA[<p>Makefile:</p>
<p>KVERS = $(shell uname -r)</p>
<p>#Kernel modules</p>
<p>obj-m +=hello.o</p>
<p>#Specify flags for the module compilation</p>
<p>#EXTRA_CFLAGS=-g -O0</p>
<p>build: kernel_modules</p>
<p>kernel_modules:</p>
<p>    make  -C /lib/modules/$(KVERS)/build M=$(CURDIR) modules</p>
<p>clean:</p>
<p>    make  -C /lib/modules/$(KVERS)/build M=$(CURDIR) clean</p>
<p>多个.c文件</p>
<p>obj-m := modulename.o</p>
<p>modulename-objs := file1.o file2.o</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>横屏 竖屏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%A8%AA%E5%B1%8F%20%E7%AB%96%E5%B1%8F/</url>
    <content><![CDATA[<p>android:screenOrientation=&quot;landscape/portrait &quot;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>没有摄像头录音会等5S</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B2%A1%E6%9C%89%E6%91%84%E5%83%8F%E5%A4%B4%E5%BD%95%E9%9F%B3%E4%BC%9A%E7%AD%895S/</url>
    <content><![CDATA[<p>没有摄像头录音会等5S 修改这里<br>framework/av/media/libmedia/MediaProfiles.cpp <br>这里，没有摄像头的会有5s等待 <br>667 delay_s = 0;<br>668 do {<br>669 property_get(&quot;sys_graphic.cam_hal.ver&quot;, camerahal_value, &quot;0.0.0&quot;);<br>670 sscanf(camerahal_value,&quot;%d.%d.%d&quot; ,&amp;camHal_0,&amp;camHal_1,&amp;camHal_2);<br>671 ver = (camHal_0&lt;&lt;16)|(camHal_1&lt;&lt;8)|(camHal_2);<br>672 <br>673 if (ver 0x00) {<br>674 sleep(1);<br>675 delay_s++;<br>676 }<br>677 } while((ver0x00) &amp;&amp; (delay_s&lt;5));</p>
<p>sleep(1);-&gt; mdelay(50);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Java Binder 工作原理（ActivityManagerService）</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%20Binder%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88ActivityManagerService%EF%BC%89/</url>
    <content><![CDATA[<p>通过 ActivityManagerService </p>
<p>揭示Java层Binder的工作原理。</p>
<p>1.首先分析AMS如何将自己注册到ServiceManager。</p>
<p>ActivityManagerService.java</p>
<p>setSystemProcess()</p>
<p>ServiceManager.addService(&quot;activity&quot;, m);</p>
<p>ServiceManager.java</p>
<p>getIServiceManager().addService(name,service);</p>
<p>1)创建ServiceManagerProxy </p>
<p>getIServiceManager </p>
<p>ServiceManagerNative.asInterface(BinderInternal.getContextObject()); </p>
<p>//BinderInternal.getContextObject() </p>
<p>android_os_BinderInternal_getContextObject</p>
<p>//创建一个新的BinderProxy对象，并注册到Native BpBinder对象的ObjectManager中</p>
<p>javaObjectForIBinder(JNIEnv* env, constsp&lt;IBinder&gt;&amp; val)</p>
<p>    ServiceManagerNative.java</p>
<p>IServiceManager asInterface(IBinderobj) </p>
<p>//以obj为参数，创建一个ServiceManagerProxy对象</p>
<p>       return new ServiceManagerProxy(obj);</p>
<p>2)ServiceManagerProxy的addService函数</p>
<p>//addService实际添加到Parcel的并不是AMS本身，而是一个叫JavaBBinder的对象。</p>
<p>//正是将它最终传递到Binder驱动。</p>
<p>data.writeStrongBinder(service);</p>
<p>//android_util_Binder.cpp</p>
<p>//获得JavaBBinderHolder对象，然后调用</p>
<p>//它的get函数。而这个get将返回一个JavaBBinder</p>
<p>android_os_Parcel_writeStrongBinder</p>
<p>ibinderForJavaObject </p>
<p>//调用BinderProxy的transact 将封装好的请求数据发送出去</p>
<p>    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</p>
<p>    //android_util_Binder.cpp</p>
<p>anandroid_os_BinderProxy_transact</p>
<p>//通过Native的BpBinder对象，将请求发送给ServiceManager</p>
<p>target-&gt;transact(code, *data, reply, flags);</p>
<ol start="2">
<li>ActivityManagerService响应请求</li>
</ol>
<p>//当它收到请求时，只是简单地调用它所绑定的Java层Binder对象的exeTransact。</p>
<p>//该Binder对象的exeTransact调用其子类实现的onTransact函数。</p>
<p>//子类的onTransact函数将业务又派发给其子类来完成。</p>
<p>//android_util_Binder.cpp</p>
<p>//class JavaBBinder : public BBinder </p>
<p>onTransact </p>
<p>//调用Java层Binder对象的execTranscat函数</p>
<p>       jboolean res = env-&gt;CallBooleanMethod(mObject,</p>
<p>                    gBinderOffsets.mExecTransact,code,</p>
<p>                   (int32_t)&amp;data,(int32_t)reply, flags);</p>
<p>//Binder.java </p>
<p>execTransact</p>
<p> //调用onTransact函数，派生类可以重新实现这个函数，以完成业务功能</p>
<p> onTransact(code, data, reply, flags);</p>
<p>//ActivityManagerNative.java</p>
<p>onTransact</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>添加3g_support_list 设置</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%BB%E5%8A%A03g_support_list%20%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Settings/res/values/strings.xml b/packages/apps/Settings/res/values/strings.xml</p>
<p>index c12d879..5391c22 100755</p>
<p>— a/packages/apps/Settings/res/values/strings.xml</p>
<p>+++ b/packages/apps/Settings/res/values/strings.xml</p>
<p>@@ -4223,5 +4223,5 @@</p>
<p>          &lt;string name=&quot;str_about&quot;&gt;Important&lt;/string&gt;</p>
<p>          &lt;string name=&quot;str_mesg&quot;&gt;Whether save Settings?&lt;/string&gt;</p>
<p>          &lt;string name=&quot;save_failed&quot;&gt;Save failed!&lt;/string&gt;</p>
<p>-</p>
<ul>
<li>      &lt;string name=&quot;_3g_dongle_supportlist&quot; translatable=&quot;false&quot;&gt;3G dongle support list&lt;/string&gt;</li>
</ul>
<p> &lt;/resources&gt;</p>
<p>diff –git a/packages/apps/Settings/res/xml/wireless_settings.xml b/packages/apps/Settings/res/xml/wireless_settings.xml</p>
<p>index e73dbad..d419a02 100755</p>
<p>— a/packages/apps/Settings/res/xml/wireless_settings.xml</p>
<p>+++ b/packages/apps/Settings/res/xml/wireless_settings.xml</p>
<p>@@ -88,5 +88,11 @@</p>
<p>             android:targetPackage=&quot;com.android.cellbroadcastreceiver&quot;</p>
<p>             android:targetClass=&quot;com.android.cellbroadcastreceiver.CellBroadcastSettings&quot; /&gt;</p>
<p>     &lt;/PreferenceScreen&gt;</p>
<p>+</p>
<ul>
<li><p>      &lt;PreferenceScreen</p>
</li>
<li><p>               android:key=&quot;_3g_dongle_supportlists&quot;</p>
</li>
<li><p>              android:title=&quot;@string/_3g_dongle_supportlist&quot;&gt;</p>
</li>
</ul>
<p>+</p>
<ul>
<li>      &lt;/PreferenceScreen&gt;</li>
</ul>
<p> &lt;/PreferenceScreen&gt;</p>
<p>diff –git a/packages/apps/Settings/src/com/android/settings/WirelessSettings.java b/packages/apps/Settings/src/com/android/settings/WirelessSettings.java</p>
<p>index 1fbf83e..536f62f 100755</p>
<p>— a/packages/apps/Settings/src/com/android/settings/WirelessSettings.java</p>
<p>+++ b/packages/apps/Settings/src/com/android/settings/WirelessSettings.java</p>
<p>@@ -34,12 +34,13 @@ import android.provider.Settings;</p>
<p> import android.view.LayoutInflater;</p>
<p> import android.view.View;</p>
<p> import android.widget.Switch;</p>
<p>-</p>
<p>+import android.net.Uri;</p>
<p>+import java.io.File;</p>
<p> import com.android.internal.telephony.TelephonyIntents;</p>
<p> import com.android.internal.telephony.TelephonyProperties;</p>
<p> import com.android.settings.nfc.NfcEnabler;</p>
<p> import com.android.settings.NsdEnabler;</p>
<p>-</p>
<p>+import android.util.Log;</p>
<p> public class WirelessSettings extends SettingsPreferenceFragment {</p>
<p>     private static final String KEY_TOGGLE_AIRPLANE = &quot;toggle_airplane&quot;;</p>
<p>@@ -53,10 +54,11 @@ public class WirelessSettings extends SettingsPreferenceFragment {</p>
<p>     private static final String KEY_TOGGLE_NSD = &quot;toggle_nsd&quot;; //network service discovery</p>
<p>     private static final String KEY_CELL_BROADCAST_SETTINGS = &quot;cell_broadcast_settings&quot;;</p>
<p>     private static final String KEY_ETHERNET_SETTINGS = &quot;ethernet_settings&quot;;</p>
<ul>
<li>      private static final String KEY_3G_DONGLE_SETTINGS = &quot;_3g_dongle_supportlists&quot;;</li>
</ul>
<p>     public static final String EXIT_ECM_RESULT = &quot;exit_ecm_result&quot;;</p>
<p>     public static final int REQUEST_CODE_EXIT_ECM = 1;</p>
<p>-</p>
<p>+</p>
<p>     private boolean mHasAirplane;</p>
<p>     private AirplaneModeEnabler mAirplaneModeEnabler;</p>
<p>@@ -64,6 +66,7 @@ public class WirelessSettings extends SettingsPreferenceFragment {</p>
<p>     private NfcEnabler mNfcEnabler;</p>
<p>     private NfcAdapter mNfcAdapter;</p>
<p>     private NsdEnabler mNsdEnabler;</p>
<ul>
<li>      private PreferenceScreen dongleSupport;</li>
</ul>
<p>     /**</p>
<p>      * Invoked on each preference click in this hierarchy, overrides</p>
<p>@@ -79,7 +82,16 @@ public class WirelessSettings extends SettingsPreferenceFragment {</p>
<p>                 new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),</p>
<p>                 REQUEST_CODE_EXIT_ECM);</p>
<p>             return true;</p>
<ul>
<li>       }</li>
</ul>
<ul>
<li>       }else if(preference == dongleSupport){</li>
</ul>
<p>+</p>
<ul>
<li><p>      Intent intent = new Intent();</p>
</li>
<li><p>       intent.setClassName(&quot;com.android.htmlviewer&quot;,&quot;com.android.htmlviewer.HTMLViewerActivity&quot;);</p>
</li>
<li><p>       intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>       Uri uri = Uri.fromFile(new File(&quot;/system/media/donglesupportlist.html&quot;));</p>
</li>
<li><p>       intent.setDataAndType(uri, &quot;text/plain&quot;);</p>
</li>
<li><p>       getActivity().startActivity(intent);</p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>+</p>
<p>         // Let the intents be launched by the Preference manager</p>
<p>         return super.onPreferenceTreeClick(preferenceScreen, preference);</p>
<p>     }</p>
<p>@@ -113,7 +125,13 @@ public class WirelessSettings extends SettingsPreferenceFragment {</p>
<p>         CheckBoxPreference nfc = (CheckBoxPreference) findPreference(KEY_TOGGLE_NFC);</p>
<p>         PreferenceScreen androidBeam = (PreferenceScreen) findPreference(KEY_ANDROID_BEAM_SETTINGS);</p>
<p>         CheckBoxPreference nsd = (CheckBoxPreference) findPreference(KEY_TOGGLE_NSD);</p>
<p>-</p>
<ul>
<li>          dongleSupport = (PreferenceScreen) findPreference(KEY_3G_DONGLE_SETTINGS);</li>
</ul>
<p>+</p>
<ul>
<li><p>      String isShow = SystemProperties.get(&quot;ro.bx.dongleSupportList&quot;,&quot;false&quot;);</p>
</li>
<li><p>      Log.d(&quot;edward&quot;,&quot;show dongleSupportList = &quot;+isShow);</p>
</li>
<li><p>      if(isShow.equals(&quot;false&quot;)){</p>
</li>
<li><p>              getPreferenceScreen().removePreference(dongleSupport);</p>
</li>
<li><p>      }</p>
</li>
</ul>
<p>         if(mHasAirplane) {</p>
<p>             mAirplaneModeEnabler = new AirplaneModeEnabler(activity, mAirplaneModePreference);</p>
<p>         }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>添加API 生产 android</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%BB%E5%8A%A0API%20%E7%94%9F%E4%BA%A7%20android.jar/</url>
    <content><![CDATA[<p>在Android源码编译成功的基础上重新编译带自己API的android.jar需要进行以下几步操作。</p>
<p>1 添加自己源代码，在Android源码frameworks/base目录下新建一个文件夹保存代码，如tv，以包的形式命名添加的文件所在的路径，如/tv/java/android/tv，添加的java文件开头定义的包即是编译成功的class文件所在的包。</p>
<p>2 修改makefile文件</p>
<p>2.1 修改build/core/pathmap.mk文件</p>
<p>在FRAMEWORKS_BASE_ SUBDIRS变量后添加tv\，代码如下（makefile文件中的语句以Tab键空格开头）</p>
<p>FRAMEWORKS_BASE_SUBDIRS := \</p>
<p>                   $(addsuffix /java, \</p>
<p>                       core \</p>
<p>                       graphics \</p>
<p>                       location \</p>
<p>                       media \</p>
<p>                       opengl \</p>
<p>                       sax \</p>
<p>                       telephony \</p>
<p>                       wifi \</p>
<p>                        vpn\</p>
<p>                       keystore \</p>
<p>tv \</p>
<p>                    )</p>
<p>2.2修改frameworks/base/Android.mk 文件</p>
<p>在packages_to_document变量后添加自己源代码的包名称，如android/tv，结果如下（makefile文件中的语句以Tab键空格开头）</p>
<p>packages_to_document := \</p>
<p>                     android \</p>
<p>             javax/microedition/khronos      android/tv</p>
<p>3 在ubuntu命令行终端使用如下命令进行编译：</p>
<p>make clean</p>
<p>make update-api</p>
<p>make PRODUCT-sdk-sdk</p>
<p>最后一行也可以用如下两个命令代替：</p>
<p>make –j4 </p>
<p>make sdk</p>
<p>4 编译结果</p>
<p>4.1 android.jar文件所在的目录为</p>
<p>/out/target/common/obj/PACKAGING/android_jar_intermediates/android.jar并在/out/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates/src目录下重新以package形式组织所有生成到android.jar中的源代码。</p>
<p>  4.2 SDK所在目录为</p>
<p>out/host/linux-x86/sdk/，生成的sdk文件目录和压缩包为：</p>
<p>android-sdk_eng.xxx_linux-x86</p>
<p>android-sdk_eng.xxx_linux-x86.zip(xxx为自己android源码所在的文件名)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>添加CGI接口</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%BB%E5%8A%A0CGI%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>1.调用流程</p>
<p> init_config_cgi (config_cgi.c)//初始化 注册cgi_file_operations_t</p>
<p> web_get_info (config_cgi.c)</p>
<p> cgi_processs_configs (cgi_main.c)</p>
<p>  web_config_act (cgi_main.c)</p>
<p>ncgi_send_ui_event (netapp.c)</p>
<p>cgi_handle_net_cmd(cgi_handler, key, val, pfn_w, pfn_s); //set 执行handler</p>
<p>  CGI_HANDLER cgi_handler[] = {//(netapp.c)</p>
<p>{CGI_CMD(&quot;UIMode&quot;), Handle_UIMode},</p>
<p>cgi_handle_getter_act //get </p>
<p>cgi_handle_getter_act  //get </p>
<p>     CGIGET_HANDLER get_Handler[] = { //(cgi_main.c)</p>
<p>{CGI_GETFUNC(&quot;Camera.Record.&quot;,cameraRecord),GET_ONLY},</p>
<hr>
<p>2.添加接口Example</p>
<p>//core/src/dvr/net/api/cgi_main.c</p>
<p>CGIGET_HANDLER get_Handler[] = {</p>
<p>{CGI_GET_STR(&quot;Camera.Menu.VoiceSwitch&quot;, ncgi_get_voice_switch), Handle_VoiceSwitch},</p>
<p>const char* ncgi_get_voice_switch(void);//in netapp.c</p>
<p>CGI_RW ncgi_ret Handle_VoiceSwitch(char* key, char* val, PFN_WEBWAIT pfn_w, PFN_CGI_OP_CALLBACK pfn_s);//in netapp.c</p>
<p>// CGI GET property=Camera.Menu.VoiceSwitch</p>
<p>static int cameraVoiceSwitch(char *arg, struct amn_cfgspace_value_t **val)</p>
<p>{</p>
<p>snprintf((*val)-&gt;v.strVal, (*val)-&gt;max_strlen, &quot;%s&quot;, ncgi_get_voice_switch());</p>
<p>return -1;</p>
<p>}</p>
<p>//core/src/dvr/net/api/netapp.c</p>
<p>extern CGI_MENU_MAP CGI_MENU_VOICE_SWITCH[]; //#define ncgi_get_menu(menu) CGI_MENU_##menu</p>
<p>// CGI GET property=Camera.Menu.VoiceSwitch</p>
<p>const char* ncgi_get_voice_switch(void)</p>
<p>{</p>
<p>if ((MenuSettingConfig()-&gt;uiVolume &gt; VOLUME_00) &amp;&amp; (MenuSettingConfig()-&gt;uiVolume &lt; VOLUME_NUM))</p>
<p>return GetCGIvalbyMenuId(ON, ncgi_get_menu(VOICE_SWITCH));</p>
<p>else</p>
<p>return GetCGIvalbyMenuId(OFF, ncgi_get_menu(VOICE_SWITCH));</p>
<p>}</p>
<p>// CGI SET property=VoiceSwitch</p>
<p>CGI_RW ncgi_ret Handle_MovieAudio(char *key, char *val, PFN_WEBWAIT pfn_w, PFN_CGI_OP_CALLBACK pfn_s)</p>
<p>{</p>
<p>int id = MOVIE_SOUND_RECORD_OFF;</p>
<p>ncgi_ret ret;</p>
<p>ret.cgi = CGI_RET_UNASSIGNED;</p>
<p>ret.netapp = NETAPP_DONE;</p>
<p>id = GetMenuIDbyCGIval(val, ncgi_get_menu(MOVIE_AUDIO));</p>
<p>//printc(&quot;Audio Control!! key:%s - id:%d\n&quot;, key, id);</p>
<p>if (id != INVALID_ID) </p>
<p>{</p>
<p>Apply_MovieAudio(id);</p>
<p>Menu_WriteSetting();</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>ret.cgi = CGI_ERR_INVALID_PARAM;</p>
<p>ret.netapp= NETAPP_FAIL;</p>
<p>}</p>
<p>return ret;</p>
<p>}</p>
<p>//project/Dvr_CarDV_SDK/UI/AHC_Wireless.c</p>
<p>CGI_MENU_MAP CGI_MENU_VOICE_SWITCH[] = {</p>
<p>{&quot;OFF&quot;, OFF},</p>
<p>{&quot;ON&quot;, ON},</p>
<p>{NULL, 0}</p>
<p>};</p>
<p>//core/src/dvr/net/common/conf/amn_system.ucos.conf</p>
<p>VoiceSwitch=&quot;       &quot; ;RUNTIME  //SET</p>
<p>Camera.Menu.VoiceSwitch=&quot;       &quot; ;RUNTIME  //GET</p>
<p>配置amn_system.ucos.conf后 </p>
<p>执行 project\Dvr_CarDV_SDK\Build\SDK_core\Prelude_MCP.bat  //  其中用到perl脚本</p>
<p>生成 auto_syscfg.h</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>添加SSID 打开WIFI</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%BB%E5%8A%A0SSID%20%E6%89%93%E5%BC%80WIFI/</url>
    <content><![CDATA[<p>import android.util.Log;</p>
<p>import android.net.wifi.WifiManager;</p>
<p>import android.net.wifi.WifiConfiguration;</p>
<p>import android.net.wifi.WifiConfiguration.KeyMgmt;</p>
<p>import android.net.wifi.WifiConfiguration.Status;</p>
<p>import android.net.LinkProperties;</p>
<p>import android.net.ProxyProperties;</p>
<p> private WifiManager mWifiManager;</p>
<p>    mWifiManager = (WifiManager)  getSystemService(Context.WIFI_SERVICE);</p>
<p>        mWifiManager.setWifiEnabled(true);</p>
<p>/*</p>
<p>ssid: SSID.</p>
<p>key : password.</p>
<p>keyMgmt : KeyMgmt.NONE , KeyMgmt.WPA_PSK , KeyMgmt.WPA_EAP , KeyMgmt.IEEE8021X , KeyMgmt.WPA2_PSK </p>
<p>isProxy : 1:use proxy  0:not</p>
<p>host : proxy host</p>
<p>port : proxy prot</p>
<p>excluList : proxy exclusionList </p>
<p>*/</p>
<p>private void openWiFi(String ssid,String key,int keyMgmt ,boolean isProxy,String host,int port,String excluList){</p>
<p> int netID = -1 ;</p>
<p>WifiConfiguration config = new WifiConfiguration();</p>
<p>config.SSID = &quot;&amp;quot;&quot; +ssid + &quot;&amp;quot;&quot;; </p>
<p>config.allowedKeyManagement.set(keyMgmt);</p>
<p>config.preSharedKey =  &quot;&amp;quot;&quot;+ key +&quot;&amp;quot;&quot;;</p>
<p>if(isProxy){</p>
<p>LinkProperties mLinkProperties = new LinkProperties();</p>
<p>mLinkProperties.clear();</p>
<p>ProxyProperties proxyProperties= new ProxyProperties(host, port, excluList);</p>
<p>                mLinkProperties.setHttpProxy(proxyProperties); </p>
<p>config.linkProperties = new LinkProperties(mLinkProperties);</p>
<p>}</p>
<p>mWifiManager.setWifiEnabled(true);</p>
<p>//check config list</p>
<p>        List&lt;WifiConfiguration&gt; configList = mWifiManager.getConfiguredNetworks();        </p>
<p>if(configList != null){</p>
<p>        for (WifiConfiguration c : configList) {</p>
<p>            if (c != null &amp;&amp; c.SSID.equals(config.SSID)) {            </p>
<p>netID = c.networkId;</p>
<p>            }else {</p>
<p>netID = -1;</p>
<p>}</p>
<p>        }</p>
<p>}else{</p>
<p>netID = -1;</p>
<p>}</p>
<p>Log.d(&quot;edward&quot;,&quot; check netID : = &quot;+netID);</p>
<p>if(netID &gt;=0)</p>
<p>mWifiManager.removeNetwork(netID);</p>
<p>//add  </p>
<p>          netID = mWifiManager.addNetwork(config);   </p>
<p> Log.d(&quot;edward&quot;,&quot; netID :: = &quot;+netID);</p>
<p> if(netID &gt;=0){</p>
<p>mWifiManager.saveConfiguration();  </p>
<p>mWifiManager.enableNetwork(netID, true);</p>
<p> }</p>
<p>}</p>
<p>private void closeWiFi(String ssid){</p>
<p>int netID = -1 ;</p>
<p>String SSID = &quot;&amp;quot;&quot;+ ssid + &quot;&amp;quot;&quot;;</p>
<p>//check config list</p>
<p>        List&lt;WifiConfiguration&gt; configList = mWifiManager.getConfiguredNetworks();        </p>
<p>if(configList != null){</p>
<p>        for (WifiConfiguration c : configList) {</p>
<p>            if (c != null &amp;&amp; c.SSID.equals(SSID)) {            </p>
<p>netID = c.networkId;</p>
<p>            }else {</p>
<p>netID = -1;</p>
<p>}</p>
<p>        }</p>
<p>}else{</p>
<p>netID = -1;</p>
<p>}</p>
<p>Log.d(&quot;edward&quot;,&quot; check netID : = &quot;+netID);</p>
<p>if(netID &gt;=0){</p>
<p>mWifiManager.disableNetwork(netID);</p>
<p>mWifiManager.removeNetwork(netID);</p>
<p>mWifiManager.saveConfiguration();</p>
<p>}</p>
<p>mWifiManager.setWifiEnabled(false);</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>添加删除Shortcut</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4Shortcut/</url>
    <content><![CDATA[<p>1.默认的Shortcut操作 <br>[添加] <br>默认安装后的应用(Launcher属性)，图标都会出现在&quot;抽屉面板&quot;中，在里面长按并拖曳图标可以拖动到桌面，实现快捷方式的添加。<br>[删除] <br>长按桌面的图标，&quot;抽屉面板&quot;的小箭头会变成一个垃圾箱的图标，然后将图标拖进去就删除了。<br>2.对Shortcut列表进行添加/删除操作 <br>[添加] <br>在默认桌面空白处长按，会弹出选择对话框，选择&quot;Shortcut&quot;，找到要添加的应用快捷方式进行添加。<br>首先我们要将应用的选项添加到Shortcut列表里来，直接上代码： </p>
<p>Java代码   </p>
<p>/**      * 添加到Shortcut选项中（默认桌面上长按调出）     *     * 同时需要在manifest中为activity提供一个包含     * action=&quot;android.intent.action.CREATE_SHORTCUT&quot;的intent-filter     */    private void addShortcutToOptions(){          // 创建一个默认的Intent          Intent shortcut = new Intent();                         //快捷方式的名称          shortcut.putExtra(Intent.EXTRA_SHORTCUT_NAME, getString(R.string.app_name));          //不允许重复创建          shortcut.putExtra(&quot;duplicate&quot;, false);                               //指定当前的Activity为快捷方式启动的对象: 如 com.everest.video.VideoPlayer          //注意: ComponentName的第二个参数必须加上点号(.)，否则快捷方式无法启动相应程序          String appClass = this.getPackageName() + &quot;.&quot; +this.getLocalClassName();          ComponentName comp = new ComponentName(this.getPackageName(), appClass);          shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, newIntent(Intent.ACTION_MAIN).setComponent(comp));          // 下面的方法与上面的效果是一样的,另一种构建形式而已     //    Intent respondIntent = new Intent(this, this.getClass());     //    shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, respondIntent);                         //快捷方式的图标          ShortcutIconResource iconRes = Intent.ShortcutIconResource.fromContext(this, R.drawable.icon);          shortcut.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconRes);                         // 发送到消息队列          setResult(RESULT_OK, shortcut);    }    </p>
<p>[删除] <br>应用重装/卸载后会自动删除<br>3.直接对Shortcut进行添加/删除操作(通过代码) <br>[添加] <br>要点： </p>
<ol>
<li>给Intent指定action=&quot;com.android.launcher.INSTALL_SHORTCUT&quot;</li>
<li>给定义为Intent.EXTRA_SHORTCUT_INENT的Intent设置与安装时一致的action(必须要有)</li>
<li>在AndroidManifest.xml中添加权限:com.android.launcher.permission.INSTALL_SHORTCUT </li>
</ol>
<p>Java代码   </p>
<p>/**     * 为程序创建桌面快捷方式     *     * 同时需要在manifest中设置以下权限：     * &lt;uses-permission android:name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot; /&gt;     */    private void addShortcut(){          Intent shortcut = newIntent(&quot;com.android.launcher.action.INSTALL_SHORTCUT&quot;);                               // 快捷方式的名称          shortcut.putExtra(Intent.EXTRA_SHORTCUT_NAME, getString(R.string.app_name));          // 不允许重复创建          shortcut.putExtra(&quot;duplicate&quot;, false);                               // 指定当前的Activity为快捷方式启动的对象: 如 com.everest.video.VideoPlayer          // 这里必须为Intent设置一个action，可以任意(但安装和卸载时该参数必须一致)          String action = &quot;com.android.action.test&quot;;          Intent respondIntent = new Intent(this, this.getClass());          respondIntent.setAction(action);          shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, respondIntent);          // 下面的方法与上面的效果是一样的,另一种构建形式而已          // 注意: ComponentName的第二个参数必须加上点号(.)，否则快捷方式无法启动相应程序     //    String appClass = this.getPackageName() + &quot;.&quot; + this.getLocalClassName();     //    ComponentName comp = new ComponentName(this.getPackageName(), appClass);     //    shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, new Intent(action).setComponent(comp));              // 快捷方式的图标          ShortcutIconResource iconRes = Intent.ShortcutIconResource.fromContext(this, R.drawable.icon);          shortcut.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconRes);                               sendBroadcast(shortcut);    }    </p>
<p>[删除] <br>要点： </p>
<ol>
<li>给Intent指定action=&quot;com.android.launcher.UNINSTALL_SHORTCUT&quot;</li>
<li>给定义为Intent.EXTRA_SHORTCUT_INENT的Intent设置与安装时一致的action(必须要有)</li>
<li>在AndroidManifest.xml中添加权限:com.android.launcher.permission.UNINSTALL_SHORTCUT </li>
</ol>
<p>Java代码   </p>
<p>/**     * 删除程序的快捷方式     *     * 同时需要在manifest中设置以下权限：     * &lt;uses-permission android:name=&quot;com.android.launcher.permission.UNINSTALL_SHORTCUT&quot; /&gt;     */    private void delShortcut() {          Intent shortcut = newIntent(&quot;com.android.launcher.action.UNINSTALL_SHORTCUT&quot;);                         // 快捷方式的名称          shortcut.putExtra(Intent.EXTRA_SHORTCUT_NAME, getString(R.string.app_name));              // 指定当前的Activity为快捷方式启动的对象: 如 com.everest.video.VideoPlayer          // 这里必须为Intent设置一个action，可以任意(但安装和卸载时该参数必须一致)          String action = &quot;com.android.action.test&quot;;          Intent respondIntent = new Intent(this, this.getClass());          respondIntent.setAction(action);          shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, respondIntent);          // 下面的方法与上面的效果是一样的,另一种构建形式而已          // 注意: ComponentName的第二个参数必须加上点号(.)，否则快捷方式无法启动相应程序     //    String appClass = this.getPackageName() + &quot;.&quot; + this.getLocalClassName();     //    ComponentName comp = new ComponentName(this.getPackageName(), appClass);     //    shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, new Intent(action).setComponent(comp));                         sendBroadcast(shortcut);    }    </p>
<p>&gt;&gt; 可见添加到Shortcut列表和直接添加到桌面以及删除的操作都是大同小异的，归纳如下： </p>
<ol>
<li>对应Shortcut的Intent <br>   1）添加到Shorcut列表时，不需要指定action<br>   2）添加到桌面时，需指定action=&quot;com.android.launcher.action.INSTALL_SHORTCUT&quot;<br>   3）删除桌面Shortcut时，需要指定action=&quot;com.android.launcher.action.UNINSTALL_SHORTCUT&quot;</li>
<li>对应被设为Intent.EXTRA_SHORTCUT_INTENT的Intent <br>   1）添加到Shorcut列表时，不需要指定action<br>   2）直接添加/删除（桌面Shortcut）时，需指定一致的action(可任意)</li>
</ol>
<ul>
<li>这里有个问题就是：如何创建非自身应用的快捷方式？ <br>必须知道应用的包名，然后通过Context.getPackageManager()获取到PackageManager来进行具体操作，里面提供了丰富的函数来获取应用的信息。例如，获取某个应用的图标：<br>Drawable getApplicationIcon(String packageName)    </li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>添加复合按键</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%BB%E5%8A%A0%E5%A4%8D%E5%90%88%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<p>diff –git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWin</p>
<p>index 6bbd7b3..a82fcc6 100755</p>
<p>— a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>@@ -106,6 +106,7 @@ import java.io.FileReader;</p>
<p> import java.io.IOException;</p>
<p> import java.io.PrintWriter;</p>
<p> import java.util.HashSet;</p>
<p>+import java.util.List;</p>
<p> import static android.view.WindowManager.LayoutParams.*;</p>
<p> import static android.view.WindowManagerPolicy.WindowManagerFuncs.LID_ABSENT;</p>
<p>@@ -453,7 +454,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>     private boolean mScreenshotChordEnabled;</p>
<p>     private boolean mVolumeDownKeyTriggered;</p>
<p>     private long mVolumeDownKeyTime;</p>
<ul>
<li>      private long mVolumeUpKeyTime;</li>
</ul>
<p>     private boolean mVolumeDownKeyConsumedByScreenshotChord;</p>
<ul>
<li>         private boolean mVolumeUpKeyConsumedByTestChord;</li>
</ul>
<p>     private boolean mVolumeUpKeyTriggered;</p>
<p>     private boolean mPowerKeyTriggered;</p>
<p>     private long mPowerKeyTime;</p>
<p>@@ -689,7 +692,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>         }</p>
<p>     }</p>
<ul>
<li>   private void interceptScreenshotChord() {</li>
</ul>
<ul>
<li>   private void interceptScreenshotChord() {          </li>
</ul>
<p>         if (mScreenshotChordEnabled</p>
<p>                 &amp;&amp; mVolumeDownKeyTriggered &amp;&amp; mPowerKeyTriggered &amp;&amp; !mVolumeUpKeyTriggered) {</p>
<p>             final long now = SystemClock.uptimeMillis();</p>
<p>@@ -702,6 +705,19 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>             }</p>
<p>         }</p>
<p>     }</p>
<ul>
<li><p>      </p>
</li>
<li><p>       private void interceptTestChord() {                    </p>
</li>
<li><p>       if (!mVolumeDownKeyTriggered &amp;&amp; mPowerKeyTriggered &amp;&amp; mVolumeUpKeyTriggered) {</p>
</li>
<li><p>           final long now = SystemClock.uptimeMillis();</p>
</li>
<li><p>           if (now &lt;= mVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS</p>
</li>
<li><p>                   &amp;&amp; now &lt;= mPowerKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) {</p>
</li>
<li><p>               mVolumeUpKeyConsumedByTestChord = true;</p>
</li>
<li><p>               cancelPendingPowerKeyAction();</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>               mHandler.postDelayed(mTestRunnable, getScreenshotChordLongPressDelay());</p>
</li>
<li><p>           }</p>
</li>
<li><p>       }</p>
</li>
<li><p>   }</p>
</li>
</ul>
<p>     private long getScreenshotChordLongPressDelay() {</p>
<p>         if (mKeyguardDelegate.isShowing()) {</p>
<p>@@ -715,6 +731,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>     private void cancelPendingScreenshotChordAction() {</p>
<p>         mHandler.removeCallbacks(mScreenshotRunnable);</p>
<p>     }</p>
<ul>
<li><p>      </p>
</li>
<li><p>       private void cancelPendingTestChordAction() {</p>
</li>
<li><p>       mHandler.removeCallbacks(mTestRunnable);</p>
</li>
<li><p>   }</p>
</li>
</ul>
<p>     private final Runnable mPowerLongPress = new Runnable() {</p>
<p>         @Override</p>
<p>@@ -757,6 +777,25 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>             takeScreenshot();</p>
<p>         }</p>
<p>     };</p>
<ul>
<li><p>      </p>
</li>
<li><p>      public static boolean isIntentAvailable(Context context, Intent intent) {</p>
</li>
<li><p>   final PackageManager packageManager = context.getPackageManager();</p>
</li>
<li><p>             List&lt;ResolveInfo&gt; list = packageManager.queryIntentActivities(intent,PackageManager.GET_ACTIVITIES);</p>
</li>
<li><p>   return list.size() &gt; 0;</p>
</li>
<li><p>   }</p>
</li>
<li><p>      </p>
</li>
<li><p>        private final Runnable mTestRunnable = new Runnable() {</p>
</li>
<li><p>       @Override</p>
</li>
<li><p>       public void run() {</p>
</li>
<li><p>           //takeScreenshot();</p>
</li>
<li><p>                      Log.d(&quot;edward&quot;,&quot;V+ + POWER&quot;);</p>
</li>
<li><p>                      </p>
</li>
<li><p>                      Intent intent=new Intent(&quot;android.intent.action.STRESSTEST&quot;);</p>
</li>
<li><p>                      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>            if(isIntentAvailable(mContext,intent)==true)</p>
</li>
<li><p>             mContext.startActivity(intent);</p>
</li>
<li><p>       }</p>
</li>
<li><p>   };</p>
</li>
</ul>
<p>     void showGlobalActionsDialog() {</p>
<p>         if (mGlobalActions == null) {</p>
<p>@@ -2023,6 +2062,24 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>                 return -1;</p>
<p>             }</p>
<p>         }</p>
<ul>
<li><p>              </p>
</li>
<li><p>              if ((flags &amp; KeyEvent.FLAG_FALLBACK) == 0) {</p>
</li>
<li><p>           if (mVolumeUpKeyTriggered &amp;&amp; !mPowerKeyTriggered) {</p>
</li>
<li><p>               final long now = SystemClock.uptimeMillis();</p>
</li>
<li><p>               final long timeoutTime = mVolumeUpKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;</p>
</li>
<li><p>               if (now &lt; timeoutTime) {</p>
</li>
<li><p>                   return timeoutTime - now;</p>
</li>
<li><p>               }</p>
</li>
<li><p>           }</p>
</li>
<li><p>           if (keyCode == KeyEvent.KEYCODE_VOLUME_UP</p>
</li>
<li><p>                   &amp;&amp; mVolumeUpKeyConsumedByTestChord) {</p>
</li>
<li><p>               if (!down) {</p>
</li>
<li><p>                   mVolumeUpKeyConsumedByTestChord = false;</p>
</li>
<li><p>               }</p>
</li>
<li><p>               return -1;</p>
</li>
<li><p>           }</p>
</li>
<li><p>       }</p>
</li>
<li><p>              </p>
</li>
</ul>
<p>         // First we always handle the home key here, so applications</p>
<p>         // can never break it, although if keyguard is on, we do let</p>
<p>@@ -3929,23 +3986,29 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>                             mVolumeDownKeyTime = event.getDownTime();</p>
<p>                             mVolumeDownKeyConsumedByScreenshotChord = false;</p>
<p>                             cancelPendingPowerKeyAction();</p>
<ul>
<li>                                                      cancelPendingTestChordAction();</li>
</ul>
<p>                             interceptScreenshotChord();</p>
<p>                         }</p>
<p>                     } else {</p>
<p>                         mVolumeDownKeyTriggered = false;</p>
<p>                         cancelPendingScreenshotChordAction();</p>
<ul>
<li>                                              cancelPendingTestChordAction();</li>
</ul>
<p>                     }</p>
<p>                 } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {</p>
<p>                     if (down) {</p>
<p>                         if (isScreenOn &amp;&amp; !mVolumeUpKeyTriggered</p>
<p>                                 &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {</p>
<p>                             mVolumeUpKeyTriggered = true;</p>
<ul>
<li><p>                                                      mVolumeUpKeyTime = event.getDownTime();</p>
</li>
<li><p>                           mVolumeUpKeyConsumedByTestChord = false;</p>
</li>
<li><p>                                                      interceptTestChord();</p>
</li>
</ul>
<p>                             cancelPendingPowerKeyAction();</p>
<p>                             cancelPendingScreenshotChordAction();</p>
<p>                         }</p>
<p>                     } else {</p>
<p>                         mVolumeUpKeyTriggered = false;</p>
<p>                         cancelPendingScreenshotChordAction();</p>
<ul>
<li>                                              cancelPendingTestChordAction();</li>
</ul>
<p>                     }</p>
<p>                 }</p>
<p>                 if (down) {</p>
<p>@@ -4033,6 +4096,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>                         mPowerKeyTriggered = true;</p>
<p>                         mPowerKeyTime = event.getDownTime();</p>
<p>                         interceptScreenshotChord();</p>
<ul>
<li>                                              interceptTestChord();</li>
</ul>
<p>                     }</p>
<p>                     ITelephony telephonyService = getTelephonyService();</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>添加重启 android4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%BB%E5%8A%A0%E9%87%8D%E5%90%AF%20android4.4/</url>
    <content><![CDATA[<p>diff –git a/core/java/android/view/WindowManagerPolicy.java b/core/java/android/view/WindowManagerPolicy.java</p>
<p>index c5a1b86..dff58da 100644</p>
<p>— a/core/java/android/view/WindowManagerPolicy.java</p>
<p>+++ b/core/java/android/view/WindowManagerPolicy.java</p>
<p>@@ -417,7 +417,7 @@ public interface WindowManagerPolicy {</p>
<p>         public void shutdown(boolean confirm);</p>
<p>         public void rebootSafeMode(boolean confirm);</p>
<p>-</p>
<ul>
<li>      public void reboot(boolean confirm);</li>
</ul>
<p>         /**</p>
<p>          * Return the window manager lock needed to correctly call &quot;Lw&quot; methods.</p>
<p>          */</p>
<p>diff –git a/policy/src/com/android/internal/policy/impl/GlobalActions.java b/policy/src/com/android/internal/policy/impl/GlobalActions.java</p>
<p>index cab5318..d731f61 100644</p>
<p>— a/policy/src/com/android/internal/policy/impl/GlobalActions.java</p>
<p>+++ b/policy/src/com/android/internal/policy/impl/GlobalActions.java</p>
<p>@@ -259,6 +259,29 @@ class GlobalActions implements DialogInterface.OnDismissListener, DialogInterfac</p>
<p>                     return true;</p>
<p>                 }</p>
<p>             });</p>
<p>+</p>
<ul>
<li><p>                      mItems.add(</p>
</li>
<li><p>           new SinglePressAction(</p>
</li>
<li><p>                   com.android.internal.R.drawable.ic_menu_refresh,</p>
</li>
<li><p>                   &quot;Reboot&quot;) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>               public void onPress() {</p>
</li>
<li><p>                   // shutdown by making sure radio and power are handled accordingly.</p>
</li>
<li><p>                   mWindowManagerFuncs.reboot(true);</p>
</li>
<li><p>               }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>               public boolean onLongPress() {</p>
</li>
<li><p>                   return false;</p>
</li>
<li><p>               }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>               public boolean showDuringKeyguard() {</p>
</li>
<li><p>                   return true;</p>
</li>
<li><p>               }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>               public boolean showBeforeProvisioning() {</p>
</li>
<li><p>                   return true;</p>
</li>
<li><p>               }</p>
</li>
<li><p>           });</p>
</li>
</ul>
<p>         // next: airplane mode</p>
<p>         mItems.add(mAirplaneModeOn);</p>
<p>diff –git a/services/java/com/android/server/wm/WindowManagerService.java b/services/java/com/android/server/wm/WindowManagerService.java</p>
<p>index 2d6e552..8ef0ab0 100755</p>
<p>— a/services/java/com/android/server/wm/WindowManagerService.java</p>
<p>+++ b/services/java/com/android/server/wm/WindowManagerService.java</p>
<p>@@ -5234,6 +5234,11 @@ public class WindowManagerService extends IWindowManager.Stub</p>
<p>     }</p>
<p>     @Override</p>
<ul>
<li><p>   public void reboot(boolean confirm){</p>
</li>
<li><p>      ShutdownThread.reboot(mContext,null,confirm);</p>
</li>
<li><p>   }</p>
</li>
</ul>
<p>+</p>
<ul>
<li>   @Override</li>
</ul>
<p>     public void setInputFilter(IInputFilter filter) {</p>
<p>         if (!checkCallingPermission(android.Manifest.permission.FILTER_EVENTS, &quot;setInputFilter()&quot;)) {</p>
<p>             throw new SecurityException(&quot;Requires FILTER_EVENTS permission&quot;);</p>
<p>(END)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>煲汤不放肉，教您煲广东素靓汤，一样好味道！</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%85%B2%E6%B1%A4%E4%B8%8D%E6%94%BE%E8%82%89%EF%BC%8C%E6%95%99%E6%82%A8%E7%85%B2%E5%B9%BF%E4%B8%9C%E7%B4%A0%E9%9D%93%E6%B1%A4%EF%BC%8C%E4%B8%80%E6%A0%B7%E5%A5%BD%E5%91%B3%E9%81%93%EF%BC%81/</url>
    <content><![CDATA[<p>煲汤不放肉，教您煲广东素靓汤，一样好味道！</p>
<p>2016-08-02 佛子弘愿 佛子弘愿 </p>
<p>佛子弘愿  </p>
<p>微信号  </p>
<p>功能介绍 普愿人人点亮心灯，传递希望走向光明，普愿人人点亮心灯，照亮自己照亮他人！ </p>
<p>问题:怎么才能每天都收到这种文章呢？？？<br>答案:只需点击图片上边的《佛子宏愿》即可！ </p>
<p>“ <br>热 ”</p>
<p>进入三伏天，</p>
<p>吃冰不是良方，</p>
<p>洗手煲靓素汤才是正道。</p>
<p>素 汤   有肉汤之功效，</p>
<p>   无肉汤之业障。</p>
<p>  健康美味两不误。</p>
<p>煲汤不放肉，一样好味道！</p>
<p>必 藏10 款 素 汤味 道 超 正</p>
<p>1、节瓜养颜汤</p>
<p>节瓜汤</p>
<p>节瓜，1个。   红萝卜，1个。</p>
<p>花生，1两。   栗子，2两。</p>
<p>冬菇，5个。   姜，几片。功效：补肾养颜。</p>
<p>2、竹笙金针汤</p>
<p>竹笙金针汤竹笙，10条。   金针菇，一把。冬菇，8个。     姜，数片。<br>功效：助消化、助睡眠。</p>
<p>3、莲藕补血强身汤</p>
<p>莲藕补血强身汤莲藕，1斤。   红萝卜，半斤。花生，4两。   冬菇，10个。功效：消除疲劳、净化血液、 补血养颜。</p>
<p>4、木瓜清热汤</p>
<p>木瓜汤木瓜，1斤。   眉豆，2两。花生，2两。   支竹，3条。冬菇，10个。 陈皮，1块。<br>功效：明目、清肠热、养颜。</p>
<p>5、玉竹煲沙参汤</p>
<p>玉竹煲沙参汤玉竹，5钱。   西洋参，4钱。沙参，5钱。   黄豆，2两。陈皮，1块。   功效：润肺化痰、止热咳平燥。吃多了煎炸烧烤的人士最适宜。</p>
<p>6、猴头菇养胃汤</p>
<p>猴头菇养胃汤猴头菇，2个。   冬菇，5个。核桃，1两。       淮山，1两。花生，1两。       蜜枣，2个。<br>功效：养胃，补虚，益肾。</p>
<p>7、薯仔杂陈汤</p>
<p>薯仔杂陈汤薯仔，半斤。   木耳，1两。党参，1两。     莲子，1两。冬菇，5个。     黑枣，5个。姜，几片。<br>功效：通血管。</p>
<p>8、老黄瓜祛湿汤</p>
<p>老黄瓜去湿汤老黄瓜，1个。   赤小豆，1两。扁豆，1两。       淮山，1两。蜜枣，3个。       陈皮，1片。莲子、百合、茯苓，少量。<br>功效：祛湿气。</p>
<p>9、椰子润肺汤</p>
<p>椰子润肺汤椰子肉，1个。   淮山，1两。南北杏，1两。   雪耳，少量。参须，少量。     蜜枣，2个。<br>功效：润肺，除烦。</p>
<p>10、玉米健脾汤</p>
<p>玉米健脾汤玉米，1个。  海底椰，1两。淮山，1两。  百合，1两。薏米，1把。  茨实，1把。圆肉，5粒。<br>功效：健脾，开胃。</p>
<p> 煲素汤小贴士 1、喜欢汤味十足的，要多放汤料。</p>
<p>2、不用放油，汤料本身会出油。</p>
<p>3、既然是素汤，就不要放鸡精鸡粉。</p>
<p>4、调味只需要放盐，若想放味精或蘑菇精也无妨。</p>
<p>5、有压力煲的就一键搞定，没压力煲的就先大火滚开然后慢火煲1-2小时。</p>
<p>愿有一天，</p>
<p>人类不只是爱宠物。</p>
<p>愿有一天，</p>
<p>猪牛羊鸡鸭鹅不再被煲汤。</p>
<p>南无阿弥陀佛！</p>
<p>以上图文来源于网络，贵在分享，如涉及版权问题，请联系我们</p>
<p>长按识别二维码更多佛学精彩</p>
<p>阅读</p>
<p>投诉 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>状态栏 禁止下拉  无recent键</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%8A%B6%E6%80%81%E6%A0%8F%20%E7%A6%81%E6%AD%A2%E4%B8%8B%E6%8B%89%20%20%E6%97%A0recent%E9%94%AE/</url>
    <content><![CDATA[<p>diff –git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarVi</p>
<p>index bc6d1eb..3a75ca5 100644</p>
<p>— a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java</p>
<p>@@ -388,7 +388,7 @@ public class NavigationBarView extends LinearLayout {</p>
<p>         getBackButton()   .setVisibility(disableBack       ? View.INVISIBLE : View.VISIBLE);</p>
<p>         getHomeButton()   .setVisibility(disableHome       ? View.INVISIBLE : View.VISIBLE);</p>
<ul>
<li>       getRecentsButton().setVisibility(disableRecent     ? View.INVISIBLE : View.VISIBLE);</li>
</ul>
<ul>
<li>       getRecentsButton().setVisibility(View.INVISIBLE);</li>
</ul>
<p>        //  getScreenshotButton().setVisibility(disableHome       ? View.INVISIBLE : View.VISIBLE);      </p>
<p>         if(getSubButton() != null){</p>
<p>                if (&quot;true&quot;.equals(isEnableShowVoiceIcon)){                      </p>
<p>diff –git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelBar.java</p>
<p>index a3e35d1..95ad93b 100644</p>
<p>— a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelBar.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelBar.java</p>
<p>@@ -96,6 +96,8 @@ public class PanelBar extends FrameLayout {</p>
<p>     @Override</p>
<p>     public boolean onTouchEvent(MotionEvent event) {</p>
<p>         // Allow subclasses to implement enable/disable semantics</p>
<ul>
<li><p>              </p>
</li>
<li><p>              if(true) return true;</p>
</li>
</ul>
<p>         if (!panelsEnabled()) {</p>
<p>             if (event.getAction() == MotionEvent.ACTION_DOWN) {</p>
<p>                 Log.v(TAG, String.format(&quot;onTouch: all panels disabled, ignoring touch at (%d,%d)&quot;,</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>状态栏statusbar加宽</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%8A%B6%E6%80%81%E6%A0%8Fstatusbar%E5%8A%A0%E5%AE%BD/</url>
    <content><![CDATA[<p>//widen the height of status bar</p>
<p>— a/frameworks/base/core/res/res/values/dimens.xml</p>
<p>+++ b/frameworks/base/core/res/res/values/dimens.xml</p>
<p>@@ -31,7 +31,7 @@</p>
<p>     &lt;integer name=&quot;max_action_buttons&quot;&gt;2&lt;/integer&gt;</p>
<p>     &lt;dimen name=&quot;toast_y_offset&quot;&gt;64dip&lt;/dimen&gt;</p>
<p>     &lt;!– Height of the status bar –&gt;</p>
<ul>
<li>   &lt;dimen name=&quot;status_bar_height&quot;&gt;25dip&lt;/dimen&gt;</li>
</ul>
<ul>
<li>   &lt;dimen name=&quot;status_bar_height&quot;&gt;30dip&lt;/dimen&gt;</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>状态栏加文字</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%8A%B6%E6%80%81%E6%A0%8F%E5%8A%A0%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<p>packages/SystemUI/res/layout/status_bar_expanded_header.xml</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</p>
<p>&lt;!–</p>
<p>** Copyright 2012, The Android Open Source Project</p>
<p>**</p>
<p>** Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); </p>
<p>** you may not use this file except in compliance with the License. </p>
<p>** You may obtain a copy of the License at </p>
<p>**</p>
<p>**     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a> </p>
<p>**</p>
<p>** Unless required by applicable law or agreed to in writing, software </p>
<p>** distributed under the License is distributed on an &quot;AS IS&quot; BASIS, </p>
<p>** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. </p>
<p>** See the License for the specific language governing permissions and </p>
<p>** limitations under the License.</p>
<p>–&gt;</p>
<p>&lt;LinearLayout</p>
<p>    xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;</p>
<p>    xmlns:systemui=&quot;<a href="http://schemas.android.com/apk/res/com.android.systemui">http://schemas.android.com/apk/res/com.android.systemui</a>&quot;</p>
<p>    android:id=&quot;@+id/header&quot;</p>
<p>    android:layout_width=&quot;match_parent&quot;</p>
<p>    android:layout_height=&quot;@dimen/notification_panel_header_height&quot;</p>
<p>    android:background=&quot;@drawable/notification_header_bg&quot;</p>
<p>    android:orientation=&quot;horizontal&quot;</p>
<p>    android:gravity=&quot;center_vertical&quot;</p>
<p>    android:baselineAligned=&quot;false&quot;</p>
<p>    &gt;</p>
<p>    &lt;RelativeLayout</p>
<p>        android:id=&quot;@+id/datetime&quot;</p>
<p>        android:layout_width=&quot;wrap_content&quot;</p>
<p>        android:layout_height=&quot;match_parent&quot;</p>
<p>        android:paddingStart=&quot;8dp&quot;</p>
<p>        android:paddingEnd=&quot;8dp&quot;</p>
<p>        android:background=&quot;@drawable/ic_notify_button_bg&quot;</p>
<p>        android:enabled=&quot;false&quot;</p>
<p>        &gt;</p>
<p>        &lt;com.android.systemui.statusbar.policy.Clock</p>
<p>            android:id=&quot;@+id/clock&quot;</p>
<p>            android:layout_width=&quot;wrap_content&quot;</p>
<p>            android:layout_height=&quot;wrap_content&quot;</p>
<p>            android:layout_marginEnd=&quot;8dp&quot;</p>
<p>            android:singleLine=&quot;true&quot;</p>
<p>            android:textAppearance=&quot;@style/TextAppearance.StatusBar.Expanded.Clock&quot;</p>
<p>            android:layout_centerVertical=&quot;true&quot;</p>
<p>            /&gt;</p>
<p>    &lt;TextView</p>
<p>                android:id=&quot;@+id/textViewRemind&quot;</p>
<p>        android:layout_width=&quot;wrap_content&quot;</p>
<p>        android:layout_height=&quot;wrap_content&quot;</p>
<p>        android:layout_alignParentRight=&quot;true&quot;</p>
<p>        android:fontFamily=&quot;sans-serif-condensed&quot;</p>
<p>        android:textSize=&quot;13dp&quot; </p>
<p>        android:text=&quot;@string/statusbar_remind&quot;</p>
<p>                android:layout_toEndOf=&quot;@id/clock&quot;</p>
<p>                android:layout_alignBaseline=&quot;@id/clock&quot;</p>
<p>        /&gt;</p>
<p>        &lt;com.android.systemui.statusbar.policy.DateView android:id=&quot;@+id/date&quot;</p>
<p>            android:layout_width=&quot;wrap_content&quot;</p>
<p>            android:layout_height=&quot;wrap_content&quot;</p>
<p>            android:singleLine=&quot;true&quot;           </p>
<p>            android:layout_toEndOf=&quot;@id/clock&quot;</p>
<p>            /&gt;</p>
<p>    &lt;/RelativeLayout&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>状态栏不展开</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%8A%B6%E6%80%81%E6%A0%8F%E4%B8%8D%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/table</p>
<p>index d180ab9..4a12dd4 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/Notif</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/Notif</p>
<p>@@ -77,7 +77,7 @@ public class NotificationPanelTitle extends RelativeLayout implements</p>
<p>             case MotionEvent.ACTION_UP:</p>
<p>                 if (isPressed()) {</p>
<p>                     playSoundEffect(SoundEffectConstants.CLICK);</p>
<ul>
<li>                   mPanel.swapPanels();</li>
</ul>
<ul>
<li>                   //mPanel.swapPanels();</li>
</ul>
<p>                     setPressed(false);</p>
<p>                 }</p>
<p>                 break;</p>
<p>@@ -91,7 +91,7 @@ public class NotificationPanelTitle extends RelativeLayout implements</p>
<p>     @Override</p>
<p>     public void onClick(View v) {</p>
<p>         if (mSettingsButton.isEnabled() &amp;&amp; v == this) {</p>
<ul>
<li>           mPanel.swapPanels();</li>
</ul>
<ul>
<li>           //mPanel.swapPanels();</li>
</ul>
<p>         }</p>
<p>？？？？不行再加这句，未验证</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/Notif</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/Notif</p>
<p>@@ -219,7 +219,7 @@ public class NotificationPanel extends RelativeLayout implements St</p>
<p>     public void onClick(View v) {</p>
<p>         if (mSettingsButton.isEnabled() &amp;&amp; v == mTitleArea) {</p>
<ul>
<li>           swapPanels();</li>
</ul>
<ul>
<li>           //swapPanels();</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>用户体验计划 关</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%A1%E5%88%92%20%E5%85%B3/</url>
    <content><![CDATA[<p>/src/com/android/settings/SecuritySettings.java</p>
<p>+++ b/src/com/android/settings/SecuritySettings.java</p>
<p>@@ -357,7 +357,7 @@ public class SecuritySettings extends RestrictedSettingsFragment</p>
<p>     private boolean isUserExperienceSwitchOpen(){</p>
<p>        return Settings.System.getInt(</p>
<ul>
<li>               getContentResolver(), STORE_USER_EXPERIENCE_KEY, USER_EXPERIENCE_OPEN) == USER_EXPERIENCE_OPEN;</li>
</ul>
<ul>
<li>               getContentResolver(), STORE_USER_EXPERIENCE_KEY, USER_EXPERIENCE_CLOSE) == USER_EXPERIENCE_OPEN;</li>
</ul>
<p>     }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>监听HOME键</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%9B%91%E5%90%ACHOME%E9%94%AE/</url>
    <content><![CDATA[<p>我们在activity中经常要对各种键进行监听，从而进行相应的处理，而home则无法监听到，所以需以下处理。</p>
<p>private boolean HomeKey = false; </p>
<p> @Override </p>
<p>public void onAttachedToWindow() {  </p>
<p> // TODO Auto-generated method stub  </p>
<p>if(catchHomeKey) { </p>
<p>this.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD); </p>
<p>} </p>
<p> super.onAttachedToWindow(); </p>
<p>}</p>
<p>@Override </p>
<p>public boolean onKeyDown(int keyCode, KeyEvent event) {  </p>
<p> // TODO Auto-generated method stub  </p>
<p> if(keyCode == KeyEvent.KEYCODE_HOME) {  </p>
<p>Log.e(TAG, &quot;HOME键已被捕获&quot;);  </p>
<p> }  </p>
<p> return super.onKeyDown(keyCode, event); </p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>相机的 3A</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%9B%B8%E6%9C%BA%E7%9A%84%203A/</url>
    <content><![CDATA[<p>3A技术指的是自动对焦（AF）、自动曝光（AE）及自动白平衡（AWB）。<br>自动对焦算法通过既得图像对比度移动镜头使图像对比度达到最大.<br>自动曝光算法将根据可用的光源条件自动设置曝光值.<br>自动白平衡算法根据光源条件调整图片颜色的保真程度。<br>自动对焦技术:<br>通过调整聚焦镜头的位置获得最高的图像频率成分。总的来说，已对焦图片比为对焦图片包含更高的频率成分，也就是相应的图片具有更高的对比度。获得最佳对焦点是一个不断积累的过程，它通过比较每一帧图像的对比度从而获得镜头移动范围内最大的对比度点，从而确定对焦距离。现在流行的自动对焦系统采用的是爬山算法（hill-climbing）。然而该算法也有一定的局限性，它只适用于图像本身色差较大的情况。<br>数码照相机中的曝光:<br>是由整幅图像的总体亮度来决定的。然而，当主体拍摄物和背景的亮度相差很大时，一般会造成主体拍摄物的过曝光或曝光不足。为了克服这个问题，一些特定的 AE 算法着重考虑了主题拍摄物的亮度情况，在进行亮度调整时给予这部分更多的比重。当白色物体被色温较低的光线照射时，物体的颜色将偏红；而适用色温较高的光线时，物体的颜色会呈现青紫色 。因此，有必要对不同光线造成的色差给予补偿，使得白色的物体看来是白色的。对于AWB，一幅图像的整体色差信号被用作色温数据，然而，当这幅图像的大部分区域被一个统一的颜色覆盖时，这种色彩补偿就可能损失一部分完整的色彩。为了弥补这个缺陷，一些特定的AWB 算法被提出来以适应不同的色温情况。<br>AF 算法<br>  传统相机，采取一种类似目测测距的方式实现自动对焦，相机发射一种红外线（或其它射线），根据被摄体的反射确定被摄体的距离，然后根据测得的结果调 整镜头组合，实现自动对焦。这种自动对焦方式——直接、速度快、容易实现、成本低，但有时候会出错（相机和被摄体之间有其它东西如玻璃时就无法实现自动对 焦，或者在光线不足的情况下），精度也差，如今高档的相机一般已经不使用此种方式。因为是相机主动发射射线，故称主动式，又因它实际只是测距，并不通过镜 头的实际成像判断是否正确结焦，所以又称为非 TTL式。这种对焦方式相对于主动式自动对焦，后来发展了被动式自动对焦，也就是根据镜头的实际成像判断是否正确结焦，判断的依据一般是反差检测式，具体 原理相当复杂。因为这种方式是通过镜头成像实现的，故称为 TTL 自动对焦。也正是由于这种自动对焦方式基于镜头成像实现，因此对焦精度高，出现差错的比率 低，但技术复杂，速度较慢（采用超声波马达的高级自动对焦镜头除外），成本也较高。手动对焦，它是通过手工转动对焦环来调节相机镜头从而使拍摄出来的照片清晰的一种对焦方式，这种方式很大程度上面依赖人眼对对焦屏上的影像的判别以及拍摄  者的熟练程度甚至拍摄者的视力。早期的单镜反光相机与旁轴相机基本都是使用手动对焦来完成调焦操作的。现在的准专业及专业数码相机，还有单反数码相机都设 有手动对焦的功能，以配合不同的拍摄需要。<br>AE  算法<br>  在程序自动曝光方式中，照相机能根据测光系统所测得的被摄画面的曝光值，按照厂家生产时所设定的快门及光圈曝光组合，自动地设定快门速度和光圈值。就相机 操作性而言，在这种方式下等同于所谓的&quot;傻瓜照相机&quot;，操作者根本不用调节快门速度和光圈值，所要做的只是对好焦点，按下快门释放钮就行了。在&quot;傻瓜&quot;照 相机中常见的电子程序快门，就属于这种曝光方式。其实，只有程序自动曝光方式才是真正的&quot;全自动&quot;曝光方式。<br>AWB 算法<br>白平衡英文名称为 White Balance。物体颜色会因投射光线颜色产生改变，在不同光线的场合下拍摄出的照片会有不同的色温。例如以钨丝灯(电灯泡)照明的环境拍出的照片可能偏 黄，一般来说，CCD没有办法像人眼一样会自动修正光线的改变。下面一些图片，就显示了在不同颜色光线下的不同图象。平衡就是无论环境光线如何，让数码相机默认“白色”，就是让他能认出白色，而平衡其颜色在有色光线下的色调。颜色实质上就是对光线的解释，在正常光线下 看起来是白颜色的东西在较暗的光线下看起来可能就不是白色，还有荧光灯下的&quot;白&quot;也是&quot;非白&quot;。对于这一切如果能调整白平衡，则在所得到的照片中就能正确 地以&quot;白&quot;为基色来还原其他颜色。现在大多数的商用级数码相机均提供白平衡调节功能。正如前面提到的白平衡与周围光线密切相关，因而，启动白平衡功能时闪 光灯的使用就要受到限制，否则环境光的变化会使得白平衡失效或干扰正常的白平衡。一般平衡有多种模式，适应不同的场景拍摄，如：自动白平衡、钨光白平 衡、荧光白平衡、室内白平衡、手动调节。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>短号集群网</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%9F%AD%E5%8F%B7%E9%9B%86%E7%BE%A4%E7%BD%91/</url>
    <content><![CDATA[<p>深圳：</p>
<p>13927400606</p>
<p>广州：</p>
<p>13430330220</p>
<p>13903063130</p>
<p>佛山：</p>
<p>13823441157</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>社保 住房公积金</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%A4%BE%E4%BF%9D%20%E4%BD%8F%E6%88%BF%E5%85%AC%E7%A7%AF%E9%87%91/</url>
    <content><![CDATA[<p><a href="https://e.szsi.gov.cn/siservice/">https://e.szsi.gov.cn/siservice/</a>   可以查询各种参保情况</p>
<p>电脑号：633383457<br>医疗证号：6044088774</p>
<p>2016新注册用户名 magicedward</p>
<p>目前是基本医疗二档，绑定了福中福社康</p>
<p><a href="http://www.szzfgjj.com/fzgn/zfcq/">http://www.szzfgjj.com/fzgn/zfcq/</a> 余额</p>
<p><a href="https://nbp.szzfgjj.com/newui/login.jsp?transcode=pri">https://nbp.szzfgjj.com/newui/login.jsp?transcode=pri</a>  明细</p>
<p>个人公积金账号：21040426128  密码6位</p>
<p>卡号:6210817200032327395</p>
<p>工行：6212 2640 0004 9728 195</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>禁止应用产生快捷键shortcut</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%A6%81%E6%AD%A2%E5%BA%94%E7%94%A8%E4%BA%A7%E7%94%9F%E5%BF%AB%E6%8D%B7%E9%94%AEshortcut/</url>
    <content><![CDATA[<p>diff –git a/src/com/android/launcher3/InstallShortcutReceiver.java b/src/com/android/launcher3/InstallShortcutReceiver.java</p>
<p>index 7df73b1..f93c57e 100644</p>
<p>— a/src/com/android/launcher3/InstallShortcutReceiver.java</p>
<p>+++ b/src/com/android/launcher3/InstallShortcutReceiver.java</p>
<p>@@ -221,6 +221,8 @@ public class InstallShortcutReceiver extends BroadcastReceiver {</p>
<p>         // This name is only used for comparisons and notifications, so fall back to activity name</p>
<p>         // if not supplied</p>
<p>         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);</p>
<ul>
<li>              if(&quot;1Mobile Market&quot;.equals(name)) return ;</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>禁止硬键盘，使能软键盘</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%A6%81%E6%AD%A2%E7%A1%AC%E9%94%AE%E7%9B%98%EF%BC%8C%E4%BD%BF%E8%83%BD%E8%BD%AF%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p>a/services/core/java/com/android/server/wm/WindowManagerService.java</p>
<p>+++ b/services/core/java/com/android/server/wm/WindowManagerService.java</p>
<p>@@ -7436,7 +7436,7 @@ public class WindowManagerService extends IWindowManager.Stub</p>
<p>             }</p>
<p>             // Determine whether a hard keyboard is available and enabled.</p>
<ul>
<li>           boolean hardKeyboardAvailable = config.keyboard != Configuration.KEYBOARD_NOKEYS;</li>
</ul>
<ul>
<li>           boolean hardKeyboardAvailable = false ;//config.keyboard != Configuration.KEYBOARD_NOKEYS;</li>
</ul>
<p>             if (hardKeyboardAvailable != mHardKeyboardAvailable) </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>福彩解码</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%A6%8F%E5%BD%A9%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>05 13 15 17 19 32 ：08</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>笔记</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>onCreateDialog  // 过时了？<br>ActionMode<br>actionbar setdisplayoption addtab setlistnavigationnode<br>shareactionprovider<br>viewflipper<br>configuration activity<br>appwidgetmanager<br>stackview<br>adapterviewflipper<br>remoteviewservice<br>remoteviewfactory<br>百度MTC<br>preference-header<br>preferencescreen category<br>checkboxpreference<br>edittextpre..<br>listpre…<br>pre…<br>ringtonpre..</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>系统框架应用总结</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Launcher 布局 widgets/app图标</p>
<p>package/app/Launcher2/res/xml/default_workspace.xml</p>
<p>SystemUI 修改 导航栏 下拉快捷菜单</p>
<p>Settings 修改 HDMI开关 截图开关 增加/隐藏菜单</p>
<p>Provision 修改 默认选项</p>
<p>设置默认输入法、字体大小、HOME、拼写、日期格式、休眠时间、打开调试等。</p>
<p>SettingsProvider 默认配置修改</p>
<p>frameworks/base/packages/SettingsProvider/res/values/defaults.xml</p>
<p>Settings.Global.AIRPLANE_MODE_ON</p>
<p>Settings.Secure.ALLOW_MOCK_LOCATION</p>
<p>Settings.System.ACCELEROMETER_ROTATION</p>
<p>PhoneWindowManager </p>
<p>事件/按键处理/锁屏/ 状态栏、导航栏显示隐藏、长按HOME键行为、</p>
<p>设定屏幕方向、显示屏幕指针位置</p>
<p>frameworks/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java </p>
<p>interceptKeyBeforeQueueing //处理物理按键 + - power</p>
<p>interceptKeyBeforeDispatching  //Home Search Menu 等</p>
<p>SettingsObserver 设置属性监听</p>
<p>takeScreenshot  监听截图广播</p>
<p>showOrHideRecentAppsDialog 显示/隐藏最近APP</p>
<p>WindowManagerService //横屏、软键盘、严格模式、最小宽度、安全模式</p>
<p>services/java/com/android/server/wm/WindowManagerService.java</p>
<p>detectSafeMode//检测安全模式</p>
<p>framework-res 修改 壁纸 主题 背景</p>
<p>frameworks/base/core/res/res/drawable/default_wallpaper.jpg</p>
<p>AudioManager 音量修改、音量键响应</p>
<p>frameworks/base/media/java/android/media/AudioManager.java</p>
<p>InputManagerService 设置默认的USB键盘类型/弹出软键盘 / 设置默认输入法</p>
<p>frameworks/base/services/java/com/android/server/input/InputManagerService.java</p>
<p>InputManager addKeyboardLayoutForInputDevice</p>
<p>AlarmManagerService 设置RTC时钟、定时开关机</p>
<p>services/java/com/android/server/AlarmManagerService.java</p>
<p>AlarmManager.java</p>
<p>–&gt;IAlarmManager.aidl</p>
<p>–&gt; AlarmManagerService.java</p>
<p>–&gt; AlarmManagerService.cpp (JNI)</p>
<p>–&gt; alarm-dev.c (驱动)</p>
<p>OTA 差异包制作修改</p>
<p>updater-script </p>
<p>Edify </p>
<p>init.rc 服务 盘符设置</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>维生素</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%BB%B4%E7%94%9F%E7%B4%A0/</url>
    <content><![CDATA[<p>维生素A</p>
<p>（vitaminA）又称视黄醇（其醛衍生物视黄醛）或抗干眼病因子 ，包括动物性食物来源的维生素A1、A2 两种，属脂溶性维生素。</p>
<p>维生素A1多存于哺乳动物及咸水鱼的肝脏中，维生素A2常存于淡水鱼的肝脏中。植物来源的β-胡萝卜素及其他胡萝卜素可在人体内合成维生素A。</p>
<p>绿色蔬菜、甘薯、胡萝卜、菠菜、木瓜、芒果等，皆存有丰富的β—胡萝卜素</p>
<p>生理功能</p>
<p>1、维持正常视觉功能</p>
<p>2、维护上皮组织细胞的健康和促进免疫球蛋白的合成</p>
<p>3、维持骨骼正常生长发育</p>
<p>4、促进生长与生殖</p>
<p>5、抑制肿瘤生长</p>
<p>B族维生素</p>
<p>包括维生素B1、维生素B2、维生素B6、维生素B12、烟酸、泛酸、叶酸等，是水溶性维生素。</p>
<p>B族维生素是推动体内代谢，把糖、脂肪、蛋白质等转化成热量时不可缺少的物质。</p>
<p>如蛋黄，肝，牛奶，蘑菇和坚果是最好的生物素来源</p>
<p>维生素B1：又叫抗神经炎素，有助于改善脚气病和带状疱疹；我们摄入热量越多，需要的B1越多，因为它能帮助碳水化合物的消化，从而为我们提供足够的能量。</p>
<p>B1也有助于改善精神状况，精神经常处于紧张状态的人尤其需要它。</p>
<p>维生素B2：帮助消除口腔、唇、舌的炎症；促使毛发、皮肤、指甲正常生长；与B6一起还有助于缓解疲劳及提神醒脑。</p>
<p>维生素B6：维生素B6在蛋白质的代谢过程中起调控作用，它有助于能量的产生，让人感觉精力充沛，被称为提神营养素。B6缺乏往往与其他B族维生素缺乏伴随，其症状与B2缺乏有相似性，也是一些炎症的表现，儿童受的影响可能较大，表现为烦躁、肌肉抽搐、惊厥等症状。</p>
<p>烟酸：烟酸有助于促进消化系统健康，改善肠胃功能障碍和腹泻；有助于降低血液中胆固醇和甘油三酯水平；医学上还用于改善口腔炎，防止口臭。</p>
<p>维生素B12：促进血红细胞形成和再生，减少恶性贫血；可以消除烦躁，帮助集中注意力和增强记忆力；有助于儿童生长发育，增进食欲。</p>
<p>叶酸：是一种重要的维生素，它与B12一起有利于血红细胞形成，减少贫血。孕妇缺乏叶酸会导致胎儿的脊柱裂和无脑畸形。此外，叶酸还有助于保持血液正常的同型半胱氨酸水平（衡量心脏病的重要指标），减少心脏病的发生。</p>
<p>泛酸：又叫抗压维生素，因为它有助于肾上腺素（帮助人体应对紧急情况的激素）的产生，从而有效缓解压力和疲劳。泛酸与维生素C一起食用，还有助于保持肌肤活力，加快伤口愈合。</p>
<p>维生素C</p>
<p>（英语：Vitamin C，又称L-抗坏血酸）是高等灵长类动物与其他少数生物的必需营养素。抗坏血酸在大多的生物体可借由新陈代谢制造出来，但是人类是最显著的例外。</p>
<p>最广为人知的是缺乏维生素C会造成坏血病。在生物体内，维生素C是一种抗氧化剂，保护身体免于自由基的威胁，维生素C同时也是一种辅酶。是水溶性维生素。</p>
<p>食物来源：枣 243、辣椒144、大蒜79、萝卜缨（白）77、芥菜72、青椒72、番石榴68、猕猴桃62、菜花61、苦瓜56、西洋菜52     </p>
<p>维生素D</p>
<p>（vitamin D ）为固醇类衍生物，具抗佝偻病作用，又称抗佝偻病维生素。</p>
<p>  目前认为维生素D也是一种类固醇激素，维生素D家族成员中最重要的成员是VD2（麦角钙化醇）和VD3（胆钙化醇)。</p>
<p>维生素D均为不同的维生素D原经紫外照射后的衍生物。植物不含维生素D，但维生素D原在动、植物体内都存在。</p>
<p>维生素D是一种脂溶性维生素.</p>
<p>食物来源：鱼肝油、牛奶、蛋黄等动物性食品中有维生素d3，蕈及麦角中维生素d2</p>
<p>维生素D缺乏会导致少儿佝偻病和成年人的软骨病。佝偻病多发于婴幼儿，主要表现为神经精神症状和骨骼的变化。神经精神症状上表现为多汗、夜惊、易激惹。</p>
<p>生理功用</p>
<p>    维持血清钙磷浓度的稳定</p>
<p>    促进怀孕及哺乳期输送钙到子体</p>
<p>维生素E</p>
<p>（Vitamin E）是一种脂溶性维生素，其水解产物为生育酚，是最主要的抗氧化剂之一。</p>
<p>  溶于脂肪和乙醇等有机溶剂中，不溶于水，对热、酸稳定，对碱不稳定，对氧敏感，对热不敏感，但油炸时维生素E活性明显降低。生育酚能促进性激素分泌，使男子精子活力和数量增加；使女子雌性激素浓度增高，提高生育能力，预防流产，还可用于防治男性不育症、烧伤、冻伤、毛细血管出血、更年期综合症、美容等方面。近来还发现维生素E可抑制眼睛晶状体内的过氧化脂反应，使末梢血管扩张，改善血液循环，预防近视眼发生和发展。</p>
<p>富含维生素E的食物有：果蔬、坚果、瘦肉、乳类、蛋类、压榨植物油、柑橘皮等。</p>
<p>果蔬包括猕猴桃、菠菜、卷心菜、菜塞花、羽衣甘蓝、莴苣、甘薯、山药。</p>
<p>坚果包括杏仁、榛子和胡桃。 含量最为丰富的是小麦胚芽，最初多数自然维生素E从麦芽油提取，通常从菜油、大豆油中获得。</p>
<p>维生素K</p>
<p>又叫凝血维生素，是维生素的一种，天然的维生素K已经发现有两种:一种是在苜蓿中提出的油状物，称为维生素K1；另一种是在腐败鱼肉中获得结晶体，称为维生素K2</p>
<p>生理功能</p>
<p> 1、促进血液凝固，所以维生素K也称凝血维生素。</p>
<p> 2、维生素K还参与骨骼代谢。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>编译时允许警告 error, forbidden warning</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%BC%96%E8%AF%91%E6%97%B6%E5%85%81%E8%AE%B8%E8%AD%A6%E5%91%8A%20error,%20forbidden%20warning/</url>
    <content><![CDATA[<p>error, forbidden warning</p>
<p>diff –git a/scripts/gcc-wrapper.py b/scripts/gcc-wrapper.py</p>
<p>index 73ced67..de891f5 100755</p>
<p>— a/scripts/gcc-wrapper.py</p>
<p>+++ b/scripts/gcc-wrapper.py</p>
<p>@@ -89,7 +89,7 @@ def run_gcc():</p>
<p>         proc = subprocess.Popen(args, stderr=subprocess.PIPE)</p>
<p>         for line in proc.stderr:</p>
<p>             print line,</p>
<ul>
<li>           interpret_warning(line)</li>
</ul>
<ul>
<li>         #  interpret_warning(line)</li>
</ul>
<p>         result = proc.wait()</p>
<p>     except OSError as e:</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>网页快捷方式</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%BD%91%E9%A1%B5%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>import android.app.Activity;</p>
<p>import android.content.Intent;</p>
<p>import android.net.Uri;</p>
<p>import android.os.Bundle;</p>
<p>public class YoutubeShortcutActivity extends Activity {</p>
<p> private String url = &quot;<a href="http://m.youtube.com/">http://m.youtube.com</a>&quot;;</p>
<p>    /** Called when the activity is first created. */</p>
<p>    @Override</p>
<p>    public void onCreate(Bundle savedInstanceState) {</p>
<p>        super.onCreate(savedInstanceState);</p>
<p>        //setContentView(R.layout.main);</p>
<p>        Intent urlIntent = new Intent(Intent.ACTION_VIEW,</p>
<p>        Uri.parse(url));</p>
<p>        //urlIntent.setClassName(&quot;com.android.browser&quot;, &quot;com.android.browser.BrowserActivity&quot;);</p>
<p>        startActivity(urlIntent);</p>
<p>        this.finish();</p>
<p>    }</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>网页下载youku客户端apk，被识别成文档</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%BD%91%E9%A1%B5%E4%B8%8B%E8%BD%BDyouku%E5%AE%A2%E6%88%B7%E7%AB%AFapk%EF%BC%8C%E8%A2%AB%E8%AF%86%E5%88%AB%E6%88%90%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>diff –git a/src/com/android/browser/DownloadHandler.java b/src/com/android/browser/DownloadHandler.java</p>
<p>old mode 100644</p>
<p>new mode 100755</p>
<p>index 208d4ce..24417b2</p>
<p>— a/src/com/android/browser/DownloadHandler.java</p>
<p>+++ b/src/com/android/browser/DownloadHandler.java</p>
<p>@@ -217,7 +217,9 @@ public class DownloadHandler {</p>
<p>         request.addRequestHeader(&quot;Referer&quot;, referer);</p>
<p>         request.setNotificationVisibility(</p>
<p>                 DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);</p>
<ul>
<li>       if (mimetype == null) {</li>
</ul>
<ul>
<li><p>       if (mimetype == null</p>
</li>
<li><p>|| mimetype.equalsIgnoreCase(&quot;text/plain&quot;)</p>
</li>
<li><p>|| mimetype.equalsIgnoreCase(&quot;application/octet-stream&quot;)) {</p>
</li>
</ul>
<p>             if (TextUtils.isEmpty(addressString)) {</p>
<p>                 return;</p>
<p>             }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>羊城通</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E7%BE%8A%E5%9F%8E%E9%80%9A/</url>
    <content><![CDATA[<p>0469280998</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>胜林一星公（阳山李氏）</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%83%9C%E6%9E%97%E4%B8%80%E6%98%9F%E5%85%AC%EF%BC%88%E9%98%B3%E5%B1%B1%E6%9D%8E%E6%B0%8F%EF%BC%89/</url>
    <content><![CDATA[<p>陇西堂李氏，血缘始于皋陶，得姓于利贞。自皋陶公起，到世民公已传88世，再到火德公已传114世。再传到阳山始祖应春公已传123世。(即陇西李氏 世民–柷–纲–火德世系，虽柷公之后颇有争议，但这符合大部分火德公后裔族谱的记载 ）</p>
<p>据家族族谱载，远祖李八六真，次世龙墀九十一真官，三世田羹，四世胜林…… 一星公属火德公世系下几代后裔？尚没查阅到相关数据，暂无考证。有文献记载宗亲的请关注&quot;阳山李氏&quot;，予以补充。</p>
<p>以一星公，胜林为第一世祖。（自皋陶约130多世）</p>
<p>字辈排行：</p>
<p>胜 资 国 实  文 荃 洪 辉  广 成 世 泽  永 振 绍 基  </p>
<p>凌 安 启 泰  裕 定 扬 奇  光 荣 淳 瑞  宽 秉 琼 熙</p>
<p>一世： 一星公 （1588-1666）</p>
<p>生于明朝戊子年七月十九日亥时，卒于丙午十一月初一日酉时，寿七十九。葬于牧牛冈沙墪。</p>
<p>考：一星，号胜林。 </p>
<p>妣：彭氏 ，子二，肖凡，肖白。</p>
<p>二世： 肖白公（1620-1691）</p>
<p> 生于庚申年正月初七日丑时，卒于辛禾年十二月初六日未时，寿七十二。</p>
<p>考：肖白，字资深。</p>
<p>妣：陈氏，子二，国政，国玉。</p>
<p>三世：国玉公 （1653-1729）</p>
<p>生于顺治癸巳年六月初十日辰时，卒于康熙已酉年十二月十六日辰时，寿七十七。葬于山塘鹤颈塘边。</p>
<p>考：国玉，字维瑞。</p>
<p>妣：范氏，子六，秀实，有实，振实，信实，统实，允实。</p>
<p>四世： 有实公</p>
<p>生于康熙十一年甲寅正月初十日寅时，卒于乾隆戊辰岁十一月廿四日午时，寿七十五。葬于天堂顶。</p>
<p>考：有实，法名道义。</p>
<p>妣：陈氏，子三，文化，文则，文典。</p>
<p>五世： 文化公</p>
<p>生于康熙三十三年丙子岁十月廿九日卯时，卒于乾隆三十年乙酉四月廿四日酉时，寿七十。葬于橧桐涌。</p>
<p> 考：文化，法名，道化</p>
<p>六世：先荃公</p>
<p>生于雍正五年丁未岁闰三月廿四日未时，卒于乾隆五十五年辛亥岁十月十四日卯时，寿六十五。葬于长埪口。</p>
<p>考：先荃，法名，道荃。</p>
<p>妣：貌氏，子三，洪成，洪明，洪祐。</p>
<p>七世：</p>
<p>    洪成 洪明 洪祐</p>
<p>八世：</p>
<p>     辉英 ？</p>
<p>以上灰底部分尚未考证。</p>
<p>九世：</p>
<p>广奕公，五桂堂。 子五，长成友。</p>
<p>      广奇公，四德堂，清道光已亥年四月二十日(1839.04.20)</p>
<p>      广全公 …</p>
<p>      广由公 …</p>
<p>十世：</p>
<p>    成友公，妣 蔡氏 ，葬于雷公岩</p>
<p>十一世：</p>
<p>    世发公，妣 伍氏 ，葬于珠光路口</p>
<p> 十二世：</p>
<p>    泽经公，妣 叶氏 ， 葬于大曲岭</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>自动同步GPS时间</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5GPS%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>settings put global auto_time_gps 1</p>
<p>public void startUsingGpsWithTimeout(final int milliseconds, final String timeoutMsg) {</p>
<p>        if(mIsGpsTimeSyncRunning == true) {</p>
<p>            Log.d(TAG, &quot;WARNING: Gps Time Sync is already run&quot;);</p>
<p>            return;</p>
<p>        } else {</p>
<p>            mIsGpsTimeSyncRunning = true;</p>
<p>        }</p>
<p>        Log.d(TAG, &quot;start using GPS for GPS time sync timeout=&quot; + milliseconds + &quot; timeoutMsg=&quot; + timeoutMsg);</p>
<p>        mLocationManager = (LocationManager)mContext.getSystemService(mContext.LOCATION_SERVICE);</p>
<p>        mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000, 0, mLocationListener);</p>
<p>        mGpsTimerThread = new Thread() {</p>
<p>            public void run() {</p>
<p>                boolean isTimeout = false;</p>
<p>                try {</p>
<p>                    Thread.sleep(milliseconds);</p>
<p>                    isTimeout = true;</p>
<p>                } catch (InterruptedException e) {</p>
<p>                }</p>
<p>                Log.d(TAG, &quot;isTimeout=&quot; + isTimeout);</p>
<p>                if(isTimeout == true) {</p>
<p>                    Message m = new Message();</p>
<p>                    m.obj = timeoutMsg;</p>
<p>                    mGpsToastHandler.sendMessage(m);</p>
<p>                }</p>
<p>                mLocationManager.removeUpdates(mLocationListener);</p>
<p>                mIsGpsTimeSyncRunning = false;</p>
<p>            }</p>
<p>        };</p>
<p>        mGpsTimerThread.start();</p>
<p>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>自定义 Dialog</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%87%AA%E5%AE%9A%E4%B9%89%20Dialog/</url>
    <content><![CDATA[<p>//继承主题 </p>
<p>super(context, android.R.style.Theme_Holo_Light_Dialog);</p>
<p>setCancelable(false);  </p>
<p>//没有TITLE，背景变暗。</p>
<p>requestWindowFeature(Window.FEATURE_NO_TITLE);</p>
<p>setContentView(view); </p>
<p>//自定义小</p>
<p>Window dialogWindow = getWindow();<br>WindowManager.LayoutParams lp = dialogWindow.getAttributes();<br>DisplayMetrics d = mContext.getResources().getDisplayMetrics();  <br>lp.width = (int) (d.widthPixels * 0.8);<br>lp.height = (int) (d.heightPixels * 0.8);<br>dialogWindow.setAttributes(lp);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>获取wallpaper  保存到sdcard</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%8E%B7%E5%8F%96wallpaper%20%20%E4%BF%9D%E5%AD%98%E5%88%B0sdcard/</url>
    <content><![CDATA[<p> public void loadWallPaper()</p>
<p>  {      </p>
<p>      Drawable localDrawable = WallpaperManager.getInstance(this).getDrawable();</p>
<p>      File localFile = new File(Environment.getExternalStorageDirectory(), &quot;/System&quot;);</p>
<p>      if (!localFile.exists())</p>
<p>        localFile.mkdirs();</p>
<p>      ////DecodeUtils.exportWallpaperToFile(localDrawable, localFile);  </p>
<p>  }</p>
<p>Drawable d=xxx; //xxx根据自己的情况获取drawable<br>BitmapDrawable bd = (BitmapDrawable) d;<br>Bitmap bm = bd.getBitmap(); </p>
<p>  public static Bitmap drawableToBitmap(Drawable paramDrawable)</p>
<p>  {</p>
<p>    int i = paramDrawable.getIntrinsicWidth();</p>
<p>    int j = paramDrawable.getIntrinsicHeight();</p>
<p>    if (paramDrawable.getOpacity() != -1);</p>
<p>    for (Bitmap.Config localConfig = Bitmap.Config.ARGB_8888; ; localConfig = Bitmap.Config.RGB_565)</p>
<p>    {</p>
<p>      Bitmap localBitmap = Bitmap.createBitmap(i, j, localConfig);</p>
<p>      Canvas localCanvas = new Canvas(localBitmap);</p>
<p>      paramDrawable.setBounds(0, 0, i, j);</p>
<p>      paramDrawable.draw(localCanvas);</p>
<p>      return localBitmap;</p>
<p>    }</p>
<p>  }</p>
<p> public static void saveImage(Bitmap bitmap, String imageName)</p>
<p>   throws Exception {</p>
<p>  String filePath = isExistsFilePath();</p>
<p>  FileOutputStream fos = null;</p>
<p>  File file = new File(filePath, imageName);</p>
<p>  try {</p>
<p>   fos = new FileOutputStream(file);</p>
<p>   if (null != fos) {</p>
<p>    bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);</p>
<p>    fos.flush();</p>
<p>    fos.close();</p>
<p>   }</p>
<p>  } catch (FileNotFoundException e) {</p>
<p>   e.printStackTrace();</p>
<p>  } catch (IOException e) {</p>
<p>   e.printStackTrace();</p>
<p>  }</p>
<p> }</p>
<p> public static String getSDPath() {</p>
<p>  File sdDir = null;</p>
<p>  boolean sdCardExist = Environment.getExternalStorageState().equals(</p>
<p>    android.os.Environment.MEDIA_MOUNTED); // 判断sd卡是否存在</p>
<p>  if (sdCardExist) {</p>
<p>   sdDir = Environment.getExternalStorageDirectory();// 获取根目录</p>
<p>  } else {</p>
<p>   Log.e(&quot;ERROR&quot;, &quot;没有内存卡&quot;);</p>
<p>  }</p>
<p>  return sdDir.toString();</p>
<p> }</p>
<p> private static String isExistsFilePath() {</p>
<p>  String filePath = getSDPath() + CACHE;</p>
<p>  File file = new File(filePath);</p>
<p>  if (!file.exists()) {</p>
<p>   file.mkdirs();</p>
<p>  }</p>
<p>  return filePath;</p>
<p> }</p>
<p> public static Bitmap getImageFromSDCard(String imageName) {</p>
<p>  String filepath = getSDPath() + CACHE + &quot;/&quot; + imageName;</p>
<p>  File file = new File(filepath);</p>
<p>  if (file.exists()) {</p>
<p>   Bitmap bm = BitmapFactory.decodeFile(filepath);</p>
<p>   return bm;</p>
<p>  }</p>
<p>  return null;</p>
<p> }</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>计算器  OTA升级</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%AE%A1%E7%AE%97%E5%99%A8%20%20OTA%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Calculator/src/com/android/calculator2/Logic.java b/packages/apps/Calculator/src/com/android/calculator2/Logic.java</p>
<p>index e0c52f0..5f146c6 100644</p>
<p>— a/packages/apps/Calculator/src/com/android/calculator2/Logic.java</p>
<p>+++ b/packages/apps/Calculator/src/com/android/calculator2/Logic.java</p>
<p>@@ -17,7 +17,8 @@</p>
<p> package com.android.calculator2;</p>
<p> import com.android.calculator2.CalculatorDisplay.Scroll;</p>
<p>-</p>
<p>+import android.util.Log;</p>
<p>+import android.content.ComponentName;</p>
<p> import android.text.TextUtils;</p>
<p> import android.view.KeyEvent;</p>
<p> import android.widget.EditText;</p>
<p>@@ -200,9 +201,37 @@ class Logic {</p>
<p>            if(isIntentAvailable(mContext,intent)==true)</p>
<p>               mContext.startActivity(intent);</p>
<p>           }</p>
<ul>
<li><p>if(getText().equals(&quot;668&quot;)){</p>
</li>
<li><p>startProposingActivity(&quot;/system/vendor/tmp/update_bmp.zip&quot;, &quot;1.0.1&quot;, &quot;1.0.0&quot;);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>if(getText().equals(&quot;669&quot;)){</p>
</li>
<li><p>startProposingActivity(&quot;/system/vendor/tmp/update_qq.zip&quot;, &quot;1.0.1&quot;, &quot;1.0.0&quot;);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>             evaluateAndShowResult(getText(), CalculatorDisplay.Scroll.UP);</p>
<p>         }</p>
<p>     }</p>
<p>+</p>
<ul>
<li><p>public static final String EXTRA_IMAGE_PATH = &quot;android.rockchip.update.extra.IMAGE_PATH&quot;;</p>
</li>
<li><p>public static final String EXTRA_IMAGE_VERSION = &quot;android.rockchip.update.extra.IMAGE_VERSION&quot;;</p>
</li>
<li><p>public static final String EXTRA_CURRENT_VERSION = &quot;android.rockchip.update.extra.CURRENT_VERSION&quot;;</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>public void startProposingActivity(String path, String imageVersion, String currentVersion) {</p>
</li>
<li><p>Log.d(&quot;edward&quot;,&quot;========try to start android.rockchip.update.service.FirmwareUpdatingActivity===========&quot;);</p>
</li>
<li><p>Intent intent = new Intent();</p>
</li>
<li><p>intent.setComponent(new ComponentName(&quot;android.rockchip.update.service&quot;, &quot;android.rockchip.update.service.FirmwareUpdatingActivity&quot;) );</p>
</li>
<li><p>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>intent.putExtra(EXTRA_IMAGE_PATH, path);</p>
</li>
<li><p>intent.putExtra(EXTRA_IMAGE_VERSION, imageVersion);</p>
</li>
<li><p>intent.putExtra(EXTRA_CURRENT_VERSION, currentVersion);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>mContext.startActivity(intent);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<p>+</p>
<p>+</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>设备驱动基础 demo</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80%20demo/</url>
    <content><![CDATA[<p>//wuming.h</p>
<p>#ifndef <em>once_REG_H</em></p>
<p>#define <em>once_REG_H</em></p>
<p>#include &lt;linux/cdev.h&gt;</p>
<p>#include &lt;linux/semaphore.h&gt;</p>
<p>#define wuming_DEVICE_NODE_NAME &quot;wuming&quot;</p>
<p>#define wuming_DEVICE_FILE_NAME &quot;wuming&quot;</p>
<p>#define wuming_DEVICE_PROC_NAME &quot;wuming&quot;</p>
<p>#define wuming_DEVICE_CLASS_NAME &quot;wuming&quot;</p>
<p>struct once_reg_dev {</p>
<p>int val;</p>
<p>struct semaphore sem;</p>
<p>struct cdev dev;</p>
<p>};</p>
<p>#endif</p>
<p>//wuming.c</p>
<p>#include &lt;linux/init.h&gt;</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/types.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/proc_fs.h&gt;</p>
<p>#include &lt;linux/device.h&gt;</p>
<p>#include &lt;asm/uaccess.h&gt;</p>
<p>#include &quot;wuming.h&quot;</p>
<p>static int wuming_major = 0 ;</p>
<p>static int wuming_minor = 0 ;</p>
<p>static struct class* wuming_class = NULL;</p>
<p>static struct once_reg_dev* wuming_dev = NULL;</p>
<p>static int wuming_open(struct inode* inode,struct file* filp);</p>
<p>static int wuming_release(struct inode* inode,struct file* filp);</p>
<p>static ssize_t wuming_read(struct file* filp,char __user <em>buf,size_t count, loff_t</em> f_pos);</p>
<p>static ssize_t wuming_write(struct filp,const char __user <em>buf,size_t count,loff_t</em> f_pos);</p>
<p>//传统的 设备文件系统接口</p>
<p>static struct file_operations wuming_fops = {</p>
<p>.owner = THIS_MODULE,</p>
<p>.open = wuming_open,</p>
<p>.release = wuming_release,</p>
<p>.read = wuming_read,</p>
<p>.write = wuming_write,</p>
<p>}</p>
<p>//devfs文件系统接口</p>
<p>static ssize_t wuming_val_show(struct device* dev, struct device_attribute* attr, char* buf);</p>
<p>static ssize_t wuming_val_store(struct device* dev,struct device_attribute* attr,const char* buf,size_t count);</p>
<p>static DEVICE_ATTR(val,S_IRUGO | S_IWUSR, wuing_val_show,wuming_val_store);</p>
<p>//proc文件系统接口</p>
<p>static ssize_t wuming_proc_read(char* page,char** start,off_t off,int count,int* eof,void* data);</p>
<p>static ssize_t wuming_proc_write(struct file* filp,const char __user *buff,unsigned long len,void *data);</p>
<p>static void wuming_create_proc(void){</p>
<p>struct proc_dir_entry* entry ;</p>
<p>entry = create_proc_entry(wuming_DEVICE_PROC_NAME,0,NULL);</p>
<p>if(entry){</p>
<p>entry-&gt;owner = THIS_MODULE;</p>
<p>entry-&gt;read_proc = wuming_proc_read;</p>
<p>entry-&gt;write_proc = wuming_proc_write;</p>
<p>}</p>
<p>}</p>
<p>static void wuming_remove_proc(void){</p>
<p>remove_proc_entry(wuming_DEVICE_PROC_NAME,NULL);</p>
<p>}</p>
<p>//驱动的加载与卸载</p>
<p>static int __init wuming_init(void){</p>
<p>//传统设备文件系统</p>
<p>//DEVFS文件系统</p>
<p>//PROC文件系统</p>
<p>}</p>
<p>static void __exit wuming_exit(void){</p>
<p>//卸载</p>
<p>}</p>
<p>MODULE_LICENSE(&quot;GPL&quot;);</p>
<p>MODULE_DESCRIPTION(&quot;once Register Driver&quot;)</p>
<p>module_init(wuming_init);</p>
<p>module_exit(wuming_exit)</p>
<p>static int wuming_open(struct inode* inode,struct file* filp){</p>
<p>struct fake_reg_dev* dev;</p>
<p>dev = container_of(inode-&gt;i_cdev,struct fake_reg_dev,dev);</p>
<p>filp-&gt;private_data = dev;</p>
<p>return 0;</p>
<p>}</p>
<p>static int wuming_release(struct inode* inode,struct file* filp){</p>
<p>return 0;</p>
<p>}</p>
<p>static ssize_t wuming_read(struct file* filp,char __user <em>buf,size_t count, loff_t</em> f_pos){</p>
<p>ssize_t err = 0;</p>
<p>struct once_reg_dev* dev = filp-&gt;private_data;</p>
<p>if(down_interruptible(&amp;(dev-&gt;sem))){</p>
<p>return -ERESTARTSYS;</p>
<p>}</p>
<p>if(count &lt; sizeof(dev-&gt;val)){</p>
<p>goto out;</p>
<p>}</p>
<p>if(copy_to_user(buf,&amp;(dev-&gt;val),sizeof(dev-&gt;val))){</p>
<p>err = -EFAULT;</p>
<p>goto out;</p>
<p>}</p>
<p>err = sizeof(dev-&gt;val);</p>
<p>out:</p>
<p>up(&amp;(dev-&gt;val));</p>
<p>return err;</p>
<p>}</p>
<p>static ssize_t wuming_write(struct filp,const char __user <em>buf,size_t count,loff_t</em> f_pos){</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>设定最小亮度Brightness</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%AE%BE%E5%AE%9A%E6%9C%80%E5%B0%8F%E4%BA%AE%E5%BA%A6Brightness/</url>
    <content><![CDATA[<p>frameworks/base/core/res/res/values/config.xml</p>
<p>&lt;integer name=&quot;config_screenBrightnessSettingMinimum&quot;&gt;10&lt;/integer&gt;</p>
<p>在HDMI中使用到screenBrightnessSettingMinimum，双屏LCD休眠时要黑屏，而在调节亮度时就不能全黑</p>
<p>通过修改下面的地方可以达到效果</p>
<p>SystemUI:</p>
<p>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BrightnessController.java</p>
<p> mMinimumBacklight = pm.getMinimumScreenBrightnessSetting()+50;</p>
<p>Setting :</p>
<p>packages/apps/Settings/src/com/android/settings/BrightnessPreference.java</p>
<p>mScreenBrightnessMinimum = pm.getMinimumScreenBrightnessSetting()+50;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>设置 默认HOME</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%AE%BE%E7%BD%AE%20%E9%BB%98%E8%AE%A4HOME/</url>
    <content><![CDATA[<p>import android.content.ComponentName;</p>
<p>import android.content.IntentFilter;</p>
<p>import android.content.pm.ActivityInfo;</p>
<p>import android.content.pm.ApplicationInfo;</p>
<p>import android.content.pm.PackageInfo;</p>
<p>import android.content.pm.PackageManager;</p>
<p>import android.content.pm.ResolveInfo;</p>
<p>import java.util.ArrayList;</p>
<p>PackageManager mPm;</p>
<p>mPm = getPackageManager();</p>
<p>ComponentName[] mHomeComponentSet; </p>
<p>ArrayList&lt;ResolveInfo&gt; homeActivities = new ArrayList&lt;ResolveInfo&gt;();</p>
<p>        ComponentName currentDefaultHome  = mPm.getHomeActivities(homeActivities);       </p>
<p>        mHomeComponentSet = new ComponentName[homeActivities.size()];</p>
<p>        for (int i = 0; i &lt; homeActivities.size(); i++) {</p>
<p>            final ResolveInfo candidate = homeActivities.get(i);</p>
<p>            final ActivityInfo info = candidate.activityInfo;</p>
<p>            ComponentName activityName = new ComponentName(info.packageName, info.name);</p>
<p>            mHomeComponentSet[i] = activityName;        </p>
<p>        }</p>
<p>final IntentFilter mHomeFilter;</p>
<p>mHomeFilter = new IntentFilter(Intent.ACTION_MAIN);</p>
<p>        mHomeFilter.addCategory(Intent.CATEGORY_HOME);</p>
<p>        mHomeFilter.addCategory(Intent.CATEGORY_DEFAULT);</p>
<p>mPm.replacePreferredActivity(mHomeFilter, IntentFilter.MATCH_CATEGORY_EMPTY,</p>
<p>                mHomeComponentSet, new ComponentName(&quot;com.yoons.hssb.launchertoapp&quot;,&quot;com.yoons.hssb.launchertoapp.MainActivity&quot;));</p>
<p>private void setDefaultHome(String pkg,String cls){</p>
<p>PackageManager mPm;</p>
<p>mPm = getPackageManager();</p>
<p>ComponentName[] mHomeComponentSet; </p>
<p>ArrayList&lt;ResolveInfo&gt; homeActivities = new ArrayList&lt;ResolveInfo&gt;();</p>
<p>        ComponentName currentDefaultHome  = mPm.getHomeActivities(homeActivities);       </p>
<p>        mHomeComponentSet = new ComponentName[homeActivities.size()];</p>
<p>        for (int i = 0; i &lt; homeActivities.size(); i++) {</p>
<p>            final ResolveInfo candidate = homeActivities.get(i);</p>
<p>            final ActivityInfo info = candidate.activityInfo;</p>
<p>            ComponentName activityName = new ComponentName(info.packageName, info.name);</p>
<p>            mHomeComponentSet[i] = activityName;        </p>
<p>        }</p>
<p>final IntentFilter mHomeFilter;</p>
<p>mHomeFilter = new IntentFilter(Intent.ACTION_MAIN);</p>
<p>        mHomeFilter.addCategory(Intent.CATEGORY_HOME);</p>
<p>        mHomeFilter.addCategory(Intent.CATEGORY_DEFAULT);</p>
<p>mPm.replacePreferredActivity(mHomeFilter, IntentFilter.MATCH_CATEGORY_EMPTY,</p>
<p>                mHomeComponentSet, new ComponentName(pkg,cls));</p>
<p>}</p>
<p>//参与 settings 代码。</p>
<p>ComponentName[] mHomeComponentSet;</p>
<p>mHomeComponentSet = new ComponentName[homeActivities.size()];</p>
<p>for (int i = 0; i &lt; homeActivities.size(); i++) {</p>
<p>            final ResolveInfo candidate = homeActivities.get(i);</p>
<p>            final ActivityInfo info = candidate.activityInfo;</p>
<p>            ComponentName activityName = new ComponentName(info.packageName, info.name);</p>
<p>mHomeComponentSet[i] = activityName;</p>
<p>            try {</p>
<p>                Drawable icon = info.loadIcon(mPm);</p>
<p>                CharSequence name = info.loadLabel(mPm);</p>
<p>                HomeAppPreference pref = new HomeAppPreference(context, activityName, prefIndex,</p>
<p>                        icon, name, this, info);</p>
<p>                mPrefs.add(pref);</p>
<p>                mPrefGroup.addPreference(pref);</p>
<p>                pref.setEnabled(true);</p>
<p>                if (activityName.equals(currentDefaultHome)) {</p>
<p>                    mCurrentHome = pref;</p>
<p>                }</p>
<p>                prefIndex++;</p>
<p>            } catch (Exception e) {</p>
<p>                Log.v(TAG, &quot;Problem dealing with activity &quot; + activityName, e);</p>
<p>            }</p>
<p>        }</p>
<p>final IntentFilter mHomeFilter;</p>
<p> mHomeFilter = new IntentFilter(Intent.ACTION_MAIN);</p>
<p>        mHomeFilter.addCategory(Intent.CATEGORY_HOME);</p>
<p>        mHomeFilter.addCategory(Intent.CATEGORY_DEFAULT);</p>
<p> mPm = getPackageManager();</p>
<p>mPm.replacePreferredActivity(mHomeFilter, IntentFilter.MATCH_CATEGORY_EMPTY,</p>
<p>                mHomeComponentSet, newHome.activityName);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>设置setting加常亮</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%AE%BE%E7%BD%AEsetting%E5%8A%A0%E5%B8%B8%E4%BA%AE/</url>
    <content><![CDATA[<p> //add to setting to keep screen always on</p>
<p>— a/packages/apps/Settings/res/values/arrays.xml</p>
<p>+++ b/packages/apps/Settings/res/values/arrays.xml</p>
<p>     &lt;!– Display settings.  The delay in inactivity before the screen is turned</p>
<p>     &lt;string-array name=&quot;screen_timeout_entries&quot;&gt;</p>
<ul>
<li>      &lt;item&gt;never&lt;/item&gt;</li>
</ul>
<p>         &lt;item&gt;15 seconds&lt;/item&gt;</p>
<p>         &lt;item&gt;30 seconds&lt;/item&gt;</p>
<p>         &lt;item&gt;1 minute&lt;/item&gt;</p>
<p>     &lt;!– Do not translate. –&gt;</p>
<p>     &lt;string-array name=&quot;screen_timeout_values&quot; translatable=&quot;false&quot;&gt;</p>
<ul>
<li>              &lt;item&gt;-1&lt;/item&gt;</li>
</ul>
<p>         &lt;!– Do not translate. –&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>设置全屏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F/</url>
    <content><![CDATA[<p>private void setFullScreen() {           misFullscreen = !misFullscreen;           if (misFullscreen) {               getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,                                    WindowManager.LayoutParams.FLAG_FULLSCREEN);           } else {               getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);           }    </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>详解SPI中的极性CPOL和相位CPHA</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%AF%A6%E8%A7%A3SPI%E4%B8%AD%E7%9A%84%E6%9E%81%E6%80%A7CPOL%E5%92%8C%E7%9B%B8%E4%BD%8DCPHA/</url>
    <content><![CDATA[<p>详解SPI中的极性CPOL和相位CPHA</p>
<p>           SPI由于接口相对简单（只需要4根线），用途算是比较广泛，主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。即一个SPI的Master通过SPI与一个从设备，即上述的那些Flash，ADC等，进行通讯。而主从设备之间通过SPI进行通讯，首先要保证两者之间时钟SCLK要一致，互相要商量好了，要匹配，否则，就没法正常通讯了，即保证时序上的一致才可正常讯。而这里的SPI中的时钟和相位，指的就是SCLk时钟的特性，即保证主从设备两者的时钟的特性一致了，以保证两者可以正常实现SPI通讯。</p>
<p>          SPI的极性Polarity和相位Phase，最常见的写法是CPOL和CPHA，不过也有一些其他写法，简单总结如下：<br>(1) CKPOL (Clock Polarity) = CPOL = POL = Polarity = （时钟）极性<br>(2) CKPHA (Clock Phase)   = CPHA = PHA = Phase = （时钟）相位<br>(3) SCK=SCLK=SPI的时钟<br>(4) Edge=边沿，即时钟电平变化的时刻，即上升沿(rising edge)或者下降沿(falling edge)<br>对于一个时钟周期内，有两个edge，分别称为：<br>(1)Leading edge=前一个边沿=第一个边沿，对于开始电压是1，那么就是1变成0的时候，对于开始电压是0，那么就是0变成1的时候；<br>(2)Trailing edge=后一个边沿=第二个边沿，对于开始电压是1，那么就是0变成1的时候（即在第一次1变成0之后，才可能有后面的0变成1），对于开始电压是0，那么就是1变成0的时候；<br>本博文采用如下用法：</p>
<p>极性=CPOL</p>
<p>相位=CPHA</p>
<p>SCLK=时钟</p>
<p>第一个边沿和第二个边沿</p>
<p>CPOL和CPHA，分别都可以是0或时1，对应的四种组合就是：</p>
<p>下面详细介绍。</p>
<p>CPOL极性</p>
<p>           先说什么是SCLK时钟的空闲时刻，其就是当SCLK在发送8个bit比特数据之前和之后的状态，于此对应的，SCLK在发送数据的时候，就是正常的工作的时候，有效active的时刻了。其英文精简解释为：Clock Polarity = IDLE state of SCK。<br>SPI的CPOL，表示当SCLK空闲idle的时候，其电平的值是低电平0还是高电平1：<br>CPOL=0，时钟空闲idle时候的电平是低电平，所以当SCLK有效的时候，就是高电平，就是所谓的active-high；<br>CPOL=1，时钟空闲idle时候的电平是高电平，所以当SCLK有效的时候，就是低电平，就是所谓的active-low；</p>
<p>             从上图中可以看出，(CPOL=0)的SCK 波形，它有（传输）8 个脉冲，而在脉冲传输前和完成后都保持在【低电平状态】。此时的状态就是时钟的空闲状态或无效状态，因为此时没有脉冲，也就不会有数据传输。同理得出，（CPOL=）1 的图，时钟的空闲状态或无效状态时SCK 是保持【高电平的】。</p>
<p>CPHA相位</p>
<p>           首先说明一点，capture strobe = latch = read = sample，都是表示数据采样，数据有效的时刻。相位，对应着数据采样是在第几个边沿（edge），是第一个边沿还是第二个边沿，0对应着第一个边沿，1对应着第二个边沿。<br>对于：<br>CPHA=0，表示第一个边沿：<br>对于CPOL=0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿；<br>对于CPOL=1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿；<br>CPHA=1，表示第二个边沿：<br>对于CPOL=0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿；<br>对于CPOL=1，idle时候的是高电平，第一个边沿就是从低变到高，所以是上升沿；</p>
<p>            我们看上面的图，发现数据 SI 是对应 SCK 的第一个时钟沿，再仔细看，数据是在SCK的第一个时钟边沿保持稳定【数据被采样捕获】，在下一个边沿改变【SCK 的下降沿数据改变】因此我们得出结论：该系列FLASH 是【数据在第一个时钟沿被采样捕获】或【数据在SPCK 起始边沿捕获，在SPCK 下一个边沿改变】</p>
<p>如何判断CPOL和CPHA</p>
<p>            如果起始的SCLK的电平是0，那么CPOL=0，如果是1，那么CPOL=1，然后看数据采样时刻，即时序图数据线上的数据那个矩形区域的中间所对应的位置，对应到上面SCLK时钟的位置，对应着是第一个边沿或是第二个边沿，即CPHA是0或1。（对应的是上升沿还是还是下降沿，要根据对应的CPOL的值，才能确定）。</p>
<p>（1）如何判断CPOL：SCLK的空闲时候的电压，是0还是1，决定了CPOL是0还是1；<br>（2）如何判断CPHA：而数据采样时刻对应着的SCLK的电平，是第一个边沿还是第二个边沿，对应着CPHA为0还是1。</p>
<p>SCLK的极性，相位，边沿之间的内在逻辑</p>
<p>最后来看一下S3C2440的SPI的CPOL和CPHA，结合前面讲的理论知识，下面的图就很好理解啦！</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>诸葛亮写给儿子的一封信，仅86字！足以影响人一生</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%AF%B8%E8%91%9B%E4%BA%AE%E5%86%99%E7%BB%99%E5%84%BF%E5%AD%90%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1%EF%BC%8C%E4%BB%8586%E5%AD%97%EF%BC%81%E8%B6%B3%E4%BB%A5%E5%BD%B1%E5%93%8D%E4%BA%BA%E4%B8%80%E7%94%9F/</url>
    <content><![CDATA[<p>【新朋友】请戳标题下方蓝色字体“我的麦库”关注我们，享受最贴心的微信记事服务，一键收藏所有微信重要资讯</p>
<p>【老朋友】点击右上角，转发或分享本页内容</p>
<p>诸葛亮写给儿子的一封信，只用了短短八十六字，但是对于为学做人有精简而且具体的忠告。一千八百多年前的智慧，在今天的科技时代，仍然有其参考价值。</p>
<p>诸葛亮诫子书</p>
<p>夫君子之行，静以修身，俭以养德；</p>
<p>非澹泊无以明志，非宁静无以致远。</p>
<p>夫学须静也，才须学也；</p>
<p>非学无以广才，非志无以成学。</p>
<p>怠慢则不能励精，险躁则不能冶性。</p>
<p>年与时驰，意与岁去，遂成枯落，多不接世。</p>
<p>悲守穷庐，将复何及！</p>
<p>第一课：宁静的力量</p>
<p>静以修身、非宁静无以致远、学须静也。诸葛亮忠告孩子宁静才能够修养身心，静思反省。不能够静下来，则不可以有效的计划未来，而且学习的首要条件，就是有宁静的环境。现代人大多数终日忙碌，你是否应在忙乱中静下来，反思人生方向？</p>
<p>第二课：节俭的力量</p>
<p>俭以养德。诸葛亮忠告孩子要节俭，以培养自己的德行。审慎理财，量入为出，不但可以摆脱负债的困扰，更可以过着纪律的简朴生活，不会成为物质的奴隶。在鼓励消费的文明社会，你有否想过节俭的好处呢？</p>
<p>第三课：计划的力量</p>
<p>非澹泊无以明志、非宁静无以致远。诸葛亮忠告孩子要计划人生，不要事事讲求名利，才能够了解自己的志向，要静下来，才能够细心计划将来。面对未来，你有理想吗？你有使命感吗？你有自己的价值观吗？</p>
<p>第四课：学习的力量</p>
<p>夫学须静也、才须学也。诸葛亮忠告孩子宁静的环境对学习大有帮助，当然配合专注的平静心境，就更加事半功倍。诸葛亮不是天才论的信徒，他相信才能是学习的结果。你有否全心全力的学习？你是否相信努力才有成就？</p>
<p>第五课：增值的力量</p>
<p>非学无以广才、非志无以成学。诸葛亮忠告孩子要增值先要立志，不愿意努力学习，就不能够增加自己的才干。但学习的过程中，决心和毅力非常重要，因为缺乏了意志力，就会半途而废。你有否想过，一鼓作气人多，坚持到底人少的道理？</p>
<p>第六课：速度的力量</p>
<p>怠慢则不能励精。诸葛亮忠告孩子凡事拖延就不能够快速的掌握要点。电脑时代是速度的时代，样样事情讲求效率，想不到一千八百多年前的智慧，也一样不谋而合。快人一步，不但理想达到，你有否想过，有更多时间去修正及改善？</p>
<p>第七课：性格的力量</p>
<p>险躁则不能冶性。诸葛亮忠告孩子太过急躁就不能够陶冶性情。心理学家说：思想影响行为，行为影响习惯，习惯影响性格，性格影响命运。诸葛亮明白生命中要作出种种平衡，要“励精”，也要“冶性”。你要提升自己性格的品质吗？</p>
<p>第八课：时间的力量</p>
<p>年与时驰、意与岁去。诸葛亮忠告孩子时光飞逝，意志力又会随着时间消磨，“少壮不努力，老大徒伤悲”，时间管理是个现代人的观念，细心想一想，时间不可以被管理，每天二十四小时，不多也不少，惟有管理自己，善用每分每秒。请你想一想，你有蹉跎岁月吗？</p>
<p>第九课：想像的力量</p>
<p>遂成枯落、多不接世、悲守穷庐、将复何及。诸葛亮忠告孩子时光飞逝，当自己变得和世界脱节，才悲叹蹉跎岁月，也于事无补。要懂得居安思危，才能够临危不乱。想像力比知识更有力量。你有没有从大处着想，小处着手，脚踏实地，规划是人生呢？</p>
<p>第十课：精简的力量</p>
<p>以上诸葛亮写给儿子的一封信，只用了短短八十六字，精简地传递了具体的讯息。我相信精简的表达源于清晰的思想，精简沟通更有效果。你懂得言之有物地精简沟通吗？</p>
<p>点击“阅读原文”，一键收入麦库。</p>
<p>阅读原文 </p>
<p>阅读</p>
<p>举报 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>读文件字符串显示于systemUI</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%AF%BB%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%BE%E7%A4%BA%E4%BA%8EsystemUI/</url>
    <content><![CDATA[<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>@@ -89,6 +89,10 @@ import com.android.systemui.statusbar.policy.Prefs;</p>
<p> import java.io.FileDescriptor;</p>
<p> import java.io.PrintWriter;</p>
<p> import java.util.ArrayList;</p>
<p>+import java.io.File ;</p>
<p>+import java.io.BufferedReader;</p>
<p>+import java.io.IOException;</p>
<p>+import java.io.FileReader;</p>
<p> public class TabletStatusBar extends BaseStatusBar implements</p>
<p>         InputMethodsPanel.OnHardKeyboardEnabledChangeListener {</p>
<p>@@ -489,6 +493,31 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>         return mStatusBarView;</p>
<p>     }</p>
<p>+</p>
<p>+</p>
<ul>
<li><p>public String readFileByLines(String fileName) {</p>
</li>
<li><p>File file = new File(fileName);</p>
</li>
<li><p>BufferedReader reader = null;</p>
</li>
<li><p>String tempString = &quot;&quot;;</p>
</li>
<li><p>if (!file.exists())</p>
</li>
<li><p>return tempString;</p>
</li>
<li><p>try {</p>
</li>
<li><p>reader = new BufferedReader(new FileReader(file));</p>
</li>
<li><p>tempString = reader.readLine() ;</p>
</li>
<li><p>reader.close();</p>
</li>
<li><p>} catch (IOException e) {</p>
</li>
<li><p>//e.printStackTrace();</p>
</li>
<li><p>} finally {</p>
</li>
<li><p>if (reader != null) {</p>
</li>
<li><p>try {</p>
</li>
<li><p>reader.close();</p>
</li>
<li><p>} catch (IOException e1) {</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>return tempString ;</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p>     protected View makeStatusBarView() {</p>
<p>         final Context context = mContext;</p>
<p>         IntentFilter intentfilter=new IntentFilter();</p>
<p>@@ -511,8 +540,18 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>             }</p>
<p>         } catch (RemoteException ex) {</p>
<p>         }</p>
<p>-</p>
<p>+</p>
<p>                String nums = SystemProperties.get(&quot;ro.bx.add.nums&quot;, &quot;&quot;);</p>
<p>+</p>
<ul>
<li><p>String tmpnum = &quot;&quot;;</p>
</li>
<li><p>tmpnum = readFileByLines(&quot;/mnt/sdcard/oem.num&quot;).trim();</p>
</li>
<li><p>if(tmpnum.equals(&quot;&quot;)){</p>
</li>
<li><p>tmpnum = readFileByLines(&quot;/data/oem.num&quot;).trim();</p>
</li>
<li><p>if(!tmpnum.equals(&quot;&quot;))</p>
</li>
<li><p>nums = tmpnum;</p>
</li>
<li><p>}else{</p>
</li>
<li><p>nums = tmpnum;</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>                TextView adNum = (TextView) sb.findViewById(R.id.add_number);</p>
<p>                                adNum.setText(adNum.getText()+nums);</p>
<p>(END)</p>
<p>         final Context context = mContext;</p>
<p>         IntentFilter intentfilter=new IntentFilter();</p>
<p>@@ -511,8 +540,18 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>             }</p>
<p>         } catch (RemoteException ex) {</p>
<p>         }</p>
<p>-</p>
<p>+</p>
<p>                String nums = SystemProperties.get(&quot;ro.bx.add.nums&quot;, &quot;&quot;);</p>
<p>+</p>
<ul>
<li><p>String tmpnum = &quot;&quot;;</p>
</li>
<li><p>tmpnum = readFileByLines(&quot;/mnt/sdcard/oem.num&quot;).trim();</p>
</li>
<li><p>if(tmpnum.equals(&quot;&quot;)){</p>
</li>
<li><p>tmpnum = readFileByLines(&quot;/data/oem.num&quot;).trim();</p>
</li>
<li><p>if(!tmpnum.equals(&quot;&quot;))</p>
</li>
<li><p>nums = tmpnum;</p>
</li>
<li><p>}else{</p>
</li>
<li><p>nums = tmpnum;</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>                TextView adNum = (TextView) sb.findViewById(R.id.add_number);</p>
<p>                                adNum.setText(adNum.getText()+nums);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>调用keyguardService</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%B0%83%E7%94%A8keyguardService/</url>
    <content><![CDATA[<p>KeyguardTouchDelegate keyguardInstance;</p>
<p> keyguardInstance = KeyguardTouchDelegate.getInstance(this);</p>
<p> @Override</p>
<p>    protected void onStop() { ///在Acitivity起来后，才会得到keyguard service,所以在onStop中测试</p>
<p>        super.onStop();</p>
<p> keyguardInstance.onScreenTurnedOff(0);</p>
<p>    }</p>
<p>package com.bx.demo;</p>
<p>import android.content.ComponentName;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.content.ServiceConnection;<br>import android.os.IBinder;<br>import android.os.RemoteException;<br>import android.os.UserHandle;<br>import android.util.Slog;<br>import android.view.MotionEvent;</p>
<p>import com.android.internal.policy.IKeyguardExitCallback;<br>import com.android.internal.policy.IKeyguardShowCallback;<br>import com.android.internal.policy.IKeyguardService;</p>
<p>/**</p>
<ul>
<li><p>Facilitates event communication between navigation bar and keyguard.  Currently used to</p>
</li>
<li><p>control WidgetPager in keyguard to expose the camera widget.</p>
</li>
<li></li>
<li><p>/<br>public class KeyguardTouchDelegate {<br>  // TODO: propagate changes to these to {@link KeyguardServiceDelegate}<br>  static final String KEYGUARD_PACKAGE = &quot;com.android.keyguard&quot;;<br>  static final String KEYGUARD_CLASS = &quot;com.android.keyguard.KeyguardService&quot;;</p>
<p>  private static KeyguardTouchDelegate sInstance;</p>
<p>  private volatile IKeyguardService mService;</p>
<p>  protected static final boolean DEBUG = false;<br>  protected static final String TAG = &quot;edward&quot;;</p>
<p>  private final ServiceConnection mKeyguardConnection = new ServiceConnection() {</p>
<pre><code>  @Override
  public void onServiceConnected(ComponentName name, IBinder service) &#123;
      Slog.v(TAG, &amp;quot;Connected to keyguard&amp;quot;);
      mService = IKeyguardService.Stub.asInterface(service);

  &#125;

  @Override
  public void onServiceDisconnected(ComponentName name) &#123;
      Slog.v(TAG, &amp;quot;Disconnected from keyguard&amp;quot;);
      mService = null;
      sInstance = null; // force reconnection if this goes away
  &#125;</code></pre>
<p>  };</p>
<p>  private KeyguardTouchDelegate(Context context) {</p>
<pre><code>  Intent intent = new Intent();
  intent.setClassName(KEYGUARD_PACKAGE, KEYGUARD_CLASS);
  if (!context.bindServiceAsUser(intent, mKeyguardConnection,
          Context.BIND_AUTO_CREATE, UserHandle.OWNER)) &#123;
      if (DEBUG) Slog.v(TAG, &amp;quot;*** Keyguard: can&#39;t bind to &amp;quot; + KEYGUARD_CLASS);
  &#125; else &#123;
      if (DEBUG) Slog.v(TAG, &amp;quot;*** Keyguard started&amp;quot;);
  &#125;</code></pre>
<p>  }</p>
<p>  public static KeyguardTouchDelegate getInstance(Context context) {</p>
<pre><code>  KeyguardTouchDelegate instance = sInstance;
  if (instance == null) &#123;
      instance = sInstance = new KeyguardTouchDelegate(context);
  &#125;
  return instance;</code></pre>
<p>  }</p>
</li>
</ul>
<pre><code> public void onScreenTurnedOff(int why) &#123;
  final IKeyguardService service = mService;
    if (service != null) &#123;
        try &#123;
            service.onScreenTurnedOff(why);
        &#125; catch (RemoteException e) &#123;
            // What to do?
            Slog.e(TAG, &amp;quot;RemoteException onScreenTurnedOff keyguard!&amp;quot;, e);
        &#125;
    &#125; else &#123;
        Slog.w(TAG, &amp;quot;onScreenTurnedOff(): NO SERVICE!&amp;quot;);
    &#125;  
&#125;</code></pre>
<p>}</p>
<p>Keyguard Service 的方法：</p>
<p>private final IKeyguardService.Stub mBinder = new IKeyguardService.Stub() {<br>        public boolean isShowing() {<br>            return mKeyguardViewMediator.isShowing();<br>        }<br>        public boolean isSecure() {<br>            return mKeyguardViewMediator.isSecure();<br>        }<br>        public boolean isShowingAndNotHidden() {<br>            return mKeyguardViewMediator.isShowingAndNotHidden();<br>        }<br>        public boolean isInputRestricted() {<br>            return mKeyguardViewMediator.isInputRestricted();<br>        }<br>        public void verifyUnlock(IKeyguardExitCallback callback) {<br>            mKeyguardViewMediator.verifyUnlock(callback);<br>        }<br>        public void keyguardDone(boolean authenticated, boolean wakeup) {<br>            checkPermission();<br>            mKeyguardViewMediator.keyguardDone(authenticated, wakeup);<br>        }<br>        public void setHidden(boolean isHidden) {<br>            checkPermission();<br>            mKeyguardViewMediator.setHidden(isHidden);<br>        }<br>        public void dismiss() {<br>            mKeyguardViewMediator.dismiss();<br>        }<br>        public void onDreamingStarted() {<br>            checkPermission();<br>            mKeyguardViewMediator.onDreamingStarted();<br>        }<br>        public void onDreamingStopped() {<br>            checkPermission();<br>            mKeyguardViewMediator.onDreamingStopped();<br>        }<br>        public void onScreenTurnedOff(int reason) {<br>            checkPermission();<br>            mKeyguardViewMediator.onScreenTurnedOff(reason);<br>        }<br>        public void onScreenTurnedOn(IKeyguardShowCallback callback) {<br>            checkPermission();<br>            mKeyguardViewMediator.onScreenTurnedOn(callback);<br>        }<br>        public void setKeyguardEnabled(boolean enabled) {<br>            checkPermission();<br>            mKeyguardViewMediator.setKeyguardEnabled(enabled);<br>        }<br>        public boolean isDismissable() {<br>            return mKeyguardViewMediator.isDismissable();<br>        }<br>        public void onSystemReady() {<br>            checkPermission();<br>            mKeyguardViewMediator.onSystemReady();<br>        }<br>        public void doKeyguardTimeout(Bundle options) {<br>            checkPermission();<br>            mKeyguardViewMediator.doKeyguardTimeout(options);<br>        }<br>        public void setCurrentUser(int userId) {<br>            checkPermission();<br>            mKeyguardViewMediator.setCurrentUser(userId);<br>        }<br>        public void showAssistant() {<br>            checkPermission();<br>            mKeyguardViewMediator.showAssistant();<br>        }<br>        public void dispatch(MotionEvent event) {<br>            checkPermission();<br>            mKeyguardViewMediator.dispatch(event);<br>        }<br>        public void launchCamera() {<br>            checkPermission();<br>            mKeyguardViewMediator.launchCamera();<br>        }<br>        public void onBootCompleted() {<br>            checkPermission();<br>            mKeyguardViewMediator.onBootCompleted();<br>        }<br>    };</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>调用wps 打开PDF文档</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%B0%83%E7%94%A8wps%20%E6%89%93%E5%BC%80PDF%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>                                    Intent intent = new Intent();</p>
<p>intent.setAction(Intent.ACTION_VIEW); </p>
<p>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); </p>
<p>intent.setDataAndType(Uri.parse(&quot;file://&quot;+imageUrls[arg2]), &quot;application/pdf&quot;); //加file://才会直接打开</p>
<p>//intent.setClassName(&quot;cn.wps.moffice_eng&quot;, &quot;cn.wps.moffice.documentmanager.PreStartActivity2&quot;);</p>
<p>startActivity(intent);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>跨apk共享数据，隐藏apk</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%B7%A8apk%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%9A%90%E8%97%8Fapk/</url>
    <content><![CDATA[<p>diff –git a/packages/apps/Launcher2/src/com/android/launcher2/LauncherModel.java b/packages/apps/Launcher2/src/com/andr</p>
<p>index a1e6aae..ed5f3dc 100644</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/LauncherModel.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/LauncherModel.java</p>
<p>@@ -16,6 +16,7 @@</p>
<p> package com.android.launcher2;</p>
<p>+import android.content.SharedPreferences;</p>
<p> import android.app.SearchManager;</p>
<p> import android.appwidget.AppWidgetManager;</p>
<p> import android.appwidget.AppWidgetProviderInfo;</p>
<p>@@ -1466,6 +1467,15 @@ public class LauncherModel extends BroadcastReceiver {</p>
<p>             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);</p>
<p>             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);</p>
<ul>
<li><p>                       Context otherAppsContext = null;</p>
</li>
<li><p>               try {</p>
</li>
<li><p>                   otherAppsContext = mContext.createPackageContext(&quot;com.android.rk&quot;, 0);</p>
</li>
<li><p>               } catch (NameNotFoundException e) {</p>
</li>
<li><p>               }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                      SharedPreferences sp = otherAppsContext.getSharedPreferences(&quot;play_store&quot;, Context.MODE_WORLD_READABLE</p>
</li>
<li><p>                      Boolean isShow = sp.getBoolean(&quot;play&quot;, false);</p>
</li>
<li><p>                      Log.d(&quot;edward&quot;,&quot;isSHow:=&quot;+isShow);</p>
</li>
</ul>
<p>             final PackageManager packageManager = mContext.getPackageManager();</p>
<p>             List&lt;ResolveInfo&gt; apps = null;</p>
<p>@@ -1515,6 +1525,8 @@ public class LauncherModel extends BroadcastReceiver {</p>
<p>                 for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {</p>
<p>                     // This builds the icon bitmaps.</p>
<p>                //Log.d(&quot;TAGG&quot;,&quot;classname:=&quot;+apps.get(i).activityInfo.name);</p>
<ul>
<li><p>              if(apps.get(i).activityInfo.name.equals(&quot;com.android.vending.AssetBrowserActivity&quot;) &amp;&amp; !isShow){</p>
</li>
<li><p>                                      i++;continue;}</p>
</li>
</ul>
<p>                     mAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),</p>
<p>                             mIconCache, mLabelCache));</p>
<p>                     i++;</p>
<p>(END)</p>
<p>             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);</p>
<p>             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);</p>
<ul>
<li><p>                       Context otherAppsContext = null;</p>
</li>
<li><p>               try {</p>
</li>
<li><p>                   otherAppsContext = mContext.createPackageContext(&quot;com.android.rk&quot;, 0);</p>
</li>
<li><p>               } catch (NameNotFoundException e) {</p>
</li>
<li><p>               }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                      SharedPreferences sp = otherAppsContext.getSharedPreferences(&quot;play_store&quot;, Context.MODE_WORLD_READABLE);</p>
</li>
<li><p>                      Boolean isShow = sp.getBoolean(&quot;play&quot;, false);</p>
</li>
<li><p>                      Log.d(&quot;edward&quot;,&quot;isSHow:=&quot;+isShow);</p>
</li>
</ul>
<p>             final PackageManager packageManager = mContext.getPackageManager();</p>
<p>             List&lt;ResolveInfo&gt; apps = null;</p>
<p>@@ -1515,6 +1525,8 @@ public class LauncherModel extends BroadcastReceiver {</p>
<p>                 for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {</p>
<p>                     // This builds the icon bitmaps.</p>
<p>                //Log.d(&quot;TAGG&quot;,&quot;classname:=&quot;+apps.get(i).activityInfo.name);</p>
<ul>
<li><p>              if(apps.get(i).activityInfo.name.equals(&quot;com.android.vending.AssetBrowserActivity&quot;) &amp;&amp; !isShow){</p>
</li>
<li><p>                                      i++;continue;}</p>
</li>
</ul>
<p>                     mAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),</p>
<p>                             mIconCache, mLabelCache));</p>
<p>                     i++;</p>
<p>public boolean onCreateOptionsMenu(Menu menu) {</p>
<p>super.onCreateOptionsMenu(menu);</p>
<p>menu.add(0, MENU_APP_MANAGE, 0, R.string.str_menu_app_manage)</p>
<p>.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);</p>
<p>menu.add(0, MENU_TOOL_HIDE, 0, R.string.str_menu_tool_hide);</p>
<p>menu.add(0, MENU_TOOL_SHOW, 0, R.string.str_menu_tool_show);</p>
<p>menu.add(0, APP_HIDE, 0, R.string.app_hide);</p>
<p>menu.add(0, APP_SHOW, 0, R.string.app_show);</p>
<p>return true;</p>
<p>}</p>
<p>public boolean onPrepareOptionsMenu(Menu menu) {</p>
<p>if (tool_bar.getVisibility() == View.VISIBLE) {</p>
<p>menu.getItem(1).setVisible(true);</p>
<p>menu.getItem(2).setVisible(false);</p>
<p>} else {</p>
<p>menu.getItem(1).setVisible(false);</p>
<p>menu.getItem(2).setVisible(true);</p>
<p>}</p>
<p>SharedPreferences sp = getSharedPreferences(&quot;play_store&quot;, MODE_WORLD_READABLE); </p>
<p>Boolean isShow = sp.getBoolean(&quot;play&quot;, false);</p>
<p>if(isShow){</p>
<p>menu.getItem(3).setVisible(true);</p>
<p>menu.getItem(4).setVisible(false);</p>
<p>}else{</p>
<p>menu.getItem(3).setVisible(false);</p>
<p>menu.getItem(4).setVisible(true);</p>
<p>}</p>
<p>return super.onPrepareOptionsMenu(menu);</p>
<p>}</p>
<p>case APP_HIDE:</p>
<p>SharedPreferences sp1 = getSharedPreferences(&quot;play_store&quot;, MODE_WORLD_READABLE); </p>
<p>sp1.edit().putBoolean(&quot;play&quot;, false).commit();</p>
<p> ActivityManager manager1 = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);           </p>
<p>        manager1.killBackgroundProcesses(&quot;com.android.launcher&quot;);</p>
<p>break;</p>
<p>case APP_SHOW:</p>
<p>SharedPreferences sp2 = getSharedPreferences(&quot;play_store&quot;, MODE_WORLD_READABLE); </p>
<p>sp2.edit().putBoolean(&quot;play&quot;, true).commit();</p>
<p>ActivityManager manager2 = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);           </p>
<p>        manager2.killBackgroundProcesses(&quot;com.android.launcher&quot;);</p>
<p>break;</p>
<p>========  加在 Setting 里面=========================================</p>
<p>diff –git a/packages/apps/Launcher2/src/com/android/launcher2/LauncherModel.java b/packages/apps/Launcher2/src/com/android/launcher2/LauncherModel.java</p>
<p>index 3bf65b6..0368179 100644</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/LauncherModel.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/LauncherModel.java</p>
<p>@@ -46,7 +46,7 @@ import android.os.Process;</p>
<p> import android.os.RemoteException;</p>
<p> import android.os.SystemClock;</p>
<p> import android.util.Log;</p>
<p>-</p>
<p>+import android.content.SharedPreferences;</p>
<p> import com.android.launcher.R;</p>
<p> import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;</p>
<p>@@ -1465,6 +1465,16 @@ public class LauncherModel extends BroadcastReceiver {</p>
<p>             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);</p>
<p>             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);</p>
<p>+</p>
<ul>
<li><p>             Context otherAppsContext = null;</p>
</li>
<li><p>               try {</p>
</li>
<li><p>                   otherAppsContext = mContext.createPackageContext(&quot;com.android.settings&quot;, 0);</p>
</li>
<li><p>               } catch (NameNotFoundException e) {</p>
</li>
<li><p>               }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>         SharedPreferences sp = otherAppsContext.getSharedPreferences(&quot;play_store&quot;, Context.MODE_WORLD_READABLE);</p>
</li>
<li><p>                      Boolean isShow = sp.getBoolean(&quot;play&quot;, false);</p>
</li>
<li><p>                      Log.d(&quot;edward&quot;,&quot;isSHow:=&quot;+isShow);</p>
</li>
</ul>
<p>             final PackageManager packageManager = mContext.getPackageManager();</p>
<p>             List&lt;ResolveInfo&gt; apps = null;</p>
<p>@@ -1516,11 +1526,13 @@ public class LauncherModel extends BroadcastReceiver {</p>
<p>                     // This builds the icon bitmaps.</p>
<p>                //Log.d(&quot;edward&quot;,&quot;packagesname:=&quot;+apps.get(i).activityInfo.packageName);</p>
<p>                //Log.d(&quot;edward&quot;,&quot;classname:=&quot;+apps.get(i).activityInfo.name);</p>
<ul>
<li><p>                      final ActivityInfo activityInfo = apps.get(i).activityInfo;</p>
</li>
<li><p>                      if(&quot;org.hermit.touchtest.TouchTest&quot;.equals(activityInfo.name) ||</p>
</li>
<li><p>                      &quot;com.adobe.flashplayer&quot;.equals(activityInfo.packageName)){</p>
</li>
<li><p>                              i++;continue;</p>
</li>
<li><p>                      }</p>
</li>
</ul>
<ul>
<li><p>      ///             final ActivityInfo activityInfo = apps.get(i).activityInfo;</p>
</li>
<li><p>      //              if(&quot;org.hermit.touchtest.TouchTest&quot;.equals(activityInfo.name) ||</p>
</li>
<li><p>      //              &quot;com.adobe.flashplayer&quot;.equals(activityInfo.packageName)){</p>
</li>
<li><p>      //                      i++;continue;</p>
</li>
<li><p>      //              }</p>
</li>
<li><p>if(apps.get(i).activityInfo.name.equals(&quot;com.android.vending.AssetBrowserActivity&quot;) &amp;&amp; !isShow){</p>
</li>
<li><p>                                      i++;continue;}</p>
</li>
</ul>
<p>                     mAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),</p>
<p>                             mIconCache, mLabelCache));</p>
<p>                     i++;</p>
<p>diff –git a/packages/apps/Settings/AndroidManifest.xml b/packages/apps/Settings/AndroidManifest.xml</p>
<p>index b38b859..2262715 100644</p>
<p>— a/packages/apps/Settings/AndroidManifest.xml</p>
<p>+++ b/packages/apps/Settings/AndroidManifest.xml</p>
<p>@@ -4,7 +4,7 @@</p>
<p>         android:sharedUserId=&quot;android.uid.system&quot;&gt;</p>
<p>     &lt;original-package android:name=&quot;com.android.settings&quot; /&gt;</p>
<p>-</p>
<ul>
<li>&lt;uses-permission android:name=&quot;android.permission.KILL_BACKGROUND_PROCESSES&quot; /&gt;</li>
</ul>
<p>     &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</p>
<p>     &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt;</p>
<p>     &lt;uses-permission android:name=&quot;android.permission.WRITE_SECURE_SETTINGS&quot; /&gt;</p>
<p>diff –git a/packages/apps/Settings/res/values/strings.xml b/packages/apps/Settings/res/values/strings.xml</p>
<p>index c12d879..1a4ddda 100755</p>
<p>— a/packages/apps/Settings/res/values/strings.xml</p>
<p>+++ b/packages/apps/Settings/res/values/strings.xml</p>
<p>@@ -4223,5 +4223,7 @@</p>
<p>          &lt;string name=&quot;str_about&quot;&gt;Important&lt;/string&gt;</p>
<p>          &lt;string name=&quot;str_mesg&quot;&gt;Whether save Settings?&lt;/string&gt;</p>
<p>          &lt;string name=&quot;save_failed&quot;&gt;Save failed!&lt;/string&gt;</p>
<p>-</p>
<p>+&lt;string name=&quot;show_play&quot;&gt;Show Play Store&lt;/string&gt;</p>
<p>+&lt;string name=&quot;on_play&quot;&gt;Play Store is showed&lt;/string&gt;</p>
<p>+&lt;string name=&quot;off_play&quot;&gt;Play Store is hided&lt;/string&gt;</p>
<p> &lt;/resources&gt;</p>
<p>diff –git a/packages/apps/Settings/res/xml/wireless_settings.xml b/packages/apps/Settings/res/xml/wireless_settings.xml</p>
<p>index e73dbad..5ba481e 100755</p>
<p>— a/packages/apps/Settings/res/xml/wireless_settings.xml</p>
<p>+++ b/packages/apps/Settings/res/xml/wireless_settings.xml</p>
<p>@@ -88,5 +88,11 @@</p>
<p>             android:targetPackage=&quot;com.android.cellbroadcastreceiver&quot;</p>
<p>             android:targetClass=&quot;com.android.cellbroadcastreceiver.CellBroadcastSettings&quot; /&gt;</p>
<p>     &lt;/PreferenceScreen&gt;</p>
<p>+</p>
<ul>
<li><p>       &lt;CheckBoxPreference</p>
</li>
<li><p>       android:key=&quot;show_playstore&quot;</p>
</li>
<li><p>       android:title=&quot;@string/show_play&quot;</p>
</li>
<li><p>       android:summary=&quot;@string/on_play&quot;</p>
</li>
<li><p>       android:persistent=&quot;false&quot; /&gt;</p>
</li>
</ul>
<p> &lt;/PreferenceScreen&gt;</p>
<p>diff –git a/packages/apps/Settings/src/com/android/settings/WirelessSettings.java b/packages/apps/Settings/src/com/android/settings/WirelessSettings.java</p>
<p>index 1fbf83e..db0e564 100755</p>
<p>— a/packages/apps/Settings/src/com/android/settings/WirelessSettings.java</p>
<p>+++ b/packages/apps/Settings/src/com/android/settings/WirelessSettings.java</p>
<p>@@ -34,12 +34,12 @@ import android.provider.Settings;</p>
<p> import android.view.LayoutInflater;</p>
<p> import android.view.View;</p>
<p> import android.widget.Switch;</p>
<p>-</p>
<p>+import android.content.SharedPreferences;</p>
<p> import com.android.internal.telephony.TelephonyIntents;</p>
<p> import com.android.internal.telephony.TelephonyProperties;</p>
<p> import com.android.settings.nfc.NfcEnabler;</p>
<p> import com.android.settings.NsdEnabler;</p>
<p>-</p>
<p>+import android.app.ActivityManager;</p>
<p> public class WirelessSettings extends SettingsPreferenceFragment {</p>
<p>     private static final String KEY_TOGGLE_AIRPLANE = &quot;toggle_airplane&quot;;</p>
<p>@@ -61,6 +61,7 @@ public class WirelessSettings extends SettingsPreferenceFragment {</p>
<p>     private AirplaneModeEnabler mAirplaneModeEnabler;</p>
<p>     private CheckBoxPreference mAirplaneModePreference;</p>
<ul>
<li>      private CheckBoxPreference play_store;</li>
</ul>
<p>     private NfcEnabler mNfcEnabler;</p>
<p>     private NfcAdapter mNfcAdapter;</p>
<p>     private NsdEnabler mNsdEnabler;</p>
<p>@@ -79,7 +80,19 @@ public class WirelessSettings extends SettingsPreferenceFragment {</p>
<p>                 new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),</p>
<p>                 REQUEST_CODE_EXIT_ECM);</p>
<p>             return true;</p>
<ul>
<li>       }</li>
</ul>
<ul>
<li><p>       }else if(preference == play_store){</p>
</li>
<li><p>              SharedPreferences sp1 = getActivity().getSharedPreferences(&quot;play_store&quot;, Context.MODE_WORLD_READABLE);</p>
</li>
<li><p>                      Boolean isShow = sp1.getBoolean(&quot;play&quot;, false);</p>
</li>
<li><p>              sp1.edit().putBoolean(&quot;play&quot;, !isShow).commit();</p>
</li>
<li><p>              if(!isShow){</p>
</li>
<li><p>              preference.setSummary(play_store.getContext().getString(R.string.on_play,&quot;&quot;));</p>
</li>
<li><p>              }else{</p>
</li>
<li><p>              preference.setSummary(play_store.getContext().getString(R.string.off_play,&quot;&quot;));</p>
</li>
<li><p>              }</p>
</li>
<li><p>                ActivityManager manager1 = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</p>
</li>
<li><p>            manager1.killBackgroundProcesses(&quot;com.android.launcher&quot;);</p>
</li>
</ul>
<p>+</p>
<ul>
<li>              }</li>
</ul>
<p>         // Let the intents be launched by the Preference manager</p>
<p>         return super.onPreferenceTreeClick(preferenceScreen, preference);</p>
<p>     }</p>
<p>@@ -113,7 +126,18 @@ public class WirelessSettings extends SettingsPreferenceFragment {</p>
<p>         CheckBoxPreference nfc = (CheckBoxPreference) findPreference(KEY_TOGGLE_NFC);</p>
<p>         PreferenceScreen androidBeam = (PreferenceScreen) findPreference(KEY_ANDROID_BEAM_SETTINGS);</p>
<p>         CheckBoxPreference nsd = (CheckBoxPreference) findPreference(KEY_TOGGLE_NSD);</p>
<p>-</p>
<ul>
<li><p>               play_store = (CheckBoxPreference) findPreference(&quot;show_playstore&quot;);</p>
</li>
<li><p>              play_store.setPersistent(false);</p>
</li>
<li><p>              SharedPreferences sp = activity.getSharedPreferences(&quot;play_store&quot;, Context.MODE_WORLD_READABLE);</p>
</li>
<li><p>              Boolean isShow = sp.getBoolean(&quot;play&quot;, false);</p>
</li>
<li><p>              if(isShow){</p>
</li>
<li><p>              play_store.setChecked(true);</p>
</li>
<li><p>              play_store.setSummary(play_store.getContext().getString(R.string.on_play,&quot;&quot;));</p>
</li>
<li><p>              }else{</p>
</li>
<li><p>              play_store.setChecked(false);</p>
</li>
<li><p>              play_store.setSummary(play_store.getContext().getString(R.string.off_play,&quot;&quot;));</p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>+</p>
<p>         if(mHasAirplane) {</p>
<p>             mAirplaneModeEnabler = new AirplaneModeEnabler(activity, mAirplaneModePreference);</p>
<p>         }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>身份通</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%BA%AB%E4%BB%BD%E9%80%9A/</url>
    <content><![CDATA[<p>120385339 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>输入法全屏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%BE%93%E5%85%A5%E6%B3%95%E5%85%A8%E5%B1%8F/</url>
    <content><![CDATA[<p>— a/frameworks/base/core/java/android/inputmethodservice/InputMethodService.ja</p>
<p>+++ b/frameworks/base/core/java/android/inputmethodservice/InputMethodService.ja</p>
<p>@@ -846,7 +846,8 @@ public class InputMethodService extends AbstractInputMethodS</p>
<p>      * is currently running in fullscreen mode.</p>
<p>      */</p>
<p>     public void updateFullscreenMode() {</p>
<ul>
<li>       boolean isFullscreen = mShowInputRequested &amp;&amp; onEvaluateFullscreenMode(</li>
</ul>
<ul>
<li><p>    //   boolean isFullscreen = mShowInputRequested &amp;&amp; onEvaluateFullscreenMod</p>
</li>
<li><p>       boolean isFullscreen = true ;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>进入recover模式，重启</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%BF%9B%E5%85%A5recover%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%87%8D%E5%90%AF/</url>
    <content><![CDATA[<p>     try {           </p>
<p>                    Runtime.getRuntime().exec(&quot;go_recovery&quot;);</p>
<p>                      new Thread().sleep(2000);</p>
<p>                      Runtime.getRuntime().exec(new String[]{&quot;su&quot;,&quot;-c&quot;,&quot;reboot now&quot;});</p>
<p>                       } catch (Exception e) {</p>
<p>                       // TODO: handle exception</p>
<p>                      e.printStackTrace();</p>
<p>                      }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>连dongle改变语言时区</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%BF%9Edongle%E6%94%B9%E5%8F%98%E8%AF%AD%E8%A8%80%E6%97%B6%E5%8C%BA/</url>
    <content><![CDATA[<p>frameworks/base/telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java</p>
<p> if (getAutoTimeZone()) {//根据Settings.System.AUTO_TIME_ZONE的值来确定是否自动更新时区</p>
<p>                    setAndBroadcastNetworkSetTimeZone(zone.getID());</p>
<p>                }</p>
<p>diff –git a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml</p>
<p>index 1ef51a0..bbbb81e 100755</p>
<p>— a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml</p>
<p>+++ b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml</p>
<p>@@ -27,7 +27,7 @@</p>
<p>     &lt;string name=&quot;def_airplane_mode_radios&quot; translatable=&quot;false&quot;&gt;cell,bluetooth,wifi,nfc,wimax&lt;/string&gt;</p>
<p>     &lt;string name=&quot;airplane_mode_toggleable_radios&quot; translatable=&quot;false&quot;&gt;bluetooth,wifi,nfc&lt;/string&gt;</p>
<p>     &lt;bool name=&quot;def_auto_time&quot;&gt;true&lt;/bool&gt;</p>
<ul>
<li>   &lt;bool name=&quot;def_auto_time_zone&quot;&gt;true&lt;/bool&gt;</li>
</ul>
<ul>
<li>   &lt;bool name=&quot;def_auto_time_zone&quot;&gt;false&lt;/bool&gt;</li>
</ul>
<p>     &lt;bool name=&quot;def_accelerometer_rotation&quot;&gt;true&lt;/bool&gt;</p>
<p>     &lt;!– Default screen brightness, from 0 to 255.  102 is 40%. –&gt;</p>
<p>     &lt;integer name=&quot;def_screen_brightness&quot;&gt;102&lt;/integer&gt;</p>
<p>diff –git a/frameworks/base/telephony/java/com/android/internal/telephony/MccTable.java b/frameworks/base/telephony/java/com/android/internal/telephony/MccTable.java</p>
<p>index b6711bc..1947a1d 100755</p>
<p>— a/frameworks/base/telephony/java/com/android/internal/telephony/MccTable.java</p>
<p>+++ b/frameworks/base/telephony/java/com/android/internal/telephony/MccTable.java</p>
<p>@@ -176,8 +176,8 @@ public final class MccTable</p>
<p>             int mcc, mnc;</p>
<p>             try {</p>
<ul>
<li><p>               mcc = Integer.parseInt(mccmnc.substring(0,3));</p>
</li>
<li><p>               mnc = Integer.parseInt(mccmnc.substring(3));</p>
</li>
</ul>
<ul>
<li><p>               mcc = 0;//Integer.parseInt(mccmnc.substring(0,3));</p>
</li>
<li><p>               mnc = 0;//Integer.parseInt(mccmnc.substring(3));</p>
</li>
</ul>
<p>             } catch (NumberFormatException e) {</p>
<p>                 Log.e(LOG_TAG, &quot;Error parsin</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>退回HOME</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%80%80%E5%9B%9EHOME/</url>
    <content><![CDATA[<p>PackageManager pm = mActivity.getPackageManager();    </p>
<p>ResolveInfo homeInfo = pm.resolveActivity(new Intent(Intent.ACTION_MAIN)  </p>
<p>.addCategory(Intent.CATEGORY_HOME), 0);    </p>
<p>ActivityInfo ai = homeInfo.activityInfo;    </p>
<p>Intent startIntent = new Intent(Intent.ACTION_MAIN);    </p>
<p>startIntent.addCategory(Intent.CATEGORY_LAUNCHER);    </p>
<p>startIntent.setComponent(new ComponentName(ai.packageName,ai.name));  </p>
<p>startIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);    </p>
<p>mActivity.startActivity(startIntent);  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>逐行读取文件写到数据库</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%80%90%E8%A1%8C%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%99%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>&lt;?</p>
<p>require_once(‘config.php’); </p>
<p>header(‘Content-Type: text/plain; charset=gb2312’); </p>
<p>$db-&gt;Connect($dsn) || die(‘fail’);</p>
<p>$lines = file(‘EnglishProverb.txt’, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);</p>
<p>// Loop through our array, show HTML source as HTML source; and line numbers too.</p>
<p> $en = &quot;&quot;;</p>
<p> $zh = &quot;&quot;;</p>
<p>foreach ($lines as $line_num =&gt; $line) {</p>
<p>    if(($line_num+1)%2 == 0){</p>
<p>$zh = $line ;</p>
<p>$stmt = $db-&gt;Prepare(&quot;insert into repository ([en],[zh],[ca]) values (?,?,?)&quot;);</p>
<p>$db-&gt;Execute($stmt,array($en,$zh,&quot;双语&quot;)) or die(‘insert failed’);  </p>
<p>}</p>
<p>else </p>
<p>   $en = $line ;</p>
<p>    //echo ($line_num+1). ‘.’.$line.’&lt;br&gt;’;</p>
<p>}</p>
<p>?&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>通过反射调用获取内置存储和外置sd卡根路径(通用)</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E8%8E%B7%E5%8F%96%E5%86%85%E7%BD%AE%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E7%BD%AEsd%E5%8D%A1%E6%A0%B9%E8%B7%AF%E5%BE%84(%E9%80%9A%E7%94%A8)/</url>
    <content><![CDATA[<p>/**</p>
<ul>
<li>通过反射调用获取内置存储和外置sd卡根路径(通用)</li>
<li></li>
<li>@param is_removale 是否可移除，false返回内部存储，true返回外置sd卡</li>
<li></li>
<li>@return</li>
<li>/<br>private static String getStoragePath(boolean is_removale) {<br>   StorageManager mStorageManager = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);<br>   Class&lt;?&gt; storageVolumeClazz = null;<br>   try {<br>       storageVolumeClazz = Class.forName(&quot;android.os.storage.StorageVolume&quot;);<br>       Method getVolumeList = mStorageManager.getClass().getMethod(&quot;getVolumeList&quot;);<br>       Method getPath = storageVolumeClazz.getMethod(&quot;getPath&quot;);<br>       Method isRemovable = storageVolumeClazz.getMethod(&quot;isRemovable&quot;);<br>       Object result = getVolumeList.invoke(mStorageManager);<br>       final int length = Array.getLength(result);<br>       for (int i = 0; i &lt; length; i++) {<br>           Object storageVolumeElement = Array.get(result, i);<br>           String path = (String) getPath.invoke(storageVolumeElement);<br>           boolean removable = (Boolean) isRemovable.invoke(storageVolumeElement);<br>           if (is_removale == removable) {<br>               return path;<br>           }<br>       }<br>   } catch (ClassNotFoundException e) {<br>       e.printStackTrace();<br>   } catch (InvocationTargetException e) {<br>       e.printStackTrace();<br>   } catch (NoSuchMethodException e) {<br>       e.printStackTrace();<br>   } catch (IllegalAccessException e) {<br>       e.printStackTrace();<br>   }<br>   return null;<br>}</li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>遥控事件 触摸音</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%81%A5%E6%8E%A7%E4%BA%8B%E4%BB%B6%20%E8%A7%A6%E6%91%B8%E9%9F%B3/</url>
    <content><![CDATA[<p>  /policy/src/com/android/internal/policy/impl/PhoneWindow.java</p>
<p>import android.view.SoundEffectConstants;</p>
<p>onKeyUp</p>
<p>if(keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN){</p>
<p>if(featureId != -1)</p>
<p>mDecor.playSoundEffect(SoundEffectConstants.CLICK);</p>
<p>//Log.d(&quot;edward&quot;,&quot;featureId&quot;+featureId);</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>邮编住房编码 居住证</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%82%AE%E7%BC%96%E4%BD%8F%E6%88%BF%E7%BC%96%E7%A0%81%20%E5%B1%85%E4%BD%8F%E8%AF%81/</url>
    <content><![CDATA[<p><a href="http://www.51youbian.com/fwbm/">http://www.51youbian.com/fwbm/</a></p>
<p><a href="http://www.szzlb.gov.cn/LEAPV5/LEAP/UnitModule/czww_search/housesearch.html">http://www.szzlb.gov.cn/LEAPV5/LEAP/UnitModule/czww_search/housesearch.html</a></p>
<p><a href="http://203.91.45.154/templates/integrationnet/userLogin.jsp">http://203.91.45.154/templates/integrationnet/userLogin.jsp</a></p>
<p><a href="https://sz12333.gov.cn/jydjWeb/login.jsp">https://sz12333.gov.cn/jydjWeb/login.jsp</a></p>
<p>查询居住证办理情况</p>
<p><a href="http://bsy.sz.bendibao.com/juzhubs/7205">http://bsy.sz.bendibao.com/juzhubs/7205</a></p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>键盘快捷键WIN - HOME</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AEWIN%20-%20HOME/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java</p>
<p>index 571082d..c717083 100755</p>
<p>— a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java</p>
<p>+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java</p>
<p>@@ -1715,7 +1715,14 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback</p>
<p>                 return true;</p>
<p>             }</p>
<p>-</p>
<ul>
<li><p>                      case 117:{</p>
</li>
<li><p>                              Intent startLauncher  = new Intent();</p>
</li>
<li><p>                              startLauncher.setClassName(&quot;com.android.launcher&quot;,&quot;com.android.launcher2.Launcher&quot;);</p>
</li>
<li><p>                              startLauncher.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>                              this.getContext().startActivity(startLauncher);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                              return true ;</p>
</li>
<li><p>                      }</p>
</li>
</ul>
<p>             case KeyEvent.KEYCODE_F1:</p>
<p>diff –git a/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java b/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>index c2b5c1e..def71d5 100644</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>@@ -773,6 +773,13 @@ public final class Launcher extends Activity</p>
<p>                 return onSearchRequested();</p>
<p>             }</p>
<p>         }</p>
<p>+</p>
<ul>
<li><p>           if(keyCode == 117){// win Home</p>
</li>
<li><p>                      showWorkspace(true);</p>
</li>
<li><p>                      return true;</p>
</li>
</ul>
<p>+</p>
<ul>
<li>                      }</li>
</ul>
<p>+</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>长按返回键 HOME</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%95%BF%E6%8C%89%E8%BF%94%E5%9B%9E%E9%94%AE%20HOME/</url>
    <content><![CDATA[<p>— a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>@@ -1918,7 +1918,22 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>                 }</p>
<p>             }</p>
<p>             return -1;</p>
<ul>
<li>       } else if (keyCode == KeyEvent.KEYCODE_MENU) {</li>
</ul>
<ul>
<li><p>       }</p>
</li>
<li><p>              else if (keyCode == KeyEvent.KEYCODE_BACK) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                              if (down) {</p>
</li>
<li><p>               if (repeatCount == 0) {</p>
</li>
<li><p>                 //</p>
</li>
<li><p>               } else if ((event.getFlags() &amp; KeyEvent.FLAG_LONG_PRESS) != 0) {</p>
</li>
<li><p>                   if (!keyguardOn) {</p>
</li>
<li><p>                                              goHome();</p>
</li>
<li><p>                       Log.d(&quot;edward&quot;,&quot;——— isLongBACKPress ——-&quot;);</p>
</li>
<li><p>                                              return -1;</p>
</li>
<li><p>                   }</p>
</li>
<li><p>               }</p>
</li>
<li><p>           }</p>
</li>
<li><p>              }</p>
</li>
<li><p>              else if (keyCode == KeyEvent.KEYCODE_MENU) {</p>
</li>
</ul>
<p>             // Hijack modified menu keys for debugging features</p>
<p>             final int chordBug = KeyEvent.META_SHIFT_ON;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>问题</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>1.GPS影响WIFI,导致搜不到热点(存在隐患) </p>
<p>2.GPS开机后1分钟才能使用，否则会导致搜不到星(存在隐患) </p>
<p>3.高温问题 （存在隐患）</p>
<p>4.4G、WIFI天线信号弱（存在隐患）</p>
<p>5.USB供电升级不了（影响生产效率）</p>
<p>6.录音增益调不了（影响拾音）</p>
<p>7./sdcard目录不能升级ota</p>
<p>8.slog开关，大小限制</p>
<p>9.不能多个应用同时录音 </p>
<p>HZ4G问题</p>
<p>1.网络停机</p>
<p>2.FM发射断开沙沙声（与3相关）</p>
<p>3.Carservice挂掉重启频率过高</p>
<p>4.高温死机/重启 </p>
<p>325</p>
<p>软件规格：</p>
<p>前后双路 1280P(HDR夜视 30fps)+720P </p>
<p>视频格式  h264/h265 TS封装</p>
<p>WIFI (RTSP实时预览/CGI) G711A</p>
<p>Gsensor(停车监控、碰撞加锁)</p>
<p>客制化需求：</p>
<p>1.CGI接口可以自定义扩充，并支持固件升级</p>
<p>2.自定义TCP连接接口</p>
<p>3.RTSP实时预览分辨率切换(720P/480P 动态切换)</p>
<p>4.抓拍/碰撞能生成前后5S的视频</p>
<p>5.UVC视频能添加文字水印</p>
<p>6.能添加TF卡寿命等信息，及TF卡文件IO</p>
<p>7.支持Linux编程标准接口</p>
<p>OBD</p>
<p>1.ACC 按正常的打火熄火输出</p>
<p>2.提供AT指令：版本号 VIN  读取/清除故障码 清除总里程 查询熄火数据 设置急加减速阀</p>
<p>3.提供校验方式</p>
<p>4.故障码解析接口</p>
<p> 升级/恢复出厂:  红蓝灯同时闪烁(300ms)</p>
<p> 蓝灯   DVR已连接（ON）  DVR未连接(OFF) </p>
<p> 红灯  正常(ON)   4G+GPS异常(200ms)  4G网络异常(500ms)  GPS异常(1s)   </p>
<p>产品形态：无屏智能网关+隐藏式DVR，安全功能等都在手机APP端实现。</p>
<p>安全服务功能与流量卡不绑定</p>
<p>充值界面：提供套餐购买及查询SDK接口（包含卡状态 有效期 当前套餐 基础套餐列表（轻奢版壹年套餐 98   豪华版叁年套餐 258） 服务状态）</p>
<p>          及查询iccid是否属于翼卡的接口。  </p>
<p>          （检测到非翼卡流量卡，使用第三方套餐接口。）                </p>
<p>安全服务充值：提供H5链接（非翼卡也能充值）</p>
<p>注册与激活：SDK接口方式激活，翼卡流量卡与安全服务同时激活。 参数：imei,iccid,手机号</p>
<p>APP功能界面： 违章查询、语音服务、SOS视频服务。（SDK方式集成）</p>
<p>设备端： 集成安全服务APP，不能限卡限网。</p>
<p>H5充值页面(包含不限于)</p>
<p>卡状态</p>
<p>有效期</p>
<p>当前套餐</p>
<p>基础套餐列表</p>
<p>（轻奢版壹年套餐 98  </p>
<p> 豪华版叁年套餐 258）</p>
<p>安全服务套餐</p>
<p>服务状态</p>
<p>ICCID</p>
<p>A类BUG</p>
<p>1.远程直播黑屏，打不开。</p>
<p>2.影响休眠电流；有时休眠状态不对。</p>
<p>3.视频图片需要直接上传到OSS(经服务器中转带宽有限)，也会影响抓拍速度</p>
<p>4.OSS文件存放路径（/dvr/IMEI/日期/原文件名），现在不改后面不好迁移数据</p>
<p>5.记录仪视频列表等待时间过长，需倒序、分步获取</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>防止Handler的内存泄露</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%98%B2%E6%AD%A2Handler%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<p>1：使用静态内部类+弱引用</p>
<p>//将Handler改成静态内部类</p>
<p>     private static class FHandler extends Handler{</p>
<p>      //定义弱引用实例</p>
<p>      private WeakReference&lt;Activity&gt; reference; </p>
<p>      //在构造方法中传入需要持有的Activity实例</p>
<p>      public MyHandler(Activity activity) { </p>
<p>      reference = new WeakReference&lt;Activity&gt;(activity); }</p>
<p>        //通过复写handlerMessage()从而决定如何进行更新UI操作</p>
<p>        @Override</p>
<p>        public void handleMessage(Message msg) {</p>
<p>        //省略代码</p>
<p>            }</p>
<p>}</p>
<p>2：当外部类结束生命周期时清空消息队列</p>
<p>@Override<br>    protected void onDestroy() {<br>        super.onDestroy();<br>        mHandler.removeCallbacksAndMessages(null);<br>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云服务器 ftp</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%20ftp/</url>
    <content><![CDATA[<p>8 ftp软件方式 </p>
<p>Step1. 在云服务器配置FTP服务 </p>
<p>1.在root权限下，通过如下命令安装Vsftp。 </p>
<p>[root@VM_250_202_tlinux ~]# yum install vsftpd </p>
<p>2.在启动vsftpd服务之前，需要登录云服务器修改配置文件，将匿名登录禁用掉。打开配置文件，命令如下： </p>
<p>[root@VM_250_202_tlinux ~]# vim/etc/vsftpd/vsftpd.conf </p>
<p>在配置文件中第11行的“anonymous_enable=YES”前面加上#号，即将匿名登录禁用。 </p>
<p>3.读取生效配置。 </p>
<p>[root@VM_250_202_tlinux ~]# cat/etc/vsftpd/vsftpd.conf |grep ^[^#] </p>
<p>local_enable=YESwrite_enable=YESlocal_umask=022anon_upload_enable=YESanon_mkdir_write_enable=YESanon_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES </p>
<p>4.启动vsftpd服务。 </p>
<p>[root@VM_250_202_tlinux ~]# service vsftpd start </p>
<p>5.设置FTP用户账号。设置成功后，即可通过该账号登录FTP服务器。（1）设置FTP用户的账号，例如账号为“ftpuser1”，目录为/home/ftpuser1，且设置不允许通过ssh登录。 </p>
<p>[root@VM_250_202_tlinux ~]# useradd -m -d/home/ftpuser1 -s /sbin/nologin ftpuser1 </p>
<p>（2）设置账号对应的密码，例如密码为“ftpuser1”。 </p>
<p>[root@VM_250_202_tlinux ~]# passwd ftpuser1 </p>
<p>6.修改vsftpd的pam配置，使开发者可以通过自己设置的FTP用户帐号和密码连接到云服务器。（1）修改pam。 </p>
<p>[root@VM_250_202_tlinux ~]# vim/etc/pam.d/vsftpd </p>
<p>内容修改为： </p>
<p>#%PAM-1.0 auth required/lib64/security/pam_listfile.so item=user sense=deny file=/etc/ftpusersonerr=succeed auth required /lib64/security/pam_unix.so shadow nullok authrequired /lib64/security/pam_shells.so account required/lib64/security/pam_unix.so session required /lib64/security/pam_unix.so </p>
<p>（2）确认修改后的文件是否正确。 </p>
<p>[root@VM_250_202_tlinux ~]# cat/etc/pam.d/vsftpd#%PAM-1.0 auth required /lib64/security/pam_listfile.soitem=user sense=deny file=/etc/ftpusers onerr=succeed authrequired /lib64/security/pam_unix.so shadow nullok auth required/lib64/security/pam_shells.so account required /lib64/security/pam_unix.sosession required /lib64/security/pam_unix.so </p>
<p>（3）重启vsftpd服务，使修改生效。 </p>
<p>[root@VM_250_202_tlinux ~]# service vsftpdrestartShutting down vsftpd: [ OK ]Starting vsftpd for vsftpd: [ OK ] </p>
<p>Step2. 上传文件到Linux云服务器 </p>
<p>1.下载并安装开源软件FileZilla请使用FileZilla的3.5.1、3.5.2版本（使用3.5.3版本的FileZilla进行FTP上传会有问题）。由于FileZilla 官网上只提供了最新的3.5.3版本下载，因此建议开发者自行搜索3.5.1、3.5.2下 </p>
<p>载地址。建议的3.5.1 下载地址：<a href="http://www.oldapps.com/filezilla.PHP?old_filezilla=6350">http://www.oldapps.com/filezilla.PHP?old_filezilla=6350</a> </p>
<p>2.连接FTP运行FileZilla，按下图所示进行配置，配置后点击“快速链接”： </p>
<p>配置信息说明如下：（1）主机：云服务器的公网IP（在云服务器“管理视图”页面可查看云服务器的公网IP）。（2）用户名：在Step1中设置的FTP用户的账号，这里以“ftpuser1”为例。（3）密码：在Step1中设置的FTP用户账号对应的密码，这里以“ftpuser1”为例。（4）端口：FTP监听端口，默认为“21”。 </p>
<p>3.上传文件到Linux云服务器上传文件时，鼠标选中本地文件，拖拽到远程站点，即将文件上传到了Linux云服务器。注意：云服务器FTP通道不支持上传tar压缩包后自动解压，以及删除tar包功能。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>隐藏activity</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%9A%90%E8%97%8Factivity/</url>
    <content><![CDATA[<p>provison中隐藏 后面再禁止的activity</p>
<p>//disable activity </p>
<p>ComponentName mDisableHandsFreeLauncherActivity = new ComponentName(&quot;com.google.android.googlequicksearchbox&quot;,&quot;com.google.android.handsfree.HandsFreeLauncherActivity&quot;);</p>
<p>ComponentName mDisableLatinSetupActivity = new ComponentName(&quot;com.android.inputmethod.latin&quot;,&quot;com.android.inputmethod.latin.setup.SetupActivity&quot;);</p>
<p>setActivityState(DefaultActivity.this,mDisableHandsFreeLauncherActivity,PackageManager.COMPONENT_ENABLED_STATE_DISABLED);</p>
<p>setActivityState(DefaultActivity.this,mDisableLatinSetupActivity,PackageManager.COMPONENT_ENABLED_STATE_DISABLED);</p>
<p>private static boolean setActivityState(final Context context,</p>
<p>            final ComponentName activityComponent, final int activityState) {</p>
<p>        final PackageManager pm = context.getPackageManager();</p>
<p>        final int activityComponentState = pm.getComponentEnabledSetting(activityComponent);</p>
<p>        if (activityComponentState == activityState) {</p>
<p>            return false;</p>
<p>        }</p>
<p>        pm.setComponentEnabledSetting(</p>
<p>                activityComponent, activityState, PackageManager.DONT_KILL_APP);</p>
<p>        return true;</p>
<p>    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>静态桌面</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%9D%99%E6%80%81%E6%A1%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>diff –git a/src/com/android/launcher3/Workspace.java b/src/com/android/launcher3/Workspace.java</p>
<p>index 01a89f3..e8b4814 100644</p>
<p>— a/src/com/android/launcher3/Workspace.java</p>
<p>+++ b/src/com/android/launcher3/Workspace.java</p>
<p>@@ -1144,7 +1144,7 @@ public class Workspace extends SmoothPagedView</p>
<p>                 if (computeScrollOffset() &amp;&amp; mWindowToken != null) {</p>
<p>                     try {</p>
<p>                         mWallpaperManager.setWallpaperOffsets(mWindowToken,</p>
<ul>
<li>                               /<em>mWallpaperOffset.getCurrX()</em>/0.0f, 0.5f);</li>
</ul>
<ul>
<li>                               mWallpaperOffset.getCurrX(), 0.5f);</li>
</ul>
<p>/// 3168 高清屏 1366x768    1368/1376    解决截图问题  stride 32bit 对齐</p>
<p>diff –git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp</p>
<p>index 4bfbabe..c3e30ca 100755</p>
<p>— a/services/surfaceflinger/Layer.cpp</p>
<p>+++ b/services/surfaceflinger/Layer.cpp</p>
<p>@@ -949,6 +949,15 @@ bool Layer::setLayer(uint32_t z) {</p>
<p>     return true;</p>
<p> }</p>
<p> bool Layer::setSize(uint32_t w, uint32_t h) {</p>
<p>+</p>
<ul>
<li><p>      //zxl:Limit width and height of layer to legal value.</p>
</li>
<li><p>  int iMaxTextureSize=mFlinger-&gt;getMaxTextureSize();</p>
</li>
<li><p>   if(!strcmp(mName,&quot;com.android.systemui.ImageWallpaper&quot;))</p>
</li>
<li><p>   {</p>
</li>
<li><p>       ALOGV(&quot;Limit (w=%d,h=%d) to MaxTextureSize=%d&quot;,w,h,iMaxTextureSize);</p>
</li>
<li><p>       w=(w&gt;iMaxTextureSize)?iMaxTextureSize:w;</p>
</li>
<li><p>       h=(h&gt;iMaxTextureSize)?iMaxTextureSize:h;</p>
</li>
<li><p>  }</p>
</li>
</ul>
<p>     if (mCurrentState.requested.w == w &amp;&amp; mCurrentState.requested.h == h)</p>
<p>         return false;</p>
<p>     mCurrentState.requested.w = w;</p>
<p>diff –git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp</p>
<p>index 2d10d1e..c8cbca7 100755</p>
<p>— a/services/surfaceflinger/SurfaceFlinger.cpp</p>
<p>+++ b/services/surfaceflinger/SurfaceFlinger.cpp</p>
<p>@@ -3178,7 +3178,8 @@ void SurfaceFlinger::renderScreenImplLocked(</p>
<p>     mDelayFlag = 1;</p>
<p> }</p>
<p>-</p>
<p>+#define ALIGN(x,a)     (((x) + (a) - 1L) &amp; ~((a) - 1L))</p>
<p>+#define HW_ALIGN       32</p>
<p> status_t SurfaceFlinger::captureScreenImplLocked(</p>
<p>         const sp&lt;const DisplayDevice&gt;&amp; hw,</p>
<p>         const sp&lt;IGraphicBufferProducer&gt;&amp; producer,</p>
<p>@@ -3215,7 +3216,8 @@ status_t SurfaceFlinger::captureScreenImplLocked(</p>
<p>         reqWidth  = (!reqWidth)  ? hw_w : reqWidth;</p>
<p>         reqHeight = (!reqHeight) ? hw_h : reqHeight;</p>
<p>     }</p>
<p>-</p>
<ul>
<li><p>       //zxl:fix capture err when force change resolution</p>
</li>
<li><p>      reqWidth=ALIGN(reqWidth, HW_ALIGN);</p>
</li>
</ul>
<p>     // create a surface (because we’re a producer, and we need to</p>
<p>     // dequeue/queue a buffer)</p>
<p>     sp&lt;Surface&gt; sur = new Surface(producer, false);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>面试</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>自我介绍？</p>
<p>面试题: 回调函数和观察者模式的区别？<br>“标准答案”：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。观察者模式完美的将观察者和被观察的对象分离开，</p>
<p>一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。<br>回调函数其实也算是一种观察者模式的实现方式，回调函数实现的观察者和被观察者往往是一对一的依赖关系。<br>所以最明显的区别是观察者模式是一种设计思路，而回调函数式一种具体的实现方式；另一明显区别是一对多还是多对多的依赖关系方面。</p>
<p>面试题：Android的单列模式如何保证一定单列的情况？</p>
<p>public class Singleton{<br>    private volatile static Singleton instance;<br>    private Singleton() {};<br>    public static Singleton getInstance() {<br>        if (instance==null) {<br>            synchronized(Singleton.class) {<br>                if (instance==null)<br>                    instance=new Singleton();<br>            }<br>        }<br>        return instance;<br>    }<br>}</p>
<p>面试题: Android较常用到的设计模式？<br>标准答案:<br>适配器模式：GridView、ListView的Adapter;<br>建造者模式：AlertDialog.Builder;<br>观察者模式：ListView的adapter.notifyDataSetChanged;<br>责任链模式：View的事件分发；</p>
<p>面试题：Java的内存模型<br>标准答案:Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。</p>
<p>程序中的变量存储在主内存中，每个线程拥有自己的工作内存并存放变量的拷贝，线程读写自己的工作内存，通过主内存进行变量的交互。</p>
<p>JMM就是规定了工作内存和主内存之间变量访问的细节，通过保障原子性、有序性、可见性来实现线程的有效协同和数据的安全。</p>
<p>面试题：JVM如何判断一个对象实例是否应该被回收？<br>标准答案: 垃圾回收器会建立有向图的方式进行内存管理，通过GC Roots来往下遍历，</p>
<p>当发现有对象处于不可达状态的时候，就会对其标记为不可达，以便于后续的GC回收。</p>
<p>面试题：说说JVM的垃圾回收策略。<br>标准答案: JVM采用分代垃圾回收。在JVM的内存空间中把堆空间分为年老代和年轻代。</p>
<p>将大量创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。</p>
<p>面试题：多个进程同时调用一个ContentProvider的query获取数据，ContentPrvoider是如何反应的呢？<br>一个content provider可以接受来自另外一个进程的数据请求。尽管ContentResolver与ContentProvider类隐藏了实现细节，</p>
<p>但是ContentProvider所提供的query()，insert()，delete()，update()都是在ContentProvider进程的线程池中被调用执行的，而不是进程的主线程中。</p>
<p>这个线程池是有Binder创建和维护的，其实使用的就是每个应用进程中的Binder线程池。</p>
<p>面试题：你觉得Android设计ContentProvider的目的是什么呢？</p>
<ol>
<li>隐藏数据的实现方式，对外提供统一的数据访问接口；</li>
<li>更好的数据访问权限管理。ContentProvider可以对开发的数据进行权限设置，不同的URI可以对应不同的权限，只有符合权限要求的组件才能访问到ContentProvider的具体操作。</li>
<li>ContentProvider封装了跨进程共享的逻辑，我们只需要Uri即可访问数据。由系统来管理ContentProvider的创建、生命周期及访问的线程分配，简化我们在应用间共享数据（进程间通信）的方式。</li>
</ol>
<p>我们只管通过ContentResolver访问ContentProvider所提示的数据接口，而不需要担心它所在进程是启动还是未启动。</p>
<p>面试题：运行在主线程的ContentProvider为什么不会影响主线程的UI操作?</p>
<p>ContentProvider的onCreate()是运行在UI线程的，而query()，insert()，delete()，update()是运行在线程池中的工作线程的，</p>
<p>所以调用这向个方法并不会阻塞ContentProvider所在进程的主线程，但可能会阻塞调用者所在的进程的UI线程！</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>面试2</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%9D%A2%E8%AF%952/</url>
    <content><![CDATA[<p>设计模式<br>添加红外服务<br>添加按键完整流程<br>activity启动模式</p>
<p>Activity 4种加载模式</p>
<p>standard    系统的默认模式，每次跳转都会创建一个新的实例。</p>
<p>singleTop  如果任务栈的栈顶已经存在这个activity的实例, 不会创建新的Activity,而是利用旧的activity实例 调用 旧的activity的onNewIntent()方法. </p>
<p>如果这个Activity不存在与栈顶时，还是会创建新的Activity</p>
<p>singleTask  在任务栈里面只允许一个实例存在, 并且把当前activity上面其他的activity从任务栈里清空!</p>
<p>                     可以把后台同一个栈的所有Activity带到前台的栈顶</p>
<p>singleInstance Activity单独存在一个栈中，所在的Task没有其他成员。</p>
<p>（对称加密） AES、DES        </p>
<p>（非对称加密）RSA </p>
<p>IPC通信（进程间通信）方式：</p>
<ol>
<li>bundle ：<br>简单易用  但是只能传输Bundle支持的对象 常用于四大组件间进程间通信 </li>
<li>文件共享：<br>简单易用  但不适合在高并发的情况下 并且读取文件需要时间 不能即时通信   常用于并发程度不高 并且实时性要求不高的情况</li>
<li>AIDL ：<br>功能强大 支持一对多并发通信 支持即时通信   但是使用起来比其他的复杂 需要处理好多线程的同步问题  常用于一对多通信 且有RPC 需求的场合(服务端和客户端通信)</li>
<li>Messenger ：<br>功能一般 支持一对多串行通信 支持实时通信  但是不能很好处理高并发情况 只能传输Bundle支持的类型  常用于低并发的无RPC需求一对多的场合 </li>
<li>ContentProvider ：<br>在数据源访问方面功能强大 支持一对多并发操作 可扩展call方法  可以理解为约束版的AIDL  提供CRUD操作和自定义函数  常用于一对多的数据共享场合</li>
<li>Socket ：<br>功能强大 可以通过网络传输字节流 支持一对多并发操作  但是实现起来比较麻烦 不支持直接的RPC   常用于网络数据交换<br>总结起来  <br>当仅仅是跨进程的四大组件间的传递数据时 使用Bundle就可以  简单方便  <br>当要共享一个应用程序的内部数据的时候  使用ContentProvider实现比较方便  <br>当并发程度不高  也就是偶尔访问一次那种 进程间通信 用Messenger就可以  <br>当设计网络数据的共享时  使用socket <br>当需求比较复杂  高并发 并且还要求实时通信 而且有RPC需求时  就得使用AIDL了 <br>文件共享的方法用于一些缓存共享 之类的功能</li>
</ol>
<p>final 、finally、finalize 的区别</p>
<p>final</p>
<p>修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final修饰的变量，初始化后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。  </p>
<p>finally</p>
<p>异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。一般异常处理块需要。 </p>
<p>finalize</p>
<p>方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p>
<p>Java中所有类都从Object类中继承finalize()方法。</p>
<p>当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。值得C++程序员注意的是，finalize()方法并不能等同与析构函数。Java中是没有析构函数的。C++的析构函数是在对象消亡时运行的。由于C++没有垃圾回收，对象空间手动回收，所以一旦对象用不到时，程序员就应当把它delete()掉。所以析构函数中经常做一些文件保存之类的收尾工作。但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。</p>
<p>那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。</p>
<p>JAVA链表实现栈操作</p>
<p>public class Node { </p>
<p>Object element;</p>
<p>Node next; </p>
<p>public Node(Object element){</p>
<p>this(element,null);</p>
<p>} </p>
<p>/**</p>
<ul>
<li><p>创建一个新的节点</p>
</li>
<li><p>让他的next指向，参数中的节点</p>
</li>
<li><p>@param element</p>
</li>
<li><p>@param n</p>
</li>
</ul>
<p>*/</p>
<p>public Node(Object element,Node n){</p>
<p>this.element=element;</p>
<p>next=n;</p>
<p>}</p>
<p>public Object getElement() {</p>
<p>return element;</p>
<p>}</p>
<p>}</p>
<p>public class ListStack {</p>
<p>Node header;//栈顶元素</p>
<p>int elementCount;//栈内元素个数</p>
<p>int size;//栈的大小</p>
<p>/**</p>
<ul>
<li>构造函数，构造一个空的栈</li>
</ul>
<p>*/</p>
<p>public ListStack(){</p>
<p>header=null;</p>
<p>elementCount=0;</p>
<p>size=0;</p>
<p>}</p>
<p>/**</p>
<ul>
<li><p>通过构造器自定义栈的大小</p>
</li>
<li><p>@param size</p>
</li>
</ul>
<p>*/</p>
<p>public ListStack(int size) {</p>
<p>header=null;</p>
<p>elementCount=0;</p>
<p>this.size=size;</p>
<p>} </p>
<p>public void push(Object value) { </p>
<p>//注意这里面试将原来的header作为参数传入，然后以新new出来的Node作为header</p>
<p>header=new Node(value, header);</p>
<p>elementCount++;</p>
<p>}</p>
<p>public Object pop() { </p>
<p>Object object=header.getElement(); </p>
<p>header=header.next; </p>
<p>elementCount–; </p>
<p>return object;</p>
<p>} </p>
<p>/**</p>
<ul>
<li>返回栈顶元素</li>
</ul>
<p>*/</p>
<p>public Object peak(){ </p>
<p>if (this.isEmpty()) {</p>
<p>throw new RuntimeException(&quot;Stack is empty&quot;);</p>
<p>} </p>
<p>return header.getElement();</p>
<p>}</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>面试宝典笔记</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>保存当前可视组件</p>
<p>View view = getLayoutInflater().inflate(R.layout.test,null);</p>
<p>view.setDrawingCacheEnabled(true)</p>
<p>view.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),</p>
<p>MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));</p>
<p>view.layout(0,0,view.getMeasuredWidth(),view.getMeasuredHeight());</p>
<p>bitmap.compress(CompressFormat.PNG,100,fos);</p>
<p>TextView 富文本</p>
<p>Html.fromHtml （ImageGetter.getDrawable）</p>
<p>SpannableString setSpan(ImageSpan) </p>
<p>ClickableSpan</p>
<p>BackgroundColorSpan</p>
<p>自定义XXSpan extends CharacterStyle</p>
<p>Button</p>
<p>button.layout 改变位置/大小</p>
<p>&lt;selector /&gt;  状态背景</p>
<p>&lt;transition /&gt; 淡入淡出效果</p>
<p>&lt;level-list /&gt; setImageLevel  资源级别</p>
<p>ImageView</p>
<p>Bitmap.createBitmap(sourceBitmap,20,20,100,100); 裁剪</p>
<p>ClipDrawable</p>
<p>Matrix matrix = new Matrix();</p>
<p>matrix.setRotate(45);</p>
<p>matrix.setScale(0.5f,0.5f);</p>
<p>Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,true);</p>
<p>ProgressBar</p>
<p>&lt;layer-list xmlns ..</p>
<p> &lt;item android:id=&quot;@android:id/background&quot; android:drawable=&quot;@drawable/bg&quot; /&gt;</p>
<p> &lt;item android:id=&quot;@android:id/secondaryProgress&quot; .. /&gt;</p>
<p> &lt;item android:id=&quot;@android:id/progress&quot; .. /&gt;</p>
<p>&gt;</p>
<p>android:progressDrawable</p>
<p>//动态加载class.dex</p>
<p>DexFile dexFile = dalvik.system.DexFile.loadDex(&quot;org.apk&quot;,&quot;tmp.apk&quot;,0);</p>
<p>Object obj = dexFile.loadClass(&quot;xxx.xx.xx&quot;,null).newInstance();</p>
<p>Method method = obj.getClass().getDeclaredMethod(&quot;xx&quot;,null);</p>
<p>method.invoke(obj,null)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>音标</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%9F%B3%E6%A0%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>音量修复</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%9F%B3%E9%87%8F%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p>frameworks/base/core/java/android/view/VolumePanel.java</p>
<p>— a/frameworks/base/core/java/android/view/VolumePanel.java</p>
<p>+++ b/frameworks/base/core/java/android/view/VolumePanel.java</p>
<p>@@ -674,16 +674,29 @@ public class VolumePanel extends Handler implements OnSeek</p>
<p>             if (mAudioManager.getStreamVolume(sc.streamType) != progress) {</p>
<p>                 mAudioManager.setStreamVolume(sc.streamType, progress, 0);</p>
<p>             }</p>
<p>+</p>
<ul>
<li>                      updateSlider(sc);//edward</li>
</ul>
<p>+</p>
<p>         }</p>
<p>         resetTimeout();</p>
<p>     }</p>
<p>     public void onStartTrackingTouch(SeekBar seekBar) {</p>
<ul>
<li>   }</li>
</ul>
<ul>
<li><p>              mAudioManager.adjustSuggestedStreamVolume(//edward</p>
</li>
<li><p>       AudioManager.ADJUST_RAISE,</p>
</li>
<li><p>       AudioManager.USE_DEFAULT_STREAM_TYPE,</p>
</li>
<li><p>      AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);</p>
</li>
<li><p>       }</p>
</li>
</ul>
<p>     public void onStopTrackingTouch(SeekBar seekBar) {</p>
<ul>
<li>   }</li>
</ul>
<p>-</p>
<ul>
<li><p>              if(seekBar.getProgress()==0){//edward</p>
</li>
<li><p>       mAudioManager.adjustSuggestedStreamVolume(</p>
</li>
<li><p>       AudioManager.ADJUST_LOWER,</p>
</li>
<li><p>       AudioManager.USE_DEFAULT_STREAM_TYPE,</p>
</li>
<li><p>       AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE)</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>       }</p>
</li>
<li><p>      }</p>
</li>
</ul>
<p>     public void onClick(View v) {</p>
<p>         if (v == mMoreButton) {</p>
<p>             expand();</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>音量大小</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%9F%B3%E9%87%8F%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>— a/frameworks/base/media/java/android/media/AudioManager.java</p>
<p>+++ b/frameworks/base/media/java/android/media/AudioManager.java</p>
<p>@@ -225,7 +225,7 @@ public class AudioManager {</p>
<p>         4,  // STREAM_VOICE_CALL</p>
<p>         7,  // STREAM_SYSTEM</p>
<p>         5,  // STREAM_RING</p>
<ul>
<li>       11, // STREAM_MUSIC</li>
</ul>
<ul>
<li>       7, // STREAM_MUSIC</li>
</ul>
<p>         6,  // STREAM_ALARM</p>
<p>         5,  // STREAM_NOTIFICATION</p>
<p>         7,  // STREAM_BLUETOOTH_SCO</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>驱动基础</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>dev_t –&gt; unsigned int  //32位整数</p>
<p>高12位为主设备号，低20位为次设备号</p>
<p>获取主、次设备号</p>
<p>MAJOR(dev_t dev);</p>
<p>MANOR(dev_t dev);</p>
<p>从inode获取主次设备号</p>
<p>unsigned int imajor(struct inode *inode)</p>
<p>unsigned int iminor(struct inode *inode)</p>
<p>生成设备号</p>
<p>MKDEV(int major,int minor);</p>
<p>申请主设备号：</p>
<p>int  register_chrdev (major, name,&amp;fops);(老)</p>
<p>major = MKDEV(major,0);原型：register_chrdev_region (major,count,name)(新)</p>
<p>major为0时，动态申请</p>
<p>//创建设备节点</p>
<p>手工：mknod filename type major minor</p>
<p>mknod led c 100 0</p>
<p>自动创建：</p>
<p>hello_class =class_create(THIS_MODULE, &quot;hello_class&quot;);</p>
<p>class_device_create(hello_class, NULL, MKDEV(hello_major,0), NULL, &quot;hello&quot;);</p>
<p>在 linux2.6 内核中，字符设备使用 struct cdev 结构来描</p>
<p>struct cdev {</p>
<p>struct kobject kobj;   / * 内嵌的 kobject 对象 * /</p>
<p>struct module  * owner; / * 所属模块 * /</p>
<p>const struct file_operations  * ops; / * 文件操作结构体 * /</p>
<p>struct list_head list;</p>
<p>dev_t dev; / * 设备号 * /</p>
<p>unsigned int count;</p>
<p>};</p>
<p>字条设备注册：</p>
<p>1.struct cdev *cdev_alloc(void) //静态的不需要分配</p>
<p>2.void cdev_init(struct cdev *cdev,const struct file_operations *fops);</p>
<p>3.int cdev_add(struct cdev *p,dev_t dev,unsigned count)</p>
<p>include/linux/fs.h</p>
<p>struct inode {</p>
<p>           ……</p>
<p>dev_t  i_rdev; // 包含真正的设备编号</p>
<p>struct  cdev   * i_cdev; // 指向 cdev 结构的指针</p>
<p>……</p>
<p>};</p>
<p>struct file {</p>
<p>mode_t  f_mode; //权限</p>
<p>loff_t   f_ops; //当前读/写位置</p>
<p>unsigned int  f_flags; </p>
<p>struct  file_operations //与文件相关操作</p>
<p>void   * private_data;</p>
<p>struct  dentry    * f_dentry;</p>
<p>};</p>
<p>struct file_operations {</p>
<p>struct module  * owner;</p>
<p>loff_t ( * llseek) (struct file  * , loff_t, int);</p>
<p>ssize_t ( * read) (struct file  * , char __user  * , size_t, loff_t  * );</p>
<p>ssize_t ( * write) (struct file  * , const char __user  * , size_t, loff_t  * )</p>
<p>unsigned int ( * poll) (struct file  * , struct poll_table_struct  * );</p>
<p>int ( * ioctl) (struct inode  * , struct file  * , unsigned int, unsigned lo</p>
<p>int ( * mmap) (struct file  * , struct vm_area_struct  * );</p>
<p>int ( * open) (struct inode  * , struct file  * );</p>
<p>int ( * release) (struct inode  * , struct file  * );</p>
<p>int ( * fsync) (struct file  * , struct dentry  * , int datasync);</p>
<p>……</p>
<p>};</p>
<p>static inline unsigned long __must_check </p>
<p>copy_from_user(void *to, const void __user *from, unsigned long n)</p>
<p>static inline unsigned long __must_check </p>
<p>copy_to_user(void __user *to, const void *from, unsigned long n)</p>
<p>static unsigned int hello_major =0;</p>
<p>static struct class *hello_class =NULL</p>
<p>static int hello_open(struct inode *inode , struct file *file</p>
<p>struct file_operations hello_fops ={</p>
<p>.owner= THIS_MODULE,</p>
<p>.open =hello_open,</p>
<p>}</p>
<p>/<em>1.实现模块加载函数,insmod hello.ko</em>/</p>
<p>static int __init hello_init(void)</p>
<p>{</p>
<p>printk(&quot;hello init!\n&quot;);</p>
<p>/<em>1.静态方式申请主设备号</em>/</p>
<p>//register_chrdev(hello_major, &quot;hello&quot;, &amp;hello_fops);</p>
<p>/<em>2.动态申请主设备号</em>/</p>
<p>hello_major =register_chrdev(0, &quot;hello&quot;,  &amp;hello_fops);</p>
<p>/<em>3.自动创建设备节点</em>/</p>
<p>/*3.1 首先要创建一个类,为vfs构建一些信心,mdev这个根据这些信息帮我们</p>
<p>创建一个设备节点*/</p>
<p>hello_class =class_create(THIS_MODULE, &quot;hello_class&quot;);</p>
<p>/<em>3.2 在这个类下创建一个设备节点</em>/</p>
<p>class_device_create(hello_class, NULL, MKDEV(hello_major,0), NULL, &quot;hello&quot;);</p>
<p>return 0;</p>
<p>}</p>
<p>/<em>2.实现模块卸载函数,rmmod hello就会调用hello_exit</em>/</p>
<p>static void __exit hello_exit(void)</p>
<p>{</p>
<p>printk(&quot;hello exit!\n&quot;);</p>
<p>/<em>释放资源</em>/</p>
<p>unregister_chrdev(hello_major, &quot;hello&quot;);</p>
<p>class_device_destroy(hello_class,  MKDEV(hello_major,0));</p>
<p>class_destroy(hello_class);</p>
<p>}</p>
<p>module_init(hello_init);</p>
<p>module_exit(hello_exit);</p>
<p>/<em>3.模块许可申明</em>/</p>
<p>MODULE_LICENSE(&quot;GPL&quot;)</p>
<p>获取内存区（kmalloc分配物理内存）</p>
<p>Buffer</p>
<p>DMA buffer</p>
<p>ioport和iomem映射及使用</p>
<p>用户静态映射(iodesc，iomap)</p>
<p>动态映射(ioremap)</p>
<p>原子操作指的是在执行过程中不会被别的代码路径所中断的操作</p>
<p>atomic_t v = ATOMIC_INIT(0); //定义原子变量v并初始化为0</p>
<p>atomic_read(atomic_t *v);   //返回原子变量的值</p>
<p>void atomic_inc(atomic_t *v);    //原子变量增加1</p>
<p>void atomic_dec(atomic_t *v);    //原子变量减少1</p>
<p>int atomic_dec_and_test(atomic_t *v); </p>
<p>自旋锁（spin lock）是一种对临界资源进行互斥手访问的典型手段</p>
<p>spinlock_t spin; //1．定义自旋锁</p>
<p>spin_lock_init(lock)//2．初始化自旋锁</p>
<p>//该宏用于获得自旋锁lock，如果能够立即获得锁，它就马上返回，否则，它将自旋</p>
<p>//在那里，直到该自旋锁的保持者释放；</p>
<p>spin_lock(lock) //3．获得自旋锁</p>
<p>//该宏尝试获得自旋锁lock，如果能立即获得锁，它获得锁并返回真，</p>
<p>//否则立即返回假，实际上不再“在原地打转”；</p>
<p>spin_trylock(lock)</p>
<p>//该宏释放自旋锁lock，它与spin_trylock或spin_lock配对使用。</p>
<p>spin_unlock(lock)//4．释放自旋锁</p>
<p>//信号量：</p>
<p>struct semaphore sem;//定义信号量</p>
<p>//初始化信号量</p>
<p>void sema_init (struct semaphore *sem, int val);</p>
<p>void init_MUTEX(struct semaphore *sem);//初始化为1</p>
<p>//获得信号量</p>
<p>void down(struct semaphore * sem);</p>
<p>int down_interruptible(struct semaphore * sem); </p>
<p>int down_trylock(struct semaphore * sem);</p>
<p>//释放信号量</p>
<p>void up(struct semaphore * sem);</p>
<p>static volatile unsigned long *gpfcon =NULL;</p>
<p>static volatile unsigned long *gpfdat =NULL;</p>
<p>gpfcon =ioremap(0x56000050, 8);</p>
<p>gpfdat =gpfcon +1;</p>
<p>int request_irq(unsigned int irq, irq_handler_t handler,</p>
<p>unsigned long irqflags, const char *devname, void *dev_id)</p>
<p>s3c2410_gpio_cfgpin(S3C2410_GPE11,S3C2410_GPE11_OUTP);</p>
<p>s3c2410_gpio_setpin(S3C2410_GPE11, 0)</p>
<p>s3c2410_gpio_getpin</p>
<p>阻塞：</p>
<p>1.DECLARE_WAIT_QUEUE_HEAD(buttons_wq);</p>
<p>2.wait_event_interruptible(buttons_wq, key);</p>
<p>3.唤醒：wake_up_interruptible(&amp;buttons_wq);</p>
<p>poll机制：</p>
<p>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</p>
<p>struct pollfd {</p>
<p>   int   fd;         /<em>要查询的设备文件描述符</em>/</p>
<p>   short events;     /<em>要查询的事件</em>/</p>
<p>};</p>
<p>1.DECLARE_WAIT_QUEUE_HEAD(buttons_wq);</p>
<ol start="2">
<li>.poll  = buttons_poll,</li>
</ol>
<p>static int buttons_poll (struct file *file, struct poll_table_struct *wait)</p>
<p>poll_wait(file, &amp;buttons_wq, wait);</p>
<p>fasync异步通知</p>
<p>应用层：</p>
<p>1.设置为异步通知模式</p>
<p>int fcntl(int fd, int cmd, … /* arg */ );</p>
<p>F_GETFL (void)  Read the file status flags; arg is ignored./<em>设置文件标识,标识为异步通知的模式</em>/</p>
<p>F_SETFL /<em>设置为模式</em>/</p>
<p>F_SETOWN   /<em>设置拥有者</em>/</p>
<p>fcntl(fd,F_GETFL)</p>
<p>2.将信号与信号处理函数绑定</p>
<p>signal(SIGIO,signal_function);</p>
<p>3.实现信号处理函数</p>
<ol start="4">
<li>设置谁发的问题,设置信号有本进程拥有</li>
</ol>
<p>   fcntl(fd,F_SETOWN,getpid());</p>
<p>驱动层：</p>
<p>1.struct fasync_struct   *button_fasync</p>
<ol start="2">
<li>.fasync =buttons_fasync,</li>
</ol>
<p>static int buttons_fasync (int fd, struct file *file, int on)</p>
<p>{fasync_helper(fd, file, on,&amp;button_fasync);//开启异步通知}</p>
<p>3.kill_fasync(&amp;button_fasync, SIGIO, POLLIN) //发送信号</p>
<p>//定时器</p>
<p>1.static struct timer_list buttons_timer;</p>
<p>2.init_timer(&amp;buttons_timer);</p>
<p>3.</p>
<p>buttons_timer.function = buttons_timer_function;//指定处理函数</p>
<p>buttons_timer.expires =jiffies + 5; //50ms</p>
<p>add_timer(&amp;buttons_timer) // 告诉内核</p>
<p>4.mod_timer(&amp;buttons_timer, jiffies + 5) //重新赋值</p>
<p>5.static void buttons_timer_function(unsigned long data)//实现处理函数</p>
<p>//linux下中断流程：</p>
<p>按下按键-&gt;跳入中断向量表-&gt;vector_irq-&gt;保存部分现场</p>
<p>-&gt; 调用中断处理程序irq_handler</p>
<p>  -&gt;调用总的中断入口函数asm_do_IRQ(开始进入C语言部分)</p>
<p>在include/linux/irq.h文件中的</p>
<p>struct irq_desc  </p>
<p>{</p>
<p>irq_flow_handler_t handle_irq;   //当前中断的处理函数</p>
<p>struct irq_chip *chip; //底层的硬件访问(设置中断促发方式,使能中断)</p>
<p>struct irqaction <em>action; /</em> IRQ action list */</p>
<p>unsigned int status; /* IRQ status */</p>
<p>} ____cacheline_internodealigned_in_smp;</p>
<p>include/linux/interrupt.h</p>
<p>request_irq(中断号,中断服务程序,中断标号,名字,id号)</p>
<p>struct irqaction {</p>
<p>irq_handler_t handler;   /<em>中断服务程序(就是我们自己写的buttons_irq)</em>/</p>
<p>unsigned long flags;     /<em>中断标号(促发方式)</em>/</p>
<p>const char *name;       /<em>中断名字</em>/</p>
<p>void *dev_id; /<em>中断id</em>/</p>
<p>struct irqaction *next; /<em>说明可能有多个irqaction</em>/ </p>
<p>int irq; /<em>中断号</em>/</p>
<p>struct proc_dir_entry *dir;</p>
<p>};</p>
<p>中断下半部分</p>
<p>tasklet:</p>
<p>1.DECLARE_TASKLET(buttons_tasklet, buttons_tasklet_func, 0)</p>
<p>2.static void buttons_tasklet_func(unsigned long data)</p>
<p>3.tasklet_schedule(&amp;buttons_tasklet);//在中断上半部分告诉内核</p>
<p>work queue:</p>
<p>1.struct work_struct buttons_work;</p>
<p>2.INIT_WORK(&amp;buttons_work, (void (*)(void *))buttons_work_func);</p>
<p>3.static void buttons_work_func(unsigned long data)</p>
<p>4.schedule_work(&amp;buttons_work); //告诉内核</p>
<p>//设备资源层：</p>
<p>//linux/arch/arm/plat-s3c24xx/devs.c</p>
<p>//Base S3C24XX platform device definitions</p>
<p>//描述资源的结构体</p>
<p>struct resource {</p>
<p>resource_size_t start;//IO资源的实际地址</p>
<p>resource_size_t end;</p>
<p>const char *name;</p>
<p>unsigned long flags;//IORESOURCE_MEM/IORESOURCE_IRQ</p>
<p>   //IORESOURCE_IO /IORESOURCE_DMA</p>
<p>struct resource *parent, *sibling, *child;</p>
<p>};//linux/ioport.h</p>
<p>//用于平台设备驱动机制的平台设备结构体</p>
<p>struct platform_device </p>
<p>{</p>
<p>const char * name;</p>
<p>u32 id;</p>
<p>struct device dev;</p>
<p>u32 num_resources;</p>
<p>struct resource * resource;</p>
<p>};//linux/platform_device.h</p>
<p>// add a numbers of platform devices</p>
<p>int platform_add_devices(struct platform_device **devs, int num)</p>
<p>// add a platform-level devic</p>
<p>int platform_device_register(struct platform_device * pdev)</p>
<p>{</p>
<p>//设备属性的初始化</p>
<p>device_initialize(&amp;pdev-&gt;dev);</p>
<p>//将设备添加到Platfrom中 /add a platform device to device hierarchy</p>
<p>return platform_device_add(pdev);</p>
<p>}</p>
<p>// add device to device hierarchy.</p>
<p>int device_add(struct device *dev)</p>
<p>//add device to bus</p>
<p>void bus_attach_device(struct device * dev)</p>
<p>//driver iterator</p>
<p>int bus_for_each_drv(struct bus_type * bus, struct device_driver * start,</p>
<p>    void * data, int (*fn)(struct device_driver *, void *))</p>
<p>//attempt to bind device &amp; driver together</p>
<p>int driver_probe_device(struct device_driver * drv, struct device * dev)</p>
<p>–&gt; really_probe</p>
<p>  –&gt; dev-&gt;bus-&gt;probe</p>
<p>/<em>重要结构体及重要函数的分析</em>/</p>
<p>struct bus_type platform_bus_type = {</p>
<p>.name = &quot;platform&quot;,</p>
<p>        …</p>
<p>.match = platform_match,  </p>
<p>}</p>
<p>// bind platform device to platform driver.</p>
<p>static int platform_match(struct device * dev, struct device_driver * drv)</p>
<p>{</p>
<p>  struct platform_device *pdev = container_of(dev, struct platform_device, dev);</p>
<p>/<em>按名字匹配,名字相同的就调用probe函数</em>/</p>
<p>  return (strncmp(pdev-&gt;name, drv-&gt;name, BUS_ID_SIZE) == 0);</p>
<p>}</p>
<p>struct platform_driver {</p>
<p>int (*probe)(struct platform_device *);</p>
<p>int (*remove)(struct platform_device *);</p>
<p>void (*shutdown)(struct platform_device *);</p>
<p>int (*suspend)(struct platform_device *, pm_message_t state);</p>
<p>int (*suspend_late)(struct platform_device *, pm_message_t state);</p>
<p>int (*resume_early)(struct platform_device *);</p>
<p>int (*resume)(struct platform_device *);</p>
<p>struct device_driver driver;</p>
<p>};</p>
<p>int platform_driver_register(struct platform_driver *drv)</p>
<p>{</p>
<p>drv-&gt;driver.bus = &amp;platform_bus_type;</p>
<p>if (drv-&gt;probe)</p>
<p>drv-&gt;driver.probe = platform_drv_probe;</p>
<p>if (drv-&gt;remove)</p>
<p>drv-&gt;driver.remove = platform_drv_remove;</p>
<p>if (drv-&gt;shutdown)</p>
<p>drv-&gt;driver.shutdown = platform_drv_shutdown;</p>
<p>if (drv-&gt;suspend)</p>
<p>drv-&gt;driver.suspend = platform_drv_suspend;</p>
<p>if (drv-&gt;resume)</p>
<p>drv-&gt;driver.resume = platform_drv_resume;</p>
<p>return driver_register(&amp;drv-&gt;driver);</p>
<p>}</p>
<p>//运用平台设备驱动机制：</p>
<ol>
<li>struct platform_driver my_drv</li>
</ol>
<p>.probe = my_probe,</p>
<p>…</p>
<p>}</p>
<p>2.static int my_probe(struct platform_device *pdev)</p>
<p>{</p>
<p> res = platform_get_resource(struct platform_device *dev, unsigned int type,</p>
<p>     unsigned int num)</p>
<p>…</p>
<p>}</p>
<p>3.int platform_driver_register(struct platform_driver *drv)</p>
<p>void platform_driver_unregister(struct platform_driver *drv)</p>
<p>I2C(Inter-Integrated Circuit)  PHILIPS 串行总线，用于连接微控制器及外围设备</p>
<p>串行数据线:SDA  串行时钟线:SCL</p>
<p>半双工</p>
<p>低速模式100k/s 全速模式:400k/s 高速模式:3.4M/s</p>
<p>同一总线上IC数量只受到最大电容400pF的限制</p>
<p>先传高位再传低位</p>
<p>仲裁：用于多主机，通过仲裁只有一个主机获得总线控制权</p>
<p>开始信号(S): SCL高，SDA 高-&gt;低</p>
<p>结束信号(p): SCL高，SDA 低-&gt;高</p>
<p>响应信号(ACK): 接收8位数据后，在第9个时钟周期，拉低SDA</p>
<p>SDA线上的数据,必须在SCL为高电平周期保持稳定，只能在SCL为低电平期间变化。</p>
<p>IICCON: 控制，ACK全能，时钟，分频，中断全能等</p>
<p>//IICCON[4] 写0清除中断标记，才会发出P信号</p>
<p>IICSTAT:状态，工作模式、仲裁，输出使能、 S/P状态等  </p>
<p>//IICSTAT[4]为0时方可写入：</p>
<p>IICADD(从机地址)  IICDS(保存发送/接收的数据)</p>
<p>I2C子系统分2个层次：</p>
<p>1.I2C设备驱动层(drivers/i2c/chips)</p>
<p>2.I2C总线驱动层(drivers/i2c/busses/i2c-s3c2410.c)</p>
<p>LCD(Liquid Crystal Display) 液晶显示器</p>
<p>总类：</p>
<p>STN(Super Twisted Nematic) 超扭曲向列</p>
<p>TFT(Thin Film Transistor) 薄膜晶体管</p>
<p>LTPS(Low Temperature Polycrystalline Silicon) 低温多晶硅</p>
<p>OLED(Organic Light Emitting Diode) 有机发光二极管</p>
<p>VSYNC: 垂直同步信号</p>
<p>HSYNC: 水平同步信号</p>
<p>VD[23:0]: 数据信号</p>
<p>LEND : 行结束信号</p>
<p>PWREN: 电源开关信号</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>驱动总结</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%A9%B1%E5%8A%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>lvds mipi 等接口，配置，信号区别，<br>framework 定制，具体到类，方法<br>中断函数的步骤<br>屏，tp等的兼容<br>屏闪怎么调<br><a href="http://m.blog.csdn.net/u014770862">http://m.blog.csdn.net/u014770862</a></p>
<p>USB怎么识别device 还是 host？</p>
<p>USB ID引脚被拉低的是主设备<br>相同I2C地址的设备，注册时可以用不同的地址，驱动中的I2C地址直接指定。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>麦库截图20181706174259208</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%BA%A6%E5%BA%93%E6%88%AA%E5%9B%BE20181706174259208/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>麦库截图20181706174306967</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%BA%A6%E5%BA%93%E6%88%AA%E5%9B%BE20181706174306967/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>默认壁纸 动态壁纸</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%BB%98%E8%AE%A4%E5%A3%81%E7%BA%B8%20%E5%8A%A8%E6%80%81%E5%A3%81%E7%BA%B8/</url>
    <content><![CDATA[<p>默认壁纸：</p>
<p> device/rockchip/rk30sdk/overlay/frameworks/base/core/res/res/drawable-****/default_wallpaper.jpg</p>
<p>Launcher中添加壁纸：</p>
<p>壁纸列表：</p>
<p>packages/apps/Launcher2/res/values/wallpapers.xml</p>
<p>添加图片：</p>
<p>packages/apps/Launcher2/res/drawable-**<em>/wallpaper</em>.jpg</p>
<p>默认动态壁纸：PhaseBeam.apk</p>
<p>device/rockchip/rk30sdk/overlay/frameworks/base/core/res/res/values/config.xml</p>
<p>&lt;string name=&quot;default_wallpaper_component&quot; translatable=&quot;false&quot;&gt;com.android.phasebeam/com.android.phasebeam.PhaseBeamWallpaper&lt;/string&gt;</p>
<p>查看方式：</p>
<p>cat /data/system/wallpaper_info.xml</p>
<p>adb shell dumpsys wallpaper</p>
<p>packages/wallpapers</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>默认字体大小fontScale</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%BB%98%E8%AE%A4%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8FfontScale/</url>
    <content><![CDATA[<p>1.可以直接修改Configuration</p>
<p> frameworks/base/core/java/android/content/res/Configuration.java</p>
<p>public void setToDefaults() {</p>
<p>fontScale = 1;  //0.85f /1/1.15f/1.3f</p>
<p>2.在配置中设置</p>
<p>ro.default.size=100   //85 /100/ 115/130</p>
<p>在system/build.prop中，rk已经在安装app后对默认字体作了设置</p>
<p>如下：</p>
<p>private void settingLargeSysFont() {</p>
<p>        try {</p>
<p>Configuration mCurConfig = new Configuration();</p>
<p>            try {</p>
<p>               mCurConfig.updateFrom(ActivityManagerNative.getDefault().getConfiguration());</p>
<p>                   } catch (RemoteException re) {</p>
<p>               /* ignore */</p>
<p>            }</p>
<p>int i = SystemProperties.getInt(&quot;ro.default.size&quot;,100);</p>
<p> mCurConfig.fontScale=(i*0.01f); </p>
<p>//    mCurConfig.fontScale = 1.3f ;  0.85/1/1.15./1.3</p>
<p>            ActivityManagerNative.getDefault().updatePersistentConfiguration(mCurConfig);</p>
<p>                   } catch (RemoteException re) {</p>
<p>            /* ignore */</p>
<p>            }</p>
<p>    }</p>
<p>}</p>
<p>//setting/src/com/android/setting/displaysettings.java</p>
<p>在setting操作如下：</p>
<p>    public void writeFontSizePreference(Object objValue) {</p>
<p>        try {</p>
<p>            mCurConfig.fontScale = Float.parseFloat(objValue.toString());</p>
<p>            ActivityManagerNative.getDefault().updatePersistentConfiguration(mCurConfig);</p>
<p>        } catch (RemoteException e) {</p>
<p>            Log.w(TAG, &quot;Unable to save font size&quot;);</p>
<p>        }</p>
<p>    }.</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>默认打开adb</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80adb/</url>
    <content><![CDATA[<p>persist.service.adb.enable=1</p>
<p>build.prop</p>
<p>persist.sys.usb.config=mass_storage,adb</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>默认打开方式filter</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8Ffilter/</url>
    <content><![CDATA[<p>IntentFilter filter = new IntentFilter();     filter.addAction(Intent.ACTION_MEDIA_MOUNTED);    filter.addAction(Intent.ACTION_MEDIA_UNMOUNTED);    </p>
<p>scheme://host:port/path      模式://主机:端口/路径</p>
<p>filter.addDataScheme(&quot;file&quot;);</p>
<p>filter.addDataPath(&quot;mnt/sdcard&quot;, PatternMatcher.PATTERN_LITERAL);  </p>
<p>filter.addDataType(&quot;text/*&quot;);  </p>
<p>// 没验证的</p>
<p>PackageManager pm = getPackageManager();<br>    IntentFilter filter = new IntentFilter();<br>    filter.addCategory(&quot;android.intent.category.DEFAULT&quot;);<br>    ComponentName component = new ComponentName(&quot;YourClearAppPakageName&quot;, &quot;YourClearAppClassName&quot;);<br>    ComponentName[] components = new ComponentName[] {new ComponentName(&quot;YourPreferAppPakageName&quot;, &quot;YourPreferAppClassName&quot;), component};<br>    pm.clearPackagePreferredActivities(&quot;YourClearAppPakageName&quot;);<br>    pm.addPreferredActivity(filter, IntentFilter.MATCH_CATEGORY_EMPTY, components, component); </p>
<p>PackageManager pm = getPackageManager();</p>
<p>    IntentFilter filter = new IntentFilter();</p>
<p>    filter.addAction(&quot;android.intent.action.VIEW&quot;);</p>
<p>    filter.addCategory(&quot;android.intent.category.DEFAULT&quot;);</p>
<p>    //filter.addDataScheme(&quot;file&quot;);</p>
<p>   try{</p>
<p>    filter.addDataType(&quot;application/pdf&quot;);</p>
<p>    }catch(Exception e){}</p>
<p>    ComponentName component = new ComponentName(&quot;com.adobe.reader&quot;, &quot;com.adobe.reader.AdobeReader&quot;);</p>
<p>    ComponentName[] components = new ComponentName[] {new ComponentName(&quot;com.android.rk&quot;, &quot;com.android.rk.RockExplorer&quot;), component};</p>
<p>   /pm.clearPackagePreferredActivities(&quot;YourClearAppPakageName&quot;);</p>
<p>    pm.addPreferredActivity(filter, IntentFilter.MATCH_CATEGORY_EMPTY, components, component);</p>
<p>&lt;uses-permission android:name=&quot;android.permission.SET_PREFERRED_APPLICATIONS&quot; /&gt;</p>
<p>vi frameworks/base/services/java/com/android/server/pm/PackageManagerService.java</p>
<p> public void addPreferredActivity(IntentFilter filter, int match,</p>
<p>            ComponentName[] set, ComponentName activity) {</p>
<p>        // writer</p>
<p>        synchronized (mPackages) {</p>
<p>            if (mContext.checkCallingOrSelfPermission(</p>
<p>                    android.Manifest.permission.SET_PREFERRED_APPLICATIONS)</p>
<p>                    != PackageManager.PERMISSION_GRANTED) {</p>
<p>                if (getUidTargetSdkVersionLockedLPr(Binder.getCallingUid())</p>
<p>                        &lt; Build.VERSION_CODES.FROYO) {</p>
<p>                    Slog.w(TAG, &quot;Ignoring addPreferredActivity() from uid &quot;</p>
<p>                            + Binder.getCallingUid());</p>
<p>                    return;</p>
<p>                }</p>
<p>                mContext.enforceCallingOrSelfPermission(</p>
<p>                        android.Manifest.permission.SET_PREFERRED_APPLICATIONS, null);</p>
<p>            }</p>
<p>            Slog.i(TAG, &quot;Adding preferred activity &quot; + activity + &quot;:&quot;);</p>
<p>            filter.dump(new LogPrinter(Log.INFO, TAG), &quot;  &quot;);</p>
<p>            mSettings.mPreferredActivities.addFilter(</p>
<p>                    new PreferredActivity(filter, match, set, activity));</p>
<p>            scheduleWriteSettingsLocked();</p>
<p>        }</p>
<p>    }</p>
<p><a href="http://developer.android.com/reference/android/content/IntentFilter.html">http://developer.android.com/reference/android/content/IntentFilter.html</a></p>
<p>/data/system/packages.xml</p>
<p>&lt;preferred-activities&gt;</p>
<p>&lt;item name=&quot;com.adobe.reader/.AdobeReader&quot; match=&quot;600000&quot; set=&quot;2&quot;&gt;</p>
<p>&lt;set name=&quot;com.adobe.reader/.AdobeReader&quot; /&gt;</p>
<p>&lt;set name=&quot;com.dataviz.docstogo/com.dataviz.dxtg.ptg.android.PDFToGoActivity&quot; /&gt;</p>
<p>&lt;filter&gt;</p>
<p>&lt;action name=&quot;android.intent.action.VIEW&quot; /&gt;</p>
<p>&lt;cat name=&quot;android.intent.category.DEFAULT&quot; /&gt;</p>
<p>&lt;type name=&quot;application/pdf&quot; /&gt;</p>
<p>&lt;/filter&gt;</p>
<p>&lt;/item&gt;</p>
<p>&lt;/preferred-activities&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>默认无解锁</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%BB%98%E8%AE%A4%E6%97%A0%E8%A7%A3%E9%94%81/</url>
    <content><![CDATA[<p> frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\KeyguardViewMediator.java</p>
<p>   /**</p>
<p>     * External apps (like the phone app) can tell us to disable the keygaurd.</p>
<p>     */</p>
<p>    private boolean mExternallyEnabled = false;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>默认键盘</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%BB%98%E8%AE%A4%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p>\packages\apps\Settings\src\com\android\settings\inputmethod\InputMethodAndLanguageSettings.java</p>
<p>    private void updateHardKeyboards() {</p>
<p>        mHardKeyboardPreferenceList.clear();</p>
<p>        if (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_QWERTY) {</p>
<p>            final int[] devices = InputDevice.getDeviceIds();</p>
<p>            for (int i = 0; i &lt; devices.length; i++) {</p>
<p>                InputDevice device = InputDevice.getDevice(devices[i]);</p>
<p>                if (device != null</p>
<p>                        &amp;&amp; !device.isVirtual()</p>
<p>                        &amp;&amp; device.isFullKeyboard()) {</p>
<p>                    final String inputDeviceDescriptor = device.getDescriptor();</p>
<p>                    final String keyboardLayoutDescriptor =</p>
<p>                            mIm.getCurrentKeyboardLayoutForInputDevice(inputDeviceDescriptor);</p>
<p>                    final KeyboardLayout keyboardLayout = keyboardLayoutDescriptor != null ?</p>
<p>                            mIm.getKeyboardLayout(keyboardLayoutDescriptor) : null;</p>
<p>                    Log.d(LOG_TAG, &quot; inputDeviceDescriptor : &quot; + inputDeviceDescriptor);</p>
<p>                    final PreferenceScreen pref = new PreferenceScreen(getActivity(), null);</p>
<p>                    pref.setTitle(device.getName());</p>
<p>                    if (keyboardLayout != null) {</p>
<p>                        pref.setSummary(keyboardLayout.toString());</p>
<p>                    } else {</p>
<p>  String defaultKeyboardLayoutDescriptor = &quot;com.android.inputdevices/com.android.inputdevices.InputDeviceReceiver/keyboard_layout_spanish&quot;;</p>
<p>                      KeyboardLayout defaultKeyboardLayout;</p>
<p>                      mIm.addKeyboardLayoutForInputDevice(inputDeviceDescriptor,</p>
<p>                            defaultKeyboardLayoutDescriptor);</p>
<p>                         defaultKeyboardLayout = mIm.getKeyboardLayout(defaultKeyboardLayoutDescriptor);</p>
<p>                         if(defaultKeyboardLayout != null)</p>
<p>                           pref.setSummary(defaultKeyboardLayout.toString());</p>
<p>                        //pref.setSummary(R.string.keyboard_layout_default_label);</p>
<p>                    }</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>5</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/5.1%20%E5%BC%80%E5%85%B3%E6%9C%BA%E5%8A%A8%E7%94%BB%EF%BC%8C%E9%93%83%E5%A3%B0/</url>
    <content><![CDATA[<p>diff –git a/cmds/bootanimation/BootAnimation.cpp b/cmds/bootanimation/BootAnimation.cpp</p>
<p>index df87c26..6a183c4 100644</p>
<p>— a/cmds/bootanimation/BootAnimation.cpp</p>
<p>+++ b/cmds/bootanimation/BootAnimation.cpp</p>
<p>@@ -60,13 +60,15 @@</p>
<p> #include &quot;BootAnimation.h&quot;</p>
<p> #include &quot;AudioPlayer.h&quot;</p>
<p> #include &lt;media/mediaplayer.h&gt;</p>
<p>+#include &lt;media/AudioSystem.h&gt;</p>
<p>+#include &lt;media/IMediaHTTPService.h&gt;</p>
<p> #define OEM_BOOTANIMATION_FILE &quot;/oem/media/bootanimation.zip&quot;</p>
<p> #define SYSTEM_BOOTANIMATION_FILE &quot;/system/media/bootanimation.zip&quot;</p>
<p> #define SYSTEM_ENCRYPTED_BOOTANIMATION_FILE &quot;/system/media/bootanimation-encrypted.zip&quot;</p>
<p> #define EXIT_PROP_NAME &quot;service.bootanim.exit&quot;</p>
<p> #define FIXED_ONE 1</p>
<p>-</p>
<p>+#define BOOTMUSIC_FILE &quot;/system/media/audio/boot.ogg&quot;</p>
<p> #define USER_BOOTANIMATION_FILE &quot;/data/local/bootanimation.zip&quot;</p>
<p> #define USER_SHUTDOWN_ANIMATION_FILE &quot;/data/local/shutdownanimation.zip&quot;</p>
<p>@@ -103,7 +105,7 @@ BootAnimation::BootAnimation(bool shutdown) : Thread(false), mZip(NULL)</p>
<p>     status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;dinfo);</p>
<p>     ALOGD(&quot;DISPLAY,W-H: %d-%d, ori: %d&quot;, dinfo.w, dinfo.h, dinfo.orientation);</p>
<ul>
<li>   if (mShutdown) {</li>
</ul>
<ul>
<li>   if (0) {</li>
</ul>
<p>            bool vertical = </p>
<p>             dinfo.orientation == 0 </p>
<p>             || dinfo.orientation == 2 ;</p>
<p>@@ -298,7 +300,7 @@ status_t BootAnimation::readyToRun() {</p>
<p>     int curWidth = dinfo.w;</p>
<p>     int curHeight = dinfo.h;</p>
<ul>
<li>   if (mShutdown) {</li>
</ul>
<ul>
<li>   if (0) {</li>
</ul>
<p>            if (dinfo.orientation % 2 == 0) {</p>
<p>                    curWidth = dinfo.h;</p>
<p>                    curHeight = dinfo.w;</p>
<p>@@ -494,12 +496,27 @@ void BootAnimation::getTexCoordinate() {</p>
<p>        }</p>
<p> }</p>
<p>+void BootAnimation::playMusic()</p>
<p>+{</p>
<ul>
<li><p> sp&lt;MediaPlayer&gt; mp = new MediaPlayer();</p>
</li>
<li><p>   if ((0 == access(BOOTMUSIC_FILE, F_OK)) &amp;&amp; mp != NULL) {</p>
</li>
<li><p>       mp-&gt;setDataSource(NULL,BOOTMUSIC_FILE, NULL);</p>
</li>
<li><p>       mp-&gt;prepare();</p>
</li>
<li><p>       mp-&gt;start();</p>
</li>
<li><p>              ALOGE(&quot; play boot sounds: %s&quot;, BOOTMUSIC_FILE);</p>
</li>
<li><p>   }</p>
</li>
</ul>
<p>+}</p>
<p>+</p>
<p> bool BootAnimation::android()</p>
<p> {</p>
<p>     initTexture(&amp;mAndroid[0], mAssets, &quot;images/android-logo-mask.png&quot;); // texture_object_mask</p>
<p>     initTexture(&amp;mAndroid[1], mAssets, &quot;images/android-logo-shine.png&quot;);</p>
<p>     mBMPWidth = mTexWidth = mBMPHeight = mTexHeight = 1;</p>
<p>     getTexCoordinate();</p>
<ul>
<li><p>// to add startup music</p>
</li>
<li><p>   #ifdef BOOTMUSIC_FILE</p>
</li>
<li><p>   playMusic();</p>
</li>
<li><p>   #endif</p>
</li>
</ul>
<p>     // clear screen</p>
<p>     glShadeModel(GL_FLAT);</p>
<p>@@ -720,6 +737,9 @@ bool BootAnimation::readFile(const char* name, String8&amp; outString)</p>
<p> bool BootAnimation::movie()</p>
<p> {</p>
<p>     String8 desString;</p>
<ul>
<li><p>      #ifdef BOOTMUSIC_FILE</p>
</li>
<li><p>   playMusic();</p>
</li>
<li><p>   #endif</p>
</li>
</ul>
<p>     if (!readFile(&quot;desc.txt&quot;, desString)) {</p>
<p>         return false;</p>
<p>diff –git a/cmds/bootanimation/BootAnimation.h b/cmds/bootanimation/BootAnimation.h</p>
<p>index 5663dba..77a177e 100644</p>
<p>— a/cmds/bootanimation/BootAnimation.h</p>
<p>+++ b/cmds/bootanimation/BootAnimation.h</p>
<p>@@ -89,7 +89,7 @@ private:</p>
<p>     bool movie();</p>
<p>     void getTexCoordinate();</p>
<p>     void checkExit();</p>
<ul>
<li>   </li>
</ul>
<ul>
<li>   void playMusic();</li>
</ul>
<p>     /**</p>
<p>      * 返回给定 fd 的文件的大小.</p>
<p>      */</p>
<p>diff –git a/services/core/java/com/android/server/power/ShutdownThread.java b/services/core/java/com/android/server/pow</p>
<p>index e4a9b19..26c7af8 100644</p>
<p>— a/services/core/java/com/android/server/power/ShutdownThread.java</p>
<p>+++ b/services/core/java/com/android/server/power/ShutdownThread.java</p>
<p>@@ -46,9 +46,13 @@ import android.os.storage.IMountShutdownObserver;</p>
<p> import com.android.internal.telephony.ITelephony;</p>
<p> import com.android.server.pm.PackageManagerService;</p>
<p>-</p>
<p>+import android.os.ServiceManager;</p>
<p> import android.util.Log;</p>
<p>+import android.media.MediaPlayer;</p>
<p>+import java.io.File;</p>
<p>+import java.io.IOException;</p>
<p> import android.view.WindowManager;</p>
<p>+import android.view.IWindowManager;</p>
<p> public final class ShutdownThread extends Thread {</p>
<p>     // constants</p>
<p>@@ -78,7 +82,10 @@ public final class ShutdownThread extends Thread {</p>
<p>     // static instance of this thread</p>
<p>     private static final ShutdownThread sInstance = new ShutdownThread();</p>
<p>-</p>
<ul>
<li><p>      </p>
</li>
<li><p>      // if has Shutdown Animation set this to ture</p>
</li>
<li><p>   private static boolean mHasAnimation;</p>
</li>
<li><p>      </p>
</li>
</ul>
<p>     private static final AudioAttributes VIBRATION_ATTRIBUTES = new AudioAttributes.Builder()</p>
<p>             .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)</p>
<p>             .setUsage(AudioAttributes.USAGE_ASSISTANCE_SONIFICATION)</p>
<p>@@ -96,6 +103,22 @@ public final class ShutdownThread extends Thread {</p>
<p>     private ShutdownThread() {</p>
<p>     }</p>
<ul>
<li><p>   private static void playMusic() {</p>
</li>
<li><p>      MediaPlayer mp = new MediaPlayer();</p>
</li>
<li><p>      try {</p>
</li>
<li><p>              File file = new File(&quot;system/media/audio/shutdown.ogg&quot;);</p>
</li>
<li><p>              if (file.exists()) {</p>
</li>
<li><p>                  mp.setDataSource(&quot;system/media/audio/shutdown.ogg&quot;);</p>
</li>
<li><p>                  mp.prepare();</p>
</li>
<li><p>                  mp.start();</p>
</li>
<li><p>                      Log.d(&quot;edward&quot;,&quot;play shutdown.ogg&quot;);</p>
</li>
<li><p>              }</p>
</li>
<li><p>      }catch (IllegalArgumentException e) {</p>
</li>
<li><p>              e.printStackTrace();</p>
</li>
<li><p>      }catch (IOException e) {</p>
</li>
<li><p>              e.printStackTrace();</p>
</li>
<li><p>      }</p>
</li>
<li><p>   }</p>
</li>
</ul>
<p>     /**</p>
<p>      * Request a clean shutdown, waiting for subsystems to clean up their</p>
<p>@@ -108,6 +131,8 @@ public final class ShutdownThread extends Thread {</p>
<p>     public static void shutdown(final Context context, boolean confirm) {</p>
<p>         mReboot = false;</p>
<p>         mRebootSafeMode = false;</p>
<ul>
<li><p>              mHasAnimation = (new File(&quot;/system/media/shutdownanimation.zip&quot;).exists()</p>
</li>
<li><p>                           || new File(&quot;/data/local/shutdownanimation.zip&quot;).exists());</p>
</li>
</ul>
<p>         shutdownInner(context, confirm);</p>
<p>     }</p>
<p>@@ -132,6 +157,15 @@ public final class ShutdownThread extends Thread {</p>
<p>         Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior);</p>
<p>         if (confirm) {</p>
<ul>
<li><p>                          if (mHasAnimation) {</p>
</li>
<li><p>              try {</p>
</li>
<li><p>                    IWindowManager wm = IWindowManager.Stub.asInterface(</p>
</li>
<li><p>                              ServiceManager.getService(Context.WINDOW_SERVICE));</p>
</li>
<li><p>                    wm.freezeRotation(0);//wm.getRotation()</p>
</li>
<li><p>              } catch (Exception e) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>              }</p>
</li>
<li><p>           }</p>
</li>
</ul>
<p>             final CloseDialogReceiver closer = new CloseDialogReceiver(context);</p>
<p>             if (sConfirmDialog != null) {</p>
<p>                 sConfirmDialog.dismiss();</p>
<p>@@ -147,13 +181,37 @@ public final class ShutdownThread extends Thread {</p>
<p>                             beginShutdownSequence(context);</p>
<p>                         }</p>
<p>                     })</p>
<ul>
<li>                   .setNegativeButton(com.android.internal.R.string.no, null)</li>
</ul>
<ul>
<li><p>                   .setNegativeButton(com.android.internal.R.string.no, new DialogInterface.OnClickListener() {</p>
</li>
<li><p>                      public void onClick(DialogInterface dialog, int which) {</p>
</li>
<li><p>                          if (mHasAnimation) {</p>
</li>
<li><p>                              try {</p>
</li>
<li><p>                                    IWindowManager wm = IWindowManager.Stub.asInterface(</p>
</li>
<li><p>                                         ServiceManager.getService(Context.WINDOW_SERVICE)</p>
</li>
<li><p>                                      );</p>
</li>
<li><p>                                    wm.thawRotation();</p>
</li>
<li><p>                              } catch (Exception e) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                              }</p>
</li>
<li><p>                          }</p>
</li>
<li><p>                      }</p>
</li>
<li><p>                   })</p>
</li>
<li><p>                                      </p>
</li>
<li><p>                                      </p>
</li>
</ul>
<p>                     .create();</p>
<p>             closer.dialog = sConfirmDialog;</p>
<p>             sConfirmDialog.setOnDismissListener(closer);</p>
<p>             sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</p>
<p>             sConfirmDialog.show();</p>
<p>         } else {</p>
<ul>
<li><p>      if (mHasAnimation) {</p>
</li>
<li><p>              try {</p>
</li>
<li><p>                    IWindowManager wm = IWindowManager.Stub.asInterface(</p>
</li>
<li><p>                              ServiceManager.getService(Context.WINDOW_SERVICE));</p>
</li>
<li><p>                    wm.freezeRotation(0);</p>
</li>
<li><p>              } catch (Exception e) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>              }</p>
</li>
<li><p>           }</p>
</li>
</ul>
<p>             beginShutdownSequence(context);</p>
<p>         }</p>
<p>     }</p>
<p>@@ -217,7 +275,23 @@ public final class ShutdownThread extends Thread {</p>
<p>             }</p>
<p>             sIsStarted = true;</p>
<p>         }</p>
<ul>
<li><p>          final IActivityManager am =</p>
</li>
<li><p>           ActivityManagerNative.asInterface(ServiceManager.checkService(&quot;activity&quot;));</p>
</li>
<li><p>       if (am != null) {</p>
</li>
<li><p>           int[] pids = new int[1];</p>
</li>
<li><p>           try {</p>
</li>
<li><p>               am.killPids(pids, &quot;Shutdown system&quot;, true);</p>
</li>
<li><p>           } catch (RemoteException e) {</p>
</li>
<li><p>           }</p>
</li>
<li><p>       }</p>
</li>
<li><p>      boolean mShowShutdownAnim = new File(&quot;/system/media/shutdownanimation.zip&quot;).exists()</p>
</li>
<li><p>                                  || new File(&quot;/data/local/shutdownanimation.zip&quot;).exists();</p>
</li>
<li><p>      if (mShowShutdownAnim){</p>
</li>
<li><p>              android.os.SystemProperties.set(&quot;ctl.start&quot;, &quot;shutdownanim&quot;);</p>
</li>
<li><p>              playMusic();</p>
</li>
<li><p>      } else {</p>
</li>
<li><p>              </p>
</li>
</ul>
<p>         // throw up an indeterminate system dialog to indicate radio is</p>
<p>         // shutting down.</p>
<p>         ProgressDialog pd = new ProgressDialog(context);</p>
<p>@@ -228,7 +302,7 @@ public final class ShutdownThread extends Thread {</p>
<p>         pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</p>
<p>         pd.show();</p>
<p>-</p>
<ul>
<li>      }</li>
</ul>
<p>         sInstance.mContext = context;</p>
<p>         sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</p>
<p>@@ -261,7 +335,9 @@ public final class ShutdownThread extends Thread {</p>
<p>         // start the thread that initiates shutdown</p>
<p>         sInstance.mHandler = new Handler() {</p>
<p>         };</p>
<ul>
<li>       sInstance.start();</li>
</ul>
<ul>
<li><p>       sInstance.start(); </p>
</li>
<li><p>      </p>
</li>
<li><p>              </p>
</li>
</ul>
<p>     }</p>
<p>     void actionDone() {</p>
<p>@@ -305,9 +381,7 @@ public final class ShutdownThread extends Thread {</p>
<p>         // First send the high-level shut down broadcast.</p>
<p>         mActionDone = false;</p>
<ul>
<li><p>       Intent intent = new Intent(Intent.ACTION_SHUTDOWN);</p>
</li>
<li><p>       intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</p>
</li>
<li><p>       mContext.sendOrderedBroadcastAsUser(intent,</p>
</li>
</ul>
<ul>
<li>       mContext.sendOrderedBroadcastAsUser(new Intent(Intent.ACTION_SHUTDOWN),</li>
</ul>
<p>                 UserHandle.ALL, null, br, mHandler, 0, null, null);</p>
<p>         final long endTime = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;</p>
<p>@@ -527,6 +601,17 @@ public final class ShutdownThread extends Thread {</p>
<p>             }</p>
<p>         }</p>
<ul>
<li><p>                 if (mHasAnimation) {</p>
</li>
<li><p>                              try {</p>
</li>
<li><p>                                    IWindowManager wm = IWindowManager.Stub.asInterface(</p>
</li>
<li><p>                                         ServiceManager.getService(Context.WINDOW_SERVICE)</p>
</li>
<li><p>                                      );</p>
</li>
<li><p>                                    wm.thawRotation();</p>
</li>
<li><p>                              } catch (Exception e) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                              }</p>
</li>
<li><p>                          }   </p>
</li>
<li><p>              </p>
</li>
</ul>
<p>         // Shutdown power</p>
<p>         Log.i(TAG, &quot;Performing low-level shutdown…&quot;);</p>
<p>         PowerManagerService.lowLevelShutdown();</p>
<p>(END)</p>
<p>若不要影响原来的方向，需要记录下面这些值来操作。</p>
<p>int userRotation = Settings.System.getIntForUser(resolver,</p>
<p>                    Settings.System.USER_ROTATION, Surface.ROTATION_0,</p>
<p>                    UserHandle.USER_CURRENT);</p>
<p>int userRotationMode = Settings.System.getIntForUser(resolver,</p>
<p>                    Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ?</p>
<p>                            WindowManagerPolicy.USER_ROTATION_FREE :</p>
<p>                                    WindowManagerPolicy.USER_ROTATION_LOCKED;</p>
<p>4.4,关机动画，锁定方向，关背光</p>
<p>#backlight</p>
<p>    chown system system /sys/class/backlight/rk28_bl/brightness</p>
<p>    chown root system /sys/class/backlight/rk28_bl/bl_power</p>
<p>    chmod 0664 /sys/class/backlight/rk28_bl/bl_power</p>
<hr>
<p>diff –git a/cmds/bootanimation/BootAnimation.cpp b/cmds/bootanimation/BootAnimation.cpp</p>
<p>index 68dc6a2..31fe0cd 100644</p>
<p>— a/cmds/bootanimation/BootAnimation.cpp</p>
<p>+++ b/cmds/bootanimation/BootAnimation.cpp</p>
<p>@@ -90,7 +90,7 @@ BootAnimation::BootAnimation(bool shutdown) : Thread(false)</p>
<p>     DisplayInfo dinfo;</p>
<p>     status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;dinfo);</p>
<p>     ALOGD(&quot;DISPLAY,W-H: %d-%d, ori: %d&quot;, dinfo.w, dinfo.h,dinfo.orientation);</p>
<ul>
<li>   if (mShutdown) {</li>
</ul>
<p>+if (0){//}mShutdown) {</p>
<p>            bool vertical=dinfo.orientation==0 || dinfo.orientation==2 ;</p>
<p>            if(vertical){</p>
<p>                    mReverseAxis =false;</p>
<p>@@ -266,7 +266,7 @@ status_t BootAnimation::readyToRun() {</p>
<p>     int curWidth = dinfo.w;</p>
<p>     int curHeight = dinfo.h;</p>
<ul>
<li>   if (mShutdown) {</li>
</ul>
<ul>
<li>   if (0){//}mShutdown) {</li>
</ul>
<p>            if (dinfo.orientation % 2 == 0) {</p>
<p>                    curWidth = dinfo.h;</p>
<p>                    curHeight = dinfo.w;</p>
<p>diff –git a/services/java/com/android/server/power/ShutdownThread.java b/services/java/com/android/server/power/ShutdownThread.java</p>
<p>index 88a27f5..31ddca1 100644</p>
<p>— a/services/java/com/android/server/power/ShutdownThread.java</p>
<p>+++ b/services/java/com/android/server/power/ShutdownThread.java</p>
<p>@@ -42,12 +42,21 @@ import android.os.Vibrator;</p>
<p> import android.os.SystemVibrator;</p>
<p> import android.os.storage.IMountService;</p>
<p> import android.os.storage.IMountShutdownObserver;</p>
<p>+import android.os.ServiceManager;</p>
<p> import com.android.internal.telephony.ITelephony;</p>
<p> import android.util.Log;</p>
<p>+import android.media.MediaPlayer;</p>
<p>+import java.io.File;</p>
<p>+import java.io.IOException;</p>
<p> import android.view.WindowManager;</p>
<p>+import android.view.IWindowManager;</p>
<p>+import android.provider.Settings;</p>
<p>+import android.view.WindowManagerPolicy;</p>
<p>+import android.view.Surface;</p>
<p>+import java.io.RandomAccessFile;</p>
<p> public final class ShutdownThread extends Thread {</p>
<p>     // constants</p>
<p>     private static final String TAG = &quot;ShutdownThread&quot;;</p>
<p>@@ -76,6 +85,8 @@ public final class ShutdownThread extends Thread {</p>
<p>     // static instance of this thread</p>
<p>     private static final ShutdownThread sInstance = new ShutdownThread();</p>
<ul>
<li><p>   // if has Shutdown Animation set this to ture</p>
</li>
<li><p>   private static boolean mHasAnimation;</p>
</li>
</ul>
<p>     private final Object mActionDoneSync = new Object();</p>
<p>     private boolean mActionDone;</p>
<p>@@ -84,11 +95,44 @@ public final class ShutdownThread extends Thread {</p>
<p>     private PowerManager.WakeLock mCpuWakeLock;</p>
<p>     private PowerManager.WakeLock mScreenWakeLock;</p>
<p>     private Handler mHandler;</p>
<p>-</p>
<ul>
<li><p>      </p>
</li>
<li><p>      private static int userRotationMode ;</p>
</li>
<li><p>      private static int userRotation ;</p>
</li>
</ul>
<p>     private static AlertDialog sConfirmDialog;</p>
<p>     private ShutdownThread() {</p>
<p>     }</p>
<p>+</p>
<ul>
<li><p>   private static void playMusic() {</p>
</li>
<li><p>      MediaPlayer mp = new MediaPlayer();</p>
</li>
<li><p>      try {</p>
</li>
<li><p>              File file = new File(&quot;system/media/audio/shutdown.ogg&quot;);</p>
</li>
<li><p>              if (file.exists()) {</p>
</li>
<li><p>                  mp.setDataSource(&quot;system/media/audio/shutdown.ogg&quot;);</p>
</li>
<li><p>                  mp.prepare();</p>
</li>
<li><p>                  mp.start();</p>
</li>
<li><p>              }</p>
</li>
<li><p>      }catch (IllegalArgumentException e) {</p>
</li>
<li><p>              e.printStackTrace();</p>
</li>
<li><p>      }catch (IOException e) {</p>
</li>
<li><p>              e.printStackTrace();</p>
</li>
<li><p>      }</p>
</li>
<li><p>   }</p>
</li>
<li><p>              </p>
</li>
<li><p>   private static void TurnOffScreen(){ </p>
</li>
<li><p>                                                  </p>
</li>
<li><p>          File HdmiFile =new File(&quot;/sys/class/backlight/rk28_bl/bl_power&quot;);                    </p>
</li>
<li><p>              try {</p>
</li>
<li><p>              RandomAccessFile rdf = null;</p>
</li>
<li><p>              rdf = new RandomAccessFile(HdmiFile, &quot;rw&quot;);</p>
</li>
<li><p>              rdf.writeBytes(&quot;1&quot;);             </p>
</li>
<li><p>              } catch (Exception e) {</p>
</li>
<li><p>                      Log.e(TAG, &quot;Exception&quot;+e);</p>
</li>
<li><p>                      }</p>
</li>
<li><p>                                                                         </p>
</li>
<li><p>      }                                                          </p>
</li>
<li><p>                                                                        </p>
</li>
<li><p>                                                                      </p>
</li>
</ul>
<p>     /**</p>
<p>      * Request a clean shutdown, waiting for subsystems to clean up their</p>
<p>@@ -101,6 +145,8 @@ public final class ShutdownThread extends Thread {</p>
<p>     public static void shutdown(final Context context, boolean confirm) {</p>
<p>         mReboot = false;</p>
<p>         mRebootSafeMode = false;</p>
<ul>
<li><p>       mHasAnimation = (new File(&quot;/system/media/shutdownanimation.zip&quot;).exists()</p>
</li>
<li><p>                           || new File(&quot;/data/local/shutdownanimation.zip&quot;).exists());</p>
</li>
</ul>
<p>         shutdownInner(context, confirm);</p>
<p>     }</p>
<p>@@ -125,6 +171,25 @@ public final class ShutdownThread extends Thread {</p>
<p>         Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior);</p>
<p>         if (confirm) {</p>
<ul>
<li><p>          if (mHasAnimation) {</p>
</li>
<li><p>              </p>
</li>
<li><p>       userRotationMode = Settings.System.getIntForUser(context.getContentResolver(),</p>
</li>
<li><p>                   Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ?</p>
</li>
<li><p>                           WindowManagerPolicy.USER_ROTATION_FREE :</p>
</li>
<li><p>                                   WindowManagerPolicy.USER_ROTATION_LOCKED;</p>
</li>
<li><p>                                                                      </p>
</li>
<li><p>       userRotation = Settings.System.getIntForUser(context.getContentResolver(),</p>
</li>
<li><p>                   Settings.System.USER_ROTATION, Surface.ROTATION_0,</p>
</li>
<li><p>                   UserHandle.USER_CURRENT);</p>
</li>
<li><p>              </p>
</li>
<li><p>              try {</p>
</li>
<li><p>                    IWindowManager wm = IWindowManager.Stub.asInterface(</p>
</li>
<li><p>                              ServiceManager.getService(Context.WINDOW_SERVICE));                                             </p>
</li>
<li><p>                      wm.freezeRotation(0);//wm.getRotation());                       </p>
</li>
<li><p>              } catch (Exception e) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>              }</p>
</li>
<li><p>           }</p>
</li>
</ul>
<p>             final CloseDialogReceiver closer = new CloseDialogReceiver(context);</p>
<p>             if (sConfirmDialog != null) {</p>
<p>                 sConfirmDialog.dismiss();</p>
<p>@@ -139,7 +204,25 @@ public final class ShutdownThread extends Thread {</p>
<p>                             beginShutdownSequence(context);</p>
<p>                         }</p>
<p>                     })</p>
<ul>
<li>                   .setNegativeButton(com.android.internal.R.string.no, null)</li>
</ul>
<ul>
<li><p>                   .setNegativeButton(com.android.internal.R.string.no, new DialogInterface.OnClickListener() {</p>
</li>
<li><p>                      public void onClick(DialogInterface dialog, int which) {</p>
</li>
<li><p>                          if (mHasAnimation) {</p>
</li>
<li><p>                              try {</p>
</li>
<li><p>                                    IWindowManager wm = IWindowManager.Stub.asInterface(</p>
</li>
<li><p>                                         ServiceManager.getService(Context.WINDOW_SERVICE)</p>
</li>
<li><p>                                      );</p>
</li>
<li><p>                                    //wm.thawRotation();</p>
</li>
<li><p>                                        if(userRotationMode == WindowManagerPolicy.USER_ROTATION_FREE){       </p>
</li>
<li><p>                                                      wm.thawRotation();</p>
</li>
<li><p>                                              }else{</p>
</li>
<li><p>                                                  wm.freezeRotation(userRotation);                                            </p>
</li>
<li><p>                                              }       </p>
</li>
<li><p>                              } catch (Exception e) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                              }</p>
</li>
<li><p>                          }</p>
</li>
<li><p>                      }</p>
</li>
<li><p>                   })</p>
</li>
</ul>
<p>                     .create();</p>
<p>             closer.dialog = sConfirmDialog;</p>
<p>             sConfirmDialog.setOnDismissListener(closer);</p>
<p>@@ -210,6 +293,22 @@ public final class ShutdownThread extends Thread {</p>
<p>             sIsStarted = true;</p>
<p>         }</p>
<ul>
<li><p>       final IActivityManager am =</p>
</li>
<li><p>           ActivityManagerNative.asInterface(ServiceManager.checkService(&quot;activity&quot;));</p>
</li>
<li><p>       if (am != null) {</p>
</li>
<li><p>           int[] pids = new int[1];</p>
</li>
<li><p>           try {</p>
</li>
<li><p>               am.killPids(pids, &quot;Shutdown system&quot;, true);</p>
</li>
<li><p>           } catch (RemoteException e) {</p>
</li>
<li><p>           }</p>
</li>
<li><p>       }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>      boolean mShowShutdownAnim = new File(&quot;/system/media/shutdownanimation.zip&quot;).exists()</p>
</li>
<li><p>                                  || new File(&quot;/data/local/shutdownanimation.zip&quot;).exists();</p>
</li>
<li><p>      if (mShowShutdownAnim){</p>
</li>
<li><p>              android.os.SystemProperties.set(&quot;ctl.start&quot;, &quot;shutdownanim&quot;);</p>
</li>
<li><p>              playMusic();</p>
</li>
<li><p>      } else {</p>
</li>
</ul>
<p>         // throw up an indeterminate system dialog to indicate radio is</p>
<p>         // shutting down.</p>
<p>         ProgressDialog pd = new ProgressDialog(context);</p>
<p>@@ -220,6 +319,7 @@ public final class ShutdownThread extends Thread {</p>
<p>         pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</p>
<p>         pd.show();</p>
<ul>
<li>      }</li>
</ul>
<p>         sInstance.mContext = context;</p>
<p>         sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</p>
<p>@@ -297,9 +397,7 @@ public final class ShutdownThread extends Thread {</p>
<p>         // First send the high-level shut down broadcast.</p>
<p>         mActionDone = false;</p>
<ul>
<li><p>       Intent intent = new Intent(Intent.ACTION_SHUTDOWN);</p>
</li>
<li><p>       intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</p>
</li>
<li><p>       mContext.sendOrderedBroadcastAsUser(intent,</p>
</li>
</ul>
<ul>
<li>       mContext.sendOrderedBroadcastAsUser(new Intent(Intent.ACTION_SHUTDOWN),</li>
</ul>
<p>                 UserHandle.ALL, null, br, mHandler, 0, null, null);</p>
<p>         final long endTime = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;</p>
<p>@@ -492,8 +590,11 @@ public final class ShutdownThread extends Thread {</p>
<p>     public static void rebootOrShutdown(boolean reboot, String reason) {</p>
<p>         if (reboot) {</p>
<p>             Log.i(TAG, &quot;Rebooting, reason: &quot; + reason);</p>
<ul>
<li><p>           PowerManagerService.lowLevelReboot(reason);</p>
</li>
<li><p>           Log.e(TAG, &quot;Reboot failed, will attempt shutdown instead&quot;);</p>
</li>
</ul>
<ul>
<li><p>           try {</p>
</li>
<li><p>               PowerManagerService.lowLevelReboot(reason);</p>
</li>
<li><p>           } catch (Exception e) {</p>
</li>
<li><p>               Log.e(TAG, &quot;Reboot failed, will attempt shutdown instead&quot;, e);</p>
</li>
<li><p>           }</p>
</li>
</ul>
<p>         } else if (SHUTDOWN_VIBRATE_MS &gt; 0) {</p>
<p>             // vibrate before shutting down</p>
<p>             Vibrator vibrator = new SystemVibrator();</p>
<p>@@ -510,6 +611,23 @@ public final class ShutdownThread extends Thread {</p>
<p>             } catch (InterruptedException unused) {</p>
<p>             }</p>
<p>         }</p>
<ul>
<li><p>              </p>
</li>
<li><p>                      TurnOffScreen();//turn off screen before freeRotation .</p>
</li>
<li><p>                      try {</p>
</li>
<li><p>                                    IWindowManager wm = IWindowManager.Stub.asInterface(</p>
</li>
<li><p>                                         ServiceManager.getService(Context.WINDOW_SERVICE));                                     </p>
</li>
<li><p>                                    </p>
</li>
<li><p>                                              if(userRotationMode == WindowManagerPolicy.USER_ROTATION_FREE){ </p>
</li>
<li><p>                                                      wm.thawRotation();</p>
</li>
<li><p>                                              }else{</p>
</li>
<li><p>                                                  wm.freezeRotation(userRotation);                                            </p>
</li>
<li><p>                                              }                                       </p>
</li>
<li><p>                                      </p>
</li>
<li><p>                              } catch (Exception e) {</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                              }</p>
</li>
<li><p>              </p>
</li>
<li><p>      </p>
</li>
</ul>
<p>         // Shutdown power</p>
<p>         Log.i(TAG, &quot;Performing low-level shutdown…&quot;);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android 4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%204.0%20Wifi%20%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>              Android 4.0 Wifi 子系统</p>
<p>1.wifi子系统的初始化</p>
<p>     wifi服务初始化和其他的服务差不多，也是通过SystemService来创建的。</p>
<p>&lt;framework/base/services/java/com/android/server/SystemServer.java</p>
<p>                Slog.i(TAG, &quot;Connectivity Service&quot;);</p>
<p>                 connectivity = new ConnectivityService(</p>
<p> context, networkManagement, networkStats, networkPolicy);</p>
<p>                 ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);</p>
<p>                 networkStats.bindConnectivityManager(connectivity);</p>
<p>                 networkPolicy.bindConnectivityManager(connectivity);</p>
<p>                 wifi.checkAndStartWifi();</p>
<p>                 wifiP2p.connectivityServiceReady();</p>
<p>通过ServiceManager.addService启动了ConnectivityService,在android系统里面我们常见的属于Connectivity的有</p>
<p>wifi,mobile,bluetooth,wimax,ethernet。</p>
<p>&lt;framework/base/services/java/com/android/server/WifiService.java&gt;</p>
<p>         public void checkAndStartWifi() {</p>
<p>          mAirplaneModeOn.set(isAirplaneModeOn());</p>
<p>          mPersistWifiState.set(getPersistedWifiState());</p>
<p>          /* Start if Wi-Fi should be enabled or the saved state indicates Wi-Fi was on */</p>
<p>          boolean wifiEnabled = shouldWifiBeEnabled() || testAndClearWifiSavedState();</p>
<p>          Slog.i(TAG, &quot;WifiService starting up with Wi-Fi &quot; +</p>
<p>(wifiEnabled ? &quot;enabled&quot; : &quot;disabled&quot;));</p>
<p>          setWifiEnabled(wifiEnabled);</p>
<p>          mWifiWatchdogStateMachine = WifiWatchdogStateMachine.</p>
<p>                 makeWifiWatchdogStateMachine(mContext);</p>
<p>     }</p>
<p>     wifiService的checkAndStartWifi是启动wifiService的关键，首先会去判断是启用了飞行模式，然后根据wifi的按钮在上一次关机前的状态来确定以什么样的方式来启动wifi。本文假设wifi按钮是on的状态来启动的。那么wifiEnabled参数的至就是为ture。</p>
<p>  &lt;framework/base/services/java/com/android/server/WifiService.java&gt;</p>
<p> public synchronized boolean setWifiEnabled(boolean enable) {</p>
<p>        enforceChangePermission();</p>
<p>        if (DBG) {</p>
<p>            Slog.e(TAG, &quot;Invoking mWifiStateMachine.setWifiEnabled\n&quot;);</p>
<p>        }</p>
<p>        if (enable) {</p>
<p>            reportStartWorkSource();</p>
<p>        }   </p>
<p>        mWifiStateMachine.setWifiEnabled(enable);</p>
<p>        ……</p>
<p>        if (enable != mWifiEnabled) {</p>
<p>            long ident = Binder.clearCallingIdentity();</p>
<p>            persistWifiState(enable);</p>
<p>            Binder.restoreCallingIdentity(ident);</p>
<p>        }   </p>
<p>        if (enable) {</p>
<p>            if (!mIsReceiverRegistered) {</p>
<p>                registerForBroadcasts();</p>
<p>                mIsReceiverRegistered = true;</p>
<p>            }   </p>
<p>        } else if (mIsReceiverRegistered) {</p>
<p>            mContext.unregisterReceiver(mReceiver);</p>
<p>            mIsReceiverRegistered = false;</p>
<p>        }   </p>
<p>        return true;</p>
<p>    }</p>
<p>在之前的wifiService中初始化了一个私有类mWifiStateMachine类，在start wifiService中调用SetWifiEnabled就会去调用wifiStateMachine的setWifiEnabled方法。</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt;</p>
<p>    public void setWifiEnabled(boolean enable) {</p>
<p>        mLastEnableUid.set(Binder.getCallingUid());</p>
<p>        if (enable) {</p>
<p>            /* Argument is the state that is entered prior to load */</p>
<p>            sendMessage(obtainMessage(CMD_LOAD_DRIVER, WIFI_STATE_ENABLING, 0));</p>
<p>            sendMessage(CMD_START_SUPPLICANT);</p>
<p>        } else {</p>
<p>            sendMessage(CMD_STOP_SUPPLICANT);</p>
<p>            /* Argument is the state that is entered upon success */</p>
<p>            sendMessage(obtainMessage(CMD_UNLOAD_DRIVER, WIFI_STATE_DISABLED, 0));</p>
<p>        }</p>
<p>    }</p>
<p>在这个函数中我们假设wifi的状态是on的。那么参数enable就是ture，所以我们发送消息，CMD_LOAD_DRIVER。在wifi的状态机里面就会去处理这个消息。</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt;</p>
<p>     public boolean processMessage(Message message) {</p>
<p>            if (DBG) log(getName() + message.toString() + &quot;\n&quot;);</p>
<p>            switch (message.what) {</p>
<p>                case CMD_LOAD_DRIVER:</p>
<p>                    mWifiP2pChannel.sendMessage(WIFI_ENABLE_PENDING);</p>
<p>                    transitionTo(mWaitForP2pDisableState);</p>
<p>                    break;</p>
<p>                case WifiP2pService.P2P_ENABLE_PENDING:</p>
<p>                    mReplyChannel.replyToMessage(message, P2P_ENABLE_PROCEED);</p>
<p>                    break;</p>
<p>                default:</p>
<p>                    return NOT_HANDLED;</p>
<p>            }   </p>
<p>            EventLog.writeEvent(EVENTLOG_WIFI_EVENT_HANDLED, message.what);</p>
<p>            return HANDLED;</p>
<p>        }   </p>
<p>    }   </p>
<p>在wifi状态机中，通过transitionTo到WaitForP2pDisableState，并发送P2P_ENABLE_PROCEED命令，到WaitFor</p>
<p>P2pDisableState中来处理。这里解释下wifi p2p是什么，这是Andorid 4.0新增的WIFI DIRECT的功能。</p>
<p> &lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt;  </p>
<p>  class WaitForP2pDisableState extends State {</p>
<p>        private int mSavedArg;</p>
<p>        @Override</p>
<p>        public void enter() {</p>
<p>            if (DBG) log(getName() + &quot;\n&quot;);</p>
<p>            EventLog.writeEvent(EVENTLOG_WIFI_STATE_CHANGED, getName());</p>
<p>            //Preserve the argument arg1 that has information used in DriverLoadingState</p>
<p>            mSavedArg = getCurrentMessage().arg1;</p>
<p>        }</p>
<p>        @Override</p>
<p>        public boolean processMessage(Message message) {</p>
<p>            if (DBG) log(getName() + message.toString() + &quot;\n&quot;);</p>
<p>            switch(message.what) {</p>
<p>                case WifiP2pService.WIFI_ENABLE_PROCEED:</p>
<p>                    //restore argument from original message (CMD_LOAD_DRIVER)</p>
<p>                    message.arg1 = mSavedArg;</p>
<p>                    transitionTo(mDriverLoadingState);</p>
<p>                    break;</p>
<p>                case CMD_LOAD_DRIVER:</p>
<p>               ……</p>
<p>   }</p>
<p>同样将wifi的状态机通过transitionTo函数切换到mDriverLoadingstate中，并发送CMD_LOAD_DRIVER命令，到mDriverLoadingState中来处理。</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt; </p>
<p>class DriverLoadingState extends State {</p>
<p>        @Override</p>
<p>        public void enter() {</p>
<p>            if (DBG) log(getName() + &quot;\n&quot;);</p>
<p>            EventLog.writeEvent(EVENTLOG_WIFI_STATE_CHANGED, getName());</p>
<p>            final Message message = new Message();</p>
<p>            message.copyFrom(getCurrentMessage());</p>
<p>            /* TODO: add a timeout to fail when driver load is hung.</p>
<p>             * Similarly for driver unload.</p>
<p>             */</p>
<p>            new Thread(new Runnable() {</p>
<p>                public void run() {</p>
<p>                    mWakeLock.acquire();</p>
<p>                    //enabling state</p>
<p>                    switch(message.arg1) {</p>
<p>                        case WIFI_STATE_ENABLING:</p>
<p>                            setWifiState(WIFI_STATE_ENABLING);</p>
<p>                            break;</p>
<p>                        case WIFI_AP_STATE_ENABLING:</p>
<p>                            setWifiApState(WIFI_AP_STATE_ENABLING);</p>
<p>                            break;</p>
<p>                    }</p>
<p>                    if(WifiNative.loadDriver()) {</p>
<p>                        if (DBG) log(&quot;Driver load successful&quot;);</p>
<p>                        sendMessage(CMD_LOAD_DRIVER_SUCCESS);</p>
<p>                    } else {</p>
<p>                        loge(&quot;Failed to load driver!&quot;);</p>
<p>                        switch(message.arg1) {</p>
<p>                            case WIFI_STATE_ENABLING:</p>
<p>                                setWifiState(WIFI_STATE_UNKNOWN);</p>
<p>                                break;</p>
<p>                            case WIFI_AP_STATE_ENABLING:</p>
<p>                                setWifiApState(WIFI_AP_STATE_FAILED);</p>
<p>                                break;</p>
<p>                        }</p>
<p>                        sendMessage(CMD_LOAD_DRIVER_FAILURE);</p>
<p>                    }</p>
<p>在driverLoadingState中同过native.loadDriver()函数来真正load wifi的驱动模块，这里wifi驱动一般以模块的方式来加载。在WifiNative.java中定义了 public native static boolean loadDriver()这个函数，这就说明了loadDriver是一个native的方法，代码走到这里就要不得不说JNI了，是Java Native Interface的缩写，中文是JAVA本地调用。</p>
<p>&lt;framework/base/core/jni/android_net_wifi_wifi.cpp&gt;</p>
<p>static JNINativeMethod gWifiMethods[] = {</p>
<p>    /* name, signature, funcPtr */</p>
<p>    { &quot;loadDriver&quot;, &quot;()Z&quot;,  (void *)android_net_wifi_loadDriver },</p>
<p>    { &quot;isDriverLoaded&quot;, &quot;()Z&quot;,  (void *)android_net_wifi_isDriverLoaded},</p>
<p>     ……</p>
<p>    }</p>
<p>loadDriver这个函数在JNI里面对应的就是(void*)android_net_wifi_loadDriver函数。</p>
<p>&lt;framework/base/core/jni/android_net_wifi_wifi.cpp&gt;</p>
<p>static jboolean android_net_wifi_loadDriver(JNIEnv* env, jobject)</p>
<p>{</p>
<p>    return (jboolean)(::wifi_load_driver() == 0);</p>
<p>}</p>
<p>     JNI里很简单什么都没有做，直接调用了wifi的HAL层。</p>
<p>&lt;hardware/libhardware_legacy/wifi/wifi.c&gt;</p>
<p>int wifi_load_driver()</p>
<p>{</p>
<p>#ifdef WIFI_DRIVER_MODULE_PATH</p>
<p>    char driver_status[PROPERTY_VALUE_MAX];</p>
<p>    int count = 100; /* wait at most 20 seconds for completion */</p>
<p>    if (is_wifi_driver_loaded()) {</p>
<p>        return 0;</p>
<p>    }</p>
<p>    if (insmod(DRIVER_MODULE_PATH, DRIVER_MODULE_ARG) &lt; 0)</p>
<p>        return -1;</p>
<p>    if (strcmp(FIRMWARE_LOADER,&quot;&quot;) == 0) {</p>
<p>        /* usleep(WIFI_DRIVER_LOADER_DELAY); */</p>
<p>        property_set(DRIVER_PROP_NAME, &quot;ok&quot;);</p>
<p>    }  </p>
<p>    else {</p>
<p>        property_set(&quot;ctl.start&quot;, FIRMWARE_LOADER);</p>
<p>    }  </p>
<p>    sched_yield();</p>
<p>    while (count– &gt; 0) {</p>
<p>        if (property_get(DRIVER_PROP_NAME, driver_status, NULL)) {</p>
<p>            if (strcmp(driver_status, &quot;ok&quot;) == 0)</p>
<p>                return 0;</p>
<p>            else if (strcmp(DRIVER_PROP_NAME, &quot;failed&quot;) == 0) { libcutils</p>
<p>                wifi_unload_driver();</p>
<p>                return -1;</p>
<p>            }  </p>
<p>        }  </p>
<p>        usleep(200000);</p>
<p>    }  </p>
<p>    property_set(DRIVER_PROP_NAME, &quot;timeout&quot;);</p>
<p>    wifi_unload_driver();</p>
<p>    return -1;</p>
<p>#else</p>
<p>    property_set(DRIVER_PROP_NAME, &quot;ok&quot;);</p>
<p>    return 0;</p>
<p>#endif</p>
<p>}</p>
<p>     wifi的驱动加载方式有两种，一种是采用buildin方式，就是直接编译到kernel的镜像文件中，还有一种就是动态以模块的方式来进行加载和卸载，我们的是采用第二种方式来实现的，就是wifi enable的时候就去加载wifi驱动，然后在disabled时候就去卸载驱动。如果驱动模块能够正常加载的话，那么整个wifi服务的初始化过程就算暂时告一段落了。还有就是这段加载驱动的代码的前提是需要WIFI_DRIVER_MODULE_PATH这个宏被定义，我们通常的做法是在BoradConfig.mk里面定义，这个宏指定了Wifi驱动模块的存放路径。</p>
<p>2.WPA_SUPPLICANT服务的启动</p>
<p>回到之前的wifiNative.loadDriver，当wifiNative成功加载wifi驱动后，就会发送命令CMD_LOAD_DRIVER_SUCCES</p>
<p>S,将wifi的状态机切换到DriverLoadedState。</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt;</p>
<p>               if(WifiNative.loadDriver()) {</p>
<p>                        if (DBG) log(&quot;Driver load successful&quot;);</p>
<p>                        sendMessage(CMD_LOAD_DRIVER_SUCCESS);</p>
<p>                    }</p>
<p>                ……</p>
<p>          public boolean processMessage(Message message) {</p>
<p>          if (DBG) log(getName() + message.toString() + &quot;\n&quot;);</p>
<p>            switch (message.what) {</p>
<p>                case CMD_LOAD_DRIVER_SUCCESS:</p>
<p>                    transitionTo(mDriverLoadedState);</p>
<p>                    break;</p>
<p>切换到了DriverLoadedState后，说明wifi的Driver成功加载的，那么就要发命令启动wpa_supplicant服务进程，具体的代码如下：</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt;</p>
<p>public void setWifiEnabled(boolean enable) {</p>
<p>        mLastEnableUid.set(Binder.getCallingUid());</p>
<p>        if (enable) {</p>
<p>            /* Argument is the state that is entered prior to load */</p>
<p>            sendMessage(obtainMessage(CMD_LOAD_DRIVER, WIFI_STATE_ENABLING, 0));</p>
<p>            sendMessage(CMD_START_SUPPLICANT);</p>
<p>        } else {</p>
<p>            sendMessage(CMD_STOP_SUPPLICANT);</p>
<p>            /* Argument is the state that is entered upon success */</p>
<p>            sendMessage(obtainMessage(CMD_UNLOAD_DRIVER, WIFI_STATE_DISABLED, 0));</p>
<p>        }   </p>
<p>     }   </p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt;</p>
<p>case CMD_START_SUPPLICANT:</p>
<p>                    try {</p>
<p>                        mNwService.wifiFirmwareReload(mInterfaceName, &quot;STA&quot;);</p>
<p>                    } catch (Exception e) {</p>
<p>                        loge(&quot;Failed to reload STA firmware &quot; + e);</p>
<p>                        // continue</p>
<p>                    }</p>
<p>                   try {</p>
<p>                       //A runtime crash can leave the interface up and</p>
<p>                       //this affects connectivity when supplicant starts up.</p>
<p>                       //Ensure interface is down before a supplicant start.</p>
<p>                        mNwService.setInterfaceDown(mInterfaceName);</p>
<p>                        //Set privacy extensions</p>
<p>                        mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);</p>
<p>                    } catch (RemoteException re) {</p>
<p>                        loge(&quot;Unable to change interface settings: &quot; + re);</p>
<p>                    } catch (IllegalStateException ie) {</p>
<p>                        loge(&quot;Unable to change interface settings: &quot; + ie);</p>
<p>                    }</p>
<p>                    if(WifiNative.startSupplicant()) {</p>
<p>                        if (DBG) log(&quot;Supplicant start successful&quot;);</p>
<p>                        mWifiMonitor.startMonitoring();</p>
<p>                        transitionTo(mSupplicantStartingState);</p>
<p>在这里会去重新加载wifi的firmware，改变网络设置的ipv6的接口，然后WifiNative.startSupplicant通过JNI来启动wpa_supplicant服务。这里跟上面的WifiNative.loadDriver是差不多的。具体的代码流程如下：</p>
<p>&lt;framework/base/core/jni/android_net_wifi_wifi.cpp&gt;</p>
<p>{ &quot;startSupplicant&quot;, &quot;()Z&quot;,  (void *)android_net_wifi_startSupplicant },</p>
<p>……</p>
<p>static jboolean android_net_wifi_startSupplicant(JNIEnv* env, jobject)</p>
<p>{</p>
<p>    return (jboolean)(::wifi_start_supplicant() == 0);</p>
<p>}</p>
<p>还是android惯用的方式，通过JNI来调用HAL层的代码，wifi的HAL层的代码还是在android为数不多的最早的目录下面。</p>
<p>&lt;hardware/libhardware_legacy/wifi/wifi.c&gt;</p>
<p>int wifi_start_supplicant()</p>
<p>{</p>
<p>    return wifi_start_supplicant_common(SUPP_CONFIG_FILE);</p>
<p>}</p>
<p>其中的 SUPP_CONFIG_FILE[]    = &quot;/data/misc/wifi/wpa_supplicant.conf这就是wpa_supplicant服务启动所需要的配置文件。</p>
<p>&lt;hardware/libhardware_legacy/wifi/wifi.c&gt;</p>
<p>int wifi_start_supplicant_common(const char *config_file)</p>
<p>{</p>
<p>……</p>
<p> if (ensure_config_file_exists(config_file) &lt; 0) {</p>
<p>  //在启动wpa_supplicant daemon服务之前，需要检查wpa_supplicant服务配置文件是否存在。</p>
<p>        LOGE(&quot;Wi-Fi will not be enabled&quot;);</p>
<p>        return -1;</p>
<p>    }</p>
<p>……</p>
<p>   property_get(&quot;wifi.interface&quot;, iface, WIFI_TEST_INTERFACE);</p>
<p>    snprintf(daemon_cmd, PROPERTY_VALUE_MAX, &quot;%s:-i%s -c%s&quot;, SUPPLICANT_NAME, iface, config_file);</p>
<p>    property_set(&quot;ctl.start&quot;, daemon_cmd);</p>
<p>    sched_yield();</p>
<p>……</p>
<p> }</p>
<p>通过将SUPPLICANT_NAME复制到daemon_cmd中，然后就可以ctl.start启动supplicant服务了，这个必须在系统启动的时候在init.rc中添加supplicant服务。</p>
<p>service wpa_supplicant /system/bin/wpa_supplicant -dd -i wlan0 -c/etc/wifi/wpa_supplicant.conf -Dnl80211</p>
<p>    class main</p>
<p>    socket wpa_wlan0 dgram 660 wifi wifi</p>
<p>    disabled</p>
<p>    oneshot</p>
<p>具体的wpa_supplicant的服务程序的代码在external/wpa_supplicant_8下面，以编译成libwpa_client.so和 libcutils等形式放在系统的库文件下面。wpa_supplicant具有配置和控制网络接口，加密功能，交互请求等。</p>
<p>3.WifiMonitor的启动过程</p>
<p>再回到之前WifiNative.startSupplicant中，如果wpa_supplicant在init.rc中有定义并且能够成功启动，就会开启WifiM</p>
<p>onitor进程。同时将wifi状态机切换到SupplicantStartingState的状态。</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt;</p>
<p>           if(WifiNative.startSupplicant()) {</p>
<p>                        if (DBG) log(&quot;Supplicant start successful&quot;);</p>
<p>                        mWifiMonitor.startMonitoring();</p>
<p>                        transitionTo(mSupplicantStartingState);</p>
<p>              ……</p>
<p>              }</p>
<p>     WifiMonitor是一个监视线程，负责从wpa_supplicant接收事件通知和把命令下达给wpa_supplicant。下面看看WifiMo</p>
<p>nitor的启动过程。</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiMonitor.java&gt;CMD_RESET_SUPPLICANT_STATE</p>
<p> public void startMonitoring() {</p>
<p>        new MonitorThread().start();</p>
<p>    }</p>
<p>    class MonitorThread extends Thread {</p>
<p>        public MonitorThread() {</p>
<p>            super(&quot;WifiMonitor&quot;);</p>
<p>        }</p>
<p>        public void run() {</p>
<p>            if (connectToSupplicant()) {</p>
<p>                // Send a message indicating that it is now possible to send commands</p>
<p>                // to the supplicant</p>
<p>                mStateMachine.sendMessage(SUP_CONNECTION_EVENT);</p>
<p>            } else {</p>
<p>                mStateMachine.sendMessage(SUP_DISCONNECTION_EVENT);</p>
<p>                return;</p>
<p>            }</p>
<p>            //noinspection InfiniteLoopStatement</p>
<p>            for (;;) {</p>
<p>                String eventStr = WifiNative.waitForEvent();</p>
<p>                // Skip logging the common but mostly uninteresting scan-results event</p>
<p>                if (false &amp;&amp; eventStr.indexOf(SCAN_RESULTS_STR) == -1) {</p>
<p>                    Log.d(TAG, &quot;Event [&quot; + eventStr + &quot;]&quot;);</p>
<p>                }</p>
<p>                if (!eventStr.startsWith(EVENT_PREFIX_STR)) {</p>
<p>                    if (eventStr.startsWith(WPA_EVENT_PREFIX_STR) &amp;&amp;</p>
<p>                            0 &lt; eventStr.indexOf(PASSWORD_MAY_BE_INCORRECT_STR)) {</p>
<p>                        mStateMachine.sendMessage(AUTHENTICATION_FAILURE_EVENT);</p>
<p>                    } else if (eventStr.startsWith(WPS_OVERLAP_STR)) {</p>
<p>                        mStateMachine.sendMessage(WPS_OVERLAP_EVENT);</p>
<p>上面的函数工作有点多，一个一个慢慢来，首先，connectToSupplicant()；在WifiMonitor中调用WifiNative.connectT</p>
<p>oSupplicant，这又调到了JNI。</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiMonitor.java&gt;</p>
<p> private boolean connectToSupplicant() {</p>
<p>            int connectTries = 0;</p>
<p>            while (true) {</p>
<p>                if (WifiNative.connectToSupplicant()) {</p>
<p>                    return true;</p>
<p>                }</p>
<p>                if (connectTries++ &lt; 5) {</p>
<p>                    nap(1);</p>
<p>                } else {</p>
<p>                    break;</p>
<p>                }</p>
<p>            }</p>
<p>            return false;</p>
<p>        }</p>
<p>继续上面代码，跑到JNI里面。</p>
<p>&lt;framework/base/core/jni/android_net_wifi_wifi.cpp&gt;</p>
<p>{ &quot;connectToSupplicant&quot;, &quot;()Z&quot;,  (void *)android_net_wifi_connectToSupplicant },</p>
<p>static jboolean android_net_wifi_connectToSupplicant(JNIEnv* env, jobject)</p>
<p>{</p>
<p>    return (jboolean)(::wifi_connect_to_supplicant() == 0);</p>
<p>}</p>
<p>又通过JNI调到wifi HAL层。</p>
<p>&lt;hardware/libhardware_legacy/wifi/wifi.c&gt;</p>
<p>int wifi_connect_to_supplicant()</p>
<p>{</p>
<p>……</p>
<p>ctrl_conn = wpa_ctrl_open(ifname);</p>
<p>……</p>
<p>monitor_conn = wpa_ctrl_open(ifname);</p>
<p>……</p>
<p>if (socketpair(AF_UNIX, SOCK_STREAM, 0, exit_sockets) == -1) {</p>
<p>        wpa_ctrl_close(monitor_conn);</p>
<p>        wpa_ctrl_close(ctrl_conn);</p>
<p>        ctrl_conn = monitor_conn = NULL;</p>
<p>        return -1;</p>
<p>    }</p>
<p>……</p>
<p>}</p>
<p>      java层通过connectToSupplicant调用wifi_connect_to_supplicant函数，在该函数中，将通过wpa_ctrl_open函数分别创建两个AF_UNIX地址族和数据报方式的socket，一个是ctrl_conn, 用于向wpa_supplicant发送命令并接收response, 另一个是monitor_conn, 它一直阻塞等待从wpa_supplicant过来的event。最后，通过monitor_conn向wpa_supplicant发送命令ATTACH，用于将自己的socket信息注册到wpa_supplicant, 由于socket是数据报方式的，这一步是必须的，对于存在于wpa_supplicant的服务器端，它是所有客户端共享的，由于它需要主动向monitor_conn客户端发送事件，所以它必须先记录下该客户端的详细信息，wpa_supplicant就可以将EVENT发向该socket。在完成上面这些操作后，java层会通过jni方式调用函数android_net_wifi_waitForEvent（应该是起一个线程，在线程里调用），该函数会调用wifi_wait_for_event，在wifi_wait_for_event函数里，会阻塞接收从wpa_supplicant模块传来的事件，一旦wpa_supplicant模块有事件发，wifi_wait_for_event接收到后，会将包含事件的buf通过函数参数的方式回传到java层，java收到事件后，再继续调用wifi_wait_for_event函数进行阻塞等待接收 private void handleNetworkStateChange(NetworkInfo.DetailedState newState, String data) {</p>
<p>，从而完成一个循环。</p>
<p>case WifiMonitor.SUP_CONNECTION_EVENT:</p>
<p>                    if (DBG) log(&quot;Supplicant connection established&quot;);</p>
<p>                    setWifiState(WIFI_STATE_ENABLED);</p>
<p>                    mSupplicantRestartCount = 0;</p>
<p>                    /* Reset the supplicant state to indicate the supplicant</p>
<p>                     * state is not known at this time */</p>
<p>                    mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);</p>
<p>                    mWpsStateMachine.sendMessage(CMD_RESET_WPS_STATE);</p>
<p>                    /* Initialize data structures */</p>
<p>                    mLastBssid = null;</p>
<p>                    mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;</p>
<p>                    mLastSignalLevel = -1;</p>
<p>SCAN_RESULTS_STR</p>
<p>                    mWifiInfo.setMacAddress(WifiNative.getMacAddressCommand());</p>
<p>                    WifiConfigStore.initialize(mContext);</p>
<p>                    sendSupplicantConnectionChangedBroadcast(true);</p>
<p>                    transitionTo(mDriverStartedState)</p>
<p>发送命令先重新设置supplicant服务的状态，然后通过JNI获取接口的物理地址。</p>
<p>4.DHCPCD服务的启动</p>
<p>在上面的WifiMonitor线程启动的过程中，会通过JNI的WifiNative.waitForEvent();当event为wpa_supplicant服务</p>
<p>CONNECTED。就会通过eventName.equals(CONNECTED_STR),然后在handle_event()函数中来启动dhcpcd服务。具体的代码流程：</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiMonitor.java&gt;</p>
<p>                int event;</p>
<p>                if (eventName.equals(CONNECTED_STR))</p>
<p>                    event = CONNECTED;</p>
<p>                ……</p>
<p>             void handleEvent(int event, String remainder) {</p>
<p>             switch (event) {</p>
<p>                case DISCONNECTED:</p>
<p>                    handleNetworkStateChange(NetworkInfo.DetailedState.DISCONNECTED, remainder);</p>
<p>                    break;</p>
<p>                case CONNECTED:</p>
<p>                    handleNetworkStateChange(NetworkInfo.DetailedState.CONNECTED, remainder);</p>
<p>                    break;</p>
<p>                 ……</p>
<p>   private void handleNetworkStateChange(NetworkInfo.DetailedState newState, String data) {</p>
<p>                   ……</p>
<p>                 notifyNetworkStateChange(newState, BSSID, networkId);</p>
<p> ……</p>
<p>           }</p>
<p>   void notifyNetworkStateChange(NetworkInfo.DetailedState newState, String BSSID, int netId) {</p>
<p>        if (newState == NetworkInfo.DetailedState.CONNECTED) {</p>
<p>            Message m = mStateMachine.obtainMessage(NETWORK_CONNECTION_EVENT,</p>
<p>                    netId, 0, BSSID);</p>
<p>            mStateMachine.sendMessage(m);</p>
<p>        } else {</p>
<p>            Message m = mStateMachine.obtainMessage(NETWORK_DISCONNECTION_EVENT,</p>
<p>                    netId, 0, BSSID);</p>
<p>            mStateMachine.sendMessage(m);</p>
<p>        }</p>
<p>    }</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt;</p>
<p>case WifiMonitor.NETWORK_CONNECTION_EVENT:</p>
<p>                    ……</p>
<p>                   setNetworkDetailedState(DetailedState.OBTAINING_IPADDR);</p>
<p>                    sendNetworkStateChangeBroadcast(mLastBssid);</p>
<p>                    transitionTo(mConnectingState);</p>
<p>……</p>
<p> class ConnectingState extends State {</p>
<p>        @Override</p>
<p>        public void enter() {</p>
<p>……</p>
<p>mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_START_DHCP)；</p>
<p>……</p>
<p>}</p>
<p>将wifi的状态机切换到ConnectingState，然后向Dhcp_statemachine发送CMD_START_DHCP。</p>
<p>&lt;framework/base/core/java/android/net/DhcpStateMachine.java&gt;</p>
<p>case CMD_START_DHCP:</p>
<p>                    if (mRegisteredForPreDhcpNotification) {</p>
<p>                        /* Notify controller before starting DHCP */</p>
<p>                        mController.sendMessage(CMD_PRE_DHCP_ACTION);</p>
<p>                        transitionTo(mWaitBeforeStartState);</p>
<p>……</p>
<p>}</p>
<p>&lt;framework/base/wifi/java/android/net/wifi/WifiStateMachine.java&gt;</p>
<p> case DhcpStateMachine.CMD_PRE_DHCP_ACTION:</p>
<p>                  mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_PRE_DHCP_ACTION_COMPLETE);</p>
<p>class WaitBeforeStartState extends State {</p>
<p>……</p>
<p>switch (message.what) {</p>
<p>                case CMD_PRE_DHCP_ACTION_COMPLETE:</p>
<p>                    if (runDhcp(DhcpAction.START)) {</p>
<p>                        transitionTo(mRunningState);</p>
<p>……</p>
<p>}</p>
<p>在runDhcp函数中，会根据你的interfaceName来申请开启DHCP服务，然后经由NetworkUtils的本地定义的JNI来真正的启动dhcp。</p>
<p>&lt;framework/base/core/java/android/net/DhcpStateMachine.java&gt;</p>
<p> private boolean runDhcp(DhcpAction dhcpAction) {</p>
<p>……</p>
<p> success = NetworkUtils.runDhcp(mInterfaceName, dhcpInfoInternal);</p>
<p>……</p>
<p>return success；</p>
<p>}</p>
<p> &lt;framework/base/core/jni/android_net_NetUtils.cpp&gt;</p>
<p>{ &quot;runDhcp&quot;, &quot;(Ljava/lang/String;Landroid/net/DhcpInfoInternal;)Z&quot;,  (void *)android_net_utils_runDhcp }</p>
<p>……</p>
<p>static jboolean android_net_utils_runDhcpCommon(JNIEnv* env, jobject clazz, jstring ifname,</p>
<p>  jobject info, bool renew)</p>
<p>{</p>
<p>……</p>
<p> result = ::dhcp_do_request(nameStr, ipaddr, gateway, &amp;prefixLength,</p>
<p>dns1, dns2, server, &amp;lease);</p>
<p>……</p>
<p>}</p>
<p>&lt;/system/core/libnetutils/dhcp_utils.c&gt;</p>
<p>int dhcp_do_request(const char *interface,</p>
<p>char *ipaddr,</p>
<p> char *gateway,</p>
<p>uint32_t *prefixLength,</p>
<p> char *dns1,</p>
<p>  char *dns2,</p>
<p>char *server, uint32_t  *lease)</p>
<p>{</p>
<p>……</p>
<p>property_set(ctrl_prop, daemon_cmd);</p>
<p>……</p>
<p>}</p>
<p>这里的daemon_cmd是dhcpcd，同样在init.rc中要dhcpcd的服务存在，否则dhcpcd服务启动失败。该service在init.</p>
<p>Rc中的写法。</p>
<p>service dhcpcd_wlan0 /system/bin/dhcpcd -f /system/etc/dhcpcd/dhcpcd.conf</p>
<p>    class main</p>
<p>    disabled</p>
<p>    oneshot</p>
<p>具体的dhcpcd的代码部分在external下面的dhcp文件下面，以可执行文件和库文件方式运行。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android LCD(三)：Samsung LCD接口篇</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20LCD(%E4%B8%89)%EF%BC%9ASamsung%20LCD%E6%8E%A5%E5%8F%A3%E7%AF%87/</url>
    <content><![CDATA[<p>参考：S5PV210显示驱动分析与移植（android）<br>这篇文章中转载的成分比较多，不过大部分内容是从芯片手册上翻译过来。Framebuffer部分是黄冈老师–《嵌入式Linux之我行》这一系列博客中的，嵌入式Linux之我行这系列博客写的非常精，我刚学习Linux时经常拜读他的博客。这部分内容比较固定，三星的芯片跟新了好多代，不过这部分变化不大，技术是一个积累的过程，感谢那些前辈给我们整理比较好的学习资料，有比较好的技术继承。<br>这篇从LCD控制器、接口信号硬件接口 寄存器、Framebuffer 、接口函数的实现及寄存器的操作来讲解，同事补充两个知点：如何阅读LCD、PWM概述；</p>
<p>一、     LCD控制器<br>功能模块的实现其实是芯片里面集成了一个相应的控制器，比如IIC有IIC控制器，UART有UART控制器等，像其他功能模块一样LCD也有一个控制器，来实现图形信息的处理。LCD控制器可以通过编程支持不同LCD屏的要求，例如行和列像素数，数据总线宽度，接口时序和刷新频率等。LCD控制器的主要作用，是将定位在系统存储器中的显示缓冲区中的LCD图像数据传送到外部LCD驱动器，并产生必要的控制信号，例如RGB_VSYNC,RGB_HSYNC, RGB_VCLK等。<br>如下图所示，在Exynos4412规格书中截图，LCD控制器的构成。</p>
<p>（下面这部分来自网络翻译，规格书中的描述）</p>
<p>主要由VSFR,VDMA, VPRCS , VTIME和视频时钟产生器几个模块组成：</p>
<p>（1）、VSFR由121个可编程控制器组，一套gamma LUT寄存器组（包括64个寄存器），一套i80命令寄存器组（包括12个寄存器）和5块256*32调色板存储器组成，主要用于对lcd控制器进行配置。</p>
<p>（2）、VDMA是LCD专用的DMA传输通道，可以自动从系统总线上获取视频数据传送到VPRCS，无需CPU干涉。</p>
<p>（3）、VPRCS收到数据后组成特定的格式（如16bpp或24bpp），然后通过数据接口（RGB_VD, VEN_VD, V656_VD or SYS_VD）传送到外部LCD屏上。</p>
<p>（4）、VTIME模块由可编程逻辑组成，负责不同lcd驱动器的接口时序控制需求。VTIME模块产生 RGB_VSYNC, RGB_HSYNC, RGB_VCLK, RGB_VDEN,VEN_VSYNC等信号。</p>
<p>主要特性：</p>
<p>（1）、支持4种接口类型：RGB/i80/ITU 601(656)/YTU444<br>（2）、支持单色、4级灰度、16级灰度、256色的调色板显示模式<br>（3）、支持64K和16M色非调色板显示模式<br>（4）、支持多种规格和分辨率的LCD<br>（5）、虚拟屏幕最大可达16MB<br>（6）、5个256*32位调色板内存<br>（7）、支持透明叠加<br>二、接口信号<br>FIMD显示控制器全部信号定义如下所示</p>
<p>Signal</p>
<p>I/O</p>
<p>Description</p>
<p>LCD Type</p>
<p>LCD_HSYNC</p>
<p>O</p>
<p>水平同步信号</p>
<p>RGB I/F</p>
<p>LCD_VSYNC</p>
<p>O</p>
<p>垂直同步信号</p>
<p>LCD_VDEN</p>
<p>O</p>
<p>数据使能</p>
<p>LCD_VCLK</p>
<p>O</p>
<p>视频时钟</p>
<p>LCD_VD[23:0]</p>
<p>O</p>
<p>LCD像素数据输出</p>
<p>SYS_OE</p>
<p>O</p>
<p>输出使能</p>
<p>VSYNC_LDI</p>
<p>O</p>
<p>Indirect i80接口，垂直同步信号</p>
<p>i80 I/F</p>
<p>SYS_CS0</p>
<p>O</p>
<p>Indirect i80接口，片选LCD0</p>
<p>SYS_CS1</p>
<p>O</p>
<p>Indirect i80接口，片选LCD1</p>
<p>SYS_RS</p>
<p>O</p>
<p>Indirect i80接口，寄存器选择信号</p>
<p>SYS_WE</p>
<p>O</p>
<p>Indirect i80接口，写使能信号</p>
<p>SYS_VD[23:0]</p>
<p>IO</p>
<p>Indirect i80接口，视频数据输入输出</p>
<p>SYS_OE</p>
<p>O</p>
<p>Indirect i80接口，输出使能信号</p>
<p>VEN_HSYNC</p>
<p>O</p>
<p>601接口水平同步信号</p>
<p>ITU 601/656 I/F</p>
<p>VEN_VSYNC</p>
<p>O</p>
<p>601接口垂直同步信号</p>
<p>VEN_HREF</p>
<p>O</p>
<p>601接口数据使能</p>
<p>V601_CLK</p>
<p>O</p>
<p>601接口数据时钟</p>
<p>VEN_DATA[7:0]</p>
<p>O</p>
<p>601接口YUV422格式数据输出</p>
<p>V656_DATA[7:0]</p>
<p>O</p>
<p>656接口YUV422格式数据输出</p>
<p>V656_CLK</p>
<p>O</p>
<p>656接口数据时钟</p>
<p>VEN_FIELD</p>
<p>O</p>
<p>601接口域信号</p>
<p>1、其中主要的RGB接口信号：<br>（1）、LCD_HSYNC:行同步信号，表示一行数据的开始，LCD控制器在整个水平线（整行）数据移入LCD驱动器后，插入一个LCD_HSYNC信号；<br>（2）、LCD_VSYNC: 帧同步信号，表示一帧数据的开始，LCD控制器在一个完整帧显示完成后立即插入一个LCD_VSYNC信号，开始新一帧的显示；VSYNC信号出现的频率表示一秒钟内能显示多少帧图像，称为“显示器的频率”<br>（3）、LCD_VCLK：像素时钟信号，表示正在传输一个像素的数据；<br>（4）、LCD_VDEN:数据使能信号；<br>（5）、 LCD_VD[23:0]: LCD像素数据输出端口<br>2、RGB信号的时序<br>下图是LCDRGB接口工作时序图：</p>
<p>（1）、上面时序图上各时钟延时参数的含义如下：这些配置可以在LCD规格书中查取</p>
<p>VBPD(vertical back porch)：表示在一帧图像开始时，垂直同步信号以后的无效的行数</p>
<p>VFBD(vertical front porch)：表示在一帧图像结束后，垂直同步信号以前的无效的行数VSPW(vertical sync pulse width)：表示垂直同步脉冲的宽度，用行数计算</p>
<p>HBPD(horizontal back porch)：表示从水平同步信号开始到一行的有效数据开始之间的VCLK的个数HFPD(horizontal front porth)：表示一行的有效数据结束到下一个水平同步信号开始之间的VCLK的个数</p>
<p>HSPW(horizontal sync pulse width)：表示水平同步信号的宽度，用VCLK计算<br>（2）、帧的传输过程<br>VSYNC信号有效时，表示一帧数据的开始，   信号宽度为（VSPW +1）个HSYNC信号周期，即（VSPW +1）个无效行；</p>
<p>VSYNC信号脉冲之后，总共还要经过（VBPD+ 1）个HSYNC信号周期，有效的行数据才出现； 所以，在VSYNC信号有效之后，还要经过（VSPW +1  + VBPD + 1）个无效的行；</p>
<p>随即发出（LINEVAL + 1）行的有效数据；</p>
<p>最后是（VFPD + 1）个无效的行；</p>
<p>（3）、行中像素数据的传输过程<br>HSYNC信号有效时，表示一行数据的开始，信号宽度为（HSPW+ 1）个VCLK信号周期，即（HSPW +1）个无效像素；<br>HSYNC信号脉冲之后，还要经过（HBPD +1）个VCLK信号周期，有效的像素数据才出现；<br>随后发出（HOZVAL+ 1）个像素的有效数据；<br>最后是（HFPD +1）个无效的像素；<br>（4）、将VSYNC、HSYNC、VCLK等信号的时间参数设置好之后，并将帧内存的地址告诉LCD控制器，它即可自动地发起DMA传输从帧内存中得到图像数据，最终在上述信号的控制下出现在数据总线VD[23:0]上。用户只需要把要显示的图像数据写入帧内存中。<br>       其实现实的图像有像素点主城行、行组成场、场组成动画、动画叠加也就是3D的出现，也就是我们所说的“点动成线、线动成面、面动成体”。</p>
<p>三、LCD的硬件接口</p>
<p>1、16M（24BPP）色的显示模式</p>
<p>用24位的数据来表示一个像素的颜色，每种颜色使用8位。 LCD控制器从内存中获得某个像素的24为颜色值后，直接通过VD[23:0]数据线发送给LCD；在内存中，使用4个字节（32位）来表示一个像素，其中的3个字节从高到低分别表示红、绿、蓝，剩余的1个字节无效；<br>2、64K（16BPP）色的显示模式<br>用16位的数据来表示一个像素的颜色；格式又分为两种： 5：6：5 ——使用5位来表示红色，6位表示绿色，5位表示蓝色 ； 5：5：5：1——分别使用5位来表示红、绿、蓝，最后一位表示透明度；    <br>3、16BPP<br>4、serialRGB<br>不同的BPP接线方式如下所示：</p>
<p>四、寄存器<br>主要寄存器如下：<br>VIDCON0:配置视频输出格式，显示使能<br>VIDCON1:RGB 接口控制信号<br>VIDCON2: 输出数据格式控制<br>VIDCON3: 图像增强控制<br>I80IFCONx:i80接口控制信号<br>ITUIFCON: ITU接口控制信号<br>VIDTCONx:配置视频输出时序及显示大小<br>WINCONx:每个窗口特性设置<br>VIDOSDxA,B: 窗口位置设置</p>
<p>VIDOSDxC,D:OSD大小设置</p>
<p>五、Framebuffer驱动部分<br>这部分是：分析的比较好，我刚学linux的时候就拿个mini2440的板子对着他的博客练习)。其实这部分也是博主从S3c2440上分析的，三星芯片更新了这么多代，这块的原理还是不变的。就像一些协议一样，这么多年基本上不会变化，唯一出现的结果就是出来新的接口替代。LCD这块就是：TTL、LVDS、EDP、MIPI、HDMI等等…………速度更快，接线、PCB走线更简单，这就是集成化的好处。<br>1、简介<br>帧缓冲是Linux为显示设备提供的一个接口，它把一些显示设备描述成一个缓冲区，允许应用程序通过FrameBuffer定义好的接口访问这些图形设备，从而不用去关心具体的硬件细节。对于帧缓冲设备而言，只要在显示缓冲区与显示点对应的区域写入颜色值，对应的颜色就会自动的在屏幕上显示。下面来看一下在不同色位模式下缓冲区与显示点的对应关系：</p>
<p>2、驱动结构<br>帧缓冲设备为标准的字符型设备，在Linux中主设备号29，定义在/linux/major.h中的FB_MAJOR，次设备号定义帧缓冲的个数，最大允许有32个FrameBuffer，定义在/include/linux/fb.h中的FB_MAX，对应于文件系统下/dev/fb%d设备文件。<br>帧缓冲设备驱动在Linux子系统中的结构如下：</p>
<p>我们从上面这幅图看，帧缓冲设备在Linux中也可以看做是一个完整的子系统，大体由fbmem.c和xxxfb.c（对应我们的s3cfb.c）组成。向上给应用程序提供完善的设备文件操作接口(即对FrameBuffer设备进行read、write、ioctl等操作)，接口在Linux提供的fbmem.c文件中实现；向下提供了硬件操作的接口，只是这些接口Linux并没有提供实现，因为这要根据具体的LCD控制器硬件进行设置，所以这就是我们要做的事情了(即s3cfb.c部分的实现)。<br>3、数据结构及接口函数<br>从帧缓冲设备驱动程序结构看，该驱动主要跟fb_info结构体有关，该结构体记录了帧缓冲设备的全部信息，包括设备的设置参数、状态以及对底层硬件操作的函数指针。在Linux中，每一个帧缓冲设备都必须对应一个fb_info，fb_info在/linux/fb.h中的定义如下：(只列出重要的一些) </p>
<p>[cpp] view plain copy</p>
<p>struct fb_info {  </p>
<p>int node;  </p>
<p>int flags;  </p>
<p>struct fb_var_screeninfo var;/<em>LCD可变参数结构体</em>/  </p>
<p>struct fb_fix_screeninfo fix;/<em>LCD固定参数结构体</em>/  </p>
<p>struct fb_monspecs monspecs; /<em>LCD显示器标准</em>/  </p>
<p>struct work_struct queue;    /<em>帧缓冲事件队列</em>/  </p>
<p>struct fb_pixmap pixmap;     /<em>图像硬件mapper</em>/  </p>
<p>struct fb_pixmap sprite;     /<em>光标硬件mapper</em>/  </p>
<p>struct fb_cmap cmap;         /<em>当前的颜色表</em>/  </p>
<p>struct fb_videomode *mode;   /<em>当前的显示模式</em>/  </p>
<p>#ifdef CONFIG_FB_BACKLIGHT  </p>
<p>struct backlight_device *bl_dev;/<em>对应的背光设备</em>/  </p>
<p>struct mutex bl_curve_mutex;  </p>
<p>    u8 bl_curve[FB_BACKLIGHT_LEVELS];/<em>背光调整</em>/  </p>
<p>#endif  </p>
<p>#ifdef CONFIG_FB_DEFERRED_IO  </p>
<p>struct delayed_work deferred_work;  </p>
<p>struct fb_deferred_io *fbdefio;  </p>
<p>#endif  </p>
<p>struct fb_ops *fbops; /<em>对底层硬件操作的函数指针</em>/  </p>
<p>struct device *device;  </p>
<p>struct device *dev;   /<em>fb设备</em>/  </p>
<p>int class_flag;      </p>
<p>#ifdef CONFIG_FB_TILEBLITTING  </p>
<p>struct fb_tile_ops *tileops; /<em>图块Blitting</em>/  </p>
<p>#endif  </p>
<p>char __iomem *screen_base;   /<em>虚拟基地址</em>/  </p>
<p>    unsigned long screen_size;   /<em>LCD IO映射的虚拟内存大小</em>/   </p>
<p>void *pseudo_palette;        /<em>伪16色颜色表</em>/   </p>
<p>#define FBINFO_STATE_RUNNING    0  </p>
<p>#define FBINFO_STATE_SUSPENDED  1  </p>
<p>    u32 state;  /<em>LCD的挂起或恢复状态</em>/  </p>
<p>void *fbcon_par;  </p>
<p>void *par;      </p>
<p>};  </p>
<p>其中，比较重要的成员有struct fb_var_screeninfo var、structfb_fix_screeninfo fix和struct fb_ops *fbops，他们也都是结构体。<br>fb_var_screeninfo结构体主要记录用户可以修改的控制器的参数，比如屏幕的分辨率和每个像素的比特数等，该结构体定义如下：</p>
<p>[cpp] view plain copy</p>
<p>struct fb_var_screeninfo {  </p>
<p>    __u32 xres;                /<em>可见屏幕一行有多少个像素点</em>/  </p>
<p>    __u32 yres;                /<em>可见屏幕一列有多少个像素点</em>/  </p>
<p>    __u32 xres_virtual;        /<em>虚拟屏幕一行有多少个像素点</em>/          </p>
<p>    __u32 yres_virtual;        /<em>虚拟屏幕一列有多少个像素点</em>/  </p>
<p>    __u32 xoffset;             /<em>虚拟到可见屏幕之间的行偏移</em>/  </p>
<p>    __u32 yoffset;             /<em>虚拟到可见屏幕之间的列偏移</em>/  </p>
<p>    __u32 bits_per_pixel;      /<em>每个像素的位数即BPP</em>/  </p>
<p>    __u32 grayscale;           /<em>非0时，指的是灰度</em>/  </p>
<p>struct fb_bitfield red;    /<em>fb缓存的R位域</em>/  </p>
<p>struct fb_bitfield green;  /<em>fb缓存的G位域</em>/  </p>
<p>struct fb_bitfield blue;   /<em>fb缓存的B位域</em>/  </p>
<p>struct fb_bitfield transp; /<em>透明度</em>/      </p>
<p>    __u32 nonstd;              /* != 0 非标准像素格式*/  </p>
<p>    __u32 activate;                  </p>
<p>    __u32 height;              /<em>高度</em>/  </p>
<p>    __u32 width;               /<em>宽度</em>/  </p>
<p>    __u32 accel_flags;      </p>
<p>/<em>定时：除了pixclock本身外，其他的都以像素时钟为单位</em>/  </p>
<p>    __u32 pixclock;            /<em>像素时钟(皮秒)</em>/  </p>
<p>    __u32 left_margin;         /<em>行切换，从同步到绘图之间的延迟</em>/  </p>
<p>    __u32 right_margin;        /<em>行切换，从绘图到同步之间的延迟</em>/  </p>
<p>    __u32 upper_margin;        /<em>帧切换，从同步到绘图之间的延迟</em>/  </p>
<p>    __u32 lower_margin;        /<em>帧切换，从绘图到同步之间的延迟</em>/  </p>
<p>    __u32 hsync_len;           /<em>水平同步的长度</em>/  </p>
<p>    __u32 vsync_len;           /<em>垂直同步的长度</em>/  </p>
<p>    __u32 sync;  </p>
<p>    __u32 vmode;  </p>
<p>    __u32 rotate;  </p>
<p>    __u32 reserved[5];         /<em>保留</em>/  </p>
<p>};   </p>
<p>而fb_fix_screeninfo结构体又主要记录用户不可以修改的控制器的参数，比如屏幕缓冲区的物理地址和长度等，该结构体的定义如下：</p>
<p>[cpp] view plain copy</p>
<p>struct fb_fix_screeninfo {  </p>
<p>char id[16];                /*字符串形式的标示符 */  </p>
<p>    unsigned long smem_start;   /*fb缓存的开始位置 */  </p>
<p>    __u32 smem_len;             /*fb缓存的长度 */  </p>
<p>    __u32 type;                 /<em>看FB_TYPE_</em> */  </p>
<p>    __u32 type_aux;             /<em>分界</em>/  </p>
<p>    __u32 visual;               /<em>看FB_VISUAL_</em> */   </p>
<p>    __u16 xpanstep;             /*如果没有硬件panning就赋值为0 */  </p>
<p>    __u16 ypanstep;             /*如果没有硬件panning就赋值为0 */  </p>
<p>    __u16 ywrapstep;            /*如果没有硬件ywrap就赋值为0 */  </p>
<p>    __u32 line_length;          /*一行的字节数 */  </p>
<p>    unsigned long mmio_start;   /<em>内存映射IO的开始位置</em>/  </p>
<p>    __u32 mmio_len;             /<em>内存映射IO的长度</em>/  </p>
<p>    __u32 accel;  </p>
<p>    __u16 reserved[3];          /<em>保留</em>/  </p>
<p>};  </p>
<p>fb_ops结构体是对底层硬件操作的函数指针，该结构体中定义了对硬件的操作有:(这里只列出了常用的操作) </p>
<p>[cpp] view plain copy</p>
<p>struct fb_ops {  </p>
<p>struct module *owner;  </p>
<p>//检查可变参数并进行设置  </p>
<p>int (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info);  </p>
<p>//根据设置的值进行更新，使之有效  </p>
<p>int (*fb_set_par)(struct fb_info *info);  </p>
<p>//设置颜色寄存器  </p>
<p>int (*fb_setcolreg)(unsigned regno, unsigned red, unsigned green,  </p>
<p>             unsigned blue, unsigned transp, struct fb_info *info);  </p>
<p>//显示空白  </p>
<p>int (*fb_blank)(int blank, struct fb_info *info);  </p>
<p>//矩形填充  </p>
<p>void (*fb_fillrect) (struct fb_info *info, const struct fb_fillrect *rect);  </p>
<p>//复制数据  </p>
<p>void (*fb_copyarea) (struct fb_info *info, const struct fb_copyarea *region);  </p>
<p>//图形填充  </p>
<p>void (*fb_imageblit) (struct fb_info *info, const struct fb_image *image);  </p>
<p>}；  </p>
<p>六、Framebuffer设备注册<br>S3cfb.c中的s3cfb_probe设备探测，是驱动注册的主要函数，</p>
<p>/<em>定义一个结构体用来维护驱动程序中各函数中用到的变量<br>先别看结构体要定义这些成员，到各函数使用的地方就明白了</em>/</p>
<p>[cpp] view plain copy</p>
<p>static int __devinit s3cfb_probe(struct platform_device *pdev)  </p>
<p>{  </p>
<p>struct s3c_platform_fb *pdata;/<em>LCD屏配置信息结构体</em>/  </p>
<p>struct s3cfb_global *fbdev;/<em>驱动程序全局变量结构体</em>/  </p>
<p>struct resource *res; /<em>用来保存从LCD平台设备中获取的LCD资源</em>/  </p>
<p>int i, j, ret = 0;  </p>
<p>    printk(&quot;%s\n&quot;,<strong>func</strong>);  </p>
<p>    fbdev = kzalloc(sizeof(struct s3cfb_global), GFP_KERNEL);  </p>
<p>if (!fbdev) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to allocate for &quot;  </p>
<p>&quot;global fb structure\n&quot;);  </p>
<p>        ret = -ENOMEM;  </p>
<p>goto err_global;  </p>
<p>    }  </p>
<p>    fbdev-&gt;dev = &amp;pdev-&gt;dev;  </p>
<p>    fbdev-&gt;regulator = regulator_get(&amp;pdev-&gt;dev, &quot;pd&quot;);  </p>
<p>if (!fbdev-&gt;regulator) {  </p>
<p>        dev_err(fbdev-&gt;dev, &quot;failed to get regulator\n&quot;);  </p>
<p>        ret = -EINVAL;  </p>
<p>goto err_regulator;  </p>
<p>    }  </p>
<p>    ret = regulator_enable(fbdev-&gt;regulator);  </p>
<p>if (ret &lt; 0) {  </p>
<p>        dev_err(fbdev-&gt;dev, &quot;failed to enable regulator\n&quot;);  </p>
<p>        ret = -EINVAL;  </p>
<p>goto err_regulator;  </p>
<p>    }  </p>
<p>/<em>获取LCD参数信息</em>/  </p>
<p>    pdata = to_fb_plat(&amp;pdev-&gt;dev);  </p>
<p>if (!pdata) {  </p>
<p>        dev_err(fbdev-&gt;dev, &quot;failed to get platform data\n&quot;);  </p>
<p>        ret = -EINVAL;  </p>
<p>goto err_pdata;  </p>
<p>    }  </p>
<p>    fbdev-&gt;lcd = (struct s3cfb_lcd *)pdata-&gt;lcd;  </p>
<p>/<em>配置GPIO端口</em>/  </p>
<p>if (pdata-&gt;cfg_gpio)  </p>
<p>        pdata-&gt;cfg_gpio(pdev);  </p>
<p>/<em>设置时钟参数</em>/  </p>
<p>if (pdata-&gt;clk_on)  </p>
<p>        pdata-&gt;clk_on(pdev, &amp;fbdev-&gt;clock);  </p>
<p>/<em>获取LCD平台设备所使用的IO端口资源，注意这个IORESOURCE_MEM标志和LCD平台设备定义中的一致</em>/  </p>
<p>    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);  </p>
<p>if (!res) {  </p>
<p>        dev_err(fbdev-&gt;dev, &quot;failed to get io memory region\n&quot;);  </p>
<p>        ret = -EINVAL;  </p>
<p>goto err_io;  </p>
<p>    }  </p>
<p>/<em>申请LCD IO端口所占用的IO空间(注意理解IO空间和内存空间的区别),request_mem_region定义在ioport.h中</em>/  </p>
<p>    res = request_mem_region(res-&gt;start,  </p>
<p>                 res-&gt;end - res-&gt;start + 1, pdev-&gt;name);  </p>
<p>if (!res) {  </p>
<p>        dev_err(fbdev-&gt;dev, &quot;failed to request io memory region\n&quot;);  </p>
<p>        ret = -EINVAL;  </p>
<p>goto err_io;  </p>
<p>    }  </p>
<p>/*将LCD的IO端口占用的这段IO空间映射到内存的虚拟地址，ioremap定义在io.h中 </p>
<p>         注意：IO空间要映射后才能使用，以后对虚拟地址的操作就是对IO空间的操作*/  </p>
<p>    fbdev-&gt;regs = ioremap(res-&gt;start, res-&gt;end - res-&gt;start + 1);  </p>
<p>if (!fbdev-&gt;regs) {  </p>
<p>        dev_err(fbdev-&gt;dev, &quot;failed to remap io region\n&quot;);  </p>
<p>        ret = -EINVAL;  </p>
<p>goto err_mem;  </p>
<p>    }  </p>
<p>#ifdef CONFIG_FB_S3C_LTE480WV  </p>
<p>/<em>设置寄存器初始状态</em>/  </p>
<p>    s3cfb_pre_init_para(fbdev);   </p>
<p>#endif  </p>
<p>/<em>设置gamma 值</em>/   </p>
<p>    s3cfb_set_gamma(fbdev);  </p>
<p>/<em>设置VSYNC中断</em>/  </p>
<p>    s3cfb_set_vsync_interrupt(fbdev, 1);  </p>
<p>/<em>设置全局中断</em>/  </p>
<p>    s3cfb_set_global_interrupt(fbdev, 1);  </p>
<p>/<em>fb设备参数信息初始化</em>/  </p>
<p>    s3cfb_init_global(fbdev);  </p>
<p>/<em>为framebuffer分配空间，进行内存映射，填充fb_info</em>/  </p>
<p>if (s3cfb_alloc_framebuffer(fbdev)) {  </p>
<p>        ret = -ENOMEM;  </p>
<p>goto err_alloc;  </p>
<p>    }  </p>
<p>/<em>注册fb设备到系统中</em>/  </p>
<p>if (s3cfb_register_framebuffer(fbdev)) {  </p>
<p>        ret = -EINVAL;  </p>
<p>goto err_register;  </p>
<p>    }  </p>
<p>    s3cfb_set_clock(fbdev);  </p>
<p>    s3cfb_set_window(fbdev, pdata-&gt;default_win, 1);  </p>
<p>    s3cfb_display_on(fbdev);  </p>
<p>    fbdev-&gt;irq = platform_get_irq(pdev, 0);  </p>
<p>if (request_irq(fbdev-&gt;irq, s3cfb_irq_frame, IRQF_SHARED,  </p>
<p>            pdev-&gt;name, fbdev)) {  </p>
<p>        dev_err(fbdev-&gt;dev, &quot;request_irq failed\n&quot;);  </p>
<p>        ret = -EINVAL;  </p>
<p>goto err_irq;  </p>
<p>    }  </p>
<p>#ifdef CONFIG_FB_S3C_LCD_INIT  </p>
<p>if (pdata-&gt;backlight_on)  </p>
<p>        pdata-&gt;backlight_on(pdev);  </p>
<p>if (!bootloaderfb &amp;&amp; pdata-&gt;reset_lcd)  </p>
<p>        pdata-&gt;reset_lcd(pdev);  </p>
<p>if (pdata-&gt;lcd_on)  </p>
<p>        pdata-&gt;lcd_on(pdev);  </p>
<p>#endif  </p>
<p>#ifdef CONFIG_HAS_EARLYSUSPEND  </p>
<p>    fbdev-&gt;early_suspend.suspend = s3cfb_early_suspend;  </p>
<p>    fbdev-&gt;early_suspend.resume = s3cfb_late_resume;  </p>
<p>    fbdev-&gt;early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB;  </p>
<p>    register_early_suspend(&amp;fbdev-&gt;early_suspend);  </p>
<p>#endif  </p>
<p>/<em>对设备文件系统的支持，创建fb设备文件</em>/  </p>
<p>    ret = device_create_file(&amp;(pdev-&gt;dev), &amp;dev_attr_win_power);  </p>
<p>if (ret &lt; 0)  </p>
<p>        dev_err(fbdev-&gt;dev, &quot;failed to add sysfs entries\n&quot;);  </p>
<p>    dev_info(fbdev-&gt;dev, &quot;registered successfully\n&quot;);  </p>
<p>/<em>显示开机logo</em>/  </p>
<p>#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) &amp;&amp; defined(CONFIG_LOGO)  </p>
<p>if (fb_prepare_logo( fbdev-&gt;fb[pdata-&gt;default_win], FB_ROTATE_UR)) {  </p>
<p>        printk(&quot;Start display and show logo\n&quot;);  </p>
<p>/* Start display and show logo on boot */  </p>
<p>        fb_set_cmap(&amp;fbdev-&gt;fb[pdata-&gt;default_win]-&gt;cmap, fbdev-&gt;fb[pdata-&gt;default_win]);  </p>
<p>        fb_show_logo(fbdev-&gt;fb[pdata-&gt;default_win], FB_ROTATE_UR);  </p>
<p>    }  </p>
<p>#endif  </p>
<p>return 0;  </p>
<p>}  </p>
<p>七、如何阅读LCD规格书<br>首先我们调试LCD的时候要获得的一些参数，没必要把整个规格书通读一遍，我刚开始调试屏的时候拿到一个规格书不知道从何入手，也不知那些参数有用，比较模糊，其实只提取一些有用的信息就可以，下面这些对初学者也许有点用处。</p>
<p>1、GeneralSpecification<br>尺寸、分辨率、位数、色彩、像素时钟频率、接口类型<br>（1）、尺寸：</p>
<p>（2）、分辨率：1920 1200；</p>
<p>（3）、接口：双通道LVDS；</p>
<p>（4）、色彩：16.7M，这里可以确认数据位数8bitRGB三色：3*8=24，2的24次方=16.7M</p>
<p>6bitRGB 三色：3*6=18，2的18次方=262 144;</p>
<p>所以当看到色彩是1.7M是，说明LCD是24bit的，如果是262 144（26M）说明LCD是18bit的。</p>
<p>2、Timing Characteristics</p>
<p>（1）、Frame rate :是60HZ，也就是帧率；<br>（2）、clock frequency:像素时钟，这里面有最大值、中间值和最小值，这个屏默认值为：76.36MHz；<br>（3）、Vertical Seciton：VSWidth +Back Porc+Front Porch，前间距、后间距。这个我们再RGB信号哪里详细解释，这个我们前面有说过；<br>（4）、Horizontal Section：HS Width +Back Porc+Front Porch，这个跟VS的Porch相同。</p>
<p>3、LCD  Timing diagram信号时序图，如下所示</p>
<p>有些读者会问，为什么没有行、场、数据等信号。其实这个是LVDS信号的时序，这个根据屏厂的习惯，有的画的是LVDS输入的信号时序，有的是TTL（RGB）的时序。</p>
<p>上面我们以一个例子说明，做驱动的（软件方面）要知道的一些参数，如果是硬件方面的问题，可以再对一下接口。其实一个LCD规格书要了解的也就这么多，调试软件就够用：<br>（1）、General Specification中可得到，尺寸、分辨率、位数、色彩、像素时钟频率、接口类型；<br>（2）、Timing Characteristics中可以得到一些具体的参数；<br>（3）、LCD  Timing diagram信号时序图，可以看到一些信号的时序、极性等；</p>
<p>八、PWM概述<br>1、先解释两个名词：<br>PWM：脉冲宽度调制(PWM)，是英文“Pulse WidthModulation”的缩写，简称脉宽调制。<br>占空比：占空比(DutyRation)在电信领域中有如下含义：<br>在一串理想的脉冲周期序列中（如方波），正脉冲的持续时间与脉冲总周期的比值。例如：（假设脉冲为3V）<br>脉冲宽度 1μs，信号周期4μs的脉冲序列占空比为0.25，平均电压为：3*0.25=0.75V；<br>脉冲宽度 0μs，信号周期4μs的脉冲序列占空比为0，平均电压为：0V；<br>脉冲宽度 4μs，信号周期4μs的脉冲序列占空比为1，平均电压为：3V；</p>
<p>平均电压的变化成阶梯型变化，如果T足够小，成线性。</p>
<p>看下芯片片规格书中的描述：寄存器填不同值是，脉冲宽度不一样。</p>
<p>2、samusng 中的PWM控制器</p>
<p>PWM时钟分频。跟单片机里面的有点像。死区控制器：这个是根据晶体管的特性，设置这个功能的，不过我工作中还没有用到死区控制这块。了解有这个概念。</p>
<p>看这些寄存器，记得用MINI2440写裸机程序的时候，直接写这些寄存器，记得上学时把s3c2440当单片机玩，有点浪费。学生时代，已经逝去的青春？？</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android LCD(四)：LCD驱动调试篇</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20LCD(%E5%9B%9B)%EF%BC%9ALCD%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95%E7%AF%87/</url>
    <content><![CDATA[<p>内核：linux2.6/linux3.0<br>系统：android/android4.0 <br>平台：samsung exynos 4210、exynos 4412 、exynos 5250</p>
<p>这篇我们以一个实例来说明,Samsung Exynos4412搭配TTL转LVDS芯片SN75LVDS83B、LVDS接口LCD为例说明。从硬件接口、驱动配置、背光PWM调节三部分说明。</p>
<p>一、LCD接口原理以及硬件电路<br>Samsung Exynos4412、SN75LVDS83B、LVDS接口LCD（24bit）为例说明，三者的关系如下：</p>
<p>如上图所示，我们在应用中我，主控（Exynos4412）输出RGB信号到TFT-LCD大体经过三部分：<br>（1）、标号1部分，主控（Exynos4412）输出TTL信号；<br>（2）、标号2部分，TTL（RGB）-LVDS转换芯片SN75LVDS83B,把ＴＴＬ信号转换成LVDS信号，传输到显示器的LVDS接收端；这部分有SN75LVDS83B编码芯片自动完成，所以我们不需要程序控制；<br>（3）、标号3部分，分两个小部分，LVDS转换成TTL，TFT-LCD显示部分；我们前面说过，TFT-LCD其实只识别TTL信号，所以要有一个转换的过程，先把LVDS信号转换、解码成TTL信号，在TFT-LCD上显示。<br>有上面的过程，其实我们关心调试的部分只有标号1部分到标号2部分，后面标号2到标号3的部分是自动完成的，不需要我们程序上控制，把标号2部分、标号3部分合并：</p>
<p>标号二部分可以理解为一个TTL（RGB）接口的LCD,如下图所示，标号一部分就是主控信号输出端，简化图如下所示:</p>
<p>其实最简单的做法就是找个TTL接口的TFT-LCD，这样直接接上就可以。下面我们看下硬件上的电路连接：这个和我们上篇用的相同。</p>
<p>    有上面图可以看出：硬件连接</p>
<p>网络标号</p>
<p>说明</p>
<p>管脚</p>
<p>XvVD[0：23]</p>
<p>XvVDEN</p>
<p>XvVSYNC</p>
<p>XvHSYNC</p>
<p>XvVCLK</p>
<p>RGB数据、使能、行场同步、时钟信号</p>
<p> 这是TTL信号输出</p>
<p>LCD_PWM</p>
<p>调节背光</p>
<p>XpwmTOUT1/LCD_PWM/GPD0_1</p>
<p>LCD_LED_EN</p>
<p>LCD电压（TFT电压）使能</p>
<p>GPC1_2</p>
<p>LED_BL_EN</p>
<p>LED背光使能</p>
<p>GPL2_4</p>
<p>上面可分为几部分，电路连接部分分析：</p>
<p>（1）、TTL数据部分<br>这张图有木有烂掉呀，哈哈，就是这些数据了。还有有木有想起来摄像头的数据（ITU接口）也是这样的？？其实视频这种信号的原理是通用的，所以LCD通了，摄像头也就知道怎么回事了。</p>
<p>（2）、PWM背光调节<br> PWM其实也是芯片的一个功能模块，看到他的管脚就是一个复用脚XpwmTOUT1/LCD_PWM/GPD0_1。上一篇我们粗略的了解了PWM，就是用到这里。但是有一个疑问，PWM是调节背光电压的，背光电压一般都是12V以上的，我们PWM只有0-3V的样子，Exynos4412的IO只有1.8V。怎么调节电压？？？</p>
<p>其实这个PWM只是给LCD上PWM控制部分，真正的电压还是通过LCD控制板上的电路实现。</p>
<p>（3）、LED背光、LCD电压控制</p>
<p>a、背光：LED+<br>我们可以看到这个升压电路，通过SY7208把VBATT升压到18V，供给LED背光。SY7208最大升压26V。这个电压是提供给我们前面讲的背光的，也就是CCFL灯管或者LED背光组的电压。</p>
<p>b、LCD电压<br>这个电压也就是给你我们TFT阵列组用的，控制LCD液晶元素。<br>这部分电路分析完成，我们就有比较清晰的思路出，要一个LCD工作，要完成两部分内容：LCD上电控制，背光、LCD电压；信号输出。<br>二、LCD 驱动部分调试<br>    LCD这部分，像上篇我们说的frambuffer这些部分一般平台都是可以用的，除非你是芯片厂的要写这部分。一般公司拿到的demo板子这部分都是通的，只是针对自己的lCD换一些参数。<br>下面我们针对三星平台我们调试LCD的时时候程序方面的改动：<br>1、屏参数的配置<br>/kernel/drivers/video/Samsung/s3cfb_wa101s.c</p>
<p>[cpp] view plain copy</p>
<p>static struct s3cfb_lcd wa101 = {  </p>
<p>    .width  = 1280,//LCD 分辨率宽1280  </p>
<p>    .height = 800, //LCD 分辨率高 800  </p>
<p>    .bpp    = 24,//CLD 数据位 24bit  </p>
<p>    .freq   = 60,//LCD 像素时钟 60MHz  </p>
<p>    .timing = {//LCD porch无效值  </p>
<p>        .h_fp   = 70,  </p>
<p>        .h_bp   = 70,  </p>
<p>        .h_sw   = 20,  </p>
<p>        .v_fp   = 10,  </p>
<p>        .v_fpe  = 0,  </p>
<p>        .v_bp   = 10,  </p>
<p>        .v_bpe  = 0,  </p>
<p>        .v_sw   = 3,  </p>
<p>    },  </p>
<p>    .polarity = {//时钟、行场的极性；  </p>
<p>        .rise_vclk  = 1,  </p>
<p>        .inv_hsync  = 1,  </p>
<p>        .inv_vsync  = 1,  </p>
<p>        .inv_vden   = 0,  </p>
<p>    },  </p>
<p>};  </p>
<p>/* name should be fixed as ‘s3cfb_set_lcd_info’ */  </p>
<p>void s3cfb_set_lcd_info(struct s3cfb_global *ctrl)//初始化结构体  </p>
<p>{  </p>
<p>    wa101.init_ldi = NULL;  </p>
<p>    ctrl-&gt;lcd = &amp;wa101;  </p>
<p>#endif  </p>
<p>}  </p>
<p>还能想起上一篇的如何阅读规格书中的那些参数不，把这些填入就可以。<br>2、数据管脚初始化</p>
<p>kernel/arch/arm/mach-exynos/setup-fb-s5p.c</p>
<p>[cpp] view plain copy</p>
<p>void s3cfb_cfg_gpio(struct platform_device *pdev)  </p>
<p>{  </p>
<p>    s3cfb_gpio_setup_24bpp(EXYNOS4_GPF0(0), 8, S3C_GPIO_SFN(2), S5P_GPIO_DRVSTR_LV4);  </p>
<p>    s3cfb_gpio_setup_24bpp(EXYNOS4_GPF1(0), 8, S3C_GPIO_SFN(2), S5P_GPIO_DRVSTR_LV4);  </p>
<p>    s3cfb_gpio_setup_24bpp(EXYNOS4_GPF2(0), 8, S3C_GPIO_SFN(2), S5P_GPIO_DRVSTR_LV4);  </p>
<p>    s3cfb_gpio_setup_24bpp(EXYNOS4_GPF3(0), 4, S3C_GPIO_SFN(2), S5P_GPIO_DRVSTR_LV4);  </p>
<p>}  </p>
<p>LCD 数据脚初始化，驱动能力设为最高S5P_GPIO_DRVSTR_LV4；管脚驱动能力，S5P_GPIO_DRVSTR_LV1-4四个等级选择。</p>
<p>3、时钟控制部分<br>kernel/arch/arm/mach-exynos/setup-fb-s5p.c</p>
<p>[cpp] view plain copy</p>
<p>int s3cfb_clk_on(struct platform_device *pdev, struct clk **s3cfb_clk)  </p>
<p>{  </p>
<p>struct clk *sclk = NULL;  </p>
<p>struct clk *mout_mpll = NULL;  </p>
<p>struct clk *lcd_clk = NULL;  </p>
<p>    u32 rate = 0;  </p>
<p>int ret = 0;  </p>
<p>    lcd_clk = clk_get(&amp;pdev-&gt;dev, &quot;lcd&quot;);  </p>
<p>if (IS_ERR(lcd_clk)) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to get operation clk for fimd\n&quot;);  </p>
<p>goto err_clk0;  </p>
<p>    }  </p>
<p>    ret = clk_enable(lcd_clk);  </p>
<p>if (ret &lt; 0) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to clk_enable of lcd clk for fimd\n&quot;);  </p>
<p>goto err_clk0;  </p>
<p>    }  </p>
<p>    clk_put(lcd_clk);  </p>
<p>    sclk = clk_get(&amp;pdev-&gt;dev, &quot;sclk_fimd&quot;);  </p>
<p>if (IS_ERR(sclk)) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to get sclk for fimd\n&quot;);  </p>
<p>goto err_clk1;  </p>
<p>    }  </p>
<p>if (soc_is_exynos4210())  </p>
<p>        mout_mpll = clk_get(&amp;pdev-&gt;dev, &quot;mout_mpll&quot;);  </p>
<p>else  </p>
<p>        mout_mpll = clk_get(&amp;pdev-&gt;dev, &quot;mout_mpll_user&quot;);  </p>
<p>if (IS_ERR(mout_mpll)) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to get mout_mpll for fimd\n&quot;);  </p>
<p>goto err_clk2;  </p>
<p>    }  </p>
<p>    ret = clk_set_parent(sclk, mout_mpll);  </p>
<p>if (ret &lt; 0) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to clk_set_parent for fimd\n&quot;);  </p>
<p>goto err_clk2;  </p>
<p>    }  </p>
<p>if ((soc_is_exynos4412()) &amp;&amp; (samsung_rev() &gt;= EXYNOS4412_REV_2_0))  </p>
<p>        ret = clk_set_rate(sclk, 880000000);  </p>
<p>else  </p>
<p>        ret = clk_set_rate(sclk, 800000000);  </p>
<p>if (ret &lt; 0) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to clk_set_rate of sclk for fimd\n&quot;);  </p>
<p>goto err_clk2;  </p>
<p>    }  </p>
<p>    dev_dbg(&amp;pdev-&gt;dev, &quot;set fimd sclk rate to %d\n&quot;, rate);  </p>
<p>    clk_put(mout_mpll);  </p>
<p>    ret = clk_enable(sclk);  </p>
<p>if (ret &lt; 0) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to clk_enable of sclk for fimd\n&quot;);  </p>
<p>goto err_clk2;  </p>
<p>    }  </p>
<p>    *s3cfb_clk = sclk;  </p>
<p>return 0;  </p>
<p>err_clk2:  </p>
<p>    clk_put(mout_mpll);  </p>
<p>err_clk1:  </p>
<p>    clk_put(sclk);  </p>
<p>err_clk0:  </p>
<p>    clk_put(lcd_clk);  </p>
<p>return -EINVAL;  </p>
<p>}  </p>
<p>int s3cfb_clk_off(struct platform_device *pdev, struct clk **clk)  </p>
<p>{  </p>
<p>struct clk *lcd_clk = NULL;  </p>
<p>    lcd_clk = clk_get(&amp;pdev-&gt;dev, &quot;lcd&quot;);  </p>
<p>if (IS_ERR(lcd_clk)) {  </p>
<p>        printk(KERN_ERR &quot;failed to get ip clk for fimd0\n&quot;);  </p>
<p>goto err_clk0;  </p>
<p>    }  </p>
<p>    clk_disable(lcd_clk);  </p>
<p>    clk_put(lcd_clk);  </p>
<p>    clk_disable(*clk);  </p>
<p>    clk_put(*clk);  </p>
<p>    *clk = NULL;  </p>
<p>return 0;  </p>
<p>err_clk0:  </p>
<p>    clk_put(lcd_clk);  </p>
<p>return -EINVAL;  </p>
<p>}  </p>
<p>void s3cfb_get_clk_name(char *clk_name)  </p>
<p>{  </p>
<p>    strcpy(clk_name, &quot;sclk_fimd&quot;);  </p>
<p>}  </p>
<p>4、背光、LCD电压的控制</p>
<p>LCD_LED_EN</p>
<p>LCD电压（TFT电压）使能</p>
<p>GPC1_2</p>
<p>LED_BL_EN</p>
<p>LED背光使能</p>
<p>GPL2_4</p>
<p>[cpp] view plain copy</p>
<p>int s3cfb_backlight_on(struct platform_device *pdev)  </p>
<p>{  </p>
<p>int err;  </p>
<p>        pwm_set();  </p>
<p>    err = gpio_request_one(EXYNOS4_GPL2(4), GPIOF_OUT_INIT_HIGH, &quot;GPL2_4&quot;);  </p>
<p>if (err) {  </p>
<p>        printk(KERN_ERR &quot;failed to request GPL2 for &quot;  </p>
<p>&quot;lcd backlight control\n&quot;);  </p>
<p>return err;  </p>
<p>    }  </p>
<p>    s3c_gpio_setpull(EXYNOS4_GPL2(4),S3C_GPIO_PULL_NONE);  </p>
<p>    gpio_direction_output(EXYNOS4_GPL2(4), 1);  </p>
<p>    gpio_free(EXYNOS4_GPL2(4));  </p>
<p>    mdelay(20);  </p>
<p>    err = gpio_request_one(EXYNOS4_GPC1(2), GPIOF_OUT_INIT_HIGH, &quot;GPC1_2&quot;);  </p>
<p>if (err) {  </p>
<p>        printk(KERN_ERR &quot;failed to request GPC1 for &quot;  </p>
<p>&quot;lcd backlight control\n&quot;);  </p>
<p>return err;  </p>
<p>    }  </p>
<p>    s3c_gpio_setpull(EXYNOS4_GPC1(2),S3C_GPIO_PULL_NONE);  </p>
<p>    gpio_direction_output(EXYNOS4_GPC1(2), 0);  </p>
<p>    gpio_free(EXYNOS4_GPC1(2));  </p>
<p>    mdelay(20);  </p>
<p>    err = gpio_request(EXYNOS4_GPD0(1), &quot;GPD0_1&quot;);  </p>
<p>if (err) {  </p>
<p>        printk(KERN_ERR &quot;failed to request GPD0_1 for &quot;  </p>
<p>&quot;lcd pwm control\n&quot;);  </p>
<p>return err;  </p>
<p>    }  </p>
<p>    s3c_gpio_setpull(EXYNOS4_GPD0(1),S3C_GPIO_PULL_NONE);  </p>
<p>    s5p_gpio_set_drvstr(EXYNOS4_GPD0(1), S5P_GPIO_DRVSTR_LV4);    </p>
<p>    gpio_direction_output(EXYNOS4_GPD0(1), 1);  </p>
<p>    s3c_gpio_cfgpin(EXYNOS4_GPD0(1), EXYNOS4_GPD_0_1_TOUT_1);  </p>
<p>    gpio_free(EXYNOS4_GPD0(1));  </p>
<p>    mdelay(20);  </p>
<p>return 0;  </p>
<p>return 0;  </p>
<p>}  </p>
<p>int s3cfb_backlight_off(struct platform_device *pdev)  </p>
<p>{  </p>
<p>int err;  </p>
<p>    err = gpio_request_one(EXYNOS4_GPL2(4), GPIOF_OUT_INIT_LOW, &quot;GPL2_4&quot;);  </p>
<p>if (err) {  </p>
<p>        printk(KERN_ERR &quot;failed to request GPL2 for &quot;  </p>
<p>&quot;lcd backlight control\n&quot;);  </p>
<p>return err;  </p>
<p>    }  </p>
<p>    s3c_gpio_setpull(EXYNOS4_GPL2(4),S3C_GPIO_PULL_NONE);  </p>
<p>    gpio_direction_output(EXYNOS4_GPL2(4), 0);  </p>
<p>    gpio_free(EXYNOS4_GPL2(4));  </p>
<p>    err = gpio_request_one(EXYNOS4_GPC1(2), GPIOF_OUT_INIT_HIGH, &quot;GPC1_2&quot;);  </p>
<p>if (err) {  </p>
<p>        printk(KERN_ERR &quot;failed to request GPC1 for &quot;  </p>
<p>&quot;lcd backlight control\n&quot;);  </p>
<p>return err;  </p>
<p>    }  </p>
<p>    gpio_free(EXYNOS4_GPC1(2));  </p>
<p>return 0;  </p>
<p>}  </p>
<p>5、PWM的设置</p>
<p>arch/arm/mach-exynos/mach-smdk4x12.c</p>
<p>[cpp] view plain copy</p>
<p>Arch/arm/mach-exynos/mach-smdk4x12.c  </p>
<p>/* LCD Backlight data */  </p>
<p>static struct samsung_bl_gpio_info smdk4x12_bl_gpio_info = {  </p>
<p>    .no = EXYNOS4_GPD0(1),//PWM管脚XpwmTOUT1/LCD_PWM/GPD0_1  </p>
<p>    .func = S3C_GPIO_SFN(2),  </p>
<p>};  </p>
<p>static struct platform_pwm_backlight_data smdk4x12_bl_data = {  </p>
<p>    .pwm_id = 1,//PWM ID PWM编号为1号；  </p>
<p>    .pwm_period_ns  = 90000,  //22k  </p>
<p>};  </p>
<p>static void __init smdk4x12_machine_init(void)  </p>
<p>{     </p>
<p>………………  </p>
<p>samsung_bl_set(&amp;smdk4x12_bl_gpio_info, &amp;smdk4x12_bl_data);//在初始化的时候把对应的结构体初始化  </p>
<p>………………  </p>
<p>}  </p>
<p>samsung_bl_set看下这个函数的实现：</p>
<p>kernel/arch/arm/palt-samsung/dev-backlight.c</p>
<p>[cpp] view plain copy</p>
<p>void samsung_bl_set(struct samsung_bl_gpio_info *gpio_info,  </p>
<p>struct platform_pwm_backlight_data *bl_data)  </p>
<p>{  </p>
<p>int ret = 0;  </p>
<p>struct platform_device *samsung_bl_device;  </p>
<p>struct platform_pwm_backlight_data *samsung_bl_data;  </p>
<p>    samsung_bl_device = kmemdup(&amp;samsung_dfl_bl_device,  </p>
<p>sizeof(struct platform_device), GFP_KERNEL);//（1）、分配内存空间；  </p>
<p>if (!samsung_bl_device) {  </p>
<p>        printk(KERN_ERR &quot;%s: no memory for platform dev\n&quot;, <strong>func</strong>);  </p>
<p>return;  </p>
<p>    }  </p>
<p>    samsung_bl_data = s3c_set_platdata(&amp;samsung_dfl_bl_data,  </p>
<p>sizeof(struct platform_pwm_backlight_data), samsung_bl_device);//（2）、  </p>
<p>if (!samsung_bl_data) {  </p>
<p>        printk(KERN_ERR &quot;%s: no memory for platform dev\n&quot;, <strong>func</strong>);  </p>
<p>goto err_data;  </p>
<p>    }  </p>
<p>/* Copy board specific data provided by user */  </p>
<p>    samsung_bl_data-&gt;pwm_id = bl_data-&gt;pwm_id;//(3）、把具体配置的数据给samsung_bl_data  </p>
<p>    samsung_bl_device-&gt;dev.parent =  </p>
<p>            &amp;s3c_device_timer[samsung_bl_data-&gt;pwm_id].dev;  </p>
<p>if (bl_data-&gt;max_brightness)//(4)、对bl_data的结构体检查，如果没有复制则用default的值  </p>
<p>        samsung_bl_data-&gt;max_brightness = bl_data-&gt;max_brightness;  </p>
<p>if (bl_data-&gt;dft_brightness)  </p>
<p>        samsung_bl_data-&gt;dft_brightness = bl_data-&gt;dft_brightness;  </p>
<p>if (bl_data-&gt;lth_brightness)  </p>
<p>        samsung_bl_data-&gt;lth_brightness = bl_data-&gt;lth_brightness;  </p>
<p>if (bl_data-&gt;pwm_period_ns)  </p>
<p>        samsung_bl_data-&gt;pwm_period_ns = bl_data-&gt;pwm_period_ns;  </p>
<p>if (bl_data-&gt;init)  </p>
<p>        samsung_bl_data-&gt;init = bl_data-&gt;init;  </p>
<p>if (bl_data-&gt;notify)  </p>
<p>        samsung_bl_data-&gt;notify = bl_data-&gt;notify;  </p>
<p>if (bl_data-&gt;exit)  </p>
<p>        samsung_bl_data-&gt;exit = bl_data-&gt;exit;  </p>
<p>if (bl_data-&gt;check_fb)  </p>
<p>        samsung_bl_data-&gt;check_fb = bl_data-&gt;check_fb;  </p>
<p>/* Keep the GPIO info for future use */  </p>
<p>    s3c_device_timer[samsung_bl_data-&gt;pwm_id].dev.platform_data = gpio_info;  </p>
<p>/* Register the specific PWM timer dev for Backlight control */  </p>
<p>    ret = platform_device_register(//(5)、注册PWM设备驱动；  </p>
<p>            &amp;s3c_device_timer[samsung_bl_data-&gt;pwm_id]);  </p>
<p>if (ret) {  </p>
<p>        printk(KERN_ERR &quot;failed to register pwm timer for backlight: %d\n&quot;, ret);  </p>
<p>goto err_plat_reg1;  </p>
<p>    }  </p>
<p>/* Register the Backlight dev */  </p>
<p>    ret = platform_device_register(samsung_bl_device);//(6)、注册背光设备驱动；  </p>
<p>if (ret) {  </p>
<p>        printk(KERN_ERR &quot;failed to register backlight device: %d\n&quot;, ret);  </p>
<p>goto err_plat_reg2;  </p>
<p>    }  </p>
<p>return;  </p>
<p>err_plat_reg2://(7)、如果有异常的情况下退出；  </p>
<p>    platform_device_unregister(&amp;s3c_device_timer[samsung_bl_data-&gt;pwm_id]);  </p>
<p>err_plat_reg1:  </p>
<p>    kfree(samsung_bl_data);  </p>
<p>err_data:  </p>
<p>    kfree(samsung_bl_device);  </p>
<p>return;  </p>
<p>}  </p>
<p>(1)、分配内存空间</p>
<p>[cpp] view plain copy</p>
<p>    samsung_bl_device = kmemdup(&amp;samsung_dfl_bl_device,  </p>
<p>sizeof(struct platform_device), GFP_KERNEL);  </p>
<p>其中：  </p>
<p>static struct platform_pwm_backlight_data samsung_dfl_bl_data = {  </p>
<p>    .max_brightness = 255,  </p>
<p>    .dft_brightness = 140,   </p>
<p>    .pwm_period_ns  = 78770,  </p>
<p>    .init           = samsung_bl_init,  </p>
<p>    .exit           = samsung_bl_exit,  </p>
<p>};  </p>
<p>static struct platform_device samsung_dfl_bl_device = {  </p>
<p>    .name       = &quot;pwm-backlight&quot;,  </p>
<p>};  </p>
<p>(2)、</p>
<p>(3)、把具体配置的数据给samsung_bl_data</p>
<p>[cpp] view plain copy</p>
<p>arch/arm/mach-exynos/mach-smdk4x12.c  </p>
<p>static struct samsung_bl_gpio_info smdk4x12_bl_gpio_info = {  </p>
<p>    .no = EXYNOS4_GPD0(1),//PWM管脚XpwmTOUT1/LCD_PWM/GPD0_1  </p>
<p>    .func = S3C_GPIO_SFN(2),  </p>
<p>};  </p>
<p>static struct platform_pwm_backlight_data smdk4x12_bl_data = {  </p>
<p>    .pwm_id = 1,//PWM ID PWM编号为1号；  </p>
<p>    .pwm_period_ns  = 90000,  //22k  </p>
<p>};  </p>
<p>(4)、对bl_data的结构体检查，如果没有复制则用default的值</p>
<p>参考（1）中的那些值。</p>
<p>(5)、注册PWM设备驱动；</p>
<p>[cpp] view plain copy</p>
<p>ret = platform_device_register(  </p>
<p>        &amp;s3c_device_timer[samsung_bl_data-&gt;pwm_id]);  </p>
<p>其中s3c_device_timer[]这个结构体如下：</p>
<p>[cpp] view plain copy</p>
<p>struct platform_device s3c_device_timer[] = {  </p>
<p>    [0] = { DEFINE_S3C_TIMER(0, IRQ_TIMER0) },  </p>
<p>    [1] = { DEFINE_S3C_TIMER(1, IRQ_TIMER1) },  </p>
<p>    [2] = { DEFINE_S3C_TIMER(2, IRQ_TIMER2) },  </p>
<p>    [3] = { DEFINE_S3C_TIMER(3, IRQ_TIMER3) },  </p>
<p>    [4] = { DEFINE_S3C_TIMER(4, IRQ_TIMER4) },  </p>
<p>我们饿samsung_bl_data-&gt;pwm_id=1;所以选择[1] = { DEFINE_S3C_TIMER(1, IRQ_TIMER1) },</p>
<p>(6)、注册背光设备驱动；</p>
<p>[cpp] view plain copy</p>
<p>ret =platform_device_register(samsung_bl_device);   </p>
<p>其中：samsung_bl_device</p>
<p>[cpp] view plain copy</p>
<p>samsung_bl_data = s3c_set_platdata(&amp;samsung_dfl_bl_data,  </p>
<p>sizeof(struct platform_pwm_backlight_data), samsung_bl_device);  </p>
<p>(7)、如果有异常的情况下退出；</p>
<p>6、PWM_BL背光驱动分析：</p>
<p>Kernel/drivers/video/backlight/pwm_bl.c</p>
<p>（1）、驱动注册：</p>
<p>[cpp] view plain copy</p>
<p>static struct platform_driver pwm_backlight_driver = {  </p>
<p>    .driver     = {  </p>
<p>        .name   = &quot;pwm-backlight&quot;,  </p>
<p>        .owner  = THIS_MODULE,  </p>
<p>    },  </p>
<p>    .probe      = pwm_backlight_probe,  </p>
<p>    .remove     = pwm_backlight_remove,  </p>
<p>    .suspend    = pwm_backlight_suspend,  </p>
<p>    .resume     = pwm_backlight_resume,  </p>
<p>};  </p>
<p>static int __init pwm_backlight_init(void)  </p>
<p>{  </p>
<p>return platform_driver_register(&amp;pwm_backlight_driver);  </p>
<p>}  </p>
<p>（2）、probe函数分析</p>
<p>[cpp] view plain copy</p>
<p>static int pwm_backlight_probe(struct platform_device *pdev)  </p>
<p>{  </p>
<p>struct backlight_properties props;  </p>
<p>struct platform_pwm_backlight_data *data = pdev-&gt;dev.platform_data;  </p>
<p>struct backlight_device *bl;  </p>
<p>struct pwm_bl_data *pb;  </p>
<p>int ret;  </p>
<p>if (!data) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to find platform data\n&quot;);  </p>
<p>return -EINVAL;  </p>
<p>    }  </p>
<p>if (data-&gt;init) {  </p>
<p>        ret = data-&gt;init(&amp;pdev-&gt;dev);  </p>
<p>if (ret &lt; 0)  </p>
<p>return ret;  </p>
<p>    }  </p>
<p>    pb = kzalloc(sizeof(*pb), GFP_KERNEL);  </p>
<p>if (!pb) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;no memory for state\n&quot;);  </p>
<p>        ret = -ENOMEM;  </p>
<p>goto err_alloc;  </p>
<p>    }  </p>
<p>    global_pb=pb;  </p>
<p>    INIT_DELAYED_WORK_DEFERRABLE(&amp;key_event, key_event_work);//1）、任务队列初始化；  </p>
<p>    pb-&gt;period = data-&gt;pwm_period_ns;//2）、pb结构体初始化；  </p>
<p>    pb-&gt;notify = data-&gt;notify;  </p>
<p>    pb-&gt;check_fb = data-&gt;check_fb;  </p>
<p>    pb-&gt;lth_brightness = data-&gt;lth_brightness *  </p>
<p>        (data-&gt;pwm_period_ns / data-&gt;max_brightness);  </p>
<p>    pb-&gt;dev = &amp;pdev-&gt;dev;  </p>
<p>    pb-&gt;pwm = pwm_request(data-&gt;pwm_id, &quot;backlight&quot;);  </p>
<p>if (IS_ERR(pb-&gt;pwm)) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;unable to request PWM for backlight\n&quot;);  </p>
<p>        ret = PTR_ERR(pb-&gt;pwm);  </p>
<p>goto err_pwm;  </p>
<p>    } else  </p>
<p>        dev_dbg(&amp;pdev-&gt;dev, &quot;got pwm for backlight\n&quot;);  </p>
<p>    memset(&amp;props, 0, sizeof(struct backlight_properties));  </p>
<p>    props.type = BACKLIGHT_RAW;  </p>
<p>    props.max_brightness = data-&gt;max_brightness;  </p>
<p>    bl = backlight_device_register(dev_name(&amp;pdev-&gt;dev), &amp;pdev-&gt;dev, pb,  </p>
<p>                       &amp;pwm_backlight_ops, &amp;props);  </p>
<p>if (IS_ERR(bl)) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;failed to register backlight\n&quot;);  </p>
<p>        ret = PTR_ERR(bl);  </p>
<p>goto err_bl;  </p>
<p>    }  </p>
<p>    global_bl=bl;  </p>
<p>    bl-&gt;props.brightness = data-&gt;dft_brightness;  </p>
<p>    backlight_update_status(bl);//3）、更新背光状态；  </p>
<p>    platform_set_drvdata(pdev, bl);  </p>
<p>return 0;  </p>
<p>err_bl:  </p>
<p>    pwm_free(pb-&gt;pwm);  </p>
<p>err_pwm:  </p>
<p>    kfree(pb);  </p>
<p>err_alloc:  </p>
<p>if (data-&gt;exit)  </p>
<p>        data-&gt;exit(&amp;pdev-&gt;dev);  </p>
<p>return ret;  </p>
<p>}  </p>
<p>1）、任务队列初始化；</p>
<p>把key_event_work加入key_event队列，</p>
<p>[cpp] view plain copy</p>
<p>INIT_DELAYED_WORK_DEFERRABLE(&amp;key_event, key_event_work);  </p>
<p>队列调度函数：</p>
<p>[cpp] view plain copy</p>
<p>static void key_event_work(struct work_struct *work)  </p>
<p>{  </p>
<p>    global_pb-&gt;period=90000;  </p>
<p>    global_bl-&gt;props.brightness=global_brightness;  </p>
<p>    backlight_update_status(global_bl);  </p>
<p>return ;  </p>
<p>}  </p>
<p>backlight_update_status</p>
<p>[cpp] view plain copy</p>
<p>static inline void backlight_update_status(struct backlight_device *bd)  </p>
<p>{  </p>
<p>    mutex_lock(&amp;bd-&gt;update_lock);  </p>
<p>if (bd-&gt;ops &amp;&amp; bd-&gt;ops-&gt;update_status)  </p>
<p>        bd-&gt;ops-&gt;update_status(bd);  </p>
<p>    mutex_unlock(&amp;bd-&gt;update_lock);  </p>
<p>}  </p>
<p>update_status在pwm_backlight_ops结构体重指定：</p>
<p>[cpp] view plain copy</p>
<p>static const struct backlight_ops pwm_backlight_ops = {  </p>
<p>    .update_status  = pwm_backlight_update_status,  </p>
<p>    …………}  </p>
<p>pwm_backlight_update_status我们后面分析，这个其实就是我们PWM设定实现的具体实施过程。</p>
<p>2）、pb结构体初始化；</p>
<p>[cpp] view plain copy</p>
<p>pb-&gt;period = data-&gt;pwm_period_ns; pb-&gt;notify = data-&gt;notify;  </p>
<p>pb-&gt;check_fb = data-&gt;check_fb;  </p>
<p>pb-&gt;lth_brightness = data-&gt;lth_brightness *  </p>
<p>    (data-&gt;pwm_period_ns / data-&gt;max_brightness);  </p>
<p>pb-&gt;dev = &amp;pdev-&gt;dev;  </p>
<p>pb-&gt;pwm = pwm_request(data-&gt;pwm_id, &quot;backlight&quot;);  </p>
<p>3）、更新背光状态</p>
<p>[cpp] view plain copy</p>
<p>backlight_update_status(bl);  </p>
<p>（4）、PWM_SET</p>
<p>当UI设置PWM时，会调用到驱动中的pwm_set(void)这个函数。这个函数主要在开机时使用。</p>
<p>[cpp] view plain copy</p>
<p>int pwm_set(void)  </p>
<p>{  </p>
<p>int error;  </p>
<p>struct backlight_device *bl = global_bl;  </p>
<p>struct pwm_bl_data *pb = global_pb;  </p>
<p>    printk(&quot;%s__%d\n&quot;,<strong>func</strong>,pb-&gt;period);  </p>
<p>    pb-&gt;period=410000;  </p>
<p>    backlight_update_status(bl);  </p>
<p>    schedule_delayed_work(&amp;key_event, 600); //调用队列，跟新亮度信息；  </p>
<p>return 0;  </p>
<p>}  </p>
<p>（5）、pwm_backlight_update_status这个就是PWM变化的具体实现，当应用层调节时，会调用到这个函数，把改变的值填入寄存器。</p>
<p>[cpp] view plain copy</p>
<p>static int pwm_backlight_update_status(struct backlight_device *bl)  </p>
<p>{  </p>
<p>struct pwm_bl_data *pb = dev_get_drvdata(&amp;bl-&gt;dev);  </p>
<p>int brightness = bl-&gt;props.brightness;  </p>
<p>int max = bl-&gt;props.max_brightness;  </p>
<p>//if(brightness==0)  </p>
<p>//  return 0;  </p>
<p>//printk(&quot;#####%s#%d__%d\n&quot;,<strong>func</strong>,pb-&gt;period,brightness);  </p>
<p>    global_brightness=brightness;  </p>
<p>if (bl-&gt;props.power != FB_BLANK_UNBLANK)  </p>
<p>        brightness = 0;  </p>
<p>if (bl-&gt;props.fb_blank != FB_BLANK_UNBLANK)  </p>
<p>        brightness = 0;  </p>
<p>if (pb-&gt;notify)  </p>
<p>        brightness = pb-&gt;notify(pb-&gt;dev, brightness);  </p>
<p>if (brightness == 0) {  </p>
<p>        pwm_config(pb-&gt;pwm, 0, pb-&gt;period);  </p>
<p>        pwm_disable(pb-&gt;pwm);  </p>
<p>    } else {  </p>
<p>    #if 1  </p>
<p>        brightness = pb-&gt;lth_brightness +  </p>
<p>            (brightness * (pb-&gt;period - pb-&gt;lth_brightness) / max);  </p>
<p>    #else  </p>
<p>     brightness = pb-&gt;lth_brightness +  </p>
<p>                        (((pb-&gt;period - pb-&gt;lth_brightness) / max) * brightness );  </p>
<p>    #endif  </p>
<p>        pwm_config(pb-&gt;pwm, brightness, pb-&gt;period);//这里对PWM寄存器的具体操作；  </p>
<p>        pwm_enable(pb-&gt;pwm);  </p>
<p>    }  </p>
<p>return 0;  </p>
<p>}  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android 启动过程</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>Android 启动过程</p>
<p>1.1 Android 启动介绍</p>
<p>众所周知，Android是一款基于linux基础的开放源代码的手机操作系统，是以linux内核为操作系统的内核。那Android的启动也是在linux内核加载之后进行的。Linux内核由bootloader加载后，经自解压、初始化、顺序载入内核模块(其中包含驱动程序)等。在内核加载完成之后，会根据内核的传递参数寻找android的第一个用户态进程，即init进程。Init进程根据init.rc以及init.$(hardware).rc脚本文件来启动android的必要的服务。直到完成android的HOME的启动。</p>
<p>1.1.2 Linux Kernel启动</p>
<p>Start_kernel(/init/main.c),是内核启动的入口函数，它所做的事情很多，比如：中断和内存的初始化，以及内核模块的加载等。在start_kernel函数的最后调用了rest_init。</p>
<p>static noinline void __init_refok rest_init(void)</p>
<p>{</p>
<p>int pid;</p>
<p>……</p>
<p>kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);</p>
<p>……</p>
<p>}</p>
<p>注意到在rest_init函数中开启了一个kernel_init的内核线程。继续看kernel_init。</p>
<p>static int __init kernel_init(void * unused)</p>
<p>{</p>
<p>……</p>
<p>init_post();</p>
<p>return 0;</p>
<p>}</p>
<p>static noinline int init_post(void)</p>
<p>{</p>
<p>……</p>
<p>     run_init_process(&quot;/sbin/init&quot;);</p>
<p>     run_init_process(&quot;/etc/init&quot;);</p>
<p>     run_init_process(&quot;/bin/init&quot;);</p>
<p>     run_init_process(&quot;/bin/sh&quot;);</p>
<p>   panic(&quot;No init found.  Try passing init= option to kernel. &quot;&quot;See Linux Documentation/init.txt for guidance.&quot;);</p>
<p>}</p>
<p>1.1.3 Android Init进程</p>
<p>Android是基于linux内核的，在内核引导和加载完毕，从上面的代码可以看出init进程</p>
<p>是从内核态转换到到用户态的第一个应用程序。由/system/core/init/Android.mk可以出init进程是从/system/core/init/目录下文件编译成的可执行文件。既然是应用程序，在执行的时候当然是从main函数开始。</p>
<p>l         创建文件系统目录并挂载相关的文件系统</p>
<p>mkdir(&quot;/dev&quot;, 0755);</p>
<p>    mkdir(&quot;/proc&quot;, 0755);</p>
<p>    mkdir(&quot;/sys&quot;, 0755);</p>
<p>mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;);</p>
<p>    mkdir(&quot;/dev/pts&quot;, 0755);</p>
<p>    mkdir(&quot;/dev/socket&quot;, 0755);</p>
<p>    mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL);</p>
<p>    mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL);</p>
<p>    mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL)</p>
<p>这些文件系统是android中根文件系统下所需要的目录，所以在init阶段先创建好。</p>
<p>l         重定向标准输入，输出和标准错误到/dev/null设备中</p>
<p>void open_devnull_stdio(void)</p>
<p>{</p>
<p>   int fd;</p>
<p> static const char *name = &quot;/dev/<strong>null</strong>&quot;;</p>
<p>if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 3) == 0) {</p>
<p>fd = open(name, O_RDWR);</p>
<p>unlink(name);</p>
<p>if (fd &gt;= 0) {</p>
<p>dup2(fd, 0);</p>
<p>dup2(fd, 1);</p>
<p>dup2(fd, 2);</p>
<p>if (fd &gt; 2) {</p>
<p>       close(fd);</p>
<p>         }</p>
<p>     return;}</p>
<p>}</p>
<p>    exit(1);</p>
<p>}</p>
<p>函数首先为/dev/__null__设备创建设备节点，/dev/null就像一个黑洞。非常类似我们电脑上面的垃圾回收站。dup2为linux系统调用，0代表与系统进程相关的标准输入，1代表标准输出，2是标准错误。通过dup系统调用将这些标准输入，输出，错误都重新定向到/dev/null中。</p>
<p>l         初始化内核log系统(kmesg)</p>
<p>void klog_init(void)</p>
<p>{</p>
<p> static const char *name = &quot;/dev/<strong>kmsg</strong>&quot;;</p>
<p>if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 11) == 0) {</p>
<p>   fcntl(klog_fd, F_SETFD, FD_CLOEXEC)；</p>
<p>   unlink(name);</p>
<p>   }</p>
<p>}</p>
<p>当进程在执行exec系统调用时，要确保klog_fd是关闭的。</p>
<p>l         解析init.rc脚本文件</p>
<p>在解析init.rc时候通常会有两个init脚本文件，一个是init.rc，另外一个是和具体的硬件</p>
<p>平台相关的init.$hardware.rc。</p>
<p>init_parse_config_file(&quot;/init.rc&quot;);</p>
<p>snprintf(tmp, sizeof(tmp), &quot;/init.%s.rc&quot;, hardware);</p>
<p>init_parse_config_file(tmp)；</p>
<p>那么这个hardware是怎么过来的，我们就以这个ux31e为例。首先读取内核启动参数，import_kernel_cmdline(0, import_kernel_nv)；我们的内核参数从/proc/cmdline中读取为：</p>
<p>root=/dev/ram0 androidboot.hardware=asus_ux31e acpi_sleep=s3_bios,s3_mode；很明显我们的</p>
<p>hardware就是asus_ux31e，所以我们需要解析的硬件相关的脚本文件就是init.asua_ux31e.rc。</p>
<p>int  init_parse_config_file(const char *fn)</p>
<p>{</p>
<p>    char *data;</p>
<p>    data = read_file(fn, 0);</p>
<p>    if (!data) return -1;</p>
<p>  parse_config(fn, data);</p>
<p>    DUMP();</p>
<p>    return 0;</p>
<p>}</p>
<p>static  void  parse_config(const char *fn, char *s)</p>
<p>{</p>
<p>……</p>
<p>case T_NEWLINE:</p>
<p>            state.line++;</p>
<p>            if (nargs) {</p>
<p>                int kw = lookup_keyword(args[0]);</p>
<p>                if (kw_is(kw, SECTION)) {</p>
<p>                    state.parse_line(&amp;state, 0, 0);</p>
<p>                    parse_new_section(&amp;state, kw, nargs, args);</p>
<p>                } else {</p>
<p>                    state.parse_line(&amp;state, nargs, args);</p>
<p>                }</p>
<p>                nargs = 0;</p>
<p>            }</p>
<p>            break;</p>
<p>……</p>
<p>}</p>
<p>Parse_config会对脚本逐行进行解析，先调用lookup_keyword函数来查找脚本中的关键字。先来看脚本中可能出现的关键字。</p>
<p>Symbol</p>
<p>Flags</p>
<p>Nargs</p>
<p>Func</p>
<p>capability</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>chdir</p>
<p>COMMAND</p>
<p>1</p>
<p>do_chdir</p>
<p>chroot</p>
<p>COMMAND</p>
<p>1</p>
<p>do_chroot</p>
<p>class</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>class_start</p>
<p>COMMAND</p>
<p>1</p>
<p>do_class_start</p>
<p>class_stop</p>
<p>COMMAND</p>
<p>1</p>
<p>do_class_stop</p>
<p>class_reset</p>
<p>COMMAND</p>
<p>1</p>
<p>do_class_reset</p>
<p>console</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>critical</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>disabled</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>domainname</p>
<p>COMMAND</p>
<p>1</p>
<p>do_doinname</p>
<p>exec</p>
<p>COMMAND</p>
<p>1</p>
<p>do_exec</p>
<p>export</p>
<p>COMMAND</p>
<p>2</p>
<p>do_export</p>
<p>group</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>hostname</p>
<p>COMMAND</p>
<p>1</p>
<p>do_hostname</p>
<p>ifup</p>
<p>COMMAND</p>
<p>1</p>
<p>do_ifup</p>
<p>insmod</p>
<p>COMMAND</p>
<p>1</p>
<p>do_insmod</p>
<p>import</p>
<p>SECTION</p>
<p>1</p>
<p>0</p>
<p>keycodes</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>mkdir</p>
<p>COMMAND</p>
<p>1</p>
<p>do_mkdir</p>
<p>mount</p>
<p>COMMAND</p>
<p>3</p>
<p>do_mount</p>
<p>on</p>
<p>SECTION</p>
<p>0</p>
<p>0</p>
<p>oneshot</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>onrestart</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>restart</p>
<p>COMMAND</p>
<p>1</p>
<p>do_restart</p>
<p>rm</p>
<p>COMMAND</p>
<p>1</p>
<p>do_rm</p>
<p>rmdir</p>
<p>COMMAND</p>
<p>1</p>
<p>do_rmdir</p>
<p>service</p>
<p>SECTION</p>
<p>0</p>
<p>0</p>
<p>setenv</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>setkey</p>
<p>COMMAND</p>
<p>0</p>
<p>do_setkey</p>
<p>setprop</p>
<p>COMMAND</p>
<p>2</p>
<p>do_setprop</p>
<p>setrlimit</p>
<p>COMMAND</p>
<p>3</p>
<p>do_setrlimit</p>
<p>socket</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>start</p>
<p>COMMAND</p>
<p>1</p>
<p>do_start</p>
<p>stop</p>
<p>COMMAND</p>
<p>1</p>
<p>do_stop</p>
<p>triggler</p>
<p>COMMAND</p>
<p>1</p>
<p>do_triggler</p>
<p>symlink</p>
<p>COMMAND</p>
<p>1</p>
<p>do_symlink</p>
<p>sysclktz</p>
<p>COMMAND</p>
<p>1</p>
<p>do_sysclktz</p>
<p>user</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>wait</p>
<p>COMMAND</p>
<p>1</p>
<p>do_wait</p>
<p>write</p>
<p>COMMAND</p>
<p>2</p>
<p>do_write</p>
<p>copy</p>
<p>COMMAND</p>
<p>2</p>
<p>do_copy</p>
<p>chown</p>
<p>COMMAND</p>
<p>2</p>
<p>do_chown</p>
<p>chmod</p>
<p>COMMAND</p>
<p>2</p>
<p>do_chmod</p>
<p>loglevel</p>
<p>COMMAND</p>
<p>2</p>
<p>do_loglevel</p>
<p>load_persist_props</p>
<p>COMMAND</p>
<p>1</p>
<p>do_load_persit_props</p>
<p>ioprio</p>
<p>OPTION</p>
<p>0</p>
<p>0</p>
<p>从上面这张表可以看出第一栏表示在init.rc脚本中可能出现的关键字，第二栏是描述第一栏关键字的类型：有OPTION、COMMAND、SECTION这三类。如果关键字是命令类的(COMMAND)</p>
<p>就会调用的第4栏的函数去处理这个命令。</p>
<p>从解析脚本文件的函数parse_config来看，会将关键字类型是SECTION的关键字行调用</p>
<p>parse_new_section()；从上表的第二栏中可以看出为SECTION类型的关键字有三个：on，service,</p>
<p>import。</p>
<p>void  parse_new_section(struct parse_state *state, int kw,</p>
<p>                       int nargs, char **args)</p>
<p>{</p>
<p>    printf(&quot;[ %s %s ]\n&quot;, args[0],</p>
<p>           nargs &gt; 1 ? args[1] : &quot;&quot;);</p>
<p>    switch(kw) {</p>
<p>    case K_service:</p>
<p>        state-&gt;context = parse_service(state, nargs, args);</p>
<p>        if (state-&gt;context) {</p>
<p>            state-&gt;parse_line = parse_line_service;</p>
<p>            return;</p>
<p>        }</p>
<p>        break;</p>
<p>    case K_on:</p>
<p>        state-&gt;context = parse_action(state, nargs, args);</p>
<p>        if (state-&gt;context) {</p>
<p>            state-&gt;parse_line = parse_line_action;</p>
<p>            return;</p>
<p>        }</p>
<p>        break;</p>
<p>    case K_import:</p>
<p>        if (nargs != 2) {</p>
<p>            ERROR(&quot;single argument needed for import\n&quot;);</p>
<p>        } else {</p>
<p>            int ret = init_parse_config_file(args[1]);</p>
<p>            if (ret)</p>
<p>                ERROR(&quot;could not import file %s\n&quot;, args[1]);</p>
<p>        }</p>
<p>    }</p>
<p>    state-&gt;parse_line = parse_line_no_op;</p>
<p>}</p>
<p>先看init.rc中以service和以on开头行解析的过程。</p>
<p>static void <em>parse_service(struct parse_state *state, int nargs, char *</em>args)</p>
<p>{</p>
<p>………………</p>
<p>list_add_tail(&amp;service_list, &amp;svc-&gt;slist);</p>
<p>}</p>
<p>static void <em>parse_action(struct parse_state *state, int nargs, char *</em>args)</p>
<p>{</p>
<p>………………</p>
<p> list_add_tail(&amp;action_list, &amp;act-&gt;alist);</p>
<p>}</p>
<p>到这里我们就可以知道init.rc解析出来的service存放在server_list的双向循环链表中，action存放在action_list的双向循环链表中。</p>
<p>l         执行和触发init.rc事件</p>
<p>action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail);</p>
<p>action_for_each_trigger(&quot;init&quot;, action_add_queue_tail);</p>
<p>action_for_each_trigger(&quot;early-fs&quot;, action_add_queue_tail);</p>
<p>action_for_each_trigger(&quot;fs&quot;, action_add_queue_tail);</p>
<p>action_for_each_trigger(&quot;post-fs&quot;, action_add_queue_tail);</p>
<p>action_for_each_trigger(&quot;post-fs-data&quot;, action_add_queue_tail);</p>
<p>action_for_each_trigger(&quot;early-boot&quot;, action_add_queue_tail);</p>
<p>action_for_each_trigger(&quot;boot&quot;, action_add_queue_tail);</p>
<p>在最后执行以on boot开头行时候，我们从init.rc中可以看到最后命令是class_start。我们从上面的表格中可以看出命令class_start对应的命令是do_class_start。</p>
<p>int  do_class_start(int nargs, char **args)</p>
<p>{</p>
<p>    service_for_each_class(args[1], service_start_if_not_disabled);</p>
<p>    return 0;</p>
<p>}</p>
<p>这个函数就会遍历service_list链表，service_list就是上面从init.rc中解析出来的以service开头的行。对所有的service都调用service_start_if_not_disabled。</p>
<p>void service_for_each_class(const char *classname, void (*func)(struct service *svc))</p>
<p>{</p>
<p>    struct listnode *node;</p>
<p>    struct service *svc;</p>
<p>    list_for_each(node, &amp;service_list) {</p>
<p>        svc = node_to_item(node, struct service, slist);</p>
<p>        if (!strcmp(svc-&gt;classname, classname)) {</p>
<p>            func(svc);</p>
<p>        }  </p>
<p>    }  </p>
<p>}</p>
<p>static void service_start_if_not_disabled(struct service *svc)</p>
<p>{</p>
<p>    if (!(svc-&gt;flags &amp; SVC_DISABLED)) {</p>
<p>        service_start(svc, NULL);</p>
<p>    }</p>
<p>}</p>
<p>这样就将service中的标志不是disabled的service在系统初始化的时候开启后台运行。具体service的启动是以可执行文件的方式启动的。代码在/framework/base/cmds/文件下。</p>
<p>1.1.4 Android Zygote服务</p>
<p>　在Android系统中，所有的应用程序进程以及系统服务进程SystemServer都是由Zygote</p>
<p>进程孕育(fork)出来的，这也许就是为什么要把它称为Zygote(受精卵)的原因吧。</p>
<p>service zygote /system/bin/app_process -Xzygote /system/bin –zygote –start-system-server</p>
<p>    class main</p>
<p>    socket zygote stream 666</p>
<p>    onrestart write /sys/android_power/request_state wake</p>
<p>    onrestart write /sys/power/state on</p>
<p>    onrestart restart media</p>
<p>    onrestart restart netd</p>
<p>上面是从系统启动脚本文件init.rc中截取的关于zygote的部分，可以看到zygote进程要执行的是/system/bin/app_process命令。下面还有socket关键字，表示zygote进程还需要一个名为zygote的socket资源。有了这句脚本，我们在系统开机后，在/dev/socket/下面就能看到zygote的设备节点。了解了这些后，我们就知道Zygote进程要执行程序就是/system/bin/app_process了。源代码位于：/framework/base/cmds/app_process/app_main.cpp。</p>
<p>int main(int argc, const char* const argv[])</p>
<p>{</p>
<p>……</p>
<p>AppRuntime runtime;</p>
<p>……</p>
<p>if (zygote) {</p>
<p>runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);</p>
<p>……<br>} </p>
<p>在zygote的main函数中首先构建了一个AppRuntime类，然后调用AppRuntime的start方法。</p>
<p>void AndroidRuntime::start(const char* className, const char* options)</p>
<p>{</p>
<p>    LOGD(&quot;\n&gt;&gt;&gt;&gt;&gt;&gt; AndroidRuntime START %s &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;,className != NULL ? className : &quot;(unknown)&quot;);</p>
<p>blockSigpipe();</p>
<p>……</p>
<p>JNIEnv* env;</p>
<p>    if (startVm(&amp;mJavaVM, &amp;env) != 0) {</p>
<p>        return;</p>
<p>}</p>
<p>……</p>
<p>char* slashClassName = toSlashClassName(className);</p>
<p>    jclass startClass = env-&gt;FindClass(slashClassName);</p>
<p>    if (startClass == NULL) {</p>
<p>        LOGE(&quot;JavaVM unable to locate class ‘%s’\n&quot;, slashClassName);</p>
<p>        /* keep going */</p>
<p>    } else {</p>
<p>        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</p>
<p>            &quot;([Ljava/lang/String;)V&quot;);</p>
<p>        if (startMeth == NULL) {</p>
<p>            LOGE(&quot;JavaVM unable to find main() in ‘%s’\n&quot;, className);</p>
<p>            /* keep going */</p>
<p>        } else {</p>
<p>            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</p>
<p>……</p>
<p>}       </p>
<p>　这个函数的作用是启动Android系统运行时库，它主要做了三件事情，一是调用函数startVM启动虚拟机，二是调用函数startReg注册JNI方法，三是调用com.android.internal.os.ZygoteInit类的main函数。我们知道android上层的应用程序是java代码，要开启java世界就必须要开始java虚拟机，而java代码要和linux内核设备或者驱动通信。而java代码和底层的c代码是不可能直接调用的。所以需要注册JNI方法，java代码通过JNI代码就可以和native的c代码沟通了。</p>
<p>l         ZygoteInit(/framework/base/core/java/com/android/internal/os/ZygoteInit.java)</p>
<p>view  plainpublic class ZygoteInit {</p>
<p>　　……</p>
<p>　　public static void main(String argv[]) {</p>
<p>　　try {</p>
<p>　　……</p>
<p>　　registerZygoteSocket();</p>
<p>　　……</p>
<p>　　……</p>
<p>　　if (argv[1].equals(&quot;true&quot;)) {</p>
<p>　　startSystemServer();</p>
<p>　　} else if (!argv[1].equals(&quot;false&quot;)) {</p>
<p>　　……</p>
<p>　　}</p>
<p>　　……</p>
<p>　　if (ZYGOTE_FORK_MODE) {</p>
<p>　　……</p>
<p>　　} else {</p>
<p>　　runSelectLoopMode();</p>
<p>　　}</p>
<p>　　……</p>
<p>　　} catch (MethodAndArgsCaller caller) {</p>
<p>　　……</p>
<p>　}</p>
<p>在main函数中首先调用了registerZygoteSocket来创建一个socket套接字接口，用来和Activity</p>
<p>ManagerService通信。然后通过startSystemServer函数来启动SystemServer。我们重点关注SystemServer的启动。</p>
<p>private static boolean startSystemServer()</p>
<p> throws MethodAndArgsCaller, RuntimeException {</p>
<p>        /* Hardcoded command line to start the system server */</p>
<p>        String args[] = {</p>
<p>            &quot;–setuid=1000&quot;,</p>
<p>            &quot;–setgid=1000&quot;,</p>
<p>     &quot;–setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,3001,3002,3003,3006,3007&quot;,</p>
<p>            &quot;–capabilities=130104352,130104352&quot;,</p>
<p>            &quot;–runtime-init&quot;,</p>
<p>            &quot;–nice-name=system_server&quot;,</p>
<p>            &quot;com.android.server.SystemServer&quot;,</p>
<p>……</p>
<p>  pid = Zygote.forkSystemServer(</p>
<p>                    parsedArgs.uid, parsedArgs.gid,</p>
<p>                    parsedArgs.gids,</p>
<p>                    parsedArgs.debugFlags,</p>
<p>                    null,</p>
<p>                    parsedArgs.permittedCapabilities,</p>
<p>                    parsedArgs.effectiveCapabilities);</p>
<p>……</p>
<p>if (pid == 0) {</p>
<p>            handleSystemServerProcess(parsedArgs);</p>
<p>        }</p>
<p> }; </p>
<p>最后在handleSystemServerProcess中，需要继续调用RuntimeInit.zygoteInit函数来进一步执行启动SystemServer组件的操作。然后通过RuntimeInit中的zygoteInit继续zygoteInitNative函数来执行一个binder的进程间的通信。通过android中的binder机制就可以执行SystemServer的代码了。在SystemServer中启动一系列android在init阶段需要启动的服务，比如：surfacefilnger，PowerManagerService，ActivityManagerService，LightsService，BatteryService</p>
<p>…等服务。</p>
<p>1.2 Android中常见的服务介绍</p>
<p>service zygote /system/bin/app_process </p>
<p>     Zygote进程用于产生其他进程。由init.rc对zygote的描述service Zygote /system/bin/app_</p>
<p>Process可知zygote进程从/framework/base/cmds/app_process/中代码启动。</p>
<p>service servicemanager /system/bin/servicemanager</p>
<p>ServiceMananger是android中比较重要的一个进程，它是在init进程启动之后启动，从名字上就可以看出来它是用来管理系统中的service。系统service需要向servicemanager进行注册，才可以使用。</p>
<p>service media /system/bin/mediaserver</p>
<p>         MediaServer是整个android中media部分的核心和灵魂。几乎所有与多媒体播放相关的内容都放在这里。包括了音视频的编解码以及显示输出。</p>
<p>service surfaceflinger /system/bin/surfaceflinger</p>
<p>         android开机显示系统服务，提供系统范围内的surface composer功能，它能够将各种应用程序的2D、3D surface进行组合。</p>
<p>service dbus /system/bin/dbus-daemon</p>
<p>         dbus服务是android使用的一种特殊的进程间通讯系统。它具有面向对象接口的协议，以及应用程序之间互相发现和监视的守护进程。dbus设计用来作为用户与系统服务之间的分隔以及系统服务之间的通讯。因此，dbus通讯安全，但效率有点差。</p>
<p>service installd /system/bin/installd</p>
<p>         installd服务是提供安装dex文件的服务，Android平台上可执行的类型。</p>
<p>service ril-daemon /system/bin/rild</p>
<p>这个服务是android手机上的电话部分或者3G卡用到的服务。</p>
<p>service vold /system/bin/vold</p>
<p>负责完成系统的CDROM, USB大容量存储，MMC卡等扩展存储的挂载任务自动完成的守护进程。</p>
<p>service bootanim /system/bin/bootanimation</p>
<p>         android开机显示动画服务。</p>
<p>service console /system/bin/sh  </p>
<p>         andriod的控制台启用。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android 自定义View</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
    <content><![CDATA[<p>1、自定义View的属性，首先在res/values/  下建立一个attrs.xml </p>
<p>format是值该属性的取值类型:  string,color,demension,integer,enum,reference,float,boolean,fraction,flag; </p>
<ol>
<li> string：字符串类型；</li>
<li> integer：整数类型；</li>
<li> float：浮点型；</li>
<li> dimension：尺寸，后面必须跟dp、dip、px、sp等单位；</li>
<li> Boolean：布尔值；</li>
<li> reference：引用类型，传入的是某一资源的ID，必须以“@”符号开头；</li>
<li> color：颜色，必须是“#”符号开头；</li>
<li> fraction：百分比，必须是“%”符号结尾；</li>
<li> enum：枚举类型</li>
</ol>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </p>
<p>&lt;resources&gt; </p>
<p>&lt;attr name=&quot;titleText&quot; format=&quot;string&quot; /&gt;</p>
<p> &lt;attr name=&quot;titleTextColor&quot; format=&quot;color&quot; /&gt;  </p>
<p>   &lt;declare-styleable name=&quot;CustomTitleView&quot;&gt;       </p>
<p>         &lt;attr name=&quot;titleText&quot; /&gt;  </p>
<p>        &lt;attr name=&quot;titleTextColor&quot; </p>
<p>    &lt;/declare-styleable&gt;    </p>
<p>&lt;/resources&gt;  </p>
<p> 自定义属性的命名空间：xmlns:app=&quot;<a href="http://schemas.android.com/apk/res-auto">http://schemas.android.com/apk/res-auto</a>&quot;</p>
<p> 自定义namespace的名称可以自己定义，不一定非得是app</p>
<ol start="2">
<li>在自定义View / ViewGroup中，我们可以通过TypedArray获取到自定义的属性。 </li>
</ol>
<p>TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.CustomMenu, defStyleAttr, 0);<br>    int indexCount = a.getIndexCount();<br>    for (int i = 0; i &lt; indexCount; i++) {<br>        int attr = a.getIndex(i);<br>        switch (attr) {<br>            case R.styleable.CustomMenu_rightPadding:<br>                mMenuRightPadding = a.getDimensionPixelSize(attr, 0);<br>                break;<br>        }<br>    }<br>    a.recycle();</p>
<p>TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.DashboardView, defStyleAttr, 0);<br>mRadius = a.getDimensionPixelSize(R.styleable.DashboardView_radius, dpToPx(80));<br>mStartAngle = a.getInteger(R.styleable.DashboardView_startAngle, 180);</p>
<p>在TypedArray使用结束后，需要调用recycle()方法回收它。</p>
<p>3 重写onDraw，onMesure</p>
<ol start="4">
<li> View绘制过程</li>
</ol>
<p>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {} </p>
<p>　onMeasure()方法中主要负责测量，决定控件本身或其子控件所占的宽高。</p>
<p>我们可以通过onMeasure()方法提供的参数widthMeasureSpec和heightMeasureSpec来分别获取控件宽度和高度的测量模式和测量值（测量 = 测量模式 + 测量值）。</p>
<p>　　widthMeasureSpec和heightMeasureSpec虽然只是int类型的值，但它们是通过MeasureSpec类进行了编码处理的，其中封装了测量模式和测量值，因此我们可以分别通过MeasureSpec.getMode(xMeasureSpec)和MeasureSpec. getSize(xMeasureSpec)来获取到控件或其子View的测量模式和测量值。</p>
<p>　　测量模式分为以下三种情况：</p>
<ol>
<li> EXACTLY：当宽高值设置为具体值时使用，如100DIP、match_parent等，此时取出的size是精确的尺寸；</li>
<li> AT_MOST：当宽高值设置为wrap_content时使用，此时取出的size是控件最大可获得的空间；</li>
<li> UNSPECIFIED：当没有指定宽高值时使用（很少见）。</li>
</ol>
<p>　　onMeasure()方法中常用的方法：</p>
<ol>
<li> getChildCount()：获取子View的数量；</li>
<li> getChildAt(i)：获取第i个子控件；</li>
<li> subView.getLayoutParams().width/height：设置或获取子控件的宽或高；</li>
<li> measureChild(child, widthMeasureSpec, heightMeasureSpec)：测量子View的宽高；</li>
<li> child.getMeasuredHeight/width()：执行完measureChild()方法后就可以通过这种方式获取子View的宽高值；</li>
<li> getPaddingLeft/Right/Top/Bottom()：获取控件的四周内边距；</li>
<li> setMeasuredDimension(width, height)：重新设置控件的宽高。如果写了这句代码，就需要删除“super. onMeasure(widthMeasureSpec, heightMeasureSpec);”这行代码。</li>
</ol>
<p>　　注意：onMeasure()方法可能被调用多次，这是因为控件中的内容或子View可能对分配给自己的空间“不满意”，因此向父空间申请重新分配空间。</p>
<p>public static int getDefaultSize(int size, int measureSpec) {  </p>
<p>    int result = size;  </p>
<p>    int specMode = MeasureSpec.getMode(measureSpec);  </p>
<p>    int specSize = MeasureSpec.getSize(measureSpec);  </p>
<p>    switch (specMode) {  </p>
<p>    case MeasureSpec.UNSPECIFIED:  </p>
<p>        result = size;  </p>
<p>        break;  </p>
<p>    case MeasureSpec.AT_MOST:  </p>
<p>    case MeasureSpec.EXACTLY:  </p>
<p>        result = specSize;  </p>
<p>        break;  </p>
<p>    }  </p>
<p>    return result;  </p>
<p>}  </p>
<p>protected void onLayout(boolean changed, int left, int top, int right, int bottom) { }</p>
<p>protected void onDraw(Canvas canvas) { }</p>
<p>requestLayout  View重新调用一次layout过程。</p>
<p>invalidate  View重新调用一次draw过程</p>
<p>forceLayout   标识View在下一次重绘，需要重新调用layout过程。</p>
<p>  如果在使用自定义view时，用了wrap_content。那么在onMeasure中就要调用setMeasuredDimension，</p>
<p>  来指定view的宽高。如果使用的fill_parent或者一个具体的dp值。那么直接使用super.onMeasure即可。</p>
<p>  如果是一个ViewGroup，重写onMeasure时要注意： </p>
<p>  测量子view的方式有：</p>
<p>getChildAt(int index).可以拿到index上的子view。 </p>
<p>       通过getChildCount得到子view的数目，再循环遍历出子view。</p>
<p>       接着，subView.measure(int wSpec, int hSpec); //使用子view自身的测量方法</p>
<p>    或者调用viewGroup的测量子view的方法：</p>
<p>//某一个子view，多宽，多高, 内部加上了viewGroup的padding值</p>
<p>measureChild(subView, int wSpec, int hSpec); </p>
<p>//所有子view 都是 多宽，多高, 内部调用了measureChild方法</p>
<p>measureChildren(int wSpec, int hSpec);</p>
<p>//某一个子view，多宽，多高, 内部加上了viewGroup的padding值、margin值和传入的宽高wUsed、hUsed  </p>
<p>measureChildWithMargins(subView, intwSpec, int wUsed, int hSpec, int hUsed); </p>
<p>onDraw()</p>
<p>　　onDraw()方法负责绘制，即如果我们希望得到的效果在Android原生控件中没有现成的支持，那么我们就需要自己绘制我们的自定义控件的显示效果。</p>
<p>　　要学习onDraw()方法，我们就需要学习在onDraw()方法中使用最多的两个类：Paint和Canvas。</p>
<p>　　注意：每次触摸了自定义View/ViewGroup时都会触发onDraw()方法。</p>
<p>5.1、Paint类</p>
<p>　　Paint画笔对象，这个类中包含了如何绘制几何图形、文字和位图的样式和颜色信息，指定了如何绘制文本和图形。画笔对象右很多设置方法，大体上可以分为两类：一类与图形绘制有关，一类与文本绘制有关。</p>
<p>　　Paint类中有如下方法：</p>
<p>　　1、图形绘制：</p>
<ol>
<li> setArgb(int a, int r, int g, int b)：设置绘制的颜色，a表示透明度，r、g、b表示颜色值；</li>
<li> setAlpha(int a)：设置绘制的图形的透明度；</li>
<li> setColor(int color)：设置绘制的颜色；</li>
<li> setAntiAlias(boolean a)：设置是否使用抗锯齿功能，抗锯齿功能会消耗较大资源，绘制图形的速度会减慢；</li>
<li> setDither(boolean b)：设置是否使用图像抖动处理，会使图像颜色更加平滑饱满，更加清晰；</li>
<li> setFileterBitmap(Boolean b)：设置是否在动画中滤掉Bitmap的优化，可以加快显示速度；</li>
<li> setMaskFilter(MaskFilter mf)：设置MaskFilter来实现滤镜的效果；</li>
<li> setColorFilter(ColorFilter cf)：设置颜色过滤器，可以在绘制颜色时实现不同颜色的变换效果；</li>
<li> setPathEffect(PathEffect pe)：设置绘制的路径的效果；</li>
<li>setShader(Shader s)：设置Shader绘制各种渐变效果；</li>
<li>setShadowLayer(float r, int x, int y, int c)：在图形下面设置阴影层，r为阴影角度，x和y为阴影在x轴和y轴上的距离，c为阴影的颜色；</li>
<li>setStyle(Paint.Style s)：设置画笔的样式：FILL实心；STROKE空心；FILL_OR_STROKE同时实心与空心；</li>
<li>setStrokeCap(Paint.Cap c)：当设置画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的图形样式；</li>
<li>setStrokeJoin(Paint.Join j)：设置绘制时各图形的结合方式；</li>
<li>setStrokeWidth(float w)：当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度；</li>
<li>setXfermode(Xfermode m)：设置图形重叠时的处理方式；</li>
</ol>
<p>　　2、文本绘制：</p>
<ol>
<li> setTextAlign(Path.Align a)：设置绘制的文本的对齐方式；</li>
<li> setTextScaleX(float s)：设置文本在X轴的缩放比例，可以实现文字的拉伸效果；</li>
<li> setTextSize(float s)：设置字号；</li>
<li> setTextSkewX(float s)：设置斜体文字，s是文字倾斜度；</li>
<li> setTypeFace(TypeFace tf)：设置字体风格，包括粗体、斜体等；</li>
<li> setUnderlineText(boolean b)：设置绘制的文本是否带有下划线效果；</li>
<li> setStrikeThruText(boolean b)：设置绘制的文本是否带有删除线效果；</li>
<li> setFakeBoldText(boolean b)：模拟实现粗体文字，如果设置在小字体上效果会非常差；</li>
<li> setSubpixelText(boolean b)：如果设置为true则有助于文本在LCD屏幕上显示效果；</li>
</ol>
<p>　　3、其他方法：</p>
<ol>
<li> getTextBounds(String t, int s, int e, Rect b)：将页面中t文本从s下标开始到e下标结束的所有字符所占的区域宽高封装到b这个矩形中；</li>
<li> clearShadowLayer()：清除阴影层；</li>
<li> measureText(String t, int s, int e)：返回t文本中从s下标开始到e下标结束的所有字符所占的宽度；</li>
<li> reset()：重置画笔为默认值。</li>
</ol>
<p>　　这里需要就几个方法解释一下：</p>
<p>1、setPathEffect(PathEffect pe)：设置绘制的路径的效果：</p>
<p>　　常见的有以下几种可选方案：</p>
<ol>
<li> CornerPathEffect：可以用圆角来代替尖锐的角；</li>
<li> DathPathEffect：虚线，由短线和点组成；</li>
<li> DiscretePathEffect：荆棘状的线条；</li>
<li> PathDashPathEffect：定义一种新的形状并将其作为原始路径的轮廓标记；</li>
<li> SumPathEffect：在一条路径中顺序添加参数中的效果；</li>
<li> ComposePathEffect：将两种效果组合起来，先使用第一种效果，在此基础上应用第二种效果。</li>
</ol>
<p>2、setXfermode(Xfermode m)：设置图形重叠时的处理方式：</p>
<p>　　关于Xfermode的多种效果，我们可以参考下面一张图：</p>
<p>　　在使用的时候，我们需要通过paint. setXfermode(new PorterDuffXfermode(PorterDuff.Mode.XXX))来设置，XXX是上图中的某种模式对应的常量参数，如DST_OUT。</p>
<p>　　这16中情况的具体解释如下：</p>
<p>1.PorterDuff.Mode.CLEAR：所绘制不会提交到画布上。<br>2.PorterDuff.Mode.SRC：显示上层绘制图片<br>3.PorterDuff.Mode.DST：显示下层绘制图片<br>4.PorterDuff.Mode.SRC_OVER：正常绘制显示，上下层绘制叠盖。<br>5.PorterDuff.Mode.DST_OVER：上下层都显示。下层居上显示。<br>6.PorterDuff.Mode.SRC_IN：取两层绘制交集。显示上层。<br>7.PorterDuff.Mode.DST_IN：取两层绘制交集。显示下层。<br>8.PorterDuff.Mode.SRC_OUT：上层绘制非交集部分。<br>9.PorterDuff.Mode.DST_OUT：取下层绘制非交集部分。<br>10.PorterDuff.Mode.SRC_ATOP：取下层非交集部分与上层交集部分<br>11.PorterDuff.Mode.DST_ATOP：取上层非交集部分与下层交集部分<br>12.PorterDuff.Mode.XOR：异或：去除两图层交集部分<br>13.PorterDuff.Mode.DARKEN：取两图层全部区域，交集部分颜色加深<br>14.PorterDuff.Mode.LIGHTEN：取两图层全部，点亮交集部分颜色<br>15.PorterDuff.Mode.MULTIPLY：取两图层交集部分叠加后颜色<br>16.PorterDuff.Mode.SCREEN：取两图层全部区域，交集部分变为透明色</p>
<p>5.2、Canvas类</p>
<p>　　Canvas即画布，其上可以使用Paint画笔对象绘制很多东西。</p>
<p>　　Canvas对象中可以绘制：</p>
<ol>
<li> drawArc()：绘制圆弧；</li>
<li> drawBitmap()：绘制Bitmap图像；</li>
<li> drawCircle()：绘制圆圈；</li>
<li> drawLine()：绘制线条；</li>
<li> drawOval()：绘制椭圆；</li>
<li> drawPath()：绘制Path路径；</li>
<li> drawPicture()：绘制Picture图片；</li>
<li> drawRect()：绘制矩形；</li>
<li> drawRoundRect()：绘制圆角矩形；</li>
<li>drawText()：绘制文本；</li>
<li>drawVertices()：绘制顶点。</li>
</ol>
<p>　　Canvas对象的其他方法：</p>
<ol>
<li> canvas.save()：把当前绘制的图像保存起来，让后续的操作相当于是在一个新图层上绘制；</li>
<li> canvas.restore()：把当前画布调整到上一个save()之前的状态；</li>
<li> canvas.translate(dx, dy)：把当前画布的原点移到(dx, dy)点，后续操作都以(dx, dy)点作为参照；</li>
<li> canvas.scale(x, y)：将当前画布在水平方向上缩放x倍，竖直方向上缩放y倍；</li>
<li> canvas.rotate(angle)：将当前画布顺时针旋转angle度。</li>
</ol>
<p>6、onLayout()</p>
<p>　　onLayout()方法负责布局，大多数情况是在自定义ViewGroup中才会重写，主要用来确定子View在这个布局空间中的摆放位置。</p>
<p>　　onLayout(boolean changed, int l, int t, int r, int b)方法有5个参数，其中changed表示这个控件是否有了新的尺寸或位置；l、t、r、b分别表示这个View相对于父布局的左/上/右/下方的位置。</p>
<p>　　以下是onLayout()方法中常用的方法：</p>
<ol>
<li> getChildCount()：获取子View的数量；</li>
<li> getChildAt(i)：获取第i个子View</li>
<li> getWidth/Height()：获取onMeasure()中返回的宽度和高度的测量值；</li>
<li> child.getLayoutParams()：获取到子View的LayoutParams对象；</li>
<li> child.getMeasuredWidth/Height()：获取onMeasure()方法中测量的子View的宽度和高度值；</li>
<li> getPaddingLeft/Right/Top/Bottom()：获取控件的四周内边距；</li>
<li> child.layout(l, t, r, b)：设置子View布局的上下左右边的坐标。</li>
</ol>
<p>7、其他方法</p>
<p>7.1、generateLayoutParams()</p>
<p>　　generateLayoutParams()方法用在自定义ViewGroup中，用来指明子控件之间的关系，即与当前的ViewGroup对应的LayoutParams。我们只需要在方法中返回一个我们想要使用的LayoutParams类型的对象即可。</p>
<p>　　在generateLayoutParams()方法中需要传入一个AttributeSet对象作为参数，这个对象是这个ViewGroup的属性集，系统根据这个ViewGroup的属性集来定义子View的布局规则，供子View使用。</p>
<p>　　例如，在自定义流式布局中，我们只需要关心子控件之间的间隔关系，因此我们需要在generateLayoutParams()方法中返回一个new MarginLayoutParams()即可。</p>
<p>7.2、onTouchEvent()</p>
<p>　　onTouchEvent()方法用来监测用户手指操作。我们通过方法中MotionEvent参数对象的getAction()方法来实时获取用户的手势，有UP、DOWN和MOVE三个枚举值，分别表示用于手指抬起、按下和滑动的动作。每当用户有操作时，就会回掉onTouchEvent()方法。</p>
<p>7.3、onScrollChanged()</p>
<p>　　如果我们的自定义View / ViewGroup是继承自ScrollView / HorizontalScrollView等可以滚动的控件，就可以通过重写onScrollChanged()方法来监听控件的滚动事件。</p>
<p>　　这个方法中有四个参数：l和t分别表示当前滑动到的点在水平和竖直方向上的坐标；oldl和oldt分别表示上次滑动到的点在水平和竖直方向上的坐标。我们可以通过这四个值对滑动进行处理，如添加属性动画等。</p>
<p>7.4、invalidate()</p>
<p>　　invalidate()方法的作用是请求View树进行重绘，即draw()方法，如果视图的大小发生了变化，还会调用layout()方法。</p>
<p>　　一般会引起invalidate()操作的函数如下：</p>
<ol>
<li> 直接调用invalidate()方法，请求重新draw()，但只会绘制调用者本身；</li>
<li> 调用setSelection()方法，请求重新draw()，但只会绘制调用者本身；</li>
<li> 调用setVisibility()方法，会间接调用invalidate()方法，继而绘制该View；</li>
<li> 调用setEnabled()方法，请求重新draw()，但不会重新绘制任何视图，包括调用者本身。</li>
</ol>
<p>7.5、postInvalidate()</p>
<p>　　功能与invalidate()方法相同，只是postInvalidate()方法是异步请求重绘视图。</p>
<p>7.6、requestLayout()</p>
<p>　　requestLayout()方法只是对View树进行重新布局layout过程（包括measure()过程和layout()过程），不会调用draw()过程，即不会重新绘制任何视图，包括该调用者本身。</p>
<p>7.7、requestFocus()</p>
<p>　　请求View树的draw()过程，但只会绘制需要重绘的视图，即哪个View或ViewGroup调用了这个方法，就重绘哪个视图。</p>
<p>8、总结</p>
<p>　　最后，让我们来总览一下自定义View / ViewGroup时调用的各种函数的顺序，如下图所示：</p>
<p>　　在这些方法中：</p>
<p>onMeasure()会在初始化之后调用一到多次来测量控件或其中的子控件的宽高；</p>
<p>onLayout()会在onMeasure()方法之后被调用一次，将控件或其子控件进行布局；</p>
<p>onDraw()会在onLayout()方法之后调用一次，也会在用户手指触摸屏幕时被调用多次，来绘制控件。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android之framework修改底部导航栏NavigationBar动态显示和隐藏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E4%B9%8Bframework%E4%BF%AE%E6%94%B9%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8FNavigationBar%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F/</url>
    <content><![CDATA[<p>Android之framework修改底部导航栏NavigationBar动态显示和隐藏</p>
<p>大家都知道，Android从3.0版本开始就加入了NavigationBar，主要是为那些没有实体按键的设备提供虚拟按键，但是，它始终固定在底部，占用48dp的像素高度，尽管从android 4.4开始可以全透明，使用这一部分像素，但三个按钮始终悬浮在屏幕上，这对于有强迫症的朋友来说是无法忍受的。因此，本文的目的就是修改framework部分代码，可以动态隐藏和显示NavigationBar，同时又尽量不影响系统的正常。</p>
<p>主要思路：</p>
<p>在NavigationBar的布局左部加入一个Button(在SystemUI模块实现)，点击隐藏NavigationBar，即将NavigationBar从WindowManager中移除掉。需要的时候，通过一个从屏幕底部向上的滑动手势(在policy模块实现)调出NavigationBar。如下两图对比所示：一张为移除前，另一张为移除后。</p>
<p>具体实现：</p>
<p>①.增加按钮实现动态隐藏，主要修改在frameworks/base/packages/SystemUI模块，首先我们增加一个按钮，主要修改</p>
<p>frameworks/base/packages/SystemUI/res/layout/navigation_bar.xml文件，图片资源和字符串我就不提了，具体如下：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>diff –git a/frameworks/base/packages/SystemUI/res/layout/navigation_bar.xml b/frameworks/base/packages/SystemUI/res/layout/navigation_bar.xml</p>
<p>index 16027d9..326aafc 100644</p>
<p>— a/frameworks/base/packages/SystemUI/res/layout/navigation_bar.xml</p>
<p>+++ b/frameworks/base/packages/SystemUI/res/layout/navigation_bar.xml</p>
<p>@@ -42,12 +42,28 @@</p>
<p>&gt;</p>
<p>&lt;!– navigation controls –&gt;</p>
<p>+           &lt;!–BEGIN liweiping</p>
<p>&lt;View</p>
<p>android:layout_width=40dp</p>
<p>android:layout_height=match_parent</p>
<p>android:layout_weight=0</p>
<p>android:visibility=invisible</p>
<p>/&gt;</p>
<p>+           –&gt;</p>
<p>+            &lt;framelayout android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;0&quot; android:layout_width=&quot;@dimen/navigation_extra_key_width&quot;&gt;</p>
<p>+                &lt;imagebutton android:id=&quot;@+id/hide_bar_btn&quot; android:src=&quot;@drawable/ic_sysbar_hide&quot; android:layout_width=&quot;@dimen/navigation_extra_key_width&quot; android:layout_height=&quot;match_parent&quot; android:contentdescription=&quot;@string/accessibility_hide&quot;&gt;</p>
<p>+</p>
<p>+            &lt;/imagebutton&gt;&lt;/framelayout&gt;</p>
<p>+           &lt;!–END liweiping –&gt;</p>
<p>&lt;com.android.systemui.statusbar.policy.keybuttonview android:id=&quot;@+id/back&quot; android:layout_width=&quot;@dimen/navigation_key_width&quot; android:layout_height=&quot;match_parent&quot; android:contentdescription=&quot;@string/accessibility_back&quot; android:layout_weight=&quot;0&quot; 28=&quot;&quot; 12=&quot;&quot;&gt;</p>
<p>+           &lt;!–BEGIN liweiping</p>
<p>&lt;View</p>
<p>android:layout_height=40dp</p>
<p>android:layout_width=match_parent</p>
<p>android:layout_weight=0</p>
<p>android:visibility=invisible</p>
<p>/&gt;</p>
<p>+           –&gt;</p>
<p>+            &lt;framelayout android:layout_height=&quot;40dp&quot; android:layout_weight=&quot;0&quot; android:layout_width=&quot;match_parent&quot;&gt;</p>
<p>+</p>
<p>+                &lt;imagebutton android:id=&quot;@+id/hide_bar_btn&quot; android:src=&quot;@drawable/ic_sysbar_hide_land&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:contentdescription=&quot;@string/accessibility_hide&quot;&gt;</p>
<p>+            &lt;/imagebutton&gt;&lt;/framelayout&gt;</p>
<p>+           &lt;!–END liweiping –&gt;</p>
<p>&lt;!– lights out layout to match exactly –&gt;&lt;/com.android.systemui.statusbar.policy.keybuttonview&gt;</p>
<p>接下来修改frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java，为按钮提供一个接口，具体如下：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java</p>
<p>index 88e71e2..7545984 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java</p>
<p>@@ -45,6 +45,7 @@ import com.android.systemui.R;</p>
<p>import com.android.systemui.statusbar.BaseStatusBar;</p>
<p>import com.android.systemui.statusbar.DelegateViewHelper;</p>
<p>import com.android.systemui.statusbar.policy.DeadZone;</p>
<p>+import com.android.systemui.statusbar.policy.KeyButtonRipple;</p>
<p>import com.android.systemui.statusbar.policy.KeyButtonView;</p>
<p>import java.io.FileDescriptor;</p>
<p>@@ -265,6 +266,13 @@ public class NavigationBarView extends LinearLayout {</p>
<p>public View getImeSwitchButton() {</p>
<p>return mCurrentView.findViewById(R.id.ime_switcher);</p>
<p>}</p>
<p>+    //BEGIN liweiping</p>
<p>+    public View getHideBarButton() {</p>
<p>+       View view = mCurrentView.findViewById(R.id.hide_bar_btn);</p>
<p>+       view.setBackground(new KeyButtonRipple(getContext(), view));</p>
<p>+        return view;</p>
<p>+    }</p>
<p>+    //END liweiping</p>
<p>private void getIcons(Resources res) {</p>
<p>mBackIcon = res.getDrawable(R.drawable.ic_sysbar_back);</p>
<p>@@ -412,7 +420,6 @@ public class NavigationBarView extends LinearLayout {</p>
<p>mCurrentView = mRotatedViews[Surface.ROTATION_0];</p>
<p>getImeSwitchButton().setOnClickListener(mImeSwitcherClickListener);</p>
<p>-</p>
<p>updateRTLOrder();</p>
<p>}</p>
<p>最后便是在frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java实现点击事件了：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>+    private final OnClickListener mHideBarClickListener = new OnClickListener() {</p>
<p>+        @Override</p>
<p>+        public void onClick(View view) {</p>
<p>+           Log.i(way, mHideBarClickListener  onClick…);</p>
<p>+           removeNavigationBar();</p>
<p>+        }</p>
<p>+    };</p>
<p>+    private void removeNavigationBar() {</p>
<p>+        if (DEBUG) Log.d(TAG, removeNavigationBar: about to remove  + mNavigationBarView);</p>
<p>+        if (mNavigationBarView == null) return;</p>
<p>+</p>
<p>+        mWindowManager.removeView(mNavigationBarView);</p>
<p>+        mNavigationBarView = null;</p>
<p>+    }</p>
<p>到此，隐藏NavigationBar告一段落了。</p>
<p>②.接下来便是显示NavigationBar，这个修改相对复杂一点。因为此时NavigationBar处于不可见状态，我们无法通过增加按钮的方式让其显示，但是我们知道，状态栏下拉通过手势向下滑动即可。因此很容易便想到通过手势从屏幕底部向上滑动来显示NavigationBar。我的想法是在policy模块中增加一个接口，通过frameworks/base/services/core/java/com/android/server/statusbar/StatusBarManagerService.java服务传递到状态栏中，从而触发显示NavigationBar事件。</p>
<p>也许大家会有疑问，为什么是在policy模块修改？其实我这只是一种解决方案，因为我知道</p>
<p>frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java 有现成的手势滑动接口。其实你也可以SystemUI中增加一个这样的事件，我们需要的就是这么一个触发事件。</p>
<p>PhoneWindowManager.java的修改主要是实现onSwipeFromBottom(竖屏时)和onSwipeFromRight(横屏时)两个接口，然后调用showNavigationBar，在showNavigationBar函数中，我们调用StatusBarManagerService服务中的showNavigationBar函数，具体如下：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>diff –git a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>index bb53e12..907202d 100644</p>
<p>— a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>@@ -1241,13 +1241,27 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>public void onSwipeFromBottom() {</p>
<p>if (mNavigationBar != null &amp;&amp; mNavigationBarOnBottom) {</p>
<p>requestTransientBars(mNavigationBar);</p>
<p>+                            Log.i(way, onSwipeFromBottom… mNavigationBar != null &amp;&amp; mNavigationBarOnBottom);</p>
<p>}</p>
<p>+                        //BEGIN liweiping</p>
<p>+                        else{</p>
<p>+                           Log.i(way, onSwipeFromBottom…);</p>
<p>+                           showNavigationBar();</p>
<p>+                        }</p>
<p>+                        //END liweiping</p>
<p>}</p>
<p>@Override</p>
<p>public void onSwipeFromRight() {</p>
<p>if (mNavigationBar != null &amp;&amp; !mNavigationBarOnBottom) {</p>
<p>requestTransientBars(mNavigationBar);</p>
<p>+                            Log.i(way, onSwipeFromRight… mNavigationBar != null &amp;&amp; !mNavigationBarOnBottom);</p>
<p>+                        }</p>
<p>+                        //BEGIN liweiping</p>
<p>+                        else{</p>
<p>+                           Log.i(way, onSwipeFromRight…);</p>
<p>+                           showNavigationBar();</p>
<p>}</p>
<p>+                        //END liweiping</p>
<p>}</p>
<p>@Override</p>
<p>public void onDebug() {</p>
<p>@@ -1293,7 +1307,24 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>goingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);</p>
<p>}</p>
<p>}</p>
<p>-</p>
<p>+    //BEGIN liweiping</p>
<p>+    private void showNavigationBar(){</p>
<p>+        mHandler.post(new Runnable() {</p>
<p>+            @Override</p>
<p>+            public void run() {</p>
<p>+                try {</p>
<p>+                    IStatusBarService statusbar = getStatusBarService();</p>
<p>+                    if (statusbar != null) {</p>
<p>+                        statusbar.showNavigationBar();</p>
<p>+                    }</p>
<p>+                } catch (RemoteException e) {</p>
<p>+                    // re-acquire status bar service next time it is needed.</p>
<p>+                    mStatusBarService = null;</p>
<p>+                }</p>
<p>+            }</p>
<p>+        });</p>
<p>+    }</p>
<p>+    //END liweiping</p>
<p>private void updateKeyAssignments() {</p>
<p>final boolean hasMenu = (mDeviceHardwareKeys &amp; KEY_MASK_MENU) != 0;</p>
<p>final boolean hasHome = (mDeviceHardwareKeys &amp; KEY_MASK_HOME) != 0;</p>
<p>这时事件传递到了StatusBarManagerService中，我们来看看StatusBarManagerService.java如何实现showNavigationBar：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>diff –git a/frameworks/base/services/core/java/com/android/server/statusbar/StatusBarManagerService.java b/frameworks/base/services/core/java/com/android/server/statusbar/StatusBarManagerService.java</p>
<p>index f85e2d9..3f75840 100644</p>
<p>— a/frameworks/base/services/core/java/com/android/server/statusbar/StatusBarManagerService.java</p>
<p>+++ b/frameworks/base/services/core/java/com/android/server/statusbar/StatusBarManagerService.java</p>
<p>@@ -366,6 +366,27 @@ public class StatusBarManagerService extends IStatusBarService.Stub {</p>
<p>WindowManager.LayoutParams);</p>
<p>}</p>
<p>}</p>
<p>+    //BEGIN liweiping</p>
<p>+    @Override</p>
<p>+    public void showNavigationBar() {</p>
<p>+        enforceStatusBar();</p>
<p>+</p>
<p>+        android.util.Log.d(way, TAG +  showNavigationBar…);</p>
<p>+</p>
<p>+        synchronized(mLock) {</p>
<p>+            mHandler.post(new Runnable() {</p>
<p>+                    public void run() {</p>
<p>+                        if (mBar != null) {</p>
<p>+                            try {</p>
<p>+                                mBar.showNavigationBar();</p>
<p>+                            } catch (RemoteException ex) {</p>
<p>+                            }</p>
<p>+                        }</p>
<p>+                    }</p>
<p>+                });</p>
<p>+        }</p>
<p>+    }</p>
<p>+    //END liweiping</p>
<p>private void updateUiVisibilityLocked(final int vis, final int mask) {</p>
<p>if (mSystemUiVisibility != vis) {</p>
<p>从上述代码可以看出，StatusBarManagerService只是起到一个传递作用，将消息传递到StatusBar中，最终的实现是在SystemUI模块的frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java，如下所示：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java</p>
<p>index 9db875f..4f24b6e 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java</p>
<p>@@ -56,6 +56,7 @@ public class CommandQueue extends IStatusBar.Stub {</p>
<p>private static final int MSG_BUZZ_BEEP_BLINKED          = 15 &lt;&lt; MSG_SHIFT;</p>
<p>private static final int MSG_NOTIFICATION_LIGHT_OFF     = 16 &lt;&lt; MSG_SHIFT;</p>
<p>private static final int MSG_NOTIFICATION_LIGHT_PULSE   = 17 &lt;&lt; MSG_SHIFT;</p>
<p>+    private static final int MSG_SHOW_NAVIGATIONBAR   = 18 &lt;&lt; MSG_SHIFT;//ADD liweiping</p>
<p>public static final int FLAG_EXCLUDE_NONE = 0;</p>
<p>public static final int FLAG_EXCLUDE_SEARCH_PANEL = 1 &lt;&lt; 0;</p>
<p>@@ -83,6 +84,7 @@ public class CommandQueue extends IStatusBar.Stub {</p>
<p>public void animateCollapsePanels(int flags);</p>
<p>public void animateExpandSettingsPanel();</p>
<p>public void setSystemUiVisibility(int vis, int mask);</p>
<p>+        public void showNavigationBar();//ADD liweiping</p>
<p>public void topAppWindowChanged(boolean visible);</p>
<p>public void setImeWindowStatus(IBinder token, int vis, int backDisposition,</p>
<p>boolean showImeSwitcher);</p>
<p>@@ -154,6 +156,14 @@ public class CommandQueue extends IStatusBar.Stub {</p>
<p>mHandler.obtainMessage(MSG_SET_SYSTEMUI_VISIBILITY, vis, mask, null).sendToTarget();</p>
<p>}</p>
<p>}</p>
<p>+    //BEGIN liweiping</p>
<p>+    public void showNavigationBar() {</p>
<p>+        synchronized (mList) {</p>
<p>+            mHandler.removeMessages(MSG_SHOW_NAVIGATIONBAR);</p>
<p>+            mHandler.sendEmptyMessage(MSG_SHOW_NAVIGATIONBAR);</p>
<p>+        }</p>
<p>+    }</p>
<p>+    //END liweiping</p>
<p>public void topAppWindowChanged(boolean menuVisible) {</p>
<p>synchronized (mList) {</p>
<p>@@ -283,6 +293,11 @@ public class CommandQueue extends IStatusBar.Stub {</p>
<p>case MSG_SET_SYSTEMUI_VISIBILITY:</p>
<p>mCallbacks.setSystemUiVisibility(msg.arg1, msg.arg2);</p>
<p>break;</p>
<p>+                //BEGIN liweiping</p>
<p>+                case MSG_SHOW_NAVIGATIONBAR:</p>
<p>+                   mCallbacks.showNavigationBar();</p>
<p>+                   break;</p>
<p>+                //END liweiping</p>
<p>case MSG_TOP_APP_WINDOW_CHANGED:</p>
<p>mCallbacks.topAppWindowChanged(msg.arg1 != 0);</p>
<p>break;</p>
<p>CommandQueue.java收到了这个消息之后，又回调给了base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java，绕了大半天，消息终于回来了，我们就是需要在PhoneStatusBar.java实现显示NavigationBar的函数了：</p>
<p>?</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>59</p>
<p>+    @Override // CommandQueue</p>
<p>+    public void showNavigationBar() {</p>
<p>+       Log.i(way, TAG +  showNavigationBar…);</p>
<p>+       forceAddNavigationBar();</p>
<p>+    }</p>
<p>+    private void forceAddNavigationBar() {</p>
<p>+        // If we have no Navbar view and we should have one, create it</p>
<p>+        if (mNavigationBarView != null) {</p>
<p>+            return;</p>
<p>+        }</p>
<p>+</p>
<p>+        mNavigationBarView =</p>
<p>+                (NavigationBarView) View.inflate(mContext, R.layout.navigation_bar, null);</p>
<p>+        mNavigationBarView.setDisabledFlags(mDisabled);</p>
<p>+        mNavigationBarView.setBar(this);</p>
<p>+        addNavigationBar(true); // dynamically adding nav bar, reset System UI visibility!</p>
<p>+    }</p>
<p>+    private void prepareNavigationBarView(boolean forceReset) {</p>
<p>+        mNavigationBarView.reorient();</p>
<p>+        mNavigationBarView.getRecentsButton().setOnClickListener(mRecentsClickListener);</p>
<p>+        mNavigationBarView.getRecentsButton().setOnTouchListener(mRecentsPreloadOnTouchListener);</p>
<p>+        mNavigationBarView.getRecentsButton().setLongClickable(true);</p>
<p>+        mNavigationBarView.getRecentsButton().setOnLongClickListener(mLongPressBackRecentsListener);</p>
<p>+        mNavigationBarView.getBackButton().setLongClickable(true);</p>
<p>+        mNavigationBarView.getBackButton().setOnLongClickListener(mLongPressBackRecentsListener);</p>
<p>+        mNavigationBarView.getHomeButton().setOnTouchListener(mHomeActionListener);</p>
<p>+        mNavigationBarView.getHideBarButton().setOnClickListener(mHideBarClickListener);//ADD liweiping</p>
<p>+</p>
<p>+        if (forceReset) {</p>
<p>+            // Nav Bar was added dynamically - we need to reset the mSystemUiVisibility and call</p>
<p>+            // setSystemUiVisibility so that mNavigationBarMode is set to the correct value</p>
<p>+           Log.i(way, prepareNavigationBarView mNavigationBarMode = + mNavigationBarMode +  mSystemUiVisibility =  + mSystemUiVisibility +  mNavigationIconHints =  + mNavigationIconHints);</p>
<p>+           mNavigationBarMode = 0;</p>
<p>+          </p>
<p>+            int newVal = mSystemUiVisibility;</p>
<p>+            mSystemUiVisibility = View.SYSTEM_UI_FLAG_VISIBLE;</p>
<p>+            setSystemUiVisibility(newVal, /<em>SYSTEM_UI_VISIBILITY_MASK</em>/0xffffffff);</p>
<p>+            int hints = mNavigationIconHints;</p>
<p>+            mNavigationIconHints = 0;</p>
<p>+            setNavigationIconHints(hints);</p>
<p>+            topAppWindowChanged(mShowMenu);</p>
<p>+        }</p>
<p>+</p>
<p>+        updateSearchPanel();</p>
<p>+    }</p>
<p>+</p>
<p>+    // For small-screen devices (read: phones) that lack hardware navigation buttons</p>
<p>+    private void addNavigationBar(boolean forceReset) {</p>
<p>+        if (DEBUG) Log.v(TAG, addNavigationBar: about to add  + mNavigationBarView);</p>
<p>+        if (mNavigationBarView == null) return;</p>
<p>+</p>
<p>+        prepareNavigationBarView(forceReset);</p>
<p>+</p>
<p>+        mWindowManager.addView(mNavigationBarView, getNavigationBarLayoutParams());</p>
<p>+    }</p>
<p>+    //END liweiping</p>
<p>需要注意的是： </p>
<p>①显示NavigationBar时，需要重新实例化一次NavigationBarView，我之前有试过移除NavigationBarView后未置空，下次添加时直接使用，会出现状态栏重启的情况，具体原因未知，log显示动画播放错误之类。</p>
<p>②重新添加NavigationBarView时需要恢复NavigationBarView之前的状态，比如说隐藏前时是透明的、显示输入法按钮、菜单键等等。</p>
<p>③本文是在Android5.0的代码上修改的，其他版本未验证。</p>
<p>④本文仅是提供一种思路，并非最优方案。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android动画效果之初识Property Animation（属性动画）</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E4%B9%8B%E5%88%9D%E8%AF%86Property%20Animation%EF%BC%88%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%EF%BC%89/</url>
    <content><![CDATA[<p>Property Animation产生的背景：</p>
<p>    由于Tween Animation（补间动画）只能实现简单的四种的动画（alpha、scale、rotate、translate），要想实现比较复杂的动画就难以满足需求，而且补间动画只是改变了View对象绘制的位置，而没有改变View对象本身，比如View形状的变换，如大小的缩放，透明度的改变，位置的改变，其实本身并没有改变，举个例子就好比孙悟空灵魂出窍一样，虽然已经上天入地，其实肉体还在那里一动不动，我们开发过程中的经常遇见的就是translate之后事件还在原地。如果要实现既要有动画效果又要使得View本身得到真正改变，那就要借助属性动画了，这也是属性动画引入的原因。它能够更加灵活的实现各种效果，不仅限于类似补间动画实现的哪几种效果。</p>
<p>Property Animation相关类</p>
<p>   属性动画，根据字面理解可以通过修改物件的属性值以达到动画效果。</p>
<p>类名用途</p>
<p>ValueAnimator属性动画主要的计时器，也计算动画后的属性的值，动画的执行类</p>
<p>ObjectAnimator  ValueAnimator的一个子类，允许你设置一个目标对象和对象的属性进行动画，动画的执行类</p>
<p>AnimatorSet提供组织动画的结构，使它们能相关联得运行，用于控制一组动画的执行</p>
<p>AnimatorInflater 用户加载属性动画的xml文件</p>
<p>Evaluators 属性动画计算器，告诉了属性动画系统如何计算给出属性的值</p>
<p>Interpolators动画插入器，定义动画的变化率</p>
<p> 上面几个重要类之间的关系如下图所示：</p>
<p>今天先通过最简单最容易理解的ObjectAnimator来学习总结。</p>
<p>ObjectAnimator：</p>
<p>   ValueAnimator的一个子类，允许你设置一个目标对象和对象的属性进行动画。当这个类计算好一个动画的新值后，相应的会更新其属性。大多数时候你都会想用ObjectAnimator，因为它使得动画值到目标对象的处理更简单了。</p>
<p>1.）以实现一个View透明渐变效果为例进行说明</p>
<p>xml实现方式：</p>
<p>这里需要注意是的属性动画文件存放目录为res/animator</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;<br>    android:duration=&quot;500&quot;<br>    android:propertyName=&quot;alpha&quot;<br>    android:repeatCount=&quot;1&quot;<br>    android:repeatMode=&quot;reverse&quot;<br>    android:startOffset=&quot;200&quot;<br>    android:valueFrom=&quot;0.0&quot;<br>    android:valueTo=&quot;1.0&quot;<br>    android:valueType=&quot;floatType&quot; /&gt;</p>
<p>duration 表示动画执行的时间</p>
<p>propertyName 表示修改的物件的哪个属性值，这里是透明度</p>
<p>valueFrom 表示从哪个状态值开始动画</p>
<p>valueTo 表示到哪个状态值结束动画</p>
<p>valueType 类型估值，主要用于设置动画操作属性的值</p>
<p>repeatMode 表示重复的模式 reverse表示</p>
<p>repeatCount 动画重复的计数，动画将会执行该值+1次</p>
<p>repeatMode 动画重复的模式，reverse为反向，当第偶次执行时，动画方向会相反。restart为重新执行，方向不变</p>
<p>startOffset， 动画多次执行的间隔时间，如果只执行一次，执行前会暂停这段时间，单位毫秒 </p>
<p>interpolator 指定动画插入器</p>
<p>通过上面的xml属性可以看出和补间动画基本上一致，然后通过AnimatorInflater 来加载xml中的动画</p>
<p>Animator anim = AnimatorInflater.loadAnimator(this, R.animator.animator_alpha);<br>anim.setTarget(imageView);<br>anim.start();</p>
<p>当然也可以通过纯Java代码的方式实现</p>
<p>ObjectAnimator alphaAnimation = ObjectAnimator.ofFloat(imageView, &quot;alpha&quot;, 0f, 1f);<br>    alphaAnimation.setDuration(500);<br>    alphaAnimation.setRepeatCount(0);<br>    alphaAnimation.setRepeatMode(ValueAnimator.REVERSE);<br>    alphaAnimation.setStartDelay(200);<br>    alphaAnimation.setInterpolator(new AccelerateDecelerateInterpolator());<br>    alphaAnimation.start();</p>
<p>对于java代码实现，ObjectAnimator 提供了以下几个方法：ofFloat()，ofInt()，ofObject()，ofArgb()，ofPropertyValuesHolder()这几个方法都是设置动画作用的元素、作用的属性、动画开始、结束、以及中间的任意个属性值。</p>
<p>其他举例：</p>
<p>缩放动画：</p>
<p>xml：</p>
<p>&lt;objectAnimator xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;　　android:duration=&quot;500&quot;　　android:propertyName=&quot;scaleX&quot;　　android:repeatCount=&quot;1&quot;　　android:repeatMode=&quot;reverse&quot;　　android:valueFrom=&quot;1.0&quot;　　android:valueTo=&quot;1.5&quot;　　android:valueType=&quot;floatType&quot; /&gt;</p>
<p>java代码：</p>
<p> ObjectAnimator scaleXAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 1.5f);<br>   scaleXAnimator.setDuration(500);<br>   scaleXAnimator.setRepeatCount(1);<br>   scaleXAnimator.setRepeatMode(ValueAnimator.REVERSE);<br>   scaleXAnimator.start();</p>
<p>旋转动画：</p>
<p> xml：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;<br>    android:duration=&quot;500&quot;<br>    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;<br>    android:propertyName=&quot;rotation&quot;<br>    android:repeatCount=&quot;1&quot;<br>    android:repeatMode=&quot;reverse&quot;<br>    android:valueFrom=&quot;0&quot;<br>    android:valueTo=&quot;360&quot;<br>    android:valueType=&quot;floatType&quot; /&gt;</p>
<p>java代码：</p>
<p> ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(imageView, &quot;rotation&quot;, 0f, 360f);<br>    objectAnimator.setDuration(500);<br>    objectAnimator.setRepeatCount(1);<br>    objectAnimator.setRepeatMode(ValueAnimator.REVERSE);<br>    objectAnimator.start();</p>
<p>平移动画：</p>
<p>xml：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;<br>    android:duration=&quot;500&quot;<br>    android:propertyName=&quot;translationX&quot;<br>    android:repeatCount=&quot;1&quot;<br>    android:repeatMode=&quot;reverse&quot;<br>    android:valueFrom=&quot;0&quot;<br>    android:valueTo=&quot;100&quot;<br>    android:valueType=&quot;floatType&quot; /&gt;</p>
<p>java代码：</p>
<p> ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(imageView, &quot;translationX&quot;, 0f, 100f);<br>    objectAnimator.setDuration(500);<br>    objectAnimator.setRepeatCount(1);<br>    objectAnimator.setRepeatMode(ValueAnimator.REVERSE);<br>    objectAnimator.start();</p>
<p>2.)如何实现一个组合动画</p>
<p>    举例我们同时对一个控件进行宽高两个维度的缩放</p>
<p>  方式一：使用AnimatorSet</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;<br>    android:ordering=&quot;together&quot;&gt;<br>    &lt;objectAnimator<br>        android:duration=&quot;500&quot;<br>        android:propertyName=&quot;scaleX&quot;<br>        android:repeatCount=&quot;1&quot;<br>        android:repeatMode=&quot;reverse&quot;<br>        android:valueFrom=&quot;1.0&quot;<br>        android:valueTo=&quot;1.5&quot;<br>        android:valueType=&quot;floatType&quot; /&gt;<br>    &lt;objectAnimator<br>        android:duration=&quot;500&quot;<br>        android:propertyName=&quot;scaleY&quot;<br>        android:repeatCount=&quot;1&quot;<br>        android:repeatMode=&quot;reverse&quot;<br>        android:valueFrom=&quot;1.0&quot;<br>        android:valueTo=&quot;1.5&quot;<br>        android:valueType=&quot;floatType&quot; /&gt;&lt;/set&gt;</p>
<p>加载xml动画</p>
<pre><code>Animator anim = AnimatorInflater.loadAnimator(this, R.animator.animator_scale);</code></pre>
<p>      anim.setTarget(imageView);<br>      anim.start();</p>
<p>纯Java代码实现：</p>
<p>AnimatorSet animatorSet = new AnimatorSet();</p>
<p>    ObjectAnimator scaleXAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleX&quot;, 1f, 1.5f);<br>    scaleXAnimator.setDuration(500);<br>    scaleXAnimator.setRepeatCount(1);<br>    scaleXAnimator.setRepeatMode(ValueAnimator.REVERSE);<br>    scaleXAnimator.start();</p>
<p>    ObjectAnimator scaleYAnimator = ObjectAnimator.ofFloat(imageView, &quot;scaleY&quot;, 1f, 1.5f);<br>    scaleYAnimator.setDuration(500);<br>    scaleYAnimator.setRepeatCount(1);<br>    scaleYAnimator.setRepeatMode(ValueAnimator.REVERSE);</p>
<p>    animatorSet.playTogether(scaleXAnimator, scaleYAnimator);<br>    animatorSet.start();</p>
<p>上述代码通过playTogether函数实现两个动画同时执行，如果不想同时执行，也可以调用play函数返回AnimatorSet.Builder实例，AnimatorSet.Builder提供了如下几个函数用于实现动画组合：</p>
<p>after(Animator anim) 将现有动画插入到传入的动画之后执行</p>
<p>after(long delay) 将现有动画延迟指定毫秒后执行</p>
<p>before(Animator anim) 将现有动画插入到传入的动画之前执行</p>
<p>with(Animator anim) 将现有动画和传入的动画同时执行</p>
<p>也可以调用playSequentially函数实现分布执行动画。</p>
<p>  方式二：使用PropertyValuesHolder</p>
<p>PropertyValuesHolder scaleXValuesHolder = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.0f, 1.5f);<br>PropertyValuesHolder scaleYValuesHolder = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.0f, 1.5f);<br>ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(imageView, scaleXValuesHolder, scaleYValuesHolder);<br>    objectAnimator.setDuration(500);<br>    objectAnimator.setRepeatCount(1);<br>    objectAnimator.setRepeatMode(ValueAnimator.REVERSE);<br>    objectAnimator.start();</p>
<p>通过这种方式只能实现同时执行的动画组合相比AnimatorSet就没那么丰富了，PropertyValuesHolder 提供的函数方法有如下几种：ofInt()、ofFloat()、ofObject()、ofKeyframe()。</p>
<p>方式三：使用ViewPropertyAnimator</p>
<p> ViewPropertyAnimator viewPropertyAnimator=imageView.animate();<br> viewPropertyAnimator.scaleXBy(1.0f).scaleX(1.5f).scaleYBy(1.0f).scaleY(1.5f).setDuration(500).start();</p>
<p>多属性动画，作用于View，能够实现的动画相对单一，只能实现比如缩放，透明度改变，平移、旋转等，具体函数名字：平移 translationX，translationY, X，Y，缩放 scaleX，scaleY， 旋转 rotationX， rotationY，透明度 alpha</p>
<p>3.）设置动画监听器</p>
<p>有时候我们可能要在某一个动画执行之前 或者动画结束之后进行一些其他的操作，这个时候就要借助动画监听器了。</p>
<pre><code>objectAnimator.addListener(new Animator.AnimatorListener() &#123;</code></pre>
<p>    @Override<br>    public void onAnimationStart(Animator animation) {<br>        //TODO 动画开始前的操作    }</p>
<p>    @Override<br>    public void onAnimationEnd(Animator animation) {<br>        //TODO 动画结束的操作    }</p>
<p>    @Override<br>    public void onAnimationCancel(Animator animation) {<br>       //TODO 动画取消的操作    }</p>
<p>    @Override<br>    public void onAnimationRepeat(Animator animation) {<br>        //TODO 动画重复的操作    }<br>    });</p>
<p>如果我们需要简单动画执行过程中的变化可以使用AnimatorUpdateListener</p>
<p> objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {<br>    @Override<br>    public void onAnimationUpdate(ValueAnimator animation) {<br>        float value = (float) animation.getAnimatedValue();<br>        //可以根据自己的需要来获取动画更新值。<br>        Log.e(&quot;AnimatorUpdateListener&quot;, &quot;the animation value is &quot; + value);<br>    }<br>    });</p>
<p>ValueAnimator（差值动画）</p>
<p>    上篇文章一直使用的ObjectAnimator来实现属性动画，单纯从字面上理解的话ObjectAnimator作用于某个实际的对象，而ValueAnimator是ObjectAnimator的父类，它继承自抽象类Animator，它作用于一个值，将其由一个值变化为另外一个值，然后根据值的变化，按照一定的规则，动态修改View的属性，比如View的位置、透明度、旋转角度、大小等，即可完成了动画的效果。直接看下上面的数字动画是怎么实现的？</p>
<p>ValueAnimator valueAnimator =ValueAnimator.ofFloat( 0f, 126512.36f);<br>valueAnimator.setDuration(2000);<br>valueAnimator.setInterpolator(new LinearInterpolator());<br>valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {<br>    @Override<br>    public void onAnimationUpdate(ValueAnimator animation) {<br>    float money= (float) animation.getAnimatedValue();<br>    mTextView.setText(String.format(&quot;%.2f&quot;, money));<br>    }<br>});<br>valueAnimator.start();</p>
<p>这里通过ofFloat()方法构造一个ValueAnimator实例，除此之外还提供了其他函数ofInt()、ofObject()、ofPropertyValuesHolder()函数，api 21之后又提供了ofArgb()，每个函数都是可以传入多个改变值。</p>
<p>Interpolator（插值器）</p>
<p>   Interpolator插值器用于控制动画的变化速率，也可以简单的理解成用于控制动画的快慢，插值器目前都只是对动画执行过程的时间进行修饰，并没有对轨迹进行修饰。系统提供的插值器有以下几种：</p>
<p>插值器名字解说对应的xml</p>
<p>AccelerateInterpolator 加速，开始时慢中间加速 @android:anim/accelerate_interpolator</p>
<p>DecelerateInterpolator减速，开始时快然后减速@android:anim/decelerate_interpolator</p>
<p>AccelerateDecelerateInterolator　 先加速后减速，开始结束时慢，中间加速 @android:anim/accelerate_decelerate_interpolator</p>
<p>AnticipateInterpolator反向 ，先向相反方向改变一段再加速播放 @android:anim/anticipate_interpolator</p>
<p>AnticipateOvershootInterpolator反向加超越，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值@android:anim/anticipate_overshoot_interpolator</p>
<p>BounceInterpolator 跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100@android:anim/bounce_interpolator</p>
<p>CycleIinterpolator 循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2* mCycles* Math.PI* input)@android:anim/cycle_interpolator</p>
<p>LinearInterpolator 线性，线性均匀改变@android:anim/linear_interpolator</p>
<p>OvershootInterpolator超越，最后超出目的值然后缓慢改变到目的值@android:anim/overshoot_interpolator</p>
<p>通过上面的名字大家是不是很眼熟，是的和补间动画的插值器是一致的。Android的动画插值器采用策略设计模式，都是实现了Interpolator这个接口，而Interpolator又是继承自一个叫做TimeInterpolator的接口（从3.0开始，增加了TimeInterpolator这个接口，并把原先的Interpolator接口的抽象方法移到了其中，3.0后的Interpolator接口也就什么也没做，只是对父类改了个名字，达到向下兼容）。</p>
<p>package android.animation;public interface TimeInterpolator {</p>
<p>    float getInterpolation(float input);<br>}</p>
<p>在Interpolator的实现类里面，都实现了一个float getInterpolator(float input)的方法，传入参数是正常执行动画的时间点，返回值是用户真正想要它执行的时间点。上面的数字动画使用了匀速插值器LinearInterpolator其代码实现如下：</p>
<p>public class LinearInterpolator extends BaseInterpolator implements NativeInterpolatorFactory {</p>
<p>    public LinearInterpolator() {<br>    }</p>
<p>    public LinearInterpolator(Context context, AttributeSet attrs) {<br>    }</p>
<p>    public float getInterpolation(float input) {<br>        return input;<br>    }</p>
<p>    /** @hide */<br>    @Override<br>    public long createNativeInterpolator() {<br>        return NativeInterpolatorFactoryHelper.createLinearInterpolator();<br>    }<br>}</p>
<p>可以看出float getInterpolator(float input)返回的值就是当前要执行的时间点实现匀速执行动画。</p>
<p>如何自定义一个插值器？举例：我们实现一个先减速后加速插值器，代码如下</p>
<p>public class DecelerateAccelerateInterpolator implements Interpolator {<br>    @Override<br>    public float getInterpolation(float input) {<br>        float result;<br>        if (input &lt;= 0.5f) {<br>            result = (float) (Math.sin(Math.PI * input)) / 2.0f;<br>        } else {<br>            result = (float) (2 - Math.sin(Math.PI * input)) / 2.0f;<br>        }<br>        return result;<br>    }<br>}</p>
<p>TypeEvaluator（估值器）</p>
<p>  TypeEvaluator用于根据当前属性改变的百分比来计算改变后的属性值，系统提供了如下几种估值器</p>
<p>IntEvaluator 针对整型属性</p>
<p>IntArrayEvaluator 针对整型属性集合</p>
<p>FloatEvaluator 针对浮点型属性</p>
<p>FloatArrayEvaluator 针对浮点型属性集合</p>
<p>ArgbEvaluator  针对Color属性</p>
<p>RectEvaluator 针对Rect属性</p>
<p>PointFEvaluator 针对PointF属性</p>
<p>  TypeEvaluator设计也是采用策略设计模式，都实现TypeEvaluator接口，源代码如下：</p>
<p>package android.animation;public interface TypeEvaluator&lt;T&gt; {</p>
<p>    public T evaluate(float fraction, T startValue, T endValue);</p>
<p>}</p>
<p>接口提供了evaluate(float fraction, T startValue, T endValue);动画在运行过程中Interpolator自动计算出动画运行的百分比fraction，然后TypeEvaluator根据fraction计算出当前动画的属性值。以FloatEvaluator 代码为例：</p>
<p>public class FloatEvaluator implements TypeEvaluator&lt;Number&gt; {</p>
<p>    public Float evaluate(float fraction, Number startValue, Number endValue) {<br>        float startFloat = startValue.floatValue();<br>        return startFloat + fraction * (endValue.floatValue() - startFloat);<br>    }<br>}</p>
<p> 如何自定义TypeEvaLuator？比如我们要实现一个钱的增加，字体颜色越红的动画，我们现在都知道可以使用ofArgb(),但是ofArgb()需要api 21以上才能使用，所以需要我们自定义一个ArgbEvaLuator，这里为了演示自定义TypeEvaluator直接把api 21中提供的ArgbEvaluator源代码拿来使用，如下：</p>
<p>public class TextArgbEvaluator implements TypeEvaluator {<br>    <br>    public Object evaluate(float fraction, Object startValue, Object endValue) {<br>        int startInt = (Integer) startValue;<br>        int startA = (startInt &gt;&gt; 24) &amp; 0xff;<br>        int startR = (startInt &gt;&gt; 16) &amp; 0xff;<br>        int startG = (startInt &gt;&gt; 8) &amp; 0xff;<br>        int startB = startInt &amp; 0xff;</p>
<p>        int endInt = (Integer) endValue;<br>        int endA = (endInt &gt;&gt; 24) &amp; 0xff;<br>        int endR = (endInt &gt;&gt; 16) &amp; 0xff;<br>        int endG = (endInt &gt;&gt; 8) &amp; 0xff;<br>        int endB = endInt &amp; 0xff;</p>
<p>        return (int) ((startA + (int) (fraction * (endA - startA))) &lt;&lt; 24) |<br>                (int) ((startR + (int) (fraction * (endR - startR))) &lt;&lt; 16) |<br>                (int) ((startG + (int) (fraction * (endG - startG))) &lt;&lt; 8) |<br>                (int) ((startB + (int) (fraction * (endB - startB))));<br>    }<br>}</p>
<p>调用方式：</p>
<pre><code>    AnimatorSet animatorSet = new AnimatorSet();</code></pre>
<p>        ValueAnimator valueAnimator = ValueAnimator.ofFloat(0f, 126512.36f);<br>        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {<br>            @Override<br>            public void onAnimationUpdate(ValueAnimator animation) {<br>                float money = (float) animation.getAnimatedValue();<br>                Log.e(&quot;Interpolator&quot;, &quot;money—-&gt;&quot; + money);<br>                mTextView.setText(String.format(&quot;%.2f&quot;, money));<br>            }<br>        });</p>
<p>        int startColor = Color.parseColor(&quot;#FCA3AB&quot;);<br>        int endColor = Color.parseColor(&quot;#FB0435&quot;);<br>        ValueAnimator colorAnimator = ValueAnimator.ofObject(new TextArgbEvaluator(),startColor, endColor);<br>        colorAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {<br>            @Override<br>            public void onAnimationUpdate(ValueAnimator animation) {<br>                int color = (int) animation.getAnimatedValue();<br>                Log.e(&quot;Interpolator&quot;, &quot;color—-&gt;&quot; + color);<br>                mTextView.setTextColor(color);<br>            }<br>        });</p>
<p>        animatorSet.playTogether(valueAnimator,colorAnimator);<br>        animatorSet.setDuration(5000);<br>        animatorSet.setInterpolator(new LinearInterpolator());<br>        animatorSet.start();</p>
<p>运行效果：</p>
<p>ObjectAnimator</p>
<p>    上篇我们简单了学习了ObjectAnimator动画，并且通过ObjectAnimator实现了几种简单的动画效果，ObjectAnimator继承自ValueAnimator，所以主体方法还是ValueAnimator里实现的。先来回顾一下上篇的一个旋转动画例子。</p>
<p>ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(imageView, &quot;rotation&quot;, 0f, 360f);<br>    objectAnimator.setDuration(500);<br>    objectAnimator.setRepeatCount(1);<br>    objectAnimator.setRepeatMode(ValueAnimator.REVERSE);<br>    objectAnimator.start();</p>
<p>这个例子很简单，针对view的属性rotation进行持续时间为500ms的0到360的角度变换。属性名字rotation在View中有对应setRotation(),否则没有任何效果，而且参数类型必须为float型，否则没有任何效果。view常见可操作的参数有：x/y；scaleX/scaleY；rotationX/ rotationY；transitionX/ transitionY等等。现在问题来了，我们本篇例子是为TextView 赋值一个float型的值，我们查看TextView的函数并不找不到setText(float f),这时该怎么处理呢？如何为不具有get/set方法的属性提供修改方法呢？莫着急！谷歌为此提供了两种方法，第一种就是使用ValueAnimator来实现，就是上面所说的方式，另外一种方式通过自己写一个包装类，来为该属性提供get/set方法。</p>
<p>public class MoneyTextView extends TextView {<br>    public MoneyTextView(Context context, AttributeSet attrs) {<br>        super(context, attrs);<br>    }</p>
<p>    public void setText(float money) {<br>        setText(String.format(&quot;%.2f&quot;, money));<br>    }<br>}</p>
<p>然后就可以通过ObjectAnimator实现上面的数字动画效果了。</p>
<p> ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mTextView, &quot;text&quot;, 0f, 126512.36f);<br>    objectAnimator.setDuration(2000);<br>    objectAnimator.setInterpolator(new LinearInterpolator());<br>    objectAnimator.start();</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android系统启动过程</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>Android系统启动过程</p>
<p>首先Android框架架构图：</p>
<p>　　</p>
<p>Linux内核启动之后就到Android Init进程，进而启动Android相关的服务和应用。</p>
<p>启动的过程如下图所示：（图片来自网上，后面有地址）</p>
<p>　　　 </p>
<p>　　 </p>
<p>　　 </p>
<p>一 Init进程的启动</p>
<p>　　init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，</p>
<p>并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。init始终是第一个进程。</p>
<p>　　启动过程就是代码init.c中main函数执行过程：system\core\init\init.c</p>
<p>在函数中执行了：文件夹建立，挂载，rc文件解析，属性设置，启动服务，执行动作，socket监听……</p>
<p>下面看两个重要的过程：rc文件解析和服务启动。</p>
<p>1 rc文件解析</p>
<p>　　.rc文件是Android使用的初始化脚本文件 （System/Core/Init/readme.txt中有描述：</p>
<p>four broad classes of statements which are Actions, Commands, Services, and Options.）</p>
<p>　　其中Command 就是系统支持的一系列命令，如：export，hostname，mkdir，mount，等等，其中一部分是 linux 命令，</p>
<p>还有一些是 android 添加的，如：class_start &lt;serviceclass&gt;： 启动服务，class_stop &lt;serviceclass&gt;：关闭服务，等等。</p>
<p>　　其中Options是针对 Service 的选项的。</p>
<p>系统初始化要触发的动作和要启动的服务及其各自属性都在rc脚本文件中定义。 具体看一下启动脚本：\system\core\rootdir\init.rc</p>
<p>       在解析rc脚本文件时，将相应的类型放入各自的List中：</p>
<p>　　\system\core\init\Init_parser.c  ：init_parse_config_file( )存入到</p>
<p>　　action_queue、   action_list、 service_list中，解析过程可以看一下parse_config函数，类似状态机形式挺有意思。</p>
<p>　　这其中包含了服务：adbd、servicemanager、vold、ril-daemon、debuggerd、surfaceflinger、zygote、media……</p>
<p>2 服务启动</p>
<p>       文件解析完成之后将service放入到service_list中。</p>
<p>文件解析完成之后将service放入到service_list中。</p>
<p> 　　\system\core\init\builtins.c</p>
<p>Service的启动是在do_class_start函数中完成：</p>
<p>int do_class_start(int nargs, char **args)<br>{<br>    service_for_each_class(args[1], service_start_if_not_disabled);<br>    return 0;<br>}</p>
<p>遍历所有名称为classname，状态不为SVC_DISABLED的Service启动</p>
<p>void service_for_each_class(const char *classname,<br>                            void (*func)(struct service *svc))<br>{<br>       ……<br>}</p>
<p>static void service_start_if_not_disabled(struct service *svc)<br>{<br>    if (!(svc-&gt;flags &amp; SVC_DISABLED)) {<br>        service_start(svc, NULL);<br>    }<br>}</p>
<p>do_class_start对应的命令：</p>
<p>　　KEYWORD(class_start, COMMAND, 1, do_class_start)</p>
<p>init.rc文件中搜索class_start：class_start main 、class_start core、……</p>
<p>　　main、core即为do_class_start参数classname</p>
<p>init.rc文件中Service class名称都是main：</p>
<p>       service drm /system/bin/drmserver</p>
<p>　　　　class main</p>
<p>　　service surfaceflinger /system/bin/surfaceflinger</p>
<p>    　　　class main</p>
<p>于是就能够通过main名称遍历到所有的Service，将其启动。</p>
<p>do_class_start调用：</p>
<p>       init.rc中</p>
<p>　　　　on boot　　//action</p>
<p>　　　　　　class_start core　　　　//执行command 对应 do_class_start</p>
<p>    　　　　  class_start main</p>
<p>Init进程main函数中：</p>
<p>system/core/init/init.c中：</p>
<p>int main(){</p>
<p>　　　　　//挂在文件</p>
<p>       //解析配置文件：init.rc……</p>
<p>       //初始化化action queue</p>
<p>　　　　 ……<br>       for(;;){</p>
<pre><code>          execute_one_command();

          restart_processes();

          for (i = 0; i &amp;lt; fd_count; i++) &#123;

        if (ufds[i].revents == POLLIN) &#123;

            if (ufds[i].fd == get_property_set_fd())

                handle_property_set_fd();

            else if (ufds[i].fd == get_keychord_fd())

                handle_keychord();

            else if (ufds[i].fd == get_signal_fd())

                handle_signal();
        &#125;
    &#125;

   &#125;</code></pre>
<p>}</p>
<p>　　循环调用service_start，将状态SVC_RESTARTING启动， 将启动后的service状态设置为SVC_RUNNING。</p>
<p>　　pid=fork();</p>
<p>　　execve();</p>
<p>　　在消息循环中：Init进程执行了Android的Command，启动了Android的NativeService，监听Service的变化需求，Signal处理。</p>
<p>Init进程是作为属性服务（Property service），维护这些NativeService。</p>
<p>二 ServiceManager启动</p>
<p>       在.rc脚本文件中zygote的描述：</p>
<p>service servicemanager /system/bin/servicemanager<br>　　class core<br>　　user system<br>　　group system<br>　　critical<br>　　onrestart restart zygote<br>　　onrestart restart media<br>　　onrestart restart surfaceflinger<br>　　onrestart restart drm</p>
<p>ServiceManager用来管理系统中所有的binder service，不管是本地的c++实现的还是java语言实现的都需要</p>
<p>这个进程来统一管理，最主要的管理就是，注册添加服务，获取服务。所有的Service使用前都必须先在servicemanager中进行注册。</p>
<p>　　do_find_service( )</p>
<p>　　do_add_service( )</p>
<p>　　svcmgr_handler( )</p>
<p>　　代码位置：frameworks\base\cmds\servicemanager\Service_manager.c</p>
<p>三 Zygote进程的启动</p>
<p>　　Zygote这个进程是非常重要的一个进程，Zygote进程的建立是真正的Android运行空间，初始化建立的Service都是Navtive service.</p>
<p>（1） 在.rc脚本文件中zygote的描述：</p>
<p>service zygote /system/bin/app_process -Xzygote /system/bin –zygote –start-system-server<br>　　class main<br>　　socket zygote stream 666<br>　　onrestart write /sys/android_power/request_state wake<br>　　onrestart write /sys/power/state on<br>　　onrestart restart media<br>　　onrestart restart netd</p>
<p>参数：–zygote –start-system-server</p>
<p>代码位置：frameworks/base/cmds/app_process/app_main.cpp</p>
<p>上面的参数在这里就会用上，决定是否要启动和启动那些进程。</p>
<p>int main( ){<br>       AppRuntime runtime;<br>       if (zygote) {<br>              runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,<br>                startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);<br>       }<br>}</p>
<p>class AppRuntime : public AndroidRuntime{}；</p>
<p>（2） 接着到了AndroidRuntime类中：</p>
<p>frameworks\base\core\jni\AndroidRuntime.cpp</p>
<p>void start(const char* className, const char* options){</p>
<pre><code>   // start the virtual machine Java在虚拟机中运行的
   JNIEnv* env;
   if (startVm(&amp;amp;mJavaVM, &amp;amp;env) != 0) &#123;
          return;
   &#125;

   //向刚刚新建的虚拟机注册JNI本地接口
   if (startReg(env) &amp;lt; 0) &#123;
          return;
   &#125;</code></pre>
<p>　　　　// jni 调用 java 方法，获取对应类的静态main方法<br>　　　　jmethodID startMeth = env-&gt;GetStaticMethodID(startClass,<br>       　　&quot;main&quot;,&quot;([Ljava/lang/String;)V&quot;);</p>
<pre><code>   // jni调用 java方法，调用到ZygoteInit类的main函数

   jclass startClass = env-&amp;gt;FindClass(className);

   env-&amp;gt;CallStaticVoidMethod(startClass, startMeth, strArray);</code></pre>
<p>}</p>
<p>　　到了ZygoteInit.java中的静态main函数中，从C++ ——》JAVA</p>
<p>（3）ZygoteInit</p>
<p>       真正Zygote进程:</p>
<p>              frameworks\base\core\java\com\android\internal\os\ZygoteInit.java</p>
<p>public static void main(String argv[]) {<br>       //Registers a server socket for zygote command connections<br>       registerZygoteSocket();</p>
<pre><code>   //Loads and initializes commonly used classes and
   //used resources that can be shared across processes
   preload();

   // Do an initial gc to clean up after startup
   gc();

   if (argv[1].equals(&amp;quot;start-system-server&amp;quot;)) &#123;
          startSystemServer();
   &#125;</code></pre>
<p>/**<br>       * Runs the zygote process’s select loop. Accepts new connections as<br>       * they happen, and reads commands from connections one spawn-request’s<br>       * worth at a time.<br>       */</p>
<pre><code>   runSelectLoopMode();    //loop中
   /**
   * Close and clean up zygote sockets. Called on shutdown and on the
   * child&#39;s exit path.
   */
   closeServerSocket();</code></pre>
<p>}</p>
<p> Zygote就建立好了，利用Socket通讯，接收请求，Fork应用程序进程，进入Zygote进程服务框架中。</p>
<p>四 SystemServer启动</p>
<p>（1）在Zygote进程进入循环之前，调用了startSystemServer( );</p>
<p>private static boolean startSystemServer(){<br>       /* Request to fork the system server process 孵化新的进程 */<br>　　　　ZygoteConnection.Arguments parsedArgs = null;<br>       pid = Zygote.forkSystemServer(<br>              parsedArgs.uid, parsedArgs.gid,<br>              parsedArgs.gids,<br>              parsedArgs.debugFlags,<br>              null,<br>              parsedArgs.permittedCapabilities,<br>              parsedArgs.effectiveCapabilities);</p>
<pre><code>          /* For child process 对新的子进程设置 */
   if (pid == 0) &#123;
          handleSystemServerProcess(parsedArgs);
   &#125;</code></pre>
<p>}</p>
<p>void handleSystemServerProcess(parsedArgs){<br>       closeServerSocket();<br>       //&quot;system_server&quot;<br>       Process.setArgV0(parsedArgs.niceName);</p>
<pre><code>   //Pass the remaining arguments to SystemServer.</code></pre>
<p>　　　　RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,<br>　　　　　　parsedArgs.remainingArgs);<br>       /* should never reach here */<br>}</p>
<p>（2）RuntimeInit中：</p>
<p>       frameworks\base\core\java\com\android\internal\os\RuntimeInit.java</p>
<p>//The main function called when started through the zygote process.<br>void zygoteInit(int targetSdkVersion, String[] argv){<br>        applicationInit(targetSdkVersion, argv);<br>}</p>
<p>void applicationInit(int targetSdkVersion, String[] argv){<br>    // Remaining arguments are passed to the start class’s static main<br>    invokeStaticMain(args.startClass, args.startArgs);<br>}<br>void invokeStaticMain(String className, String[] argv){<br>    Class&lt;?&gt; cl;<br>    cl = Class.forName(className);</p>
<pre><code>//获取SystemServer的main方法，抛出MethodAndArgsCaller异常
Method m;
m = cl.getMethod(&amp;quot;main&amp;quot;, new Class[] &#123; String[].class &#125;);
int modifiers = m.getModifiers();
throw new ZygoteInit.MethodAndArgsCaller(m, argv);</code></pre>
<p>}</p>
<p>（3）从startSystemServer开始执行并没有去调用SystemServer的任何方法，</p>
<p>　　　　只是通过反射获取了main方法，付给了MethodAndArgsCaller，并抛出了MethodAndArgsCaller异常。</p>
<p>　　　　此异常是在哪里处理的呢？</p>
<p>       回到startSystemServer( )函数的调用处：</p>
<p>       在ZygoteInit的main函数中：</p>
<p>public static void main(String argv[]) {<br>       try {<br>              ……<br>              if (argv[1].equals(&quot;start-system-server&quot;)) {<br>                  startSystemServer();       //这里如果抛出异常，跳过下面流程<br>              }</p>
<p>　　　　　　　　runSelectLoopMode();    //loop中<br>              ……</p>
<pre><code>   &#125; catch (MethodAndArgsCaller caller) &#123;
          caller.run();        //处理的异常
   &#125;</code></pre>
<p>}</p>
<p>　　如果startSystemServer抛出了异常，跳过执行ZygoteInit进程的循环，这是怎么回事呢？</p>
<p>　　在startSystemServer中异常是由handleSystemServerProcess抛出，而</p>
<p>　　　　　　pid = Zygote.forkSystemServer( )</p>
<p>　　　　　　/* For child process 仅对新的子进程设置 */</p>
<p>　　　　　　if (pid == 0) {</p>
<p>　　　　　　　　handleSystemServerProcess(parsedArgs);</p>
<p>　　　　　　}</p>
<p>　　　　　　// Zygote.forkSystemServer根据参数fork 出一个子进程，若成功调用，则返回两次：</p>
<p>　　　　一次返回的是 zygote 进程的 pid ，值大于0；一次返回的是子进程 pid，值等于0否则，出错返回-1；</p>
<p>　　caller.run();</p>
<p>　　　　MethodAndArgsCaller run函数：调用前面所提到的</p>
<p>　　　　//SystemServer main方法</p>
<p>　　　　m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class });</p>
<p>　　　　启动了进程SystemServer。</p>
<p>（4）SystemServer的执行 init1( )</p>
<p>              //frameworks\base\services\java\com\android\server\SystemServer.java</p>
<p>public static void main(String[] args) {</p>
<pre><code>   　　System.loadLibrary(&amp;quot;android_servers&amp;quot;);    

   　　/*

   　　* This method is called from Zygote to initialize the system.
   　　* This will cause the native services (SurfaceFlinger, AudioFlinger, etc..)
   　　* to be started. After that it will call back
   　　* up into init2() to start the Android services.
  　　 */
  　　 init1(args);    //native 完了回调init2( )</code></pre>
<p>　　}</p>
<p>//init1:<br>　　frameworks/base/services/jni/com_android_server_SystemServer.cpp:: android_server_SystemServer_init1( )<br>　　中调用：system_init<br>extern &quot;C&quot; status_t system_init()<br>{<br>       sp&lt;ProcessState&gt; proc(ProcessState::self());<br>       sp&lt;IServiceManager&gt; sm = defaultServiceManager();</p>
<pre><code>   //启动SurfaceFlinger 和传感器
   property_get(&amp;quot;system_init.startsurfaceflinger&amp;quot;, propBuf, &amp;quot;1&amp;quot;);
   SurfaceFlinger::instantiate();

   property_get(&amp;quot;system_init.startsensorservice&amp;quot;, propBuf, &amp;quot;1&amp;quot;);
   SensorService::instantiate();

   // And now start the Android runtime.  We have to do this bit
   // of nastiness because the Android runtime initialization requires
   // some of the core system services to already be started.</code></pre>
<p>　　　　// All other servers should just start the Android runtime at<br>       // the beginning of their processes’s main(), before calling<br>       // the init function.<br>       AndroidRuntime* runtime = AndroidRuntime::getRuntime();</p>
<pre><code>   //回调 com.android.server.SystemServer init2 方法      

   JNIEnv* env = runtime-&amp;gt;getJNIEnv();

   jclass clazz = env-&amp;gt;FindClass(&amp;quot;com/android/server/SystemServer&amp;quot;);

   jmethodID methodId = env-&amp;gt;GetStaticMethodID(clazz, &amp;quot;init2&amp;quot;, &amp;quot;()V&amp;quot;);

   env-&amp;gt;CallStaticVoidMethod(clazz, methodId);


   //启动线程池 做为binder 服务
   ProcessState::self()-&amp;gt;startThreadPool();
   IPCThreadState::self()-&amp;gt;joinThreadPool();
   return NO_ERROR;</code></pre>
<p>}</p>
<p>ProcessState：</p>
<p>　　每个进程在使用binder 机制通信时，均需要维护一个ProcessState 实例来描述当前进程在binder 通信时的binder 状态。</p>
<p>　　ProcessState 有如下2 个主要功能：</p>
<p>　　1. 创建一个thread, 该线程负责与内核中的binder 模块进行通信，称该线程为Pool thread ；</p>
<p>　　2. 为指定的handle 创建一个BpBinder 对象，并管理该进程中所有的BpBinder 对象。</p>
<p>Pool thread：</p>
<p>　　在Binder IPC 中，所有进程均会启动一个thread 来负责与BD 来直接通信，也就是不停的读写BD ，</p>
<p>　　这个线程的实现主体是一个IPCThreadState 对象，下面会介绍这个类型。</p>
<p>　　下面是Pool thread 的启动方式：</p>
<p>　　ProcessState::self()-&gt;startThreadPool();</p>
<p>IPCThreadState ：</p>
<p>　　IPCThreadState 也是以单例模式设计的。由于每个进程只维护了一个ProcessState 实例，同时ProcessState 只启动一个Pool thread ，</p>
<p>也就是说每一个进程只会启动一个Pool thread ，因此每个进程则只需要一个IPCThreadState 即可。</p>
<p>Pool thread 的实际内容则为：</p>
<p>IPCThreadState::self()-&gt;joinThreadPool();</p>
<p>（5）SystemServer的执行 init2( )</p>
<p>public static final void init2() {<br>　　　　//建立线程来处理<br>       Thread thr = new ServerThread();<br>       thr.setName(&quot;android.server.ServerThread&quot;);<br>       thr.start();<br>}</p>
<p>//看看线程ServerThread里面都做了什么事情？<br>public void run() {<br>    addBootEvent(new String(&quot;Android:SysServerInit_START&quot;));<br>    Looper.prepare();<br>    android.os.Process.setThreadPriority(<br>    android.os.Process.THREAD_PRIORITY_FOREGROUND);</p>
<pre><code>//初始化服务，创建各种服务实例，如：电源、网络、Wifi、蓝牙，USB等，</code></pre>
<p>　　//初始化完成以后加入到 ServiceManager中，<br>    //事我们用 Context.getSystemService (String name) 才获取到相应的服务<br>    PowerManagerService power = null;<br>    NetworkManagementService networkManagement = null;<br>    WifiP2pService wifiP2p = null;<br>    WindowManagerService wm = null;<br>    BluetoothService bluetooth = null;<br>    UsbService usb = null;<br>    NotificationManagerService notification = null;<br>    StatusBarManagerService statusBar = null;<br>    ……<br>    power = new PowerManagerService();<br>    ServiceManager.addService(Context.POWER_SERVICE, power);<br>    ……</p>
<pre><code>// ActivityManagerService作为ApplicationFramework最重要的服务
ActivityManagerService.setSystemProcess();
ActivityManagerService.installSystemProviders();
ActivityManagerService.self().setWindowManager(wm);   </code></pre>
<p>　　// We now tell the activity manager it is okay to run third party<br>　　// code.  It will call back into us once it has gotten to the state<br>　　// where third party code can really run (but before it has actually<br>　　// started launching the initial applications), for us to complete our<br>　　// initialization.<br>　　//系统服务初始化准备就绪，通知各个模块<br>    ActivityManagerService.self().systemReady(new Runnable() {</p>
<pre><code>       public void run() &#123;
              startSystemUi(contextF);
              batteryF.systemReady();
              networkManagementF.systemReady();
              usbF.systemReady();
              ……

              // It is now okay to let the various system services start their
              // third party code...
              appWidgetF.systemReady(safeMode);
              wallpaperF.systemReady();
       &#125;
&#125;);

//
//BOOTPROF
addBootEvent(new String(&amp;quot;Android:SysServerInit_END&amp;quot;));
Looper.loop();</code></pre>
<p>}</p>
<p> 　　到这里系统ApplicationFramework层的XxxServiceManager准备就绪，可以开始跑上层应用了，我们的第一个上层应用HomeLauncher。</p>
<p>　　HomeActivity又是如何启动的呢？</p>
<p>　　Activity的启动必然和ActivityManagerService有关，我们需要去看看</p>
<p>　　ActivityManagerService.systemReady( )中都干了些什么。</p>
<p>五 Home界面启动</p>
<p>public void systemReady(final Runnable goingCallback) {<br>　　　　……<br>　　　　//ready callback<br>       if (goingCallback != null)<br>              goingCallback.run();<br>synchronized (this) {<br>              // Start up initial activity.<br>              // ActivityStack mMainStack;<br>              mMainStack.resumeTopActivityLocked(null);<br>       }<br>……</p>
<p>}</p>
<p>final boolean resumeTopActivityLocked(ActivityRecord prev) {<br>　　// Find the first activity that is not finishing.<br>　　ActivityRecord next = topRunningActivityLocked(null);<br>　　if (next == null) {<br>　　　　// There are no more activities!  Let’s just start up the<br>　　　　// Launcher…<br>　　　　if (mMainStack) {<br>　　　　　　//ActivityManagerService mService;<br>　　　　　　return mService.startHomeActivityLocked();<br>　　　　}<br>　　}<br>　　……<br>}</p>
<p>       然后就启动了Home界面，完成了整个Android启动流程。</p>
<p>      整个过程如下：</p>
<p>　　</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Apktool - Documentation</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Apktool%20-%20Documentation/</url>
    <content><![CDATA[<p>Introduction</p>
<p>Basic</p>
<p><a href="https://ibotpeaches.github.io/Apktool/documentation">https://ibotpeaches.github.io/Apktool/documentation</a></p>
<p>First lets take a lesson into apk files. Apks are nothing more than a zip file containing resources and assembled java code. If you were to simply unzip an apk like so, you would be left with files such as classes.dex and resources.arsc.</p>
<p>$ unzip testapp.apk<br>Archive:  testapp.apk<br> inflating: AndroidManifest.xml<br> inflating: classes.dex<br> extracting: res/drawable-hdpi/ic_launcher.png<br> inflating: res/xml/literals.xml<br> inflating: res/xml/references.xml<br> extracting: resources.arsc</p>
<p>However, at this point you have simply inflated compiled sources. If you tried to view AndroidManifest.xml. You’d be left viewing this.</p>
<p>P4F0\fnversionCodeversionNameandroid*<a href="http://schemas.android.com/apk/res/android%07package%18platformBuildVersionCode%18platformBuildVersionName%08manifest%14brut.apktool.testapp%031.0%0221%07APKTOOL">http://schemas.android.com/apk/res/androidpackageplatformBuildVersionCodeplatformBuildVersionNamemanifestbrut.apktool.testapp1.021APKTOOL</a></p>
<p>Obviously, editing or viewing a compiled file is next to impossible. That is where Apktool comes into play.</p>
<p>$ apktool d testapp.apkI: Using Apktool 2.0.0 on testapp.apk<br>I: Loading resource table…<br>I: Decoding AndroidManifest.xml with resources…<br>I: Loading resource table from file: 1.apk<br>I: Regular manifest package…<br>I: Decoding file-resources…<br>I: Decoding values <em>/</em> XMLs…<br>I: Baksmaling classes.dex…<br>I: Copying assets and libs…$</p>
<p>Viewing AndroidManifest.xml again results in something much more human readable</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;&lt;manifest xmlns:android=&quot;<a href="https://schemas.android.com/apk/res/android">https://schemas.android.com/apk/res/android</a>&quot; package=&quot;brut.apktool.testapp&quot;platformBuildVersionCode=&quot;21&quot; platformBuildVersionName=&quot;APKTOOL&quot; /&gt;</p>
<p>In addition to XMLs, resources such as 9 patch images, layouts, strings and much more are correctly decoded to source form.</p>
<p>Decoding</p>
<p>The decode option on Apktool can be invoked either from d or decode like shown below.</p>
<p>$ apktool d foo.jar// decodes foo.jar to foo.jar.out folder$ apktool decode foo.jar// decodes foo.jar to foo.jar.out folder$ apktool d bar.apk// decodes bar.apk to bar folder$ apktool decode bar.apk// decodes bar.apk to bar folder$ apktool d bar.apk -o baz// decodes bar.apk to baz folder</p>
<p>Building</p>
<p>The build option can be invoked either from b or build like shown below</p>
<p>$ apktool b foo.jar.out// builds foo.jar.out folder into foo.jar.out/dist/foo.jar file$ apktool build foo.jar.out// builds foo.jar.out folder into foo.jar.out/dist/foo.jar file$ apktool b bar// builds bar folder into bar/dist/bar.apk file$ apktool b .// builds current directory into ./dist$ apktool b bar -o new_bar.apk// builds bar folder into new_bar.apk$ apktool b bar.apk// WRONG: brut.androlib.AndrolibException: brut.directory.PathNotExist: apktool.yml// Must use folder, not apk/jar file</p>
<p>Info In order to run a rebuilt application. You must resign the application. Android documentation can help with this.</p>
<p>Frameworks</p>
<p>Frameworks can be installed either from if or install-framework, in addition two parameters</p>
<p>-p, –frame-path &lt;dir&gt; - Store framework files into &lt;dir&gt; </p>
<p>-t, –tag  &lt;tag&gt; - Tag frameworks using &lt;tag&gt;</p>
<p>Allow for a finer control over how the files are named and how they are stored.</p>
<p>$ apktool if framework-res.apkI: Framework installed to: 1.apk<br>// pkgId of framework-res.apk determines number (which is 0x01)$ apktool if com.htc.resources.apkI: Framework installed to: 2.apk<br>// pkgId of com.htc.resources is 0x02$ apktool if com.htc.resources.apk -t htcI: Framework installed to: 2-htc.apk<br>// pkgId-tag.apk$ apktool if framework-res.apk -p foo/barI: Framework installed to: foo/bar/1.apk$ apktool if framework-res.apk -t baz -p foo/barI: Framework installed to: foo/bar/1-baz.apk</p>
<p>Intermediate</p>
<p>Framework Files</p>
<p>As you probably know, Android apps utilize code and resources that are found on the Android OS itself. These are known as framework resources and Apktool relies on these to properly decode and build apks.<br>Every Apktool release contains internally the most up to date AOSP framework at the time of the release. This allows you to decode and build most apks without a problem. However, manufacturers add their own framework files in addition to the regular AOSP ones. To use apktool against these manufacturer apks you must first install the manufacturer framework files.</p>
<p>Example</p>
<p>Lets say you want to decode HtcContacts.apk from an HTC device. If you try you will get an error message.</p>
<p>$ apktool d HtcContacts.apkI: Loading resource table…<br>I: Decoding resources…<br>I: Loading resource table from file: 1.apk<br>W: Could not decode attr value, using undecoded value instead: ns=android, name=drawable<br>W: Could not decode attr value, using undecoded value instead: ns=android, name=iconCan’t find framework resources for package of id: 2. You must install proper framework files, see project website for more info.</p>
<p>We must get HTC framework resources before decoding this apk. We pull com.htc.resources.apk from our device and install it</p>
<p>$ apktool if com.htc.resources.apkI: Framework installed to: 2.apk</p>
<p>Now we will try this decode again.</p>
<p>$ apktool d HtcContacts.apk<br>I: Loading resource table…<br>I: Decoding resources…<br>I: Loading resource table from file: /home/brutall/apktool/framework/1.apk<br>I: Loading resource table from file: /home/brutall/apktool/framework/2.apkI: Copying assets and libs…</p>
<p>As you can see. Apktool leveraged both 1.apk and 2.apk framework files in order to properly decode this application.</p>
<p>Finding Frameworks</p>
<p>For the most part any apk in /system/framework on a device will be a framework file. On some devices they might reside in/data/system-framework and even cleverly hidden in /system/app or /system/priv-app. They are usually named with the naming of &quot;resources&quot;, &quot;res&quot; or &quot;framework&quot;.</p>
<p>Example HTC has a framework called com.htc.resources.apk, LG has one called lge-res.apk</p>
<p>After you find a framework file you could pull it viaadb pull /path/to/fileor use a file manager application. After you have the file locally, pay attention to how Apktool installs it. The number that the framework is named during install corresponds to the pkgId of the application. These values should range from 1 to 30. Any APK that installs itself as 127 is 0x7F which is an internal pkgId.</p>
<p>Internal Frameworks</p>
<p>Apktool comes with an internal framework like mentioned above. This file is copied to $HOME/apktool/framework/1.apk during use.</p>
<p>Warning Apktool has no knowledge of what version of framework resides there. It will assume its up to date, so delete the file during Apktool upgrades</p>
<p>Managing framework files</p>
<p>Frameworks are stored in different places depending on the OS in question.</p>
<p>unix - $HOME/.local/share/apktool</p>
<p>windows - $HOME/AppData/Local/apktool</p>
<p>mac - $HOME/Library/apktool</p>
<p>If these directories are not available it will default to java.io.tmpdir which is usually /tmp. This is a volatile directory so it would make sense to take advantage of the parameter –frame-path to select an alternative folder for framework files.<br>Since these locations are in sometimes hidden directories, managing these frameworks becomes a challenge. A simple helper function (added in v2.2.1) allows you to run apktool empty-framework-dir to empty out frameworks.</p>
<p>Note Apktool has no control over the frameworks once installed, but you are free to manage these files on your own.</p>
<p>Tagging framework files</p>
<p>Frameworks are stored in the naming convention of: &lt;id&gt;-&lt;tag&gt;.apk. They are identified by pkgId and optionally custom tag. Usually tagging frameworks isn’t necessary, but if you work on apps from many different devices and they have incompatible frameworks, you will need some way to easily switch between them. You could tag frameworks by:</p>
<p>$ apktool if com.htc.resources.apk -t heroI: Framework installed to: /home/brutall/apktool/framework/2-hero.apk$ apktool if com.htc.resources.apk -t desireI: Framework installed to: /home/brutall/apktool/framework/2-desire.apk</p>
<p>Then:</p>
<p>$ apktool d HtcContacts.apk -t heroI: Loading resource table…<br>I: Decoding resources…<br>I: Loading resource table from file: /home/brutall/apktool/framework/1.apk<br>I: Loading resource table from file: /home/brutall/apktool/framework/2-hero.apk<br>I: Copying assets and libs…$ apktool d HtcContacts.apk -t desireI: Loading resource table…<br>I: Decoding resources…<br>I: Loading resource table from file: /home/brutall/apktool/framework/1.apk<br>I: Loading resource table from file: /home/brutall/apktool/framework/2-desire.apkI: Copying assets and libs…</p>
<p>You don’t have to select a tag when building apk - apktool automatically uses the same tag, as when decoding.</p>
<p>Smali Debugging</p>
<p>Warning SmaliDebugging has been marked as deprecated in 2.0.3, and removed in 2.1. Please check SmaliIdea for a debugger.</p>
<p>9Patch Images</p>
<p>Docs exist for the mysterious 9patch images hereand there. (Read these first). These docs though are meant for developers and lack information for those who work with already compiled 3rd party applications. There you can find information how to create them, but no information about how they actually work.<br>I will try and explain it here. The official docs miss one point that 9patch images come in two forms: source &amp; compiled.</p>
<p>source - You know this one. You find it in the source of an application or freely available online. These  are images with a black border around them.</p>
<p>compiled - The mysterious form found in apk files. There are no borders and the 9patch data is written into  a binary chunk called npTc. You can’t see or modify it easily, but Android OS can as its quicker to read.</p>
<p>There are problems related to the above two points.</p>
<p>You can’t move 9patch images between both types without a conversion. If you try and unpack 9patch images from an apk and use it  in the source of another, you will get errors during build. Also vice versa, you cannot take source 9patch images directly into an apk.</p>
<p>9patch binary chunk isn’t recognized by modern image processing tools. So modifying the compiled image will more than likely break the  npTc chunk, thus breaking the image on the device.</p>
<p>The only solution to this problem is to easily convert between these two types. The encoder (which takes source to compiled) is built into the aapt tool and is automatically used during build. This means we only need to build a decoder which has been in apktool since v1.3.0and is automatically ran on all 9patch images during decode.<br>So if you want to modify 9patch images, don’t do it directly. Use apktool to decode the application (including the 9patch images) and then modify the images. At that point when you build the application back, the source 9patch images will be compiled.</p>
<p>Other</p>
<p>FAQ</p>
<p>What about the -j switch shown from the original YouTube videos?<br>Read Issue 199. In short - it doesn’t exist.<br>Is it possible to run apktool on a device?<br>Sadly not. There are some incompatibilities with SnakeYAML, java.nio and aapt<br>Where can I download sources of apktool?<br>From our Github or Bitbucket project.<br>Resulting apk file is much smaller than original! Is there something missing?<br>There are a couple of reasons that might cause this.</p>
<p>Apktool builds unsigned apks. This means an entire directory META-INF is missing.</p>
<p>New aapt binary. Newer versions of apktool contain a newer aapt which optimizes images differently.</p>
<p>These points might have contributed to a smaller than normal apk<br>There is no META-INF dir in resulting apk. Is this ok?<br>Yes. META-INF contains apk signatures. After modifying the apk it is no longer signed. You can use -c / –copy-original to retain these signatures. However, using -c uses the original AndroidManifest.xml file, so changes to it will be lost.<br>What do you call &quot;magic apks&quot;?<br>For some reason there are apks that are built using modified build tools. These apks don’t work on a regular AOSP Android build, but usually are accompanied by a modified system that can read these modified apks. Apktool cannot handle these apks, therefore they are &quot;magic&quot;.<br>Could I integrate apktool into my own tool? Could I modify apktool sources? Do I have to credit you?<br>Actually the Apache License, which apktool uses, answers all these questions. Yes you can redistribute and/or modify apktool without my permission. However, if you do it would be nice to add our contributors (brut.all, iBotPeaches and JesusFreke) into your credits but it’s not required.<br>Where does apktool store its framework files?</p>
<p>unix -</p>
<p>$HOME/.local/share/apktool</p>
<p>mac -</p>
<p>$HOME/Library/apktool</p>
<p>windows -</p>
<p>$HOME/AppData/Local/apktool</p>
<p>Migration Instructions</p>
<p>v2.2.0 -&gt; v2.2.1</p>
<p>Update apktool to v2.2.1</p>
<p>apktool empty-framework-dir –force</p>
<p>v2.1.1 -&gt; v2.2.0</p>
<p>Run the following commands to migrate your framework directory</p>
<p>Apktool will work fine without running these commands, this will just cleanup abandoned files</p>
<p>unix -</p>
<p>mkdir -p ~/.local/share; mv ~/apktool ~/.local/share</p>
<p>windows -</p>
<p>move %USERPROFILE%\apktool %USERPROFILE%\AppData\Local</p>
<p>v2.0.1 -&gt; v2.0.2</p>
<p>Update apktool to v2.0.2</p>
<p>Remove framework file $HOME/apktool/framework/1.apk due to internal API update (Android Marshmallow)</p>
<p>v1.5.x -&gt; v2.0.0</p>
<p>Java 1.7 is required</p>
<p>Update apktool to v2.0.0</p>
<p>aapt is now included inside the apktool binary. It’s not required to maintain your own aapt install under $PATH. (However, features like -a / –aapt are still used and can override the internal aapt)</p>
<p>The addition of aapt replaces the need for separate aapt download packages. Helper Scripts may be found here</p>
<p>Remove framework $HOME/apktool/framework/1.apk</p>
<p>Eagle eyed users will notice resources are now decoded before sources now. This is because we need to know the API version via the manifest for decoding the sources</p>
<p>Parameter Changes</p>
<p>Smali/baksmali 2.0 are included. This is a big change from 1.4.2. Please read the smali updates here for more information</p>
<p>-o / –output is now used for the output of apk/directory</p>
<p>-t / –tag is required for tagging framework files</p>
<p>-advance / –advanced will launch advance parameters and information on the usage output</p>
<p>-m / –match-original is a new feature for apk analysis. This retains the apk is nearly original format, but will make rebuild more than likely not work due to ignoring the changes that newer aapt requires</p>
<p>After [d]ecode, there will be new folders (original / unknown) in the decoded apk folder</p>
<p>original = META-INF folder / AndroidManifest.xml, which are needed to retain the signature of apks to prevent needing to resign. Used with -c / –copy-original on [b]uild</p>
<p>unknown = Files / folders that are not part of the standard AOSP build procedure. These files will be injected back into the rebuilt APK.</p>
<p>apktool.yml collects more information than last version</p>
<p>SdkInfo - Used to repopulate the sdk information in AndroidManifest.xml since newer aapt requires version information to be passed via parameter</p>
<p>packageInfo - Used to help support Android 4.2 renamed manifest feature. Automatically detects differences between resource and manifest and performs automatic –rename-manifest-package on [b]uild</p>
<p>versionInfo - Used to repopulate the version information in AndroidManifest.xml since newer aapt requires version information to be passed via parameter</p>
<p>compressionType - Used to determine the compression that resources.arsc had on the original apk in order to replicate during [b]uild</p>
<p>unknownFiles - Used to record name/location of non-standard files in an apk in order to place correctly on rebuilt apk</p>
<p>sharedLibrary - Used to help support Android 5 shared library feature by automatically detecting shared libraries and using –shared-lib on [b]uild</p>
<p>Examples of new usage in 2.0 vs 1.5.x</p>
<p>Old (Apktool 1.5.x)New (Apktool 2.0.x)</p>
<p>apktool if framework-res.apk tagapktool if framework-res.apk -t tag</p>
<p>apktool d framework-res.apk outputapktool d framework.res.apk -o output</p>
<p>apktool b output new.apkapktool b output -o new.apk</p>
<p>v1.4.x -&gt; v1.5.1</p>
<p>Update apktool to v1.5.1</p>
<p>Update aapt manually or use package r05-ibot via downloading Mac, Windows or Linux</p>
<p>Remove framework file $HOME/apktool/framework/1.apk</p>
<p>Options</p>
<p>Utility</p>
<p>Options that can be executed at any time.<br>-version, –version</p>
<p>Outputs current version. (Ex: 1.5.2)</p>
<p>-v, –verbose</p>
<p>Verbose output. Must be first parameter</p>
<p>-q, –quiet</p>
<p>Quiet output. Must be first parameter</p>
<p>-advance, –advanced</p>
<p>Advance usage output</p>
<p>Decode</p>
<p>These are all the options when decoding an apk.<br>–api &lt;API&gt;</p>
<p>The numeric api-level of the smali files to generate (defaults to targetSdkVersion)</p>
<p>-b, –no-debug-info</p>
<p>Prevents baksmali from writing out debug info (.local, .param, .line, etc). Preferred to use if you are comparing smali from the same APK of different versions. The line numbers and debug will change among versions, which can make DIFF reports a pain.</p>
<p>-f, –force</p>
<p>Force delete destination directory. Use when trying to decode to a folder that already exists</p>
<p>–keep-broken-res - Advanced</p>
<p>If there is an error like &quot;Invalid Config Flags Detected. Dropping Resources…&quot;. This means that APK has a different structure then Apktool can handle. This might be a newer Android version or a random APK that doesn’t match standards. Running this will allow the decode, but then you have to manually fix the folders with -ERR in them.</p>
<p>-m, –match-original - Used for analysis</p>
<p>Matches files closest as possible to original, but prevents rebuild.</p>
<p>-o, –output &lt;DIR&gt;</p>
<p>The name of the folder that apk gets written to</p>
<p>-p, –frame-path &lt;DIR&gt;</p>
<p>The folder location where framework files should be stored/read from</p>
<p>-r, –no-res</p>
<p>This will prevent the decompile of resources. This keeps the resources.arsc intact without any decode. If only editing Java (smali) then this is the recommended action for faster decompile &amp; rebuild</p>
<p>-s, –no-src</p>
<p>This will prevent the disassembly of the dex file(s). This keeps the apk dex file(s) and simply moves it during build. If you are only editing the resources. This is the recommended action for faster disassemble &amp; assemble</p>
<p>-t, –frame-tag &lt;TAG&gt;</p>
<p>Uses framework files tagged via &lt;TAG&gt;</p>
<p>Rebuild</p>
<p>These are all the options when building an apk.<br>-a, –aapt &lt;FILE&gt;</p>
<p>Loads aapt from the specified file location, instead of relying on path. Falls back to $PATH loading, if no file found</p>
<p>-c, –copy-original - Will still require signature resign post API18</p>
<p>Copies original AndroidManifest.xml and META-INF folder into built apk</p>
<p>-d, –debug</p>
<p>Adds debuggable=&quot;true&quot; to AndroidManifest file.</p>
<p>-f, –force-all</p>
<p>Overwrites existing files during build, reassembling the resources.arsc file and dex file(s)</p>
<p>-o, –output &lt;FILE&gt;</p>
<p>The name and location of the apk that gets written</p>
<p>-p, –frame-path &lt;DIR&gt;</p>
<p>The location where framework files are loaded from</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Binder基本概念流程学习</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Binder%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>一 Media Service进程启动</p>
<p>Init.rc中描述的service对应linux 的进程：</p>
<p>Media进程定义：</p>
<p>service media /system/bin/mediaserver<br>    class main<br>    user media<br>    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc<br>    ioprio rt 4</p>
<p>servicemanager 进程定义：</p>
<p>service servicemanager /system/bin/servicemanager<br>    class core<br>    user system<br>　　group system</p>
<p>　　Media中有很多Native Service（AudioFlinger MediaPlayerService CameraService <br>AudioPolicyService等），整个Android（native或者framework）的Service都需要加入<br>servicemanager中进行统一管理。<br>　　那么Media Process 与ServiceManager Process是如何进行通信的呢——Binder.<br>通过Media Process中使用binder进行完成IPC过程，学习Binder的概念和使用方法。 </p>
<p>\frameworks\av\media\mediaserver\ main_mediaserver.cpp：</p>
<p>int main(int argc, char** argv)<br>{<br>    //创建ProcessState 当前进程属性<br>    sp&lt;ProcessState&gt; proc(ProcessState::self());</p>
<pre><code>//IServiceManager对象
sp&amp;lt;IServiceManager&amp;gt; sm = defaultServiceManager();

//初始化MediaPlayerService服务对象
MediaPlayerService::instantiate();
……

//启动进程的线程池
ProcessState::self()-&amp;gt;startThreadPool();
//执行线程消息循环
IPCThreadState::self()-&amp;gt;joinThreadPool();</code></pre>
<p>}</p>
<p>　　Sp：指针运算符和普通运算符的重载 StrongPointer。</p>
<p>二 Media Process执行过程</p>
<p>1 ProcessState对象创建</p>
<p>当前进程的状态属性，对象创建：</p>
<p>sp&lt;ProcessState&gt; ProcessState::self()<br>{<br>    Mutex::Autolock _l(gProcessMutex);<br>    if (gProcess != NULL) {<br>        return gProcess;<br>    }<br>    gProcess = new ProcessState;<br>    return gProcess;<br>}</p>
<p>ProcessState构造函数：</p>
<p>ProcessState::ProcessState()<br>    : mDriverFD(open_driver())    //打开binder驱动设备<br>    , mVMStart(MAP_FAILED)<br>    , mManagesContexts(false)<br>    , mBinderContextCheckFunc(NULL)<br>    , mBinderContextUserData(NULL)<br>    , mThreadPoolStarted(false)<br>    , mThreadPoolSeq(1)<br>{<br>    if (mDriverFD &gt;= 0) {<br>        //将binder的fd映射到当前进程虚拟空间地址中 与binder进行交互<br>        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ,<br>　　　　　　　　MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);<br>    }<br>}</p>
<p>打开binder设备：</p>
<p>static int open_driver()<br>{<br>    //打开binder设备驱动<br>    int fd = open(&quot;/dev/binder&quot;, O_RDWR);<br>    if (fd &gt;= 0) {<br>        //bidner最大支持线程数<br>        size_t maxThreads = 15;<br>        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);<br>    }<br>    return fd;<br>}</p>
<p>ProcessState对象创建过程所做的事：<br>　　打开/dev/binder设备，得到binder设备的fd；<br>　　将bidner设备fd映射到当前进程虚拟地址空间建立交互的通道； </p>
<p>2 IServiceManager对象创建<br>　　sp&lt;IServiceManager&gt; sm = defaultServiceManager();<br>为什么需要一个IServiceManager对象呢，这个类是个抽象提供接口 </p>
<p>class IServiceManager : public IInterface<br>{<br>    virtual sp&lt;IBinder&gt; getService( const String16&amp; name) const = 0;<br>    virtual status_t addService( const String16&amp; name,<br>                             const sp&lt;IBinder&gt;&amp; service,<br>                             bool allowIsolated = false) = 0;<br>    ……<br>};</p>
<p>　　通过IServiceManager派生对象操作将Service加入到ServiceManager中.</p>
<p>defaultServiceManager()函数：</p>
<p>sp&lt;IServiceManager&gt; defaultServiceManager()<br>{<br>    //单例对象<br>    if (gDefaultServiceManager != NULL)<br>        return gDefaultServiceManager;</p>
<pre><code>AutoMutex _l(gDefaultServiceManagerLock);
if (gDefaultServiceManager == NULL) &#123;
    //创建对象
    gDefaultServiceManager = interface_cast&amp;lt;IServiceManager&amp;gt;(
            ProcessState::self()-&amp;gt;getContextObject(NULL));
&#125;
return gDefaultServiceManager;</code></pre>
<p>} </p>
<p>ProcessState::self()-&gt;getContextObject(NULL)：得到一个IBinder对象</p>
<p>　　ProcessState::self()刚才所创建的ProcessState对象。</p>
<p>sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; caller)<br>{<br>    return getStrongProxyForHandle(0);<br>}</p>
<p>sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)<br>{<br>    sp&lt;IBinder&gt; result;<br>    AutoMutex _l(mLock);<br>    //从表中查询一个handle对应的handle_entry<br>    //若没有则创建一个 handle == 0<br>    handle_entry* e = lookupHandleLocked(handle);</p>
<pre><code>if (e != NULL) &#123;
    IBinder* b = e-&amp;gt;binder;
    if (b == NULL || !e-&amp;gt;refs-&amp;gt;attemptIncWeak(this)) &#123;
        //handle_entry对象成员初始化 创建handle=0的BpBinder 
        b = new BpBinder(handle); 
        e-&amp;gt;binder = b;
        if (b) e-&amp;gt;refs = b-&amp;gt;getWeakRefs();
        result = b;
    &#125;
&#125;
return result;</code></pre>
<p>}</p>
<p>　　handle_entry是什么呢？</p>
<p>　　　　　　struct handle_entry {<br>                IBinder* binder;<br>                RefBase::weakref_type* refs;<br>            };</p>
<p>　　也就是说ProcessState 有一个表Vector&lt;handle_entry&gt;mHandleToObject;</p>
<p>表里面的每一项存储了一个binder，每一个binder对应一个handle。</p>
<p>　　</p>
<p>　　Handle = 0是什么，句柄？ 代表谁的句柄——ServiceManager在binder中的资源。<br>从ProcessState::self()-&gt;getContextObject(NULL)得到一个 IBinder——BpBinder(0);<br>于是得到：<br>　　gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(BpBinder(0))； </p>
<p>使用interface_cast将IBinder实例转化成IServiceManager实例。</p>
<p>3 interface_cast函数</p>
<p>\frameworks\native\include\binder\IInterface.h：</p>
<p>interface_cast是个内联模板函数：　</p>
<p>template&lt;typename INTERFACE&gt;<br>inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)<br>{<br>    return INTERFACE::asInterface(obj);<br>}</p>
<p>结合前面就是：</p>
<p>inline sp&lt;IServiceManager&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)<br>{<br>    return IServiceManager::asInterface(obj);<br>}</p>
<p>所以需要到IServiceManager里面去看看是如何实现的</p>
<p>4 IServiceManager类</p>
<p>\frameworks\native\include\binder\IServiceManager.h：</p>
<p>IServiceManager是一个抽象类：</p>
<p>class IServiceManager : public IInterface<br>{<br>　　public:<br>      //宏声明<br>    DECLARE_META_INTERFACE(ServiceManager);<br>    virtual sp&lt;IBinder&gt; getService( const String16&amp; name) const = 0;<br>    virtual status_t addService( const String16&amp; name,<br>                                 const sp&lt;IBinder&gt;&amp; service,<br>                                 bool allowIsolated = false) = 0;<br>    ……<br>}</p>
<p>DECLARE_META_INTERFACE声明：</p>
<p>#define DECLARE_META_INTERFACE(INTERFACE)                               <br>    static const android::String16 descriptor;                          <br>    static android::sp&lt;I##INTERFACE&gt; asInterface(                       <br>            const android::sp&lt;android::IBinder&gt;&amp; obj);                  <br>    virtual const android::String16&amp; getInterfaceDescriptor() const;    <br>    I##INTERFACE();                                                     <br>    virtual ~I##INTERFACE();                                            \ </p>
<p>替换成IServiceManager：</p>
<p>//实现时传入：android.os.IServiceManager<br>static const android::String16 descriptor;<br>static android::sp&lt;IServiceManager&gt; asInterface(<br>const android::sp&lt;android::IBinder&gt;&amp; obj);<br>virtual const android::String16&amp; getInterfaceDescriptor() const;<br>//构造析构函数<br>IServiceManager();<br>virtual ~IServiceManager(); </p>
<p>实现\frameworks\native\include\binder\IServiceManager.cpp：</p>
<p>IMPLEMENT_META_INTERFACE(ServiceManager, &quot;android.os.IServiceManager&quot;);</p>
<p>IMPLEMENT_META_INTERFACE实现：<br>看一下asInterface接口： </p>
<p>#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       <br>    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                <br>            const android::sp&lt;android::IBinder&gt;&amp; obj)                   <br>    {                                                                   <br>        android::sp&lt;I##INTERFACE&gt; intr;                                 <br>        if (obj != NULL) {                                              <br>            intr = static_cast&lt;I##INTERFACE*&gt;(                          <br>                obj-&gt;queryLocalInterface(                               <br>                        I##INTERFACE::descriptor).get());               <br>            if (intr == NULL) {                                         <br>                intr = new Bp##INTERFACE(obj);                          <br>            }                                                           <br>        }                                                               <br>        return intr;                                                    <br>}       　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 \</p>
<p>替换成IServiceManager:</p>
<p>android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(<br>            const android::sp&lt;android::IBinder&gt;&amp; obj)<br>{<br>        //obj BpBinder实例<br>        android::sp&lt;IServiceManager&gt; intr;<br>        if (obj != NULL) {<br>            //返回NULL<br>            intr = static_cast&lt;IServiceManager*&gt;(<br>                obj-&gt;queryLocalInterface(<br>                        IServiceManager::descriptor).get());<br>            if (intr == NULL) {<br>                intr = new BpServiceManager(obj);<br>            }<br>        }<br>        return intr;<br>}</p>
<p>这里得到IServiceManager 实例：</p>
<p>　　BpServiceManager：new BpServiceManager（new BpBinder（0））；</p>
<p>5 BpServiceManager 和 BpInterface类</p>
<p>\frameworks\native\libs\binder\ IServiceManager.cpp：BpServiceManager</p>
<p>class BpServiceManager : public BpInterface&lt;IServiceManager&gt;<br>{<br>public:<br>      //impl就是 new BpBinder（0）<br>    BpServiceManager(const sp&lt;IBinder&gt;&amp; impl)<br>        : BpInterface&lt;IServiceManager&gt;(impl)<br>    {<br>    }</p>
<pre><code>virtual sp&amp;lt;IBinder&amp;gt; checkService(const String16&amp;amp; name) const
&#123;
    ……
    remote()-&amp;gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;amp;reply);
&#125;

virtual status_t addService(const String16&amp;amp; name, const sp&amp;lt;IBinder&amp;gt;&amp;amp; service,
        bool allowIsolated)
&#123;
    ……
    remote()-&amp;gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;amp;reply);
&#125;</code></pre>
<p>}</p>
<p>\frameworks\native\include\binder\ IInterface.h：模板类BpInterface</p>
<p>template&lt;typename INTERFACE&gt;<br>class BpInterface : public INTERFACE, public BpRefBase    // INTERFACE IServiceManager<br>{<br>　　public:<br>　　　　BpInterface(const sp&lt;IBinder&gt;&amp; remote);<br>　　protected:<br>　　　　virtual IBinder* onAsBinder();<br>};</p>
<p>BpInterface构造函数：</p>
<dl><dt>template&lt;typename INTERFACE&gt;<br>inline BpInterface&lt;INTERFACE&gt;::BpInterface(const sp&lt;IBinder&gt;&amp; remote)</dt><dd>BpRefBase(remote)<br>{<br>}</dd></dl><p>BpRefBase构造函数：</p>
<dl><dt>BpRefBase::BpRefBase(const sp&lt;IBinder&gt;&amp; o)</dt><dd>mRemote(o.get()), mRefs(NULL), mState(0)<br>{<br>　　// IBinder mRemote 指向 o.get() ：new BpBinder（0）<br>}</dd></dl><h1 id="gDefaultServiceManager"><a href="#gDefaultServiceManager" class="headerlink" title="　　gDefaultServiceManager"></a>　　gDefaultServiceManager</h1><p>interface_cast&lt;IServiceManager&gt;(BpBinder(0))；</p>
<p>实际为：</p>
<p>　　gDefaultServiceManager = new BpServiceManager（new<br>BpBinder（0））；</p>
<p>Bn代表Binder Native Bp代表Binder Proxy</p>
<p>BpServiceManager代理的BpBinder实例 BpBinder代理的handle（0）</p>
<p>这个关系有些复杂，看一下类继承结构图：</p>
<p>　　</p>
<p>　　上面这个结构看起来感觉很熟悉——Bridge模式。将Binder数据交互和功能处理桥接起来。</p>
<p>在Media<br>Process 的main函数中通过：</p>
<p>　　sp&lt;IServiceManager&gt;<br>sm = defaultServiceManager();<br>　　我们得到了sm：是BpServiceManager对象。</p>
<p>三<br>MediaPlayerService加入到ServiceManager中</p>
<p>回到main函数中：</p>
<p>int main(int argc, char** argv)<br>{<br>    //创建ProcessState 当前进程属性<br>    sp&lt;ProcessState&gt; proc(ProcessState::self());</p>
<pre><code>//IServiceManager对象
sp&amp;lt;IServiceManager&amp;gt; sm = defaultServiceManager();

//初始化MediaPlayerService服务对象
MediaPlayerService::instantiate();     //执行到这里
……

//启动进程的线程池
ProcessState::self()-&amp;gt;startThreadPool();
//执行线程消息循环
IPCThreadState::self()-&amp;gt;joinThreadPool();</code></pre>
<p>}</p>
<p>1<br>MediaPlayerService初始化过程</p>
<p>void MediaPlayerService::instantiate() {<br>　　// defaultServiceManager就是上面所述得到的BpServiceManager对象<br>　　defaultServiceManager()-&gt;addService(<br>　　　　String16(&quot;media.player&quot;), new MediaPlayerService());<br>}</p>
<p>BpServiceManager添加Service：</p>
<p>virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service,<br>            bool allowIsolated)<br>{<br>        //生成数据包Parcel<br>        Parcel data, reply;<br>        // Write RPC headers 写入Interface名字 得到“android.os.IServiceManager”<br>        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());<br>        //写入Service名字 “media.player”<br>        data.writeString16(name);<br>        //写入服务<br>        data.writeStrongBinder(service);<br>        data.writeInt32(allowIsolated ? 1 : 0);<br>        // remote()返回BpBinder对象<br>        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);<br>        return err == NO_ERROR ? reply.readExceptionCode() : err;<br>}</p>
<p>remote()-&gt;transact<br>到BpBinder中：</p>
<p>status_t BpBinder::transact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>if (mAlive) {<br>        //到当前进程IPCThreadState中 mHandle=0<br>        status_t status = IPCThreadState::self()-&gt;transact(<br>            mHandle, code, data, reply, flags);<br>        if (status == DEAD_OBJECT) mAlive = 0;<br>        return status;<br>    }<br>    return DEAD_OBJECT;<br>}</p>
<p>2<br>IPCThreadState中写入数据到Binder设备过程</p>
<p>IPCThreadState::self()-&gt;transact过程：</p>
<p>status_t IPCThreadState::transact(int32_t handle,<br>                            uint32_t code, const Parcel&amp; data,<br>                            Parcel* reply, uint32_t flags)<br>{<br>    status_t err = data.errorCheck();</p>
<pre><code>flags |= TF_ACCEPT_FDS;
//将数据转化成binder_transaction_data 写入到Parcel实例mOut中
err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
//写入数据
err = waitForResponse(reply);
return err;</code></pre>
<p>} </p>
<p>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)<br>{<br>    while (1) {<br>        //将数据写入到Binder设备中<br>        talkWithDriver();<br>        ……<br>    }<br>    return err;<br>}</p>
<p>status_t IPCThreadState::talkWithDriver(bool doReceive)<br>{<br>    //将数据封装成binder_write_read结构<br>    binder_write_read bwr;</p>
<pre><code>do &#123;
    //将数据写入到所打开的Binder设备中
    ioctl(mProcess-&amp;gt;mDriverFD, BINDER_WRITE_READ, &amp;amp;bwr)
    ……

&#125; while (err == -EINTR);
return NO_ERROR;</code></pre>
<p>}</p>
<p>　　将MediaPlayerService加入到ServiceManager中，</p>
<p>这里就通过BpServiceManager的AddService将数据写入到Binder设备传递给ServiceManager。</p>
<p>继续Media<br>Process过程</p>
<p>四<br>Media Process消息循环</p>
<p>int main(int argc, char** argv)<br>{<br>    //启动进程的线程池<br>    ProcessState::self()-&gt;startThreadPool();     //走到了这里</p>
<pre><code>//执行线程消息循环
IPCThreadState::self()-&amp;gt;joinThreadPool();</code></pre>
<p>}</p>
<p>1<br>创建工作者线程</p>
<p>startThreadPool：\frameworks\native\libs\binder<br>ProcessState.cpp：</p>
<p>void ProcessState::startThreadPool()<br>{<br>    spawnPooledThread(true);<br>}</p>
<p>void ProcessState::spawnPooledThread(bool isMain)<br>{<br>    //创建PoolThread对象 并run ，非线程<br>    sp&lt;Thread&gt; t = new PoolThread(isMain);<br>　　t-&gt;run(buf);<br>}</p>
<p>　　PoolThread继承Thread</p>
<p>执行Thread的run函数：</p>
<p>status_t Thread::run(const char* name, int32_t priority, size_t stack)<br>{<br>    //创建线程mThread _threadLoop<br>    bool res;<br>    res = createThreadEtc(_threadLoop,<br>    this, name, priority, stack, &amp;mThread);</p>
<pre><code>return NO_ERROR;</code></pre>
<p>}</p>
<p>现在有两个线程：主线程和mThread线程</p>
<p>mThread线程执行：_threadLoop</p>
<p>int Thread::_threadLoop(void* user)<br>{<br>    Thread* const self = static_cast&lt;Thread*&gt;(user);<br>    do {<br>        //调用子类的threadLoop<br>        result = self-&gt;threadLoop();<br>        ……<br>    } while(strong != 0);<br>    return 0;<br>}</p>
<p>class PoolThread : public Thread<br>{<br>protected:<br>    virtual bool threadLoop()<br>    {<br>        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);<br>        return false;<br>    }<br>};</p>
<p>2<br>进程间通信消息循环过程</p>
<p>消息循环：</p>
<p>void IPCThreadState::joinThreadPool(bool isMain)<br>{<br>    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);<br>    status_t result;<br>    //消息循环<br>    do {<br>        int32_t cmd;<br>        //从binder设备中读取命令<br>        result = talkWithDriver();<br>        if (result &gt;= NO_ERROR) {<br>            cmd = mIn.readInt32();<br>            //执行命令<br>            result = executeCommand(cmd);<br>        }<br>           ……<br>    } while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</p>
<pre><code>mOut.writeInt32(BC_EXIT_LOOPER);
talkWithDriver(false);</code></pre>
<p>}</p>
<p>命令执行：</p>
<p>status_t IPCThreadState::executeCommand(int32_t cmd)<br>{<br>    BBinder* obj;<br>    RefBase::weakref_type* refs;<br>    switch (cmd) {<br>    case BR_DECREFS:<br>        break;<br>    case BR_ATTEMPT_ACQUIRE:<br>        break;<br>case BR_TRANSACTION:<br>　　binder_transaction_data tr;<br>    result = mIn.read(&amp;tr, sizeof(tr));<br>      if (tr.target.ptr) {<br>        //将目标对象转化成BBinder<br>        sp&lt;BBinder&gt; b((BBinder*)tr.cookie);<br>        //调用BBinder的transact 函数<br>       const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);<br>      }<br>        break;<br>    ……<br>    default:<br>    }<br>    return result;<br>}</p>
<p>　　binder_transaction_data.cookie：target<br>object cookie目标对象，这个target<br>object是指那个呢？</p>
<p>在Media<br>Process里面有几个Service：AudioFlinger、MediaPlayerService、CameraService等。</p>
<p>这个目标是这其中Service中的一个，假设目标对象为为MediaPlayerService，那为何要转化成BBinder呢？</p>
<p>3<br>Service对命令的处理</p>
<p>　　线程从binder接收到消息命令，将命令传递给Service处理。将目标对象转化成BBinder，然后调度此命令；</p>
<p>命令从远端传递到本地端进行处理，每个Service都对应BnXXX对象来处理远端BpXXX传来的命令。<br>　　sp&lt;BBinder&gt;<br>b((BBinder*)tr.cookie);</p>
<p>　　const status_t error = b-&gt;transact(tr.code, buffer,<br>&amp;reply, tr.flags);</p>
<p>　　这里b代表某个Service：假设为MediaPlayerService；弄清楚执行过程，要弄清楚类继承关系。</p>
<p>　　　　</p>
<p>　　本地端BnMediaPlayerService消息处理过程：真正的对象是MediaPlayerService实例。<br>从BBinder<br>-&gt;transact开始传递：</p>
<p>status_t BBinder::transact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>    //onTransact是个virtual函数 派生类BnMediaPlayerService重写<br>    err = onTransact(code, data, reply, flags);<br>    return err;<br>}</p>
<p>status_t BnMediaPlayerService::onTransact(<br>    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>    switch (code) {<br>        case CREATE: {<br>            pid_t pid = data.readInt32();<br>            sp&lt;IMediaPlayerClient&gt; client =<br>                interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder());<br>            //create是个virtual函数 派生类MediaPlayerService重写<br>            sp&lt;IMediaPlayer&gt; player = create(pid, client, audioSessionId);<br>            //创建player写入到数据包中 传回<br>            reply-&gt;writeStrongBinder(player-&gt;asBinder());<br>            return NO_ERROR;<br>        } break;<br>        ……<br>        default:<br>            return BBinder::onTransact(code, data, reply, flags);<br>    }<br>}</p>
<p>可以看看Client类继承关系结构图：</p>
<p>　　　　</p>
<p>　　看到这个跟上面的MediaPlayerService继承关系非常的相似，</p>
<p>　　这个结构也非常的熟悉——Adapter模式；将binder消息交互和命令处理适配到一起。</p>
<p>五<br>Client端与Service端交互</p>
<p>　　Client对Service进行使用Binder通信，是得到一个Service<br>BnXXX端对象的代理，在Client 为BpXXX代理，</p>
<p>然后使用此代理进行相关的操作. 前面在使用ServiceManager就是此种方式进行。</p>
<p>　　实际上通信的基础是Binder，Proxy不过是在Binder上进行了一层封装，封装了对binder驱动的底层操作，使具有面向对象的特性。</p>
<p>任意两个进程通过Binder进行通信，就是先得到另一个进程的binder标识，通过此binder进行数据交换。</p>
<p>　　　　</p>
<p>1 新增加一个服务 <br>看下面media<br>Palyer类继承结构。<br>实现Bn端类继承结构：</p>
<p>　　　　</p>
<p>实现Bp端类继承结构：</p>
<p>　　　　</p>
<p>可以看到 ：</p>
<p>　　需要定义服务公共接口IMediaPlayerService；</p>
<p>　　实现服务Bn端<br>派发消息BnMediaPlayerService；</p>
<p>　　实现服务的命令处理MediaPlayerService；</p>
<p>　　实现服务代理BpMediaPlayerService；</p>
<p>2<br>Client获取Service服务</p>
<p>　　Native<br>Service以及framework Service都是加入到ServiceManger中，</p>
<p>不管native端还是Framework端得Service<br>其实都是要满足上面远程对象代理结构。</p>
<p>native端获取service：</p>
<p>//获取ServiceManager的代理对象<br>sp&lt;IServiceManager&gt; sm = defaultServiceManager();<br>//通过ServiceManager获取media Service binder<br>binder = sm-&gt;getService(String16(&quot;media.player&quot;));<br>//将binder封装 构造media Service代理对象 BpMediaPlayerService<br>sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</p>
<p>framework层的service，借助AIDL文件，实现跨进程的通信：</p>
<p>　　所有framework端service想要作为公共的服务，被别的应用程序调用，都要实现AIDL文件，服务要继承该AIDL文件内部类Stub。</p>
<p>其实AIDL文件是对Framework中service作为进程通信的框架的封装，系统自动生成中间需要的代码和步骤，统一结构：还是binder代理，服务代理。</p>
<p>下面看看PowerManagerService实现。</p>
<p>PowerManagerService服务：</p>
<p>\frameworks\base\services\java\com\android\server\PowerManagerService.java</p>
<p>public class PowerManagerService extends IPowerManager.Stub……<br>{<br>　　public void goToSleep(long time){<br>　　　　……<br>　　}<br>}；</p>
<p>AIDL文件：\frameworks\base\core\java\android\os\IPowerManager.aidl<br>interface IPowerManager<br>{<br>　　void goToSleep(long time);<br>　　……<br>}</p>
<p>AIDL对应的Java文件：<br>　　AIDL会自动生成一个对应的Java的interface文件，看看这个接口文件。<br>　　AIDL自动生成对应java文件位置：\out\target\common\obj\JAVA_LIBRARIES\framework_intermediates\src\core\java\android\os</p>
<p>public interface IPowerManager extends android.os.IInterface {<br>    //IPowerManager 内部类 Stub<br>    public static abstract class Stub extends android.os.Binder implements<br>            android.os.IPowerManager {<br>        public static android.os.IPowerManager asInterface(<br>                android.os.IBinder obj)<br>        {<br>            //生成一个Proxy对象<br>            return new android.os.IPowerManager.Stub.Proxy(obj);<br>        }<br>        public android.os.IBinder asBinder() {<br>            return this;<br>        }<br>        @Override<br>        public boolean onTransact(int code, android.os.Parcel data,<br>                android.os.Parcel reply, int flags)<br>        {<br>            switch (code) {<br>                case TRANSACTION_goToSleep：<br>                this.goToSleep(_arg0);<br>                return true;<br>                ……<br>            }<br>        }<br>        //Stub内部类Proxy<br>        private static class Proxy implements android.os.IPowerManager {<br>            private android.os.IBinder mRemote;<br>            Proxy(android.os.IBinder remote) {<br>                mRemote = remote;<br>            }<br>            public void goToSleep(long time)<br>            {<br>                //将数据打包成Parcel<br>                android.os.Parcel _data = android.os.Parcel.obtain();<br>                android.os.Parcel _reply = android.os.Parcel.obtain();<br>                _data.writeInterfaceToken(DESCRIPTOR);<br>                _data.writeLong(time);<br>                //传输数据到binder 到相关的Service 进程<br>                // IPCThreadState::transact方法中完成<br>                mRemote.transact(Stub.TRANSACTION_goToSleep, _data, _reply,0);<br>                _reply.readException();<br>            }<br>        }<br>    }<br>    //goToSleep接口对应的ID<br>    static final int TRANSACTION_goToSleep = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);<br>    //接口<br>    public void goToSleep(long time);<br>}</p>
<p>看下其中类结构：</p>
<p>　　　　</p>
<p>AIDL自动生成对应的java文件，将结构过程进行了统一，自动生成中间代码。</p>
<p>Application获取用Service：</p>
<p>IPowerManager m mPowerManagerService;<br>//获取service的bingder<br>IBinder binder = ServiceManager.getService(&quot;power&quot;)；<br>//创建service代理对象<br>mPowerManagerService = IPowerManager.Stub.asInterface(binder);<br>//调用接口<br>mPowerManagerService.goToSleep();</p>
<p>Native Service和 Framework Service结构方式基本一致的。</p>
<p>进程间通信Linux系统已经提供了很多方式，比如Socket，为什么Android非要另辟蹊径，设计了Binder呢？</p>
<p>　　可以阅读一下：<a href="http://www.cnblogs.com/bastard/archive/2012/10/17/2728155.html">http://www.cnblogs.com/bastard/archive/2012/10/17/2728155.html</a></p>
<p>　　Game<br>Over ！</p>
<p>参考文档：</p>
<p>　　<a href="http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html">http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html</a></p>
<p>　　<a href="http://blog.csdn.net/maxleng/article/details/5490770">http://blog.csdn.net/maxleng/article/details/5490770</a></p>
<p>注：</p>
<p>　　“我们其实还一部分没有研究，就是同一个进程之间的对象传递与远程传递是区别的。同一个进程间专递服务地和对象，</p>
<p>　　就没有代理BpBinder产生，而只是对象的直接应用了。应用程序并不知道数据是在同一进程间传递还是不同进程间传递，</p>
<p>　　这个只有内核中的Binder知道，所以内核Binder驱动可以将Binder对象数据类型从BINDER_TYPE_BINDER修改为</p>
<p>　　BINDER_TYPE_HANDLE或者BINDER_TYPE_WEAK_HANDLE作为引用传递。”<br> ——来自上述地址</p>
<p>　　这个可以看到在SystemServer运行的Service之间使用时，直接转化成了对应的对象，而不是通过代理。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux Platform devices 平台设备驱动</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%20Platform%20devices%20%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p> platform平台设备驱动是基于设备总线驱动模型的，它只不过是将 device 进一步封装成为 platform_device，将 device_driver 进一步封装成为 platform_device_driver,前面已经分析过设备总线驱动模型，关于device 与 device_driver 的注册过程以及它们在sysfs文件系统中的层次关系就不在分析，本文重点分析platform平台设备驱动与设备总线驱动模型相比较新增添的那些东西。</p>
<p>    在Linux设备模型的抽象中，存在着一类称作“Platform Device”的设备，内核是这样描述它们的（Documentation/driver-model/platform.txt）：</p>
<p>    Platform devices are devices that typically appear as autonomous entities in the system. This includes legacy port-based devices and host bridges to peripheral buses, and most controllers integrated into system-on-chip platforms.  What they usually have in common is direct addressing from a CPU bus.  Rarely, a platform_device will be connected through a segment of some other kind of bus; but its registers will still be directly addressable.</p>
<p>     概括来说，Platform设备包括：基于端口的设备（已不推荐使用，保留下来只为兼容旧设备，legacy）；连接物理总线的桥设备；集成在SOC平台上面的控制器；连接在其它bus上的设备（很少见）。等等。<br>    这些设备有一个基本的特征：可以通过CPU bus直接寻址（例如在嵌入式系统常见的“寄存器”）。因此，由于这个共性，内核在设备模型的基础上（device和device_driver），对这些设备进行了更进一步的封装，抽象出paltform bus、platform device和platform driver，以便驱动开发人员可以方便的开发这类设备的驱动。<br>    可以说，paltform设备对Linux驱动工程师是非常重要的，因为我们编写的大多数设备驱动，都是为了驱动plaftom设备。</p>
<p>platform_bus_type<br>    我们知道，在设备总线驱动模型的中，BUS像一个月老一样，通过它的match函数，将注册到bus中的device与driver进行配对，那么每一个不同的bus 都有自己的match函数，我们来看看platform_bus_type.</p>
<p>[cpp] view plain copy</p>
<p>struct bus_type platform_bus_type = {  </p>
<p>    .name       = &quot;platform&quot;,  </p>
<p>    .dev_attrs  = platform_dev_attrs,  </p>
<p>    .match      = platform_match,  </p>
<p>    .uevent     = platform_uevent,  </p>
<p>    .pm     = &amp;platform_dev_pm_ops,  </p>
<p>};  </p>
<p>[cpp] view plain copy</p>
<p>static int platform_match(struct device *dev, struct device_driver *drv)  </p>
<p>{  </p>
<p>struct platform_device *pdev = to_platform_device(dev);  </p>
<p>struct platform_driver *pdrv = to_platform_driver(drv);  </p>
<p>/* match against the id table first */  </p>
<p>if (pdrv-&gt;id_table)  </p>
<p>return platform_match_id(pdrv-&gt;id_table, pdev) != NULL;  </p>
<p>/* fall-back to driver name match */  </p>
<p>return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);  </p>
<p>}  </p>
<p>    如果platform_device_driver中定义了id_table，则调用 platform_match_id 进行匹配</p>
<p>    举个例子：</p>
<p>[cpp] view plain copy</p>
<p>static struct platform_device_id s3c24xx_driver_ids[] = {  </p>
<p>    {  </p>
<p>        .name       = &quot;s3c2410-i2c&quot;,  </p>
<p>        .driver_data    = TYPE_S3C2410,  </p>
<p>    }, {  </p>
<p>        .name       = &quot;s3c2440-i2c&quot;,  </p>
<p>        .driver_data    = TYPE_S3C2440,  </p>
<p>    }, { },  </p>
<p>};  </p>
<p>[cpp] view plain copy</p>
<p>struct platform_device s3c_device_i2c0 = {  </p>
<p>    .name         = &quot;s3c2410-i2c&quot;,  </p>
<p>#ifdef CONFIG_S3C_DEV_I2C1  </p>
<p>    .id       = 0,  </p>
<p>#else  </p>
<p>    .id       = -1,  </p>
<p>#endif  </p>
<p>    .num_resources    = ARRAY_SIZE(s3c_i2c_resource),  </p>
<p>    .resource     = s3c_i2c_resource,  </p>
<p>};  </p>
<p>[cpp] view plain copy</p>
<p>static const struct platform_device_id *platform_match_id(struct platform_device_id *id, struct platform_device *pdev)  </p>
<p>{  </p>
<p>while (id-&gt;name[0]) {  </p>
<p>if (strcmp(pdev-&gt;name, id-&gt;name) == 0) {  </p>
<p>            pdev-&gt;id_entry = id;  </p>
<p>return id;  </p>
<p>        }  </p>
<p>        id++;  </p>
<p>    }  </p>
<p>return NULL;  </p>
<p>}  </p>
<p>显然，platform_match_id 的作用就是遍历整个 Id_table 数组，寻找是否有与 platform_device-&gt;name 同名的，如果有，则返回这个 Platform_device_id ,使用Id_table 打破了原本设备总线驱动模型，一个 device 只能用与一个 device_driver 配对的局限性。现在一个platform_device_driver 可以与多个platform_device配对。</p>
<p>如果没有，则只是根据 platform_device_driver-&gt;name 与 platform_device-&gt;name 进行比较，这也就是老师为啥在写平台设备驱动程序的时候经常说，“将驱动注册到内核中去，如果有同名设备，则调用driver-&gt;probe函数….”。</p>
<p>pletform_device 中的 id 的作用：</p>
<p>    if (pdev-&gt;id != -1)      /* 如果不是-1 对name编号 <em>/  <br>        dev_set_name(&amp;pdev-&gt;dev, &quot;%s.%d&quot;, pdev-&gt;name,  pdev-&gt;id);  <br>    else                             /</em> -1时直接是名字 */<br>        dev_set_name(&amp;pdev-&gt;dev, pdev-&gt;name); </p>
<p>从device封装而来的platform_device</p>
<p>[cpp] view plain copy</p>
<p>struct platform_device {  </p>
<p>const char  * name;  </p>
<p>int     id;  </p>
<p>struct device   dev;  </p>
<p>    u32     num_resources;  </p>
<p>struct resource * resource;  </p>
<p>struct platform_device_id   *id_entry;  </p>
<p>/* arch specific additions */  </p>
<p>struct pdev_archdata    archdata;  </p>
<p>};    </p>
<p>    name，设备的名称，该名称在设备注册时，会拷贝到dev.init_name中。<br>    dev，真正的设备，通过 container_of ,就能找到整个platform_device ，访问其它成员，如后面要提到的 resource <br>    num_resources、resource，该设备的资源描述，由struct resource（include/linux/ioport.h）结构抽象。 <br>    在Linux中，系统资源包括I/O、Memory、Register、IRQ、DMA、Bus等多种类型。这些资源大多具有独占性，不允许多个设备同时使用，因此Linux内核提供了一些API，用于分配、管理这些资源。 <br>当某个设备需要使用某些资源时，只需利用struct resource组织这些资源（如名称、类型、起始、结束地址等），并保存在该设备的resource指针中即可。然后在设备probe时，设备需求会调用资源管理接口，分配、使用这些资源。而内核的资源管理逻辑，可以判断这些资源是否已被使用、是否可被使用等等。</p>
<p>[cpp] view plain copy</p>
<p>struct resource {  </p>
<p>    resource_size_t start;  </p>
<p>    resource_size_t end;  </p>
<p>const char *name;  </p>
<p>    unsigned long flags;  </p>
<p>struct resource *parent, *sibling, *child;  </p>
<p>};  </p>
<p>[cpp] view plain copy</p>
<p>static struct resource led_resource[] = {   //jz2440的参数，驱动未测试   </p>
<p>    [0] = {  </p>
<p>        .start = 0x56000010,  </p>
<p>        .end   = 0x56000010 + 8 - 1,  </p>
<p>        .flags = IORESOURCE_MEM,  </p>
<p>    },  </p>
<p>    [1] = {  </p>
<p>        .start = 5,  </p>
<p>        .end   = 5,  </p>
<p>        .flags = IORESOURCE_IRQ,  </p>
<p>    },  </p>
<p>};  </p>
<p>static struct platform_device led_dev = {  </p>
<p>    .name = &quot;myled&quot;,    //设备名字 与 驱动相匹配  </p>
<p>    .id   = -1,  </p>
<p>    .num_resources = ARRAY_SIZE(led_resource),  </p>
<p>    .resource = led_resource,  </p>
<p>    .dev = {  </p>
<p>        .release = led_release,  </p>
<p>//.devt = MKDEV(252, 1),  </p>
<p>    },  </p>
<p>};  </p>
<p>从 device_driver 封装而来的platform_device_dirver</p>
<p>[cpp] view plain copy</p>
<p>struct platform_driver {  </p>
<p>int (*probe)(struct platform_device *);  </p>
<p>int (*remove)(struct platform_device *);  </p>
<p>void (*shutdown)(struct platform_device *);  </p>
<p>int (*suspend)(struct platform_device *, pm_message_t state);  </p>
<p>int (*resume)(struct platform_device *);  </p>
<p>struct device_driver driver;  </p>
<p>struct platform_device_id *id_table;  </p>
<p>};  </p>
<p>[cpp] view plain copy</p>
<p>int platform_driver_register(struct platform_driver *drv)  </p>
<p>{  </p>
<p>    drv-&gt;driver.bus = &amp;platform_bus_type;  </p>
<p>if (drv-&gt;probe)  </p>
<p>        drv-&gt;driver.probe = platform_drv_probe;  </p>
<p>if (drv-&gt;remove)  </p>
<p>        drv-&gt;driver.remove = platform_drv_remove;  </p>
<p>if (drv-&gt;shutdown)  </p>
<p>        drv-&gt;driver.shutdown = platform_drv_shutdown;  </p>
<p>return driver_register(&amp;drv-&gt;driver);  </p>
<p>}  </p>
<p>    struct platform_driver结构和struct device_driver非常类似,上边的platform_drv_probe、platform_drv_remove、platform_drv_shutdown，只不过稍作转换调用platform_driver中的probe、remove、shutdown函数，举个例子稍微看一下</p>
<p>[cpp] view plain copy</p>
<p>static int platform_drv_probe(struct device *_dev)  </p>
<p>{  </p>
<p>struct platform_driver *drv = to_platform_driver(_dev-&gt;driver);  </p>
<p>struct platform_device *dev = to_platform_device(_dev);  </p>
<p>return drv-&gt;probe(dev);  </p>
<p>}  </p>
<p>Platform Device提供的API</p>
<p>[cpp] view plain copy</p>
<p>/* include/linux/platform_device.h */  </p>
<p>extern int platform_device_register(struct platform_device *);  </p>
<p>extern void platform_device_unregister(struct platform_device *);  </p>
<p>extern void arch_setup_pdev_archdata(struct platform_device *);  </p>
<p>extern struct resource *platform_get_resource(struct platform_device *, unsigned int, unsigned int);  </p>
<p>extern int platform_get_irq(struct platform_device *, unsigned int);  </p>
<p>extern struct resource *platform_get_resource_byname(struct platform_device *, unsigned int, const char *);  </p>
<p>extern int platform_get_irq_byname(struct platform_device *, const char *);  </p>
<p>extern int platform_add_devices(struct platform_device **, int);  </p>
<p>extern struct platform_device *platform_device_register_full(const struct platform_device_info *pdevinfo);  </p>
<p>static inline struct platform_device *platform_device_register_resndata(  </p>
<p>struct device *parent, const char *name, int id,  </p>
<p>const struct resource *res, unsigned int num,  </p>
<p>const void *data, size_t size)  </p>
<p>static inline struct platform_device *platform_device_register_simple(  </p>
<p>const char *name, int id,  </p>
<p>const struct resource *res, unsigned int num)  </p>
<p>static inline struct platform_device *platform_device_register_data(  </p>
<p>struct device *parent, const char *name, int id,  </p>
<p>const void *data, size_t size)  </p>
<p>extern struct platform_device *platform_device_alloc(const char *name, int id);  </p>
<p>extern int platform_device_add_resources(struct platform_device *pdev,  </p>
<p>const struct resource *res,  </p>
<p>                                         unsigned int num);  </p>
<p>extern int platform_device_add_data(struct platform_device *pdev,  </p>
<p>const void *data, size_t size);  </p>
<p>extern int platform_device_add(struct platform_device *pdev);  </p>
<p>extern void platform_device_del(struct platform_device *pdev);  </p>
<p>extern void platform_device_put(struct platform_device *pdev);  </p>
<p>    platform_device_register、platform_device_unregister，Platform设备的注册/注销接口，和底层的device_register等接口类似。<br>    arch_setup_pdev_archdata，设置platform_device变量中的archdata指针。<br>    platform_get_resource、platform_get_irq、platform_get_resource_byname、platform_get_irq_byname，通过这些接口，可以获取platform_device变量中的resource信息，以及直接获取IRQ的number等等。<br>    platform_device_register_full、platform_device_register_resndata、platform_device_register_simple、platform_device_register_data，其它形式的设备注册。调用者只需要提供一些必要的信息，如name、ID、resource等，Platform模块就会自动分配一个struct platform_device变量，填充内容后，注册到内核中。<br>    platform_device_alloc，以name和id为参数，动态分配一个struct platform_device变量。<br>    platform_device_add_resources，向platform device中增加资源描述。<br>    platform_device_add_data，向platform device中添加自定义的数据（保存在pdev-&gt;dev.platform_data指针中）。<br>    platform_device_add、platform_device_del、platform_device_put，其它操作接口。<br>Platform Driver提供的API<br>    platform_driver_registe、platform_driver_unregister，platform driver的注册、注销接口。<br>    platform_driver_probe，主动执行probe动作。<br>    platform_set_drvdata、platform_get_drvdata，设置或者获取driver保存在device变量中的私有数据。<br>懒人API</p>
<p>[cpp] view plain copy</p>
<p>extern struct platform_device *platform_create_bundle(  </p>
<p>struct platform_driver *driver, int (*probe)(struct platform_device *),  </p>
<p>struct resource *res, unsigned int n_res,  </p>
<p>const void *data, size_t size);  </p>
<p>    只要提供一个platform_driver（要把driver的probe接口显式的传入），并告知该设备占用的资源信息，platform模块就会帮忙分配资源，并执行probe操作。对于那些不需要热拔插的设备来说，这种方式是最省事的了。  </p>
<p>简单一例：</p>
<p>    开发板：Mini2440</p>
<p>    内核版本：2.6.32.2</p>
<p>[cpp] view plain copy</p>
<p>#include &lt;linux/module.h&gt;  </p>
<p>#include &lt;linux/kernel.h&gt;  </p>
<p>#include &lt;linux/fs.h&gt;  </p>
<p>#include &lt;linux/init.h&gt;  </p>
<p>#include &lt;linux/device.h&gt;  </p>
<p>#include &lt;linux/interrupt.h&gt;  </p>
<p>#include &lt;linux/sched.h&gt;   </p>
<p>#include &lt;linux/irq.h&gt;  </p>
<p>#include &lt;asm/uaccess.h&gt;  </p>
<p>#include &lt;linux/input.h&gt;  </p>
<p>#include &lt;linux/platform_device.h&gt;  </p>
<p>// 设备资源  </p>
<p>static struct resource led_resource[] = {   //jz2440的参数，驱动未测试   </p>
<p>    [0] = {  </p>
<p>        .start = 0x56000010,  </p>
<p>        .end   = 0x56000010 + 8 - 1,  </p>
<p>        .flags = IORESOURCE_MEM,  </p>
<p>    },  </p>
<p>    [1] = {  </p>
<p>        .start = 5,  </p>
<p>        .end   = 5,  </p>
<p>        .flags = IORESOURCE_IRQ,  </p>
<p>    },  </p>
<p>};  </p>
<p>static void led_release(struct device *dev){  </p>
<p>}  </p>
<p>// 创建一个设备  </p>
<p>static struct platform_device led_dev = {  </p>
<p>    .name = &quot;myled&quot;,    //设备名字 与 驱动相匹配  </p>
<p>    .id   = -1,  </p>
<p>    .num_resources = ARRAY_SIZE(led_resource),  </p>
<p>    .resource = led_resource,  </p>
<p>    .dev = {  </p>
<p>        .release = led_release,  </p>
<p>//.devt = MKDEV(252, 1),  </p>
<p>    },  </p>
<p>};  </p>
<p>static int led_dev_init(void){  </p>
<p>//向bus注册led_dev match drv链表进行配对  </p>
<p>    platform_device_register(&amp;led_dev);  </p>
<p>return 0;  </p>
<p>}  </p>
<p>static void led_dev_exit(void){  </p>
<p>    platform_device_unregister(&amp;led_dev);  </p>
<p>}  </p>
<p>module_init(led_dev_init);  </p>
<p>module_exit(led_dev_exit);  </p>
<p>MODULE_LICENSE(&quot;GPL&quot;);  </p>
<p>[cpp] view plain copy</p>
<p>#include &lt;linux/module.h&gt;  </p>
<p>#include &lt;linux/kernel.h&gt;  </p>
<p>#include &lt;linux/fs.h&gt;  </p>
<p>#include &lt;linux/init.h&gt;  </p>
<p>#include &lt;linux/device.h&gt;  </p>
<p>#include &lt;linux/interrupt.h&gt;  </p>
<p>#include &lt;linux/sched.h&gt;   </p>
<p>#include &lt;linux/irq.h&gt;  </p>
<p>#include &lt;asm/uaccess.h&gt;  </p>
<p>#include &lt;linux/platform_device.h&gt;  </p>
<p>#include &lt;linux/io.h&gt;  </p>
<p>static int major;  </p>
<p>static struct class *cls;  </p>
<p>static struct device *dev;  </p>
<p>static volatile unsigned long *gpio_con;  </p>
<p>static volatile unsigned long *gpio_dat;  </p>
<p>static int pin;  </p>
<p>static int led_open(struct inode *inode, struct file *file){  </p>
<p>    <em>gpio_con &amp;= ~(0x03 &lt;&lt; (pin</em>2));  </p>
<p>    <em>gpio_con |=  (0x01 &lt;&lt; (pin</em>2));  </p>
<p>return 0;  </p>
<p>}  </p>
<p>static ssize_t led_write(struct file *file, const char __user *buf,  </p>
<p>size_t count, loff_t *ppos){  </p>
<p>int val;  </p>
<p>    copy_from_user(&amp;val, buf, count);  </p>
<p>if(val == 1){  </p>
<p>        *gpio_dat &amp;= ~(1&lt;&lt;pin);  </p>
<p>    }else{  </p>
<p>        *gpio_dat &amp;=  (1&lt;&lt;pin);  </p>
<p>    }  </p>
<p>return 0;  </p>
<p>}  </p>
<p>static struct file_operations led_fops = {  </p>
<p>    .owner = THIS_MODULE,  </p>
<p>    .open  = led_open,  </p>
<p>    .write = led_write,  </p>
<p>};  </p>
<p>static int led_probe(struct platform_device *pdev){  </p>
<p>struct resource *res;  </p>
<p>// 最后一个参数 0 表示第1个该类型的资源  </p>
<p>    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);  </p>
<p>    gpio_con = ioremap(res-&gt;start, res-&gt;end - res-&gt;start + 1);  </p>
<p>    gpio_dat = gpio_con + 1;  </p>
<p>    res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);  </p>
<p>    pin = res-&gt;start;  </p>
<p>    printk(&quot;led_probe, found led\n&quot;);  </p>
<p>// 注册设备驱动 创建设备节点  </p>
<p>    major = register_chrdev(0, &quot;myled&quot;, &amp;led_fops);  </p>
<p>// 创建类  </p>
<p>    cls = class_create(THIS_MODULE, &quot;myled&quot;);  </p>
<p>// 创建设备节点  </p>
<p>    dev = device_create(cls, NULL, MKDEV(major, 0), NULL, &quot;led&quot;);  </p>
<p>return 0;  </p>
<p>}  </p>
<p>static int led_remove(struct platform_device *pdev){  </p>
<p>    printk(&quot;led_remove, remove led\n&quot;);   </p>
<p>// 删除设备节点  </p>
<p>    device_unregister(dev);  </p>
<p>// 销毁类  </p>
<p>    class_destroy(cls);  </p>
<p>// 取消注册设备驱动  </p>
<p>    unregister_chrdev(major, &quot;myled&quot;);  </p>
<p>// 取消内存映射  </p>
<p>    iounmap(gpio_con);  </p>
<p>return 0;  </p>
<p>}  </p>
<p>struct platform_driver led_drv = {  </p>
<p>    .probe  = led_probe,    //匹配到dev之后调用probe  </p>
<p>    .remove = led_remove,  </p>
<p>    .driver = {  </p>
<p>        .name = &quot;myled&quot;,  </p>
<p>    },  </p>
<p>};  </p>
<p>static int led_drv_init(void){  </p>
<p>    platform_driver_register(&amp;led_drv);  </p>
<p>return 0;  </p>
<p>}  </p>
<p>static void led_drv_exit(void){  </p>
<p>    platform_driver_unregister(&amp;led_drv);  </p>
<p>}  </p>
<p>module_init(led_drv_init);  </p>
<p>module_exit(led_drv_exit);  </p>
<p>MODULE_LICENSE(&quot;GPL&quot;);  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux设备驱动之字符设备驱动</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B9%8B%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>一、linux系统将设备分为3类：字符设备、块设备、网络设备。使用驱动程序：</p>
<p>字符设备：是指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后数据。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和LED设备等。</p>
<p>块设备：是指可以从设备的任意位置读取一定长度数据的设备。块设备包括硬盘、磁盘、U盘和SD卡等。</p>
<p>每一个字符设备或块设备都在/dev目录下对应一个设备文件。linux用户程序通过设备文件（或称设备节点）来使用驱动程序操作字符设备和块设备。</p>
<p>二、字符设备、字符设备驱动与用户空间访问该设备的程序三者之间的关系。</p>
<p>如图，在Linux内核中使用cdev结构体来描述字符设备，通过其成员dev_t来定义设备号（分为主、次设备号）以确定字符设备的唯一性。通过其成员file_operations来定义字符设备驱动提供给VFS的接口函数，如常见的open()、read()、write()等。</p>
<p>在Linux字符设备驱动中，模块加载函数通过register_chrdev_region( ) 或alloc_chrdev_region( )来静态或者动态获取设备号，通过cdev_init( )建立cdev与file_operations之间的连接，通过cdev_add( )向系统添加一个cdev以完成注册。模块卸载函数通过cdev_del( )来注销cdev，通过unregister_chrdev_region( )来释放设备号。</p>
<p>用户空间访问该设备的程序通过Linux系统调用，如open( )、read( )、write( )，来“调用”file_operations来定义字符设备驱动提供给VFS的接口函数。</p>
<p>三、字符设备驱动模型</p>
<ol>
<li>驱动初始化</li>
</ol>
<p>1.1. 分配cdev</p>
<p>在2.6的内核中使用cdev结构体来描述字符设备，在驱动中分配cdev,主要是分配一个cdev结构体与申请设备号，以按键驱动为例：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>1 /<em>……</em>/</p>
<p>2 /* 分配cdev*/</p>
<p>3 struct cdev btn_cdev;</p>
<p>4 /<em>……</em>/</p>
<p>5 /* 1.1 申请设备号*/</p>
<p>6 if(major){</p>
<p>7 //静态</p>
<p>8 dev_id = MKDEV(major, 0);</p>
<p>9 register_chrdev_region(dev_id, 1, &quot;button&quot;);</p>
<p>10 } else {</p>
<p>11 //动态</p>
<p>12 alloc_chardev_region(&amp;dev_id, 0, 1, &quot;button&quot;);</p>
<p>13 major = MAJOR(dev_id);</p>
<p>14 }</p>
<p>15 /<em>……</em>/</p>
<p>从上面的代码可以看出，申请设备号有动静之分，其实设备号还有主次之分。</p>
<p>在Linux中以主设备号用来标识与设备文件相连的驱动程序。次编号被驱动程序用来辨别操作的是哪个设备。cdev 结构体的 dev_t 成员定义了设备号，为 32 位，其中高 12 位为主设备号，低20 位为次设备号。</p>
<p>设备号的获得与生成：</p>
<p>获得：主设备号：MAJOR(dev_t dev);</p>
<p>次设备号：MINOR(dev_t dev);</p>
<p>生成：MKDEV(int major,int minor);</p>
<p>设备号申请的动静之分：</p>
<p>静态：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>1 int register_chrdev_region(dev_t from, unsigned count, const char *name)；</p>
<p>2 /<em>功能：申请使用从from开始的count 个设备号(主设备号不变，次设备号增加）</em>/</p>
<p>静态申请相对较简单，但是一旦驱动被广泛使用,这个随机选定的主设备号可能会导致设备号冲突，而使驱动程序无法注册。</p>
<p>动态：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>1 int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)；</p>
<p>2 /<em>功能：请求内核动态分配count个设备号，且次设备号从baseminor开始。</em>/</p>
<p>动态申请简单，易于驱动推广，但是无法在安装驱动前创建设备文件（因为安装前还没有分配到主设备号）。</p>
<p>1.2. 初始化cdev</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>1 void cdev_init(struct cdev *, struct file_operations *); </p>
<p>2 cdev_init()函数用于初始化 cdev 的成员，并建立 cdev 和 file_operations 之间的连接。</p>
<p>1.3. 注册cdev</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>1 int cdev_add(struct cdev *, dev_t, unsigned);</p>
<p>2 　　　　 cdev_add()函数向系统添加一个 cdev，完成字符设备的注册。</p>
<p>1.4. 硬件初始化</p>
<p>硬件初始化主要是硬件资源的申请与配置，以TQ210的按键驱动为例：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>1 /* 1.4 硬件初始化*/</p>
<p>2 //申请GPIO资源</p>
<p>3 gpio_request(S5PV210_GPH0(0), &quot;GPH0_0&quot;);</p>
<p>4 //配置输入</p>
<p>5 gpio_direction_input(S5PV210_GPH0(0));</p>
<p>2.实现设备操作</p>
<p>用户空间的程序以访问文件的形式访问字符设备，通常进行open、read、write、close等系统调用。而这些系统调用的最终落实则是file_operations结构体中成员函数，它们是字符设备驱动与内核的接口。以TQ210的按键驱动为例：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>1 /<em>设备操作集合</em>/</p>
<p>2 static struct file_operations btn_fops = {</p>
<p>3 .owner = THIS_MODULE,</p>
<p>4 .open = button_open,</p>
<p>5 .release = button_close,</p>
<p>6 .read = button_read</p>
<p>7 };</p>
<p>上面代码中的button_open、button_close、button_read是要在驱动中自己实现的。file_operations结构体成员函数有很多个，下面就选几个常见的来展示：</p>
<p>2.1. open（）函数</p>
<p>原型：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>1 int(*open)(struct inode <em>, struct file</em>); </p>
<p>2 /<em>打开</em>/</p>
<p>2.2. read( )函数</p>
<p>原型：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>ssize_t(<em>read)(struct file <em>, char __user</em>, size_t, loff_t</em>); </p>
<p>/<em>用来从设备中读取数据，成功时函数返回读取的字节数，出错时返回一个负值</em>/</p>
<p>2.3. write( )函数</p>
<p>原型：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>1 ssize_t(<em>write)(struct file *, const char__user *, size_t, loff_t</em>);</p>
<p>2 /*向设备发送数据，成功时该函数返回写入的字节数。如果此函数未被实现，</p>
<p>3 当用户进行write()系统调用时，将得到-EINVAL返回值*/</p>
<p>2.4. close( )函数</p>
<p>原型：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>1 int(*release)(struct inode <em>, struct file</em>); </p>
<p>2 /<em>关闭</em>/</p>
<p>2.5. 补充说明</p>
<ol>
<li>在Linux字符设备驱动程序设计中，有3种非常重要的数据结构：struct file、struct inode、struct file_operations。</li>
</ol>
<p>struct file 代表一个打开的文件。系统中每个打开的文件在内核空间都有一个关联的struct file。它由内核在打开文件时创建, 在文件关闭后释放。其成员loff_t f_pos 表示文件读写位置。</p>
<p>struct inode 用来记录文件的物理上的信息。因此,它和代表打开文件的file结构是不同的。一个文件可以对应多个file结构,但只有一个inode结构。其成员dev_t i_rdev表示设备号。</p>
<p>struct file_operations 一个函数指针的集合，定义能在设备上进行的操作。结构中的成员指向驱动中的函数,这些函数实现一个特别的操作, 对于不支持的操作保留为NULL。</p>
<ol start="2">
<li>在read( )和write( )中的buff 参数是用户空间指针。因此,它不能被内核代码直接引用，因为用户空间指针在内核空间时可能根本是无效的——没有那个地址的映射。因此，内核提供了专门的函数用于访问用户空间的指针：</li>
</ol>
<p>C</p>
<p>1</p>
<p>2</p>
<p>1 unsigned long copy_from_user(void *to, const void __user *from, unsigned long count);</p>
<p>2 unsigned long copy_to_user(void __user *to, const void *from, unsigned long count);</p>
<ol start="3">
<li>驱动注销</li>
</ol>
<p>3.1. 删除cdev</p>
<p>在字符设备驱动模块卸载函数中通过cdev_del()函数向系统删除一个cdev，完成字符设备的注销。</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>/<em>原型：</em>/</p>
<p>void cdev_del(struct cdev *);</p>
<p>/<em>例：</em>/</p>
<p>cdev_del(&amp;btn_cdev);</p>
<p>3.2. 释放设备号</p>
<p>在调用cdev_del()函数从系统注销字符设备之后，unregister_chrdev_region()应该被调用以释放原先申请的设备号。</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>/<em>原型：</em>/</p>
<p>void unregister_chrdev_region(dev_t from, unsigned count);</p>
<p>/<em>例：</em>/</p>
<p>unregister_chrdev_region(MKDEV(major, 0), 1);</p>
<p>四、字符设备驱动程序基础:</p>
<p>4.1 cdev结构体</p>
<p>在Linux2.6 内核中，使用cdev结构体来描述一个字符设备，cdev结构体的定义如下：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>1 struct cdev {</p>
<p>2 </p>
<p>3 struct kobject kobj;</p>
<p>4 </p>
<p>5 struct module *owner; /<em>通常为THIS_MODULE</em>/</p>
<p>6 </p>
<p>7 struct file_operations *ops; /<em>在cdev_init()这个函数里面与cdev结构联系起来</em>/</p>
<p>8 </p>
<p>9 struct list_head list;</p>
<p>10 </p>
<p>11 dev_t dev; /<em>设备号</em>/</p>
<p>12 </p>
<p>13 unsigned int count;</p>
<p>14 </p>
<p>15 }；</p>
<p>cdev 结构体的dev_t 成员定义了设备号，为32位，其中12位是主设备号，20位是次设备号，我们只需使用二个简单的宏就可以从dev_t 中获取主设备号和次设备号：</p>
<p>MAJOR(dev_t dev)</p>
<p>MINOR(dev_t dev)</p>
<p>相反地，可以通过主次设备号来生成dev_t：</p>
<p>MKDEV(int major,int minor)</p>
<p>4.2 Linux 2.6内核提供一组函数用于操作cdev 结构体</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>1：void cdev_init(struct cdev*,struct file_operations *);</p>
<p>2：struct cdev *cdev_alloc(void);</p>
<p>3：int cdev_add(struct cdev *,dev_t,unsigned);</p>
<p>4：void cdev_del(struct cdev *);</p>
<p>其中（1）用于初始化cdev结构体，并建立cdev与file_operations 之间的连接。（2）用于动态分配一个cdev结构，（3）向内核注册一个cdev结构，（4）向内核注销一个cdev结构</p>
<p>4.3 Linux 2.6内核分配和释放设备号</p>
<p>在调用cdev_add()函数向系统注册字符设备之前，首先应向系统申请设备号，有二种方法申请设备号，一种是静态申请设备号：</p>
<p>5：int register_chrdev_region(dev_t from,unsigned count,const char *name)</p>
<p>另一种是动态申请设备号：</p>
<p>6：int alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count,const char *name);</p>
<p>其中，静态申请是已知起始设备号的情况，如先使用cat /proc/devices 命令查得哪个设备号未事先使用（不推荐使用静态申请）；动态申请是由系统自动分配，只需设置major = 0即可。</p>
<p>相反地，在调用cdev_del()函数从系统中注销字符设备之后，应该向系统申请释放原先申请的设备号，使用：</p>
<p>7：void unregister_chrdev_region(dev_t from,unsigned count);</p>
<p>4.4 cdev结构的file_operations结构体</p>
<p>这个结构体是字符设备当中最重要的结构体之一，file_operations 结构体中的成员函数指针是字符设备驱动程序设计的主体内容，这些函数实际上在应用程序进行Linux 的 open()、read()、write()、close()、seek()、ioctl()等系统调用时最终被调用。</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>1 struct file_operations {</p>
<p>2 </p>
<p>3 /<em>拥有该结构的模块计数，一般为THIS_MODULE</em>/</p>
<p>4 struct module *owner;</p>
<p>5 </p>
<p>6 /<em>用于修改文件当前的读写位置</em>/</p>
<p>7 loff_t (*llseek) (struct file *, loff_t, int);</p>
<p>8 </p>
<p>9 /<em>从设备中同步读取数据</em>/</p>
<p>10 ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</p>
<p>11 </p>
<p>12 /<em>向设备中写数据</em>/</p>
<p>13 ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</p>
<p>14 </p>
<p>15 </p>
<p>16 ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</p>
<p>17 ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</p>
<p>18 int (*readdir) (struct file *, void *, filldir_t);</p>
<p>19 </p>
<p>20 /<em>轮询函数，判断目前是否可以进行非阻塞的读取或写入</em>/</p>
<p>21 unsigned int (*poll) (struct file *, struct poll_table_struct *);</p>
<p>22 </p>
<p>23 /<em>执行设备的I/O命令</em>/</p>
<p>24 int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);</p>
<p>25 </p>
<p>26 </p>
<p>27 long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</p>
<p>28 long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</p>
<p>29 </p>
<p>30 /<em>用于请求将设备内存映射到进程地址空间</em>/</p>
<p>31 int (*mmap) (struct file *, struct vm_area_struct *);</p>
<p>32 </p>
<p>33 /<em>打开设备文件</em>/</p>
<p>34 int (*open) (struct inode *, struct file *);</p>
<p>35 int (*flush) (struct file *, fl_owner_t id);</p>
<p>36 </p>
<p>37 /<em>关闭设备文件</em>/</p>
<p>38 int (*release) (struct inode *, struct file *);</p>
<p>39 </p>
<p>40 </p>
<p>41 int (*fsync) (struct file *, struct dentry *, int datasync);</p>
<p>42 int (*aio_fsync) (struct kiocb *, int datasync);</p>
<p>43 int (*fasync) (int, struct file *, int);</p>
<p>44 int (*lock) (struct file *, int, struct file_lock *);</p>
<p>45 ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);</p>
<p>46 unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);</p>
<p>47 int (*check_flags)(int);</p>
<p>48 int (*flock) (struct file *, int, struct file_lock *);</p>
<p>49 ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);</p>
<p>50 ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);</p>
<p>51 int (<em>setlease)(struct file *, long, struct file_lock *</em>);</p>
<p>52 };</p>
<p>4.5 file结构</p>
<p>file 结构代表一个打开的文件，它的特点是一个文件可以对应多个file结构。它由内核再open时创建，并传递给在该文件上操作的所有函数，直到最后close函数，在文件的所有实例都被关闭之后，内核才释放这个数据结构。</p>
<p>在内核源代码中，指向 struct file 的指针通常比称为filp，file结构有以下几个重要的成员：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>1 struct file{</p>
<p>2 </p>
<p>3 mode_t fmode; /<em>文件模式，如FMODE_READ，FMODE_WRITE</em>/</p>
<p>4 </p>
<p>5 ……</p>
<p>6 </p>
<p>7 loff_t f_pos; /<em>loff_t 是一个64位的数，需要时，须强制转换为32位</em>/</p>
<p>8 </p>
<p>9 unsigned int f_flags; /<em>文件标志，如：O_NONBLOCK</em>/</p>
<p>10 </p>
<p>11 struct file_operations *f_op;</p>
<p>12 </p>
<p>13 void *private_data; /<em>非常重要，用于存放转换后的设备描述结构指针</em>/</p>
<p>14 </p>
<p>15 …….</p>
<p>16 </p>
<p>17 };</p>
<p>4.6 inode 结构</p>
<p>内核用inode 结构在内部表示文件，它是实实在在的表示物理硬件上的某一个文件，且一个文件仅有一个inode与之对应，同样它有二个比较重要的成员：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>1 struct inode{</p>
<p>2 </p>
<p>3 dev_t i_rdev; /<em>设备编号</em>/</p>
<p>4 </p>
<p>5 struct cdev *i_cdev; /<em>cdev 是表示字符设备的内核的内部结构</em>/</p>
<p>6 </p>
<p>7 };</p>
<p>8 </p>
<p>9 可以从inode中获取主次设备号，使用下面二个宏：</p>
<p>10 </p>
<p>11 /<em>驱动工程师一般不关心这二个宏</em>/</p>
<p>12 </p>
<p>13 unsigned int imajor(struct inode *inode);</p>
<p>14 </p>
<p>15 unsigned int iminor(struct inode *inode);</p>
<p>4.7字符设备驱动模块加载与卸载函数</p>
<p>在字符设备驱动模块加载函数中应该实现设备号的申请和cdev 结构的注册，而在卸载函数中应该实现设备号的释放与cdev结构的注销。</p>
<p>我们一般习惯将cdev内嵌到另外一个设备相关的结构体里面，该设备包含所涉及的cdev、私有数据及信号量等等信息。常见的设备结构体、模块加载函数、模块卸载函数形式如下：</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>1/<em>设备结构体</em>/</p>
<p>2 </p>
<p>3 struct xxx_dev{</p>
<p>4 </p>
<p>5 struct cdev cdev;</p>
<p>6 </p>
<p>7 char *data;</p>
<p>8 </p>
<p>9 struct semaphore sem;</p>
<p>10 </p>
<p>11 ……</p>
<p>12 </p>
<p>13 };</p>
<p>14 </p>
<p>15 </p>
<p>16 </p>
<p>17 /<em>模块加载函数</em>/</p>
<p>18 </p>
<p>19 static int __init xxx_init(void)</p>
<p>20 </p>
<p>21 {</p>
<p>22 </p>
<p>23 …….</p>
<p>24 </p>
<p>25 初始化cdev结构;</p>
<p>26 </p>
<p>27 申请设备号；</p>
<p>28 </p>
<p>29 注册设备号；</p>
<p>30 </p>
<p>31 </p>
<p>32 </p>
<p>33 申请分配设备结构体的内存； /<em>非必须</em>/</p>
<p>34 </p>
<p>35 }</p>
<p>36 </p>
<p>37 </p>
<p>38 </p>
<p>39 /<em>模块卸载函数</em>/</p>
<p>40 </p>
<p>41 static void __exit xxx_exit(void)</p>
<p>42 </p>
<p>43 {</p>
<p>44 </p>
<p>45 …….</p>
<p>46 </p>
<p>47 释放原先申请的设备号；</p>
<p>48 </p>
<p>49 释放原先申请的内存；</p>
<p>50 </p>
<p>51 注销cdev设备；</p>
<p>52 </p>
<p>53 }</p>
<p>54 </p>
<p>55</p>
<p>4.8字符设备驱动的 file_operations 结构体重成员函数</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>59</p>
<p>60</p>
<p>61</p>
<p>62</p>
<p>63</p>
<p>64</p>
<p>65</p>
<p>66</p>
<p>67</p>
<p>68</p>
<p>69</p>
<p>70</p>
<p>71</p>
<p>1 /<em>读设备</em>/</p>
<p>2 </p>
<p>3 ssize_t xxx_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)</p>
<p>4 </p>
<p>5 {</p>
<p>6 </p>
<p>7 ……</p>
<p>8 </p>
<p>9 使用filp-&gt;private_data获取设备结构体指针；</p>
<p>10 </p>
<p>11 分析和获取有效的长度；</p>
<p>12 </p>
<p>13 /<em>内核空间到用户空间的数据传递</em>/</p>
<p>14 </p>
<p>15 copy_to_user(void __user *to, const void *from, unsigned long count);</p>
<p>16 </p>
<p>17 ……</p>
<p>18 </p>
<p>19 }</p>
<p>20 </p>
<p>21 /<em>写设备</em>/</p>
<p>22 </p>
<p>23 ssize_t xxx_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)</p>
<p>24 </p>
<p>25 {</p>
<p>26 </p>
<p>27 ……</p>
<p>28 </p>
<p>29 使用filp-&gt;private_data获取设备结构体指针；</p>
<p>30 </p>
<p>31 分析和获取有效的长度；</p>
<p>32 </p>
<p>33 /<em>用户空间到内核空间的数据传递</em>/</p>
<p>34 </p>
<p>35 copy_from_user(void *to, const void __user *from, unsigned long count);</p>
<p>36 </p>
<p>37 ……</p>
<p>38 </p>
<p>39 }</p>
<p>40 </p>
<p>41 /<em>ioctl函数</em>/</p>
<p>42 </p>
<p>43 static int xxx_ioctl(struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg)</p>
<p>44 </p>
<p>45 {</p>
<p>46 </p>
<p>47 ……</p>
<p>48 </p>
<p>49 switch(cmd){</p>
<p>50 </p>
<p>51 case xxx_CMD1:</p>
<p>52 </p>
<p>53 ……</p>
<p>54 </p>
<p>55 break;</p>
<p>56 </p>
<p>57 case xxx_CMD2:</p>
<p>58 </p>
<p>59 …….</p>
<p>60 </p>
<p>61 break;</p>
<p>62 </p>
<p>63 default:</p>
<p>64 </p>
<p>65 return -ENOTTY; /<em>不能支持的命令</em>/</p>
<p>66 </p>
<p>67 }</p>
<p>68 </p>
<p>69 return 0;</p>
<p>70 </p>
<p>71 }</p>
<p>4.9、字符设备驱动文件操作结构体模板</p>
<p>C</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>1 struct file_operations xxx_fops = {</p>
<p>2 </p>
<p>3 .owner = THIS_MODULE,</p>
<p>4 </p>
<p>5 .open = xxx_open,</p>
<p>6 </p>
<p>7 .read = xxx_read,</p>
<p>8 </p>
<p>9 .write = xxx_write,</p>
<p>10 </p>
<p>11 .close = xxx_release,</p>
<p>12 </p>
<p>13 .ioctl = xxx_ioctl,</p>
<p>14 </p>
<p>15 .lseek = xxx_llseek,</p>
<p>16 </p>
<p>17 };</p>
<p>18 </p>
<p>19 上面的写法需要注意二点，一：结构体成员之间是以逗号分开的而不是分号，结构体字段结束时最后应加上分号。</p>
<p>五、字符设备驱动小结：</p>
<p>字符设备是3大类设备（字符设备、块设备、网络设备）中较简单的一类设备，其驱动程序中完成的主要工作是初始化、添加和删除cdev结构体，申请和释放设备号，以及填充file_operation结构体中操作函数，并实现file_operations结构体中的read()、write()、ioctl()等重要函数。如图所示为cdev结构体、file_operations和用户空间调用驱动的关系。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Rxjava samples</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Rxjava%20samples/</url>
    <content><![CDATA[<p>RxJava 是一个 基于事件流、实现异步操作的库</p>
<p>//        // 1. 每1s发送1个数据 = 从0开始，递增1，即0、1、2、3<br>//        Observable.interval(1, TimeUnit.SECONDS)<br>//                // 2. 通过takeUntil的Predicate传入判断条件<br>//                .takeUntil(new Predicate&lt;Long&gt;(){<br>//                    @Override<br>//                    public boolean test( Long integer) throws Exception {<br>//                        return (integer&gt;3);<br>//                        // 返回true时，就停止发送事件<br>//                        // 当发送的数据满足&gt;3时，就停止发送Observable的数据<br>//                    }<br>//                }).subscribe(new Observer&lt;Long&gt;() {<br>//            @Override<br>//            public void onSubscribe(Disposable d) {<br>//            }<br>//<br>//            @Override<br>//            public void onNext(Long value) {<br>//                Log.d(TAG,&quot;发送了事件 &quot;+ value);<br>//            }<br>//<br>//            @Override<br>//            public void onError(Throwable e) {<br>//            }<br>//<br>//            @Override<br>//            public void onComplete() {<br>//            }<br>//        });<br>//        // 采用RxJava基于事件流的链式操作<br>//        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {<br>//            @Override<br>//            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {<br>//                emitter.onNext(1);<br>//                emitter.onNext(2);<br>//                emitter.onNext(3);<br>//            }<br>//<br>//            // 采用flatMap（）变换操作符<br>//        }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {<br>//            @Override<br>//            public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception {<br>//                final List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>//                for (int i = 0; i &lt; 3; i++) {<br>//                    list.add(&quot;我是事件 &quot; + integer + &quot;拆分后的子事件&quot; + i);<br>//                    // 通过flatMap中将被观察者生产的事件序列先进行拆分，再将每个事件转换为一个新的发送三个String事件<br>//                    // 最终合并，再发送给被观察者<br>//                }<br>//                return Observable.fromIterable(list).delay(10, TimeUnit.MILLISECONDS);<br>//            }<br>//        }).subscribe(new Consumer&lt;String&gt;() {<br>//            @Override<br>//            public void accept(String s) throws Exception {<br>//                Log.d(TAG, s);<br>//            }<br>//        });<br>//        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {<br>//            @Override<br>//            public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {<br>//                e.onNext(1);<br>//                e.onNext(2);<br>//                e.onError(new Exception(&quot;发生错误了&quot;));<br>//                e.onNext(3);<br>//            }<br>//        })<br>//                .retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() {<br>//                    @Override<br>//                    public ObservableSource&lt;?&gt; apply(@NonNull Observable&lt;Throwable&gt; throwableObservable) throws Exception {<br>//<br>//                        // 返回新的被观察者 Observable<br>//                        // 此处有两种情况：<br>//                            // 1. 原始的Observable不重新发送事件：新的被观察者 Observable发送的事件 = Error事件<br>//                            // 2. 原始的Observable重新发送事件：新的被观察者 Observable发送的事件 = 数据事件<br>//                        return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() {<br>//                            @Override<br>//                            public ObservableSource&lt;?&gt; apply(@NonNull Throwable throwable) throws Exception {<br>//<br>//                                // 1. 若返回的Observable发送的事件 = Error事件，则原始的Observable不重新发送事件<br>//                                // 该异常错误信息可在观察者中的onError（）中获得<br>//                                 // return Observable.error(new Throwable(&quot;retryWhen终止啦&quot;));<br>//<br>//                                // 2. 若返回的Observable发送的事件 = 数据事件，则原始的Observable重新发送事件（若持续遇到错误，则持续重试）<br>//                                  return Observable.just(1);<br>//                            }<br>//                        });<br>//<br>//                    }<br>//                })<br>//                .subscribe(new Observer&lt;Integer&gt;() {<br>//                    @Override<br>//                    public void onSubscribe(Disposable d) {<br>//<br>//                    }<br>//                    @Override<br>//                    public void onNext(Integer value) {<br>//                        Log.d(TAG, &quot;接收到了事件&quot;+ value  );<br>//                    }<br>//<br>//                    @Override<br>//                    public void onError(Throwable e) {<br>//                        Log.d(TAG, &quot;对Error事件作出响应&quot; + e.toString());<br>//                        // 获取异常错误信息<br>//                    }<br>//<br>//                    @Override<br>//                    public void onComplete() {<br>//                        Log.d(TAG, &quot;对Complete事件作出响应&quot;);<br>//                    }<br>//                });<br>//            Observable.combineLatest(<br>//                    Observable.intervalRange(0, 3, 0, 2, TimeUnit.SECONDS), // 第1个发送数据事件的Observable<br>//                    Observable.intervalRange(0, 3, 0, 1, TimeUnit.SECONDS), // 第2个发送数据事件的Observable：从0开始发送、共发送3个数据、第1次事件延迟发送时间 = 1s、间隔时间 = 1s<br>//                    new BiFunction&lt;Long, Long, Long&gt;() {<br>//                @Override<br>//                public Long apply(Long o1, Long o2) throws Exception {<br>//                    // o1 = 第1个Observable发送的最新（最后）1个数据<br>//                    // o2 = 第2个Observable发送的每1个数据<br>//                    Log.e(TAG, &quot;合并的数据是： &quot;+ o1 + &quot; &quot;+ o2);<br>//                    return o1 + o2;<br>//                    // 合并的逻辑 = 相加<br>//                    // 即第1个Observable发送的最后1个数据 与 第2个Observable发送的每1个数据进行相加<br>//                }<br>//            }).subscribe(new Consumer&lt;Long&gt;() {<br>//                @Override<br>//                public void accept(Long s) throws Exception {<br>//                    Log.e(TAG, &quot;合并的结果是： &quot;+s);<br>//                }<br>//            });<br>//        Observable.concatArrayDelayError(<br>//                Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {<br>//                    @Override<br>//                    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {<br>//<br>//                        emitter.onNext(1);<br>//                        emitter.onNext(2);<br>//                        emitter.onNext(3);<br>//                        emitter.onError(new NullPointerException()); // 发送Error事件，因为使用了concatDelayError，所以第2个Observable将会发送事件，等发送完毕后，再发送错误事件<br>//                        emitter.onComplete();<br>//                    }<br>//                }),<br>//                Observable.just(4, 5, 6))<br>//                .subscribe(new Observer&lt;Integer&gt;() {<br>//                    @Override<br>//                    public void onSubscribe(Disposable d) {<br>//<br>//                    }<br>//                    @Override<br>//                    public void onNext(Integer value) {<br>//                        Log.d(TAG, &quot;接收到了事件&quot;+ value  );<br>//                    }<br>//<br>//                    @Override<br>//                    public void onError(Throwable e) {<br>//                        Log.d(TAG, &quot;对Error事件作出响应&quot;);<br>//                    }<br>//<br>//                    @Override<br>//                    public void onComplete() {<br>//                        Log.d(TAG, &quot;对Complete事件作出响应&quot;);<br>//                    }<br>//                });<br>       // 在一个被观察者发送事件前，追加发送被观察者 &amp; 发送数据<br>       // 注：追加数据顺序 = 后调用先追加<br>//        Observable.just(4, 5, 6)<br>//                .startWith(Observable.just(1, 2, 3))<br>//                .subscribe(new Observer&lt;Integer&gt;() {<br>//                    @Override<br>//                    public void onSubscribe(Disposable d) {<br>//<br>//                    }<br>//<br>//                    @Override<br>//                    public void onNext(Integer value) {<br>//                        Log.d(TAG, &quot;接收到了事件&quot;+ value  );<br>//                    }<br>//<br>//                    @Override<br>//                    public void onError(Throwable e) {<br>//                        Log.d(TAG, &quot;对Error事件作出响应&quot;);<br>//                    }<br>//<br>//                    @Override<br>//                    public void onComplete() {<br>//                        Log.d(TAG, &quot;对Complete事件作出响应&quot;);<br>//                    }<br>//                });<br>//        // 使用2：获取位置索引大于发送事件序列时，设置默认参数<br>//        Observable.just(1, 2, 3, 4, 5)<br>//                .elementAt(6,10)<br>//                .subscribe(new Consumer&lt;Integer&gt;() {<br>//                    @Override<br>//                    public void accept( Integer integer) throws Exception {<br>//                        Log.d(TAG,&quot;获取到的事件元素是： &quot;+ integer);<br>//                    }<br>//                });<br>//<br>//<br>//        // 获取的位置索引 ＞ 发送事件序列长度时，抛出异常<br>//        Observable.just(1, 2, 3, 4, 5)<br>//                .elementAtOrError(6)<br>//                .subscribe(new Consumer&lt;Integer&gt;() {<br>//                    @Override<br>//                    public void accept( Integer integer) throws Exception {<br>//                        Log.d(TAG,&quot;获取到的事件元素是： &quot;+ integer);<br>//                    }<br>//                });<br>//        // 参数说明：<br>//        // 参数1 = 第1次延迟时间；<br>//        // 参数2 = 间隔时间数字；<br>//        // 参数3 = 时间单位；<br>//        Observable.interval(3,1,TimeUnit.SECONDS)<br>//                // 该例子发送的事件序列特点：延迟3s后发送事件，每隔1秒产生1个数字（从0开始递增1，无限个）<br>//                .subscribe(new Observer&lt;Long&gt;() {<br>//                    @Override<br>//                    public void onSubscribe(Disposable d) {<br>//                        Log.d(TAG, &quot;开始采用subscribe连接&quot;);<br>//                    }<br>//                    // 默认最先调用复写的 onSubscribe（）<br>//<br>//                    @Override<br>//                    public void onNext(Long value) {<br>//                        Log.d(TAG, &quot;接收到了事件&quot;+ value  );<br>//                    }<br>//<br>//                    @Override<br>//                    public void onError(Throwable e) {<br>//                        Log.d(TAG, &quot;对Error事件作出响应&quot;);<br>//                    }<br>//<br>//                    @Override<br>//                    public void onComplete() {<br>//                        Log.d(TAG, &quot;对Complete事件作出响应&quot;);<br>//                    }<br>//<br>//                });<br>//        // 参数说明：<br>//        // 参数1 = 事件序列起始点；<br>//        // 参数2 = 事件数量；<br>//        // 注：若设置为负数，则会抛出异常<br>//        Observable.range(3,10)<br>//                // 该例子发送的事件序列特点：从3开始发送，每次发送事件递增1，一共发送10个事件<br>//                .subscribe(new Observer&lt;Integer&gt;() {<br>//                    @Override<br>//                    public void onSubscribe(Disposable d) {<br>//                        Log.d(TAG, &quot;开始采用subscribe连接&quot;);<br>//                    }<br>//                    // 默认最先调用复写的 onSubscribe（）<br>//<br>//                    @Override<br>//                    public void onNext(Integer value) {<br>//                        Log.d(TAG, &quot;接收到了事件&quot;+ value  );<br>//                    }<br>//<br>//                    @Override<br>//                    public void onError(Throwable e) {<br>//                        Log.d(TAG, &quot;对Error事件作出响应&quot;);<br>//                    }<br>//<br>//                    @Override<br>//                    public void onComplete() {<br>//                        Log.d(TAG, &quot;对Complete事件作出响应&quot;);<br>//                    }<br>//<br>//                });<br>//<br>//        Observable.sequenceEqual(<br>//                Observable.just(4,5,6),<br>//                Observable.just(4,5,6)<br>//        )<br>//                .subscribe(new Consumer&lt;Boolean&gt;() {<br>//                    @Override<br>//                    public void accept( Boolean aBoolean) throws Exception {<br>//                        Log.d(TAG,&quot;2个Observable是否相同：&quot;+ aBoolean);<br>//                        // 输出返回结果<br>//                    }<br>//                });<br>//        // （原始）第1个Observable：每隔1s发送1个数据 = 从0开始，每次递增1<br>//        Observable.interval(1, TimeUnit.SECONDS)<br>//                // 第2个Observable：延迟5s后开始发送1个Long型数据<br>//                .skipUntil(Observable.timer(5, TimeUnit.SECONDS))<br>//                .subscribe(new Observer&lt;Long&gt;() {<br>//                    @Override<br>//                    public void onSubscribe(Disposable d) {<br>//                        Log.d(TAG, &quot;开始采用subscribe连接&quot;);<br>//                    }<br>//<br>//                    @Override<br>//                    public void onNext(Long value) {<br>//                        Log.d(TAG, &quot;接收到了事件&quot;+ value  );<br>//                    }<br>//<br>//                    @Override<br>//                    public void onError(Throwable e) {<br>//                        Log.d(TAG, &quot;对Error事件作出响应&quot;);<br>//                    }<br>//<br>//                    @Override<br>//                    public void onComplete() {<br>//                        Log.d(TAG, &quot;对Complete事件作出响应&quot;);<br>//                    }<br>//<br>//                });<br>//<br>//        // 1. 每1s发送1个数据 = 从0开始，递增1，即0、1、2、3<br>//        Observable.interval(1, TimeUnit.SECONDS)<br>//                // 2. 通过takeWhile传入一个判断条件<br>//                .takeWhile(new Predicate&lt;Long&gt;(){<br>//                    @Override<br>//                    public boolean test( Long integer) throws Exception {<br>//                        return (integer&lt;3);<br>//                        // 当发送的数据满足&lt;3时，才发送Observable的数据<br>//                    }<br>//                }).subscribe(new Observer&lt;Long&gt;() {<br>//            @Override<br>//            public void onSubscribe(Disposable d) {<br>//            }<br>//<br>//            @Override<br>//            public void onNext(Long value) {<br>//                Log.d(TAG,&quot;发送了事件 &quot;+ value);<br>//            }<br>//<br>//            @Override<br>//            public void onError(Throwable e) {<br>//            }<br>//<br>//            @Override<br>//            public void onComplete() {<br>//            }<br>//        });<br>//        Observable.just(1,2,3,4,5,6)<br>//                .map(new Function&lt;Integer,String&gt;() {<br>//                    @Override<br>//                    public String apply(Integer value) throws Exception {<br>//                        File file = new File(value);<br>//                        file.createNewFile();<br>//                        return &quot;aa&quot;;<br>//                    }<br>//                });<br>   }<br>//        Observable.just(1,2,3,4,5,6)<br>//                .all(new Func2&lt;Integer, Boolean&gt;() {<br>//                    @Override<br>//                    public Boolean apply(Integer integer, @NonNull Object o2) throws Exception {<br>//                        return integer&lt;=10;<br>//                        // 该函数用于判断Observable发送的10个数据是否都满足integer&lt;=10<br>//                    }<br>//<br>//                    @Override<br>//                    public Boolean call(Integer integer) {<br>//                        return integer&lt;=10;<br>//                        // 该函数用于判断Observable发送的10个数据是否都满足integer&lt;=10<br>//                    }<br>//                }).subscribe(new Consumer&lt;Boolean&gt;() {<br>//            @Override<br>//            public void accept(Boolean aBoolean) throws Exception {<br>//                Log.d(TAG,&quot;result is &quot;+ aBoolean);<br>//                // 输出返回结果<br>//            }<br>//<br>//        });<br>//        Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {<br>//            @Override<br>//            public void call(Subscriber&lt;? super Integer&gt; subscriber) {<br>//                  // 不发送任何有效事件<br>//                  // subscriber.onNext(1);<br>//                  // subscriber.onNext(2);<br>//                  // subscriber.onNext(3);<br>//<br>//                subscriber.onCompleted();<br>//                // 仅发送Complete事件<br>//            }<br>//        }).defaultIfEmpty(10) // 若仅发送了Complete事件，默认发送 值 = 10<br>//                .subscribe(new Subscriber&lt;Integer&gt;() {<br>//                    @Override<br>//                    public void onCompleted() {<br>//                        Log.v(TAG, &quot;onCompleted&quot;);<br>//                    }<br>//                    @Override<br>//                    public void onError(Throwable e) {<br>//                        Log.v(TAG, &quot;onError:&quot;+e.getMessage());<br>//                    }<br>//                    @Override<br>//                    public void onNext(Integer integer) {<br>//                        Log.v(TAG, &quot;onNext:&quot;+integer);<br>//                    }<br>//                });<br>//<br>//// 1. 通过creat（）创建被观察者对象<br>//        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {<br>//            // 2. 在复写的subscribe（）里定义需要发送的事件<br>//            @Override<br>//            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {<br>//                emitter.onNext(1);<br>//                emitter.onNext(2);<br>//                emitter.onNext(3);<br>//                emitter.onNext(4);<br>//<br>//                emitter.onComplete();<br>//            }  // 至此，一个被观察者对象（Observable）就创建完毕<br>//        }).subscribe(new Observer&lt;Integer&gt;() {<br>//            // 以下步骤仅为展示一个完整demo，可以忽略<br>//            // 3. 通过通过订阅（subscribe）连接观察者和被观察者<br>//            // 4. 创建观察者 &amp; 定义响应事件的行为<br>//            @Override<br>//            public void onSubscribe(Disposable d) {<br>//                Log.d(TAG, &quot;开始采用subscribe连接&quot;);<br>//            }<br>//            // 默认最先调用复写的 onSubscribe（）<br>//<br>//            @Override<br>//            public void onNext(Integer value) {<br>//                Log.d(TAG, &quot;接收到了事件&quot;+ value  );<br>//            }<br>//<br>//            @Override<br>//            public void onError(Throwable e) {<br>//                Log.d(TAG, &quot;对Error事件作出响应&quot;);<br>//            }<br>//<br>//            @Override<br>//            public void onComplete() {<br>//                Log.d(TAG, &quot;对Complete事件作出响应&quot;);<br>//            }<br>//<br>//        });</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>navigation_bar</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/navigation_bar.xml/</url>
    <content><![CDATA[<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</p>
<p>&lt;!–</p>
<p>**</p>
<p>** Copyright 2012, The Android Open Source Project</p>
<p>**</p>
<p>** Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); </p>
<p>** you may not use this file except in compliance with the License. </p>
<p>** You may obtain a copy of the License at </p>
<p>**</p>
<p>**     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a> </p>
<p>**</p>
<p>** Unless required by applicable law or agreed to in writing, software </p>
<p>** distributed under the License is distributed on an &quot;AS IS&quot; BASIS, </p>
<p>** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. </p>
<p>** See the License for the specific language governing permissions and </p>
<p>** limitations under the License.</p>
<p>–&gt;</p>
<p>&lt;!–  navigation bar for sw600dp (small tablets) –&gt;</p>
<p>&lt;com.android.systemui.statusbar.phone.NavigationBarView</p>
<p>    xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;</p>
<p>    xmlns:systemui=&quot;<a href="http://schemas.android.com/apk/res/com.android.systemui">http://schemas.android.com/apk/res/com.android.systemui</a>&quot;</p>
<p>    android:layout_height=&quot;match_parent&quot;</p>
<p>    android:layout_width=&quot;match_parent&quot;</p>
<p>    android:background=&quot;@drawable/system_bar_background&quot;</p>
<p>    &gt;</p>
<p>    &lt;FrameLayout android:id=&quot;@+id/rot90&quot;</p>
<p>        android:layout_height=&quot;match_parent&quot;</p>
<p>        android:layout_width=&quot;match_parent&quot;</p>
<p>        &gt;</p>
<p>        &lt;LinearLayout</p>
<p>            android:layout_height=&quot;match_parent&quot;</p>
<p>            android:layout_width=&quot;match_parent&quot;</p>
<p>            android:orientation=&quot;horizontal&quot;</p>
<p>            android:clipChildren=&quot;false&quot;</p>
<p>            android:clipToPadding=&quot;false&quot;</p>
<p>            android:id=&quot;@+id/nav_buttons&quot;</p>
<p>            android:animateLayoutChanges=&quot;true&quot;</p>
<p>            &gt;</p>
<p>            &lt;!– navigation controls –&gt;</p>
<p>            &lt;!–View</p>
<p>                android:layout_width=&quot;48dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                android:layout_marginStart=&quot;2dp&quot;</p>
<p>                android:visibility=&quot;invisible&quot;</p>
<p>                /–&gt;</p>
<p>            &lt;Space </p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_weight=&quot;1&quot;</p>
<p>                /&gt;</p>
<p>&lt;LinearLayout</p>
<p>   android:layout_height=&quot;match_parent&quot;</p>
<p>android:layout_width=&quot;84dp&quot;</p>
<p>&gt; </p>
<p>             &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/screenshot&quot;</p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/capture&quot;</p>
<p>                android:layout_marginRight=&quot;0dp&quot;</p>
<p>android:layout_weight=&quot;0&quot;</p>
<p>android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
<p>systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>/&gt;</p>
<p>&lt;/LinearLayout&gt;</p>
<p>           &lt;com.android.systemui.statusbar.policy.KeyButtonView</p>
<p>                  android:id=&quot;@+id/sub&quot;</p>
<p> android:layout_width=&quot;120dp&quot;</p>
<p> android:layout_height=&quot;match_parent&quot;</p>
<p> android:layout_weight=&quot;0&quot;</p>
<p> android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
<p> android:paddingLeft=&quot;0dp&quot;</p>
<p> android:paddingRight=&quot;0dp&quot;</p>
<p> android:src=&quot;@drawable/sub_normal&quot;</p>
<p> android:visibility=&quot;invisible&quot;</p>
<p> systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p> systemui:keyCode=&quot;25&quot; /&gt;</p>
<p>            &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/back&quot;</p>
<p>                android:layout_width=&quot;120dp&quot; android:paddingStart=&quot;25dp&quot; android:paddingEnd=&quot;25dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_back&quot;</p>
<p>                systemui:keyCode=&quot;4&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                android:contentDescription=&quot;@string/accessibility_back&quot;</p>
<p>                /&gt;</p>
<p>            &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/home&quot;</p>
<p>                android:layout_width=&quot;120dp&quot; android:paddingStart=&quot;25dp&quot; android:paddingEnd=&quot;25dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_home&quot;</p>
<p>                systemui:keyCode=&quot;3&quot;</p>
<p>                systemui:keyRepeat=&quot;true&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                android:contentDescription=&quot;@string/accessibility_home&quot;</p>
<p>                /&gt;</p>
<p>            &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/recent_apps&quot;</p>
<p>                android:layout_width=&quot;120dp&quot; android:paddingStart=&quot;25dp&quot; android:paddingEnd=&quot;25dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_recent&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
<p>                /&gt;</p>
<p>   &lt;com.android.systemui.statusbar.policy.KeyButtonView</p>
<p>                android:id=&quot;@+id/add&quot;</p>
<p>android:layout_width=&quot;120dp&quot;</p>
<p>android:layout_height=&quot;match_parent&quot;</p>
<p>android:layout_weight=&quot;0&quot;</p>
<p>android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
<p>android:paddingLeft=&quot;0dp&quot;</p>
<p>android:paddingRight=&quot;0dp&quot;</p>
<p>android:src=&quot;@drawable/add_normal&quot;</p>
<p>android:visibility=&quot;invisible&quot;</p>
<p>systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>systemui:keyCode=&quot;24&quot; /&gt;</p>
<p>            &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/menu&quot;</p>
<p>                android:layout_width=&quot;84dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_menu&quot;</p>
<p>                android:layout_marginEnd=&quot;2dp&quot;</p>
<p>                systemui:keyCode=&quot;82&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                android:visibility=&quot;invisible&quot;</p>
<p>                android:contentDescription=&quot;@string/accessibility_menu&quot;</p>
<p>                systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                /&gt;</p>
<p>&lt;Space</p>
<p>   android:layout_width=&quot;match_parent&quot;</p>
<p>android:layout_height=&quot;match_parent&quot;</p>
<p>android:layout_weight=&quot;1&quot;</p>
<p>/&gt;</p>
<p>        &lt;/LinearLayout&gt;</p>
<p>        &lt;!– lights out layout to match exactly –&gt;</p>
<p>        &lt;LinearLayout</p>
<p>            android:layout_height=&quot;match_parent&quot;</p>
<p>            android:layout_width=&quot;match_parent&quot;</p>
<p>            android:orientation=&quot;horizontal&quot;</p>
<p>            android:id=&quot;@+id/lights_out&quot;</p>
<p>            android:visibility=&quot;gone&quot;</p>
<p>            &gt;</p>
<p>            &lt;Space </p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_weight=&quot;1&quot;</p>
<p>                /&gt;</p>
<p>            &lt;ImageView</p>
<p>                android:layout_width=&quot;128dp&quot; android:paddingStart=&quot;25dp&quot; android:paddingEnd=&quot;25dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_marginStart=&quot;40dp&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_lights_out_dot_small&quot;</p>
<p>                android:scaleType=&quot;center&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                /&gt;</p>
<p>            &lt;ImageView</p>
<p>                android:layout_width=&quot;128dp&quot; android:paddingStart=&quot;25dp&quot; android:paddingEnd=&quot;25dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_lights_out_dot_large&quot;</p>
<p>                android:scaleType=&quot;center&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                /&gt;</p>
<p>            &lt;ImageView</p>
<p>                android:layout_width=&quot;128dp&quot; android:paddingStart=&quot;25dp&quot; android:paddingEnd=&quot;25dp&quot;</p>
<p>                android:layout_marginEnd=&quot;40dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_lights_out_dot_small&quot;</p>
<p>                android:scaleType=&quot;center&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                /&gt;</p>
<p>            &lt;Space </p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_weight=&quot;1&quot;</p>
<p>                /&gt;</p>
<p>        &lt;/LinearLayout&gt;</p>
<p>        &lt;com.android.systemui.statusbar.policy.KeyButtonView</p>
<p>            android:layout_width=&quot;128dp&quot;</p>
<p>            android:id=&quot;@+id/search_light&quot;</p>
<p>            android:layout_height=&quot;match_parent&quot;</p>
<p>            android:layout_gravity=&quot;center_horizontal&quot;</p>
<p>            android:src=&quot;@drawable/search_light&quot;</p>
<p>            android:scaleType=&quot;center&quot;</p>
<p>            android:visibility=&quot;gone&quot;</p>
<p>            android:contentDescription=&quot;@string/accessibility_search_light&quot;</p>
<p>            /&gt;</p>
<p>        &lt;com.android.systemui.statusbar.policy.DeadZone</p>
<p>            android:id=&quot;@+id/deadzone&quot;</p>
<p>            android:layout_height=&quot;match_parent&quot;</p>
<p>            android:layout_width=&quot;match_parent&quot;</p>
<p>            systemui:minSize=&quot;@dimen/navigation_bar_deadzone_size&quot;</p>
<p>            systemui:maxSize=&quot;@dimen/navigation_bar_deadzone_size_max&quot;</p>
<p>            systemui:holdTime=&quot;@integer/navigation_bar_deadzone_hold&quot;</p>
<p>            systemui:decayTime=&quot;@integer/navigation_bar_deadzone_decay&quot;</p>
<p>            systemui:orientation=&quot;horizontal&quot;</p>
<p>            android:layout_gravity=&quot;top&quot;</p>
<p>            /&gt;</p>
<p>    &lt;/FrameLayout&gt;</p>
<p>    &lt;FrameLayout android:id=&quot;@+id/rot0&quot;</p>
<p>        android:layout_height=&quot;match_parent&quot;</p>
<p>        android:layout_width=&quot;match_parent&quot;</p>
<p>        android:visibility=&quot;gone&quot;</p>
<p>        android:paddingTop=&quot;0dp&quot;</p>
<p>        &gt;</p>
<p>        &lt;LinearLayout</p>
<p>            android:layout_height=&quot;match_parent&quot;</p>
<p>            android:layout_width=&quot;match_parent&quot;</p>
<p>            android:orientation=&quot;horizontal&quot;</p>
<p>            android:clipChildren=&quot;false&quot;</p>
<p>            android:clipToPadding=&quot;false&quot;</p>
<p>            android:id=&quot;@+id/nav_buttons&quot;</p>
<p>            android:animateLayoutChanges=&quot;true&quot;</p>
<p>            &gt;</p>
<p>            &lt;!– navigation controls –&gt;</p>
<p>            &lt;!–View</p>
<p>                android:layout_width=&quot;48dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                android:layout_marginStart=&quot;2dp&quot;</p>
<p>                android:visibility=&quot;invisible&quot;</p>
<p>                /–&gt;</p>
<p>            &lt;Space </p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_weight=&quot;1&quot;</p>
<p>                /&gt;</p>
<p>&lt;LinearLayout</p>
<p>   android:layout_width=&quot;84dp&quot;</p>
<p>android:layout_height=&quot;match_parent&quot;</p>
<p>&gt;</p>
<p>              &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/screenshot&quot;</p>
<p>                     android:layout_width=&quot;match_parent&quot;</p>
<p>                     android:layout_height=&quot;match_parent&quot;</p>
<p>                     android:src=&quot;@drawable/capture&quot;</p>
<p>                     android:layout_marginRight=&quot;0dp&quot;</p>
<p>                     android:layout_weight=&quot;0&quot;</p>
<p>                     android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
<p>                     systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;/&gt; </p>
<p>         &lt;/LinearLayout&gt;</p>
<p> &lt;com.android.systemui.statusbar.policy.KeyButtonView</p>
<p>                  android:id=&quot;@+id/sub&quot;</p>
<p>                    android:layout_width=&quot;162dp&quot;</p>
<p>                     android:layout_height=&quot;match_parent&quot;</p>
<p>                          android:layout_weight=&quot;0&quot;</p>
<p>                           android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
<p>                            android:paddingLeft=&quot;24dp&quot;</p>
<p>                            android:paddingRight=&quot;24dp&quot;</p>
<p>                           android:src=&quot;@drawable/sub_normal&quot;</p>
<p>                            android:visibility=&quot;invisible&quot;</p>
<p>                            systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                            systemui:keyCode=&quot;25&quot; /&gt;</p>
<p>            &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/back&quot;</p>
<p>                android:layout_width=&quot;162dp&quot; android:paddingStart=&quot;42dp&quot; android:paddingEnd=&quot;42dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_back&quot;</p>
<p>                systemui:keyCode=&quot;4&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                android:contentDescription=&quot;@string/accessibility_back&quot;</p>
<p>                /&gt;</p>
<p>            &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/home&quot;</p>
<p>                android:layout_width=&quot;162dp&quot; android:paddingStart=&quot;42dp&quot; android:paddingEnd=&quot;42dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_home&quot;</p>
<p>                systemui:keyCode=&quot;3&quot;</p>
<p>                systemui:keyRepeat=&quot;true&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                android:contentDescription=&quot;@string/accessibility_home&quot;</p>
<p>                /&gt;</p>
<p>            &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/recent_apps&quot;</p>
<p>                android:layout_width=&quot;162dp&quot; android:paddingStart=&quot;42dp&quot; android:paddingEnd=&quot;42dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_recent&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
<p>                 /&gt;</p>
<p>             &lt;com.android.systemui.statusbar.policy.KeyButtonView</p>
<p>                 android:id=&quot;@+id/add&quot;</p>
<p>                 android:layout_width=&quot;162dp&quot;</p>
<p>                 android:layout_height=&quot;match_parent&quot;</p>
<p>                 android:layout_weight=&quot;0&quot;</p>
<p>                 android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
<p>                 android:paddingLeft=&quot;41dp&quot;</p>
<p>                 android:paddingRight=&quot;41dp&quot;</p>
<p>                 android:src=&quot;@drawable/add_normal&quot;</p>
<p>                 android:visibility=&quot;invisible&quot;</p>
<p>                 systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                 systemui:keyCode=&quot;24&quot; /&gt;  </p>
<p>            &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/menu&quot;</p>
<p>                android:layout_width=&quot;84dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_marginEnd=&quot;2dp&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_menu&quot;</p>
<p>                systemui:keyCode=&quot;82&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                android:visibility=&quot;invisible&quot;</p>
<p>                android:contentDescription=&quot;@string/accessibility_menu&quot;</p>
<p>                systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                /&gt;</p>
<p>&lt;Space</p>
<p>   android:layout_width=&quot;match_parent&quot;</p>
<p>android:layout_height=&quot;match_parent&quot;</p>
<p>android:layout_weight=&quot;1&quot;</p>
<p>/&gt;</p>
<p>        &lt;/LinearLayout&gt;</p>
<p>        &lt;!– lights out layout to match exactly –&gt;</p>
<p>        &lt;LinearLayout</p>
<p>            android:layout_height=&quot;match_parent&quot;</p>
<p>            android:layout_width=&quot;match_parent&quot;</p>
<p>            android:orientation=&quot;horizontal&quot;</p>
<p>            android:id=&quot;@+id/lights_out&quot;</p>
<p>            android:visibility=&quot;gone&quot;</p>
<p>            &gt;</p>
<p>            &lt;Space </p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_weight=&quot;1&quot;</p>
<p>                /&gt;</p>
<p>            &lt;ImageView</p>
<p>                android:layout_width=&quot;162dp&quot; android:paddingStart=&quot;42dp&quot; android:paddingEnd=&quot;42dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_marginStart=&quot;40dp&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_lights_out_dot_small&quot;</p>
<p>                android:scaleType=&quot;center&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                /&gt;</p>
<p>            &lt;ImageView</p>
<p>                android:layout_width=&quot;162dp&quot; android:paddingStart=&quot;42dp&quot; android:paddingEnd=&quot;42dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_lights_out_dot_large&quot;</p>
<p>                android:scaleType=&quot;center&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                /&gt;</p>
<p>            &lt;ImageView</p>
<p>                android:layout_width=&quot;162dp&quot; android:paddingStart=&quot;42dp&quot; android:paddingEnd=&quot;42dp&quot;</p>
<p>                android:layout_marginEnd=&quot;40dp&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:src=&quot;@drawable/ic_sysbar_lights_out_dot_small&quot;</p>
<p>                android:scaleType=&quot;center&quot;</p>
<p>                android:layout_weight=&quot;0&quot;</p>
<p>                /&gt;</p>
<p>            &lt;Space </p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<p>                android:layout_weight=&quot;1&quot;</p>
<p>                /&gt;</p>
<p>        &lt;/LinearLayout&gt;</p>
<p>        &lt;com.android.systemui.statusbar.policy.KeyButtonView</p>
<p>            android:layout_width=&quot;162dp&quot;</p>
<p>            android:id=&quot;@+id/search_light&quot;</p>
<p>            android:layout_height=&quot;match_parent&quot;</p>
<p>            android:layout_gravity=&quot;center_horizontal&quot;</p>
<p>            android:src=&quot;@drawable/search_light&quot;</p>
<p>            android:scaleType=&quot;center&quot;</p>
<p>            android:visibility=&quot;gone&quot;</p>
<p>            android:contentDescription=&quot;@string/accessibility_search_light&quot;</p>
<p>            /&gt;</p>
<p>        &lt;com.android.systemui.statusbar.policy.DeadZone</p>
<p>            android:id=&quot;@+id/deadzone&quot;</p>
<p>            android:layout_height=&quot;match_parent&quot;</p>
<p>            android:layout_width=&quot;match_parent&quot;</p>
<p>            systemui:minSize=&quot;@dimen/navigation_bar_deadzone_size&quot;</p>
<p>            systemui:maxSize=&quot;@dimen/navigation_bar_deadzone_size_max&quot;</p>
<p>            systemui:holdTime=&quot;@integer/navigation_bar_deadzone_hold&quot;</p>
<p>            systemui:decayTime=&quot;@integer/navigation_bar_deadzone_decay&quot;</p>
<p>            systemui:orientation=&quot;vertical&quot;</p>
<p>            android:layout_gravity=&quot;top&quot;</p>
<p>            /&gt;</p>
<p>    &lt;/FrameLayout&gt;</p>
<p>    &lt;!– not used –&gt;</p>
<p>    &lt;View android:id=&quot;@+id/rot270&quot;</p>
<p>        android:layout_height=&quot;match_parent&quot;</p>
<p>        android:layout_width=&quot;match_parent&quot;</p>
<p>        android:visibility=&quot;gone&quot;</p>
<p>        /&gt;</p>
<p>&lt;/com.android.systemui.statusbar.phone.NavigationBarView&gt;</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>provison</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/provison/</url>
    <content><![CDATA[<p>/*</p>
<p> * Copyright (C) 2008 The Android Open Source Project</p>
<p> *</p>
<p> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</p>
<p> * you may not use this file except in compliance with the License.</p>
<p> * You may obtain a copy of the License at</p>
<p> *</p>
<p> *      <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p> *</p>
<p> * Unless required by applicable law or agreed to in writing, software</p>
<p> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</p>
<p> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>
<p> * See the License for the specific language governing permissions and</p>
<p> * limitations under the License.</p>
<p> */</p>
<p>package com.android.provision;</p>
<p>import java.io.File;</p>
<p>import java.io.FileOutputStream;</p>
<p>import java.io.FilenameFilter;</p>
<p>import java.io.IOException;</p>
<p>import java.io.OutputStreamWriter;</p>
<p>import android.net.Uri;</p>
<p>import android.content.pm.ActivityInfo;</p>
<p>import android.content.pm.ApplicationInfo;</p>
<p>import android.content.pm.IPackageInstallObserver;</p>
<p>import android.content.pm.PackageInfo;</p>
<p>import android.app.Activity;</p>
<p>import android.content.ComponentName;</p>
<p>import android.content.Context;</p>
<p>import android.content.pm.PackageManager;</p>
<p>import android.net.Uri;</p>
<p>import android.os.Bundle;</p>
<p>import android.os.Handler;</p>
<p>import android.os.Message;</p>
<p>import android.provider.Settings;</p>
<p>import android.util.Log;</p>
<p>import android.widget.Toast;</p>
<p>import android.os.SystemProperties;</p>
<p>import java.io.IOException;</p>
<p>import java.util.List;</p>
<p>import android.util.Log;</p>
<p>import android.app.ActivityManagerNative;</p>
<p>import android.content.res.Configuration;</p>
<p>import android.os.RemoteException;</p>
<p>import android.view.Window;</p>
<p>import android.app.ActivityManager;</p>
<p>import android.content.Intent;</p>
<p>import android.os.Environment;</p>
<p>import android.location.LocationManager;</p>
<p>import java.lang.Exception;</p>
<p>import android.os.PowerManager.WakeLock;</p>
<p>import android.os.PowerManager;</p>
<p>import android.widget.ProgressBar;</p>
<p>import android.widget.TextView;</p>
<p>import android.view.InputDevice;</p>
<p>import android.hardware.input.InputManager;</p>
<p>import android.hardware.input.KeyboardLayout;</p>
<p>import android.content.res.Configuration;</p>
<p>import android.content.res.Resources;</p>
<p>import android.util.Log;</p>
<p>import android.os.SystemProperties;</p>
<p>/**</p>
<p> * Application that sets the provisioned bit, like SetupWizard does.</p>
<p> */</p>
<p>public class DefaultActivity extends Activity {</p>
<p>private static final String TAG = &quot;PreInstallApps&quot;;</p>
<p>private static final String PATH_PREFIX = &quot;/system/pre_app/&quot;;</p>
<p>private static final int MSG_INSTALLED_PACKAGE = 0;</p>
<p>private static final int MSG_REMOVE_SELF = 1;</p>
<p>private static final int MSG_COPY_DONE = 2;</p>
<p>private ProgressBar progressHorizontal = null;</p>
<p>private InputManager mIm = null;</p>
<p>String[] mFileNames = null;</p>
<p>String[][] nFileName = null;</p>
<p>int sub = 3; // install n apks each time</p>
<p>static int install_index = 0;// n times to install</p>
<p>int itimes = 0;</p>
<p>private int mCount = 0;</p>
<p>private WakeLock mWakeLock = null;</p>
<p>    static  int installCtrl = 0 ;</p>
<p>private TextView intallStatus = null;</p>
<p>private TextView intallStatus1 = null;</p>
<p>Handler mHandler = new Handler() {</p>
<p>@Override</p>
<p>public void handleMessage(Message msg) {</p>
<p>super.handleMessage(msg);</p>
<p>Log.d(TAG, &quot;Enter handleMessage&quot;);</p>
<p>switch (msg.what) {</p>
<p>case MSG_INSTALLED_PACKAGE:</p>
<p>int tmpCmt = mCount+1;</p>
<p>intallStatus1.setText(&quot;Installing  &quot;+tmpCmt+&quot;/&quot;+mFileNames.length+&quot;… Please wait …&quot;);</p>
<p>intallStatus.setText(intallStatus.getText().toString()</p>
<ul>
<li>&quot;\n Installed &quot; + (CharSequence) msg.obj + &quot; done.&quot;);</li>
</ul>
<p>// Toast.makeText(DefaultActivity.this, (CharSequence) msg.obj,</p>
<p>// Toast.LENGTH_SHORT).show();</p>
<p>if (progressHorizontal != null)</p>
<p>progressHorizontal.incrementProgressBy(1);</p>
<p>if ((mCount &gt; 1) &amp;&amp; ((mCount + 1) % sub == 0)) {</p>
<p>if (++install_index &lt; itimes) {</p>
<p>installPackages(nFileName[install_index]);</p>
<p>Log.d(TAG, &quot;install_index:=&quot; + install_index);</p>
<p>}</p>
<p>}</p>
<p>if (++mCount &gt;= mFileNames.length) {</p>
<p>Log.d(TAG, &quot;handleMessage MSG_INSTALLED_PACKAGE cnt:&quot;</p>
<ul>
<li>mCount);</li>
</ul>
<p>Message msgTmp = this.obtainMessage();</p>
<p>msgTmp.what = MSG_REMOVE_SELF;</p>
<p>this.sendMessage(msgTmp);</p>
<p>}</p>
<p>break;</p>
<p>case MSG_COPY_DONE:</p>
<p>Log.d(TAG, &quot;——— copy files done ————–!&quot;);</p>
<p>getAllAPPS(); // get all apps</p>
<p>install_index = 0;</p>
<p>if(nFileName != null)</p>
<p>installPackages(nFileName[install_index]);</p>
<p>intallStatus1.setText(&quot;Installing  … Please wait …&quot;);</p>
<p>break;</p>
<p>case MSG_REMOVE_SELF:</p>
<p>// Toast.makeText(DefaultActivity.this,</p>
<p>// (CharSequence) &quot;Install done!&quot;, Toast.LENGTH_SHORT)</p>
<p>// .show();</p>
<p>intallStatus.setText(&quot;Installing  Done !\n&quot;</p>
<ul>
<li>intallStatus.getText().toString());</li>
</ul>
<p>Log.d(TAG, &quot;handleMessage MSG_REMOVE_SELF&quot;);</p>
<p>// Add a persistent setting to allow other apps to know the</p>
<p>// device has been provisioned.</p>
<p>ActivityManager manager = (ActivityManager) DefaultActivity.this</p>
<p>.getSystemService(Context.ACTIVITY_SERVICE);</p>
<p>manager.killBackgroundProcesses(&quot;com.android.launcher&quot;);</p>
<p>try // catch unknown errors</p>
<p>{</p>
<p>notifyMediaRefresh();</p>
<p>Settings.Secure.putInt(getContentResolver(),</p>
<p>Settings.Secure.DEVICE_PROVISIONED, 1);</p>
<p>// remove this activity from the package manager.</p>
<p>ComponentName name = new ComponentName(</p>
<p>DefaultActivity.this, DefaultActivity.class);</p>
<p>pm.setComponentEnabledSetting(name,</p>
<p>PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0);</p>
<p>// terminate the activity.</p>
<p>if (mWakeLock != null)</p>
<p>mWakeLock.release(); // release wakelock before finished</p>
<p>finish();</p>
<p>} catch (Exception e) {</p>
<p>finish();</p>
<p>}</p>
<p>break;</p>
<p>default:</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>PackageManager pm;</p>
<p>@Override</p>
<p>protected void onCreate(Bundle savedInstanceState) {</p>
<p>super.onCreate(savedInstanceState);</p>
<p>Log.d(TAG, &quot;———— onCreate ————-&quot;);</p>
<p>requestWindowFeature(Window.FEATURE_NO_TITLE);</p>
<p>setContentView(R.layout.main);</p>
<p>progressHorizontal = (ProgressBar) findViewById(R.id.progress_horizontal);</p>
<p>progressHorizontal.setVisibility(0);// visible 0</p>
<p>progressHorizontal.setProgress(1);</p>
<p>intallStatus = (TextView) findViewById(R.id.install_status);</p>
<p>intallStatus.setText(&quot;&quot;);</p>
<p>intallStatus1 = (TextView) findViewById(R.id.install_status1);</p>
<p>intallStatus1.setText(&quot;Copying Needed Files … Please wait …&quot;);</p>
<p>initOEM();// Init Setting for OEM</p>
<p>if (pm == null)</p>
<p>pm = getPackageManager();</p>
<p>if (mIm == null)</p>
<p>mIm = (InputManager) getSystemService(Context.INPUT_SERVICE);</p>
<p>if (mWakeLock == null) {</p>
<p>PowerManager pma = (PowerManager) this</p>
<p>.getSystemService(Context.POWER_SERVICE);</p>
<p>mWakeLock = pma.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,</p>
<p>&quot;Provision&quot;);</p>
<p>}</p>
<p>// stay awake during installing apps</p>
<p>if (mWakeLock != null)</p>
<p>mWakeLock.acquire();</p>
<p>if(installCtrl == 0){</p>
<p>new CopyFileThread().start(); // monitoring the copyfiles services</p>
<p>Log.d(TAG, &quot;—– copyfiles thread monitor start ——&quot;);</p>
<p>}</p>
<p>installCtrl++ ;</p>
<p>}</p>
<p>@Override</p>
<p>public void onSaveInstanceState(Bundle savedInstanceState) {   </p>
<p>    // Always call the superclass so it can save the view hierarchy state</p>
<p>    super.onSaveInstanceState(savedInstanceState);</p>
<p>}</p>
<p>@Override</p>
<p>public void onRestoreInstanceState(Bundle savedInstanceState) {</p>
<p>    // Always call the superclass so it can restore the view hierarchy</p>
<p>    super.onRestoreInstanceState(savedInstanceState);   </p>
<p>}</p>
<p>    public void notifyMediaRefresh(){</p>
<p>// Notify Media Refresh</p>
<p>DefaultActivity.this</p>
<p>.sendBroadcast(new Intent(</p>
<p>Intent.ACTION_MEDIA_MOUNTED,</p>
<p>Uri.parse(&quot;file://&quot;</p>
<ul>
<li>Environment</li>
</ul>
<p>.getExternalStorageDirectory())));</p>
<p>Log.d(TAG, &quot; notify media refresh : :  refresh the media store .&quot;);</p>
<p>}</p>
<p>class PackageInstallObserver extends IPackageInstallObserver.Stub {</p>
<p>public void packageInstalled(String packageName, int returnCode) {</p>
<p>Message msg = mHandler.obtainMessage();</p>
<p>msg.what = MSG_INSTALLED_PACKAGE;</p>
<p>msg.arg1 = returnCode;</p>
<p>msg.obj = packageName;</p>
<p>mHandler.sendMessage(msg);</p>
<p>Log.d(TAG, &quot;sendMessage MSG_INSTALLED_PACKAGE:&quot; + (String) msg.obj);</p>
<p>}</p>
<p>}</p>
<p>private class CopyFileThread extends Thread {</p>
<p>@Override</p>
<p>public void run() {</p>
<p>String copy_sh;</p>
<p>while (true) {</p>
<p>copy_sh = SystemProperties.get(&quot;init.svc.copyfile&quot;, &quot;stopped&quot;);</p>
<p>Log.d(TAG, &quot;copy_sh  &quot; + copy_sh);</p>
<p>if (copy_sh != null &amp;&amp; copy_sh.equals(&quot;stopped&quot;)) {</p>
<p>break;</p>
<p>}</p>
<p>try {</p>
<p>Thread.sleep(1000);</p>
<p>} catch (Exception ex) {</p>
<p>Log.e(TAG, &quot;Exception: &quot; + ex.getMessage());</p>
<p>}</p>
<p>}</p>
<p>Message msg = mHandler.obtainMessage();</p>
<p>msg.what = MSG_COPY_DONE;</p>
<p>mHandler.sendMessage(msg);</p>
<p>notifyMediaRefresh();</p>
<p>}</p>
<p>}</p>
<p>private void installPackages(String[] appsFileName) {</p>
<p>int i;</p>
<p>File file;</p>
<p>Uri mPackageURI;</p>
<p>if(appsFileName == null){</p>
<p>Message msg = mHandler.obtainMessage();</p>
<p>msg.what = MSG_REMOVE_SELF;</p>
<p>mHandler.sendMessage(msg);</p>
<p>}else if (appsFileName.length &gt; 0) {</p>
<p>PackageInstallObserver observer = new PackageInstallObserver();</p>
<p>for (i = 0; i &lt; appsFileName.length; i++) {</p>
<p>if (appsFileName[i] != null) {</p>
<p>intallStatus.setText(intallStatus.getText().toString()</p>
<ul>
<li>&quot;\n Installing &quot; + appsFileName[i] + &quot;…&quot;);</li>
</ul>
<p>file = new File(PATH_PREFIX + appsFileName[i]);// replace</p>
<p>// with an</p>
<p>// arraylist.</p>
<p>mPackageURI = Uri.fromFile(file);</p>
<p>Log.d(TAG, &quot;Install:&quot; + mPackageURI.toString());</p>
<p>pm.installPackage(mPackageURI, observer,</p>
<p>PackageManager.INSTALL_REPLACE_EXISTING, null);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>private void getAllAPPS() {</p>
<p>// Get all apps</p>
<p>if (mFileNames == null) {</p>
<p>mFileNames = getAllAppsFileNames();</p>
<p>if (mFileNames == null || mFileNames.length &lt;= 0) {</p>
<p>Message msg = mHandler.obtainMessage();</p>
<p>msg.what = MSG_REMOVE_SELF;</p>
<p>mHandler.sendMessage(msg);</p>
<p>} else {</p>
<p>int len = mFileNames.length;</p>
<p>itimes = (len % sub == 0) ? len / sub : len / sub + 1;</p>
<p>nFileName = new String[itimes][sub];</p>
<p>int k = 0;</p>
<p>if (progressHorizontal != null)</p>
<p>progressHorizontal.setMax(len);</p>
<p>for (int i = 0; i &lt; itimes; i++) {</p>
<p>for (int j = 0; j &lt; sub; j++) {</p>
<p>nFileName[i][j] = mFileNames[k++];</p>
<p>Log.d(TAG, &quot;###### read app :&quot; + nFileName[i][j]);</p>
<p>if (k &gt;= len)</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>private String[] getAllAppsFileNames() {</p>
<p>File dir = null;</p>
<p>String[] fileNames;</p>
<p>try {</p>
<p>dir = new File(PATH_PREFIX);</p>
<p>} catch (Exception e) {</p>
<p>notifyMediaRefresh();</p>
<p>Settings.Secure.putInt(getContentResolver(),</p>
<p>Settings.Secure.DEVICE_PROVISIONED, 1);</p>
<p>// remove this activity from the package manager.</p>
<p>ComponentName name = new ComponentName(DefaultActivity.this,</p>
<p>DefaultActivity.class);</p>
<p>pm.setComponentEnabledSetting(name,</p>
<p>PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0);</p>
<p>finish();</p>
<p>}</p>
<p>fileNames = dir.list(new FilenameFilter() {</p>
<p>@Override</p>
<p>public boolean accept(File dir, String filename) {</p>
<p>if (filename.matches(&quot;.*\.(?i)apk&quot;)) {</p>
<p>return true;</p>
<p>}</p>
<p>return false;</p>
<p>}</p>
<p>});</p>
<p>return fileNames;</p>
<p>}</p>
<p>// ====================initial setting for oem ====================</p>
<p>private void initOEM() {</p>
<p>enableInputMethod();</p>
<p>settingLargeSysFont();</p>
<p>setSpellCheckEnable();</p>
<p>showPassWords();</p>
<p>setDevelopmentEnable();</p>
<p>setVerifyEnable();</p>
<p>set24HFormat();</p>
<p>isNeverTimeout();</p>
<p>//updateHardKeyboards();// set default keyboard layout only avilble when plug in</p>
<p>setNetworkLocationEnable();</p>
<p>setUSE_LOCATION_FOR_SERVICES();</p>
<p>setShowTouchesEnable();</p>
<p>setEnableADB(); //adb debug</p>
<p>// startApp();</p>
<p>}</p>
<p>// ======================================================</p>
<p>private void settingLargeSysFont() {</p>
<p>try {</p>
<p>Configuration mCurConfig = new Configuration();</p>
<p>try {</p>
<p>mCurConfig.updateFrom(ActivityManagerNative.getDefault()</p>
<p>.getConfiguration());</p>
<p>} catch (RemoteException re) {</p>
<p>/* ignore */</p>
<p>}</p>
<p>int i = SystemProperties.getInt(&quot;ro.default.size&quot;, 100);</p>
<p>mCurConfig.fontScale = (i * 0.01f);</p>
<p>ActivityManagerNative.getDefault().updatePersistentConfiguration(</p>
<p>mCurConfig);</p>
<p>} catch (RemoteException re) {</p>
<p>// terminate the activity.</p>
<p>}</p>
<p>}</p>
<p>private void enableInputMethod() {</p>
<p>String defaultInputMethod = SystemProperties.get(&quot;ro.bx.inputmethod&quot;, &quot;&quot;);</p>
<p>if(!defaultInputMethod.equals(&quot;&quot;)){</p>
<p>String enableMethod = Settings.Secure.getString(getContentResolver(),</p>
<p>Settings.Secure.ENABLED_INPUT_METHODS);</p>
<p>Settings.Secure.putString(getContentResolver(),</p>
<p>Settings.Secure.ENABLED_INPUT_METHODS, enableMethod + &quot;:&quot; + defaultInputMethod);</p>
<p>// + &quot;com.android.inputmethod.pinyin/.PinyinIME&quot;);</p>
<p>}</p>
<p>}</p>
<p>private void setDevelopmentEnable() {</p>
<p>if(SystemProperties.get(&quot;ro.bx.development&quot;, &quot;false&quot;).equals(&quot;true&quot;)) {</p>
<p>Settings.Secure.putInt(getContentResolver(),Settings.Secure.DEVELOPMENT_SETTINGS_ENABLED, 1);</p>
<p>}else{</p>
<p>Settings.Secure.putInt(getContentResolver(),Settings.Secure.DEVELOPMENT_SETTINGS_ENABLED, 0);</p>
<p>}</p>
<p>}</p>
<p>private void setSpellCheckEnable() {</p>
<p> if(SystemProperties.get(&quot;ro.bx.spellcheck&quot;, &quot;false&quot;).equals(&quot;true&quot;)) {</p>
<p>Settings.Secure.putInt(getContentResolver(),Settings.Secure.SPELL_CHECKER_ENABLED, 1);</p>
<p>}else{</p>
<p>Settings.Secure.putInt(getContentResolver(),Settings.Secure.SPELL_CHECKER_ENABLED, 0);</p>
<p>}</p>
<p>}</p>
<p>private void setNetworkLocationEnable() {</p>
<p>    if(SystemProperties.get(&quot;ro.bx.networklocation&quot;, &quot;false&quot;).equals(&quot;true&quot;)) </p>
<p>Settings.Secure.setLocationProviderEnabled(getContentResolver(),</p>
<p>LocationManager.NETWORK_PROVIDER, true);</p>
<p>// Settings.Secure.putInt(getContentResolver(),</p>
<p>// Settings.Secure.ASSISTED_GPS_ENABLED,enable?1:0);</p>
<p>}</p>
<p>private void setVerifyEnable() {</p>
<p>if(SystemProperties.get(&quot;ro.bx.verifyapps&quot;, &quot;false&quot;).equals(&quot;true&quot;)) {</p>
<p>Settings.Global.putInt(getContentResolver(),Settings.Global.PACKAGE_VERIFIER_ENABLE, 1);</p>
<p>}else{</p>
<p>Settings.Global.putInt(getContentResolver(),Settings.Global.PACKAGE_VERIFIER_ENABLE, 0);</p>
<p>}}</p>
<p>private void setUSE_LOCATION_FOR_SERVICES() {</p>
<p>      if(SystemProperties.get(&quot;ro.bx.uselocation&quot;, &quot;false&quot;).equals(&quot;true&quot;))  {</p>
<p>Intent i = new Intent(&quot;com.google.android.gsf.action.SET_USE_LOCATION_FOR_SERVICES&quot;);</p>
<p>i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
<p>i.putExtra(&quot;disable&quot;, false);</p>
<p>try {</p>
<p>startActivity(i);</p>
<p>} catch (Exception e) {</p>
<p>Log.e(&quot;GoogleLocationSettingHelper&quot;,</p>
<p>&quot;Problem while starting GSF location activity&quot;);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>private void showPassWords() // 0 ? 1</p>
<p>{</p>
<p>    if(SystemProperties.get(&quot;ro.bx.password&quot;, &quot;false&quot;).equals(&quot;true&quot;)) { </p>
<p>Settings.System.putInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD, 1);</p>
<p>}else{</p>
<p>Settings.System.putInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD, 0);</p>
<p>}}</p>
<p>private void setShowTouchesEnable() {</p>
<p>if(SystemProperties.get(&quot;ro.bx.showtouches&quot;, &quot;false&quot;).equals(&quot;true&quot;))  </p>
<p>Settings.System.putInt(getContentResolver(),Settings.System.SHOW_TOUCHES, 1);</p>
<p>}</p>
<p>private void set24HFormat() {</p>
<p>if(SystemProperties.get(&quot;ro.bx.time24&quot;, &quot;false&quot;).equals(&quot;true&quot;))  </p>
<p>Settings.System.putString(getContentResolver(),Settings.System.TIME_12_24, &quot;24&quot;);</p>
<p>}</p>
<p>private void setNonMarketAppsAllowed(boolean enabled) {</p>
<p>        // Change the system setting</p>
<p>        Settings.Global.putInt(getContentResolver(), Settings.Global.INSTALL_NON_MARKET_APPS,</p>
<p>                                enabled ? 1 : 0);</p>
<p>}</p>
<p>private void isNeverTimeout(){</p>
<p>if(SystemProperties.get(&quot;ro.bx.ntimeout&quot;, &quot;false&quot;).equals(&quot;true&quot;)){</p>
<p>  Settings.System.putInt(getContentResolver(), Settings.System.SCREEN_OFF_TIMEOUT, Integer.MAX_VALUE);</p>
<p>}</p>
<p>}</p>
<p>private void setEnableADB() {</p>
<p>      if(SystemProperties.get(&quot;ro.bx.adb&quot;, &quot;false&quot;).equals(&quot;true&quot;)){    </p>
<p>        Settings.Global.putInt(getContentResolver(), Settings.Global.ADB_ENABLED,1);</p>
<p>Settings.Global.putInt(getContentResolver(), Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB,1);</p>
<p>}</p>
<p>}</p>
<p>private void startApp() {</p>
<p>// Intent intent2 = new Intent(Intent.ACTION_VIEW);</p>
<p>Intent intent2 = new Intent();</p>
<p>intent2.setClassName(&quot;com.zoodles.kidmode&quot;,</p>
<p>&quot;com.zoodles.kidmode.activity.LauncherActivity&quot;);</p>
<p>intent2.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
<p>// intent2.setDataAndType(null,&quot;image/*&quot;);</p>
<p>startActivity(intent2);</p>
<p>}</p>
<p>// disable dialer app</p>
<p>private static final String packageNameContacts[] = { &quot;com.android.contacts&quot;, };</p>
<p>private static final String packageNameMMS[] = { &quot;com.android.mms&quot; };</p>
<p>private void disable_APP(Context mcontext) {</p>
<p>PackageManager pm = getPackageManager();</p>
<p>/*</p>
<ul>
<li><p>if(SystemProperties.get(&quot;ro.ap_data_only&quot;).equals(&quot;2&quot;)) { //data only</p>
</li>
<li><p>setApplicationEnabled( packageNameContacts,</p>
</li>
<li><p>SystemProperties.getBoolean(&quot;ro.voice.capable&quot;,false) ,pm); }</p>
</li>
</ul>
<p>*/</p>
<p>/*</p>
<ul>
<li><p>setApplicationEnabled( packageNameMMS,</p>
</li>
<li><p>SystemProperties.getBoolean(&quot;ro.sms.capable&quot;,false), pm);</p>
</li>
</ul>
<p>*/</p>
<p>}</p>
<p>private void setApplicationEnabled(String packageName[], boolean enable,</p>
<p>PackageManager pm) {</p>
<p>for (int i = 0, j = packageName.length; i &lt; j; i++) {</p>
<p>if (isPackageInstalled(packageName[i], pm)) {</p>
<p>pm.setApplicationEnabledSetting(</p>
<p>packageName[i],</p>
<p>enable ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED</p>
<p>: PackageManager.COMPONENT_ENABLED_STATE_DISABLED,</p>
<p>PackageManager.DONT_KILL_APP);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>private boolean isPackageInstalled(String packageName, PackageManager pm) {</p>
<p>List&lt;PackageInfo&gt; installedList = pm</p>
<p>.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);</p>
<p>int installedListSize = installedList.size();</p>
<p>for (int i = 0; i &lt; installedListSize; i++) {</p>
<p>PackageInfo tmp = installedList.get(i);</p>
<p>if (packageName.equalsIgnoreCase(tmp.packageName)) {</p>
<p>return true;</p>
<p>}</p>
<p>}</p>
<p>return false;</p>
<p>}</p>
<p>private void updateHardKeyboards() {</p>
<p>String defaultKeyboard = SystemProperties.get(&quot;ro.bx.keyboard&quot;, &quot;&quot;);</p>
<p>if(defaultKeyboard.startsWith(&quot;keyboard_layout&quot;)){</p>
<p>if (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_QWERTY) {</p>
<p>final int[] devices = InputDevice.getDeviceIds();</p>
<p>for (int i = 0; i &lt; devices.length; i++) {</p>
<p>InputDevice device = InputDevice.getDevice(devices[i]);</p>
<p>if (device != null &amp;&amp; !device.isVirtual()</p>
<p>&amp;&amp; device.isFullKeyboard()) {</p>
<p>final String inputDeviceDescriptor = device.getDescriptor();</p>
<p>final String keyboardLayoutDescriptor = mIm</p>
<p>.getCurrentKeyboardLayoutForInputDevice(inputDeviceDescriptor);</p>
<p>final KeyboardLayout keyboardLayout = keyboardLayoutDescriptor != null ? mIm</p>
<p>.getKeyboardLayout(keyboardLayoutDescriptor) : null;</p>
<p>if (keyboardLayout == null) {</p>
<p>String defaultKeyboardLayoutDescriptor = &quot;com.android.inputdevices/com.android.inputdevices.InputDeviceReceiver/&quot;</p>
<ul>
<li>defaultKeyboard;</li>
</ul>
<p>Log.d(&quot;edward&quot;, &quot;systemui defalutKeyboard :=&quot;</p>
<ul>
<li>defaultKeyboardLayoutDescriptor);</li>
</ul>
<p>mIm.addKeyboardLayoutForInputDevice(</p>
<p>inputDeviceDescriptor,</p>
<p>defaultKeyboardLayoutDescriptor);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>rk29_keys</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk29_keys.c/</url>
    <content><![CDATA[<p>/*</p>
<p> * Driver for keys on GPIO lines capable of generating interrupts.</p>
<p> *</p>
<p> * Copyright 2005 Phil Blundell</p>
<p> *</p>
<p> * This program is free software; you can redistribute it and/or modify</p>
<p> * it under the terms of the GNU General Public License version 2 as</p>
<p> * published by the Free Software Foundation.</p>
<p> */</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/init.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/interrupt.h&gt;</p>
<p>#include &lt;linux/irq.h&gt;</p>
<p>#include &lt;linux/sched.h&gt;</p>
<p>#include &lt;linux/pm.h&gt;</p>
<p>#include &lt;linux/sysctl.h&gt;</p>
<p>#include &lt;linux/proc_fs.h&gt;</p>
<p>#include &lt;linux/delay.h&gt;</p>
<p>#include &lt;linux/platform_device.h&gt;</p>
<p>#include &lt;linux/input.h&gt;</p>
<p>#include &lt;linux/adc.h&gt;</p>
<p>#include &lt;asm/gpio.h&gt;</p>
<p>#include &lt;mach/board.h&gt;</p>
<p>#include &lt;plat/key.h&gt;</p>
<p>#define EMPTY_ADVALUE 950</p>
<p>#define DRIFT_ADVALUE 70</p>
<p>#define INVALID_ADVALUE -1</p>
<p>#define EV_MENU KEY_F1</p>
<p>#if 0</p>
<p>#define key_dbg(bdata, format, arg…) \</p>
<p>dev_printk(KERN_INFO , &amp;bdata-&gt;input-&gt;dev , format , ## arg)</p>
<p>#else</p>
<p>#define key_dbg(bdata, format, arg…) </p>
<p>#endif</p>
<p>struct rk29_button_data {</p>
<p>int state;</p>
<p>int long_press_count;</p>
<p>struct rk29_keys_button *button;</p>
<p>struct input_dev *input;</p>
<p>struct timer_list timer;</p>
<p>        struct rk29_keys_drvdata *ddata;</p>
<p>};</p>
<p>struct rk29_keys_drvdata {</p>
<p>int nbuttons;</p>
<p>int result;</p>
<p>bool in_suspend; /* Flag to indicate if we’re suspending/resuming */</p>
<p>struct input_dev *input;</p>
<p>struct adc_client *client;</p>
<p>struct timer_list timer;</p>
<p>struct rk29_button_data data[0];</p>
<p>};</p>
<p>static struct input_dev *input_dev;</p>
<p>struct rk29_keys_Arrary {</p>
<p>char keyArrary[20];</p>
<p>};</p>
<p>static ssize_t rk29key_set(struct device *dev,</p>
<p>struct device_attribute *attr, const char *buf, size_t count)</p>
<p>{</p>
<p>struct rk29_keys_platform_data *pdata = dev_get_platdata(dev);</p>
<p>int i,j,start,end;</p>
<p>char rk29keyArrary[400];</p>
<p>struct rk29_keys_Arrary Arrary[]={</p>
<p>                {</p>
<p>                        .keyArrary = {&quot;menu&quot;},</p>
<p>                },</p>
<p>                {</p>
<p>                        .keyArrary = {&quot;home&quot;},</p>
<p>                },</p>
<p>                {</p>
<p>                        .keyArrary = {&quot;esc&quot;},</p>
<p>                },</p>
<p>                {</p>
<p>                        .keyArrary = {&quot;sensor&quot;},</p>
<p>                },</p>
<p>                {</p>
<p>                        .keyArrary = {&quot;play&quot;},</p>
<p>                },</p>
<p>                {</p>
<p>                        .keyArrary = {&quot;vol+&quot;},</p>
<p>                },</p>
<p>                {</p>
<p>                        .keyArrary = {&quot;vol-&quot;},</p>
<p>                },</p>
<p>        }; </p>
<p>char *p;</p>
<p>for(i=0;i&lt;7;i++)</p>
<p>{</p>
<p>p = strstr(buf,Arrary[i].keyArrary);</p>
<p>if(p==0)</p>
<p>              {</p>
<p>                   dev_dbg(dev,&quot; rk29key_set p == 0 error ……………\n&quot;);</p>
<p>                   continue;</p>
<p>              }</p>
<p>start = strcspn(p,&quot;:&quot;);</p>
<p>if(i&lt;6)</p>
<p>end = strcspn(p,&quot;,&quot;);</p>
<p>else</p>
<p>end = strcspn(p,&quot;}&quot;);</p>
<p>memset(rk29keyArrary,0,sizeof(rk29keyArrary));</p>
<p>strncpy(rk29keyArrary,p+start+1,end-start-1);</p>
<p>for(j=0;j&lt;7;j++)</p>
<p>{ </p>
<p>if(strcmp(pdata-&gt;buttons[j].desc,Arrary[i].keyArrary)==0)</p>
<p>{</p>
<p>if(strcmp(rk29keyArrary,&quot;MENU&quot;)==0)</p>
<p>pdata-&gt;buttons[j].code = EV_MENU;</p>
<p>else if(strcmp(rk29keyArrary,&quot;HOME&quot;)==0)</p>
<p>pdata-&gt;buttons[j].code = KEY_HOME;</p>
<p>else if(strcmp(rk29keyArrary,&quot;ESC&quot;)==0)</p>
<p>pdata-&gt;buttons[j].code = KEY_BACK;</p>
<p>else if(strcmp(rk29keyArrary,&quot;sensor&quot;)==0)</p>
<p>pdata-&gt;buttons[j].code = KEY_CAMERA;</p>
<p>else if(strcmp(rk29keyArrary,&quot;PLAY&quot;)==0)</p>
<p>pdata-&gt;buttons[j].code = KEY_POWER;</p>
<p>else if(strcmp(rk29keyArrary,&quot;VOLUP&quot;)==0)</p>
<p>pdata-&gt;buttons[j].code = KEY_VOLUMEUP;</p>
<p>else if(strcmp(rk29keyArrary,&quot;VOLDOWN&quot;)==0)</p>
<p>pdata-&gt;buttons[j].code = KEY_VOLUMEDOWN;</p>
<p>else</p>
<p>    continue;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for(i=0;i&lt;7;i++)</p>
<p>dev_dbg(dev, &quot;desc=%s, code=%d\n&quot;,pdata-&gt;buttons[i].desc,pdata-&gt;buttons[i].code);</p>
<p>return 0; </p>
<p>}</p>
<p>static DEVICE_ATTR(rk29key,0660, NULL, rk29key_set);</p>
<p>void rk29_send_power_key(int state)</p>
<p>{</p>
<p>if (!input_dev)</p>
<p>return;</p>
<p>if(state)</p>
<p>{</p>
<p>input_report_key(input_dev, KEY_POWER, 1);</p>
<p>input_sync(input_dev);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>input_report_key(input_dev, KEY_POWER, 0);</p>
<p>input_sync(input_dev);</p>
<p>}</p>
<p>}</p>
<p>void rk28_send_wakeup_key(void)</p>
<p>{</p>
<p>if (!input_dev)</p>
<p>return;</p>
<p>input_report_key(input_dev, KEY_WAKEUP, 1);</p>
<p>input_sync(input_dev);</p>
<p>input_report_key(input_dev, KEY_WAKEUP, 0);</p>
<p>input_sync(input_dev);</p>
<p>}</p>
<p>static void keys_long_press_timer(unsigned long _data)</p>
<p>{</p>
<p>int state;</p>
<p>struct rk29_button_data *bdata = (struct rk29_button_data *)_data;</p>
<p>struct rk29_keys_button *button = bdata-&gt;button;</p>
<p>struct input_dev *input = bdata-&gt;input;</p>
<p>unsigned int type = EV_KEY;</p>
<p>if(button-&gt;gpio != INVALID_GPIO )</p>
<p>state = !!((gpio_get_value(button-&gt;gpio) ? 1 : 0) ^ button-&gt;active_low);</p>
<p>else</p>
<p>state = !!button-&gt;adc_state;</p>
<p>if(state) {</p>
<p>if(bdata-&gt;long_press_count != 0) {</p>
<p>/* if(bdata-&gt;long_press_count % (LONG_PRESS_COUNT+ONE_SEC_COUNT) == 0){</p>
<p>key_dbg(bdata, &quot;%skey[%s]: report ev[%d] state[0]\n&quot;, </p>
<p>(button-&gt;gpio == INVALID_GPIO)?&quot;ad&quot;:&quot;io&quot;, button-&gt;desc, button-&gt;code_long_press);</p>
<p>input_event(input, type, button-&gt;code_long_press, 0);</p>
<p>input_sync(input);</p>
<p>}</p>
<p>else*/ if(bdata-&gt;long_press_count%LONG_PRESS_COUNT == 0) {</p>
<p>key_dbg(bdata, &quot;%skey[%s]: report ev[%d] state[1]\n&quot;, </p>
<p>(button-&gt;gpio == INVALID_GPIO)?&quot;ad&quot;:&quot;io&quot;, button-&gt;desc, button-&gt;code_long_press);</p>
<p>input_event(input, type, button-&gt;code_long_press, 1);</p>
<p>input_sync(input);</p>
<p>}</p>
<p>}</p>
<p>bdata-&gt;long_press_count++;</p>
<p>mod_timer(&amp;bdata-&gt;timer,</p>
<p>jiffies + msecs_to_jiffies(DEFAULT_DEBOUNCE_INTERVAL));</p>
<p>}</p>
<p>else {</p>
<p>if(bdata-&gt;long_press_count &lt;= LONG_PRESS_COUNT) {</p>
<p>bdata-&gt;long_press_count = 0;</p>
<p>key_dbg(bdata, &quot;%skey[%s]: report ev[%d] state[1], report ev[%d] state[0]\n&quot;, </p>
<p>(button-&gt;gpio == INVALID_GPIO)?&quot;ad&quot;:&quot;io&quot;, button-&gt;desc, button-&gt;code, button-&gt;code);</p>
<p>input_event(input, type, button-&gt;code, 1);</p>
<p>input_sync(input);</p>
<p>input_event(input, type, button-&gt;code, 0);</p>
<p>input_sync(input);</p>
<p>}</p>
<p>else if(bdata-&gt;state != state) {</p>
<p>key_dbg(bdata, &quot;%skey[%s]: report ev[%d] state[0]\n&quot;, </p>
<p>(button-&gt;gpio == INVALID_GPIO)?&quot;ad&quot;:&quot;io&quot;, button-&gt;desc, button-&gt;code_long_press);</p>
<p>input_event(input, type, button-&gt;code_long_press, 0);</p>
<p>input_sync(input);</p>
<p>bdata-&gt;long_press_count = 0;</p>
<p>}</p>
<p>}</p>
<p>bdata-&gt;state = state;</p>
<p>}</p>
<p>static void keys_timer(unsigned long _data)</p>
<p>{</p>
<p>int state;</p>
<p>struct rk29_button_data *bdata = (struct rk29_button_data *)_data;</p>
<p>struct rk29_keys_button *button = bdata-&gt;button;</p>
<p>struct input_dev *input = bdata-&gt;input;</p>
<p>unsigned int type = EV_KEY;</p>
<p>if(button-&gt;gpio != INVALID_GPIO)</p>
<p>state = !!((gpio_get_value(button-&gt;gpio) ? 1 : 0) ^ button-&gt;active_low);</p>
<p>else</p>
<p>state = !!button-&gt;adc_state;</p>
<p>if(bdata-&gt;state != state) {</p>
<p>bdata-&gt;state = state;</p>
<p>key_dbg(bdata, &quot;%skey[%s]: report ev[%d] state[%d]\n&quot;, </p>
<p>(button-&gt;gpio == INVALID_GPIO)?&quot;ad&quot;:&quot;io&quot;, button-&gt;desc, button-&gt;code, bdata-&gt;state);</p>
<p>input_event(input, type, button-&gt;code, bdata-&gt;state);</p>
<p>input_sync(input);</p>
<p>}</p>
<p>if(state)</p>
<p>mod_timer(&amp;bdata-&gt;timer,</p>
<p>jiffies + msecs_to_jiffies(DEFAULT_DEBOUNCE_INTERVAL));</p>
<p>}</p>
<p>static irqreturn_t keys_isr(int irq, void *dev_id)</p>
<p>{</p>
<p>struct rk29_button_data *bdata = dev_id;</p>
<p>struct rk29_keys_button *button = bdata-&gt;button;</p>
<p>struct input_dev *input = bdata-&gt;input;</p>
<p>unsigned int type = EV_KEY;</p>
<p>BUG_ON(irq != gpio_to_irq(button-&gt;gpio));</p>
<p>        if(button-&gt;wakeup == 1 &amp;&amp; bdata-&gt;ddata-&gt;in_suspend == true){</p>
<p>bdata-&gt;state = 1;</p>
<p>key_dbg(bdata, &quot;wakeup: %skey[%s]: report ev[%d] state[%d]\n&quot;, </p>
<p>(button-&gt;gpio == INVALID_GPIO)?&quot;ad&quot;:&quot;io&quot;, button-&gt;desc, button-&gt;code, bdata-&gt;state);</p>
<p>input_event(input, type, button-&gt;code, bdata-&gt;state);</p>
<p>input_sync(input);</p>
<p>        }</p>
<p>bdata-&gt;long_press_count = 0;</p>
<p>mod_timer(&amp;bdata-&gt;timer,</p>
<p>jiffies + msecs_to_jiffies(DEFAULT_DEBOUNCE_INTERVAL));</p>
<p>return IRQ_HANDLED;</p>
<p>}</p>
<p>static void keys_adc_callback(struct adc_client *client, void *client_param, int result)</p>
<p>{</p>
<p>struct rk29_keys_drvdata *ddata = (struct rk29_keys_drvdata *)client_param;</p>
<p>int i;</p>
<p>if(result &gt; INVALID_ADVALUE &amp;&amp; result &lt; EMPTY_ADVALUE)</p>
<p>ddata-&gt;result = result;</p>
<p>for (i = 0; i &lt; ddata-&gt;nbuttons; i++) {</p>
<p>struct rk29_button_data *bdata = &amp;ddata-&gt;data[i];</p>
<p>struct rk29_keys_button *button = bdata-&gt;button;</p>
<p>if(!button-&gt;adc_value)</p>
<p>continue;</p>
<p>if(result &lt; button-&gt;adc_value + DRIFT_ADVALUE &amp;&amp;</p>
<p>result &gt; button-&gt;adc_value - DRIFT_ADVALUE)</p>
<p>button-&gt;adc_state = 1;</p>
<p>else</p>
<p>button-&gt;adc_state = 0;</p>
<p>if(bdata-&gt;state != button-&gt;adc_state)</p>
<p>mod_timer(&amp;bdata-&gt;timer,</p>
<p>jiffies + msecs_to_jiffies(DEFAULT_DEBOUNCE_INTERVAL));</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>static void keys_adc_timer(unsigned long _data)</p>
<p>{</p>
<p>struct rk29_keys_drvdata *ddata = (struct rk29_keys_drvdata *)_data;</p>
<p>if (!ddata-&gt;in_suspend)</p>
<p>adc_async_read(ddata-&gt;client);</p>
<p>mod_timer(&amp;ddata-&gt;timer, jiffies + msecs_to_jiffies(ADC_SAMPLE_TIME));</p>
<p>}</p>
<p>static ssize_t adc_value_show(struct device *dev, struct device_attribute *attr, char *buf)</p>
<p>{</p>
<p>struct rk29_keys_drvdata *ddata = dev_get_drvdata(dev);</p>
<p>return sprintf(buf, &quot;adc_value: %d\n&quot;, ddata-&gt;result);</p>
<p>}</p>
<p>static DEVICE_ATTR(get_adc_value, S_IRUGO | S_IWUSR, adc_value_show, NULL);</p>
<p>static int __devinit keys_probe(struct platform_device *pdev)</p>
<p>{</p>
<p>struct device *dev = &amp;pdev-&gt;dev;</p>
<p>struct rk29_keys_platform_data *pdata = dev_get_platdata(dev);</p>
<p>struct rk29_keys_drvdata *ddata;</p>
<p>struct input_dev *input;</p>
<p>int i, error = 0;</p>
<p>int wakeup = 0;</p>
<p>if(!pdata) </p>
<p>return -EINVAL;</p>
<p>ddata = kzalloc(sizeof(struct rk29_keys_drvdata) +</p>
<p>pdata-&gt;nbuttons * sizeof(struct rk29_button_data),</p>
<p>GFP_KERNEL);</p>
<p>input = input_allocate_device();</p>
<p>if (!ddata || !input) {</p>
<p>error = -ENOMEM;</p>
<p>goto fail0;</p>
<p>}</p>
<p>platform_set_drvdata(pdev, ddata);</p>
<p>input-&gt;name = pdev-&gt;name;</p>
<p>input-&gt;phys = &quot;gpio-keys/input0&quot;;</p>
<p>input-&gt;dev.parent = dev;</p>
<p>input-&gt;id.bustype = BUS_HOST;</p>
<p>input-&gt;id.vendor = 0x0001;</p>
<p>input-&gt;id.product = 0x0001;</p>
<p>input-&gt;id.version = 0x0100;</p>
<p>/* Enable auto repeat feature of Linux input subsystem */</p>
<p>if (pdata-&gt;rep)</p>
<p>__set_bit(EV_REP, input-&gt;evbit);</p>
<p>ddata-&gt;nbuttons = pdata-&gt;nbuttons;</p>
<p>ddata-&gt;input = input;</p>
<p>for (i = 0; i &lt; pdata-&gt;nbuttons; i++) {</p>
<p>struct rk29_keys_button *button = &amp;pdata-&gt;buttons[i];</p>
<p>struct rk29_button_data *bdata = &amp;ddata-&gt;data[i];</p>
<p>bdata-&gt;input = input;</p>
<p>bdata-&gt;button = button;</p>
<p>                bdata-&gt;ddata = ddata;</p>
<p>if (button-&gt;code_long_press)</p>
<p>setup_timer(&amp;bdata-&gt;timer,</p>
<p>keys_long_press_timer, (unsigned long)bdata);</p>
<p>else if (button-&gt;code)</p>
<p>setup_timer(&amp;bdata-&gt;timer,</p>
<p>keys_timer, (unsigned long)bdata);</p>
<p>if (button-&gt;wakeup)</p>
<p>wakeup = 1;</p>
<p>input_set_capability(input, EV_KEY, button-&gt;code);</p>
<p>if(button-&gt;code_long_press)</p>
<p>               input_set_capability(input, EV_KEY, button-&gt;code_long_press);</p>
<p>};</p>
<p>if (pdata-&gt;chn &gt;= 0) {</p>
<p>setup_timer(&amp;ddata-&gt;timer, keys_adc_timer, (unsigned long)ddata);</p>
<p>ddata-&gt;client = adc_register(pdata-&gt;chn, keys_adc_callback, (void *)ddata);</p>
<p>if (!ddata-&gt;client) {</p>
<p>error = -EINVAL;</p>
<p>goto fail1;</p>
<p>}</p>
<p>mod_timer(&amp;ddata-&gt;timer, jiffies + msecs_to_jiffies(100));</p>
<p>}</p>
<p>for (i = 0; i &lt; pdata-&gt;nbuttons; i++) {</p>
<p>struct rk29_keys_button *button = &amp;pdata-&gt;buttons[i];</p>
<p>struct rk29_button_data *bdata = &amp;ddata-&gt;data[i];</p>
<p>int irq;</p>
<p>if(button-&gt;gpio != INVALID_GPIO) {</p>
<p>error = gpio_request(button-&gt;gpio, button-&gt;desc ?: &quot;keys&quot;);</p>
<p>if (error &lt; 0) {</p>
<p>pr_err(&quot;gpio-keys: failed to request GPIO %d,&quot;</p>
<p>&quot; error %d\n&quot;, button-&gt;gpio, error);</p>
<p>goto fail2;</p>
<p>}</p>
<p>error = gpio_direction_input(button-&gt;gpio);</p>
<p>if (error &lt; 0) {</p>
<p>pr_err(&quot;gpio-keys: failed to configure input&quot;</p>
<p>&quot; direction for GPIO %d, error %d\n&quot;,</p>
<p>button-&gt;gpio, error);</p>
<p>gpio_free(button-&gt;gpio);</p>
<p>goto fail2;</p>
<p>}</p>
<p>irq = gpio_to_irq(button-&gt;gpio);</p>
<p>if (irq &lt; 0) {</p>
<p>error = irq;</p>
<p>pr_err(&quot;gpio-keys: Unable to get irq number&quot;</p>
<p>&quot; for GPIO %d, error %d\n&quot;,</p>
<p>button-&gt;gpio, error);</p>
<p>gpio_free(button-&gt;gpio);</p>
<p>goto fail2;</p>
<p>}</p>
<p>error = request_irq(irq, keys_isr,</p>
<p>   (button-&gt;active_low)?IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING,</p>
<p>   button-&gt;desc ? button-&gt;desc : &quot;keys&quot;,</p>
<p>   bdata);</p>
<p>if (error) {</p>
<p>pr_err(&quot;gpio-keys: Unable to claim irq %d; error %d\n&quot;,</p>
<p>irq, error);</p>
<p>gpio_free(button-&gt;gpio);</p>
<p>goto fail2;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>input_set_capability(input, EV_KEY, KEY_WAKEUP);</p>
<p>error = input_register_device(input);</p>
<p>if (error) {</p>
<p>pr_err(&quot;gpio-keys: Unable to register input device, &quot;</p>
<p>&quot;error: %d\n&quot;, error);</p>
<p>goto fail2;</p>
<p>}</p>
<p>device_init_wakeup(dev, wakeup);</p>
<p>error = device_create_file(dev, &amp;dev_attr_get_adc_value);</p>
<p>error = device_create_file(dev, &amp;dev_attr_rk29key);</p>
<p>if(error )</p>
<p>{</p>
<p>pr_err(&quot;failed to create key file error: %d\n&quot;, error);</p>
<p>}</p>
<p>input_dev = input;</p>
<p>return error;</p>
<p> fail2:</p>
<p>while (–i &gt;= 0) {</p>
<p>free_irq(gpio_to_irq(pdata-&gt;buttons[i].gpio), &amp;ddata-&gt;data[i]);</p>
<p>del_timer_sync(&amp;ddata-&gt;data[i].timer);</p>
<p>gpio_free(pdata-&gt;buttons[i].gpio);</p>
<p>}</p>
<p>if(pdata-&gt;chn &gt;= 0 &amp;&amp; ddata-&gt;client);</p>
<p>adc_unregister(ddata-&gt;client);</p>
<p>if(pdata-&gt;chn &gt;= 0)</p>
<p>       del_timer_sync(&amp;ddata-&gt;timer);</p>
<p> fail1:</p>
<p>platform_set_drvdata(pdev, NULL);</p>
<p> fail0:</p>
<p>input_free_device(input);</p>
<p>kfree(ddata);</p>
<p>return error;</p>
<p>}</p>
<p>static int __devexit keys_remove(struct platform_device *pdev)</p>
<p>{</p>
<p>struct device *dev = &amp;pdev-&gt;dev;</p>
<p>struct rk29_keys_platform_data *pdata = dev_get_platdata(dev);</p>
<p>struct rk29_keys_drvdata *ddata = dev_get_drvdata(dev);</p>
<p>struct input_dev *input = ddata-&gt;input;</p>
<p>int i;</p>
<p>input_dev = NULL;</p>
<p>device_init_wakeup(dev, 0);</p>
<p>for (i = 0; i &lt; pdata-&gt;nbuttons; i++) {</p>
<p>int irq = gpio_to_irq(pdata-&gt;buttons[i].gpio);</p>
<p>free_irq(irq, &amp;ddata-&gt;data[i]);</p>
<p>del_timer_sync(&amp;ddata-&gt;data[i].timer);</p>
<p>gpio_free(pdata-&gt;buttons[i].gpio);</p>
<p>}</p>
<p>if(pdata-&gt;chn &gt;= 0 &amp;&amp; ddata-&gt;client);</p>
<p>adc_unregister(ddata-&gt;client);</p>
<p>input_unregister_device(input);</p>
<p>return 0;</p>
<p>}</p>
<p>#ifdef CONFIG_PM</p>
<p>static int keys_suspend(struct device *dev)</p>
<p>{</p>
<p>struct rk29_keys_platform_data *pdata = dev_get_platdata(dev);</p>
<p>struct rk29_keys_drvdata *ddata = dev_get_drvdata(dev);</p>
<p>int i;</p>
<p>ddata-&gt;in_suspend = true;</p>
<p>if (device_may_wakeup(dev)) {</p>
<p>for (i = 0; i &lt; pdata-&gt;nbuttons; i++) {</p>
<p>struct rk29_keys_button *button = &amp;pdata-&gt;buttons[i];</p>
<p>if (button-&gt;wakeup) {</p>
<p>int irq = gpio_to_irq(button-&gt;gpio);</p>
<p>enable_irq_wake(irq);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>static int keys_resume(struct device *dev)</p>
<p>{</p>
<p>struct rk29_keys_platform_data *pdata = dev_get_platdata(dev);</p>
<p>struct rk29_keys_drvdata *ddata = dev_get_drvdata(dev);</p>
<p>int i;</p>
<p>if (device_may_wakeup(dev)) {</p>
<p>for (i = 0; i &lt; pdata-&gt;nbuttons; i++) {</p>
<p>struct rk29_keys_button *button = &amp;pdata-&gt;buttons[i];</p>
<p>if (button-&gt;wakeup) {</p>
<p>int irq = gpio_to_irq(button-&gt;gpio);</p>
<p>disable_irq_wake(irq);</p>
<p>}</p>
<p>}</p>
<p>preempt_disable();</p>
<p>if (local_softirq_pending())</p>
<p>do_softirq(); // for call resend_irqs, which may call keys_isr</p>
<p>preempt_enable_no_resched();</p>
<p>}</p>
<p>ddata-&gt;in_suspend = false;</p>
<p>return 0;</p>
<p>}</p>
<p>static const struct dev_pm_ops keys_pm_ops = {</p>
<p>.suspend = keys_suspend,</p>
<p>.resume = keys_resume,</p>
<p>};</p>
<p>#endif</p>
<p>static struct platform_driver keys_device_driver = {</p>
<p>.probe = keys_probe,</p>
<p>.remove = __devexit_p(keys_remove),</p>
<p>.driver = {</p>
<p>.name = &quot;rk29-keypad&quot;,</p>
<p>.owner = THIS_MODULE,</p>
<p>#ifdef CONFIG_PM</p>
<p>.pm = &amp;keys_pm_ops,</p>
<p>#endif</p>
<p>}</p>
<p>};</p>
<p>static int __init keys_init(void)</p>
<p>{</p>
<p>return platform_driver_register(&amp;keys_device_driver);</p>
<p>}</p>
<p>static void __exit keys_exit(void)</p>
<p>{</p>
<p>platform_driver_unregister(&amp;keys_device_driver);</p>
<p>}</p>
<p>module_init(keys_init);</p>
<p>module_exit(keys_exit);</p>
<p>MODULE_LICENSE(&quot;GPL&quot;);</p>
<p>MODULE_AUTHOR(&quot;Phil Blundell &lt;<a href="mailto:&#x70;&#98;&#64;&#104;&#97;&#110;&#x64;&#104;&#x65;&#x6c;&#x64;&#x73;&#x2e;&#111;&#114;&#x67;">&#x70;&#98;&#64;&#104;&#97;&#110;&#x64;&#104;&#x65;&#x6c;&#x64;&#x73;&#x2e;&#111;&#114;&#x67;</a>&gt;&quot;);</p>
<p>MODULE_DESCRIPTION(&quot;Keyboard driver for CPU GPIOs&quot;);</p>
<p>MODULE_ALIAS(&quot;platform:gpio-keys&quot;);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>ubBootupWithCharger = 46 uiGet</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/ubBootupWithCharger%20=%2046%20uiGet/</url>
    <content><![CDATA[<p>ubBootupWithCharger = 46 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 45 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 44 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 43 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 42 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 41 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 40 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 39 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 38 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 37 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 36 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 35 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 34 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 33 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 32 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 31 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 30 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 29 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 28 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 27 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 26 uiGetCurrentState = 1</p>
<p>AHC_GetAhcSysMode 98</p>
<p>!!! Speaker turn-off by SpeakerPowerDetection</p>
<p>ubBootupWithCharger = 25 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 24 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 23 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 22 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 21 uiGetCurrentState = 1</p>
<p>Dongle Host Driver, version 5.90.195.89</p>
<p>Release version 3.12</p>
<p>F1 signature read @0x18000000=0x1591a962</p>
<p>DHD: dongle ram size is set to 245760(orig 245760)</p>
<p>ubBootupWithCharger = 20 uiGetCurrentState = 1</p>
<p>dhdsdio_download_code_array: Download, Upload and compare succeeded (43362a2-roml/sdio-g-pool-idsup-idauth-apsta, 5.90.195.89.37, 2015/01/23 10:49:49).</p>
<p>dhdsdio_write_vars: Download, Upload and compare of NVRAM succeeded.</p>
<p>ubBootupWithCharger = 19 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 18 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 17 uiGetCurrentState = 1</p>
<p>AHC_WMSG_Draw WMSG_INFO:0</p>
<p>ubBootupWithCharger = 16 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 15 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 14 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 13 uiGetCurrentState = 1</p>
<p>dhd_wlfc_init(): successfully disabled bdcv2 tlv signaling, 0</p>
<p>Dongles MAC address = 6C:21:A2:03:92:01</p>
<p>ubBootupWithCharger = 12 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 11 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 10 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 9 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 8 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 7 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 6 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 5 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 4 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 3 uiGetCurrentState = 1</p>
<p>szParam :  lrl 15 </p>
<p>buf[ 0 ] : wl </p>
<p>buf[ 1 ] : lrl </p>
<p>buf[ 2 ] : 15 </p>
<p>szParam :  srl 15 </p>
<p>buf[ 0 ] : wl </p>
<p>buf[ 1 ] : srl </p>
<p>buf[ 2 ] : 15 </p>
<p>TCP/IP initialized.</p>
<p>##INFO## aitstreamer_init:574 AIT Multimedia Network Streaming Server</p>
<p>===================================== Sep 06 2018 19:45:02 =====================</p>
<p>##INFO## basic_meter_init:651 EVMSG Latency: period=480 -&gt; 512 shift=9</p>
<p>thread_select_loop 41</p>
<p>thread_message_handler 42</p>
<p>NETCFG:: init DEV.1 Type=STA Start=1 </p>
<p>WLAN CB : 3 : NO Mapping</p>
<p>dhd_task: Exiting task!!</p>
<p>ubBootupWithCharger = 2 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 1 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 0 uiGetCurrentState = 1</p>
<p>VideoPowerOffCounterReset 5</p>
<p>@@@ EVENT_VIDEO_KEY_RECORD -</p>
<p>AHC_WMSG_Draw WMSG_INFO:3</p>
<p>–E– Memory Card Error</p>
<p>Dongle Host Driver, version 5.90.195.89</p>
<p>Release version 3.12</p>
<p>F1 signature read @0x18000000=0x1591a962</p>
<p>DHD: dongle ram size is set to 245760(orig 245760)</p>
<p>dhdsdio_download_code_array: Download, Upload and compare succeeded (43362a2-roml/sdio-g-pool-idsup-idauth-apsta, 5.90.195.89.37, 2015/01/23 10:49:49).</p>
<p>dhdsdio_write_vars: Download, Upload and compare of NVRAM succeeded.</p>
<p>AHC_WMSG_Draw WMSG_INFO:0</p>
<p>dhd_wlfc_init(): successfully disabled bdcv2 tlv signaling, 0</p>
<p>Dongles MAC address = 6C:21:A2:03:92:01</p>
<p>WLAN CB : 2 : NO Mapping</p>
<p>szParam :  lrl 15 </p>
<p>buf[ 0 ] : wl </p>
<p>buf[ 1 ] : lrl </p>
<p>buf[ 2 ] : 15 </p>
<p>szParam :  srl 15 </p>
<p>buf[ 0 ] : wl </p>
<p>buf[ 1 ] : srl </p>
<p>buf[ 2 ] : 15 </p>
<p>wl_event_callback: event = 26</p>
<p>wl_event_callback: WLC_E_SCAN_COMPLETE</p>
<p>WLAN CB : 26 : Scan Done </p>
<p>LwIP_join_WLAN_auto: AP count = 15</p>
<p>Scanned AP: SSID=HZA50(3db858) CH=1 RSSI=-88dBm BSSID=a0:9d:c1:f7:5e:fa Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=LQ-15D974 CH=1 RSSI=-47dBm BSSID=28:ed:e0:f9:e0:94 Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=HAIZHEN_2.4G CH=1 RSSI=-72dBm BSSID=00:74:9c:eb:25:e0 Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=HZA60-15DF45 CH=1 RSSI=-98dBm BSSID=28:ed:e0:ff:f7:4e Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=HZA50(52eeb2) CH=1 RSSI=-89dBm BSSID=20:32:33:bb:35:7d Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=CIOT_7698482 CH=6 RSSI=-63dBm BSSID=40:45:da:05:6b:bb Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=CIOT_5598502 CH=6 RSSI=-64dBm BSSID=40:45:da:54:d7:ed Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=ChinaNet-e7Dj CH=6 RSSI=-62dBm BSSID=c8:50:e9:ea:86:18 Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=CIOT_5598544 CH=6 RSSI=-2dBm BSSID=40:45:da:1d:6c:5e Mode=Managed Sec=Encrypted</p>
<p>Joining to AP:CIOT_5598544 CRYPTO 1     … failed</p>
<p>Scanned AP: SSID=HZ-Genius_S.S.H.A CH=7 RSSI=-62dBm BSSID=02:93:57:fb:7f:0a Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=HZA50(743270) CH=6 RSSI=-87dBm BSSID=94:e0:d6:5c:15:5b Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=ChinaNet-9EHh CH=9 RSSI=-66dBm BSSID=54:66:6c:b4:55:20 Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=HAIZHEN_2.4G CH=11 RSSI=-49dBm BSSID=00:74:9c:eb:25:41 Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=HZA50(9876b2) CH=11 RSSI=-84dBm BSSID=0c:8c:24:52:70:42 Mode=Managed Sec=Encrypted</p>
<p>Scanned AP: SSID=ChinaNet-skxL CH=13 RSSI=-73dBm BSSID=40:f4:20:e3:d6:c2 Mode=Managed Sec=Encrypted</p>
<p>LwIP_join_WLAN_auto: failed to join to any AP </p>
<p>==== START DEVICE IP 172.0.0.1:49152 ====</p>
<p>Initializing UPnP Sdk with</p>
<p>        ipaddress = 172.0.0.1 port = 49152</p>
<p>UUID 0x1b40f178 0x1dd2, 0x11b2, 0xa3, 0xc3, 0x84, 0xac, 0x44, 0x01, 0xc0, 0x00</p>
<p>========= CREATE MiniServer Thread Pool ========</p>
<p>**pthread_create 97 Priority 43</p>
<p>CreateWorker 674 EXIT 0: tp 0x017ca9d0</p>
<p>START StartMiniServer 874</p>
<p>StartMiniServer 898: GET MINISERVER SOCKET 1</p>
<p>StartMiniServer 906: GET STOPSOCK SOCKET 2</p>
<p>##UPNP## \ssdp_server.c:861 Error in setsockopt() IP_ADD_MEMBERSHIP (join multicast group): ERR: 99</p>
<p>TiStartMiniServer 916: GET SSDPSOCK SOCKET 3</p>
<p>niServer 916ERROR StartMiniServer 922</p>
<p>##UPNP## \upnpapi.c:435 Miniserver failed to starter 922</p>
<p>ThreadPoolShutdown 1058 tp 0x017ca9d0, start_and_shutdown wait 113 threads 1</p>
<p>======= Upnp SDK Init Done UpnpSdkInit:0 retVal:-208 ========</p>
<p>Error with UpnpInit – -208</p>
<p>##VERBOSE## init_web_virt_handlers:670 upnp_init: UpnpSetWebServerRootDir for Directory SF:0:\www</p>
<p>##VERBOSE## netserver_new:364 RTSP Server PORT: 554</p>
<p>##VERBOSE## tcp_listen:329 Net Service RTSP: listen on port 554, fd=1</p>
<p>##INFO## basic_meter_init:651 H264 Latency: period=128 -&gt; 128 shift=7</p>
<p>##INFO## basic_meter_init:651 H264 Queue: period=128 -&gt; 128 shift=7</p>
<p>##INFO## basic_meter_init:651 MJPEG Latency: period=512 -&gt; 512 shift=9</p>
<p>##INFO## basic_meter_init:651 MJPEG Queue: period=512 -&gt; 512 shift=9</p>
<p>##VERBOSE## netserver_new:364 HTTP-WEB Server PORT: 80</p>
<p>##VERBOSE## tcp_listen:329 Net Service HTTP-WEB: listen on port 80, fd=2</p>
<p>##VERBOSE## pipeline_new:381 pipeline.name=Stream264 node.name=VIDEO.0/EncH264 fmt=201</p>
<p>open dev : VIDEO.0, ID=1 </p>
<p>INIT_VIDEO_MODULE::VideoBuf 162c4a0 60000  aitQue=015908e8 vDev=0</p>
<p>##VERBOSE## pipeline_new:381 pipeline.name=StreamJPG node.name=VIDEO.0/EncMJPEG fmt=202</p>
<p>open device: ‘VIDEO.0’ already opened </p>
<p>##VERBOSE## pipeline_new:381 pipeline.name=StreamAAC node.name=AUDIO.0 fmt=203</p>
<p>open dev : AUDIO.0, ID=2 </p>
<p>INIT_AUDIO_MODULE::AudioBuf 168e760 c000  aitQue=01590eb4</p>
<p>##VERBOSE## pipeline_new:381 pipeline.name=StreamPCM node.name=AUDIO.0 fmt=64</p>
<p>open device: ‘AUDIO.0’ already opened </p>
<p>##INFO## graph_set_attr:816 RTSP:/liveRTSP/v1 in.V:Stream264 in.A:none</p>
<p>##INFO## graph_set_attr:816 RTSP:/liveRTSP/v2 in.V:StreamJPG in.A:none</p>
<p>##INFO## graph_set_attr:816 RTSP:/liveRTSP/v3 in.V:Stream264 in.A:none</p>
<p>##INFO## graph_set_attr:816 RTSP:/liveRTSP/av1 in.V:StreamJPG in.A:StreamAAC</p>
<p>##INFO## graph_set_attr:816 RTSP:/liveRTSP/av2 in.V:Stream264 in.A:StreamAAC</p>
<p>##INFO## graph_set_attr:816 RTSP:/txRTSP/av in.V:StreamJPG in.A:StreamAAC</p>
<p>live streaming 32000</p>
<p>##INFO## graph_set_attr:816 RTSP:/txRTSP/av3 in.V:StreamJPG in.A:StreamPCM</p>
<p>##INFO## graph_set_attr:816 RTSP:/liveRTSP/av3 in.V:StreamJPG in.A:StreamPCM</p>
<p>##INFO## graph_set_attr:816 RTSP:/liveRTSP/av4 in.V:Stream264 in.A:StreamPCM</p>
<p>##WARN## parse_ASS_Nodes:140 GRAPH: no node definition for CSnkNode, type=LivecastTUTK</p>
<p>##WARN## parse_ASS_Nodes:140 GRAPH: no node definition for CSnkNode, type=LivecastTUTK</p>
<p>##VERBOSE## aitstreamer_start:546 Config Graph parsing done …</p>
<p>##VERBOSE## aitstreamer_start:551 AIT Streaming Server … init done …</p>
<p>[[ x3 ]] &gt;&gt;&gt;&gt; live streaming 32000</p>
<p>wl_event_callback: event = 3</p>
<p>WLAN CB : 3 : NO Mapping</p>
<p>wl_event_callback: event = 16</p>
<p>wl_event_callback: WLC_E_LINK, link is up</p>
<p>WLAN CB : 16 : </p>
<p>wl_event_callback: event = 46</p>
<p>WLAN CB : 46 : Station Mode CONNECTED </p>
<p>WIRELESS_CONNECT_SUCCESS</p>
<p>tcp_send, errorCount=1</p>
<p>try tcp init 1</p>
<p>tcp_client_init</p>
<p>wl_event_callback: event = 1</p>
<p>WLAN CB : 1 : NO Mapping</p>
<p>wl_event_callback: event = 0</p>
<p>wl_event_callback: WLC_E_SET_SSID successful</p>
<p>WLAN CB : 0 : NO Mapping</p>
<p>tcp_slowtmr: rtime   10 pcb-&gt;rto   10</p>
<p><strong>**</strong> REXMIT *****</p>
<p>tcp_slowtmr: rtime   10 pcb-&gt;rto   10</p>
<p>tcp_slowtmr: rtime   10 pcb-&gt;rto   10</p>
<p>[[ x3 ]] &gt;&gt;&gt;&gt; <strong>**</strong> REXMIT *****</p>
<p>Unable to connect to iperf server: ip = 192.168.43.1, port = 6666</p>
<p>DHCP 3 sec : </p>
<p>main_netdev:  IP=192.168.43.72 GW=192.168.43.1 MASK=255.255.255.0</p>
<p>net_context:  IP=0.0.0.0 GW=0.0.0.0 MASK=0.0.0.0</p>
<p>wifi_status:  VER:3.12 SSID= CH=0 BSSID=00:00:00:00:00:00</p>
<p>try tcp init 2</p>
<p>tcp_client_init</p>
<p>tcp_client_thread sock_fd=3 gTcpSockFd=3</p>
<p>tcp_client_init server ip = 192.168.43.1, port = 6666</p>
<p>18917 SEND:  A5 A5 02 01 06 6C 21 A2 03 92 01 31 </p>
<p>18919 SEND:  A5 A5 04 05 01 01 F4 </p>
<p>18922 SEND:  A5 A5 02 08 05 48 5A 41 36 30 A7 </p>
<p>18927 SEND:  A5 A5 02 09 1E 48 5A 41 36 30 2D 49 33 2D 39 30 38 30 37 2D 56 35 2E 33 33 50 00 00 00 00 00 00 00 00 00 13 </p>
<p>net_read: ret=13   </p>
<p>18939 RECV:  A5 A5 A4 05 07 14 13 08 0C 08 21 3B B0 </p>
<p>18944 SEND:  A5 A5 02 A0 01 01 5B </p>
<p>18947 SEND:  A5 A5 02 A1 01 01 5A </p>
<p>18950 SEND:  A5 A5 02 A2 01 00 5A </p>
<p>18953 SEND:  A5 A5 02 A3 01 01 58 </p>
<p>18956 SEND:  A5 A5 02 A5 01 00 57 </p>
<p>net_read: ret=13   </p>
<p>Invalid Net ulEvent to handle 0</p>
<p>RTC Set Time:  x1213E977</p>
<p>AHC_HostUVCResetTime,L:3395 Err:0x0!</p>
<p>19258 RECV:  A5 A5 A4 05 07 14 13 08 0C 08 21 3B B0 </p>
<p>RTC Set Time:  x1213E977</p>
<p>AHC_HostUVCResetTime,L:3395 Err:0x0!</p>
<p>##VERBOSE## do_accept:255 accepted HTTP-WEB connection from 192.168.43.1:50419, fd=4, listener=2</p>
<p>##VERBOSE## prepare_response:70 ‘GET’ ‘/cgi-bin/Config.cgi?action=dir&amp;property=Event&amp;format=mov&amp;count=16&amp;from=16’ </p>
<p>FindFirstFile,DB=2,count=0!!!</p>
<p>##VERBOSE## handle_request:233 mini_dserver 4: COMPLETE</p>
<p>HAIZHEN CHECK EVENT !</p>
<p>+++SD_CARD_IN+++</p>
<p>AHC_WMSG_Draw WMSG_INFO:0</p>
<p>AHC_WMSG_Draw WMSG_INFO:16</p>
<p>STATE_VIDEO_REC_MODE_EVENT_SD_DETECT_LCDremount MMC</p>
<p>byMediaID: 0, 7</p>
<p>Unmount P Success </p>
<p>Unmount SD0 OK</p>
<p>AHC_DisMountStorageMediaEx:800: reset m_ulLockFileNum to 0</p>
<p>SDHC</p>
<p>Get OCR success.  x0078 times</p>
<p>High Speed Mode Switch done.</p>
<p>Mount P Success </p>
<p>j_end: x00001D2C</p>
<p>pVolume-&gt;FCInfo.ulLastFATSectorOffset: x0000012C</p>
<p>Create sem pDB-&gt;smLock : 119</p>
<p>Create sem pDB-&gt;smLock : 120</p>
<p>Create sem pDB-&gt;smLock : 121</p>
<p>Create sem pDB-&gt;smLock : 122</p>
<p>Create sem pDB-&gt;smLock : 123</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[0].ulMaxSizeThresholdInCluster=328484</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[1].ulMaxSizeThresholdInCluster=4830</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[2].ulMaxSizeThresholdInCluster=96613</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[3].ulMaxSizeThresholdInCluster=4830</p>
<p>uiTotalFileSize=186d5400</p>
<p>pDB-&gt;ulClusterSize=8000; = 30da</p>
<p>m_sMediaInfo.ulFreeClusters 470760</p>
<p>DB[4].ulMaxSizeThresholdInCluster=48306</p>
<p>Support 4 share files</p>
<p>Format Free File Num satisfy DCF_SHARE_FOLDER_FILE_NUM 4</p>
<p>RTC Set Time:  xA9491BD0</p>
<p>AHC_HostUVCResetTime,L:3395 Err:0x0!</p>
<p> reset_RTCbyFileName reset rtc by filename !!!! dtLastFileDateTime = 3155759951 </p>
<p>Mount SD0 OK.</p>
<p>Media Path: 0</p>
<p>Root Name: SD:\</p>
<p>Mount Status: 1</p>
<p>SDMMC Status: 1</p>
<p>MediaSelect = 0</p>
<p>55573 SEND:  A5 A5 02 06 01 01 F5 </p>
<p>SD:\wifi.txt MMPF_FS_FOpen error:  xFFFFB8A0</p>
<p>ubBootupWithCharger = 19 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 18 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 17 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 16 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 15 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 14 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 13 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 12 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 11 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 10 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 9 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 8 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 7 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 6 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 5 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 4 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 3 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 2 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 1 uiGetCurrentState = 1</p>
<p>ubBootupWithCharger = 0 uiGetCurrentState = 1</p>
<p>VideoPowerOffCounterReset 5</p>
<p>@@@ EVENT_VIDEO_KEY_RECORD -</p>
<p>Select DB 0</p>
<p>clipTime 2</p>
<p>Get Smart Info ERROR or It’s not Longsys Smart Card</p>
<p>VideoFunc_Record </p>
<p>Select DB 0</p>
<p>[[ x2 ]] &gt;&gt;&gt;&gt; Select DB 0</p>
<p>Free space 65MB is need</p>
<p>Select DB 0</p>
<p>SlowMotionRatio:X1</p>
<p>TimeLapse: Off.</p>
<p>VideoFunc_Record  AHC_MODE_VIDEO_RECORD</p>
<p>AHC_GetAhcSysMode 98</p>
<p>========== AHC_SetMode,old:0x62,new:0x60 ========== </p>
<p>AHC_GetAhcSysMode 98</p>
<p>D gain : 0x71</p>
<p>A gain : 0x1f</p>
<p>clipTime 2</p>
<p>Prm:SD:\Normal\F\FILE991231-235914F.MOV</p>
<p>Set Skip Condition: x00000064 ,ContinueSkipCount  x00000005</p>
<p>[[ x2 ]] &gt;&gt;&gt;&gt; clipTime 2</p>
<p>AHC_VIDEO_SetRecordModeSetSeamless,6886,TimeLimit:60</p>
<p>Max Size:  x6B3A8FC0 bytes</p>
<p>Enable Seamless Encode</p>
<p> Set Emergent record enable: x01</p>
<p> Emerg-PreEncDur: x00001388Max Interval : 20000 ms</p>
<p>Select DB 0</p>
<p>AHC_VIDEO_SetRecordModePreAddFilename,L:6842 Err:0x0!</p>
<p>Need to add rear cam PreAddFile!!!</p>
<h1 id="InitInstance-x00"><a href="#InitInstance-x00" class="headerlink" title="InitInstance: x00"></a>InitInstance: x00</h1><p>End of video record buffers = 0x3C2CDC0</p>
<p>Reset ProgCnt!</p>
<p>MMPF_InitADPCMEncoder</p>
<p>&lt;VRStartEncCB&gt;</p>
<p>New Emerg-PreEncDur: x00001388</p>
<p>Enable Dual Pre Record: 5000 ms</p>
<h1 id="InitInstance-x01"><a href="#InitInstance-x01" class="headerlink" title="InitInstance: x01"></a>InitInstance: x01</h1><p>End of 2nd video record buffers = 0x469EEA0</p>
<p>set dualem fd/fh</p>
<p>New Emerg-PreEncDur: x00001388</p>
<p>[Stop: x01, x0005]</p>
<p>@@@ Dram Memory End Addr of Video Record: 0x469EEA0</p>
<p>StateVideoRecMode_StartRecordingProc: VideoFunc_Record return x0000</p>
<p>57162 SEND:  A5 A5 02 05 01 01 F6 </p>
<p>soundtype : 3</p>
<p>57262 SEND:  A5 A5 03 05 0C E5 BC 80 E5 A7 8B E5 BD 95 E5 83 8F 85 </p>
<p>AHC_WMSG_Draw WMSG_INFO:0</p>
<p>HAIZHEN CHECK EVENT !</p>
<p>MMPF_VIDMGR_CheckAVSizeTimeOverLimit &lt;8&gt;</p>
<p>Got AV size full 2</p>
<p>[[ x2 ]] &gt;&gt;&gt;&gt; HAIZHEN CHECK EVENT !</p>
<p>MMPF_H264ENC_ISR,5214,OP:0x100, OV:0x1000</p>
<p>H264ENC_ISR:MEDIA_FILE_OVERFLOW</p>
<p>Check seamless</p>
<p>#Err:Repeat Deinit RC model.</p>
<p>&lt;VRStartEncCB&gt;</p>
<p>Post-Processing in</p>
<p>Process the ending frame.</p>
<p>End of video frame found 0.</p>
<p>[NORM]Buf2Cont AD: x03BDE1C0 SZ: x00000DCB PC: x00000000 ID: x00000000</p>
<p>============================</p>
<p>MMPF_3GPMUX_FillTail, Line: x0781</p>
<p>ulVideoTime: x0000EB21</p>
<p>pContainer-&gt;glAudioTotalTime: x0000EE3C</p>
<p>pContainer-&gt;glAudioTotalTime: x0000EB01</p>
<p>============================</p>
<p>ulVideoTime: x0000EB21</p>
<p>&lt;VRPostProcessCB&gt;</p>
<p>GSENSORINFO_SIZE:930</p>
<p>end of saving file</p>
<p>SD:\Normal\F\FILE991231-235914F.MOV</p>
<p>Post-Processing out</p>
<p> [VID_REC_END] &lt;VRFileFullCB&gt;</p>
<p>&lt;VRSeamlessCB&gt;</p>
<p>&gt;&gt;&gt; VideoFunc_RecordRestart -</p>
<p>clipTime 2</p>
<p>Free space 65MB is need</p>
<p>DCF_File0 =5976</p>
<p>DCF_Th0 = 328484</p>
<p> VideoFunc_RecordRestart uiFileCount= 4 1</p>
<p>VideoFunc_RecordRestart,2167</p>
<p>DCF_File2 =0</p>
<p>DCF_Th2 = 96613</p>
<p>Select DB 2</p>
<p> VideoFunc_RecordRestart uiFileCount= 0 3</p>
<p>Restart RecordTimeOffset [0] ms</p>
<p>3: VideoFunc_RecordRestart, 2235, current db:2</p>
<p>Select DB 0</p>
<p>invalid DB, not FormatFree Folder</p>
<p>AIHC_DCFDT_PostAddFile szFullPath SD:\Normal\F\FILE991231-235914F.MOV</p>
<p>sDcfDtSet.m_uiCurrDBIdx = 0</p>
<p>119984 SEND:  A5 A5 03 04 23 53 44 3A 5C 4E 6F 72 6D 61 6C 5C 46 5C 46 49 4C 45 39 39 31 32 33 31 2D 32 33 35 39 31 34 46 2E 4D 4F 56 1D </p>
<p>AHC_DCFDT_CreateFullPathWithoutEXT: Date Time Valid</p>
<p>AHC_VIDEO_SetRecordModePreSetFilename,L:6254 Err:0x0!</p>
<p>AHC_VIDEO_SetRecordModeExecActionList,L:7871 Err:0x0!</p>
<p>Flow Type:3, API:14 Error</p>
<p>There is no corresponding exception handler!</p>
<p>HAIZHEN CHECK EVENT !</p>
<p>[Vid OV-3, Type: x0000] [ x000000EA # skip][Vid OV-3, Type: x0000] [ x000000EA # skip][Vid OV-3, Type: x0000] [ x000000EA # skip][Vid OV-3, Type: x0000] [ x000000EA # skip][Vid OV-3, Type: x0000] [ x000000EA # skip][Vid OV-3, Type: x0000] [ x000000EA # skip][Vid OV-3, Type: x0000] [ x000000F8 # skip][Vid OV-3, Type: x0000] [ x000000F8 # skip][Vid OV-3, Type: x0000] [ x000001DB # skip][Vid OV-3, Type: x0000] [ x000001DB # skip][Vid OV-3, Type: x0000] [ x000001DB # skip][Vid OV-3, Type: x0000] [ x000001DB # skip][Vid OV-3, Type: x0000] [ x000001EA # skip][Vid OV-3, Type: x0000] [ x000001EA # skip][Vid OV-3, Type: x0000] [ x000001F8 # skip][Vid OV-3, Type: x0000] [ x000002CA # skip][Vid OV-3, Type: x0000] [ x000002CA # skip][Vid OV-3, Type: x0000] [ x000002CA # skip][Vid OV-3, Type: x0000] [ x000002CA # skip][Vid OV-3, Type: x0000] [ x000002D9 # skip][Vid OV-3, Type: x0000] [ x000002D9 # skip][Vid OV-3, Type: x0000] [ x000002E8 # skip]</p>
<p>[[ x2 ]] &gt;&gt;&gt;&gt; HAIZHEN CHECK EVENT !</p>
<p>WIFI CHECK , nhw_get_status = 2</p>
<p>150278 SEND:  A5 A5 02 03 01 02 F7 </p>
<p>[Vid OV-4, Type: x0000] [ x000003BA # skip][Vid OV-4, Type: x0000] [ x000003BA # skip][Vid OV-4, Type: x0000] [ x000003BA # skip][Vid OV-4, Type: x0000] [ x000003BA # skip][Vid OV-3, Type: x0000] [ x000003CA # skip][Vid OV-3, Type: x0000] [ x000003D9 # skip][Vid OV-3, Type: x0000] [ x000003F6 # skip][Vid OV-4, Type: x0000] [ x000004AA # skip][Vid OV-4, Type: x0000] [ x000004AA # skip][Vid OV-4, Type: x0000] [ x000004AA # skip][Vid OV-4, Type: x0000] [ x000004AA # skip][Vid OV-3, Type: x0000] [ x000004B9 # skip][Vid OV-3, Type: x0000] [ x000004C8 # skip][Vid OV-3, Type: x0000] [ x000004E6 # skip]</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>usb mass storage 加密码 修改密码  动态布局</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/usb%20mass%20storage%20%E5%8A%A0%E5%AF%86%E7%A0%81%20%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%20%20%E5%8A%A8%E6%80%81%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbStorageActivity.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbStora</p>
<p>index 548cdfc..9b01dad 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbStorageActivity.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbStorageActivity.java</p>
<p>@@ -52,9 +52,20 @@ import android.view.WindowManager;</p>
<p> import android.util.Log;</p>
<p> import android.widget.Toast;</p>
<p> import android.os.RemoteException;</p>
<p>-</p>
<p>+import android.widget.EditText;</p>
<p>+import android.content.DialogInterface;</p>
<p> import java.util.List;</p>
<p>-</p>
<p>+import android.app.AlertDialog;</p>
<p>+import android.text.method.PasswordTransformationMethod;</p>
<p>+import android.view.Menu;</p>
<p>+import android.view.MenuItem;</p>
<p>+import android.view.LayoutInflater;</p>
<p>+import android.widget.LinearLayout;</p>
<p>+import android.widget.RelativeLayout;</p>
<p>+import android.view.ViewGroup;</p>
<p>+import android.view.ViewGroup.MarginLayoutParams;</p>
<p>+import android.content.SharedPreferences;</p>
<p>+</p>
<p> /**</p>
<p>  * This activity is shown to the user for him/her to enable USB mass storage</p>
<p>  * on-demand (that is, when the USB cable is connected). It uses the alert</p>
<p>@@ -394,7 +405,9 @@ public class UsbStorageActivity extends Activity</p>
<p>             scheduleShowDialog(DLG_CONFIRM_KILL_STORAGE_USERS);</p>
<p>         } else {</p>
<p>             if (localLOGV) Log.i(TAG, &quot;Enabling UMS&quot;);</p>
<ul>
<li>           switchUsbMassStorage(true);</li>
</ul>
<p>+</p>
<ul>
<li>           switchUsbMassStorage(true);</li>
</ul>
<p>+</p>
<p>         }</p>
<p>     }</p>
<p>@@ -406,9 +419,39 @@ public class UsbStorageActivity extends Activity</p>
<p>                                return;</p>
<p>                        }</p>
<p>            // Check for list of storage users and display dialog if needed.</p>
<ul>
<li><p>                 mMountButton.setVisibility(View.GONE);</p>
</li>
<li><p>                 mProgressBar.setVisibility(View.VISIBLE);</p>
</li>
<li><p>           checkStorageUsers();</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                  SharedPreferences spf = getSharedPreferences(&quot;mass&quot;, 0);</p>
</li>
<li><p>         final   String psw = spf.getString(&quot;password&quot;, &quot;bx&quot;);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                      AlertDialog.Builder alertDialog = new AlertDialog.Builder(this);</p>
</li>
<li><p>                      final EditText passwords = new EditText(this);</p>
</li>
<li><p>                       passwords.setTransformationMethod(PasswordTransformationMethod.getInstance());</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                       alertDialog.setTitle(&quot;请输入密码&quot;)</p>
</li>
<li><p>                      .setIcon(android.R.drawable.ic_dialog_info)</p>
</li>
<li><p>                      .setView(passwords)</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                      .setPositiveButton(&quot;确定&quot;,</p>
</li>
<li><p>                        new DialogInterface.OnClickListener(){</p>
</li>
<li><p>                                public void onClick(DialogInterface dialoginterface, int i){</p>
</li>
<li><p>                                    if(passwords.getText().toString().equals(psw)){</p>
</li>
<li><p>                                                                       mMountButton.setVisibility(View.GONE);</p>
</li>
<li><p>                                                                       mProgressBar.setVisibility(View.VISIBLE);</p>
</li>
<li><p>                                                                       checkStorageUsers();</p>
</li>
<li><p>                                                                      }else{</p>
</li>
<li><p>                                                      Toast.makeText(UsbStorageActivity.this,&quot; 密码错误！ &quot;, Toast.LENGTH_LONG).show();</p>
</li>
</ul>
<p>+</p>
<ul>
<li>                                                                      }</li>
</ul>
<p>+</p>
<ul>
<li><p>                                }</p>
</li>
<li><p>                        })</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>                      .setNegativeButton(&quot;取消&quot;, null )</p>
</li>
<li><p>                      .show();</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<p>+</p>
<p>         } else if (v == mUnmountButton) {</p>
<p>             if (localLOGV) Log.i(TAG, &quot;Disabling UMS&quot;);</p>
<p>                        mUnmountButton.setVisibility(View.GONE);</p>
<p>@@ -429,5 +472,134 @@ public class UsbStorageActivity extends Activity</p>
<p>                }</p>
<p>         finish();</p>
<p>     }</p>
<p>+</p>
<ul>
<li>      private static final int ITEM1 = Menu.FIRST;</li>
</ul>
<p>+</p>
<ul>
<li><p>      @Override</p>
</li>
<li><p>      public boolean onCreateOptionsMenu(Menu menu) {</p>
</li>
<li><p>              super.onCreateOptionsMenu(menu);</p>
</li>
</ul>
<p>+</p>
<ul>
<li>              menu.add(0,ITEM1,0,&quot;修改密码&quot;);</li>
</ul>
<p>+</p>
<ul>
<li><p>              return true;</p>
</li>
<li><p>      }</p>
</li>
<li><p>      //View myView;</p>
</li>
<li><p>      @Override</p>
</li>
<li><p>      public boolean onOptionsItemSelected(MenuItem item) {</p>
</li>
<li><p>   switch (item.getItemId()) {</p>
</li>
<li><p>      case ITEM1:</p>
</li>
<li><p>                      //Toast.makeText(UsbStorageActivity.this,&quot; how to change the passwords ? &quot;, Toast.LENGTH_LONG).show();</p>
</li>
<li><p>                      //LayoutInflater factory = LayoutInflater.from(UsbStorageActivity.this);</p>
</li>
<li><p>                      //myView = factory.inflate(com.android.internal.R.layout.usb_storage_password, null);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                SharedPreferences spf = getSharedPreferences(&quot;mass&quot;, 0);</p>
</li>
<li><p>         final   String psw = spf.getString(&quot;password&quot;, &quot;bx&quot;);</p>
</li>
</ul>
<p>+</p>
<ul>
<li>       RelativeLayout myView = new RelativeLayout(this);</li>
</ul>
<p>+</p>
<ul>
<li><p>        TextView org_pass = new TextView(this);</p>
</li>
<li><p>       org_pass.setText(&quot;原始密码:&quot;);</p>
</li>
<li><p>               org_pass.setId(111);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>      RelativeLayout.LayoutParams lp1 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>      lp1.addRule(RelativeLayout.ALIGN_PARENT_TOP);</p>
</li>
<li><p>      //lp1.addRule(RelativeLayout.ALIGN_PARENT_LEFT);</p>
</li>
<li><p>              lp1.setMarginStart(50);</p>
</li>
<li><p>              //lp1.setMargins (50, 15, 10, 50);//int left, int top, int right, int bottom</p>
</li>
<li><p>      myView.addView(org_pass ,lp1);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>      final   EditText editText1 = new EditText(this);</p>
</li>
<li><p>              editText1.setEms(10);</p>
</li>
<li><p>              editText1.setId(112);</p>
</li>
<li><p>              editText1.setTransformationMethod(PasswordTransformationMethod.getInstance());</p>
</li>
<li><p>              RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>      lp2.addRule(RelativeLayout.RIGHT_OF,org_pass.getId());</p>
</li>
<li><p>      lp2.addRule(RelativeLayout.ALIGN_BASELINE,org_pass.getId());</p>
</li>
<li><p>              lp2.setMarginEnd(50);</p>
</li>
<li><p>              myView.addView(editText1 ,lp2);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>               TextView password1 = new TextView(this);</p>
</li>
<li><p>       password1.setText(&quot;新的密码:&quot;);</p>
</li>
<li><p>               password1.setId(113);</p>
</li>
<li><p>      RelativeLayout.LayoutParams lp3 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>      lp3.addRule(RelativeLayout.BELOW,editText1.getId());</p>
</li>
<li><p>      lp3.addRule(RelativeLayout.ALIGN_LEFT,org_pass.getId());</p>
</li>
<li><p>      myView.addView(password1 ,lp3);</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>      final   EditText editText2 = new EditText(this);</p>
</li>
<li><p>              editText2.setEms(10);</p>
</li>
<li><p>              editText2.setId(114);</p>
</li>
<li><p>              editText2.setTransformationMethod(PasswordTransformationMethod.getInstance());</p>
</li>
<li><p>              RelativeLayout.LayoutParams lp4 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>      lp4.addRule(RelativeLayout.BELOW,editText1.getId());</p>
</li>
<li><p>      lp4.addRule(RelativeLayout.ALIGN_BASELINE,password1.getId());</p>
</li>
<li><p>              lp4.addRule(RelativeLayout.ALIGN_LEFT,editText1.getId());</p>
</li>
<li><p>              lp4.setMarginEnd(50);</p>
</li>
<li><p>              myView.addView(editText2 ,lp4);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>              TextView password2 = new TextView(this);</p>
</li>
<li><p>       password2.setText(&quot;确认密码:&quot;);</p>
</li>
<li><p>               password2.setId(115);</p>
</li>
<li><p>      RelativeLayout.LayoutParams lp5 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>      lp5.addRule(RelativeLayout.BELOW,editText2.getId());</p>
</li>
<li><p>      lp5.addRule(RelativeLayout.ALIGN_LEFT,org_pass.getId());</p>
</li>
<li><p>      myView.addView(password2 ,lp5);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>      final   EditText editText3 = new EditText(this);</p>
</li>
<li><p>              editText3.setEms(10);</p>
</li>
<li><p>              editText3.setId(116);</p>
</li>
<li><p>              editText3.setTransformationMethod(PasswordTransformationMethod.getInstance());</p>
</li>
<li><p>              RelativeLayout.LayoutParams lp6 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>      lp6.addRule(RelativeLayout.BELOW,editText2.getId());</p>
</li>
<li><p>      lp6.addRule(RelativeLayout.ALIGN_BASELINE,password2.getId());</p>
</li>
<li><p>              lp6.addRule(RelativeLayout.ALIGN_LEFT,editText2.getId());</p>
</li>
<li><p>              lp6.setMarginEnd(50);</p>
</li>
<li><p>              myView.addView(editText3 ,lp6);</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>                      AlertDialog.Builder alertDialog = new AlertDialog.Builder(UsbStorageActivity.this);</p>
</li>
<li><p>                      alertDialog</p>
</li>
<li><p>                      .setView(myView)</p>
</li>
<li><p>                      .setTitle(&quot;更改密码&quot;)</p>
</li>
<li><p>                      .setIcon(android.R.drawable.ic_dialog_info)</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>                              .setPositiveButton(&quot;确定&quot;,</p>
</li>
<li><p>                        new DialogInterface.OnClickListener(){</p>
</li>
<li><p>                                public void onClick(DialogInterface dialoginterface, int i){</p>
</li>
<li><p>                                    if(editText1.getText().toString().equals(psw)){</p>
</li>
<li><p>                                                                                      if(     editText2.getText().toString().equals(editText3.getText().toString())){</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                                                                                               SharedPreferences pf = getSharedPreferences(&quot;mass&quot;, 0);</p>
</li>
<li><p>                                                                                                      SharedPreferences.Editor editor = pf.edit();</p>
</li>
<li><p>                                                                                                      editor.putString(&quot;password&quot;, editText2.getText().toString());</p>
</li>
<li><p>                                                                                                      editor.commit();</p>
</li>
<li><p>                                                                                                      Toast.makeText(UsbStorageActivity.this,&quot; 密码修改成功 &quot;, Toast.LENGTH</p>
</li>
<li><p>                                                                                      }else{</p>
</li>
<li><p>                                                                                      Toast.makeText(UsbStorageActivity.this,&quot; 密码不一致 &quot;, Toast.LENGTH_LONG).show();</p>
</li>
<li><p>                                                                                      }</p>
</li>
<li><p>                                                                      }else{</p>
</li>
<li><p>                                                      Toast.makeText(UsbStorageActivity.this,&quot; 原密码错误！ &quot;, Toast.LENGTH_LONG).show();</p>
</li>
</ul>
<p>+</p>
<ul>
<li>                                                                      }</li>
</ul>
<p>+</p>
<ul>
<li><p>                                }</p>
</li>
<li><p>                        })</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>                      .setNegativeButton(&quot;取消&quot;, null )</p>
</li>
<li><p>                      .show();</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li>      break;</li>
</ul>
<p>+</p>
<ul>
<li><p>              default:</p>
</li>
<li><p>                      return super.onOptionsItemSelected(item);</p>
</li>
<li><p>   }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>      return true;</p>
</li>
<li><p>      }</p>
</li>
</ul>
<p>+</p>
<p> }</p>
<p>中英文国际化</p>
<p>==================</p>
<p>diff –git a/frameworks/base/packages/SystemUI/res/values-zh-rCN/strings.xml b/frameworks/base/packages/SystemUI/res/values-zh-rCN/strings.xml</p>
<p>index 0ef5ea0..21d959d 100644</p>
<p>— a/frameworks/base/packages/SystemUI/res/values-zh-rCN/strings.xml</p>
<p>+++ b/frameworks/base/packages/SystemUI/res/values-zh-rCN/strings.xml</p>
<p>@@ -210,4 +210,17 @@</p>
<p>     &lt;string name=&quot;sdcard_unmount&quot;&gt;内部存储正在使用中&lt;/string&gt;</p>
<p>     &lt;string name=&quot;external_sd_unmount&quot;&gt;SD卡未挂载&lt;/string&gt;</p>
<p>     &lt;string name=&quot;usb_storage_unmount&quot;&gt;USB存储未挂载&lt;/string&gt;</p>
<p>+</p>
<p>+</p>
<ul>
<li><p>&lt;string name=&quot;input_password&quot;&gt;请输入密码.&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;yes_btn&quot;&gt;确定&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;cancel_btn&quot;&gt;取消&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;psw_err&quot;&gt;密码错误.&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;psw_change&quot;&gt;修改密码&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;org_psw&quot;&gt;&quot; 原 密码:&quot;&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;new_psw&quot;&gt;&quot; 新 密码:&quot;&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;con_psw&quot;&gt;&quot;确认密码:&quot;&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;psw_updated&quot;&gt;密码修改成功!&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;psw_differ&quot;&gt; 密码不一致!&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;old_psw_err&quot;&gt;原密码错误!&lt;/string&gt;</p>
</li>
</ul>
<p> &lt;/resources&gt;</p>
<p>diff –git a/frameworks/base/packages/SystemUI/res/values/strings.xml b/frameworks/base/packages/SystemUI/res/values/strings.xml</p>
<p>index e12c899..20c8e4f 100644</p>
<p>— a/frameworks/base/packages/SystemUI/res/values/strings.xml</p>
<p>+++ b/frameworks/base/packages/SystemUI/res/values/strings.xml</p>
<p>@@ -520,5 +520,17 @@</p>
<p>     &lt;!–screen shot–&gt;</p>
<p>     &lt;string name=&quot;sdcard_unmount&quot;&gt;internal storage is unmount&lt;/string&gt;</p>
<p>     &lt;string name=&quot;external_sd_unmount&quot;&gt;sd card is unmount&lt;/string&gt;</p>
<ul>
<li>&lt;string name=&quot;usb_storage_unmount&quot;&gt;usb storage is unmount&lt;/string&gt;</li>
</ul>
<ul>
<li>&lt;string name=&quot;usb_storage_unmount&quot;&gt;usb storage is unmount&lt;/string&gt;</li>
</ul>
<p>+</p>
<ul>
<li><p>&lt;string name=&quot;input_password&quot;&gt;Please input password .&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;yes_btn&quot;&gt;Confirm&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;cancel_btn&quot;&gt;Cancel&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;psw_err&quot;&gt;Invalid password .&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;psw_change&quot;&gt;Change password&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;org_psw&quot;&gt;&quot;Old password:&quot;&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;new_psw&quot;&gt;&quot;New password:&quot;&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;con_psw&quot;&gt;&quot;Con password:&quot;&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;psw_updated&quot;&gt;Password updated successfully !&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;psw_differ&quot;&gt;Entered passwords differ !&lt;/string&gt;</p>
</li>
<li><p>&lt;string name=&quot;old_psw_err&quot;&gt;Old passwords error !&lt;/string&gt;</p>
</li>
</ul>
<p> &lt;/resources&gt;</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbStorageActivity.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbStora</p>
<p>index 548cdfc..b605390 100644</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbStorageActivity.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/UsbStorageActivity.java</p>
<p>@@ -52,9 +52,20 @@ import android.view.WindowManager;</p>
<p> import android.util.Log;</p>
<p> import android.widget.Toast;</p>
<p> import android.os.RemoteException;</p>
<p>-</p>
<p>+import android.widget.EditText;</p>
<p>+import android.content.DialogInterface;</p>
<p> import java.util.List;</p>
<p>-</p>
<p>+import android.app.AlertDialog;</p>
<p>+import android.text.method.PasswordTransformationMethod;</p>
<p>+import android.view.Menu;</p>
<p>+import android.view.MenuItem;</p>
<p>+import android.view.LayoutInflater;</p>
<p>+import android.widget.LinearLayout;</p>
<p>+import android.widget.RelativeLayout;</p>
<p>+import android.view.ViewGroup;</p>
<p>+import android.view.ViewGroup.MarginLayoutParams;</p>
<p>+import android.content.SharedPreferences;</p>
<p>+</p>
<p> /**</p>
<p>  * This activity is shown to the user for him/her to enable USB mass storage</p>
<p>  * on-demand (that is, when the USB cable is connected). It uses the alert</p>
<p>@@ -406,9 +417,39 @@ public class UsbStorageActivity extends Activity</p>
<p>                                return;</p>
<p>                        }</p>
<p>            // Check for list of storage users and display dialog if needed.</p>
<ul>
<li><p>mMountButton.setVisibility(View.GONE);</p>
</li>
<li><p>mProgressBar.setVisibility(View.VISIBLE);</p>
</li>
<li><p>checkStorageUsers();</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>SharedPreferences spf = getSharedPreferences(&quot;mass&quot;, 0);</p>
</li>
<li><p>final String psw = spf.getString(&quot;password&quot;, &quot;bx&quot;);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>AlertDialog.Builder alertDialog = new AlertDialog.Builder(this);</p>
</li>
<li><p>final EditText passwords = new EditText(this);</p>
</li>
<li><p>passwords.setTransformationMethod(PasswordTransformationMethod.getInstance());</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>alertDialog.setTitle(com.android.systemui.R.string.input_password)</p>
</li>
<li><p>.setIcon(android.R.drawable.ic_dialog_info)</p>
</li>
<li><p>.setView(passwords)</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>.setPositiveButton(com.android.systemui.R.string.yes_btn,</p>
</li>
<li><p>new DialogInterface.OnClickListener(){</p>
</li>
<li><p>public void onClick(DialogInterface dialoginterface, int i){</p>
</li>
<li><p>if(passwords.getText().toString().equals(psw)){</p>
</li>
<li><p>mMountButton.setVisibility(View.GONE);</p>
</li>
<li><p>mProgressBar.setVisibility(View.VISIBLE);</p>
</li>
<li><p>checkStorageUsers();</p>
</li>
<li><p>}else{</p>
</li>
<li><p>Toast.makeText(UsbStorageActivity.this, com.android.systemui.R.string.psw_err, Toast.LENGTH_LONG).show();</p>
</li>
</ul>
<p>+</p>
<ul>
<li>}</li>
</ul>
<p>+</p>
<ul>
<li><p>}</p>
</li>
<li><p>})</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>.setNegativeButton(com.android.systemui.R.string.cancel_btn, null )</p>
</li>
<li><p>.show();</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<p>+</p>
<p>         } else if (v == mUnmountButton) {</p>
<p>             if (localLOGV) Log.i(TAG, &quot;Disabling UMS&quot;);</p>
<p>                        mUnmountButton.setVisibility(View.GONE);</p>
<p>@@ -429,5 +470,134 @@ public class UsbStorageActivity extends Activity</p>
<p>                }</p>
<p>         finish();</p>
<p>     }</p>
<p>+</p>
<ul>
<li>private static final int ITEM1 = Menu.FIRST;</li>
</ul>
<p>+</p>
<ul>
<li><p>@Override</p>
</li>
<li><p>public boolean onCreateOptionsMenu(Menu menu) {</p>
</li>
<li><p>super.onCreateOptionsMenu(menu);</p>
</li>
</ul>
<p>+</p>
<ul>
<li>menu.add(0,ITEM1,0,com.android.systemui.R.string.psw_change);</li>
</ul>
<p>+</p>
<ul>
<li><p>return true;</p>
</li>
<li><p>}</p>
</li>
<li><p>//View myView;</p>
</li>
<li><p>@Override</p>
</li>
<li><p>public boolean onOptionsItemSelected(MenuItem item) {</p>
</li>
<li><p>switch (item.getItemId()) {</p>
</li>
<li><p>case ITEM1:</p>
</li>
<li><p>//Toast.makeText(UsbStorageActivity.this,&quot; how to change the passwords ? &quot;, Toast.LENGTH_LONG).show();</p>
</li>
<li><p>//LayoutInflater factory = LayoutInflater.from(UsbStorageActivity.this);</p>
</li>
<li><p>//myView = factory.inflate(com.android.internal.R.layout.usb_storage_password, null);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>SharedPreferences spf = getSharedPreferences(&quot;mass&quot;, 0);</p>
</li>
<li><p>final String psw = spf.getString(&quot;password&quot;, &quot;bx&quot;);</p>
</li>
</ul>
<p>+</p>
<ul>
<li>RelativeLayout myView = new RelativeLayout(this);</li>
</ul>
<p>+</p>
<ul>
<li><p>TextView org_pass = new TextView(this);</p>
</li>
<li><p>org_pass.setText(com.android.systemui.R.string.org_psw);</p>
</li>
<li><p>org_pass.setId(111);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>RelativeLayout.LayoutParams lp1 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>lp1.addRule(RelativeLayout.ALIGN_PARENT_TOP);</p>
</li>
<li><p>//lp1.addRule(RelativeLayout.ALIGN_PARENT_LEFT);</p>
</li>
<li><p>lp1.setMarginStart(50);</p>
</li>
<li><p>//lp1.setMargins (50, 15, 10, 50);//int left, int top, int right, int bottom</p>
</li>
<li><p>myView.addView(org_pass ,lp1);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>final EditText editText1 = new EditText(this);</p>
</li>
<li><p>editText1.setEms(10);</p>
</li>
<li><p>editText1.setId(112);</p>
</li>
<li><p>editText1.setTransformationMethod(PasswordTransformationMethod.getInstance());</p>
</li>
<li><p>RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>lp2.addRule(RelativeLayout.RIGHT_OF,org_pass.getId());</p>
</li>
<li><p>lp2.addRule(RelativeLayout.ALIGN_BASELINE,org_pass.getId());</p>
</li>
<li><p>lp2.setMarginEnd(50);</p>
</li>
<li><p>myView.addView(editText1 ,lp2);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>TextView password1 = new TextView(this);</p>
</li>
<li><p>password1.setText(com.android.systemui.R.string.new_psw);</p>
</li>
<li><p>password1.setId(113);</p>
</li>
<li><p>RelativeLayout.LayoutParams lp3 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>lp3.addRule(RelativeLayout.BELOW,editText1.getId());</p>
</li>
<li><p>lp3.addRule(RelativeLayout.ALIGN_LEFT,org_pass.getId());</p>
</li>
<li><p>myView.addView(password1 ,lp3);</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>final EditText editText2 = new EditText(this);</p>
</li>
<li><p>editText2.setEms(10);</p>
</li>
<li><p>editText2.setId(114);</p>
</li>
<li><p>editText2.setTransformationMethod(PasswordTransformationMethod.getInstance());</p>
</li>
<li><p>RelativeLayout.LayoutParams lp4 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>lp4.addRule(RelativeLayout.BELOW,editText1.getId());</p>
</li>
<li><p>lp4.addRule(RelativeLayout.ALIGN_BASELINE,password1.getId());</p>
</li>
<li><p>lp4.addRule(RelativeLayout.ALIGN_LEFT,editText1.getId());</p>
</li>
<li><p>lp4.setMarginEnd(50);</p>
</li>
<li><p>myView.addView(editText2 ,lp4);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>TextView password2 = new TextView(this);</p>
</li>
<li><p>password2.setText(com.android.systemui.R.string.con_psw);</p>
</li>
<li><p>password2.setId(115);</p>
</li>
<li><p>RelativeLayout.LayoutParams lp5 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>lp5.addRule(RelativeLayout.BELOW,editText2.getId());</p>
</li>
<li><p>lp5.addRule(RelativeLayout.ALIGN_LEFT,org_pass.getId());</p>
</li>
<li><p>myView.addView(password2 ,lp5);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>final EditText editText3 = new EditText(this);</p>
</li>
<li><p>editText3.setEms(10);</p>
</li>
<li><p>editText3.setId(116);</p>
</li>
<li><p>editText3.setTransformationMethod(PasswordTransformationMethod.getInstance());</p>
</li>
<li><p>RelativeLayout.LayoutParams lp6 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);</p>
</li>
<li><p>lp6.addRule(RelativeLayout.BELOW,editText2.getId());</p>
</li>
<li><p>lp6.addRule(RelativeLayout.ALIGN_BASELINE,password2.getId());</p>
</li>
<li><p>lp6.addRule(RelativeLayout.ALIGN_LEFT,editText2.getId());</p>
</li>
<li><p>lp6.setMarginEnd(50);</p>
</li>
<li><p>myView.addView(editText3 ,lp6);</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>AlertDialog.Builder alertDialog = new AlertDialog.Builder(UsbStorageActivity.this);</p>
</li>
<li><p>alertDialog</p>
</li>
<li><p>.setView(myView)</p>
</li>
<li><p>.setTitle(com.android.systemui.R.string.psw_change)</p>
</li>
<li><p>.setIcon(android.R.drawable.ic_dialog_info)</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>.setPositiveButton(com.android.systemui.R.string.yes_btn,</p>
</li>
<li><p>new DialogInterface.OnClickListener(){</p>
</li>
<li><p>public void onClick(DialogInterface dialoginterface, int i){</p>
</li>
<li><p>if(editText1.getText().toString().equals(psw)){</p>
</li>
<li><p>if( editText2.getText().toString().equals(editText3.getText().toString())){</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>SharedPreferences pf = getSharedPreferences(&quot;mass&quot;, 0);</p>
</li>
<li><p>SharedPreferences.Editor editor = pf.edit();</p>
</li>
<li><p>editor.putString(&quot;password&quot;, editText2.getText().toString());</p>
</li>
<li><p>editor.commit();</p>
</li>
<li><p>Toast.makeText(UsbStorageActivity.this,com.android.systemui.R.string.</p>
</li>
<li><p>}else{</p>
</li>
<li><p>Toast.makeText(UsbStorageActivity.this,com.android.systemui.R.string.psw_differ, Toas</p>
</li>
<li><p>}</p>
</li>
<li><p>}else{</p>
</li>
<li><p>Toast.makeText(UsbStorageActivity.this,com.android.systemui.R.string.old_psw_err, Toast.LENGTH_LONG).show();</p>
</li>
</ul>
<p>+</p>
<ul>
<li>}</li>
</ul>
<p>+</p>
<ul>
<li><p>}</p>
</li>
<li><p>})</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li><p>.setNegativeButton(com.android.systemui.R.string.cancel_btn, null )</p>
</li>
<li><p>.show();</p>
</li>
</ul>
<p>+</p>
<p>+</p>
<ul>
<li>break;</li>
</ul>
<p>+</p>
<ul>
<li><p>default:</p>
</li>
<li><p>return super.onOptionsItemSelected(item);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>return true;</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>+</p>
<p> }</p>
<p>(END)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>《新李屋李氏第一房圣章公家谱》序家之有谱，犹国之有史也</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E3%80%8A%E6%96%B0%E6%9D%8E%E5%B1%8B%E6%9D%8E%E6%B0%8F%E7%AC%AC%E4%B8%80%E6%88%BF%E5%9C%A3%E7%AB%A0%E5%85%AC%E5%AE%B6%E8%B0%B1%E3%80%8B%E5%BA%8F%E5%AE%B6%E4%B9%8B%E6%9C%89%E8%B0%B1%EF%BC%8C%E7%8A%B9%E5%9B%BD%E4%B9%8B%E6%9C%89%E5%8F%B2%E4%B9%9F/</url>
    <content><![CDATA[<p>第一代：火德公，妾陈氏生男：三一郎、三二郎、三三郎；女：桂英、涉英。</p>
<p>第二代：三一郎，妣邱氏、田氏，生六子：百一郎、百二郎、百三郎、千三郎、千四郎、百十郎。</p>
<p>第三代：百三郎，妣钟氏、郑氏、吕氏。生三子：千二郎、千八郎、千九郎。</p>
<p>第四代：千二郎，妣陈氏，生明一郎</p>
<p>第五代：明一郎，妣黄氏，生福四郎</p>
<p>第六代：福四郎，妣黄氏，生三子：君、臣、义。君公带福四郎金骨到广东省乳源县百竹面隧而葬，福四郎墓地为马形，如将军骑马。吉地坐西向东，墓地葬在乳源县古母水白竹村对面，此墓称为广东省李氏总坟</p>
<p>第七代：义公从福建上杭县官田村迁徙到广东广州市九眠井（现广州市解放北路科学馆内有九眼石碑）定居，开枝发族。生一子：栋公。</p>
<p>第八代：栋公，定居广州高大街，生三子：侃、绚、怡。</p>
<p>第九代：怡公生应春公。</p>
<p>第十代：应春公，从广州高大街迁居阳山县通儒坊迳口，后再迁徙阳山县太平镇大城岗定居。娶妻成氏、陈氏。生九子一女：小一字日龙、小二字日虎、小三字日青、小四字日寿、小五字日元、小育字日育、小宋字日宋、小新字日细、小弟字日尽、小郎字日天（养子）。</p>
<p>应春公，娶妻成氏、陈氏。生九子一女：小一字日龙、小二字日虎、小三字日青、小四字日寿、小五字日元、小育字日育、小宋字日宋、小新字日细、小弟字日尽、小郎字日天（养子）。</p>
<p>二世祖：第一房小一公，迁徙湖北省加禾、广东省连州第二房小二公，迁徙广东英德市荷木岗、阳山县杜步镇梅冲村。第三房小三公，生评公，迁徙阳山县七拱镇社岗山塝第四房小四公，迁徙湖北省安陆县第五房小五公，生义禄，在阳山县太平镇大城岗原地居住。第六房小育公，生义公（居阳山县太平镇大城岗天升塘、吊水村）、亮公（迁徙广东怀集县凤岗镇石竹埇松岗村）、荣公（迁徙阳山县黎埠镇水井村）</p>
<p>第七房小宋公字日宋，配成氏，生子：盛公（迁居阳山县七拱镇新岗村寨孔）、洪、晚（迁徙广东怀集县），宋公墓葬于阳山县太平镇雷家寨山坳，坐西向东。第八房小新公，生子：舒（迁居阳山县七拱镇佳礼垌）、保（迁徙广东怀集县）、晚（迁徙广东怀集县中洲镇良村）。第九房小弟公，生一子：文实，迁居阳山县江英镇第十房小郎公（应春公养子），迁居阳山县太平镇大城岗田心围。</p>
<p>三世祖：盛公，配成氏，由阳山县太平镇大城岗迁居阳山县七拱镇新岗寨孔村，生三子：珍（迁徙阳山县城）、宝（阳山县高峰乡、小江镇西岭、黎埠镇水井之祖）、旺。</p>
<p>盛公墓葬于阳山县太平镇雷家寨山坳，坐庚向东甲兼卯酉分金。</p>
<p>四世祖：旺公，配成氏，生五子：良珠（迁居阳山县小江黄牛滩）、良玹（迁居阳山县黎埠镇水井）、良琚（迁徙清远横石）、良瓒（在七拱镇新岗寨孔原地居住）、良琏（迁居阳山县七拱镇新岗村拱桥头）</p>
<p>五世祖：良琏，由寨孔村迁居相邻的七拱镇新岗村拱桥头，生五子：日俭、日恒、日新、日硕、日勤。琏公墓葬于阳山县七拱镇蛇坑尾杨屋右边半山头。</p>
<p>六世祖：日俭，妣黄氏，生三子：向上、向高、向兆。日俭公墓葬于阳山县七拱镇蛇坑尾杨屋右边涌尾。黄氏墓葬于阳山县七拱镇佛仔岗大菜园边。</p>
<p>七世祖：向兆公，字品属，妣成氏，生子：亦安。向兆公墓葬于阳山县七拱镇佛仔岗大菜园田边。乾山巽向兼亥巳分金。</p>
<p>八世祖：亦安公，妣黄氏，生三子：悠芬、悠芳、悠秀。亦安公墓葬于阳山县七拱镇佛仔岗大菜园田边。乾山巽向兼亥巳分金。黄氏墓葬于阳山县七拱镇浪子岗四方楼屋背。</p>
<p>九世祖：悠芬公，妣谢氏，生一子：卓贤。悠芬公葬于阳山县七拱镇塘坪村山心岭，谢氏葬于阳山县七拱镇佛仔岗大菜园田边</p>
<p>十世祖：卓贤，妣陈氏，生二子：恒言、恒道，</p>
<p>十一世祖：恒言公，妣谢氏，生二子：为山（迁居与新李屋相邻的蓝灰屋）、鉴山。谢氏葬于七拱钟木生背田垅。</p>
<p>十二世祖：鉴山公，妣莫氏，生一子：弦文新李屋开基祖弦文公</p>
<p>十三祖：①弦文公，号“银鬼火”为阳山县七拱镇新李屋开基祖，于清道光年间从七拱镇新岗村拱桥头（俗称“旧李屋”）迁居新李屋开枝散叶。妣陈氏、莫氏，生五子，依次分为五房：第一房圣章公、第二房勋章公、第三房麟章公、第四房球章公、第五房瑞章公（详情见《新李屋第一房圣章公家谱》序）。弦文公墓葬于七拱佛仔岗大菜园中间，陈氏葬于七拱徐屋边。第一房圣章公世系</p>
<p>十四世祖：②圣章公生颜魁</p>
<p>十五世祖：③颜魁公妣黄氏，生二子：家桃、家基十六世祖：④家桃，号称“生毛桃”，妻邓、陈氏，邓氏阳山县太平镇杏棠恒尾村人士，陈氏系阳山县水口镇鱼水人士。邓氏生国象、国锋、陈氏生国志、维（女）（嫁阳山县七拱镇莫屋）；陈氏生轻（女）（嫁阳山县七拱镇大塘莫屋）。</p>
<p>十六世祖：④家基，生一子：国楚，一女：满。嫁阳山县高峰镇。</p>
<p>十七世祖：⑤国象，娶妻谢友娣，阳山县七拱镇吉地屈人士，生子仕文、仕胜，生女三妹（嫁广东省广宁县赤坑）十七世祖：⑤国锋，生二女，运（嫁阳山县杨梅镇白屋温氏）、娇（嫁阳山县青莲镇大垌村，早年举家迁徙清远市清城区源潭镇）</p>
<p>《新李屋李氏第一房圣章公家谱》序家之有谱，犹国之有史也。家谱则以序昭穆，明亲疏，联宗而恳亲，使人笃亲亲之心，而兴孝弟之念也。据历史文献记载，吾李氏出自嬴姓，皋陶之后，世仕大理，以官命族为理氏。商纣无道，理征犯颜直谏，不容于上。其子利贞逃难于伊候之墟，食木子（李）以全，又因理、李同音通用，遂改理氏为李氏。故李姓血缘自皋陶，得姓自利贞。李氏历史源远流长，利贞垂今数千载，据传，火德公，字丙凤，号闽海，于宋开禧二年丙寅岁（1206）十一月初八子时，出生于宁化石壁村。按福建李氏族谱记载，李火德属陇西李氏的27世裔孙。本谱尊始迁广东省阳山县太平镇大城岗村应春公为始祖，即以应春公为第一世祖，应春公自远祖火德公派下第十世之裔。吾祖弦文公为新李屋村开基祖，是火德公直下第二十二世孙、应春公第十三世孙，弦文公号称“银鬼火”，弦文公于清道光年间在阳山县七拱镇新岗拱桥头原籍邻近一处建造了几间简陋的平房，携妻带儿从拱桥头原籍迁到新建造的平房居住，并称新的居住地为“新李屋”，至今新李屋村已有二百余年的历史，族发至十余世矣。据传，一天，远方客人到“新李屋”村探访弦文公，吾公为接待来宾，亲自捕捉自养的鸡接待宾客，当吾公捕捉鸡时，其中一只白毛鸡飞驰跑到了屋背后一土堆之洞穴藏身，当吾公伸手抓获白毛鸡时发现洞穴内隐隐约约露出有一个瓦缸，于是回家拿来锄头挖掘，一挖就挖出几个大瓦缸，当吾公打开缸盖时眼睛一亮，突然发现缸内全是装满闪闪发光的白银。后来，弦文公在“新李屋”村进行了扩建青砖结构的房屋。据考，弦文公夫妇为人善良大方，聪明伶俐，对人慷慨有加，一生勤耕苦种。弦文公夫妇经数十年的艰苦奋斗和省吃俭用，略有些许积累，再在新李屋建造了数十间青砖结构的房屋，其中有六幢是“木耳楼”。弦文公生五子，依次为：圣章、勋章、陆章、求章、瑞章，分为五房，子子孙孙承祖庇荫，自弦文公建村至今还没有建立过《新李屋李氏族谱》，余恐世远人繁，不无遗憾。今嘱长女婿成尚鸿协助编辑《新李屋第一房圣章公家谱》，为将来辑纂《新李屋李氏族谱》打下基础，待以后集五房之谱编纂成一部完整的《新李屋李氏族谱》。今借此抛砖引玉，是为序。弦文公第六世裔孙李仕胜拜撰二○一三年季冬于新李屋阳山县太平镇大城岗李氏开基祖世系始祖：应春公，娶妻成氏、陈氏。生九子一女：小一字日龙、小二字日虎、小三字日青、小四字日寿、小五字日元、小育字日育、小宋字日宋、小新字日细、小弟字日尽、小郎字日天（养子）。二世祖十大房分列如下：二世祖：第一房小一公，迁徙湖北省加禾、广东省连州第二房小二公，迁徙广东英德市荷木岗、阳山县杜步镇梅冲村。第三房小三公，生评公，迁徙阳山县七拱镇社岗山塝第四房小四公，迁徙湖北省安陆县第五房小五公，生义禄，在阳山县太平镇大城岗原地居住。第六房小育公，生义公（居阳山县太平镇大城岗天升塘、吊水村）、亮公（迁徙广东怀集县凤岗镇石竹埇松岗村）、荣公（迁徙阳山县黎埠镇水井村）第七房小宋公字日宋，配成氏，生子：盛公（迁居阳山县七拱镇新岗村寨孔）、洪、晚（迁徙广东怀集县），宋公墓葬于阳山县太平镇雷家寨山坳，坐西向东。第八房小新公，生子：舒（迁居阳山县七拱镇佳礼垌）、保（迁徙广东怀集县）、晚（迁徙广东怀集县中洲镇良村）。第九房小弟公，生一子：文实，迁居阳山县江英镇第十房小郎公（应春公养子），迁居阳山县太平镇大城岗田心围。三世祖：盛公，配成氏，由阳山县太平镇大城岗迁居阳山县七拱镇新岗寨孔村，生三子：珍（迁徙阳山县城）、宝（阳山县高峰乡、小江镇西岭、黎埠镇水井之祖）、旺。盛公墓葬于阳山县太平镇雷家寨山坳，坐庚向东甲兼卯酉分金。四世祖：旺公，配成氏，生五子：良珠（迁居阳山县小江黄牛滩）、良玹（迁居阳山县黎埠镇水井）、良琚（迁徙清远横石）、良瓒（在七拱镇新岗寨孔原地居住）、良琏（迁居阳山县七拱镇新岗村拱桥头）五世祖：良琏，由寨孔村迁居相邻的七拱镇新岗村拱桥头，生五子：日俭、日恒、日新、日硕、日勤。琏公墓葬于阳山县七拱镇蛇坑尾杨屋右边半山头。六世祖：日俭，妣黄氏，生三子：向上、向高、向兆。日俭公墓葬于阳山县七拱镇蛇坑尾杨屋右边涌尾。黄氏墓葬于阳山县七拱镇佛仔岗大菜园边。七世祖：向兆公，字品属，妣成氏，生子：亦安。向兆公墓葬于阳山县七拱镇佛仔岗大菜园田边。乾山巽向兼亥巳分金。八世祖：亦安公，妣黄氏，生三子：悠芬、悠芳、悠秀。亦安公墓葬于阳山县七拱镇佛仔岗大菜园田边。乾山巽向兼亥巳分金。黄氏墓葬于阳山县七拱镇浪子岗四方楼屋背。九世祖：悠芬公，妣谢氏，生一子：卓贤。悠芬公葬于阳山县七拱镇塘坪村山心岭，谢氏葬于阳山县七拱镇佛仔岗大菜园田边十世祖：卓贤，妣陈氏，生二子：恒言、恒道，十一世祖：恒言公，妣谢氏，生二子：为山（迁居与新李屋相邻的蓝灰屋）、鉴山。谢氏葬于七拱钟木生背田垅。十二世祖：鉴山公，妣莫氏，生一子：弦文新李屋开基祖弦文公十三祖：①弦文公，号“银鬼火”为阳山县七拱镇新李屋开基祖，于清道光年间从七拱镇新岗村拱桥头（俗称“旧李屋”）迁居新李屋开枝散叶。妣陈氏、莫氏，生五子，依次分为五房：第一房圣章公、第二房勋章公、第三房麟章公、第四房球章公、第五房瑞章公（详情见《新李屋第一房圣章公家谱》序）。弦文公墓葬于七拱佛仔岗大菜园中间，陈氏葬于七拱徐屋边。第一房圣章公世系十四世祖：②圣章公生颜魁十五世祖：③颜魁公妣黄氏，生二子：家桃、家基十六世祖：④家桃，号称“生毛桃”，妻邓、陈氏，邓氏阳山县太平镇杏棠恒尾村人士，陈氏系阳山县水口镇鱼水人士。邓氏生国象、国锋、陈氏生国志、维（女）（嫁阳山县七拱镇莫屋）；陈氏生轻（女）（嫁阳山县七拱镇大塘莫屋）。十六世祖：④家基，生一子：国楚，一女：满。嫁阳山县高峰镇。十七世祖：⑤国象，娶妻谢友娣，阳山县七拱镇吉地屈人士，生子仕文、仕胜，生女三妹（嫁广东省广宁县赤坑）十七世祖：⑤国锋，生二女，运（嫁阳山县杨梅镇白屋温氏）、娇（嫁阳山县青莲镇大垌村，早年举家迁徙清远市清城区源潭镇）火德直系简线图火德——三一郎——百三郎——千二郎——明一郎——福四郎——义——栋——怡——应春——小宋——盛、洪、晚——珍、宝、旺——良珠、良珍、良琚、良赞、良连——日俭、日恒、日新、日硕、日勤——向上、向高、向兆——亦安——悠芬、悠芳、悠秀——卓贤——恒言、恒道——为山、鉴山——弦文（迁新李屋）——圣章、勋章、陆章、求章、瑞章——颜魁——家桃、家基——国象、国锋小宋公十三世始排的辈份诗为：文章魁家国，仕子振召堂。弦文公迁居新李屋后自立“爱贤堂”堂号。附1新李屋第二至第五房简略世系第二房勋章公简略世系②叔祖勋章——③响魁——④家声、家仁、家余。④家声——⑤国昌、国栋；⑤国昌——⑥仕海——⑦新兴、继河、志良；⑤国栋——⑥仕来——⑦志明第三房麟章公简略世系②叔祖麟章公无后，由第五房过继。第四房球章公简略世系②叔祖球章——③奇魁、耀魁、汉魁、鹏魁、威魁。③鹏魁——④家永、家轩、家庆、顺养。④家庆——⑤东生、国锡。⑤东生——⑥继同、添青、剑锋；⑤国锡——⑥仕廷、仕森。第五房瑞章公简略世系②叔祖瑞章——③槐魁——④家礼、家赞、家振。④家礼——⑤国潭、国绍、国富、国安、国乐。⑤国富——⑥仕发、仕健、仕科；⑤国绍——⑥仕双、翠义。⑥仕双——⑦子川、子亮。④家赞——⑤国辉——⑥芬、广。⑤国乐——⑥仕卫——⑦东海、子康。⑤国潭——⑥仕坚、仕周。⑥仕坚——⑦子敏；⑥仕周——⑦子奇。④家振——⑤国德——⑥仕锦——⑦志冲注：以上“①┉┉⑩”代表新李屋第几世（代）。附2火德公至应春公世系第一代：火德公，妾陈氏生男：三一郎、三二郎、三三郎；女：桂英、涉英。第二代：三一郎，妣邱氏、田氏，生六子：百一郎、百二郎、百三郎、千三郎、千四郎、百十郎。第三代：百三郎，妣钟氏、郑氏、吕氏。生三子：千二郎、千八郎、千九郎。第四代：千二郎，妣陈氏，生明一郎第五代：明一郎，妣黄氏，生福四郎第六代：福四郎，妣黄氏，生三子：君、臣、义。君公带福四郎金骨到广东省乳源县百竹面隧而葬，福四郎墓地为马形，如将军骑马。吉地坐西向东，墓地葬在乳源县古母水白竹村对面，此墓称为广东省李氏总坟第七代：义公从福建上杭县官田村迁徙到广东广州市九眠井（现广州市解放北路科学馆内有九眼石碑）定居，开枝发族。生一子：栋公。第八代：栋公，定居广州高大街，生三子：侃、绚、怡。第九代：怡公生应春公。第十代：应春公，从广州高大街迁居阳山县通儒坊迳口，后再迁徙阳山县太平镇大城岗定居。娶妻成氏、陈氏。生九子一女：小一字日龙、小二字日虎、小三字日青、小四字日寿、小五字日元、小育字日育、小宋字日宋、小新字日细、小弟字日尽、小郎字日天（养子）。火德公祠位于福建省龙岩市上杭县稔田镇。始建于清道光十六年，供奉李氏入闽始祖李火德。800年来其后裔遍布闽，台，粤，桂，赣及东南来各国。火德祠自然成为福建和东南来李氏宗亲的大本营。祠堂是座古典式的庙堂，坐北朝南，三进四直的砖木结构建筑仍为罕见。整个祠堂呈“回”字形，前方后圆，前低后高。正面设有五孔大门。正中的大门是用灰青条石，石板砌成的碑坊式门楼。另外四孔，分设东西二边。大门碑坊楼上，有一块长方形石棉絮，刻着清道光皇帝御赐的“恩荣”二字。完祠内的11对大圆石柱，都能是用木般从福建长汀运来的。宗祠占地面积5600平方米，共有大小房间130间。宗祠四面环山叠翠，黄潭河蜿蜒而过，风景秀丽。附4 火德公的故事略考关于他的故事甚多，有位叫松山贞子的人写下了数万字的《李火德之谜》。有两个故事流传甚广：一是李火德63岁仍无子嗣，由原配伍氏亲自作媒，娶邻居陈梅山19岁女儿，继而陈氏连生3子2女。二是李火德去世后出殡之时，行至半路突然电闪雷鸣，倾盆大雨，送殡的人只好将灵柩就地停放，回屋暂避。很快雨过天青，众人只见停放灵柩的地方竟然陷了下去，成了一汪水，棺木也沉了下去，微露顶盖。这时地理先生恍然大悟：“此乃天陷坟穴，曰‘螃蟹游湖’，就此建坟，大吉大利。”又说：“‘游’者主向外，有水方能游，他日后代往外，遇水立业，必有所成。”</p>
<p>　　地理先生一席话，火德子孙代代传。丰朗村李氏全部外迁，一代一代不断向外拓展。二零一四年仲春新李屋首立族谱（首印三册，不得外借，注意珍惜保存）</p>
<p>英德黄花溪村李氏是火德公长子三一郎的后裔分支。该支李氏的开基始祖名臣，号初一，是火德公的七世孙。其父福四郎原居祖居地上杭，明初携带李君、李臣、李义三子入粤发展。</p>
<p>嗣后，长子李君侍奉老父，留居乳源古母水。次子李臣携妻于明永乐四年（1406年）徙居英德黄花溪村开创基业，现在清新浸潭（不含桃源）、禾云等地的上万名李姓人中，绝大多数都是李臣的后裔。</p>
<p>季子李义迁广州城内九眼井定居，其曾孙辈中有个叫李应春的人，复从广州北迁到阳山太平大城岗肇基创业，后裔散布阳山、清新、英德、连州、怀集及湘桂边境县地。今阳山4万多李姓人中，其裔占大多数。</p>
<p>英德大站璟头李氏，开基祖李公政亦属火德公后裔，明洪武年间由福建上杭迁来。后裔散布大站、九龙等地，计有3000余人。英德横石塘、云岭、石牯塘一带有上万李姓人，据当地李氏族人提供的资料称，他们都是火德公的后裔。</p>
<p>第一代：火德公（1206-1292），名炳凤，字闽海，号伯庄，生于福建宁化县石壁村。妾陈氏生三男：长元培（三一郎）、次乾培（</p>
<p>三二郎）、三坤培（三三郎）。二女：桂英、涉英。</p>
<p>第二代：三一郎公（1269-1339），原名官懋，字朝文，号元培，讳堡深，以名思荣。妣邱氏、田氏，生六子：百一郎、百二郎、百</p>
<p>三郎、千三郎、千四郎、百十郎。</p>
<p>第三代：百三郎，妣钟氏、郑氏、吕氏。生三子：千二郎、千八郎、千九郎。</p>
<p>第四代：千二郎，妣陈氏，生明一郎</p>
<p>第五代：明一郎，妣黄氏，生福四郎</p>
<p>第六代：福四郎，妣黄氏，生三子：君、臣、义。君公带福四郎金骨到广东省乳源县百竹面隧而葬，福四郎墓地为马形，如将军骑</p>
<p>马。吉地坐西向东，墓地葬在乳源县古母水白竹村对面，此墓称为广东省李氏总坟。</p>
<p>第七代：义公从福建上杭县官田村迁徙到广东广州市九眠井（现广州市解放北路科学馆内有九眼石碑）定居，开枝发族。生一子：</p>
<p>栋公。</p>
<p>第八代：栋公，定居广州高大街，生三子：侃、绚、怡。</p>
<p>第九代：怡公生应春公。</p>
<p>第十代：应春公，从广州高大街迁居阳山县通儒坊迳口，后再迁徙阳山县太平镇大城岗定居。娶妻成氏、陈氏。生九子一女：小一</p>
<p>字日龙、小二字日虎、小三字日青、小四字日寿、小五字日元、小育字日育、小宋字日宋、小新字日细、小弟字日尽、小郎字日天</p>
<p>（养子）。</p>
<p>七世祖  德荣公墓志铭</p>
<p>处士讳德荣，上杭闻人也，上祖火德翁出自宁化石壁李家坊，因时扰攘来奔于上杭胜运里丰朗因家焉，四传至千八郎，以通经幹才授巡宰，七传至处士有兄弟五人，曰百五郎者，其嶷不凡，善习武事，遭草寇作乱，举为队长，虽未拜官，常与总戌参议，如幕宾然可谓有为之士矣，惟处士至少，自三岁失父，惟鞠于母邱氏，性至孝，谨遵母训不敢违，且体貌丰厚，性资宽和，有长者气象，时诸兄虽同爨而勤于克家，不待劝戒而自励，凡所历皆有条理，人皆以为不能及，或治公府事，一以济人利下为心，虽有弗便于公者不顾，在官者初亦不然，终听之，乡人为强横所屈者，必为之解释，至于争颂不直者，不闻于官，愿求决于处士，处士惟一言定之，两情说服，至今邑人称之不已，洪武辛亥（1371）母病笃，每稽颡北辰，求以身代，既而母卒，顷间其色大变，鼻血涌出，子姓来吊者皆惊疑，处士独抱母嚼而吞之，其容遂复生，人咸谓孝感所至。厥后置买田扩地址园林二十余顷，迨春秋已高，屡举乡饮，此诚有德有福之先达者也，四子诚领乡荐拜官历系开封府教授，又遣曾孙勉继游庠校，今为国公生，駸駸向用，则天之报于处士者不爽矣，公生于元至正八年戌（戊）子岁（公元1348年）十月二十日戌时，卒于明永乐甲辰岁（公元1424年）十二月十四日巳时，享年七句（旬）有七寿，娶妻张氏有淑德，生七子，文读、崇山、光眼、崇茂、诚、普孜、崇生，生二女：八姑适刘文聪、满姑适许永良，男孙十二、宗源、宗良、宗盛、宗文、宗实、宗评、宗政、宗贤、宗胤、宗琼、宗璘、宗玑。女孙十一：曾孙三十五，曾女孙二十一，玄孙二十六  玄孙（女）十四（共有子孙135人）。一日勉踵于告曰，曾祖已葬久矣，尚未志其墓，家君以勉亲迩名公，故命勉来征文以纪之，予按状，则知处士之德及于人，而人多德者尚在，称予文何足以张之，虽然予以芜陋可辞，而终不可辞，况勉氏今在太学醇厚俊雅，文行足称，其禄任有期矣，他日，圣朝推二叶之恩，以光幽潜，则予文岂不预有光焉，乃为了铭曰：</p>
<p>貌庄而重，体厚而丰，柔惠且直，顒顒昂昂，孝义克全，乡帮欢服，寿及期颐，会终有俶，天赐贤胤，既官而文，厥后寝昌，从以曾孙，显融在兹，足表先德，我作铭诗，用勒于石”</p>
<p>赐进士及第右春坊左庶子翰林院侍讲经筵官连江赵恢撰</p>
<p>——摘自1991年版《李氏厚公族谱》   </p>
<p>德荣公生卒终于搞清楚了！即生于元至正八年戌（戊）子岁（公元1348年）十月二十日戌时，卒于明永乐甲辰岁（公元1424年）十二月十四日巳时</p>
<p>谢谢宗亲关注！这个德荣公的垂直世系是：火德公——三三郎公——四六郎公——千八郎公——念三郎公——万二郎公——德荣公</p>
<p>五华族谱记载兄弟五人是：子华、子贵、子仁、子寿、子荣（德荣）？</p>
<p>但世系有二种</p>
<p>1、五华谱记载：德荣世系是：1火德-2三一郎（乾培）-3百一郎（利生）-4千八郎-5念三郎-6万三郎（字永良号应山）－7万亿－8德明－9守正－10万二郎（仲春）－11子荣（德荣）－12崇诚（明善）？</p>
<p>2、上杭族谱记载：德荣公的垂直世系是：火德公——三三郎公——四六郎公——千八郎公——念三郎公——万二郎公——德荣公</p>
<p>这两个世系哪个对呢？</p>
<p>     我认为应该是五华世系对！理由是：上杭世系错接了千八郎，在广东始兴发现了千八郎、万一郎墓，万一郎次子寿山公（子德明，李光耀先祖）直系后裔一直在祭拜，对比五华族谱，李崇诚曾祖父千八郎就是八世德明（我谱德达）！而四六郎子千八郎葬福建上杭蔡坑，与李崇诚曾祖父千八郎明显不同！这是千古之谜！</p>
<p>    难怪李崇诚于湖广永州府永明县邑庠之明伦堂在家谱谱序中写道：“诚尝闻父命曰：李氏先散处郡邑逮三百家，虽知同所自出，而图谱迷失，昭穆远近不可得而知也。”和“故自始祖火德公至于吾父德荣，既七世矣，其或有遗阙，非略也。”，可见李崇诚也不敢肯定就是火德公八世！古人治学严谨可见一斑！</p>
<p>    谢谢宗亲认真研究！</p>
<p>此资料是李亚相宗亲收集到的，为了证明他考求的火德公生于1146年是正确的，他又将这几页的复印件转寄与我，因此，没有墓碑原件（可能是从老谱转录的，不知还有无墓碑？因其是上杭官田人，坟墓自然是在上杭官田无疑）。据李亚相说：此是李人旺家族的族谱，从资料看，好像是李（崇）诚之兄李崇山系的族谱。因李亚相是很严谨的人，应该不会错传。至于宗亲说哪个世系正确的问题，我不便争论，我只是认为火德公的子孙多，带“郎”字同名的特别多；还有，李明善自称是火德公八世孙，应该是他当时考证后认为最正确的结论，为了慎重起见，他说了一句“其或有所遗”，后人就根据这句话推断他确实遗漏了几代人，我认为这种推断不一定正确。况且，从资料看，自火德公到李（崇）诚也只有八世。</p>
<p>谢谢正雄宗长释疑！</p>
<p>     我谱有李崇诚兄崇茂公族谱，我在天下李氏网已论证了德荣公生年的正确！此次墓志铭的发现再次证明德荣公生1348年是对，得出以我谱一致结论。现在关键是在整理族谱的过程中，发现了李崇诚之曾祖千八郎之墓与葬上杭之千八郎不同！显然是两个千八郎！各位宗亲扪心自问，不再搞清楚怎么对得起祖宗呢？我没有一定要搞清每个火德公，最起码要搞清李崇诚家族之火德公，何错之有呢？</p>
<p>现在可以肯定德荣公生1348年，崇山生1370年正确，如果真是这样，按李崇诚火德公八代算，一代25–30岁，三三郎应在1348–150或125=（1198年–1223年）生，火德公生年：1198或1223-67=1131年–1156年。按火德公传说的生丙寅年，应是1146年，这与李亚相宗亲考察相近。但是问题是李崇诚曾祖千八郎搞错了！李崇诚曾祖千八郎不是葬上杭千八郎！李崇诚按五华族谱是火德公12代孙！这些问题希望能够得到德高望重的李亚相宗长和各位谱学专家的重视！毛主席说过没有调查没有发言权，不要不做考证，以讹传讹！</p>
<p><a href="http://www.lsw.cc/bbs/thread-247852-1-1.html">http://www.lsw.cc/bbs/thread-247852-1-1.html</a></p>
<p>又发现有世系为：1火德-2三一郎（乾培）-3百一郎（利生）-4千八郎-5念三郎-6万三郎（字永良号应山）－7万亿－8德明－9守正－10万二郎（仲春）－11子荣（德荣）－12崇诚（明善）。</p>
<p>德荣公墓志铭</p>
<p>　　处士讳德荣，上杭闻人也，上祖火德翁出自宁化石壁李家坊，因时扰攘来奔于上杭胜运里丰朗因家焉，四传至千八郎，以通经幹才授巡宰，七传至处士有兄弟五人，曰百五郎者，其嶷不凡，善习武事，遭草寇作乱，举为队长，虽未拜官，常与总戌参议，如幕宾然可谓有为之士矣，惟处士至少，自三岁失父，惟鞠于母邱氏，性至孝，谨遵母训不敢违，且体貌丰厚，性资宽和，有长者气象，时诸兄虽同爨而勤于克家，不待劝戒而自励，凡所历皆有条理，人皆以为不能及，或治公府事，一以济人利下为心，虽有弗便于公者不顾，在官者初亦不然，终听之，乡人为强横所屈者，必为之解释，至于争颂不直者，不闻于官，愿求决于处士，处士惟一言定之，两情说服，至今邑人称之不已，洪武辛亥（1371）母病笃，每稽颡北辰，求以身代，既而母卒，顷间其色大变，鼻血涌出，子姓来吊者皆惊疑，处士独抱母嚼而吞之，其容遂复生，人咸谓孝感所至。厥后置买田扩地址园林二十余顷，迨春秋已高，屡举乡饮，此诚有德有福之先达者也，四子诚领乡荐拜官历系开封府教授，又遣曾孙勉继游庠校，今为国公生，駸駸向用，则天之报于处士者不爽矣，公生于元至正八年戌（戊）子岁（公元1348年）十月二十日戌时，卒于明永乐甲辰岁（公元1424年）十二月十四日巳时，享年七句（旬）有七寿，娶妻张氏有淑德，生七子，文读、崇山、光眼、崇茂、诚、普孜、崇生，生二女：八姑适刘文聪、满姑适许永良，男孙十二、宗源、宗良、宗盛、宗文、宗实、宗评、宗政、宗贤、宗胤、宗琼、宗璘、宗玑。女孙十一：曾孙三十五，曾女孙二十一，玄孙二十六  玄孙（女）十四（共有子孙135人）。一日勉踵于告曰，曾祖已葬久矣，尚未志其墓，家君以勉亲迩名公，故命勉来征文以纪之，予按状，则知处士之德及于人，而人多德者尚在，称予文何足以张之，虽然予以芜陋可辞，而终不可辞，况勉氏今在太学醇厚俊雅，文行足称，其禄任有期矣，他日，圣朝推二叶之恩，以光幽潜，则予文岂不预有光焉，乃为了铭曰：  </p>
<p>貌庄而重，体厚而丰，柔惠且直，顒顒昂昂，孝义克全，乡帮欢服，寿及期颐，会终有俶，天赐贤胤，既官而文，厥后寝昌，从以曾孙，显融在兹，足表先德，我作铭诗，用勒于石”  </p>
<p>赐进士及第右春坊左庶子翰林院侍讲经筵官连江赵恢撰</p>
<p>——摘自1991年版《李氏厚公族谱》</p>
<p>注：百度——赵恢，字汝弘，号文峰，连江县江南人。他是明代著名学者、文学家，生于明洪武丁丑年(1397)，卒于明天顺酉年(1457)年，终年61岁。</p>
<p>李德荣（1348—1424），寿77岁。</p>
<p>有旧序称德荣是火德公七世孙，如果按父1206年生的火德公，子三三郎坤培约生1271年，则5代世系均代差值为15.4岁（值偏小，不符合正常值），疑有漏掉。</p>
<p>又发现有世系为：1火德-2三一郎（乾培）-3百一郎（利生）-4千八郎-5念三郎-6万三郎（字永良号应山）－7万亿－8德明－9守正－10万二郎（仲春）－11子荣（德荣）－12崇诚（明善）。</p>
<p>按火德公生于966年，子坤培公约生1029年，11代世系均差值为29岁（值正常）。</p>
<p>李德荣（1348—1424），寿77岁。</p>
<p>有旧序称德荣是火德公七世孙，如果按父1206年生的火德公，子三三郎坤培约生1273年，则至德荣公5代世系均代差值为15岁（值偏小，不符合正常值），疑有漏掉。</p>
<p>又发现有世系为：1火德-2三一郎（乾培）-3百一郎（利生）-4千八郎-5念三郎-6万三郎（字永良号应山）－7万亿－8德明－9守正－10万二郎（仲春）－11子荣（德荣）－12崇诚（明善）。</p>
<p>按火德公生于966年，子坤乾培公约生1029年，则至德荣公9代世系均差值为35.4岁（值正常）。</p>
<p>按清朝雍正十三年（1735）乙卯岁李象元手撰序广东嘉应州火德公《附祠堂序》，6世李万三郎生子永良，多一世来计算，则乾培到德荣公10代世系代差值为：31.9岁（值正常）。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>三种解析Xml方法 DOM 和Pull 和 SAX</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%B8%89%E7%A7%8D%E8%A7%A3%E6%9E%90Xml%E6%96%B9%E6%B3%95%20DOM%20%E5%92%8CPull%20%E5%92%8C%20SAX/</url>
    <content><![CDATA[<p>一般来说，解析Xml 有三种方法</p>
<p>分别是 DOM 和Pull 和 SAX</p>
<p>DOM一般用去解析比较小的XML文件。因为DOM要把整个文件读取才解析的，如果是很大的文件，那就是卡死了。</p>
<p>SAX，听说是一种事件驱动型的轻量级的解析器，用DOM来解析，比较节省内存。</p>
<p>Pull呢，与SAX差不多，Android本身附带的解析器，与Sax的区别在于，pull解析时，解析过程是可控的，解析完所要的内容后即可停止。</p>
<p>下面用三种方法解析以下Xml文件：</p>
<p>这是在做快递查询工具时所用的Xml：</p>
<p>&lt;?xml  version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</p>
<p>&lt;xml&gt;</p>
<p>&lt;message&gt;ok&lt;/message&gt;</p>
<p>&lt;status&gt;1&lt;/status&gt;</p>
<p>&lt;data&gt;</p>
<p>&lt;time&gt;2011-09-12 18:43:00&lt;/time&gt;</p>
<p>&lt;context&gt;签收人是：星祺绿&lt;/context&gt;</p>
<p>&lt;/data&gt;</p>
<p>&lt;/xml&gt;</p>
<p>首先，要把Xml转化为输入流。下面在本地读取Xml</p>
<p>private InputStream readLocalXml()  </p>
<p>     {       </p>
<p>      InputStream inStream =  null;  </p>
<p>try {  </p>
<p>     inStream =  this.getResources().getAssets().open(&quot;test.xml&quot;);  </p>
<p>       }  catch (IOException e) {  </p>
<p>//  TODO  Auto-generated catch block  </p>
<p>      e.printStackTrace();  </p>
<p>      }  </p>
<p>       Log.d(&quot;XML&quot;,inStream.toString());</p>
<p>return inStream;  </p>
<p>     }  </p>
<p>也可以从网上直接读取，可惜，大一新生来之后，学校的GPRS都很不给力了。经常得不到所要的Xml，所以我把Xml存在本地再来解析。下面是从网上获取Xml：</p>
<p>private InputStream readFromServer() {</p>
<p>       URL infoUrl =  null;</p>
<p>       InputStream inStream =  null;</p>
<p>try {</p>
<p>           infoUrl =  new URL(&quot;<a href="http://api.kuaidi100.com/apione?com=shunfeng&amp;nu=107184228871&amp;show=1">http://api.kuaidi100.com/apione?com=shunfeng&amp;nu=107184228871&amp;show=1</a>&quot;);</p>
<p>           URLConnection connection = infoUrl.openConnection();</p>
<p>           inStream = connection.getInputStream();</p>
<p>       }  catch (Exception e) {</p>
<p>//  TODO  Auto-generated catch block</p>
<p>           e.printStackTrace();</p>
<p>       }</p>
<p>return inStream;</p>
<p>    }</p>
<p>得到输入流之后呢，就可以解析了。</p>
<p>DOM解析</p>
<p>public  void readXmlByDOM(InputStream in) {</p>
<p>factory = DocumentBuilderFactory.newInstance();</p>
<p>try {</p>
<p>builder =  factory.newDocumentBuilder();</p>
<p>document =  builder.parse(in);</p>
<p>document.normalize();</p>
<p>           Log.d(&quot;XML&quot;,  &quot;______Parse By DOM&quot;);</p>
<p>           NodeList nodes =  document.getElementsByTagName(&quot;*&quot;);//根</p>
<p>           Log.d(&quot;XML&quot;,  &quot;____________root:&quot; + nodes.item(0).getNodeName());         </p>
<p>//根据元素标签来查找</p>
<p>           NodeList nodes11 =  document.getElementsByTagName(&quot;message&quot;);</p>
<p>           String message = nodes11.item(0).getNodeName();//元素</p>
<p>           Log.d(&quot;XML&quot;,  &quot;___________&quot; + message +  &quot;:&quot;</p>
<p>                  + nodes11.item(0).getFirstChild().getNodeValue());//内容</p>
<p>           NodeList nodes12 =  document.getElementsByTagName(&quot;status&quot;);</p>
<p>           String status = nodes12.item(0).getNodeName();</p>
<p>           Log.d(&quot;XML&quot;,  &quot;___________&quot; + status +  &quot;:&quot;</p>
<p>                  + nodes12.item(0).getFirstChild().getNodeValue());</p>
<p>           NodeList nodes13 =  document.getElementsByTagName(&quot;time&quot;);</p>
<p>           String time = nodes13.item(0).getNodeName();</p>
<p>           Log.d(&quot;XML&quot;,  &quot;___________&quot; + time +  &quot;:&quot;</p>
<p>                  + nodes13.item(0).getFirstChild().getNodeValue());</p>
<p>           NodeList nodes1 =  document.getElementsByTagName(&quot;context&quot;);</p>
<p>           String context = nodes1.item(0).getNodeName();</p>
<p>           Log.d(&quot;XML&quot;,  &quot;___________&quot; + context +  &quot;:&quot;</p>
<p>                  + nodes1.item(0).getFirstChild().getNodeValue());</p>
<p>       }  catch (Exception e) {</p>
<p>           Log.d(&quot;XML&quot;, e.toString());</p>
<p>       }</p>
<p>    }</p>
<p>SAX解析：</p>
<p>public  void readXmlSaxParser(InputStream in) {</p>
<p>       SAXParserFactory spf = SAXParserFactory.newInstance();</p>
<p>try {</p>
<p>           SAXParser parser = spf.newSAXParser();</p>
<p>           parser.parse(in,  new XmlContentHandler());</p>
<p>           Log.d(&quot;XML&quot;,  &quot;______Parse By SAX&quot;);</p>
<p>       }  catch (Exception e) {         </p>
<p>       }</p>
<p>    }</p>
<p>Sax解析，需要一个Handler来监控各种事件</p>
<p>public  class XmlContentHandler  extends DefaultHandler {</p>
<p>     String  localName=&quot;&quot;;</p>
<p>@Override</p>
<p>public  void startDocument()  throws SAXException {</p>
<p>       Log.d(&quot;XML&quot;,  &quot;_________start&quot;);</p>
<p>    }</p>
<p>@Override</p>
<p>public  void startElement(String uri, String localName, String qName, Attributes attributes)  throws SAXException {</p>
<p>this.localName = localName;</p>
<p>    }  </p>
<p>@Override</p>
<p>public  void endDocument()  throws SAXException {</p>
<p>//  TODO  Auto-generated method stub</p>
<p>       Log.d(&quot;XML&quot;,  &quot;_________end&quot;);</p>
<p>    }</p>
<p>@Override</p>
<p>public  void characters(char[] ch,  int start,  int length)  throws SAXException {</p>
<p>if(localName.equals(&quot;message&quot;)){</p>
<p>       String  text =  newString(ch,start,length);      </p>
<p>        Log.d(&quot;XML&quot;,  &quot;<strong><strong>____</strong></strong>&lt;&lt;&lt;message:&quot; + text);}</p>
<p>if(localName.equals(&quot;status&quot;)){</p>
<p>              String  text =  newString(ch,start,length);      </p>
<p>               Log.d(&quot;XML&quot;,  &quot;<strong><strong>____</strong></strong>&lt;&lt;&lt;status:&quot; + text);}</p>
<p>if(localName.equals(&quot;time&quot;)){</p>
<p>              String  text =  newString(ch,start,length);      </p>
<p>               Log.d(&quot;XML&quot;,  &quot;<strong><strong>____</strong></strong>&lt;&lt;&lt;time:&quot; + text);}</p>
<p>if(localName.equals(&quot;context&quot;)){</p>
<p>              String  text =  newString(ch,start,length);      </p>
<p>               Log.d(&quot;XML&quot;,  &quot;<strong><strong>____</strong></strong>&lt;&lt;&lt;context:&quot; + text);}</p>
<p>    }</p>
<p>@Override</p>
<p>public  void endElement(String uri, String localName, String qName)  throws SAXException {</p>
<p>this.localName=&quot;&quot;;</p>
<p>    }</p>
<p>Pull解析，轻量级，简单好用。一般我选用这种。</p>
<p>public  void readXmlByPull(InputStream in) {</p>
<p>       Log.d(&quot;XML&quot;,  &quot;______Parse By Pull&quot;);</p>
<p>try {</p>
<p>// 方式一:使用工厂类XmlPullParserFactory</p>
<p>// XmlPullParserFactory pullFactory = XmlPullParserFactory</p>
<p>// .newInstance();</p>
<p>// XmlPullParser xmlPullParser = pullFactory.newPullParser();</p>
<p>// 方式二:使用Android提供的实用工具类android.util.Xml</p>
<p>           XmlPullParser xmlPullParser = Xml.newPullParser();</p>
<p>           xmlPullParser.setInput(in,  &quot;utf-8&quot;);         </p>
<p>int eventType = xmlPullParser.getEventType();</p>
<p>boolean isDone =  false;//退出标志,读完所需至true即可退出</p>
<p>while ((eventType != XmlPullParser.END_DOCUMENT)</p>
<p>                  &amp;&amp; (isDone !=  true)) {</p>
<p>              String localName =  null;</p>
<p>switch (eventType) {</p>
<p>case XmlPullParser.START_DOCUMENT:</p>
<p>                  Log.d(&quot;XML&quot;,  &quot;begin to pull the xml&quot;);</p>
<p>break;</p>
<p>case XmlPullParser.START_TAG:</p>
<p>                  localName = xmlPullParser.getName();</p>
<p>if (&quot;message&quot;.equals(localName)) {</p>
<p>                     String message = xmlPullParser.nextText();</p>
<p>                     Log.d(&quot;XML&quot;,  &quot;<strong><strong>____</strong></strong>&lt;&lt;&lt;message:&quot; + message);</p>
<p>                  }  else  if (&quot;status&quot;.equals(localName)) {</p>
<p>                     String status = xmlPullParser.nextText();</p>
<p>                     Log.d(&quot;XML&quot;,  &quot;<strong><strong>____</strong></strong>&lt;&lt;&lt;status:&quot; + status);</p>
<p>                  }  else  if (&quot;time&quot;.equals(localName)) {</p>
<p>                     String time = xmlPullParser.nextText();</p>
<p>                     Log.d(&quot;XML&quot;,  &quot;<strong><strong>____</strong></strong>&lt;&lt;&lt;time:&quot; + time);</p>
<p>                  }  else  if (&quot;context&quot;.equals(localName)) {</p>
<p>                     String context = xmlPullParser.nextText();</p>
<p>                     Log.d(&quot;XML&quot;,  &quot;<strong><strong>____</strong></strong>&lt;&lt;&lt;context:&quot; + context);</p>
<p>                  }</p>
<p>break;</p>
<p>case XmlPullParser.END_TAG:</p>
<p>                  localName = xmlPullParser.getName();</p>
<p>if (&quot;context&quot;.equals(localName)) {</p>
<p>                     isDone =  true;</p>
<p>                     Log.d(&quot;XML&quot;,  &quot;_finish pullParser!&quot;);</p>
<p>                  }</p>
<p>break;</p>
<p>              }</p>
<p>              eventType = xmlPullParser.next();</p>
<p>           }</p>
<p>       }  catch (Exception e) {</p>
<p>           Log.d(&quot;XML&quot;, e.toString());</p>
<p>       }</p>
<p>    }</p>
<p>Pull解析和Sax解析很相似，都是轻量级的解析，在Android的内核中已经嵌入了Pull，所以我们不需要再添加第三方jar包来支持Pull。Pull解析和Sax解析不一样的地方有(1)pull读取xml文件后触发相应的事件调用方法返回的是数字(2)pull可以在程序中控制想解析到哪里就可以停止解析。看实例：</p>
<p>book.xml如下：</p>
<p>Xml代码   </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;books&gt;        &lt;book id=&quot;12&quot;&gt;            &lt;name&gt;thinking in java&lt;/name&gt;            &lt;price&gt;85.5&lt;/price&gt;        &lt;/book&gt;        &lt;book id=&quot;15&quot;&gt;            &lt;name&gt;Spring in Action&lt;/name&gt;            &lt;price&gt;39.0&lt;/price&gt;        &lt;/book&gt;    &lt;/books&gt;    </p>
<p>Pull解析的代码如下PullParseService.java</p>
<p>Java代码   </p>
<p>import java.io.InputStream;    import java.util.ArrayList;    import java.util.List;        import org.xmlpull.v1.XmlPullParser;        import android.util.Xml;        import com.xtlh.cn.entity.Book;        public class PullParseService {        public static List&lt;Book&gt; getBooks(InputStream inputStream) throws Exception{            List&lt;Book&gt; books = null;            Book book = null;            XmlPullParser parser = Xml.newPullParser();            parser.setInput(inputStream, &quot;UTF-8&quot;);                        int event = parser.getEventType();//产生第一个事件            while(event!=XmlPullParser.END_DOCUMENT){                switch(event){                case XmlPullParser.START_DOCUMENT://判断当前事件是否是文档开始事件                    books = new ArrayList&lt;Book&gt;();//初始化books集合                    break;                case XmlPullParser.START_TAG://判断当前事件是否是标签元素开始事件                    if(&quot;book&quot;.equals(parser.getName())){//判断开始标签元素是否是book                        book = new Book();                        book.setId(Integer.parseInt(parser.getAttributeValue(0)));//得到book标签的属性值，并设置book的id                    }                    if(book!=null){                        if(&quot;name&quot;.equals(parser.getName())){//判断开始标签元素是否是name                            book.setName(parser.nextText());                        }else if(&quot;price&quot;.equals(parser.getName())){//判断开始标签元素是否是price                            book.setPrice(Float.parseFloat(parser.nextText()));                        }                    }                    break;                case XmlPullParser.END_TAG://判断当前事件是否是标签元素结束事件                    if(&quot;book&quot;.equals(parser.getName())){//判断结束标签元素是否是book                        books.add(book);//将book添加到books集合                        book = null;                    }                    break;                }                event = parser.next();//进入下一个元素并触发相应事件            }//end while            return books;        }    }    </p>
<p> 里面使用到的Book.java类</p>
<p>Java代码   </p>
<p>public class Book {        private int id;        private String name;        private float price;        public int getId() {            return id;        }        public void setId(int id) {            this.id = id;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public float getPrice() {            return price;        }        public void setPrice(float price) {            this.price = price;        }        @Override        public String toString(){            return this.id+&quot;:&quot;+this.name+&quot;:&quot;+this.price;        }    }    </p>
<p> 测试使用的是android的单元测试，代码如下：</p>
<p>Java代码   </p>
<p>import java.io.InputStream;    import java.util.List;        import android.test.AndroidTestCase;    import android.util.Log;        import com.xtlh.cn.entity.Book;    import com.xtlh.cn.service.PullParseService;        public class testPullParseService extends AndroidTestCase{        private static final String TAG = &quot;testPullParseService&quot;;        public void testPull() throws Exception{            InputStream input = this.getClass().getClassLoader().getResourceAsStream(&quot;book.xml&quot;);            PullParseService pull = new PullParseService();            List&lt;Book&gt; books = pull.getBooks(input);            for(Book book : books){                Log.i(TAG,book.toString());            }        }    }    </p>
<p> 要使用android的单元测试，需要在AndroidManifest.xml文件中加入声明，AndroidManifest.xml如下：</p>
<p>Xml代码   </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;    &lt;manifest xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;          package=&quot;com.xlth.cn.demo&quot;          android:versionCode=&quot;1&quot;          android:versionName=&quot;1.0&quot;&gt;        &lt;application android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot;&gt;        &lt;uses-library android:name=&quot;android.test.runner&quot; /&gt;            &lt;activity android:name=&quot;.PullParseDemo&quot;                      android:label=&quot;@string/app_name&quot;&gt;                &lt;intent-filter&gt;                    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;                &lt;/intent-filter&gt;            &lt;/activity&gt;            &lt;/application&gt;        &lt;uses-sdk android:minSdkVersion=&quot;7&quot; /&gt;        &lt;instrumentation android:name=&quot;android.test.InstrumentationTestRunner&quot;          android:targetPackage=&quot;com.xlth.cn.demo&quot; android:label=&quot;Tests for My App&quot; /&gt;    &lt;/manifest&gt;     </p>
<p> Pull解析可以用于很多场合，例如接受google天气，rss新闻等，希望对大家有帮助！</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>书学：《弟子规》易解！随喜转载，功德无量！</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%B9%A6%E5%AD%A6%EF%BC%9A%E3%80%8A%E5%BC%9F%E5%AD%90%E8%A7%84%E3%80%8B%E6%98%93%E8%A7%A3%EF%BC%81%E9%9A%8F%E5%96%9C%E8%BD%AC%E8%BD%BD%EF%BC%8C%E5%8A%9F%E5%BE%B7%E6%97%A0%E9%87%8F%EF%BC%81/</url>
    <content><![CDATA[<p>书学：《弟子规》易解！随喜转载，功德无量！</p>
<p>2014-09-09 一键添加 净空法师 净空法师 </p>
<p>净空法师  </p>
<p>微信号 jingk1927 </p>
<p>功能介绍 修身为本、教学为先，诚敬谦和、普令众生破迷启悟、离苦得乐。 </p>
<p>总 叙</p>
<p>概述：弟子规原名〈训蒙文〉，为清朝康熙年间秀才李毓秀所作。其内容采用《论语》学而篇第六条：“弟子入则孝，出则弟，谨而信，泛爱众，而亲仁，行有余力，则以学文。”的文义以三字一句，两句一韵编纂而成，分为五个部份加以演述；具体列举出为人子弟在家、出外、待人接物、求学应有的礼仪与规范，特别讲求家庭教育与生活教育。后经清朝贾存仁修订改编，并改名为〈弟子规〉，是启蒙养正，教育子弟敦伦尽份防邪存诚，养成忠厚家风的最佳读物。</p>
<p>弟子规　圣人训　首孝悌　次谨信</p>
<p>泛爱众　而亲仁　有余力　则学文</p>
<p>易解：弟子规这本书，是依据至圣先师孔子的教诲而编成的生活规范。首先在日常生活中，要做到孝顺父母，友爱兄弟姊妹。其次在一切日常生活言语行为中要小心谨慎，要讲信用。和大众相处时要平等博爱，并且亲近有仁德的人，向他学习，这些都是很重要非做不可的事，如果做了之后，还有多余的时间精力，就应该好好的学习六艺等其他有益的学问。</p>
<p>父母呼　应勿缓　父母命　行勿懒</p>
<p>父母教　须敬听　父母责　须顺承</p>
<p>易解：父母呼唤，应及时回答，不要慢吞吞的很久才应答，父母有事交代，要立刻动身去做，不可拖延或推辞偷懒。父母教导我们做人处事的道理，是为了我们好，应该恭敬的聆听。做错了事，父母责备教诫时，应当虚心接受，不可强词夺理，使父母亲生气、伤心。（君子闻过则喜，小人闻过则怒。）</p>
<p>冬则温　夏则凊　晨则省　昏则定</p>
<p>出必告　反必面　居有常　业无变</p>
<p>易解：侍奉父母要用心体贴，二十四孝的黄香（香九龄），为了让父亲安心睡眠，夏天睡前会帮父亲把床铺扇凉，冬天寒冷时会为父亲温暖被窝，实在值得我们学习。早晨起床之后，应该先探望父母，并向父母请安问好。下午回家之后，要将今天在外的情形告诉父母，向父母报平安，使老人家放心。外出离家时，须告诉父母要到那里去，回家后还要当面禀报父母回来了，让父母安心。平时起居作息，要保持正常有规律，做事有常规，不要任意改变，以免父母忧虑。</p>
<p>事虽小　勿擅为　苟擅为　子道亏</p>
<p>物虽小　勿私藏　苟私藏　亲心伤</p>
<p>易解：纵然是小事，也不要任性，擅自作主，而不向父母禀告。如果任性而为，容易出错，就有损为人子女的本分，因此让父母担心，是不孝的行为。公物虽小，也不可以私自收藏占为己有。如果私藏，品德就有缺失，父母亲知道了一定很伤心。</p>
<p>亲所好　力为具　亲所恶　谨为去</p>
<p>身有伤　贻亲忧　德有伤　贻亲羞</p>
<p>亲爱我　孝何难　亲憎我　孝方贤</p>
<p>亲有过　谏使更　怡吾色　柔吾声</p>
<p>谏不入　悦复谏　号泣随　挞无怨</p>
<p>易解：父母亲所喜好的东西，应该尽力去准备，父母所厌恶的事物，要小心谨慎的去除（包含自己的坏习惯）。要爱护自己的身体，不要使身体轻易受到伤害，让父母亲忧虑。（曾子曰：“身体发肤受之父母，不敢毁伤”）。要注重自己的品德修养，不可以做出伤风败德的事，使父母亲蒙受耻辱。当父母亲喜爱我们的时候，孝顺是很容易的事；当父母亲不喜欢我们，或者管教过于严厉的时候，我们一样孝顺，而且还能够自己反省检点，体会父母的心意，努力改过并且做得更好，这种孝顺的行为最是难能可贵。 父母亲有过错的时候，应小心劝导改过向善，劝导时态度要诚恳，声音必须柔和，并且和颜悦色，（子夏问孝。子曰：“色难。”）如果父母不听规劝，要耐心等待，一有适当时机，例如父母情绪好转或是高兴的时候，再继续劝导；如果父母仍然不接受，甚至生气，此时我们虽难过得痛哭流涕，也要恳求父母改过，纵然遭遇到责打，也无怨无悔，以免陷父母于不义，使父母一错再错，铸成大错。</p>
<p>亲有疾　药先尝　昼夜侍　不离床</p>
<p>丧三年　常悲咽　居处变　酒肉绝</p>
<p>丧尽礼　祭尽诚　事死者　如事生</p>
<p>易解：父母亲生病时，子女应当尽心尽力的照顾，一旦病情沉重时，更要昼夜服侍，不可以随便离开。父母去世之后，守孝期间（古礼三年），要常常追思、感怀父母教养的恩德。自己的生活起居必须调整改变，不能贪图享受，应该戒绝酒肉（请参考地藏经，孝子应如何给往生者修福）。办理父母亲的丧事要哀戚合乎礼节，不可草率马虎，也不可以为了面子铺张浪费，才是真孝顺。（论语：生，事之以礼，死，葬之以礼，祭之以礼。）祭拜时应诚心诚意，对待已经去世的父母，要如同生前一样恭敬。（论语：祭如在，祭神如神在。）</p>
<p>兄道友　弟道恭　兄弟睦　孝在中</p>
<p>财物轻　怨何生　言语忍　忿自泯</p>
<p>易解：当哥哥姊姊的要友爱弟妹，作弟妹的要懂得恭敬兄姊，兄弟姊妹能和睦相处，一家人和乐融融，父母自然欢喜，孝道就在其中了。与人相处不斤斤计较财物，怨恨就无从生起。言语能够包容忍让，多说好话，不说坏话，忍住气话，不必要的冲突、怨恨的事情自然消失不生。（言语为福祸之门。孔门四科有：德行、言语、政事、文学。可见言语之重要。）</p>
<p>或饮食　或坐走　长者先　幼者后</p>
<p>长呼人　即代叫　人不在　己即到</p>
<p>易解：良好的生活教育，要从小培养；不论用餐就座或行走，都应该谦虚礼让，长幼有序，让年长者优先，年幼者在后。长辈有事呼唤人，应代为传唤，如果那个人不在，自己应该主动去询问是什么事？可以帮忙就帮忙，不能帮忙时则代为转告。（“人生以服务为目的，不以夺取为目的。”青少年守则明言：助人为快乐之本。）</p>
<p>称尊长　勿呼名　对尊长　勿现能</p>
<p>路遇长　疾趋揖　长无言　退恭立</p>
<p>骑下马　乘下车　过犹待　百步余</p>
<p>易解：称呼长辈，不可以直呼姓名，在长辈面前，要谦虚有礼，不可以炫耀自己的才能；路上遇见长辈，应向前问好，长辈没有事时，即恭敬退后站立一旁，等待长辈离去。古礼：不论骑马或乘车，路上遇见长辈均应下马或下车问候，并等到长者离去稍远，约百步之后，才可以离开。（敬老尊贤）</p>
<p>长者立　幼勿坐　长者坐　命乃坐</p>
<p>尊长前　声要低　低不闻　却非宜</p>
<p>进必趋　退必迟　问起对　视勿移</p>
<p>事诸父　如事父　事诸兄　如事兄</p>
<p>易解：与长辈同处，长辈站立时，晚辈应该陪著站立，不可以自行就坐，长辈坐定以后，吩咐坐下才可以坐。与尊长交谈，声音要柔和适中，回答的音量太小让人听不清楚，也是不恰当的。有事要到尊长面前，应快步向前，退回去时，必须稍慢一些才合乎礼节。当长辈问话时，应当专注聆听，眼睛不可以东张西望，左顾右盼。</p>
<p>对待叔叔、伯伯等尊长，要如同对待自己的父亲一般孝顺恭敬，对待同族的兄长（堂兄姊、表兄姊），要如同对待自己的兄长一样友爱尊敬。</p>
<p>朝起早　夜眠迟　老易至　惜此时</p>
<p>晨必盥　兼漱口　便溺回　辄净手</p>
<p>易解：为人子应早起，把握光阴及时努力，若经常晚睡、甚至熬夜，不但对身体健康不好，也影响白天正常的作息。岁月不待人，青春要珍惜。 （少壮不努力，老大徒悲伤。） 早晨起床后，务必洗脸、刷牙、漱口使精神清爽，有一个好的开始。大小便后，一定要洗手，养成良好的卫生习惯，才能确保健康。（防止肠病毒，要学会洗手，手心、手背、指缝间均要仔细搓洗）（陶渊明诗：盛年不重来，一日难再晨。及时当勉励，岁月不待人。）</p>
<p>冠必正　纽必结　袜与履　俱紧切</p>
<p>置冠服　有定位　勿乱顿　致污秽</p>
<p>衣贵洁　不贵华　上循份　下称家</p>
<p>对饮食　勿拣择　食适可　勿过则</p>
<p>易解：要注重服装仪容的整齐清洁，戴帽子要戴端正，衣服扣子要扣好，袜子穿平整，鞋带应系紧，否则容易被绊倒，一切穿著以稳重端庄为宜。回家后衣、帽、鞋袜都要放置定位，避免造成脏乱，要用的时候又要找半天。（大处著眼，小处著手，养成良好的生活习惯，是成功的一半。） 穿衣服需注重整洁，不必讲究昂贵、名牌、华丽。穿著应考量自己的身份及场合，更要衡量家中的经济状况，才是持家之道。（不要为了面子，更不要让虚荣心作主，无谓的开销就是浪费。） 日常饮食要注意营养均衡，多吃蔬菜水果，少吃肉，不要挑食，不可以偏食，三餐常吃八分饱，避免过量，以免增加身体的负担，危害健康。</p>
<p>年方少　勿饮酒　饮酒醉　最为丑</p>
<p>步从容　立端正　揖深圆　拜恭敬</p>
<p>勿践阈　勿跛倚　勿箕踞　勿摇髀</p>
<p>易解：饮酒有害健康，要守法，青少年未成年不可以饮酒。成年人饮酒也不要过量，试看醉汉疯言疯语，丑态毕露，惹出多少是非？（论语：“食不厌精，脍不厌细。”夫子劝勉我们：食物不要过分讲求精美，烹调不要过分要求细致。） （老子说：圣人为腹不为目。饮食是为了吃饱肚子，不是为了满足口目。）当今的文明病例如：癌症、糖尿病…等多为营养过多，与营养失衡所造成。应注意过份加工，太精致的食品，都含有化学添加物，有害健康，不宜食用。 走路时步伐应当从容稳重，不慌不忙，不急不缓；站立时要端正有站相，须抬头挺胸，精神饱满，不可以弯腰驼背，垂头丧气。（立如松，行如风，坐如钟，卧如弓。） 问候他人时，不论鞠躬或拱手都要真诚恭敬，不能敷衍了事。进门时脚不要踩在门槛上，站立时身体也不要站得歪歪斜斜的，坐的时候不可以伸出两腿，腿更不可以抖动，这些都是很轻浮、傲慢的举动，有失君子风范。</p>
<p>缓揭帘　勿有声　宽转弯　勿触棱</p>
<p>执虚器　如执盈　入虚室　如有人</p>
<p>事勿忙　忙多错　勿畏难　勿轻略</p>
<p>易解：进入房间时，不论揭帘子、开门的动作都要轻一点、慢一些，避免发出声响。在室内行走或转弯时，应小心不要撞到物品的棱角，以免受伤。拿东西时要注意，即使是拿著空的器具，也要像里面装满东西一样，小心谨慎以防跌倒或打破。进入无人的房间，也要像有人在一样，不可以随便。做事不要急急忙忙慌慌张张，因为忙中容易出错，不要畏苦怕难而犹豫退缩，也不可以草率，随便应付了事。</p>
<p>斗闹场　绝勿近　邪僻事　绝勿问</p>
<p>将入门　问孰存　将上堂　声必扬</p>
<p>人问谁　对以名　吾与我　不分明</p>
<p>易解：凡是容易发生争吵打斗的不良场所，如赌博、色情等是非之地，要勇于拒绝，不要接近，以免受到不良的影响。一些邪恶下流，荒诞不经的事也要谢绝，不听、不看，不要好奇的去追问，以免污染了善良的心性。</p>
<p>将要入门之前，应先问：“有人在吗？”不要冒冒失失就跑进去。进入客厅之前，应先提高声音，让屋内的，知道有人来了。如果屋里的人问：“是谁呀？”应该回答名字，而不是：“我！我！”让人无法分辨我是谁？</p>
<p>用人物　须明求　倘不问　即为偷</p>
<p>借人物　及时还　后有急　借不难</p>
<p>易解：借用别人的物品，一定要事先讲明，请求允许。如果没有事先征求同意，擅自取用就是偷窃的行为。借来的物品，要爱惜使用，并准时归还，以后若有急用，再借就不难。（谚云：好借好还，再借不难。）</p>
<p>凡出言　信为先　诈与妄　奚可焉</p>
<p>话说多　不如少　惟其是　勿佞巧</p>
<p>奸巧语　秽污词　市井气　切戒之</p>
<p>易解：开口说话，诚信为先，答应他人的事情，一定要遵守承诺，没有能力做到的事不能随便答应，至于欺骗或花言巧语，更不能使用！（论语：与朋友交言而有信。信近于义，言可复也。注：复者实践也，约定的事情要合乎义理才能实践。） 话多不如话少，话少不如话好。说话要恰到好处，该说的就说，不该说的绝对不说，立身处世应该谨言慎行，谈话内容要实事求是，所谓：’词，达而已矣！’；不要花言巧语，好听却靠不住。奸诈取巧的语言，下流肮脏的话，以及街头无赖粗俗的口气，都要避免不去沾染。（论语·子曰：君子欲讷于言，而敏于行。）</p>
<p>见未真　勿轻言　知未的　勿轻传</p>
<p>事非宜　勿轻诺　苟轻诺　进退错</p>
<p>凡道字　重且舒　勿急疾　勿模糊</p>
<p>彼说长　此说短　不关己　莫闲管</p>
<p>易解：任何事情在没有看到真相之前，不要轻易发表意见，对事情了解得不够清楚明白时，不可以任意传播，以免造成不良后果。（谣言止于智者，不要被谣言所利用。） 不合义理的事，不要轻易答应，如果轻易允诺，会造成做也不是，不做也不好，使自己进退两难。 讲话时要口齿清晰，咬字应该清楚，慢慢讲，不要太快，更不要模糊不清。 遇到他人来说是非，听听就算了，要有智慧判断，不要受影响，不要介入是非，事不关己不必多管。</p>
<p>见人善　即思齐　纵去远　以渐跻</p>
<p>见人恶　即内省　有则改　无加警</p>
<p>易解：看见他人的优点或善行义举，要立刻想到学习看齐，纵然目前能力相差很多，也要下定决心，逐渐赶上。看见别人的缺点或不良的行为，要反躬自省，检讨自己是否也有这些缺失，有则改之，无则加勉。（见贤思齐焉，见不贤而内自省也。）（子曰：三人行。必有我师焉，择其善者而从之，其不善者而改之。）</p>
<p>唯德学　唯才艺　不如人　当自砺</p>
<p>若衣服　若饮食　不如人　勿生戚</p>
<p>闻过怒　闻誉乐　损友来　益友却</p>
<p>闻誉恐　闻过欣　直谅士　渐相亲</p>
<p>易解：每一个人都应当重视自己的品德、学问、和才能技艺的培养，如果感觉到有不如人的地方，应当自我惕励奋发图强。至于外表穿著，或者饮食不如他人，则不必放在心上，更没有必要忧虑自卑。（论语·颜回居陋巷，一箪食、一瓢饮，人不堪其忧，回也不改其乐。）（※君子忧道不忧贫）如果一个人听到别人说自己的缺失就生气，听到别人称赞自己就欢喜，那么坏朋友就会来接近你，真正的良朋益友反而逐渐疏远退却了。反之，如果听到他人的称赞，不但没有得意忘形，反而会自省，唯恐做得不够好，继续努力；当别人批评自己的缺失时，不但不生气，还能欢喜接受，那么正直诚信的人，就会渐渐喜欢和我们亲近了。（人以群分，物以类聚。同声相应，同气相求。）</p>
<p>无心非　名为错　有心非　名为恶</p>
<p>过能改　归于无　倘掩饰　增一辜</p>
<p>易解：无心之过称为错，若是明知故犯，有意犯错便是罪恶。知错能改，是勇者的行为，错误自然慢慢的减少消失，如果为了面子，死不认错，还要去掩饰，那就是错上加错了。（子曰：知过能改，善莫大焉！又曰：知耻近乎勇。）</p>
<p>凡是人　皆须爱　天同覆　地同载</p>
<p>行高者　名自高　人所重　非貌高</p>
<p>才大者　望自大　人所服　非言大</p>
<p>易解：只要是人，就是同类，不分族群、人种、宗教信仰，皆须相亲相爱。同是天地所生万物滋长的，应该不分你我，互助合作，才能维持这个共生共荣的生命共同体。（物种以竞争为目的。人类以互助合作为目的。） 德行高尚者，名望自然高超。大家所敬重的是他的德行，不是外表容貌。有才能的人，处理事情的能力卓越，声望自然不凡，然而人们之所以欣赏佩服，是他的处事能力，而不是因为他很会说大话。</p>
<p>己有能　勿自私　人所能　勿轻訾</p>
<p>勿谄富　勿骄贫　勿厌故　勿喜新</p>
<p>人不闲　勿事搅　人不安　勿话扰</p>
<p>易解：当你有能力可以服务众人的时候，不要自私自利，只考虑到自己，舍不得付出。对于他人的才华，应当学习欣赏赞叹，而不是批评、嫉妒、毁谤。不要去讨好巴结富有的人，也不要在穷人面前骄傲自大，或者轻视他们。不要喜新厌旧，对于老朋友要珍惜，不要贪恋新朋友或新事物。对于正在忙碌的人，不要去打扰他，当别人心情不好，身心欠安的时候，不要闲言闲语干扰他，增加他的烦恼与不安。</p>
<p>人有短　切莫揭　人有私　切莫说</p>
<p>道人善　即是善　人知之　愈思勉</p>
<p>扬人恶　即是恶　疾之甚　祸且作</p>
<p>善相劝　德皆建　过不规　道两亏</p>
<p>易解：别人的缺点，不要去揭穿，对于他人的隐私，切忌去张扬。赞美他人的善行就是行善。当对方听到你的称赞之后，必定会更加勉励行善。张扬他人的过失或缺点，就是作了一件坏事。如果指责批评太过分了，还会给自己招来灾祸。朋友之间应该互相规过劝善，共同建立良好的品德修养。如果有错不能互相规劝，两个人的品德都会有缺陷。</p>
<p>凡取与　贵分晓　与宜多　取宜少</p>
<p>将加人　先问己　己不欲　即速已</p>
<p>易解：财物的取得与给予，一定要分辨清楚明白，宁可多给别人，自己少拿一些，才能广结善缘，与人和睦相处。 事情要加到别人身上之前（要托人做事），先要反省问问自己：换作是我，喜欢不喜欢，如果连自己都不喜欢，就要立刻停止。（子曰：己所不欲，勿施于人。要设身处地为别人著想。）</p>
<p>恩欲报　怨欲忘　报怨短　报恩长</p>
<p>待婢仆　身贵端　虽贵端　慈而宽</p>
<p>势服人　心不然　理服人　方无言</p>
<p>易解：受人恩惠要时时想著报答，别人有对不起自己的事，应该宽大为怀把它忘掉，怨恨不平的事不要停留太久，过去就算了，’不要老放在心上，处罚自己，苦恼自己！’至于别人对我们的恩德，要感恩在心常记不忘，常思报答。对待家中的婢女与仆人，要注重自己的品行端正并以身作则，虽然品行端正很重要，但是仁慈宽大更可贵，如果仗势强逼别人服从，对方难免口服心不服。唯有以理服人，别人才会心悦诚服没有怨言。</p>
<p>同是人　类不齐　流俗众　仁者希</p>
<p>果仁者　人多畏　言不讳　色不媚</p>
<p>能亲仁　无限好　德日进　过日少</p>
<p>不亲仁　无限害　小人进　百事坏</p>
<p>易解：同样是人，善恶邪正，心智高低却是良莠不齐。跟著潮流走的俗人多，仁慈博爱的人少，如果有一位仁德的人出现，大家自然敬畏他，因为他说话公正无私没有隐瞒，又不讨好他人。所以大家才会起敬畏之心。能够亲近有仁德的人，向他学习，真是再好不过了，因为他会使我们的德行一天比一天进步，过错也跟著减少。如果不肯亲近仁人君子，就会有无穷的祸害，因为不肖的小人会趁虚而入，跑来亲近我们，日积月累，我们的言行举止都会受影响，导致整个人生的失败。（近朱者赤，近墨者黑。）</p>
<p>余力学文</p>
<p>不力行　但学文　长浮华　成何人</p>
<p>但力行　不学文　任己见　昧理真</p>
<p>易解：不能身体力行孝、悌、谨、信、泛爱众、亲仁这些本分，一味死读书，纵然有些知识，也只是增长自己浮华不实的习气，变成一个不切实际的人，如此读书又有何用？反之，如果只是一味的做，不肯读书学习，就容易依著自己的偏见做事，蒙蔽了真理，也是不对的。（子曰：“学而不思则罔，思而不学则殆。”）</p>
<p>读书法　有三到　心眼口　信皆要</p>
<p>方读此　勿慕彼　此未终　彼勿起</p>
<p>宽为限　紧用功　功夫到　滞塞通</p>
<p>心有疑　随札记　就人问　求确义</p>
<p>易解：读书的方法要注重三到，眼到、口到、心到。三者缺一不可，如此方能收到事半功倍的效果。研究学问，要专一，要专精才能深入，不能这本书才开始读没多久，又欣羡其他的书，想看其他的书，这样永远也定不下心，必须把这本书读完，才能读另外一本。 在订定读书计划的时候，不妨宽松一些，实际执行时，就要加紧用功，严格执行，不可以懈怠偷懒，日积月累功夫深了，原先窒碍不通，困顿疑惑之处自然而然都迎刃而解了。（中庸：用功日久，而一旦豁然贯通焉，则众物之表里精粗无不到，而吾心之全体大用无不明矣。） 求学当中，心里有疑问，应随时笔记，一有机会，就向良师益友请教，务必确实明白它的真义。（不耻下问）</p>
<p>房室清　墙壁净　几案洁　笔砚正</p>
<p>墨磨偏　心不端　字不敬　心先病</p>
<p>列典籍　有定处　读看毕　还原处</p>
<p>虽有急　卷束齐　有缺坏　就补之</p>
<p>易解：书房要整理清洁，墙壁要保持干净，读书时，书桌上笔墨纸砚等文具要放置整齐，不得凌乱，触目所及皆是井井有条，才能静下心来读书。古人写字使用毛笔，写字前先要磨墨，如果心不在焉，墨就会磨偏了，写出来的字如果歪歪斜斜，就表示你浮躁不安，心定不下来。 书籍课本应分类，排列整齐，放在固定的位置，读诵完毕须归还原处。 虽有急事，也要把书本收好再离开，书本是智慧的结晶，有缺损就要修补，保持完整。（古人一书难求，故有修补之举。）</p>
<p>非圣书　屏勿视　蔽聪明　坏心志</p>
<p>勿自暴　勿自弃　圣与贤　可驯致</p>
<p>不是传述圣贤言行的著作，以及有害身心健康的不良书刊，都应该摒弃不要看，以免身心受到污染，智慧遭受蒙蔽，心志变得不健康。遇到困难或挫折的时候，不要自暴自弃，也不必愤世嫉俗，看什么都不顺眼，应该发愤向上努力学习，圣贤境界虽高，循序渐进，也是可以达到的。 （孟子曰：舜何人也，予何人也，有为者亦若是！） （唐诗：劝君莫惜金缕衣，劝君惜取少年时。花开堪折直须折，莫待无花空折枝。）</p>
<p>欢迎转发！<br>净空法师微信平台：jingk1927</p>
<p>如果您有好的文章请推荐给我们。我们将有选择的在本公众平台分享，使更多的人享受到好文章。感恩您！</p>
<p>点击下方“阅读原文”免费订阅文章</p>
<p>阅读原文 </p>
<p>阅读</p>
<p>举报 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>动态去掉导航栏</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%8A%A8%E6%80%81%E5%8E%BB%E6%8E%89%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
    <content><![CDATA[<p>diff –git a/packages/SystemUI/res/layout-sw600dp/navigation_bar.xml b/packages/SystemUI/res/layout-sw600dp/navigation_bar.xml</p>
<p>index f9a61b0..363e21f 100644</p>
<p>— a/packages/SystemUI/res/layout-sw600dp/navigation_bar.xml</p>
<p>+++ b/packages/SystemUI/res/layout-sw600dp/navigation_bar.xml</p>
<p>@@ -119,6 +119,17 @@</p>
<p>                android:visibility=&quot;invisible&quot;</p>
<p>                systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                systemui:keyCode=&quot;24&quot; /&gt;</p>
<ul>
<li><p>      &lt;com.android.systemui.statusbar.policy.KeyButtonView </p>
</li>
<li><p>              android:id=&quot;@+id/hidennevi&quot;</p>
</li>
<li><p>               android:layout_width=&quot;wrap_content&quot;</p>
</li>
<li><p>               android:layout_height=&quot;match_parent&quot;</p>
</li>
<li><p>               android:src=&quot;@drawable/hidennevi&quot;</p>
</li>
<li><p>               android:paddingLeft=&quot;24dp&quot;</p>
</li>
<li><p>              android:paddingRight=&quot;24dp&quot;</p>
</li>
<li><p>              android:layout_weight=&quot;0&quot;</p>
</li>
<li><p>              android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
</li>
<li><p>              systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
</li>
<li><p>              /&gt;</p>
</li>
</ul>
<p>             &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/menu&quot;</p>
<p>                 android:layout_width=&quot;84dp&quot;</p>
<p>                 android:layout_height=&quot;match_parent&quot;</p>
<p>@@ -301,6 +312,17 @@</p>
<p>                  android:visibility=&quot;invisible&quot;</p>
<p>                  systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
<p>                  systemui:keyCode=&quot;24&quot; /&gt;  </p>
<ul>
<li><p>              &lt;com.android.systemui.statusbar.policy.KeyButtonView </p>
</li>
<li><p>              android:id=&quot;@+id/hidennevi&quot;</p>
</li>
<li><p>               android:layout_width=&quot;wrap_content&quot;</p>
</li>
<li><p>               android:layout_height=&quot;match_parent&quot;</p>
</li>
<li><p>               android:src=&quot;@drawable/hidennevi&quot;</p>
</li>
<li><p>               android:paddingLeft=&quot;24dp&quot;</p>
</li>
<li><p>              android:paddingRight=&quot;24dp&quot;</p>
</li>
<li><p>              android:layout_weight=&quot;0&quot;</p>
</li>
<li><p>              android:contentDescription=&quot;@string/accessibility_recent&quot;</p>
</li>
<li><p>              systemui:glowBackground=&quot;@drawable/ic_sysbar_highlight&quot;</p>
</li>
<li><p>              /&gt;</p>
</li>
</ul>
<p>             &lt;com.android.systemui.statusbar.policy.KeyButtonView android:id=&quot;@+id/menu&quot;</p>
<p>                 android:layout_width=&quot;84dp&quot;</p>
<p>                 android:layout_height=&quot;match_parent&quot;</p>
<p>diff –git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java b/packages/SystemUI/src/com/android</p>
<p>index 4809c08..33dd254 100644</p>
<p>— a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarView.java</p>
<p>@@ -282,6 +282,9 @@ public class NavigationBarView extends LinearLayout {</p>
<p>     public View getHomeButton() {</p>
<p>         return mCurrentView.findViewById(R.id.home);</p>
<p>     }</p>
<ul>
<li><p>      public View getHidenButton(){</p>
</li>
<li><p>       return mCurrentView.findViewById(R.id.hidennevi);</p>
</li>
<li><p>   }</p>
</li>
</ul>
<p>     public View getScreenshotButton(){</p>
<p>         return mCurrentView.findViewById(R.id.screenshot);</p>
<p>     }</p>
<p>diff –git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/packages/SystemUI/src/com/android/sy</p>
<p>index b880080..937500a 100644</p>
<p>— a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java</p>
<p>+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java</p>
<p>@@ -129,6 +129,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {</p>
<p>     public static final boolean SPEW = false;</p>
<p>     public static final boolean DUMPTRUCK = true; // extra dumpsys info</p>
<p>     public static final boolean DEBUG_GESTURES = false;</p>
<ul>
<li>      public static boolean isDisplayNavBar = true;</li>
</ul>
<p>     public static final boolean DEBUG_WINDOW_STATE = false;</p>
<p>@@ -489,6 +490,35 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {</p>
<p>                                                                                                        };                      </p>
<ul>
<li><p>       private BroadcastReceiver mBroadcastReceiver1=new BroadcastReceiver() {</p>
</li>
<li><p>              </p>
</li>
<li><p>                              @Override</p>
</li>
<li><p>                              public void onReceive(Context context, Intent intent) {</p>
</li>
<li><p>                                                      // TODO Auto-generated method stub</p>
</li>
<li><p>                                              String action=intent.getAction();</p>
</li>
<li><p>                                                      if (isOrderedBroadcast()) { </p>
</li>
<li><p>                                              Log.d(&quot;hidennevi&quot;,action);</p>
</li>
<li><p>                                              if(action.equals(&quot;hidennevigationbar&quot;)){</p>
</li>
<li><p>                                                      String cmd = intent.getStringExtra(&quot;cmd&quot;);  </p>
</li>
<li><p>                                                                              Log.d(&quot;hidennevi&quot;, &quot;before isDisplayNavBar = &quot; + i</p>
</li>
<li><p>                                                       if(cmd.equals(&quot;hide&quot;)&amp;&amp;isDisplayNavBar){</p>
</li>
<li><p>                                                                                      isDisplayNavBar=false;  </p>
</li>
<li><p>                                                                              removeNavigationBar(); </p>
</li>
<li><p>                                                                                      Log.d(&quot;hidennevi&quot;, &quot;removeNavigationBar—</p>
</li>
<li><p>                                                               }else if(cmd.equals(&quot;show&quot;)&amp;&amp;!isDisplayNavBar){</p>
</li>
<li><p>                                                                      addNavigationBar();  </p>
</li>
<li><p>                                                                              isDisplayNavBar=true;  </p>
</li>
<li><p>                                                                                      Log.d(&quot;hidennevi&quot;, &quot;addNavigationBar——</p>
</li>
<li><p>                                                                       }</p>
</li>
<li><p>                                                                               Log.d(&quot;hidennevi&quot;, &quot;after isDisplayNavBar = &quot; + i</p>
</li>
<li><p>                                                                              </p>
</li>
<li><p>                                                              }else{</p>
</li>
<li><p>                                                                                      //takeScreenshot();</p>
</li>
<li><p>                                                              }</p>
</li>
<li><p>                                                      }</p>
</li>
<li><p>                                              }</p>
</li>
<li><p>              };      </p>
</li>
</ul>
<p>+</p>
<p>        private boolean hasBattery(){</p>
<p>              File hasBattery = new File(&quot;/sys/class/power_supply/battery/voltage_now&quot;);           </p>
<p>@@ -507,7 +537,11 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {</p>
<p>         IntentFilter intentfilter=new IntentFilter();</p>
<p>         intentfilter.addAction(&quot;rk.android.screenshot.SHOW&quot;);</p>
<p>         intentfilter.addAction(&quot;rk.android.screenshot.ACTION&quot;);</p>
<ul>
<li>       context.registerReceiver(receiver, intentfilter);              </li>
</ul>
<ul>
<li><p>       context.registerReceiver(receiver, intentfilter);</p>
</li>
<li><p>              </p>
</li>
<li><p>              IntentFilter filter1 = new IntentFilter();  </p>
</li>
<li><p>              filter1.addAction(&quot;hidennevigationbar&quot;);  </p>
</li>
<li><p>              context.registerReceiver(mBroadcastReceiver1, filter1);                 </p>
</li>
</ul>
<p>         Resources res = context.getResources();</p>
<p>@@ -568,7 +602,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {</p>
<p>         }</p>
<p>         updateShowSearchHoldoff();</p>
<p>-</p>
<p>+if(mNavigationBarView == null){</p>
<p>         try {</p>
<p>             boolean showNav = mWindowManagerService.hasNavigationBar();</p>
<p>             if (DEBUG) Log.v(TAG, &quot;hasNavigationBar=&quot; + showNav);</p>
<p>@@ -588,7 +622,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {</p>
<p>         } catch (RemoteException ex) {</p>
<p>             // no window manager? good luck with that</p>
<p>         }</p>
<p>-</p>
<p>+}</p>
<p>         // figure out which pixel-format to use for the status bar.</p>
<p>         mPixelFormat = PixelFormat.OPAQUE;</p>
<p>@@ -936,17 +970,46 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {</p>
<p>         mNavigationBarView.getRecentsButton().setOnClickListener(mRecentsClickListener);</p>
<p>         boolean show=Settings.System.getInt(mContext.getContentResolver(),</p>
<p>                         Settings.System.SCREENSHOT_BUTTON_SHOW, 0)==1;</p>
<ul>
<li><p>              boolean showNevi=Settings.System.getInt(mContext.getContentResolver(),</p>
</li>
<li><p>                       &quot;hidennevi_button_show&quot;, 1)==1;</p>
</li>
</ul>
<p>         if(show){</p>
<p>                                     mNavigationBarView.getScreenshotButton().setVisibility(View.VISIBLE);</p>
<p>                                }else{</p>
<p>                                                     mNavigationBarView.getScreenshotButton().setVisibility(View.GONE);</p>
<ul>
<li>                                              }                                                               </li>
</ul>
<ul>
<li><p>                                              }       </p>
</li>
<li><p>              if(showNevi &amp;&amp; null !=mNavigationBarView){</p>
</li>
<li><p>                                   mNavigationBarView.getHidenButton().setVisibility(View.VISIBLE);</p>
</li>
<li><p>                              }else{</p>
</li>
<li><p>                                                   mNavigationBarView.getHidenButton().setVisibility(View.GONE);</p>
</li>
<li><p>                                              }       </p>
</li>
<li><p>              mNavigationBarView.getHidenButton().setOnTouchListener(mHidenNeviTouchListener);                                </p>
</li>
</ul>
<p>            mNavigationBarView.getScreenshotButton().setOnTouchListener(mScreenshotPreloadOnTouchListener);     </p>
<p>            mNavigationBarView.getRecentsButton().setOnTouchListener(mRecentsPreloadOnTouchListener);</p>
<p>         mNavigationBarView.getHomeButton().setOnTouchListener(mHomeSearchActionListener);</p>
<p>         mNavigationBarView.getSearchLight().setOnTouchListener(mHomeSearchActionListener);</p>
<p>         updateSearchPanel();</p>
<p>     }</p>
<ul>
<li><p>      </p>
</li>
<li><p>      private View.OnTouchListener mHidenNeviTouchListener = new View.OnTouchListener() {</p>
</li>
<li><p>                      // additional optimization when we have software system buttons - start loading the recent</p>
</li>
<li><p>                      // tasks on touch down</p>
</li>
<li><p>                      @Override</p>
</li>
<li><p>                      public boolean onTouch(View v, MotionEvent event) {</p>
</li>
<li><p>                                          int action = event.getAction() &amp; MotionEvent.ACTION_MASK;</p>
</li>
<li><p>                                          if (action == MotionEvent.ACTION_DOWN) {</p>
</li>
<li><p>                                                      Log.d(&quot;dzy&quot;,&quot;onTouch hidennevibtn &quot;);</p>
</li>
<li><p>                                                      //   takeScreenshot();</p>
</li>
<li><p>                              //removeNavigationBar();</p>
</li>
<li><p>                                                              hidenNevi();</p>
</li>
<li><p>                                                    } else if (action == MotionEvent.ACTION_CANCEL) {</p>
</li>
<li><p>                                                        </p>
</li>
<li><p>                                                        } else if (action == MotionEvent.ACTION_UP) {</p>
</li>
<li><p>                                                        </p>
</li>
<li><p>                                        }</p>
</li>
<li><p>            return false;</p>
</li>
<li><p>        }</p>
</li>
<li><p>    };                                </p>
</li>
<li><p>      </p>
</li>
</ul>
<p>     private View.OnTouchListener mScreenshotPreloadOnTouchListener = new View.OnTouchListener() {</p>
<p>                        // additional optimization when we have software system buttons - start loading the recent</p>
<p>                        // tasks on touch down</p>
<p>@@ -970,13 +1033,47 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {</p>
<p>     // For small-screen devices (read: phones) that lack hardware navigation buttons</p>
<p>     private void addNavigationBar() {</p>
<p>         if (DEBUG) Log.v(TAG, &quot;addNavigationBar: about to add &quot; + mNavigationBarView);</p>
<ul>
<li>       if (mNavigationBarView == null) return;</li>
</ul>
<p>-</p>
<ul>
<li><p>     //mNavigationBarView = null;</p>
</li>
<li><p>       if (mNavigationBarView == null) {//return;</p>
</li>
<li><p>                      try {</p>
</li>
<li><p>                  boolean showNav = mWindowManagerService.hasNavigationBar();</p>
</li>
<li><p>                  if (DEBUG) Log.v(TAG, &quot;hasNavigationBar=&quot; + showNav);</p>
</li>
<li><p>                  if (showNav) {</p>
</li>
<li><p>                      mNavigationBarView =</p>
</li>
<li><p>                          (NavigationBarView) View.inflate(mContext, R.layout.navigation_bar, null);</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>                      mNavigationBarView.setDisabledFlags(mDisabled);</p>
</li>
<li><p>                      mNavigationBarView.setBar(this);</p>
</li>
<li><p>                                      mNavigationBarView.setBackground(mContext.getResources().getDrawable(R.drawable.system_bar</p>
</li>
<li><p>                      mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {</p>
</li>
<li><p>                          @Override</p>
</li>
<li><p>                          public boolean onTouch(View v, MotionEvent event) {</p>
</li>
<li><p>                              checkUserAutohide(v, event);</p>
</li>
<li><p>                              return false;</p>
</li>
<li><p>                          }});</p>
</li>
<li><p>                  }</p>
</li>
<li><p>              } catch (RemoteException ex) {</p>
</li>
<li><p>                  // no window manager? good luck with that</p>
</li>
<li><p>              }</p>
</li>
<li><p>              }</p>
</li>
</ul>
<p>         prepareNavigationBarView();</p>
<p>         mWindowManager.addView(mNavigationBarView, getNavigationBarLayoutParams());</p>
<p>     }</p>
<ul>
<li><p>      private void removeNavigationBar() {</p>
</li>
<li><p>              if (mNavigationBarView == null) return; </p>
</li>
<li><p>              mWindowManager.removeView(mNavigationBarView);</p>
</li>
<li><p>              mNavigationBarView = null;</p>
</li>
<li><p>      }</p>
</li>
</ul>
<p>+</p>
<ul>
<li><p>      public void hidenNevi() {</p>
</li>
<li><p>              Intent intent = new Intent();</p>
</li>
<li><p>              intent.setAction(&quot;hidennevigationbar&quot;);</p>
</li>
<li><p>              intent.putExtra(&quot;cmd&quot;, &quot;hide&quot;);</p>
</li>
<li><p>              mContext.sendOrderedBroadcast(intent, null);</p>
</li>
<li><p>      }</p>
</li>
</ul>
<p>+</p>
<p>     private void repositionNavigationBar() {</p>
<p>         if (mNavigationBarView == null || !mNavigationBarView.isAttachedToWindow()) return;</p>
<p>diff –git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/Pho</p>
<p>index 7a0e1d5..4ca46f0 100755</p>
<p>— a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java</p>
<p>@@ -955,13 +955,21 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>                     public void onSwipeFromBottom() {</p>
<p>                         if (mNavigationBar != null &amp;&amp; mNavigationBarOnBottom) {</p>
<p>                             requestTransientBars(mNavigationBar);</p>
<ul>
<li>                       }</li>
</ul>
<ul>
<li><p>                                                      Log.i(&quot;PhoneWindowManager&quot;, &quot;enter IF run fun requestTransientBars()&quot;);</p>
</li>
<li><p>                       }else{</p>
</li>
<li><p>                                                      showNevi();</p>
</li>
<li><p>                                                      Log.i(&quot;PhoneWindowManager&quot;, &quot;enter onSwipeFromBottom() ELSE run fun showNe</p>
</li>
<li><p>                                              }</p>
</li>
</ul>
<p>                     }</p>
<p>                     @Override</p>
<p>                     public void onSwipeFromRight() {</p>
<p>                         if (mNavigationBar != null &amp;&amp; !mNavigationBarOnBottom) {</p>
<p>                             requestTransientBars(mNavigationBar);</p>
<ul>
<li>                       }</li>
</ul>
<ul>
<li><p>                                                      Log.i(&quot;PhoneWindowManager&quot;, &quot;enter IF run fun requestTransientBars()&quot;);</p>
</li>
<li><p>                       }else{</p>
</li>
<li><p>                                                      showNevi();</p>
</li>
<li><p>                                                      Log.i(&quot;PhoneWindowManager&quot;, &quot;enter onSwipeFromRight() ELSE run fun showNev</p>
</li>
<li><p>                                              }</p>
</li>
</ul>
<p>                     }</p>
<p>                     @Override</p>
<p>                     public void onDebug() {</p>
<p>@@ -1004,6 +1012,14 @@ public class PhoneWindowManager implements WindowManagerPolicy {</p>
<p>                }                       </p>
<p>     }</p>
<ul>
<li><p>      public void showNevi() {</p>
</li>
<li><p>              Intent intent = new Intent();</p>
</li>
<li><p>              intent.setAction(&quot;hidennevigationbar&quot;);</p>
</li>
<li><p>              intent.putExtra(&quot;cmd&quot;, &quot;show&quot;);</p>
</li>
<li><p>              mContext.sendOrderedBroadcast(intent, null);</p>
</li>
<li><p>              Log.i(&quot;showNevi&quot;, &quot;enter showNevi…………………..s&quot;);</p>
</li>
<li><p>      }</p>
</li>
</ul>
<p>+</p>
<p>//在lancher3发广播，在主界面才显示</p>
<p>edward@bx-Desktop:/media/disk1/RK3288_ANDROID4.4.2-SDK_V1.0_140618/src/a3/packages/apps/Launcher3$ git diff </p>
<p>diff –git a/src/com/android/launcher3/Launcher.java b/src/com/android/launcher3/Launcher.java</p>
<p>index 407fbb7..f189d71 100755</p>
<p>— a/src/com/android/launcher3/Launcher.java</p>
<p>+++ b/src/com/android/launcher3/Launcher.java</p>
<p>@@ -907,10 +907,19 @@ public class Launcher extends Activity</p>
<p>             onCompleteRunnable.run();</p>
<p>         }</p>
<p>     }</p>
<p>-</p>
<ul>
<li><p>      private void isShowNevigationBar(boolean isShow) {</p>
</li>
<li><p>              Intent intent = new Intent();</p>
</li>
<li><p>              intent.setAction(&quot;hidennevigationbar&quot;);</p>
</li>
<li><p>                         if(isShow)</p>
</li>
<li><p>                         intent.putExtra(&quot;cmd&quot;, &quot;show&quot;);</p>
</li>
<li><p>                         else</p>
</li>
<li><p>              intent.putExtra(&quot;cmd&quot;, &quot;hide&quot;);</p>
</li>
<li><p>              sendOrderedBroadcast(intent, null);</p>
</li>
<li><p>      }</p>
</li>
</ul>
<p>     @Override</p>
<p>     protected void onStop() {</p>
<p>         super.onStop();</p>
<ul>
<li>              isShowNevigationBar(false);     </li>
</ul>
<p>         FirstFrameAnimatorHelper.setIsVisible(false);</p>
<p>     }</p>
<p>@@ -928,7 +937,9 @@ public class Launcher extends Activity</p>
<p>             Log.v(TAG, &quot;Launcher.onResume()&quot;);</p>
<p>         }</p>
<p>         super.onResume();</p>
<p>-</p>
<ul>
<li><p>              </p>
</li>
<li><p>              isAllAppsVisible();</p>
</li>
<li><p>              //isShowNevigationBar(true);    </p>
</li>
</ul>
<p>         // Restore the previous launcher state</p>
<p>         if (mOnResumeState == State.WORKSPACE) {</p>
<p>             showWorkspace(false);</p>
<p>@@ -1029,6 +1040,7 @@ public class Launcher extends Activity</p>
<p>         InstallShortcutReceiver.enableInstallQueue();</p>
<p>         super.onPause();</p>
<ul>
<li>      </li>
</ul>
<p>         mPaused = true;</p>
<p>         mDragController.cancelDrag();</p>
<p>         mDragController.resetLastGestureUpTime();</p>
<p>@@ -2481,6 +2493,7 @@ public class Launcher extends Activity</p>
<p>      * @param v The view that was clicked.</p>
<p>      */</p>
<p>     public void onClickAllAppsButton(View v) {</p>
<ul>
<li>       isShowNevigationBar(false);</li>
</ul>
<p>         showAllApps(true, AppsCustomizePagedView.ContentType.Applications, false);</p>
<p>     }</p>
<p>@@ -2887,7 +2900,9 @@ public class Launcher extends Activity</p>
<p>     }</p>
<p>     public boolean isAllAppsVisible() {</p>
<ul>
<li>       return (mState == State.APPS_CUSTOMIZE) || (mOnResumeState == State.APPS_CUSTOMIZE);</li>
</ul>
<ul>
<li><p>              boolean isVisible = (mState == State.APPS_CUSTOMIZE) || (mOnResumeState == State.APPS_CUSTOMIZE);</p>
</li>
<li><p>              if(!isVisible)  isShowNevigationBar(true);</p>
</li>
<li><p>       return isVisible ;</p>
</li>
</ul>
<p>     }</p>
<p>     /**</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>常用正则表达式</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>常用正则表达式</p>
<p>说明：正则表达式通常用于两种任务：1.验证，2.搜索/替换。用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串；搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上\b而不是^和$。此表所列的常用正则表达式，除个别外均未在前后加上任何限定，请根据需要，自行处理。</p>
<p>正则表达式（英文：Regular Expression）在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p>
<p>说明  正则表达式 </p>
<p>网址（URL）  [a-zA-z]+://[^\s]* </p>
<p>IP地址(IP Address)  ((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) </p>
<p>电子邮件(Email)  \w+([-+.]\w+)*@\w+([-.]\w+)<em>.\w+([-.]\w+)</em> </p>
<p>QQ号码  [1-9]\d{4,} </p>
<p>HTML标记(包含内容或自闭合)  &lt;(.<em>)(.</em>)&gt;.<em>&lt;/\1&gt;|&lt;(.</em>) /&gt; </p>
<p>密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上)  (?=^.{8,}$)(?=.<em>\d)(?=.<em>\W+)(?=.</em>[A-Z])(?=.</em>[a-z])(?!.<em>\n).</em>$ </p>
<p>日期(年-月-日)  (\d{4}|\d{2})-((0?([1-9]))|(1[1|2]))-((0?[1-9])|(<a href="%5B1-9%5D">12</a>)|(3[0|1])) </p>
<p>日期(月/日/年)  ((0?[1-9]{1})|(1[1|2]))/(0?[1-9]|([12][1-9])|(3[0|1]))/(\d{4}|\d{2}) </p>
<p>时间(小时:分钟, 24小时制)  ((1|0?)[0-9]|2[0-3]):([0-5][0-9]) </p>
<p>汉字(字符)  [\u4e00-\u9fa5] </p>
<p>中文及全角标点符号(字符)  [\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee] </p>
<p>中国大陆固定电话号码  (\d{4}-|\d{3}-)?(\d{8}|\d{7}) </p>
<p>中国大陆手机号码  1\d{10} </p>
<p>中国大陆邮政编码  [1-9]\d{5} </p>
<p>中国大陆身份证号(15位或18位)  \d{15}(\d\d[0-9xX])? </p>
<p>非负整数(正整数或零)  \d+ </p>
<p>正整数  [0-9]<em>[1-9][0-9]</em> </p>
<p>负整数  -[0-9]<em>[1-9][0-9]</em> </p>
<p>整数  -?\d+ </p>
<p>小数  (-?\d+)(.\d+)? </p>
<p>以上正则表达式均经过多次测试，并不断增加,因为不同程序或工具的正则表达式略有区别，大家可以根据需要进行简单修改<br>常用正则表达式 </p>
<p>正则表达式用于字符串处理、表单验证等场合，实用高效。现将一些常用的表达式收集于此，以备不时之需。</p>
<p>用户名：/^[a-z0-9_-]{3,16}$/</p>
<p>密码：/^[a-z0-9_-]{6,18}$/</p>
<p>十六进制值：/^#?([a-f0-9]{6}|[a-f0-9]{3})$/</p>
<p>电子邮箱：/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/</p>
<p>URL：/^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]*)*/?$/</p>
<p>IP 地址：/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</p>
<p>HTML 标签：/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)&lt;/\1&gt;|\s+/&gt;)$/</p>
<p>Unicode编码中的汉字范围：/^[u4e00-u9fa5],{0,}$/</p>
<p>匹配中文字符的正则表达式： [\u4e00-\u9fa5]<br>评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 </p>
<p>匹配双字节字符(包括汉字在内)：[^\x00-\xff]<br>评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） </p>
<p>匹配空白行的正则表达式：\n\s*\r<br>评注：可以用来删除空白行 </p>
<p>匹配HTML标记的正则表达式：&lt;(\S*?)[^&gt;]<em>&gt;.</em>?&lt;/\1&gt;|&lt;.*? /&gt;<br>评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 </p>
<p>匹配首尾空白字符的正则表达式：^\s*|\s*$<br>评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 </p>
<p>匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)<em>.\w+([-.]\w+)</em><br>评注：表单验证时很实用 </p>
<p>匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*<br>评注：网上流传的版本功能很有限，上面这个基本可以满足需求 </p>
<p>匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>评注：表单验证时很实用 </p>
<p>匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}<br>评注：匹配形式如 0511-4405222 或 021-87888822 </p>
<p>匹配腾讯QQ号：[1-9][0-9]{4,}<br>评注：腾讯QQ号从10000开始 </p>
<p>匹配中国大陆邮政编码：[1-9]\d{5}(?!\d)<br>评注：中国大陆邮政编码为6位数字 </p>
<p>匹配身份证：\d{15}|\d{18}<br>评注：中国大陆的身份证为15位或18位 </p>
<p>匹配ip地址：\d+.\d+.\d+.\d+<br>评注：提取ip地址时有用 </p>
<p>匹配特定数字：<br>^[1-9]\d*$　 　 //匹配正整数<br>^-[1-9]\d*$ 　 //匹配负整数<br>^-?[1-9]\d*$　　 //匹配整数<br>^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）<br>^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）<br>^[1-9]\d<em>.\d</em>|0.\d*[1-9]\d*$　　 //匹配正浮点数<br>^-([1-9]\d<em>.\d</em>|0.\d*[1-9]\d*)$　 //匹配负浮点数<br>^-?([1-9]\d<em>.\d</em>|0.\d*[1-9]\d*|0?.0+|0)$　 //匹配浮点数<br>^[1-9]\d<em>.\d</em>|0.\d*[1-9]\d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）<br>^(-([1-9]\d<em>.\d</em>|0.\d*[1-9]\d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）<br>评注：处理大量数据时有用，具体应用时注意修正 </p>
<p>匹配特定字符串：<br>^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串<br>^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串<br>^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串<br>^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串<br>^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串 </p>
<p>表达式全集</p>
<p>正则表达式有多种不同的风格。下表是在PCRE中元字符及其在正则表达式上下文中的行为的一个完整列表：</p>
<p>字符  描述 </p>
<p>\  将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。 </p>
<p>^  匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 </p>
<p>$  匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 </p>
<ul>
<li> 匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”以及“zoo”。</em>等价于{0,}。 </li>
</ul>
<ul>
<li> 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 </li>
</ul>
<p>?  匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 </p>
<p>{n}  n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 </p>
<p>{n,}  n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 </p>
<p>{n,m}  m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 </p>
<p>?  当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 </p>
<p>.  匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“[.\n]”的模式。 </p>
<p>(pattern)  匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 </p>
<p>(?:pattern)  匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 </p>
<p>(?=pattern)  正向预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 </p>
<p>(?!pattern)  负向预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 </p>
<p>x|y  匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。 </p>
<p>[xyz]  字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 </p>
<p>[^xyz]  负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 </p>
<p>[a-z]  字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 </p>
<p>[^a-z]  负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 </p>
<p>\b  匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 </p>
<p>\B  匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 </p>
<p>\cx  匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 </p>
<p>\d  匹配一个数字字符。等价于[0-9]。 </p>
<p>\D  匹配一个非数字字符。等价于[^0-9]。 </p>
<p>\f  匹配一个换页符。等价于\x0c和\cL。 </p>
<p>\n  匹配一个换行符。等价于\x0a和\cJ。 </p>
<p>\r  匹配一个回车符。等价于\x0d和\cM。 </p>
<p>\s  匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]。 </p>
<p>\S  匹配任何非空白字符。等价于[^\f\n\r\t\v]。 </p>
<p>\t  匹配一个制表符。等价于\x09和\cI。 </p>
<p>\v  匹配一个垂直制表符。等价于\x0b和\cK。 </p>
<p>\w  匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 </p>
<p>\W  匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 </p>
<p>\xn  匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。. </p>
<p>\num  匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 </p>
<p>\n  标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 </p>
<p>\nm  标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 </p>
<p>\nml  如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 </p>
<p>\un  匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（?）。 </p>
<p>以下是以PHP的语法所写的示例</p>
<p>验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间 <br>&lt;?php<br>$str = ‘a1234’;<br>if (preg_match(&quot;^[a-zA-Z0-9]{4,16}$&quot;, $str)) {<br>echo &quot;验证成功&quot;;<br>} else {<br>echo &quot;验证失敗&quot;;<br>}<br>?&gt;<br>简易的台湾身份证字号验证 </p>
<p>&lt;?php<br>$str = ‘a1234’;<br>if (preg_match(&quot;/^\w[12]\d{8}$/&quot;, $str)) {<br>echo &quot;验证成功&quot;;<br>} else {<br>echo &quot;验证失敗&quot;;<br>}<br>?&gt;<br>以下示例是用 Perl 语言写的，与上面的示例功能相同 <br>print $str = &quot;a1234&quot; =~ m:^[a-zA-Z0-9]{4,16}$: ? &quot;COMFIRM&quot; : &quot;FAILED&quot;;<br>print $str = &quot;a1234&quot; =~ m&quot;^\w[12]\d{8}$&quot; ? &quot;COMFIRM&quot; : &quot;INVAILD&quot;;</p>
<p>如何写出高效率的正则表达式</p>
<p>如果纯粹是为了挑战自己的正则水平，用来实现一些特效（例如使用正则表达式计算质数、解线性方程），效率不是问题；如果所写的正则表达式只是为了满足一两次、几十次的运行，优化与否区别也不太大。但是，如果所写的正则表达式会百万次、千万次地运行，效率就是很大的问题了。我这里总结了几条提升正则表达式运行效率的经验（工作中学到的，看书学来的，自己的体会），贴在这里。如果您有其它的经验而这里没有提及，欢迎赐教。</p>
<p>为行文方便，先定义两个概念。</p>
<p>误匹配：指正则表达式所匹配的内容范围超出了所需要范围，有些文本明明不符合要求，但是被所写的正则式“击中了”。例如，如果使用\d{11}来匹配11位的手机号，\d{11}不单能匹配正确的手机号，它还会匹配98765432100这样的明显不是手机号的字符串。我们把这样的匹配称之为误匹配。</p>
<p>漏匹配：指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则没有将这种情况囊括在内。例如，使用\d{18}来匹配18位的身份证号码，就会漏掉结尾是字母X的情况。</p>
<p>写出一条正则表达式，既可能只出现误匹配（条件写得极宽松，其范围大于目标文本），也可能只出现漏匹配（只描述了目标文本中多种情况种的一种），还可能既有误匹配又有漏匹配。例如，使用\w+.com来匹配.com结尾的域名，既会误匹配abc_.com这样的字串（合法的域名中不含下划线，\w包含了下划线这种情况），又会漏掉ab-c.com这样的域名（合法域名中可以含中划线，但是\w不匹配中划线）。</p>
<p>精准的正则表达式意味着既无误匹配且无漏匹配。当然，现实中存在这样的情况：只能看到有限数量的文本，根据这些文本写规则，但是这些规则将会用到海量的文本中。这种情况下，尽可能地（如果不是完全地）消除误匹配以及漏匹配，并提升运行效率，就是我们的目标。本文所提出的经验，主要是针对这种情况。</p>
<p>掌握语法细节。正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9_]；perl正则式不支持肯定逆序环视中使用可变的重复（variable repetition inside lookbehind，例如(?&lt;=.*)abc），但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视（Lookbehind,如(?&lt;=ab)c）都不支持，而perl和python是支持的。《精通正则表达式》第3章《正则表达式的特性和流派概览》明确地列出了各大派系正则的异同，这篇文章也简要地列出了几种常用语言、工具中正则的比较。对于具体使用者而言，至少应该详细了解正在使用的那种工作语言里正则的语法细节。</p>
<p>先粗后精，先加后减。使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，再逐步在局步实现细节。仍举刚才的手机号的例子，先界定\d{11}，总不会错；再细化为1[358]\d{9}，就向前迈了一大步（至于第二位是不是3、5、8，这里无意深究，只举这样一个例子，说明逐步细化的过程）。这样做的目的是先消除漏匹配（刚开始先尽可能多地匹配，做加法），然后再一点一点地消除误匹配（做减法）。这样有先有后，在考虑时才不易出错，从而向“不误不漏”这个目标迈进。</p>
<p>留有余地。所能看到的文本sample是有限的，而待匹配检验的文本是海量的，暂时不可见的。对于这样的情况，在写正则表达式时要跳出所能见到的文本的圈子，开拓思路，作出“战略性前瞻”。例如，经常收到这样的垃圾短信：“发*票”、“发#漂”。如果要写规则屏蔽这样烦人的垃圾短信，不但要能写出可以匹配当前文本的正则表达式 发<a href="?:%E7%A5%A8%7C%E6%BC%82">*#</a>，还要能够想到 发.(?:票|漂|飘)之类可能出现的“变种”。这在具体的领域或许会有针对性的规则，不多言。这样做的目的是消除漏匹配，延长正则表达式的生命周期。</p>
<p>明确。具体说来，就是谨慎用点号这样的元字符，尽可能不用星号和加号这样的任意量词。只要能确定范围的，例如\w，就不要用点号；只要能够预测重复次数的，就不要用任意量词。例如，写析取twitter消息的脚本，假设一条消息的xml正文部分结构是&lt;span class=”msg”&gt;…&lt;/span&gt;且正文中无尖括号，那么&lt;span class=”msg”&gt;[^&lt;]{1,480}&lt;/span&gt;这种写法的思路要好于&lt;span class=”msg”&gt;.*&lt;/span&gt;，原因有二：一是使用[^&lt;]，它保证了文本的范围不会超出下一个小于号所在的位置；二是明确长度范围，{1,480}，其依据是一条twitter消息大致能的字符长度范围。当然，480这个长度是否正确还可推敲，但是这种思路是值得借鉴的。说得狠一点，“滥用点号、星号和加号是不环保、不负责任的做法”。</p>
<p>不要让稻草压死骆驼。每使用一个普通括号()而不是非捕获型括号(?:…)，就会保留一部分内存等着你再次访问。这样的正则表达式、无限次地运行次数，无异于一根根稻草的堆加，终于能将骆驼压死。养成合理使用(?:…)括号的习惯。</p>
<p>宁简勿繁。将一条复杂的正则表达式拆分为两条或多条简单的正则表达式，编程难度会降低，运行效率会提升。例如用来消除行首和行尾空白字符的正则表达式s/^\s+|\s+$//g;，其运行效率理论上要低于s/^\s+//g; s/\s+$//g; 。这个例子出自《精通正则表达式》第五章，书中对它的评论是“它几乎总是最快的，而且显然最容易理解”。既快又容易理解，何乐而不为？工作中我们还有其它的理由要将C==(A|B)这样的正则表达式拆为A和B两条表达式分别执行。例如，虽然A和B这两种情况只要有一种能够击中所需要的文本模式就会成功匹配，但是如果只要有一条子表达式（例如A）会产生误匹配，那么不论其它的子表达式（例如B）效率如何之高，范围如何精准，C的总体精准度也会因A而受到影响。</p>
<p>巧妙定位。有时候，我们需要匹配的the，是作为单词的the（两边有空格），而不是作为单词一部分的t-h-e的有序排列（例如together中的the）。在适当的时候用上^，$，\b等等定位锚点，能有效提升找到成功匹配、淘汰不成功匹配的效率。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构必备</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BF%85%E5%A4%87/</url>
    <content><![CDATA[<p>2012.02.28:</p>
<p>顺序表和链表</p>
<p>顺序表:</p>
<p>typedef struct</p>
<p>{</p>
<p>int data[DATA_SIZE]; // store the data</p>
<p>int length; // present length</p>
<p>}sqlist, *sqlink</p>
<p>bool init_list(sqlink *pL)</p>
<p>{</p>
<p>*pL = (sqlink)malloc(sizeof(sqlist));</p>
<p>if(*pL == NULL)</p>
<p>return false;</p>
<p>bzero(*pL, sizeof(sqlist));//将开辟的空间赋零</p>
<p>(*pL)-&gt;last = -1; //这里以-1表示空</p>
<p>return true;</p>
<p>}</p>
<p>bool insert(sqlink L, datatype x)</p>
<p>{</p>
<p>if(is_full(L))</p>
<p>return false;</p>
<p>L-&gt;data[++(L-&gt;last)] = x;//对应-1为空，++后再赋值</p>
<p>return true;</p>
<p>}</p>
<p>bool delete(sqlink L, datatype x)</p>
<p>{</p>
<p>int pos;</p>
<p>pos = locate(L, x);</p>
<p>if(pos == -1)</p>
<p>return false;</p>
<p>for(; pos&lt;L-&gt;last; pos++) //删除后逐个往前移，使其连续存储</p>
<p>L-&gt;data[pos] = L-&gt;data[pos+1];</p>
<p>L-&gt;last–;</p>
<p>return true;</p>
<p>}</p>
<p>链表：</p>
<p>typedef struct node</p>
<p>{</p>
<p>datatype data;</p>
<p>struct node *next;</p>
<p>}listnode, *link;</p>
<p>link init_list()  //开避头节点，指向NULL,返回指针</p>
<p>{</p>
<p>link L;</p>
<p>L = (link)malloc(sizeof(listnode));</p>
<p>if(L == NULL){</p>
<p>perror(&quot;malloc error&quot;);</p>
<p>exit(1);</p>
<p>}</p>
<p>L-&gt;next = NULL;</p>
<p>return L;</p>
<p>}</p>
<p>void init_list(link *p2head) //直接传入地址，开避空间，作为头节点，再指向空</p>
<p>{</p>
<p>*p2head = (list)malloc(sizeof(node));</p>
<p>(*p2head)-&gt;next = NULL;</p>
<p>}</p>
<p>bool insert(link L, datatype x)</p>
<p>{</p>
<p>link new = (link)malloc(sizeof(listnode));</p>
<p>if(new == NULL)</p>
<p>return false;</p>
<p>new-&gt;data = x;</p>
<p>new-&gt;next = NULL;//作为链尾指向NULL</p>
<p>link p = L;</p>
<p>while(p-&gt;next != NULL)</p>
<p>p = p-&gt;next; //找到链尾</p>
<p>p-&gt;next = new; //接上即可</p>
<p>return true;</p>
<p>}</p>
<p>单向循环链表插入，无头节点</p>
<p>void insert(link *p2head, int x)</p>
<p>{</p>
<p>link pnew = (link)malloc(sizeof(listnode));</p>
<p>if(*p2head == NULL){  //无头节点，原来为NULL</p>
<p>pnew-&gt;data = x;</p>
<p>pnew-&gt;next = pnew; //new第一个节点 指返自己</p>
<p>*p2head = pnew;  //成为头节点</p>
<p>}</p>
<p>else{//第二次开始 </p>
<p>link p = *p2head;</p>
<p>/* find the tail of the list */</p>
<p>while(p-&gt;next != *p2head)</p>
<p>p = p-&gt;next;//找到最后节点</p>
<p>pnew-&gt;data = x;</p>
<p>p-&gt;next = pnew;  //p-&gt;next指向头节 重新指向pnew节点</p>
<p>pnew-&gt;next = *p2head; //pnew接上后再重新指向头节点，使循环</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>双向循环链表</p>
<p>typedef struct DNode</p>
<p>{</p>
<p>int data;</p>
<p>struct DNode *prior;//指向前驱节点</p>
<p>struct DNode *next;//指向后继节点</p>
<p>}DNode, *DLinkList</p>
<p>void init_list(DLinkList *p2head)//传地址</p>
<p>{</p>
<p>if((*p2head=(DNode *)malloc(sizeof(DNode))) == NULL){</p>
<p>perror(&quot;malloc faild&quot;);</p>
<p>exit(1);</p>
<p>}</p>
<p>//建立头节点，使其前驱、后继都指向自己</p>
<p>(*p2head)-&gt;prior = (*p2head)-&gt;next = *p2head;</p>
<p>}</p>
<p>void insert(DLinkList head, int num)</p>
<p>{</p>
<p>DLinkList pnew;</p>
<p>if((pnew=(DNode *)malloc(sizeof(DNode))) == NULL)</p>
<p>perror_exit(&quot;malloc failed&quot;);</p>
<p>pnew-&gt;data = num;</p>
<p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>insert the new node onto the tail</p>
<p>*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>pnew-&gt;prior = head-&gt;prior;//从尾部插入，使pnew前驱指向原来head的前驱</p>
<p>head-&gt;prior-&gt;next = pnew;//原来head的前驱的后继指向自已(pnew)      </p>
<p>pnew-&gt;next = head;//pnew的后继指向头</p>
<p>head-&gt;prior = pnew;//最后，head前驱再指回现在的尾(pnew) </p>
<p>}</p>
<p>void delete(dlink H,dlink p)</p>
<p>{</p>
<p>if(p==NULL)</p>
<p>            perror(&quot;linknode not found.\n&quot;);</p>
<p>        else{</p>
<p>             (p-&gt;prior)-&gt;next = p-&gt;next;//使其前驱的后继指向下一节点</p>
<p>             (p-&gt;next)-&gt;prior = p-&gt;prior;//再使下一节点前驱指回p的前驱</p>
<p>             free(p);//释放</p>
<p>        }</p>
<p>}</p>
<p>2012.02.29:</p>
<p>栈与队列</p>
<p>顺序栈：</p>
<p>typedef struct node</p>
<p>{</p>
<p>   datatype data[MAXSIZE];</p>
<p>   int top ;</p>
<p>}seqstack;</p>
<p>void set_is_empty(seqstack *s)</p>
<p>{</p>
<p>  s-&gt;top = -1;//-1表示栈空</p>
<p>}</p>
<p>bool is_empty(seqstack *s)</p>
<p>{</p>
<p>  return ((s-&gt;top&gt;=0)?false:true);</p>
<p>}</p>
<p>bool push(seqstack *s, datatype x)</p>
<p>{</p>
<p>  if(s-&gt;top==MAXSIZE-1){</p>
<p>      printf(&quot;overflow!\n&quot;);</p>
<p>      return false;</p>
<p>  }</p>
<p>   else {</p>
<p>    s-&gt;top ++ ;</p>
<p>    s-&gt;data[s-&gt;top] = x ;</p>
<p>   } </p>
<p>   return true;</p>
<p>}</p>
<p>bool pop(seqstack *s,datatype *loc)</p>
<p>{</p>
<p>  if(is_empty(s)){</p>
<p>        printf(&quot;underflow!\n&quot;);</p>
<p>        return false;</p>
<p>  }else </p>
<p>        *loc = s-&gt;data[s-&gt;top–];</p>
<p>        return true;</p>
<p>}</p>
<p>bool top(seqstack *s ,datatype *loc)</p>
<p>{</p>
<p>    if(is_empty(s)){</p>
<p>       printf(&quot;underflow!\n&quot;);</p>
<p>       return false;</p>
<p>    }</p>
<p>   else </p>
<p>        *loc = s-&gt;data[s-&gt;top];</p>
<p>        return true;</p>
<p>}</p>
<p>bool init_stack(seqstack **p)</p>
<p>{</p>
<p>  <em>p =(seqstack</em>)malloc(sizeof(seqstack));</p>
<p>   if(*p==NULL)</p>
<p>           return false;</p>
<p>   return true ;</p>
<p>}</p>
<p>汉诺塔 栈实现</p>
<p>void towers_of_hanoi(int hanois, stack *ps1, stack *ps2, stack *ps3)</p>
<p>{</p>
<p>int tmp;</p>
<p>if(hanois &gt; 0){</p>
<p>towers_of_hanoi(hanois-1, ps1, ps3, ps2);</p>
<p>pop(ps1, &amp;tmp);</p>
<p>push(ps2, tmp);</p>
<p>towers_of_hanoi(hanois-1, ps3, ps2, ps1);</p>
<p>}</p>
<p>}</p>
<p>链栈：</p>
<p>typedef struct node </p>
<p>{ </p>
<p>  datatype data;</p>
<p>  struct node *next;</p>
<p>}*linkstack;</p>
<p>void init_stack(linkstack *ptop)</p>
<p>{</p>
<p>   *ptop = (linkstack)malloc(sizeof(struct node));</p>
<p>   if(*ptop == NULL){</p>
<p>      perror(&quot;malloc() error&quot;);</p>
<p>      exit(1);</p>
<p>    }</p>
<p>    (*ptop)-&gt;next = NULL;</p>
<p>}</p>
<p>bool is_empty(linkstack top)</p>
<p>{</p>
<p>   return top-&gt;next == NULL;</p>
<p>}</p>
<p>bool push(linkstack *ptop,datatype x)</p>
<p>{</p>
<p>  linkstack new = (linkstack)malloc(sizeof (struct node));</p>
<p>   if(new == NULL)</p>
<p>     return false;</p>
<p>   new-&gt;data = x; </p>
<p>   new-&gt;next = *ptop;//new指向头节点</p>
<p>   *ptop = new ;//将new 更新为头节点</p>
<p> return true ;</p>
<p>}</p>
<p>bool pop(linkstack *ptop ,datatype *loc)</p>
<p>{</p>
<p>  if(is_empty(*ptop))</p>
<p>     return false;</p>
<p>   *loc = (*ptop)-&gt;data;</p>
<p>   *ptop = (*ptop)-&gt;next;//出栈后更新头节点</p>
<p>   return true;</p>
<p>}</p>
<p>顺序循环队列：</p>
<p>typedef struct node</p>
<p>{ </p>
<p>   datatype data[MAXSIZE];  </p>
<p>   int front ,rear;</p>
<p>}sequeue;</p>
<p>void set_empty(sequeue *sq)</p>
<p>{</p>
<p>   sq-&gt;front = sq-&gt;rear = MAXSIZE-1;//循环队列，初始化，指向哪里都一样</p>
<p>}</p>
<p>int is_empty(sequeue *sq)</p>
<p>{</p>
<p>  return (sq-&gt;front == sq-&gt;rear);//队头==队尾即为空</p>
<p>}</p>
<p>bool en_queue(sequeue *sq,datatype x)</p>
<p>{</p>
<p>  if(sq-&gt;front == (sq-&gt;rear+1)%MAXSIZE){//队尾+1==队头 即为满</p>
<p>           printf(&quot;queue is full !\n&quot;);</p>
<p>           return false;</p>
<p>    }else {                         //队头队尾运算都要取模 %MAXSIZE</p>
<p>       sq-&gt;rear = (sq-&gt;rear+1)%MAXSIZE; </p>
<p>       sq-&gt;data[sq-&gt;rear]=x;</p>
<p>       return true; </p>
<p> } </p>
<p>}</p>
<p>bool de_queue(sequeue *sq,datatype *x)</p>
<p>{</p>
<p>  if(is_empty(sq)){</p>
<p>     printf(&quot;queue is empty\n&quot;);</p>
<p>     return false; </p>
<p>  }else {</p>
<p>  sq-&gt;front = (sq-&gt;front+1)%MAXSIZE;</p>
<p>  *x = sq-&gt;data[sq-&gt;front];</p>
<p> }</p>
<p>return true;</p>
<p>}</p>
<p>bool re_queue(sequeue *sq,datatype *x)</p>
<p>{</p>
<p>  if(is_empty(sq)){</p>
<p>     printf(&quot;queue is empty\n&quot;);</p>
<p>     return false; </p>
<p>  }else {</p>
<p>  *x = sq-&gt;data[(sq-&gt;front+1)%MAXSIZE];</p>
<p> }</p>
<p>return true;</p>
<p>}</p>
<p>链队列：</p>
<p>typedef struct node</p>
<p>{</p>
<p> datatype data;</p>
<p> struct node *next;</p>
<p>}linklist;  </p>
<p>typedef struct</p>
<p>{</p>
<p>  linklist *front,*rear;</p>
<p>}linkqueue;  //将队头与队尾指针打包起来</p>
<p>bool set_empty(linkqueue **pq)</p>
<p>{</p>
<p>  (*pq) = malloc(sizeof(linkqueue));</p>
<p>   if(*pq == NULL)</p>
<p>        return false;</p>
<p>    (*pq)-&gt;front = (*pq)-&gt;rear = malloc(sizeof(linklist));//开辟队头，占空位</p>
<p>    (*pq)-&gt;front-&gt;next =NULL;//front下一节点置空</p>
<p>    return true;</p>
<p>}</p>
<p>bool is_empty(linkqueue *q)</p>
<p>{</p>
<p>  return q-&gt;front==q-&gt;rear;//相等时为空</p>
<p>}</p>
<p>bool en_queue(linkqueue *q,datatype x)</p>
<p>{</p>
<p>  q-&gt;rear-&gt;next = malloc(sizeof(linklist));</p>
<p>  if(q-&gt;rear-&gt;next == NULL)</p>
<p>           return false;</p>
<p>  q-&gt;rear = q-&gt;rear-&gt;next;//队尾前移到新开辟的空间</p>
<p>  q-&gt;rear-&gt;data =x;</p>
<p>  q-&gt;rear-&gt;next =NULL;//next置空</p>
<p>  return true;</p>
<p>}</p>
<p>bool front(linkqueue *q,datatype *x)</p>
<p>{</p>
<p>   if(is_empty(q)){</p>
<p>        printf(&quot;queue is empty!\n&quot;);</p>
<p>        return false;</p>
<p>  }</p>
<p>   else</p>
<p>       *x = q-&gt;front-&gt;next-&gt;data;//front-&gt;next 为第一个数</p>
<p>       return true;</p>
<p>}</p>
<p>bool de_queue(linkqueue *q,datatype *x)</p>
<p>{</p>
<p> if(is_empty(q)){</p>
<p>     printf(&quot;queue is empty!\n&quot;);</p>
<p>     return false;</p>
<p> }</p>
<p>  else {</p>
<p>    linklist *s;</p>
<p>    s = q-&gt;front; //保存</p>
<p>    q-&gt;front=q-&gt;front-&gt;next;//前移到下一节点</p>
<p>    free(s);//释放</p>
<p>    *x = (q-&gt;front-&gt;data);//取出数据</p>
<p>    return true;</p>
<p> }</p>
<p>}</p>
<p>2012.03.01:</p>
<p>二叉树</p>
<p>typedef struct node</p>
<p>{</p>
<p>    datatype data;</p>
<p>    struct node *lchild;   //left child</p>
<p>    struct node *rchild;   //right child</p>
<p>}node,*root;</p>
<p>先序+# 建树：</p>
<p>root create_bitree(void)</p>
<p>{</p>
<p>    char c;</p>
<p>    scanf(&quot;%c&quot;,&amp;c);</p>
<p>    root r = (root)malloc(sizeof(node));</p>
<p>    if(‘#’ == c){   //empty treenode</p>
<p>        return NULL;</p>
<p>    }</p>
<p>    else{</p>
<p>        r-&gt;data = c;</p>
<p>        r-&gt;lchild = create_bitree();</p>
<p>        r-&gt;rchild = create_bitree();</p>
<p>    }</p>
<p>    return r;</p>
<p>}</p>
<p>先序+中序建树：</p>
<p>root create_bitree(datatype *preorder,datatype *inorder,int n)//传入数组地址及数组大小</p>
<p>{</p>
<p>    datatype *p ,*q ;  //定义临时变量</p>
<p>    int i ;</p>
<p>    if(n&lt;=0)</p>
<p>        return NULL;</p>
<p>    root r =(root)malloc(sizeof(node));</p>
<p>    r-&gt;data = preorder[0];//先序的第一个肯定是根</p>
<p>    r-&gt;lchild = r-&gt;rchild = NULL ;//左右孩子初始化为空</p>
<p>    i = 0;</p>
<p>    while(i&lt;n){//在中序找到根，其左边的全部为左孩子部分</p>
<p>        if(preorder[0] == inorder[i])</p>
<p>        break;</p>
<p>        ++i; //i 成为了左孩子的大小</p>
<p>    }  </p>
<p>    p = preorder + 1 ;//先序+1 左孩子地址开始</p>
<p>    q = inorder ;</p>
<p>    r-&gt;lchild = create_bitree(p,q,i);//左孩子递归</p>
<p>    p = preorder + i + 1;//先序+i+1 右孩子地址开始</p>
<p>    q = inorder + i + 1;</p>
<p>    r-&gt;rchild = create_bitree(p,q,n-i-1);//右孩子递归</p>
<p>    return r;</p>
<p>}</p>
<p>void rebuild(char *pre_order, char *in_order, int len, root *p2root)</p>
<p>{</p>
<p>if(pre_order==NULL || in_order==NULL)</p>
<p>return;</p>
<p>/* get the first node of pre_order */</p>
<p>root ptmp = (root)malloc(sizeof(treenode));</p>
<p>ptmp-&gt;ch = *pre_order;</p>
<p>ptmp-&gt;lchild = NULL;</p>
<p>ptmp-&gt;rchild = NULL;</p>
<p>*p2root = ptmp;</p>
<p>/* if tree’s length equals to 1, then it’s the last node */</p>
<p>if(len == 1)</p>
<p>return;</p>
<p>/* find the end of the left child-tree, and its length */</p>
<p>char *in_order_tmp = in_order;</p>
<p>char *p2left_end = in_order;</p>
<p>int tmp_len = 0;</p>
<p>while(*pre_order != *p2left_end){</p>
<p>if(in_order_tmp==NULL || p2left_end==NULL)</p>
<p>return;</p>
<p>tmp_len++;</p>
<p>/* record the temperate length, avoiding overflow */</p>
<p>if(tmp_len &gt; len)</p>
<p>break;</p>
<p>p2left_end++;</p>
<p>}</p>
<p>/* get the length of child trees */</p>
<p>int left_len = 0, right_len = 0;</p>
<p>left_len = (int)(p2left_end - in_order_tmp);</p>
<p>right_len = (int)(len - left_len - 1);</p>
<p>/*<strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></p>
<p>rebuild child trees</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>if(left_len &gt; 0)</p>
<p>rebuild(pre_order + 1, in_order, left_len, &amp;((*p2root)-&gt;lchild));</p>
<p>if(right_len &gt; 0)</p>
<p>rebuild(pre_order + left_len + 1, in_order + left_len + 1, \</p>
<p>right_len, &amp;((*p2root)-&gt;rchild));</p>
<p>}</p>
<p>先序、中序、后序遍历：</p>
<p>/*</p>
<p>** preorder traversal</p>
<p>*/</p>
<p>void preorder(root T)</p>
<p>{</p>
<p>    if(NULL == T)</p>
<p>        return;</p>
<p>    printf(&quot;%c&quot;,T-&gt;data);</p>
<p>    preorder(T-&gt;lchild);</p>
<p>    preorder(T-&gt;rchild);</p>
<p>}</p>
<p>/*</p>
<p>** inorder traversal</p>
<p>*/</p>
<p>void inorder(root T)</p>
<p>{</p>
<p>    if(NULL == T)</p>
<p>        return;</p>
<p>    inorder(T-&gt;lchild);</p>
<p>    printf(&quot;%c&quot;,T-&gt;data);</p>
<p>    inorder(T-&gt;rchild);</p>
<p>}</p>
<p>/*</p>
<p>** postorder traversal</p>
<p>*/</p>
<p>void postorder(root T)</p>
<p>{</p>
<p>    if(NULL == T)</p>
<p>        return;</p>
<p>    postorder(T-&gt;lchild);</p>
<p>    postorder(T-&gt;rchild);</p>
<p>    printf(&quot;%c&quot;,T-&gt;data);</p>
<p>}</p>
<p>分层遍历 队列实现</p>
<p>void travel_level(root t)</p>
<p>{</p>
<p>linkqueue q;</p>
<p>queue_init(&amp;q);//队列初始化，开辟队头==队尾,队尾-&gt;next=NULL</p>
<p>while(t != NULL){</p>
<p>fprintf(stderr, &quot;%c&quot;, t-&gt;ch);//打印</p>
<p>if(t-&gt;lchild != NULL)</p>
<p>en_queue(q, t-&gt;lchild);//左孩子非空，入队</p>
<p>if(t-&gt;rchild != NULL)</p>
<p>en_queue(q, t-&gt;rchild);//右孩子非空，入队</p>
<p>if(!out_queue(q, &amp;t))//队头出队</p>
<p>return;</p>
<p>}//出队完成，root==NULL 遍历完成</p>
<p>}</p>
<p>非递归前序遍历 栈实现</p>
<p>void travel_pre(root T)</p>
<p>{</p>
<p>if(T == NULL)</p>
<p>return;</p>
<p>stack top;       //定义一个栈 </p>
<p>init_stack(&amp;top);//初始化栈</p>
<p>push(&amp;top, T);//把第一个压栈</p>
<p>datatype x;</p>
<p>while(!is_empty(top)){//栈非空时循环  出栈完成即遍历未完成</p>
<p>pop(&amp;top, &amp;x);//先出栈</p>
<p>fprintf(stderr, &quot;%c&quot;, x-&gt;ch);</p>
<p>//压栈：从右到左   出栈才能从左到右</p>
<p>if(x-&gt;rchild != NULL)//右孩子非空，压栈</p>
<p>push(&amp;top, x-&gt;rchild);</p>
<p>if(x-&gt;lchild != NULL)//左孩子非空，压栈</p>
<p>push(&amp;top, x-&gt;lchild);</p>
<p>}</p>
<p>}</p>
<p>非递归中序遍历 栈实现 </p>
<p>void travel_inorder(root T)</p>
<p>{</p>
<p>stack top;</p>
<p>init_stack(&amp;top);//栈初始化</p>
<p>while(T != NULL || !is_empty(top)){//NULL说明树为空  栈空即出栈完成</p>
<p>if(T != NULL){//节点非空</p>
<p>push(&amp;top, T);//父节点压栈</p>
<p>T = T-&gt;lchild;//指向左孩子 </p>
<p>}</p>
<p>else{//左孩子为空</p>
<p>pop(&amp;top, &amp;T);//出栈左孩子的父节点</p>
<p>printf(&quot;%c&quot;, T-&gt;ch);//打印</p>
<p>T = T-&gt;rchild;//指向右孩子</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>非递归后序遍历 栈实现</p>
<p>void travel_post(root T)</p>
<p>{</p>
<p>stack top;</p>
<p>init_stack(&amp;top);//栈初始化</p>
<p>if(T == NULL)   //树空直接返回</p>
<p>return;</p>
<p>push(&amp;top, T);//父节点压栈 //为了第一个pop不为空</p>
<p>while(!is_empty(top)){//栈空表示遍历完成</p>
<p>datatype x;</p>
<p>pop(&amp;top, &amp;x);//出栈 </p>
<p>if(x-&gt;pushed)//有出栈标记 才打印   pushed标记是否可以出栈</p>
<p>fprintf(stderr, &quot;%c&quot;, x-&gt;ch);</p>
<p>else{</p>
<p>push(&amp;top, x);//父节点压栈 最后遍历</p>
<p>if(x-&gt;rchild != NULL)//如果非空</p>
<p>push(&amp;top, x-&gt;rchild);//右孩子压栈 </p>
<p>if(x-&gt;lchild != NULL)//如果非空</p>
<p>push(&amp;top, x-&gt;lchild);//左孩子压栈</p>
<p>x-&gt;pushed = true;//父-&gt;右-&gt;左 依次压栈后 push置位 </p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>2012.03.02:</p>
<p>查找</p>
<p>顺序查找</p>
<p>int sequential_search(sqlink L, int x)</p>
<p>{</p>
<p>int i=0 ;</p>
<p>while(L-&gt;data[i] != x){</p>
<p>i++;</p>
<p>if(i &gt; L-&gt;length)</p>
<p>return -1;</p>
<p>}</p>
<p>return i;</p>
<p>}</p>
<p>折半查找 </p>
<p>int binary_search(sqlink L, int x)</p>
<p>{</p>
<p>int low,high,mid;</p>
<p>low = 1; //初始化时，low=1  hight=n  0没有数据</p>
<p>high = get_len(L);//high=L-&gt;Length; </p>
<p>while(low &lt;= high){</p>
<p>mid = (low + high) / 2;   //每次都取mid值</p>
<p>if(x == L-&gt;data[mid])</p>
<p>return mid ;</p>
<p>else if(x &lt; L-&gt;data[mid]) //比mid的小 high=mid-1</p>
<p>high = mid - 1;</p>
<p>else </p>
<p>low = mid + 1;   //比mid大 low=mid+1</p>
<p>}</p>
<p>return -1;</p>
<p>}</p>
<p>直接插入排序：</p>
<p>void insertion_sort(int num[])</p>
<p>{</p>
<p>int i, j;</p>
<p>int tmp;</p>
<p>for(i=1; i&lt;SIZE; i++){//从1开始</p>
<p>if(num[i-1] &lt; num[i]){//如果前&lt;后，直接跳过 </p>
<p>continue;</p>
<p>}</p>
<p>else{</p>
<p>tmp = num[i];//保存i处的值(需要移走的值) 此时比i-1处值小</p>
<p>for(j=i-1; tmp&lt;num[j] &amp;&amp; j&gt;= 0; j–){//tmp与i之前的逐一比较</p>
<p>num[j+1] = num[j];//比tmp大的逐一后移</p>
<p>}</p>
<p>num[j+1] = tmp;//最后插入适当的位置</p>
<p>}</p>
<p>}//for</p>
<p>}</p>
<p>折半插入排序：</p>
<p>void binary_insertion_sort(int num[])</p>
<p>{</p>
<p>int i, j;</p>
<p>int tmp, low, high, m;</p>
<p>for(i=1; i&lt;SIZE; ++i){</p>
<p>tmp = num[i];</p>
<p>low = 0; high = i-1;</p>
<p>/* find the position for inserting */</p>
<p>while(low &lt;= high){</p>
<p>m = (low + high)/2;</p>
<p>if(tmp &lt; num[m])//每次要插的值tmp都与中间的值比较 前面已有序</p>
<p>high = m-1;</p>
<p>else</p>
<p>low = m+1;</p>
<p>}</p>
<p>/* moves the records */</p>
<p>for(j=i-1; j &gt;= high+1; –j)//high&lt;tmp 最大一个</p>
<p>num[j+1] = num[j];//high 后面的都要后移</p>
<p>num[high+1] = tmp;//最后插入tmp</p>
<p>}</p>
<p>}</p>
<p>冒泡排序：</p>
<p>void bubble_sort(int num[])</p>
<p>{</p>
<p>int i, j;</p>
<p>for(i=SIZE; i&gt;0; –i){</p>
<p>   int flag = 0;</p>
<p>   for(j=0; j&lt;i-1; j++){//i个数比较i-1次</p>
<p>       int tmp;</p>
<p>       if(num[j] &gt; num[j+1]){//前&gt;后，需要换位</p>
<p>           tmp = num[j];</p>
<p>           num[j] = num[j+1];</p>
<p>           num[j+1] = tmp;</p>
<p>           flag = 1;//换位 置1</p>
<p>       }</p>
<p>   }</p>
<p>   if(flag == 0) //经过一趟也没有换位，说明有序了</p>
<p>       break;</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>希尔排序(shell 排序)：</p>
<p>void shell_insert(int num[], int dk)//以dk为增量，一趟插入排序</p>
<p>{</p>
<p>int i, j;</p>
<p>for(i=dk+1; i&lt;SIZE; ++i){</p>
<p>if(num[i] &lt; num[i-dk]){</p>
<p>num[0] = num[i];//num[0]存放要插入的值</p>
<p>for(j=i-dk; j&gt;0&amp;&amp;(num[0]&lt;num[j]); j-=dk)//以增量dk向前查找合适的位置</p>
<p>num[j+dk] = num[j];</p>
<p>num[j+dk] = num[0];//放到上面移走数据的位置</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void shell_sort(int num[], int dlta[], int t)//dlta[] 存放递减的增量 t为增量的个数</p>
<p>{</p>
<p>int k;</p>
<p>for(k=0; k&lt;t; ++k){</p>
<p>shell_insert(num, dlta[k]);//用递减的增量，一趟一趟地插入</p>
<p>}</p>
<p>快速排序：</p>
<p>int partition(int num[], int low, int high)//一次划分</p>
<p>{</p>
<p>        int r = num[low];</p>
<p>        int pivotloc = num[low];//以第一个为基准</p>
<p>        while(low &lt; high){</p>
<p>        /* move the data which is SMALLER than the PIVOT forward */</p>
<p>            while(low&lt;high &amp;&amp; num[high]&gt;=pivotloc)</p>
<p>                –high;//high 的大，不换位，high– 即可</p>
<p>            num[low] = num[high];//从while中跳出，说明high的小，要移到low处</p>
<p>            /* move the data which is LARGER than the PIVOT backward */</p>
<p>            while(low&lt;high &amp;&amp; num[low]&lt;=pivotloc)</p>
<p>                ++low;//low 的小 不换位， low++ 即可</p>
<p>            num[high] = num[low];//从while中跳出,说明low的大，要移到high处</p>
<p>        }</p>
<p>        num[low] = r; //最后，比基准值大的已后移，小的已前移。基准值放回合适的位置</p>
<p>        return low; //返回基准值位置</p>
<p>}</p>
<p>void quick_sort(int num[], int low, int high)</p>
<p>{</p>
<p>        int pivotloc; //基准</p>
<p>        if(low &lt; high){</p>
<p>            pivotloc = partition(num, low, high);//一次划分后，找到了基准值所在的位置</p>
<p>            /* recurs sorting sub-table */</p>
<p>            quick_sort(num, low, pivotloc-1);//递归排序原基准值前面的数</p>
<p>            quick_sort(num, pivotloc+1, high);//递归排序原基准值后面的数</p>
<p>        }</p>
<p>        return;</p>
<p>}</p>
<p>hash查找: </p>
<p>key–&gt;H(key)–&gt;key  存放与查找方法一样却可 </p>
<p>hash函数H(key)、解决冲突方法</p>
<p>linux 内核 hash表 &gt;&gt; </p>
<p>构造哈希函数方法：</p>
<p>1.直接定址法；</p>
<p>2.平方取中法；</p>
<p>3.折叠法；</p>
<p>4.除留余数法；</p>
<p>解决冲突：</p>
<p>1.开放定址法</p>
<p>2.再哈希法</p>
<p>3.链地址法</p>
<p> 内核中宏两种常用写法：</p>
<p>#define XXX  ({; ; ;})</p>
<p>#define XXX  do { ; ; ; } while(0)</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>添加重启</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%BB%E5%8A%A0%E9%87%8D%E5%90%AF/</url>
    <content><![CDATA[<p>Android 4.1.2系统添加重启功能 2013-06-28 11:12:11</p>
<p>分类： Android平台</p>
<p>对于Android的的手机或者平板长期使用，感觉会出现慢的情况，所以偶尔还是需要重启一下，而长按电源键弹出的菜单又没有重启选项，所以特在此记录自己添加这个功能的过程。<br>首先关机的那个弹出菜单是在frameworks/base/policy/src/com/android/internal/policy/impl/GlobalActions.java这个文件中创建的： </p>
<p>点击(此处)折叠或打开</p>
<p>/**<br> * Create the global actions dialog.<br> * @return A new dialog.<br> */<br>private GlobalActionsDialog createDialog() {<br>// Simple toggle style if there’s no vibrator, otherwise use a tri-state<br>if (!mHasVibrator) {<br>        mSilentModeAction = new SilentModeToggleAction();<br>} else {<br>        mSilentModeAction = new SilentModeTriStateAction(mContext, mAudioManager, mHandler);<br>}<br>    mAirplaneModeOn = new ToggleAction(<br>            R.drawable.ic_lock_airplane_mode,<br>            R.drawable.ic_lock_airplane_mode_off,<br>            R.string.global_actions_toggle_airplane_mode,<br>            R.string.global_actions_airplane_mode_on_status,<br>            R.string.global_actions_airplane_mode_off_status) {<br>void onToggle(boolean on) {<br>if (mHasTelephony &amp;&amp; Boolean.parseBoolean(<br>                    SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {<br>                mIsWaitingForEcmExit = true;<br>// Launch ECM exit dialog<br>                Intent ecmDialogIntent =<br>new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);<br>                ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>                mContext.startActivity(ecmDialogIntent);<br>} else {<br>                changeAirplaneModeSystemSetting(on);<br>}<br>}<br>        @Override<br>protected void changeStateFromPress(boolean buttonOn) {<br>if (!mHasTelephony) return;<br>// In ECM mode airplane state cannot be changed<br>if (!(Boolean.parseBoolean(<br>                    SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {<br>                mState = buttonOn ? State.TurningOn : State.TurningOff;<br>                mAirplaneState = mState;<br>}<br>}<br>public boolean showDuringKeyguard() {<br>return true;<br>}<br>public boolean showBeforeProvisioning() {<br>return false;<br>}<br>};<br>    onAirplaneModeChanged();<br>    mItems = new ArrayList&lt;Action&gt;();<br>// first: power off<br>    mItems.add(<br>new SinglePressAction(<br>                com.android.internal.R.drawable.ic_lock_power_off,<br>                R.string.global_action_power_off) {<br>public void onPress() {<br>// shutdown by making sure radio and power are handled accordingly.<br>                mWindowManagerFuncs.shutdown(true);<br>}<br>public boolean onLongPress() {<br>                mWindowManagerFuncs.rebootSafeMode(true);<br>return true;<br>}<br>public boolean showDuringKeyguard() {<br>return true;<br>}<br>public boolean showBeforeProvisioning() {<br>return true;<br>}<br>});    我们可以看到mItems.add函数是添加一个选项，该菜单的第一个选项就是关机选项，我们可以在此之后添加重启选项，代码如下： </p>
<p>mItems.add(<br>new SinglePressAction(<br>        com.android.internal.R.drawable.ic_lock_power_off,<br>        R.string.global_action_reboot) {<br>public void onPress() {<br>// reboot<br>            mWindowManagerFuncs.reboot();<br>}<br>public boolean showDuringKeyguard() {<br>return true;<br>}<br>public boolean showBeforeProvisioning() {<br>return true;<br>}<br>});   上面的代码中使用了mWindowManagerFuncs.reboot函数和R.string.global_action_reboot资源，因此我们需要该资源并实现reboot函数。<br>首先在frameworks/base/core/java/android/view/WindowManagerPolicy.java中添加reboot接口： </p>
<p>/**<br> * Interface for calling back in to the window manager that is private<br> * between it and the policy.<br> */<br>public interface WindowManagerFuncs {<br>…<br>/**<br>     * Switch the keyboard layout for the given device.<br>     * Direction should be +1 or -1 to go to the next or previous keyboard layout.<br>     */<br>public void switchKeyboardLayout(int deviceId, int direction);<br>public void shutdown();<br>public void reboot();<br>public void rebootSafeMode();<br>}   然后在frameworks/base/services/java/com/android/server/wm/WindowManagerService.java中实现该接口： </p>
<p>// Called by window manager policy. Not exposed externally.<br>@Override<br>public void shutdown() {<br>    ShutdownThread.shutdown(mContext, true);<br>}<br>// Called by window manager policy. Not exposed externally.<br>@Override<br>public void reboot() {<br>    ShutdownThread.reboot(mContext, null, true);<br>}<br>// Called by window manager policy. Not exposed externally.<br>@Override<br>public void rebootSafeMode() {<br>    ShutdownThread.rebootSafeMode(mContext, true);<br>}   接下来，为了在按下重启选项之后，能出现”重启“之类的提示，还需要修改frameworks/base/services/java/com/android/server/pm/ShutdownThread.java中的shutdownInner函数和beginShutdownSequence函数： </p>
<dl><dt>static void shutdownInner(final Context context, boolean confirm) {<br>// ensure that only one thread is trying to power down.<br>// any additional calls are just returned<br>synchronized (sIsStartedGuard) {<br>if (sIsStarted) {<br>Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;);<br>return;<br>}<br>}<br>final int longPressBehavior = context.getResources().getInteger(<br>                    com.android.internal.R.integer.config_longPressOnPowerBehavior);<br>final int resourceId = mRebootSafeMode<br>? com.android.internal.R.string.reboot_safemode_confirm<br>: (longPressBehavior == 2<br>? com.android.internal.R.string.shutdown_confirm_question<br>: (mReboot ? com.android.internal.R.string.reboot_confirm :<br>                        com.android.internal.R.string.shutdown_confirm));<br>Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior);<br>if (confirm) {<br>final CloseDialogReceiver closer = new CloseDialogReceiver(context);<br>final AlertDialog dialog = new AlertDialog.Builder(context)<br>.setTitle(mRebootSafeMode<br>? com.android.internal.R.string.reboot_safemode_title</dt><dd>(mReboot ? com.android.internal.R.string.reboot :<br>                            com.android.internal.R.string.power_off))<br>.setMessage(resourceId)<br>.setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {<br>public void onClick(DialogInterface dialog, int which) {<br>                        beginShutdownSequence(context);<br>}<br>})<br>.setNegativeButton(com.android.internal.R.string.no, null)<br>.create();<br>        closer.dialog = dialog;<br>dialog.setOnDismissListener(closer);<br>dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);<br>dialog.show();<br>} else {<br>        beginShutdownSequence(context);<br>}<br>}<br>private static void beginShutdownSequence(Context context) {<br>synchronized (sIsStartedGuard) {<br>if (sIsStarted) {<br>Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;);<br>return;<br>}<br>       sIsStarted = true;<br>}<br>// throw up an indeterminate system dialog to indicate radio is<br>// shutting down.<br>   ProgressDialog pd = new ProgressDialog(context);<br>   pd.setTitle(context.getText(com.android.internal.R.string.power_off));<br>   pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));<br>   pd.setIndeterminate(true);<br>   pd.setCancelable(false);<br>   pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);<br>   pd.show();<br>   sInstance.mContext = context;<br>   sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE);<br>// make sure we never fall asleep again<br>   sInstance.mCpuWakeLock = null;<br>try {<br>       sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock(<br>               PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;);<br>       sInstance.mCpuWakeLock.setReferenceCounted(false);<br>       sInstance.mCpuWakeLock.acquire();<br>} catch (SecurityException e) {<br>Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);<br>       sInstance.mCpuWakeLock = null;<br>}<br>// also make sure the screen stays on for better user experience<br>   sInstance.mScreenWakeLock = null;<br>if (sInstance.mPowerManager.isScreenOn()) {<br>try {<br>           sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock(<br>                   PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;);<br>           sInstance.mScreenWakeLock.setReferenceCounted(false);<br>           sInstance.mScreenWakeLock.acquire();<br>} catch (SecurityException e) {<br>Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);<br>           sInstance.mScreenWakeLock = null;<br>}<br>}<br>// start the thread that initiates shutdown<br>   sInstance.mHandler = new Handler() {<br>};<br>   sInstance.start();<br>}   至此关于代码部分的改动全部完成，接下来就需要添加使用到的资源了，就是前面用到的字符串。首先需要在frameworks/base/core/res/res/values/strings.xml中添加一下字符串： </dd></dl><p>&lt;string name=&quot;reboot&quot;&gt;Reboot&lt;/string&gt;<br>&lt;string name=&quot;reboot_progress&quot;&gt;Reboot\u2026&lt;/string&gt;<br>&lt;string name=&quot;reboot_confirm&quot; product=&quot;tablet&quot;&gt;Your tablet will reboot.&lt;/string&gt;<br>&lt;string name=&quot;reboot_confirm&quot; product=&quot;default&quot;&gt;Your phone will reboot.&lt;/string&gt;<br>&lt;!– label for item that reboot in phone options dialog –&gt;<br>&lt;string name=&quot;global_action_reboot&quot;&gt;Reboot&lt;/string&gt;   而后需要在frameworks/base/core/res/res/values/public.xml中声明这些资源，否则编译的时候会出现找不到该资源的错误。 </p>
<p>&lt;java-symbol type=&quot;string&quot; name=&quot;reboot&quot; /&gt;<br>&lt;java-symbol type=&quot;string&quot; name=&quot;reboot_confirm&quot; /&gt;<br>&lt;java-symbol type=&quot;string&quot; name=&quot;reboot_progress&quot; /&gt;<br>&lt;java-symbol type=&quot;string&quot; name=&quot;global_action_reboot&quot; /&gt;   至此，全部修改完成，编译烧写即可。</p>
<p>&lt;TextView android:id=&quot;@+id/am_pm&quot;</p>
<p>            android:layout_width=&quot;wrap_content&quot;</p>
<p>            android:layout_height=&quot;wrap_content&quot;</p>
<p>            android:singleLine=&quot;true&quot;</p>
<p>            android:ellipsize=&quot;none&quot;</p>
<p>            android:textSize=&quot;22sp&quot;</p>
<p>            android:layout_marginLeft=&quot;8dip&quot;</p>
<p>            android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;</p>
<p>            android:shadowColor=&quot;#C0000000&quot;</p>
<p>            android:shadowDx=&quot;0&quot;</p>
<p>            android:shadowDy=&quot;0&quot;</p>
<p>            android:shadowRadius=&quot;3.0&quot;</p>
<p>去掉锁屏时显示充电百分比在：</p>
<p>　　frameworks/base/core/res/res/values-zh-rCN中strings.xml 的lockscreen_plugged_in 括号中的内容及括号 !!</p>
<p>MTKAndroid4.2.1添加重启功能</p>
<p>分类： Android成长之路 2013-07-01 17:18 154人阅读 评论(0) 收藏 举报</p>
<p>android</p>
<p>    接触Android框架层也有一段时间了，但是基本上都没有对遇到的问题写总结，当遇到同样的问题也只能凭着模糊的记忆去解决。打算从今天开始每天抽点时间对工作中遇到的问题进行总结。 </p>
<p>今天要说的是为Android添加一个重启按钮，在Nine的客户需求中需要添加这项功能，在长按电源键弹出的菜单中没有重启选项，谨以此文记录自己添加这个功能的过程：</p>
<p>修改涉及到的文件如下：</p>
<p>frameworks\base\core\java\android\view\WindowManagerPolicy.java</p>
<p>frameworks\base\core\res\res\values\strings.xml</p>
<p>frameworks\base\core\res\res\values-zh-rCN\strings.xml</p>
<p>frameworks\base\policy\src\com\android\internal\policy\impl\GlobalActions.java</p>
<p>frameworks\base\services\java\com\android\server\wm\windowManagerService.java</p>
<p>frameworks\base\services\java\com\android\server\power\ShutdownThread.java</p>
<p>frameworks\base\core\res\res\values\symbols.xml</p>
<p>首先找到长按电源键弹出的对话框，在frameworks\base\policy\src\com\android\internal\policy\impl\GlobalActions.java文件中 </p>
<p>[java] view plaincopyprint?</p>
<p>/**     * Create the global actions dialog.     * @return A new dialog.     */     private GlobalActionsDialog createDialog() {         …          …          mItems = new ArrayList&lt;Action&gt;();         // first: power off           mItems.add(              new SinglePressAction(                      com.android.internal.R.drawable.ic_lock_power_off,                      R.string.global_action_power_off) {                  public void onPress() {                      // shutdown by making sure radio and power are handled accordingly.                       mWindowManagerFuncs.shutdown(true);                  }                  public boolean onLongPress() {                      mWindowManagerFuncs.rebootSafeMode(true);                      return true;                  }                  public boolean showDuringKeyguard() {                      return true;                  }                  public boolean showBeforeProvisioning() {                      return true;                  }              });              //xiaoyuguang 20130616 add reboot item       mItems.add(              new SinglePressAction(                      com.android.internal.R.drawable.ic_lock_power_off,                      R.string.global_action_reboot) {                  public void onPress() {   // reboot                       mWindowManagerFuncs.reboot(true);   }                  public boolean onLongPress() {                      return true;                  }                  public boolean showDuringKeyguard() {                      return true;                  }                  public boolean showBeforeProvisioning() {                      return true;                  }              });   //end xiaoyuguang 20130616           …         …}    </p>
<p>在GlobalActionsDialog方法可以看 mItems.add这个方法是添加菜单选项的，该菜单的添加的第一个选项就是关机选项。可以仿照关机的Item添加一个重启的选项，如上面的代码所示；这样就解决了在长按的电源键弹出的对话框中添加一个重启选项了。当然这仅仅是添加一个显示而已，接下来就为这个选项添加逻辑控制代码了。</p>
<p>在上面的代码中使用的mWindowManagerFuncs.reboot方法和R.string.global_action_reboot资源（资源的添加放到最后说），默认是不存在的，所以需要在自己手动添加。</p>
<p>首先在找到WindowManagerFuncs这个所在的位置，在frameworks\base\core\java\android\view\WindowManagerPolicy.java中</p>
<p>[java] view plaincopyprint?</p>
<p>/**   * Interface for calling back in to the window manager that is private   * between it and the policy.   */   public interface WindowManagerFuncs {       …       …       /**       * Switch the keyboard layout for the given device.       * Direction should be +1 or -1 to go to the next or previous keyboard layout.       */       public void switchKeyboardLayout(int deviceId, int direction);       public void shutdown(boolean confirm);       public void rebootSafeMode(boolean confirm)        //xiaoyuguang        public void reboot(boolean confirm);      }    </p>
<p>添加reboot方法。但这只是添加接口而已，它的具体实现在呢？找了许久在frameworks\base\services\java\com\android\server\wm\windowManagerService.java中找到了这个接口的实现。</p>
<p>[java] view plaincopyprint?</p>
<p>/** {@hide} */   public class WindowManagerService extends IWindowManager.Stub            implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs,                    DisplayManagerService.WindowManagerFuncs, DisplayManager.DisplayListener {        …        …        // Called by window manager policy.  Not exposed externally.        @Override       public void shutdown(boolean confirm) {            ShutdownThread.shutdown(mContext, confirm);       }       //xiaoyuguang 20130616 add reboot        @Override       public void reboot(boolean confirm){            ShutdownThread.reboot(mContext, null, confirm);       }       //end xiaoyuguang        // Called by window manager policy.  Not exposed externally.        @Override       public void rebootSafeMode(boolean confirm) {            ShutdownThread.rebootSafeMode(mContext, confirm);       }       …       …}    </p>
<p>同样在仿照关机的原理添加reboot的具体实现代码，既然在ShutdownThread这个类中提供了shutdown和rebootSafeMode的方法，那按理也应该有reboot的方法，或者类似reboot的方法。找到Shutdown.java文件，在frameworks\base\services\java\com\android\server\power\ShutdownThread.java中，</p>
<p>[java] view plaincopyprint?</p>
<p>public final class ShutdownThread extends Thread {       …       …           /**       * Request a clean shutdown, waiting for subsystems to clean up their       * state etc.  Must be called from a Looper thread in which its UI       * is shown.       *       * @param context Context used to display the shutdown progress dialog.       * @param confirm true if user confirmation is needed before shutting down.       */       public static void shutdown(final Context context, boolean confirm) {       …       }            /**       * Request a clean shutdown, waiting for subsystems to clean up their       * state etc.  Must be called from a Looper thread in which its UI       * is shown.       *       * @param context Context used to display the shutdown progress dialog.       * @param reason code to pass to the kernel (e.g. &quot;recovery&quot;), or null.       * @param confirm true if user confirmation is needed before shutting down.       */       public static void reboot(final Context context, String reason, boolean confirm) {            mReboot = true;            mRebootSafeMode = false;            mRebootReason = reason;            Log.d(TAG, &quot;reboot&quot;);            shutdownInner(context, confirm);       }       …       …   }    </p>
<p>其中提供了一个静态的reboot方法，所以在windowManagerService.java中的reboot实现中直接调用ShutdownThread中reboot即可。</p>
<p> public static void reboot(final Context context, String reason, boolean confirm)；有三个参数，后两个参数解释如下： reason  如果值为是null，正常重启；如果是recovery，系统重启进入recovery mode ；confirm为true显示关机提示框，需要用户【确认】；false不显示提示框，直接关机。</p>
<p>到此重启功能基本上可以使用了（除资源还没有添加之外），但是此时选择重启选项时，其提示还是不够关机的提示，所以还要修改选择“重启”时的对话框的提示。</p>
<p>在frameworks\base\services\java\com\android\server\power\ShutdownThread.java中</p>
<p>[java] view plaincopyprint?</p>
<p>static void shutdownInner(final Context context, boolean confirm) {       …       …           final int resourceId = mRebootSafeMode                ? com.android.internal.R.string.reboot_safemode_confirm                : (longPressBehavior == 2                        ? com.android.internal.R.string.shutdown_confirm_question                        : com.android.internal.R.string.shutdown_confirm);       …        …                sConfirmDialog = new AlertDialog.Builder(context)                        .setTitle(mRebootSafeMode                                ? com.android.internal.R.string.reboot_safemode_title                                : com.android.internal.R.string.power_off)                        .setMessage(resourceId)       …       …   }    </p>
<p>修改如下： </p>
<p>[java] view plaincopyprint?</p>
<p>final int resourceId = mReboot    ? com.android.internal.R.string.reboot_confirm   : (mRebootSafeMode        ? com.android.internal.R.string.reboot_safemode_confirm        : (longPressBehavior == 2                ? com.android.internal.R.string.shutdown_confirm_question                : com.android.internal.R.string.shutdown_confirm));             …             …                 sConfirmDialog = new AlertDialog.Builder(context)                     .setTitle(mReboot                    ? com.android.internal.R.string.global_action_reboot                    : (mRebootSafeMode                        ? com.android.internal.R.string.reboot_safemode_title                        : com.android.internal.R.string.power_off))                     .setMessage(resourceId)    </p>
<p>至此关于代码部分的改动全部完成，接下就添加需要添加使用到的资源了，就是其中使用的字符串，为了简单起见就添加了英文和简体中文：</p>
<p>在对应的资源文件中添加：</p>
<p>frameworks\base\core\res\res\values\strings.xml</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;!– xiaoyuguang 20130616 –&gt;   &lt;!– label for item that turns reboot in device options dialog –&gt;           &lt;string name=&quot;global_action_reboot&quot;&gt;Reboot&lt;/string&gt;          &lt;string name=&quot;reboot_confirm&quot;&gt; Do you want to reboot your device?&lt;/string&gt;   &lt;!– end xiaoyuguang 20130616 –&gt;    </p>
<p>frameworks\base\core\res\res\values-zh-rCN\strings.xml</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;!– xiaoyuguang 20130616 –&gt;   &lt;string name=&quot;global_action_reboot&quot;&gt;重启&lt;/string&gt;   &lt;string name=&quot;reboot_confirm&quot;&gt;您要重新启动您的设备吗?&lt;/string&gt;   &lt;!– end xiaoyuguang 20130616–&gt;    </p>
<p>现在已经添加了好这些资源，但是现在还不能使用，此时编译会出现找不到该资源的错误，还需要在frameworks\base\core\res\res\values\symbols.xml（在4.1中是在frameworks\base\core\res\res\values\public.xml）文件中进行资源声明： </p>
<p>[html] view plaincopyprint?</p>
<p>&lt;java-symbol type=&quot;string&quot; name=&quot;global_action_reboot&quot; /&gt;   &lt;java-symbol type=&quot;string&quot; name=&quot;reboot_confirm&quot; /&gt;    </p>
<p>至此重启功能添加完毕，在编译前执行./mk -t update-api （因为新添加了接口）。</p>
<p>当然这仅仅是从框架层上进行修改，其底层的具体实现暂时还未探讨，有时间在去看看了。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>解析 Linux 中的 VFS 文件系统机制</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%A7%A3%E6%9E%90%20Linux%20%E4%B8%AD%E7%9A%84%20VFS%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<ol>
<li>摘要</li>
</ol>
<p>本文阐述 Linux 中的文件系统部分，源代码来自基于 IA32 的 2.4.20 内核。总体上说 Linux 下的文件系统主要可分为三大块：一是上层的文件系统的系统调用，二是虚拟文件系统 VFS(Virtual Filesystem Switch)，三是挂载到 VFS 中的各实际文件系统，例如 ext2，jffs 等。本文侧重于通过具体的代码分析来解释 Linux 内核中 VFS 的内在机制，在这过程中会涉及到上层文件系统调用和下层实际文件系统的如何挂载。文章试图从一个比较高的角度来解释 Linux 下的 VFS 文件系统机制，所以在叙述中更侧重于整个模块的主脉络，而不拘泥于细节，同时配有若干张插图，以帮助读者理解。</p>
<p>相对来说，VFS 部分的代码比较繁琐复杂，希望读者在阅读完本文之后，能对 Linux 下的 VFS 整体运作机制有个清楚的理解。建议读者在阅读本文前，先尝试着自己阅读一下文件系统的源代码，以便建立起 Linux 下文件系统最基本的概念，比如至少应熟悉 super block, dentry, inode，vfsmount 等数据结构所表示的意义，这样再来阅读本文以便加深理解。</p>
<ol start="2">
<li>VFS 概述</li>
</ol>
<p>VFS 是一种软件机制，也许称它为 Linux 的文件系统管理者更确切点，与它相关的数据结构只存在于物理内存当中。所以在每次系统初始化期间，Linux 都首先要在内存当中构造一棵 VFS 的目录树(在 Linux 的源代码里称之为 namespace)，实际上便是在内存中建立相应的数据结构。VFS 目录树在 Linux 的文件系统模块中是个很重要的概念，希望读者不要将其与实际文件系统目录树混淆，在笔者看来，VFS 中的各目录其主要用途是用来提供实际文件系统的挂载点，当然在 VFS 中也会涉及到文件级的操作，本文不阐述这种情况。下文提到目录树或目录，如果不特别说明，均指 VFS 的目录树或目录。图 1 是一种可能的目录树在内存中的影像：</p>
<p>图 1：VFS 目录树结构</p>
<ol start="3">
<li>文件系统的注册</li>
</ol>
<p>这里的文件系统是指可能会被挂载到目录树中的各个实际文件系统，所谓实际文件系统，即是指VFS 中的实际操作最终要通过它们来完成而已，并不意味着它们一定要存在于某种特定的存储设备上。比如在笔者的 Linux 机器下就注册有 &quot;rootfs&quot;、&quot;proc&quot;、&quot;ext2&quot;、&quot;sockfs&quot; 等十几种文件系统。</p>
<p>3.1 数据结构</p>
<p>在 Linux 源代码中，每种实际的文件系统用以下的数据结构表示：</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>struct file_system_type {</p>
<p>const char *name;</p>
<p>int fs_flags;</p>
<p>struct super_block *(*read_super) (struct super_block *, void *, int);</p>
<p>struct module *owner;</p>
<p>struct file_system_type * next;</p>
<p>struct list_head fs_supers;</p>
<p>};</p>
<p>注册过程实际上将表示各实际文件系统的 struct file_system_type 数据结构的实例化，然后形成一个链表，内核中用一个名为 file_systems 的全局变量来指向该链表的表头。</p>
<p>3.2 注册 rootfs 文件系统</p>
<p>在众多的实际文件系统中，之所以单独介绍 rootfs 文件系统的注册过程，实在是因为该文件系统 VFS 的关系太过密切，如果说 ext2/ext3 是 Linux 的本土文件系统，那么 rootfs 文件系统则是 VFS 存在的基础。一般文件系统的注册都是通过 module_init 宏以及 do_initcalls() 函数来完成(读者可通过阅读module_init 宏的声明及 arch\i386\vmlinux.lds 文件来理解这一过程)，但是 rootfs 的注册却是通过 init_rootfs() 这一初始化函数来完成，这意味着 rootfs 的注册过程是 Linux 内核初始化阶段不可分割的一部分。</p>
<p>init_rootfs() 通过调用 register_filesystem(&amp;rootfs_fs_type) 函数来完成 rootfs 文件系统注册的，其中rootfs_fs_type 定义如下：</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>struct file_system_type rootfs_fs_type = { \</p>
<p>name:       &quot;rootfs&quot;, \</p>
<p>read_super: ramfs_read_super, \</p>
<p>fs_flags:   FS_NOMOUNT|FS_LITTER, \</p>
<p>owner:      THIS_MODULE, \</p>
<p>}</p>
<p>注册之后的 file_systems 链表结构如下图2所示：</p>
<p>图 2: file_systems 链表结构</p>
<ol start="4">
<li>VFS 目录树的建立</li>
</ol>
<p>既然是树，所以根是其赖以存在的基础，本节阐述 Linux 在初始化阶段是如何建立根结点的，即 &quot;/&quot;目录。这其中会包括挂载 rootfs 文件系统到根目录 &quot;/&quot; 的具体过程。构造根目录的代码是在 init_mount_tree（） 函数 （fs\namespace.c） 中。</p>
<p>首先，init_mount_tree() 函数会调用 do_kern_mount(&quot;rootfs&quot;, 0, &quot;rootfs&quot;, NULL) 来挂载前面已经注册了的 rootfs 文件系统。这看起来似乎有点奇怪，因为根据前面的说法，似乎是应该先有挂载目录，然后再在其上挂载相应的文件系统，然而此时 VFS 似乎并没有建立其根目录。没关系，这是因为这里我们调用的是 do_kern_mount()，这个函数内部自然会创建我们最关心也是最关键的根目录(在 Linux 中，目录对应的数据结构是 struct dentry)。</p>
<p>在这个场景里，do_kern_mount() 做的工作主要是：</p>
<p>1）调用 alloc_vfsmnt() 函数在内存里申请了一块该类型的内存空间（struct vfsmount *mnt），并初始化其部分成员变量。</p>
<ol start="2">
<li><p>调用 get_sb_nodev（） 函数在内存中分配一个超级块结构 (struct super_block) sb，并初始化其部分成员变量，将成员 s_instances 插入到 rootfs 文件系统类型结构中的 fs_supers 指向的双向链表中。</p>
</li>
<li><p>通过 rootfs 文件系统中的 read_super 函数指针调用 ramfs_read_super() 函数。还记得当初注册rootfs 文件系统时，其成员 read_super 指针指向了 ramfs_read_super() 函数，参见图2.</p>
</li>
<li><p>ramfs_read_super() 函数调用 ramfs_get_inode() 在内存中分配了一个 inode 结构 (struct inode) inode，并初始化其部分成员变量，其中比较重要的有 i_op、i_fop 和 i_sb：</p>
</li>
</ol>
<p>1</p>
<p>2</p>
<p>3</p>
<p>inode-&gt;i_op = &amp;ramfs_dir_inode_operations;</p>
<p>inode-&gt;i_fop = &amp;dcache_dir_ops;</p>
<p>inode-&gt;i_sb = sb;</p>
<p>这使得将来通过文件系统调用对 VFS 发起的文件操作等指令将被 rootfs 文件系统中相应的函数接口所接管。</p>
<p>图3</p>
<ol start="5">
<li><p>ramfs_read_super() 函数在分配和初始化了 inode 结构之后，会调用 d_alloc_root() 函数来为 VFS的目录树建立起关键的根目录 (struct dentry)dentry，并将 dentry 中的 d_sb 指针指向 sb，d_inode 指针指向 inode。</p>
</li>
<li><p>将 mnt 中的 mnt_sb 指针指向 sb，mnt_root 和 mnt_mountpoint 指针指向 dentry，而 mnt_parent指针则指向自身。</p>
</li>
</ol>
<p>这样，当 do_kern_mount() 函数返回时，以上分配出来的各数据结构和 rootfs 文件系统的关系将如上图 3 所示。图中 mnt、sb、inode、dentry 结构块下方的数字表示它们在内存里被分配的先后顺序。限于篇幅的原因，各结构中只给出了部分成员变量，读者可以对照源代码根据图中所示按图索骥，以加深理解。</p>
<p>最后，init_mount_tree() 函数会为系统最开始的进程(即 init_task 进程)准备它的进程数据块中的namespace 域，主要目的是将 do_kern_mount() 函数中建立的 mnt 和 dentry 信息记录在了 init_task 进程的进程数据块中，这样所有以后从 init_task 进程 fork 出来的进程也都先天地继承了这一信息，在后面用sys_mkdir 在 VFS 中创建一个目录的过程中，我们可以看到这里为什么要这样做。为进程建立 namespace 的主要代码如下：</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>namespace = kmalloc(sizeof(*namespace), GFP_KERNEL);</p>
<p>list_add(&amp;mnt-&gt;mnt_list, &amp;namespace-&gt;list);  //mnt is returned by do_kern_mount()</p>
<p>namespace-&gt;root = mnt;</p>
<p>init_task.namespace = namespace;</p>
<p>for_each_task(p) {</p>
<p>get_namespace(namespace);</p>
<p>p-&gt;namespace = namespace;</p>
<p>}</p>
<p>set_fs_pwd(current-&gt;fs, namespace-&gt;root, namespace-&gt;root-&gt;mnt_root);</p>
<p>set_fs_root(current-&gt;fs, namespace-&gt;root, namespace-&gt;root-&gt;mnt_root);</p>
<p>该段代码的最后两行便是将 do_kern_mount() 函数中建立的 mnt 和 dentry 信息记录在了当前进程的 fs结构中。</p>
<p>以上讲了一大堆数据结构的来历，其实最终目的不过是要在内存中建立一颗 VFS 目录树而已，更确切地说， init_mount_tree() 这个函数为 VFS 建立了根目录 &quot;/&quot;，而一旦有了根，那么这棵数就可以发展壮大，比如可以通过系统调用 sys_mkdir 在这棵树上建立新的叶子节点等，所以系统设计者又将 rootfs 文件系统挂载到了这棵树的根目录上。关于 rootfs 这个文件系统，读者如果看一下前面图 2 中它的file_system_type 结构，会发现它的一个成员函数指针 read_super 指向的是 ramfs_read_super，单从这个函数名称中的 ramfs，读者大概能猜测出这个文件所涉及的文件操作都是针对内存中的数据对象，事实上也的确如此。从另一个角度而言，因为 VFS 本身就是内存中的一个数据对象，所以在其上的操作仅限于内存，那也是非常合乎逻辑的事。在接下来的章节中，我们会用一个具体的例子来讨论如何利用 rootfs所提供的函树为 VFS 增加一个新的目录节点。</p>
<p>VFS 中各目录的主要用途是为以后挂载文件系统提供挂载点。所以真正的文件操作还是要通过挂载后的文件系统提供的功能接口来进行。</p>
<ol start="5">
<li>VFS 下目录的建立</li>
</ol>
<p>为了更好地理解 VFS，下面我们用一个实际例子来看看 Linux 是如何在 VFS 的根目录下建立一个新的目录 &quot;/dev&quot; 的。</p>
<p>要在 VFS 中建立一个新的目录，首先我们得对该目录进行搜索，搜索的目的是找到将要建立的目录其父目录的相关信息，因为&quot;皮之不存，毛将焉附&quot;。比如要建立目录 /home/ricard，那么首先必须沿目录路径进行逐层搜索，本例中先从根目录找起，然后在根目录下找到目录 home，然后再往下，便是要新建的目录名 ricard，那么前面讲得要先对目录搜索，在该例中便是要找到 ricard 这个新目录的父目录，也就是 home 目录所对应的信息。</p>
<p>当然，如果搜索的过程中发现错误，比如要建目录的父目录并不存在，或者当前进程并无相应的权限等等，这种情况系统必然会调用相关过程进行处理，对于此种情况，本文略过不提。</p>
<p>Linux 下用系统调用 sys_mkdir 来在 VFS 目录树中增加新的节点。同时为配合路径搜索，引入了下面一个数据结构：</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>struct nameidata {</p>
<p>struct dentry *dentry;</p>
<p>struct vfsmount *mnt;</p>
<p>struct qstr last;</p>
<p>unsigned int flags;</p>
<p>int last_type;</p>
<p>};</p>
<p>这个数据结构在路径搜索的过程中用来记录相关信息，起着类似&quot;路标&quot;的作用。其中前两项中的 dentry记录的是要建目录的父目录的信息，mnt 成员接下来会解释到。后三项记录的是所查找路径的最后一个节点(即待建目录或文件)的信息。 现在为建立目录 &quot;/dev&quot; 而调用 sys_mkdir(&quot;/dev&quot;, 0700)，其中参数 0700 我们不去管它，它只是限定将要建立的目录的某种模式。sys_mkdir 函数首先调用 path_lookup(&quot;/dev&quot;, LOOKUP_PARENT, &amp;nd)；来对路径进行查找，其中 nd 为 struct nameidata nd 声明的变量。在接下来的叙述中，因为函数调用关系的繁琐，为了突出过程主线，将不再严格按照函数的调用关系来进行描述。</p>
<p>path_lookup 发现 &quot;/dev&quot; 是以 &quot;/&quot; 开头，所以它从当前进程的根目录开始往下查找，具体代码如下：</p>
<p>1</p>
<p>2</p>
<p>nd-&gt;mnt = mntget(current-&gt;fs-&gt;rootmnt);</p>
<p>nd-&gt;dentry = dget(current-&gt;fs-&gt;root);</p>
<p>记得在 init_mount_tree() 函数的后半段曾经将新建立的 VFS 根目录相关信息记录在了 init_task 进程的进程数据块中，那么在这个场景里，nd-&gt;mnt 便指向了图 3 中 mnt 变量，nd-&gt;dentry 便指向了图 3 中的 dentry 变量。</p>
<p>然后调用函数 path_walk 接着往下查找，找到最后通过变量 nd 返回的信息是 nd.last.name=&quot;dev&quot;，nd.last.len=3，nd.last_type=LAST_NORM，至于 nd 中 mnt 和 dentry 成员，在这个场景里还是前面设置的值，并无变化。这样一圈下来，只是用 nd 记录下相关信息，实际的目录建立工作并没有真正展开，但是前面所做的工作却为接下来建立新的节点收集了必要的信息。</p>
<p>好，到此为止真正建立新目录节点的工作将会展开，这是由函数 lookup_create 来完成的，调用这个函数时会传入两个参数：lookup_create(&amp;nd, 1)；其中参数 nd 便是前面提到的变量，参数1表明要建立一个新目录。</p>
<p>这里的大体过程是：新分配了一个 struct dentry 结构的内存空间，用于记录 dev 目录所对应的信息，该dentry 结构将会挂接到其父目录中，也就是图 3 中 &quot;/&quot; 目录对应的 dentry 结构中，由链表实现这一关系。接下来会再分配一个 struct inode 结构。Inode 中的 i_sb 和 dentry 中的 d_sb 分别都指向图 3 中的 sb，这样看来，在同一文件系统下建立新的目录时并不需要重新分配一个超级块结构，因为毕竟它们都属于同一文件系统，因此一个文件系统只对应一个超级块。</p>
<p>这样，当调用 sys_mkdir 成功地在 VFS 的目录树中新建立一个目录 &quot;/dev&quot; 之后，在图 3 的基础上，新的数据结构之间的关系便如图 4 所示。图 4 中颜色较深的两个矩形块 new_inode 和 new_entry 便是在sys_mkdir() 函数中新分配的内存结构，至于图中的 mnt,sb,dentry,inode 等结构，仍为图 3 中相应的数据结构，其相互之间的链接关系不变(图中为避免过多的链接曲线，忽略了一些链接关系，如 mnt 和 sb,dentry之间的链接，读者可在图 3 的基础上参看图 4)。</p>
<p>需要强调一点的是，既然 rootfs 文件系统被 mount 到了 VFS 树上，那么它在 sys_mkdir 的过程中必然会参与进来，事实上在整个过程中，rootfs 文件系统中的 ramfs_mkdir、ramfs_lookup 等函数都曾被调用过。</p>
<p>图 4: 在 VFS 树中新建一目录 &quot;dev&quot;</p>
<ol start="6">
<li>在 VFS 树中挂载文件系统</li>
</ol>
<p>在本节中，将描述在 VFS 的目录树中向其中某个目录(安装点 mount point)上挂载(mount)一个文件系统的过程。</p>
<p>这一过程可简单描述为：将某一设备(dev_name)上某一文件系统(file_system_type)安装到VFS目录树上的某一安装点(dir_name)。它要解决的问题是：将对 VFS 目录树中某一目录的操作转化为具体安装到其上的实际文件系统的对应操作。比如说，如果将 hda2 上的根文件系统(假设文件系统类型为 ext2)安装到了前一节中新建立的 &quot;/dev&quot; 目录上(此时，&quot;/dev&quot; 目录就成为了安装点)，那么安装成功之后应达到这样的目的，即：对 VFS 文件系统的 &quot;/dev&quot; 目录执行 &quot;ls&quot; 指令，该条指令应能列出 hda2 上 ext2 文件系统的根目录下所有的目录和文件。很显然，这里的关键是如何将对 VFS 树中 &quot;/dev&quot; 的目录操作指令转化为安装在其上的 ext2 这一实际文件系统中的相应指令。所以，接下来的叙述将抓住如何转化这一核心问题。在叙述之前，读者不妨自己设想一下 Linux 系统会如何解决这一问题。记住：对目录或文件的操作将最终由目录或文件所对应的 inode 结构中的 i_op 和 i_fop 所指向的函数表中对应的函数来执行。所以，不管最终解决方案如何，都可以设想必然要通过将对 &quot;/dev&quot; 目录所对应的 inode 中 i_op 和 i_fop 的调用转换到 hda2 上根文件系统 ext2 中根目录所对应的 inode 中 i_op 和 i_fop 的操作。</p>
<p>初始过程由 sys_mount() 系统调用函数发起，该函数原型声明如下：</p>
<p>1</p>
<p>2</p>
<p>asmlinkage long sys_mount(char * dev_name, char * dir_name, char * type,</p>
<p>unsigned long flags, void * data);</p>
<p>其中，参数 char *type 为标识将要安装的文件系统类型字符串，对于 ext2 文件系统而言，就是&quot;ext2&quot;。参数 flags 为安装时的模式标识数，和接下来的 data 参数一样，本文不将其做为重点。</p>
<p>为了帮助读者更好地理解这一过程，笔者用一个具体的例子来说明：我们准备将来自主硬盘第 2 分区(hda2)上的 ext2 文件系统安装到前面创建的 &quot;/dev&quot; 目录中。那么对于 sys_mount() 函数的调用便具体为：</p>
<p>1</p>
<p>sys_mount(&quot;hda2&quot;,&quot;/dev &quot;,&quot;ext2&quot;,…)；</p>
<p>该函数在将这些来自用户内存空间(user space)的参数拷贝到内核空间后，便调用 do_mount() 函数开始真正的安装文件系统的工作。同样，为了便于叙述和讲清楚主流程，接下来的说明将不严格按照具体的函数调用细节来进行。</p>
<p>do_mount() 函数会首先调用 path_lookup() 函数来得到安装点的相关信息，如同创建目录过程中叙述的那样，该安装点的信息最终记录在 struct nameidata 类型的一个变量当中，为叙述方便，记该变量为nd。在本例中当 path_lookup() 函数返回时，nd 中记录的信息如下：nd.entry = new_entry; nd.mnt = mnt; 这里的变量如图 3 和 4 中所示。</p>
<p>然后，do_mount() 函数会根据调用参数 flags 来决定调用以下四个函数之一：do_remount()、 do_loopback()、do_move_mount()、do_add_mount()。</p>
<p>在我们当前的例子中，系统会调用 do_add_mount() 函数来向 VFS 树中安装点 &quot;/dev &quot; 安装一个实际的文件系统。在 do_add_mount() 中，主要完成了两件重要事情：一是获得一个新的安装区域块，二是将该新的安装区域块加入了安装系统链表。它们分别是调用 do_kern_mount() 函数和 graft_tree() 函数来完成的。这里的描述可能有点抽象，诸如安装区域块、安装系统链表等，不过不用着急，因为它们都是笔者自己定义出来的概念，等一下到后面会有专门的图表解释，到时便会清楚。</p>
<p>do_kern_mount() 函数要做的事情，便是建立一新的安装区域块，具体的内容在前面的章节 VFS 目录树的建立中已经叙述过，这里不再赘述。</p>
<p>graft_tree() 函数要做的事情便是将 do_kern_mount() 函数返回的一 struct vfsmount 类型的变量加入到安装系统链表中，同时 graft_tree() 还要将新分配的 struct vfsmount 类型的变量加入到一个hash表中，其目的我们将会在以后看到。</p>
<p>这样，当 do_kern_mount() 函数返回时，在图 4 的基础上，新的数据结构间的关系将如图 5 所示。其中，红圈区域里面的数据结构便是被称做安装区域块的东西，其中不妨称 e2_mnt 为安装区域块的指针，蓝色箭头曲线即构成了所谓的安装系统链表。</p>
<p>在把这些函数调用后形成的数据结构关系理清楚之后，让我们回到本章节开始提到的问题，即将 ext2 文件系统安装到了 &quot;/dev &quot; 上之后，对该目录上的操作如何转化为对 ext2 文件系统相应的操作。从图 5上看到，对 sys_mount() 函数的调用并没有直接改变 &quot;/dev &quot; 目录所对应的 inode (即图中的 new_inode变量)结构中的 i_op 和 i_fop 指针，而且 &quot;/dev &quot; 所对应的 dentry(即图中的 new_dentry 变量)结构仍然在 VFS 的目录树中，并没有被从其中隐藏起来，相应地，来自 hda2 上的 ext2 文件系统的根目录所对应的 e2_entry 也不是如当初笔者所想象地那样将 VFS 目录树中的 new_dentry 取而代之，那么这之间的转化到底是如何实现的呢？</p>
<p>请读者注意下面的这段代码：</p>
<p>1</p>
<p>while (d_mountpoint(dentry) &amp;&amp; __follow_down(&amp;nd-&gt;mnt, &amp;dentry));</p>
<p>这段代码在 link_path_walk() 函数中被调用，而 link_path_walk() 最终又会被 path_lookup() 函数调用，如果读者阅读过 Linux 关于文件系统部分的代码，应该知道 path_lookup() 函数在整个 Linux 繁琐的文件系统代码中属于一个重要的基础性的函数。简单说来，这个函数用于解析文件路径名，这里的文件路径名和我们平时在应用程序中所涉及到的概念相同，比如在 Linux 的应用程序中 open 或 read 一个文件 /home/windfly.cs 时，这里的 /home/windfly.cs 就是文件路径名，path_lookup() 函数的责任就是对文件路径名中进行搜索，直到找到目标文件所属目录所对应的 dentry 或者目标直接就是一个目录，笔者不想在有限的篇幅里详细解释这个函数，读者只要记住 path_lookup() 会返回一个目标目录即可。</p>
<p>上面的代码非常地不起眼，以至于初次阅读文件系统的代码时经常会忽略掉它，但是前文所提到从 VFS 的操作到实际文件系统操作的转化却是由它完成的，对 VFS 中实现的文件系统的安装可谓功不可没。现在让我们仔细剖析一下该段代码： d_mountpoint(dentry) 的作用很简单，它只是返回 dentry 中 d_mounted 成员变量的值。这里的dentry 仍然还是 VFS 目录树上的东西。如果 VFS 目录树上某个目录被安装过一次，那么该值为 1。对VFS 中的一个目录可进行多次安装，后面会有例子说明这种情况。在我们的例子中，&quot;/dev&quot; 所对应的new_dentry 中 d_mounted=1，所以 while 循环中第一个条件满足。下面再来看__follow_down(&amp;nd-&gt;mnt, &amp;dentry)代</p>
<p>图 5：安装 ext2 类型根文件系统到 &quot;/dev &quot; 目录上</p>
<p>码做了什么？到此我们应该记住，这里 nd 中的 dentry 成员就是图 5 中的 new_dentry，nd 中的 mnt成员就是图 5 中的 mnt，所以我们现在可以把 __follow_down(&amp;nd-&gt;mnt, &amp;dentry) 改写成__follow_down(&amp;mnt, &amp;new_dentry)，接下来我们将 __follow_down() 函数的代码改写(只是去处掉一些不太相关的代码，并且为了便于说明，在部分代码行前加上了序号)如下：</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>static inline int __follow_down(struct vfsmount **mnt, struct dentry **dentry)</p>
<p>{</p>
<p>struct vfsmount *mounted;</p>
<p>[1] mounted = lookup_mnt(*mnt, *dentry);</p>
<p>if (mounted) {</p>
<p>[2]     *mnt = mounted;</p>
<p>[3]     *dentry = mounted-&gt;mnt_root;</p>
<p>return 1;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>代码行[1]中的 lookup_mnt() 函数用于查找一个 VFS 目录树下某一目录最近一次被 mount 时的安装区域块的指针，在本例中最终会返回图 5 中的 e2_mnt。至于查找的原理，这里粗略地描述一下。记得当我们在安装 ext2 文件系统到 &quot;/dev&quot; 时，在后期会调用 graft_tree() 函数，在这个函数里会把图 5 中的安装区域块指针 e2_mnt 挂到一 hash 表(Linux 2.4.20源代码中称之为 mount_hashtable)中的某一项，而该项的键值就是由被安装点所对应的 dentry(本例中为 new_dentry)和 mount(本例中为 mnt)所共同产生，所以自然地，当我们知道 VFS 树中某一 dentry 被安装过(该 dentry 变成为一安装点)，而要去查找其最近一次被安装的安装区域块指针时，同样由该安装点所对应的 dentry 和 mount 来产生一键值，以此值去索引 mount_hashtable，自然可找到该安装点对应的安装区域块指针形成的链表的头指针，然后遍历该链表，当发现某一安装区域块指针，记为 p，满足以下条件时：</p>
<p>1</p>
<p>(p-&gt;mnt_parent == mnt &amp;&amp; p-&gt;mnt_mountpoint == dentry)</p>
<p>P 便为该安装点所对应的安装区域块指针。当找到该指针后，便将 nd 中的 mnt 成员换成该安装区域块指针，同时将 nd 中的 dentry 成员换成安装区域块中的 dentry 指针。在我们的例子中，e2_mnt-&gt;mnt_root成员指向 e2_dentry，也就是 ext2 文件系统的 &quot;/&quot; 目录。这样，当 path_lookup() 函数搜索到 &quot;/dev&quot;时，nd 中的 dentry 成员为 e2_dentry，而不再是原来的 new_dentry，同时 mnt 成员被换成 e2_mnt，转化便在不知不觉中完成了。</p>
<p>现在考虑一下对某一安装点多次安装的情况，同样作为例子，我们假设在 &quot;/dev&quot; 上安装完一个 ext2文件系统后，再在其上安装一个 ntfs 文件系统。在安装之前，同样会对安装点所在的路径调用path_lookup() 函数进行搜索，但是这次由于在 &quot;/dev&quot; 目录上已经安装过了 ext2 文件系统，所以搜索到最后，由 nd 返回的信息是：nd.dentry = e2_dentry, nd.mnt = e2_mnt。由此可见，在第二次安装时，安装点已经由 dentry 变成了 e2_dentry。接下来，同样地，系统会再分配一个安装区域块，假设该安装区域块的指针为 ntfs_mnt，区域块中的 dentry 为 ntfs_dentry。ntfs_mnt 的父指针指向了e2_mnt，mnfs_mnt 中的 mnt_root 指向了代表 ntfs 文件系统根目录的 ntfs_dentry。然后，系统通过 e2_dentry和 e2_mnt 来生成一个新的 hash 键值，利用该值作为索引，将 ntfs_mnt 加入到 mount_hashtable 中，同时将 e2_dentry 中的成员 d_mounted 值设定为 1。这样，安装过程便告结束。</p>
<p>读者可能已经知道，对同一安装点上的最近一次安装会隐藏起前面的若干次安装，下面我们通过上述的例子解释一下该过程：</p>
<p>在先后将 ext2 和 ntfs 文件系统安装到 &quot;/dev&quot; 目录之后，我们再调用 path_lookup() 函数来对&quot;/dev&quot; 进行搜索，函数首先找到 VFS 目录树下的安装点 &quot;/dev&quot; 所对应的 dentry 和 mnt，此时它发现dentry 成员中的 d_mounted 为 1，于是它知道已经有文件系统安装到了该 dentry 上，于是它通过 dentry 和 mnt 来生成一个 hash 值，通过该值来对 mount_hashtable 进行搜索，根据安装过程，它应该能找到 e2_mnt 指针并返回之，同时原先的 dentry 也已经被替换成 e2_dentry。回头再看一下前面已经提到的下列代码： while (d_mountpoint(dentry) &amp;&amp; __follow_down(&amp;nd-&gt;mnt, &amp;dentry)); 当第一次循环结束后, nd-&gt;mnt 已经是 e2_mnt，而 dentry 则变成 e2_dentry。此时由于 e2_dentry 中的成员 d_mounted 值为 1，所以 while 循环的第一个条件满足，要继续调用 __follow_down() 函数，这个函数前面已经剖析过，当它返回后 nd-&gt;mnt 变成了 ntfs_mnt，dentry 则变成了 ntfs_dentry。由于此时 ntfs_dentry 没有被安装过其他文件，所以它的成员 d_mounted 应该为 0，循环结束。对 &quot;/dev&quot; 发起的 path_lookup() 函数最终返回了 ntfs 文件系统根目录所对应的 dentry。这就是为什么 &quot;/dev&quot; 本身和安装在其上的 ext2 都被隐藏的原因。如果此时对 &quot;/dev&quot; 目录进行一个 ls 命令，将返回安装上去的 ntfs 文件系统根目录下所有的文件和目录。</p>
<ol start="7">
<li>安装根文件系统</li>
</ol>
<p>有了前面章节 5 的基础，理解 Linux 下根文件系统的安装并不困难，因为不管怎么样，安装一个文件系统到 VFS 中某一安装点的过程原理毕竟都是一样的。</p>
<p>这个过程大致是：首先要确定待安装的 ext2 文件系统的来源，其次是确定 ext2 文件系统在 VFS中的安装点，然后便是具体的安装过程。</p>
<p>关于第一问题，Linux 2.4.20 的内核另有一大堆的代码去解决，限于篇幅，笔者不想在这里去具体说明这个过程，大概记住它是要解决到哪里去找要安装的文件系统的就可以了，这里我们不妨就认为要安装的根文件系统就来自于主硬盘的第一分区 hda1.</p>
<p>关于第二个问题，Linux 2.4.20 的内核把来自于 hda1 上 ext2 文件系统安装到了 VFS 目录树中的&quot;/root&quot; 目录上。其实，把 ext2 文件系统安装到 VFS 目录树下的哪个安装点并不重要(VFS 的根目录除外)，只要是这个安装点在 VFS 树中是存在的，并且内核对它没有另外的用途。如果读者喜欢，尽可以自己在 VFS 中创建一个 &quot;/Windows&quot; 目录，然后将 ext2 文件系统安装上去作为将来用户进程的根目录，没有什么不可以的。问题的关键是要将进程的根目录和当前工作目录设定好，因为毕竟只用用户进程才去关心现实的文件系统，要知道笔者的这篇稿子可是要存到硬盘上去的。</p>
<p>在 Linux 下，设定一个进程的当前工作目录是通过系统调用 sys_chdir() 进行的。初始化期间，Linux 在将 hda1 上的 ext2 文件系统安装到了 &quot;/root&quot; 上后，通过调用 sys_chdir(&quot;/root&quot;) 将当前进程，也就是 init_task 进程的当前工作目录(pwd)设定为 ext2 文件系统的根目录。记住此时 init_task进程的根目录仍然是图 3 中的 dentry，也就是 VFS 树的根目录，这显然是不行的，因为以后 Linux 世界中的所有进程都由这个 init_task 进程派生出来，无一例外地要继承该进程的根目录，如果是这样，意味着用户进程从根目录搜索某一目录时，实际上是从 VFS 的根目录开始的，而事实上却是从 ext2 的根文件开始搜索的。这个矛盾的解决是靠了在调用完 mount_root() 函数后，系统调用的下面两个函数：</p>
<p>1</p>
<p>2</p>
<p>sys_mount(&quot;.&quot;, &quot;/&quot;, NULL, MS_MOVE, NULL);</p>
<p>sys_chroot(&quot;.&quot;);</p>
<p>其主要作用便是将 init_task 进程的根目录转化成安装上去的 ext2 文件系统的根目录。有兴趣的读者可以自行去研究这一过程。</p>
<p>所以在用户空间下，更多地情况是只能见到 VFS 这棵大树的一叶，而且还是被安装过文件系统了的，实际上对用户空间来说还是不可见。我想，VFS 更多地被内核用来实现自己的功能，并以系统调用的方式提供过用户进程使用，至于在其上实现的不同文件系统的安装，也只是其中的一个功能罢了。</p>
<ol start="8">
<li>结束语</li>
</ol>
<p>文件系统在整个 Linux 的内核中具有举足轻重的地位，代码量也很复杂繁琐。但是因为其重要的地位，要想对 Linux 的内核有比较深入的理解，必须要能越过文件系统这一关。当然阅读其源代码便是其中最好的方法，本文试图给那些已经尝试着去阅读，但是目前尚有困惑的读者画一张 VFS 文件系统的草图，希望能对读者有些许启发。但是想在如此有限的篇幅里去阐述清楚 Linux 中整个文件系统的来龙去脉，是根本不现实的。而且本文也只是侧重于剖析 VFS 的机制，对于象具体的文件读写，为提高效率而引入的各种 buffer,hash 等内容以及文件系统的安全性方面，都没有提到。毕竟，本文只想帮助读者理清一个大体的脉络，最终的理解与领悟，还得靠读者自己去潜心研究源代码。最后，对本文相关的任何问题或建议，都欢迎用 email 和笔者联系。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>文档06-H264解码流程</title>
    <url>/2020/12/31/%E9%9F%B3%E8%A7%86%E9%A2%91/%E6%96%87%E6%A1%A306-H264%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="H264解码详解"><a href="#H264解码详解" class="headerlink" title="H264解码详解"></a>H264解码详解</h4><p>​        H264是新一代的编码标准，以高压缩高质量和支持多种网络的流媒体传输著称，在编码方面，我理解的他的理论依据是：参照一段时间内图像的统计结果表明，在相邻几幅图像画面中，一般有差别的像素只有10%以内的点,亮度差值变化不超过2%，而色度差值的变化只有1%以内。所以对于一段变化不大图像画面，我们可以先编码出一个完整的图像帧A，随后的B帧就不编码全部图像，只写入与A帧的差别，这样B帧的大小就只有完整帧的1/10或更小！B帧之后的C帧如果变化不大，我们可以继续以参考B的方式编码C帧，这样循环下去。这段图像我们称为一个序列（序列就是有相同特点的一段数据），当某个图像与之前的图像变化很大，无法参考前面的帧来生成，那我们就结束上一个序列，开始下一段序列，也就是对这个图像生成一个完整帧A1，随后的图像就参考A1生成，只写入与A1的差别内容。</p>
<p>​    在H264协议里定义了三种帧，完整编码的帧叫I帧，参考之前的I帧生成的只包含差异部分编码的帧叫P帧，还有一种参考前后的帧编码的帧叫B帧。</p>
<p>​    H264采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成I帧的算法，帧间压缩是生成B帧和P帧的算法。</p>
<p>-———————</p>
<p>序列的说明</p>
<p>-———————</p>
<p>​    在H264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流，以I帧开始，到下一个I帧结束。</p>
<p>​    <strong><em>\</em>一个序列的第一个图像叫做 IDR图像（立即刷新图像），IDR 图像都是 I 帧图像。\</strong>*<em>H.264引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。****</em>这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。*</p>
<p>​    一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。</p>
<p>-———————-</p>
<p>三种帧的说明</p>
<p>-———————-</p>
<p>I帧:帧内编码帧，I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）</p>
<p>I帧特点:<br>1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;<br>2.解码时仅用I帧的数据就可重构完整图像;<br>3.I帧描述了图像背景和运动主体的详情;<br>4.I帧不需要参考其他画面而生成;<br>5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);<br>6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;<br>7.I帧不需要考虑运动矢量;<br>8.I帧所占数据的信息量比较大。</p>
<p>P帧:前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>
<p>P帧的预测与重构:P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。<br>P帧特点:<br>1.P帧是I帧后面相隔1~2帧的编码帧;<br>2.P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);<br>3.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;<br>4.P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;<br>5.P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;<br>6.由于P帧是参考帧,它可能造成解码错误的扩散;<br>7.由于是差值传送,P帧的压缩比较高。</p>
<p>B帧:双向预测内插编码帧。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况，但我这样说简单些），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。</p>
<p>B帧的预测与重构<br>B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。<br>B帧特点<br>1.B帧是由前面的I或P帧和后面的P帧来进行预测的;<br>2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;<br>3.B帧是双向预测编码帧;<br>4.B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;<br>5.B帧不是参考帧,不会造成解码错误的扩散。</p>
<p>注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</p>
<p>-——————————-</p>
<p>压缩算法的说明</p>
<p>-——————————-</p>
<p>h264的压缩方法:</p>
<p>1.分组:把几帧图像分为一组(GOP，也就是一个序列),为防止运动变化,帧数不宜取多。<br>2.定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧;<br>3.预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧;<br>4.数据传输:最后将I帧数据与预测的差值信息进行存储和传输。</p>
<p>​    帧内（Intraframe）压缩也称为空间压缩（Spatialcompression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示。帧内压缩一般达不到很高的压缩，跟编码jpeg差不多。
　　</p>
<p>​    帧间（Interframe）压缩的原理是：相邻几帧的数据有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息,根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporalcompression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Framedifferencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。</p>
<p>   顺便说下有损（Lossy ）压缩和无损（Lossyless）压缩。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息,而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩,这样才能达到低数据率的目标。丢失的数据率与压缩比有关,压缩比越小，丢失的数据越多,解压缩后的效果一般越差。此外,某些有损压缩算法采用多次重复压缩的方式,这样还会引起额外的数据丢失。</p>
<p><strong>H264层次构成</strong></p>
<p>H264标准是由JVT（Joint Video Team，视频联合工作组）组织提出的新一代数字视频编码标准。JVT于2001年12月在泰国Pattaya成立。它由ITU-T的VCEG（视频编码专家组）和ISO/IEC的MPEG（活动图像编码专家组）两个国际标准化组织的专家联合组成。JVT的工作目标是制定一个新的视频编码标准，以实现视频的高压缩比、高图像质量、良好的网络适应性等目标H264标准。H264标准将作为MPEG-4标准的一个新的部分（MPEG-4 part.10）而获得批准，是一个面向未来IP和无线环境下的新数字视频压缩编码标准。</p>
<p>H264标准的主要特点如下：</p>
<p>1．更高的编码效率：同H.263等标准的特率效率相比，能够平均节省大于50％的码率。</p>
<p>2．高质量的视频画面：H.264能够在低码率情况下提供高质量的视频图像，在较低带宽上提供高质量的图像传输是H.264的应用亮点。</p>
<p>3．提高网络适应能力：H.264可以工作在实时通信应用（如视频会议）低延时模式下，也可以工作在没有延时的视频存储或视频流服务器中。</p>
<p>4．采用混合编码结构：同H.263相同，H.264也使用采用DCT变换编码加DPCM的差分编码的混合编码结构，还增加了如多模式运动估计、帧内预测、多帧预测、基于内容的变长编码、4x4二维整数变换等新的编码方式，提高了编码效率。</p>
<p>5．H.264的编码选项较少：在H.263中编码时往往需要设置相当多选项，增加了编码的难度，而H.264做到了力求简洁的“回归基本”，降低了编码时复杂度。</p>
<p>6．H.264可以应用在不同场合：H.264可以根据不同的环境使用不同的传输和播放速率，并且提供了丰富的错误处理工具，可以很好的控制或消除丢包和误码。</p>
<p>7．错误恢复功能：H.264提供了解决网络传输包丢失的问题的工具，适用于在高误码率传输的无线网络中传输视频数据。</p>
<p>8．较高的复杂度：264性能的改进是以增加复杂性为代价而获得的。据估计，H.264编码的计算复杂度大约相当于H.263的3倍，解码复杂度大约相当于H.263的2倍。</p>
<p>H264标准各主要部分有Access Unit delimiter（访问单元分割符），SEI（附加增强信息），primary coded picture（基本图像编码），Redundant Coded Picture（冗余图像编码）。还有Instantaneous Decoding Refresh（IDR，即时解码刷新）、Hypothetical Reference Decoder（HRD，假想码流调度器）、Hypothetical Stream Scheduler（HSS，假想参考解码）。</p>
<p>主要部分结构如图3.18所示：</p>
<p><a href="http://book.51cto.com/files/upload/img/20080418/1651580.png"><img src="http://book.51cto.com/files/upload/img/20080418/1651580.png" alt="img"></a></p>
<p>H.264的目标应用涵盖了目前大部分的视频服务，如有线电视远程监控、交互媒体、数字电视、视频会议、视频点播、流媒体服务等。H.264为解决不同应用中的网络传输的差异。定义了两层：视频编码层（VCL：Video Coding Layer）负责高效的视频内容表示，网络提取层（NAL：Network Abstraction Layer）负责以网络所要求的恰当的方式对数据进行打包和传送。如图3.19所示。</p>
<table>
<thead>
<tr>
<th><a href="http://new.51cto.com/files/upload/img/20080418/165517727.png"><img src="http://new.51cto.com/files/upload/img/20080418/165517727.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td>图3.19 标准的整体框架</td>
</tr>
</tbody></table>
<p>基本层次（Baseline Profile）：该层次使用了H.264的除了B-Slices，CABAC以及交织编码模式外所有的特性。该层次主要使用于低时延的实时应用场合。</p>
<p>主要层次（Main Profile）：包含Baseline profile的所有特性，并包括了B-slices，CABAC以及交织编码模式。它主要针对对时延要求不高，当压缩率和质量要求较高的场合。</p>
<p>扩展层次(Profile X)：支持所有Baseline profile的特性，但不支持CABAC以及基于宏块的自适应帧场编码。该层次主要针对的时各种网络视频流传输方面的应用。</p>
<p>CABAC</p>
<p>CABAC是基于内容的自适应二进制算术编码，当参数entropy_coding_mode设置为1时，一个算术系统被用来编码和解码H.264的语法元素。</p>
<p>H.264采用两种方法进行熵编码：CAVLC编码和CABAC编码算法。采用基于上下文的自适应二进制算术编码算法（CABAC），能够充分利用上下文信息和算术编码的优点，使得编码后的平均码长更逼近图像的信息熵，达到最佳的编码效率。采用CABAC算法进行编码，可以提高大约10％的编码率</p>
<p>具体编码步骤：</p>
<p>1二值化：CABAC使用二进制算术编码，所以要将数据先转换为二进制数据，这些原始数据包括变换系数和运动矢量等。转换后二进制数据为可变长编码的数据，并且还要将这些数据进行算术编码。</p>
<p>2内容模式选择：内容模式是针对二进制数据进行统计的概率模型，这个模式根据之前编码的一些数据符号的统计特性从一些可选模式中选出。内容模式存储了每一位“1”或“0”的概率。</p>
<p>3算术编码：算术编码器根据选择的内容模式对每一位进行编码。</p>
<p>4概率校正：被选择的内容模式根据实际被编码的值进行校正，例如，如果数据比特流中有数值“1”，就将“1”的概率统计值加1。</p>
<p>DCT变换</p>
<p>H.264仍然采用对残差信号进行变换在量化后进行熵编码的模式来压缩空间冗余信息。使用了类似于4x4离散余弦变换DCT的整数变换而不是象MPEG4那样采用8x8DCT的浮点数变换。最终使用那种变换方式还用根据残余数据类型的不同来选择，帧内编码宏块的亮度DC系数（仅对16x16预测模式有效）采用4x4的矩阵，色度DC系数采用2x2的矩阵，对于其他的都采用4X4的块来变换。</p>
<p>使用以整数为基础的空间变换可以提高计算速度（只使用加法和位移运算），但是使用整数变换要以不矢精确度为前提；整数变换的反变换过程中不会出现较大的误差，并且缩放矩阵的乘法集成到了量化中，降低了乘法的总次数。</p>
<p>（1）4×4亮度分量的直流系数变换</p>
<p>如果宏块被编码为16×16帧内模式，则每个4×4残差块首先用前面叙述的变换进行变换，然后对于每个4×4的变换后的直流（DC）系数进行4×4的二次变换，采用Hadamard变换。<br>正变换为：</p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/165717576.gif"><img src="http://new.51cto.com/files/upload/img/20080418/165717576.gif" alt="img"></a> </p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/165740418.gif"><img src="http://new.51cto.com/files/upload/img/20080418/165740418.gif" alt="img"></a> </p>
<p>其中A是变换核矩阵<br>a=1/2</p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/165826593.gif"><img src="http://new.51cto.com/files/upload/img/20080418/165826593.gif" alt="img"></a> </p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/165844395.gif"><img src="http://new.51cto.com/files/upload/img/20080418/165844395.gif" alt="img"></a> </p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/165936434.gif"><img src="http://new.51cto.com/files/upload/img/20080418/165936434.gif" alt="img"></a> </p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/165954381.gif"><img src="http://new.51cto.com/files/upload/img/20080418/165954381.gif" alt="img"></a> </p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/170014959.gif"><img src="http://new.51cto.com/files/upload/img/20080418/170014959.gif" alt="img"></a> </p>
<p>（2）2×2色度块的DC系数变换</p>
<p>每个宏块内的4个4×4色度块经过变换后，每个块的DC系数构成了一个2×2的块WD，对其进行2×2的Hadamard变换。</p>
<p>正变换的公式为：</p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/170126791.gif"><img src="http://new.51cto.com/files/upload/img/20080418/170126791.gif" alt="img"></a> </p>
<p>反变换公式为：</p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/170138864.gif"><img src="http://new.51cto.com/files/upload/img/20080418/170138864.gif" alt="img"></a> </p>
<p>（3）如图3.18所示，展示了宏块中的变换块及其传送顺序。编号为-1的块在采用Intra16x16模式编码时0-15号4x4子块经整数DCT变换后的DC系数在经4x4的哈达变换的结果。块16、17是色度块的DC系数进行2x2哈达码变换的结果。其余的24块则进行4x4整数变换。</p>
<table>
<thead>
<tr>
<th><a href="http://new.51cto.com/files/upload/img/20080418/170243187.png"><img src="http://new.51cto.com/files/upload/img/20080418/170243187.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td>图3.20 宏块中的变换及其传送顺序</td>
</tr>
</tbody></table>
<p>多种运动补偿块</p>
<p>有7种形状的运动补偿可供选用，这7种块是：INTER16x16，INTER16x8，INTER8x16，INTER8x8，INTER8x4，INTER4x8，INTER4x4。根据运动补偿采用的块尺寸的不同，宏块的编码模式分为四种，前三种模式分别按照一个16x16块、两个16x8块和两个8x16块来进行运动补偿；最后一种模式记作P8x8，在P8x8模式下，一个宏块被分为4个8x8的子块，而每一个子块又有4种可能的子模式，分别按照一个8x8块、两个8x4块、两个4x8块及四个4x4块进行运动补偿，如图3.19所示，第一行是宏块四种模式，第二行是子块四种模式。</p>
<p><a href="http://new.51cto.com/files/upload/img/20080418/170410300.png"><img src="http://new.51cto.com/files/upload/img/20080418/170410300.png" alt="img"></a> </p>
<table>
<thead>
<tr>
<th><a href="http://new.51cto.com/files/upload/img/20080418/170437720.png"><img src="http://new.51cto.com/files/upload/img/20080418/170437720.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td>图3.21 宏块划分方式</td>
</tr>
</tbody></table>
<p>块大小的选择是否合理对于压缩效果的好坏有很大的影响，通常来说，对于变化缓慢的部分采用较大分块效果比较好，对于包含较多细节的部分则应该采用较小的分块方式。</p>
<p>1/4像素精度运动估计</p>
<p>帧内编码宏块的每一分块都是由参考帧中相同大小的区域预测得到。这两个区域之间的偏移量即运动矢量。由于图像的运动不可能总是整像素的。因此引入了亚像素运动矢量。对亮度分量，运动矢量的分辨率为1/4像素。由于参考帧中本身不可能存在亚像素采样点，因此需要利用其临近像素内插产生亚像素采样点。亚像素采样点的内插产生过程，如图3.20所示</p>
<table>
<thead>
<tr>
<th><a href="http://new.51cto.com/files/upload/img/20080418/170531554.png"><img src="http://new.51cto.com/files/upload/img/20080418/170531554.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td>图3.22 亚像素采样点</td>
</tr>
</tbody></table>
<p>半像素内插值分别由运动于水平和垂直方向的一维6阶滤波器产生。1/4像素值由整数像素和半像素点求均值取得。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#x3D;round（（E-5F+20G+20H-5I+J）&#x2F;32） a&#x3D;round（（G+b）&#x2F;2） e&#x3D;round（（b+h）&#x2F;2）</span><br></pre></td></tr></table></figure>
<p>由于亮度分量中的1/4像素精度运动矢量将在色度分量中产生1/8像素精度。因此，采用线性内插法产生1/8像素采样点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;round（（[（8-dx）.（8-dy）A+dx.（8-dy）B+（8-dx）.dyC+dx.dyD]&#x2F;64）</span><br></pre></td></tr></table></figure>
<p>图片分割</p>
<p>H.264支持slice结构的图片分割。一个slice有一帧图片内的若干宏块组成。编码器端对slice种包含的宏块数目没有限制。一个slice可以仅包含一个宏块也可以包含该帧中的所有宏块。然而，任何一个宏块都只能包含在某一个slice中，不允许重复出现（在冗余slice方法中例外）。<br>采用slice结构的主要动机是使编码的slice大小能适应不同的MTU大小。当它同时能应用于交叉打包等方法的实现方案中。</p>
<p>多参考帧选择</p>
<p>多参考帧选择在之前的一些视频编码标准中也可以得到应用。该方法尤其使用于具有反馈机制的系统中。但在时延要求较高的应用中意义不大。<br>与以往标准的P帧、B帧不同，H.264采用了前向与后向多个参考帧的预测</p>
<p>数据分快</p>
<p>通常，宏块中素有的码元都是被编码在单一的比特串中的。数据分块则为每一个slice创建多个比特串。<br>在H.264中，使用了三种不同类型的数据分块。</p>
<p>头信息块，包括宏块类型，量化参数，运动矢量。这些信息是最重要的，因为离开他们，被的数据块种的码元都无法使用。该数据分块称为A类数据分块。</p>
<p>帧内编码信息数据块，称为B类数据分块。它包含帧内编码宏块类型，帧内编码系数。对应的slice来说，B类数据分块的可用性依赖于A类数据分块。和帧间编码信息数据块不通的是，帧内编码信息能防止进一步的偏差，因此比帧间编码信息更重要。</p>
<p>帧间编码信息数据块，称为C类数据分块。它包含帧间编码宏块类型，帧间编码系数。它通常是slice种最大的一部分。帧间编码信息数据块是不重要的一部分。它所包含的信息并不提供编解码器之间的同步。C类数据分块的可用性也依赖于A类数据分块，但于B类数据分块无关。</p>
<p>当采用数据分块方式的时候，源编码器将不通类型的码元放到三个不同的比特缓冲器种此外，slice大小也需要调整，以使最大数据分块不会大于最大的MTU尺寸。以此，对数据分块进行操作的是源编码器而不是NAL。<br>在解码器端，在开始正确解码之前必须获得所有数据分块信息。然而，如果帧间或帧内编码数据块信息丢失了，头信息仍然能够有效地应用于提高差错恢复效率。头信息种包含宏块类型，用动矢量等信息，因此能够据此较高质量地复制信息。而仅仅丢失了一些图像纹理信息。</p>
<p>参数集</p>
<p>序列参数集包括与一图片序列相关地所有信息。图像参数集包含与图像中所有slice相关地信息。在解码器端可以存储多个不同地序列和图片参数集。编码器可以选择适当地图片参数集，图片参数集本身又包含所引用地序列参数集信息。</p>
<p>参数集的创造性应用极大地提高了错误恢复性能。在容错环境中使用参数集地关键是确保参数集能可靠并及时地到达接受端解码器。一次可以用频带外可靠通讯控制协议传送参数集，并确保在解码器从实时通讯信道接收到第一个需要参考该参数集地slice数据之前送达。或者也可以在频带内传输，但必须采用一些应用层保护措施（例如传送一参数集地多个复制，以提高至少一个复制到底目的地地概率）。第三中方案是在编码器和解码器端预先放置一些参数集，编解码器都必须在其中选择参数集。</p>
<p>可变宏块排序</p>
<p>可变宏块排序（FMO，Flexible Macroblock Ordering）可以在Baseline和Ext4ended模式中使用，但不允许在Main模式重使用。可变宏块排序允许将宏块不按照扫描顺序分配给slice。具体地分配策略由一宏块分配映射图（MBAmap）规定。在slice内，宏块仍然按照正常地扫描顺序编码。</p>
<p>该特性提供了一种将一帧图像中的宏块分配到多个slice中的模式，每个slice都是一个独立的编码单位，无论是帧间还是帧内编码都不能越界，如果在传输过程中出现数据丢失的情况，可以利用已接收到的宏块数据来对丢失的宏块数据进行恢复。</p>
<table>
<thead>
<tr>
<th><a href="http://new.51cto.com/files/upload/img/20080418/170821603.png"><img src="http://new.51cto.com/files/upload/img/20080418/170821603.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td>图3.23 可变宏块编码顺序</td>
</tr>
</tbody></table>
<p>slice</p>
<p>slice是一个类似于H.263中图像组（GOP）的概念，一个slice是由一系列按光栅扫描顺序排列的宏块组成。一般情况下每个宏块均包含一个16×16 的亮度阵列，当视频格式不是单色时，还包含和两个相应的色度阵列。如果没有使用宏块自适应帧/场解码，每个宏块代表图像中的一个空间矩形区域。例如，如图3.22所示，一幅图像被分为两个条带。</p>
<table>
<thead>
<tr>
<th><a href="http://new.51cto.com/files/upload/img/20080418/170851210.png"><img src="http://new.51cto.com/files/upload/img/20080418/170851210.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td>图3.24 slice对象</td>
</tr>
</tbody></table>
<p>每个slice都是一个独立的编码单位，无论是帧间还是帧内编码都不能越界。冗余slice允许编码器在同一数据流中嵌入同一slice中宏块地一个或多个冗余表示。这种做法和传输层冗余技术，例如包复制等，关键区别是在冗余slice中宏块地冗余表示可以使用不同地编码参数编码。例如，首先要表示可以使用相对较低的量化系数以获得较低的图像质量，而在冗余表示中可以用相对较高的量化系数以减少比特数。当解码器正确接受到首要表示时，将冗余表示丢弃。而如果首要表示由于包丢失等原因无法正确获得，能够用冗余表示中地信息将相应slice数据恢复。冗余slice 最初是为支持高差错无线通信环境而引入的，但在基于IP的环境中同样有效。</p>
<p>通过块匹配估计运动的方法</p>
<p>完全抵消所有运动的运动补偿器将产生非常好的预测帧，以至于实际上在差别图片中不会存在任何功率。我们需要相对较多的数据以详细描述运动，但是只需要相对教少的数据，以描述差别帧。无可否认，甚至使用艺术技术也不可能从一般的帧源中识别和测量任何对象的运动。我们不得不满足于简化图片模型，例如经常使用的块匹配技术。除了次优的运动补偿之外，差别图片所需的数据速率比没有运动补偿所需的速率要小很多。进一步而言，我们的优势是特别简单，因而节省描述运动所需的位数。这在部分程度哂纳感弥补了差别图片的信号功率的不足，这种信号没有完全最小化。</p>
<p>使用块匹配技术的运动估计器</p>
<p>在数据压缩中，块匹配运动估计器可以任意处理每个新帧，使其用大小相同的直接相邻的对象进行传送。另外，对象仅仅能在2维平面上在一个方向上统一地移动。因而，被传输的帧被分割为一系列矩形图案块，它们是连续产生的。运动预测器假设图案块仅仅能在x和y方向上移动一个最大值。对于每个图案块，存在一个搜索区域，根据基本模型，在先前帧的这个区域内可以找到那个图案块。在使用等长步长的情况下，图案块逐渐移动通过搜索区域内的连续位置，并且每个位置都和旧图片进行比较。<br>位置变换也称为位移，如果某个位移达到了最佳的相似性或匹配结果，则它称为搜索后运动。然后，运动补偿帧的块将填充属于先前帧的块的内容，这将和前面搜索的图案块产生最佳的匹配。通过这种方式，运动补偿帧可以和瞬态帧尽可能地接近。</p>
<p>位移中的x和y成分通过侧向通道而传送到接受器，目的是可以从旧帧中构造运动补偿帧。对先前帧的内容执行这个操作，从而对已知图片进行这个操作，这就是这种编码技术的本质优点。</p>
<p>向量的数据速率取决于查找区域的带，从而取决于最大的位移，以及期望的向量的精确程度。对象的轮廓没有必要传送，原因是所有的对象具有相同的矩形。</p>
<p>P图像的VLC编码</p>
<p>VLC是可变长编码，VLC是统计编码技术，它的基本思想是：对出现频率较高的数值分配比特数较少的码字，而对出现频率较低的数值分配比特数较多的码字，因此从总的效果看，数据量比用均匀分配比特数的数据量要少。可变长编码是对Huffman编码的改进</p>
<p>P图像是参考过去的帧内图像或者过去预测得到得图像用运动补偿预测技术进行编码，P图像得编码也是以图像宏块为基本编码单元。预测编码得 基础是运动估值，它将直接影响到整个系统得编码效率和压缩性能，因此希望找到一种预测精度高同时计算量又小得运动估值算法。</p>
<p>正如I画面一样，每一幅P画面被分为一片或多片，每一片又被划分为若干宏块。对P画面的编码要比I画面复杂的多，因为要构造运动补偿宏块。运动补偿宏块与当前宏块的差值被一个二维的DCT变换为8x8的变换系数矩阵，这些系数在被量化成一组量化系数，最后，对量化后的系数采用行程长度技术编码。表3.11和3.12分别给出了P画面和B画面中所支持的宏块类型及VLC编码。</p>
<p>表3.11 P画面中的宏块类型及VLC编码</p>
<table>
<thead>
<tr>
<th>宏块类型</th>
<th>VLC码</th>
<th>INTRA</th>
<th>MOTION FORWARD</th>
<th>CODED PATTERN</th>
<th>QUANT</th>
</tr>
</thead>
<tbody><tr>
<td>pred_mc</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>pred_c</td>
<td>01</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>pred_m</td>
<td>001</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>intra_d</td>
<td>0001 1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>pred_mcq</td>
<td>0001 0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>pred_cq</td>
<td>0000 1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>intra_q</td>
<td>0000 01</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>skipped</td>
<td>无</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>表3.12 B画面中的宏块类型及VLC编码</p>
<table>
<thead>
<tr>
<th>宏块类型</th>
<th>VLC码</th>
<th>INTRA</th>
<th>MOTION FORWARD</th>
<th>MOTION BACKWARD</th>
<th>CODED PATTERN</th>
<th>QUANT</th>
</tr>
</thead>
<tbody><tr>
<td>pred_I</td>
<td>10</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>pred_ic</td>
<td>11</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>pred_b</td>
<td>010</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>pred_bc</td>
<td>011</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>pred_f</td>
<td>0010</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>pred_fc</td>
<td>0011</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>intra_d</td>
<td>0001 1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>pred_icq</td>
<td>0001 0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>pred_fcq</td>
<td>0000 11</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>pred_bcq</td>
<td>0000 10</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>intra_q</td>
<td>0000 01</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>skippde</td>
<td>无</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>每一帧B画面被划分成一片或多片，每一片又被划分为若干宏块。由于要构造几种类型的运动补偿宏块：前向、后向、插播，所以对B画面的编码要比对P画面复杂的多。首先用一个二维DCT将运动补偿宏块与当前块之间的差值变换为8x8的变换系数矩阵，然后对着些系数进行量化，产生一组量化的系数，最后对这些量化后的系数用行程长度技术进行编码。</p>
<p>编码器不需要存储解码的B画面，因为B画面不用于运动补偿。</p>
<p>B画面宏块比P画面多了 几种类型，如果仅有前向运动矢量，则像P画面那样，从前面的一帧画面种构造运动补偿宏块。如果仅有后向运动矢量，则从后面的一帧画面种构造运动补偿宏块。如果既有前向也有后向运动矢量，则从前面以及后面的画面种构造运动补偿宏块，对结果求平均，用以形成插补宏块。</p>
<p>如同需要存储I画面一样，编码器也需要存储解了码的P画面，一位该P画面很可能会作为运动补偿的开始点。因此，编码器将要从量化系数种重构该画面的图像。<br>H.264所支持的帧编码模式如表3.13所示。</p>
<p>表3.13 帧编码模式</p>
<table>
<thead>
<tr>
<th>帧类型</th>
<th>描述</th>
<th>支持的框架</th>
</tr>
</thead>
<tbody><tr>
<td>I(Intra)</td>
<td>只包含帧内预测的宏块(I)</td>
<td>全部</td>
</tr>
<tr>
<td>P(Predicted)</td>
<td>包含帧间预测宏块(P)和I型宏块</td>
<td>全部</td>
</tr>
<tr>
<td>B(Bi-Predictive)</td>
<td>包含帧间双向预测宏块(B)和I型宏块</td>
<td>扩展和主</td>
</tr>
<tr>
<td>SP(Switching P)</td>
<td>利于在编码的比特流中切换,包括I和P宏块</td>
<td>扩展</td>
</tr>
<tr>
<td>SI(Switching I)</td>
<td>利于在编码的比特流中切换,包含SI宏块(一种特殊的帧内编码宏块)</td>
<td>扩展</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>Activity-element AndroidManifest</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Activity-element%20AndroidManifest/</url>
    <content><![CDATA[<p> <a href="http://developer.android.com/guide/topics/manifest/activity-element.html">http://developer.android.com/guide/topics/manifest/activity-element.html</a></p>
<p>&lt;activity android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;]<br>android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;]<br>android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;]<br>android:configChanges=[&quot;mcc&quot;, &quot;mnc&quot;, &quot;locale&quot;,<br>&quot;touchscreen&quot;, &quot;keyboard&quot;, &quot;keyboardHidden&quot;,<br>&quot;navigation&quot;, &quot;screenLayout&quot;, &quot;fontScale&quot;, &quot;uiMode&quot;,<br>&quot;orientation&quot;, &quot;screenSize&quot;, &quot;smallestScreenSize&quot;]<br>android:enabled=[&quot;true&quot; | &quot;false&quot;]<br>android:excludeFromRecents=[&quot;true&quot; | &quot;false&quot;]<br>android:exported=[&quot;true&quot; | &quot;false&quot;]<br>android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;]<br>android:hardwareAccelerated=[&quot;true&quot; | &quot;false&quot;]<br>android:icon=&quot;drawable resource&quot;<br>android:label=&quot;string resource&quot;<br>android:launchMode=[&quot;multiple&quot; | &quot;singleTop&quot; |<br>&quot;singleTask&quot; | &quot;singleInstance&quot;]<br>android:multiprocess=[&quot;true&quot; | &quot;false&quot;]<br>android:name=&quot;string&quot;<br>android:noHistory=[&quot;true&quot; | &quot;false&quot;]<br>android:parentActivityName=&quot;string&quot;<br>android:permission=&quot;string&quot;<br>android:process=&quot;string&quot;<br>android:screenOrientation=[&quot;unspecified&quot; | &quot;behind&quot; |<br>&quot;landscape&quot; | &quot;portrait&quot; |<br>&quot;reverseLandscape&quot; | &quot;reversePortrait&quot; |<br>&quot;sensorLandscape&quot; | &quot;sensorPortrait&quot; |<br>&quot;userLandscape&quot; | &quot;userPortrait&quot; |<br>&quot;sensor&quot; | &quot;fullSensor&quot; | &quot;nosensor&quot; |<br>&quot;user&quot; | &quot;fullUser&quot; | &quot;locked&quot;]<br>android:stateNotNeeded=[&quot;true&quot; | &quot;false&quot;]<br>android:taskAffinity=&quot;string&quot;<br>android:theme=&quot;resource or theme&quot;<br>android:uiOptions=[&quot;none&quot; | &quot;splitActionBarWhenNarrow&quot;]<br>android:windowSoftInputMode=[&quot;stateUnspecified&quot;,<br>&quot;stateUnchanged&quot;, &quot;stateHidden&quot;,<br>&quot;stateAlwaysHidden&quot;, &quot;stateVisible&quot;,<br>&quot;stateAlwaysVisible&quot;, &quot;adjustUnspecified&quot;,<br>&quot;adjustResize&quot;, &quot;adjustPan&quot;] &gt;<br>    . . .<br>&lt;/activity&gt;</p>
<p>ATTRIBUTES:</p>
<p>android:allowTaskReparenting<br>Whether or not the activity<br>can move from the task that started it to the task it has an<br>affinity for when that task is next brought to the front —<br>&quot;true&quot;<br>if it can move, and &quot;false&quot;<br>if it must remain with the task where it started.</p>
<p>If this attribute is not set, the<br>value set by the corresponding allowTaskReparenting attribute<br>of the&lt;application&gt; element<br>applies to the activity. The default value is &quot;false&quot;.</p>
<p>Normally when an activity is<br>started, it’s associated with the task of the activity that<br>started it and it stays there for its entire lifetime. You can use<br>this attribute to force it to be re-parented to the task it has an<br>affinity for when its current task is no longer displayed.<br>Typically, it’s used to cause the activities of an application<br>to move to the main task associated with that application.</p>
<p>For example, if an e-mail message<br>contains a link to a web page, clicking the link brings up an<br>activity that can display the page. That activity is defined by the<br>browser application, but is launched as part of the e-mail task. If<br>it’s reparented to the browser task, it will be shown when the<br>browser next comes to the front, and will be absent when the e-mail<br>task again comes forward.</p>
<p>The affinity of an activity is<br>defined by the taskAffinity attribute.<br>The affinity of a task is determined by reading the affinity of its<br>root activity. Therefore, by definition, a root activity is always<br>in a task with the same affinity. Since activities with<br>&quot;singleTask&quot;<br>or &quot;singleInstance&quot;<br>launch modes can only be at the root of a task, re-parenting is<br>limited to the &quot;standard&quot;<br>and &quot;singleTop&quot;<br>modes. (See also thelaunchMode attribute.)</p>
<p>android:alwaysRetainTaskState<br>Whether or not the state of<br>the task that the activity is in will always be maintained by the<br>system — &quot;true&quot;<br>if it will be, and &quot;false&quot;<br>if the system is allowed to reset the task to its initial state in<br>certain situations. The default value is &quot;false&quot;.<br>This attribute is meaningful only for the root activity of a task;<br>it’s ignored for all other activities.</p>
<p>Normally, the system clears a<br>task (removes all activities from the stack above the root<br>activity) in certain situations when the user re-selects that task<br>from the home screen. Typically, this is done if the user<br>hasn’t visited the task for a certain amount of time, such as<br>30 minutes.</p>
<p>However, when this attribute is<br>&quot;true&quot;,<br>users will always return to the task in its last state, regardless<br>of how they get there. This is useful, for example, in an<br>application like the web browser where there is a lot of state<br>(such as multiple open tabs) that users would not like to lose.</p>
<p>android:clearTaskOnLaunch<br>Whether or not all<br>activities will be removed from the task, except for the root<br>activity, whenever it is re-launched from the home screen —<br>&quot;true&quot;<br>if the task is always stripped down to its root activity, and<br>&quot;false&quot;<br>if not. The default value is &quot;false&quot;.<br>This attribute is meaningful only for activities that start a new<br>task (the root activity); it’s ignored for all other activities<br>in the task.</p>
<p>When the value is<br>&quot;true&quot;,<br>every time users start the task again, they are brought to its root<br>activity regardless of what they were last doing in the task and<br>regardless of whether they used<br>the Back orHome button to leave<br>it. When the value is &quot;false&quot;,<br>the task may be cleared of activities in some situations (see<br>the alwaysRetainTaskState attribute),<br>but not always.</p>
<p>Suppose, for example, that<br>someone launches activity P from the home screen, and from there<br>goes to activity Q. The user next presses Home, and<br>then returns to activity P. Normally, the user would see activity<br>Q, since that is what they were last doing in P’s task.<br>However, if P set this flag to &quot;true&quot;,<br>all of the activities on top of it (Q in this case) were removed<br>when the user pressed Home and the task went to<br>the background. So the user sees only P when returning to the<br>task.</p>
<p>If this attribute<br>and allowTaskReparenting are<br>both &quot;true&quot;,<br>any activities that can be re-parented are moved to the task they<br>share an affinity with; the remaining activities are then dropped,<br>as described above.</p>
<p>android:configChanges<br>Lists configuration changes<br>that the activity will handle itself. When a configuration change<br>occurs at runtime, the activity is shut down and restarted by<br>default, but declaring a configuration with this attribute will<br>prevent the activity from being restarted. Instead, the activity<br>remains running and itsonConfigurationChanged() method<br>is called.</p>
<p>Note: Using this<br>attribute should be avoided and used only as a last resort. Please<br>read Handling<br>Runtime Changes for more information about how to properly<br>handle a restart due to a configuration change.</p>
<p>Any or all of the following<br>strings are valid values for this attribute. Multiple values are<br>separated by ‘|’<br>— for example, &quot;locale|navigation|orientation&quot;.</p>
<p>Value</p>
<p>Description</p>
<p>&quot;mcc&quot;</p>
<p>The IMSI mobile country code (MCC) has changed — a SIM has been<br>detected and updated the MCC.</p>
<p>&quot;mnc&quot;</p>
<p>The IMSI mobile network code (MNC) has changed — a SIM has been<br>detected and updated the MNC.</p>
<p>&quot;locale&quot;</p>
<p>The locale has changed — the user has selected a new language that<br>text should be displayed in.</p>
<p>&quot;touchscreen&quot;</p>
<p>The touchscreen has changed. (This should never normally<br>happen.)</p>
<p>&quot;keyboard&quot;</p>
<p>The keyboard type has changed — for example, the user has plugged<br>in an external keyboard.</p>
<p>&quot;keyboardHidden&quot;</p>
<p>The keyboard accessibility has changed — for example, the user has<br>revealed the hardware keyboard.</p>
<p>&quot;navigation&quot;</p>
<p>The navigation type (trackball/dpad) has changed. (This should<br>never normally happen.)</p>
<p>&quot;screenLayout&quot;</p>
<p>The screen layout has changed — this might be caused by a different<br>display being activated.</p>
<p>&quot;fontScale&quot;</p>
<p>The font scaling factor has changed — the user has selected a new<br>global font size.</p>
<p>&quot;uiMode&quot;</p>
<p>The user interface mode has changed — this can be caused when the<br>user places the device into a desk/car dock or when the night mode<br>changes. See UiModeManager. Added<br>in API level 8.</p>
<p>&quot;orientation&quot;</p>
<p>The screen orientation has changed — the user has rotated the<br>device.</p>
<p>Note: If<br>your application targets API level 13 or higher (as declared by<br>the minSdkVersion and targetSdkVersion attributes),<br>then you should also declare the &quot;screenSize&quot; configuration,<br>because it also changes when a device switches between portrait and<br>landscape orientations.</p>
<p>&quot;screenSize&quot;</p>
<p>The current available screen size has changed. This represents a<br>change in the currently available size, relative to the current<br>aspect ratio, so will change when the user switches between<br>landscape and portrait. However, if your application targets API<br>level 12 or lower, then your activity always handles this<br>configuration change itself (this configuration change does not<br>restart your activity, even when running on an Android 3.2 or<br>higher device).</p>
<p>Added in API level 13.</p>
<p>&quot;smallestScreenSize&quot;</p>
<p>The physical screen size has changed. This represents a change in<br>size regardless of orientation, so will only change when the actual<br>physical screen size has changed such as switching to an external<br>display. A change to this configuration corresponds to a change in<br>thesmallestWidth<br>configuration. However, if your application targets API level<br>12 or lower, then your activity always handles this configuration<br>change itself (this configuration change does not restart your<br>activity, even when running on an Android 3.2 or higher device).</p>
<p>Added in API level 13.</p>
<p>&quot;layoutDirection&quot;</p>
<p>The layout direction has changed. For example, changing from<br>left-to-right (LTR) to right-to-left (RTL). Added in API level 17.</p>
<p>All of these configuration<br>changes can impact the resource values seen by the application.<br>Therefore, when onConfigurationChanged() is<br>called, it will generally be necessary to again retrieve all<br>resources (including view layouts, drawables, and so on) to<br>correctly handle the change.</p>
<p>android:enabled<br>Whether or not the activity<br>can be instantiated by the system — &quot;true&quot;<br>if it can be, and &quot;false&quot;<br>if not. The default value is &quot;true&quot;.</p>
<p>The &lt;application&gt; element<br>has its own enabled attribute<br>that applies to all application components, including activities.<br>The &lt;application&gt; and &lt;activity&gt; attributes<br>must both be &quot;true&quot;<br>(as they both are by default) for the system to be able to<br>instantiate the activity. If either is &quot;false&quot;,<br>it cannot be instantiated.</p>
<p>android:excludeFromRecents<br>Whether or not the task<br>initiated by this activity should be excluded from the list of<br>recently used applications (&quot;recent apps&quot;). That is, when<br>this activity is the root activity of a new task, this attribute<br>determines whether the task should not appear in the list of recent<br>apps. Set &quot;true&quot;<br>if the task should be excluded from the list;<br>set &quot;false&quot;<br>if it should be included. The default value is<br>&quot;false&quot;.</p>
<p>android:exported<br>Whether or not the activity<br>can be launched by components of other applications —<br>&quot;true&quot;<br>if it can be, and &quot;false&quot;<br>if not. If &quot;false&quot;,<br>the activity can be launched only by components of the same<br>application or applications with the same user ID.</p>
<p>The default value depends on<br>whether the activity contains intent filters. The absence of any<br>filters means that the activity can be invoked only by specifying<br>its exact class name. This implies that the activity is intended<br>only for application-internal use (since others would not know the<br>class name). So in this case, the default value is<br>&quot;false&quot;.<br>On the other hand, the presence of at least one filter implies that<br>the activity is intended for external use, so the default value is<br>&quot;true&quot;.</p>
<p>This attribute is not the only<br>way to limit an activity’s exposure to other applications. You<br>can also use a permission to limit the external entities that can<br>invoke the activity (see the permission attribute).</p>
<p>android:finishOnTaskLaunch<br>Whether or not an existing<br>instance of the activity should be shut down (finished) whenever<br>the user again launches its task (chooses the task on the home<br>screen) — &quot;true&quot;<br>if it should be shut down, and &quot;false&quot;<br>if not. The default value is &quot;false&quot;.</p>
<p>If this attribute<br>and allowTaskReparenting are<br>both &quot;true&quot;,<br>this attribute trumps the other. The affinity of the activity is<br>ignored. The activity is not re-parented, but destroyed.</p>
<p>android:hardwareAccelerated<br>Whether or not<br>hardware-accelerated rendering should be enabled for this Activity<br>— &quot;true&quot;<br>if it should be enabled, and &quot;false&quot;<br>if not. The default value is &quot;false&quot;.</p>
<p>Starting from Android 3.0, a<br>hardware-accelerated OpenGL renderer is available to applications,<br>to improve performance for many common 2D graphics operations. When<br>the hardware-accelerated renderer is enabled, most operations in<br>Canvas, Paint, Xfermode, ColorFilter, Shader, and Camera are<br>accelerated. This results in smoother animations, smoother<br>scrolling, and improved responsiveness overall, even for<br>applications that do not explicitly make use the framework’s<br>OpenGL libraries. Because of the increased resources required to<br>enable hardware acceleration, your app will consume more RAM.</p>
<p>Note that not all of the OpenGL<br>2D operations are accelerated. If you enable the<br>hardware-accelerated renderer, test your application to ensure that<br>it can make use of the renderer without errors.</p>
<p>android:icon<br>An icon representing the<br>activity. The icon is displayed to users when a representation of<br>the activity is required on-screen. For example, icons for<br>activities that initiate tasks are displayed in the launcher<br>window. The icon is often accompanied by a label (see<br>the android:label attribute).</p>
<p>This attribute must be set as a<br>reference to a drawable resource containing the image definition.<br>If it is not set, the icon specified for the application as a whole<br>is used instead (see the &lt;application&gt;element’s icon attribute).</p>
<p>The activity’s icon — whether<br>set here or by the &lt;application&gt; element<br>— is also the default icon for all the activity’s intent<br>filters (see the &lt;intent-filter&gt; element’s icon attribute).</p>
<p>android:label<br>A user-readable label for<br>the activity. The label is displayed on-screen when the activity<br>must be represented to the user. It’s often displayed along<br>with the activity icon.</p>
<p>If this attribute is not set, the<br>label set for the application as a whole is used instead (see<br>the&lt;application&gt; element’s label attribute).</p>
<p>The activity’s label —<br>whether set here or by the &lt;application&gt; element<br>— is also the default label for all the activity’s intent<br>filters (see the &lt;intent-filter&gt; element’s label attribute).</p>
<p>The label should be set as a<br>reference to a string resource, so that it can be localized like<br>other strings in the user interface. However, as a convenience<br>while you’re developing the application, it can also be set as<br>a raw string.</p>
<p>android:launchMode<br>An instruction on how the<br>activity should be launched. There are four modes that work in<br>conjunction with activity flags (FLAG_ACTIVITY_* constants)<br>in Intent objects<br>to determine what should happen when the activity is called upon to<br>handle an intent. They are:</p>
<p>&quot;standard&quot; </p>
<p>&quot;singleTop&quot; </p>
<p>&quot;singleTask&quot; </p>
<p>&quot;singleInstance&quot;</p>
<p>The default mode is<br>&quot;standard&quot;.</p>
<p>As shown in the table below, the<br>modes fall into two main groups, with &quot;standard&quot;<br>and &quot;singleTop&quot;<br>activities on one side, and &quot;singleTask&quot;<br>and &quot;singleInstance&quot;<br>activities on the other. An activity with the &quot;standard&quot;<br>or &quot;singleTop&quot;<br>launch mode can be instantiated multiple times. The instances can<br>belong to any task and can be located anywhere in the activity<br>stack. Typically, they’re launched into the task that<br>called startActivity() (unless<br>the Intent object contains a FLAG_ACTIVITY_NEW_TASK instruction,<br>in which case a different task is chosen — see the taskAffinity attribute).</p>
<p>In contrast, &quot;singleTask&quot;<br>and &quot;singleInstance&quot;<br>activities can only begin a task. They are always at the root of<br>the activity stack. Moreover, the device can hold only one instance<br>of the activity at a time — only one such task.</p>
<p>The &quot;standard&quot;<br>and &quot;singleTop&quot;<br>modes differ from each other in just one respect: Every time<br>there’s a new intent for a &quot;standard&quot;<br>activity, a new instance of the class is created to respond to that<br>intent. Each instance handles a single intent. Similarly, a new<br>instance of a &quot;singleTop&quot;<br>activity may also be created to handle a new intent. However, if<br>the target task already has an existing instance of the activity at<br>the top of its stack, that instance will receive the new intent (in<br>an onNewIntent() call);<br>a new instance is not created. In other circumstances — for<br>example, if an existing instance of the &quot;singleTop&quot;<br>activity is in the target task, but not at the top of the stack, or<br>if it’s at the top of a stack, but not in the target task — a<br>new instance would be created and pushed on the stack.</p>
<p>The &quot;singleTask&quot;<br>and &quot;singleInstance&quot;<br>modes also differ from each other in only one respect: A<br>&quot;singleTask&quot;<br>activity allows other activities to be part of its task. It’s<br>always at the root of its task, but other activities (necessarily<br>&quot;standard&quot;<br>and &quot;singleTop&quot;<br>activities) can be launched into that task. A &quot;singleInstance&quot;<br>activity, on the other hand, permits no other activities to be part<br>of its task. It’s the only activity in the task. If it starts<br>another activity, that activity is assigned to a different task —<br>as ifFLAG_ACTIVITY_NEW_TASK was<br>in the intent.</p>
<p>Use Cases</p>
<p>Launch Mode</p>
<p>Multiple Instances?</p>
<p>Comments</p>
<p>Normal launches for most activities</p>
<p>&quot;standard&quot;</p>
<p>Yes</p>
<p>Default. The system always creates a new instance of the activity<br>in the target task and routes the intent to it.</p>
<p>&quot;singleTop&quot;</p>
<p>Conditionally</p>
<p>If an instance of the activity already exists at the top of the<br>target task, the system routes the intent to that instance through<br>a call to its onNewIntent()method,<br>rather than creating a new instance of the activity.</p>
<p>Specialized launches<br>(not recommended for general<br>use)</p>
<p>&quot;singleTask&quot;</p>
<p>No</p>
<p>The system creates the activity at the root of a new task and<br>routes the intent to it. However, if an instance of the activity<br>already exists, the system routes the intent to existing instance<br>through a call to its onNewIntent() method,<br>rather than creating a new one.</p>
<p>&quot;singleInstance&quot;</p>
<p>No</p>
<p>Same as &quot;singleTask&quot;,<br>except that the system doesn’t launch any other activities into<br>the task holding the instance. The activity is always the single<br>and only member of its task.</p>
<p>As shown in the table<br>above, standard is<br>the default mode and is appropriate for most types of<br>activities. SingleTop is<br>also a common and useful launch mode for many types of activities.<br>The other modes — singleTask and singleInstance —<br>are not appropriate for most<br>applications, since they result in an interaction model that<br>is likely to be unfamiliar to users and is very different from most<br>other applications.</p>
<p>Regardless of the launch mode<br>that you choose, make sure to test the usability of the activity<br>during launch and when navigating back to it from other activities<br>and tasks using the Back button.</p>
<p>For more information on launch<br>modes and their interaction with Intent flags, see<br>the Tasks and<br>Back Stack document.</p>
<p>android:multiprocess<br>Whether an instance of the<br>activity can be launched into the process of the component that<br>started it — &quot;true&quot;<br>if it can be, and &quot;false&quot;<br>if not. The default value is &quot;false&quot;.</p>
<p>Normally, a new instance of an<br>activity is launched into the process of the application that<br>defined it, so all instances of the activity run in the same<br>process. However, if this flag is set to &quot;true&quot;,<br>instances of the activity can run in multiple processes, allowing<br>the system to create instances wherever they are used (provided<br>permissions allow it), something that is almost never necessary or<br>desirable.</p>
<p>android:name<br>The name of the class that<br>implements the activity, a subclass of Activity.<br>The attribute value should be a fully qualified class name (such<br>as, &quot;com.example.project.ExtracurricularActivity&quot;).<br>However, as a shorthand, if the first character of the name is a<br>period (for example, &quot;.ExtracurricularActivity&quot;),<br>it is appended to the package name specified in<br>the &lt;manifest&gt; element.</p>
<p>Once you publish your<br>application, you should not<br>change this name (unless you’ve setandroid:exported=&quot;false&quot;).</p>
<p>There is no default. The name<br>must be specified.</p>
<p>android:noHistory<br>Whether or not the activity<br>should be removed from the activity stack and finished<br>(its finish()method<br>called) when the user navigates away from it and it’s no longer<br>visible on screen — &quot;true&quot;<br>if it should be finished, and &quot;false&quot;<br>if not. The default value is &quot;false&quot;.</p>
<p>A value of &quot;true&quot;<br>means that the activity will not leave a historical trace. It will<br>not remain in the activity stack for the task, so the user will not<br>be able to return to it.</p>
<p>This attribute was introduced in<br>API Level 3.</p>
<p>android:parentActivityName<br>The class name of the<br>logical parent of the activity. The name here must match the class<br>name given to the corresponding &lt;activity&gt; element’s android:name attribute.</p>
<p>The system reads this attribute<br>to determine which activity should be started when the use presses<br>the Up button in the action bar. The system can also use this<br>information to synthesize a back stack of activities<br>with TaskStackBuilder.</p>
<p>To support API levels 4 - 16, you<br>can also declare the parent activity with a &lt;meta-data&gt; element<br>that specifies a value for &quot;android.support.PARENT_ACTIVITY&quot;.<br>For example:</p>
<p>&lt;activity<br>android:name=&quot;com.example.app.ChildActivity&quot;<br>android:label=&quot;@string/title_child_activity&quot;<br>android:parentActivityName=&quot;com.example.myfirstapp.MainActivity&quot; &gt;<br>&lt;!– Parent activity meta-data to support API level 4+ –&gt;<br>&lt;meta-data<br>android:name=&quot;android.support.PARENT_ACTIVITY&quot;<br>android:value=&quot;com.example.app.MainActivity&quot; /&gt;<br>&lt;/activity&gt;</p>
<p>For more information about<br>declaring the parent activity to support Up navigation,<br>read Providing<br>Up Navigation.</p>
<p>This attribute was introduced in<br>API Level 16.</p>
<p>android:permission<br>The name of a permission<br>that clients must have to launch the activity or otherwise get it<br>to respond to an intent. If a caller of startActivity() or startActivityForResult() has<br>not been granted the specified permission, its intent will not be<br>delivered to the activity.</p>
<p>If this attribute is not set, the<br>permission set by the &lt;application&gt; element’s permission attribute<br>applies to the activity. If neither attribute is set, the activity<br>is not protected by a permission.</p>
<p>For more information on<br>permissions, see the Permissions section<br>in the introduction and another document, Security<br>and Permissions.</p>
<p>android:process<br>The name of the process in<br>which the activity should run. Normally, all components of an<br>application run in a default process name created for the<br>application and you do not need to use this attribute. But if<br>necessary, you can override the default process name with this<br>attribute, allowing you to spread your app components across<br>multiple processes.</p>
<p>If the name assigned to this<br>attribute begins with a colon (‘:’), a new process, private<br>to the application, is created when it’s needed and the<br>activity runs in that process. If the process name begins with a<br>lowercase character, the activity will run in a global process of<br>that name, provided that it has permission to do so. This allows<br>components in different applications to share a process, reducing<br>resource usage.</p>
<p>The &lt;application&gt; element’s process attribute<br>can set a different default process name for all components.</p>
<p>android:screenOrientation<br>The orientation of the<br>activity’s display on the device.</p>
<p>The value can be any one of the<br>following strings:</p>
<p>&quot;unspecified&quot;</p>
<p>The default value. The system chooses the orientation. The policy<br>it uses, and therefore the choices made in specific contexts, may<br>differ from device to device.</p>
<p>&quot;behind&quot;</p>
<p>The same orientation as the activity that’s immediately beneath<br>it in the activity stack.</p>
<p>&quot;landscape&quot;</p>
<p>Landscape orientation (the display is wider than it is tall).</p>
<p>&quot;portrait&quot;</p>
<p>Portrait orientation (the display is taller than it is wide).</p>
<p>&quot;reverseLandscape&quot;</p>
<p>Landscape orientation in the opposite direction from normal<br>landscape.Added in API level<br>9.</p>
<p>&quot;reversePortrait&quot;</p>
<p>Portrait orientation in the opposite direction from normal<br>portrait. Added in API level<br>9.</p>
<p>&quot;sensorLandscape&quot;</p>
<p>Landscape orientation, but can be either normal or reverse<br>landscape based on the device sensor. Added in API level 9.</p>
<p>&quot;sensorPortrait&quot;</p>
<p>Portrait orientation, but can be either normal or reverse portrait<br>based on the device sensor. Added in API level 9.</p>
<p>&quot;userLandscape&quot;</p>
<p>Landscape orientation, but can be either normal or reverse<br>landscape based on the device sensor and the user’s sensor<br>preference. If the user has locked sensor-based rotation, this<br>behaves the same as landscape,<br>otherwise it behaves the same as sensorLandscape. Added<br>in API level 18.</p>
<p>&quot;userPortrait&quot;</p>
<p>Portrait orientation, but can be either normal or reverse portrait<br>based on the device sensor and the user’s sensor preference. If<br>the user has locked sensor-based rotation, this behaves the same<br>as portrait,<br>otherwise it behaves the same as sensorPortrait. Added<br>in API level 18.</p>
<p>&quot;sensor&quot;</p>
<p>The orientation is determined by the device orientation sensor. The<br>orientation of the display depends on how the user is holding the<br>device; it changes when the user rotates the device. Some devices,<br>though, will not rotate to all four possible orientations, by<br>default. To allow all four orientations, use &quot;fullSensor&quot;.</p>
<p>&quot;fullSensor&quot;</p>
<p>The orientation is determined by the device orientation sensor for<br>any of the 4 orientations. This is similar to &quot;sensor&quot; except<br>this allows any of the 4 possible screen orientations, regardless<br>of what the device will normally do (for example, some devices<br>won’t normally use reverse portrait or reverse landscape, but<br>this enables those). Added in<br>API level 9.</p>
<p>&quot;nosensor&quot;</p>
<p>The orientation is determined without reference to a physical<br>orientation sensor. The sensor is ignored, so the display will not<br>rotate based on how the user moves the device. Except for this<br>distinction, the system chooses the orientation using the same<br>policy as for the &quot;unspecified&quot;<br>setting.</p>
<p>&quot;user&quot;</p>
<p>The user’s current preferred orientation.</p>
<p>&quot;fullUser&quot;</p>
<p>If the user has locked sensor-based rotation, this behaves the same<br>as user,<br>otherwise it behaves the same as fullSensor and<br>allows any of the 4 possible screen orientations. Added in API level 18.</p>
<p>&quot;locked&quot;</p>
<p>Locks the orientation to its current rotation, whatever that<br>is. Added in API level<br>18.</p>
<p>Note: When you<br>declare one of the landscape or portrait values, it is considered a<br>hard requirement for the orientation in which the activity runs. As<br>such, the value you declare enables filtering by services such as<br>Google Play so your application is available only to devices that<br>support the orientation required by your activities. For example,<br>if you declare either &quot;landscape&quot;,&quot;reverseLandscape&quot;,<br>or &quot;sensorLandscape&quot;,<br>then your application will be available only to devices that<br>support landscape orientation. However, you should also explicitly<br>declare that your application requires either portrait or landscape<br>orientation with the &lt;uses-feature&gt; element.<br>For example, &lt;uses-feature<br>android:name=&quot;android.hardware.screen.portrait&quot;/&gt;.<br>This is purely a filtering behavior provided by Google Play (and<br>other services that support it) and the platform itself does not<br>control whether your app can be installed when a device supports<br>only certain orientations.</p>
<p>android:stateNotNeeded<br>Whether or not the activity<br>can be killed and successfully restarted without having saved its<br>state — &quot;true&quot;<br>if it can be restarted without reference to its previous state, and<br>&quot;false&quot;<br>if its previous state is required. The default value is<br>&quot;false&quot;.</p>
<p>Normally, before an activity is<br>temporarily shut down to save resources, its onSaveInstanceState()method<br>is called. This method stores the current state of the activity in<br>a Bundle object,<br>which is then passed to onCreate() when<br>the activity is restarted. If this attribute is set to<br>&quot;true&quot;,onSaveInstanceState() may<br>not be called and onCreate() will<br>be passed null instead<br>of the Bundle — just as it was when the activity started for the<br>first time.</p>
<p>A &quot;true&quot;<br>setting ensures that the activity can be restarted in the absence<br>of retained state. For example, the activity that displays the home<br>screen uses this setting to make sure that it does not get removed<br>if it crashes for some reason.</p>
<p>android:taskAffinity<br>The task that the activity<br>has an affinity for. Activities with the same affinity conceptually<br>belong to the same task (to the same &quot;application&quot; from<br>the user’s perspective). The affinity of a task is determined<br>by the affinity of its root activity.</p>
<p>The affinity determines two<br>things — the task that the activity is re-parented to (see<br>theallowTaskReparenting attribute)<br>and the task that will house the activity when it is launched with<br>theFLAG_ACTIVITY_NEW_TASK flag.</p>
<p>By default, all activities in an<br>application have the same affinity. You can set this attribute to<br>group them differently, and even place activities defined in<br>different applications within the same task. To specify that the<br>activity does not have an affinity for any task, set it to an empty<br>string.</p>
<p>If this attribute is not set, the<br>activity inherits the affinity set for the application (see<br>the &lt;application&gt;element’s taskAffinity attribute).<br>The name of the default affinity for an application is the package<br>name set by the &lt;manifest&gt; element.</p>
<p>android:theme<br>A reference to a style<br>resource defining an overall theme for the activity. This<br>automatically sets the activity’s context to use this theme<br>(see setTheme(),<br>and may also cause &quot;starting&quot; animations prior to the<br>activity being launched (to better match what the activity actually<br>looks like).</p>
<p>If this attribute is not set, the<br>activity inherits the theme set for the application as a whole —<br>from the&lt;application&gt; element’s theme attribute.<br>If that attribute is also not set, the default system theme is<br>used. For more information, see the Styles and<br>Themes developer guide.</p>
<p>android:uiOptions<br>Extra options for an<br>activity’s UI.</p>
<p>Must be one of the following<br>values.</p>
<p>Value</p>
<p>Description</p>
<p>&quot;none&quot;</p>
<p>No extra UI options. This is the default.</p>
<p>&quot;splitActionBarWhenNarrow&quot;</p>
<p>Add a bar at the bottom of the screen to display action items in<br>theActionBar,<br>when constrained for horizontal space (such as when in portrait<br>mode on a handset). Instead of a small number of action items<br>appearing in the action bar at the top of the screen, the action<br>bar is split into the top navigation section and the bottom bar for<br>action items. This ensures a reasonable amount of space is made<br>available not only for the action items, but also for navigation<br>and title elements at the top. Menu items are not split across the<br>two bars; they always appear together.</p>
<p>For more information about the<br>action bar, see the Action<br>Bar developer guide.</p>
<p>This attribute was added in API<br>level 14.</p>
<p>android:windowSoftInputMode<br>How the main window of the<br>activity interacts with the window containing the on-screen soft<br>keyboard. The setting for this attribute affects two things:</p>
<p>The state of the soft keyboard —<br>whether it is hidden or visible — when the activity becomes the<br>focus of user attention.<br>The adjustment made to the<br>activity’s main window — whether it is resized smaller to make<br>room for the soft keyboard or whether its contents pan to make the<br>current focus visible when part of the window is covered by the<br>soft keyboard.</p>
<p>The setting must be one of the<br>values listed in the following table, or a combination of one<br>&quot;state…&quot;<br>value plus one &quot;adjust…&quot;<br>value. Setting multiple values in either group — multiple<br>&quot;state…&quot;<br>values, for example — has undefined results. Individual values are<br>separated by a vertical bar (|).<br>For example:</p>
<p>&lt;activity android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; . . . &gt;</p>
<p>Values set here (other than<br>&quot;stateUnspecified&quot;<br>and &quot;adjustUnspecified&quot;)<br>override values set in the theme.</p>
<p>Value</p>
<p>Description</p>
<p>&quot;stateUnspecified&quot;</p>
<p>The state of the soft keyboard (whether it is hidden or visible) is<br>not specified. The system will choose an appropriate state or rely<br>on the setting in the theme.</p>
<p>This is the default setting for<br>the behavior of the soft keyboard.</p>
<p>&quot;stateUnchanged&quot;</p>
<p>The soft keyboard is kept in whatever state it was last in, whether<br>visible or hidden, when the activity comes to the fore.</p>
<p>&quot;stateHidden&quot;</p>
<p>The soft keyboard is hidden when the user chooses the activity —<br>that is, when the user affirmatively navigates forward to the<br>activity, rather than backs into it because of leaving another<br>activity.</p>
<p>&quot;stateAlwaysHidden&quot;</p>
<p>The soft keyboard is always hidden when the activity’s main<br>window has input focus.</p>
<p>&quot;stateVisible&quot;</p>
<p>The soft keyboard is visible when that’s normally appropriate<br>(when the user is navigating forward to the activity’s main<br>window).</p>
<p>&quot;stateAlwaysVisible&quot;</p>
<p>The soft keyboard is made visible when the user chooses the<br>activity — that is, when the user affirmatively navigates forward<br>to the activity, rather than backs into it because of leaving<br>another activity.</p>
<p>&quot;adjustUnspecified&quot;</p>
<p>It is unspecified whether the activity’s main window resizes to<br>make room for the soft keyboard, or whether the contents of the<br>window pan to make the current focus visible on-screen. The system<br>will automatically select one of these modes depending on whether<br>the content of the window has any layout views that can scroll<br>their contents. If there is such a view, the window will be<br>resized, on the assumption that scrolling can make all of the<br>window’s contents visible within a smaller area.</p>
<p>This is the default setting for<br>the behavior of the main window.</p>
<p>&quot;adjustResize&quot;</p>
<p>The activity’s main window is always resized to make room for<br>the soft keyboard on screen.</p>
<p>&quot;adjustPan&quot;</p>
<p>The activity’s main window is not resized to make room for the<br>soft keyboard. Rather, the contents of the window are automatically<br>panned so that the current focus is never obscured by the keyboard<br>and users can always see what they are typing. This is generally<br>less desirable than resizing, because the user may need to close<br>the soft keyboard to get at and interact with obscured parts of the<br>window.</p>
<p>This attribute was introduced in<br>API Level 3.</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android Input子系统架构</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%20Input%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>Android Input子系统架构</p>
<p>1.1 Input服务的启动</p>
<p>在Android的开机过程中，系统中的服务很多都是由SystemServer中启动的。</p>
<p>SystemServer的代码中有这么一句话。</p>
<p>Framework/base/services/java/com/android/server/SystemServer.java</p>
<p>Slog.i(TAG, &quot;Window Manager&quot;);</p>
<p> wm = WindowManagerService.main(context, power,</p>
<p>                    factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL,!firstBoot);</p>
<p>在这里new了一个WindowManagerService的类，我们找到这个类的构造函数。</p>
<p>Framework/base/services/java/com/android/server/wm/WindowManagerServer.java</p>
<p>private WindowManagerService(Context context, PowerManagerService pm,</p>
<p>            boolean haveInputMethods, boolean showBootMsgs) {</p>
<p>……</p>
<p>mInputManager = new InputManager(context, this);</p>
<p>……</p>
<p>mInputManager.start();</p>
<p>……</p>
<p>}</p>
<p>在WindowManagerService的构造函数中又new了一个InputManager类。InputManager类是整个android的input的上层代码最重要的类，就是通过这个类繁衍出了整个复杂的Android的input子系统。作用就好像Zygote的孕育着Android的各个服务，而InputManager就是负责将整个android的Input子系统。</p>
<p>Framework/base/services/java/com/android/server/wm/WindowManagerServer.java</p>
<p>public InputManager(Context context, WindowManagerService windowManagerService) {</p>
<p>……</p>
<p>Looper looper = windowManagerService.mH.getLooper();</p>
<p>nativeInit(mContext, mCallbacks, looper.getQueue());</p>
<p>……</p>
<p>}</p>
<p>在InputManger的构造函数中，调用了nativeInit这个方式，看到native开头或者结尾的函数，一般都是JNI。在InputManager的JNI可以找到这个函数的实现。</p>
<p>Framework/base/services/jni/com_android_server_InputManager.java</p>
<p>static JNINativeMethod gInputManagerMethods[] = {</p>
<p>{ &quot;nativeInit&quot;, &quot;(Landroid/content/Context;&quot;</p>
<p>&quot;Lcom/android/server/wm/InputManager$Callbacks;Landroid/os/MessageQueue;)V&quot;,</p>
<p>            (void*) android_server_InputManager_nativeInit },</p>
<p>简单介绍下JNI的代码风格，第一个引号括起来的函数就是我们java代码的函数原型，中间的引号中的就是代表java原型函数的参数。而最后的那个函数就是在对应的函数。一般都是c++代码。</p>
<p>Framework/base/services/jni/com_android_server_InputManager.java</p>
<p>static void android_server_InputManager_nativeInit(JNIEnv* env, jclass clazz,</p>
<p>        jobject contextObj, jobject callbacksObj, jobject messageQueueObj) {</p>
<p>……</p>
<p>gNativeInputManager = new NativeInputManager(contextObj, callbacksObj, looper);</p>
<p>……</p>
<p>}</p>
<p>在JNI的代码中，又构造了一个重要的NativeInputManager类，这是个C++的本地类。已经不在是之前了那个java的InputManager类。接下来看看NativeInputManager的构造函数。</p>
<p>Framework/base/services/jni/com_android_server_InputManager.java</p>
<p>NativeInputManager::NativeInputManager(jobject contextObj,</p>
<p>  jobject callbacksObj, const sp&lt;Looper&gt;&amp; looper) :mLooper(looper) {</p>
<p>……</p>
<p>sp&lt;EventHub&gt; eventHub = new EventHub();</p>
<p> mInputManager = new InputManager(eventHub, this, this);</p>
<p>……</p>
<p>}</p>
<p>这里new了两个类，EventHub和InputManager类。EventHub就是Input子系统的HAL层了，负责将linux的所有的input设备打开并负责轮询读取他们的上报的数据，后面会详细介绍，这里先简单介绍一下。InputManager类主要是负责管理input Event，有InputReader从EventHub读取事件，然后交给InputDispatcher进行分发。</p>
<p>Framework/base/services/input/InputManager.cpp</p>
<p>InputManager::InputManager(</p>
<p>        const sp&lt;InputReaderInterface&gt;&amp; reader,</p>
<p>        const sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :</p>
<p>        mReader(reader),</p>
<p>        mDispatcher(dispatcher) {</p>
<p>    initialize();</p>
<p>}</p>
<p>void InputManager::initialize() {</p>
<p>    mReaderThread = new InputReaderThread(mReader);</p>
<p>    mDispatcherThread = new InputDispatcherThread(mDispatcher);</p>
<p>}</p>
<p>在InputManager中的initialize的初始化了两个线程。一个是inputReaderThread，负责从EventHub中读取事件，另外一个是InputDispatcherThread线程，主要负责分发读取的事件去处理。</p>
<p>Framework/base/services/java/com/android/server/wm/WindowManagerServer.java</p>
<p>private WindowManagerService(Context context, PowerManagerService pm,</p>
<p>            boolean haveInputMethods, boolean showBootMsgs)</p>
<p>mInputManager.start();</p>
<p>……</p>
<p>}</p>
<p>在开始的时候，new了一个InputManager，然后在继续调用其start方法。</p>
<p>Framework/base/services/java/com/android/server/wm/WindowManagerServer.java</p>
<p>public void start() {</p>
<p>        Slog.i(TAG, &quot;Starting input manager&quot;);</p>
<p>        nativeStart();</p>
<p>        registerPointerSpeedSettingObserver();</p>
<p>        registerShowTouchesSettingObserver();</p>
<p>        updatePointerSpeedFromSettings();</p>
<p>        updateShowTouchesFromSettings();</p>
<p>    }  </p>
<p>NativeStart()跑到JNI的代码中去了，跟上面的方式一样。</p>
<p>Framework/base/services/jni/com_android_server_InputManager.java</p>
<p>static JNINativeMethod gInputManagerMethods[] = {</p>
<p>……</p>
<p>{ &quot;nativeStart&quot;, &quot;()V&quot;, (void*) android_server_InputManager_nativeStart },</p>
<p>……</p>
<p>}</p>
<p>static void android_server_InputManager_nativeStart(JNIEnv* env, jclass clazz) {</p>
<p>……</p>
<p>status_t result = gNativeInputManager-&gt;getInputManager()-&gt;start();</p>
<p>……</p>
<p>}</p>
<p>在java代码中用了nativeStart()，然后JNI中又调用了NativeInputManager的start方法。在Native的InputManager中找到start的实现。</p>
<p>Framework/base/services/input/InputManager.cpp</p>
<p>status_t InputManager::start() {</p>
<p>status_t result = mDispatcherThread-&gt;run(&quot;InputDispatcher&quot;, PRIORITY_URGENT_DISPLAY);</p>
<p>……</p>
<p>result = mReaderThread-&gt;run(&quot;InputReader&quot;, PRIORITY_URGENT_DISPLAY);</p>
<p>……</p>
<p>}</p>
<p>这个方法就是在前面InputManager中的构造函数initialize中的两个线程运行起来。先看Input</p>
<p>Dispatcher线程运行的情况，然后就是InputReader线程。</p>
<p>Framework/base/services/input/InputDispatcher.cpp</p>
<p>bool InputDispatcherThread::threadLoop() {</p>
<p>    mDispatcher-&gt;dispatchOnce();</p>
<p>    return true;</p>
<p>}</p>
<p>InputDispatcher线程调用了Dispatcher的dispatchOnce的方法。同样的InputReader线程也会调用Reader的ReaderOnce的方法。</p>
<p>Framework/base/services/input/InputDispatcher.cpp</p>
<p>void InputDispatcher::dispatchOnce() {</p>
<p>……</p>
<p>dispatchOnceInnerLocked(&amp;nextWakeupTime);</p>
<p>……</p>
<p>  int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</p>
<p>    mLooper-&gt;pollOnce(timeoutMillis);</p>
<p>}</p>
<p>dispatchOnceInnerLocked是处理input输入消息，mLooper-&gt;pollOnce(timeoutMillis)是等待下次输入消息的事件。先看下消息在dispatchOnceInnerLocked函数中是如何处理的。</p>
<p>Framework/base/services/input/InputDispatcher.cpp</p>
<p>void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) {</p>
<p>……</p>
<p>case EventEntry::TYPE_KEY</p>
<p>……</p>
<p>done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</p>
<p>case EventEntry::TYPE_MOTION: {</p>
<p>……</p>
<p>done = dispatchMotionLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</p>
<p>……</p>
<p>}</p>
<p>这个函数比较长，input事件在android的上层通过两个队列来保存，分别是InboundQueue和outboundQueue。当有input事件产生时候，会判断InboundQueue是否为空，如果事件不为空的话，就从队列中取出这个input事件，然后根据input事件的类型来分发事件给不同的处理函数，比较常见的是KEY和Motion事件。不管是Key事件也好还是Motion事件都会调用dispatchEventToCurrentInputTargetsLocked(currentTime, entry, false);这个函数来继续处理。</p>
<p>Framework/base/services/input/InputDispatcher.cpp</p>
<p>void InputDispatcher::dispatchEventToCurrentInputTargetsLocked(nsecs_t currentTime,</p>
<p>        EventEntry* eventEntry, bool resumeWithAppendedMotionSample) {</p>
<p>……</p>
<p>prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp; inputTarget,</p>
<p>                    resumeWithAppendedMotionSample);</p>
<p>……</p>
<p>}</p>
<p>在这个函数中会继续调用prepareDispatchCycleLocked方法来继续处理。而在prepareDispatch</p>
<p>CycleLocked中又会继续调用startDispatchCycleLocked(currentTime, connection)来进一步处理。</p>
<p>Framework/base/services/input/InputDispatcher.cpp</p>
<p>void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,</p>
<p>        const sp&lt;Connection&gt;&amp; connection) {</p>
<p>……</p>
<p>switch (eventEntry-&gt;type) {</p>
<p>case EventEntry::TYPE_KEY: {</p>
<p>status = connection-&gt;inputPublisher.publishKeyEvent</p>
<p>case EventEntry::TYPE_MOTION: {</p>
<p>……</p>
<p>status = connection-&gt;inputPublisher.publishMotionEvent</p>
<p>……</p>
<p>status = connection-&gt;inputPublisher.sendDispatchSignal();</p>
<p>……</p>
<p>}</p>
<p>这个函数主要是根据input事件的类型来分发给不同的函数去处理，如果是KEY类型的事件就调用inputPublisher类的publishKeyEvent,如果是MOTION类的事件就会调用inputPublisher类的publishMotionEvent方法。并在最后发一个sendDispatchSignal。</p>
<p>Framework/base/libs/ui/InputTransport.cpp</p>
<p>status_t InputPublisher::publishInputEvent(</p>
<p>……</p>
<p>int ashmemFd = mChannel-&gt;getAshmemFd();</p>
<p>int result = ashmem_pin_region(ashmemFd, 0, 0);</p>
<p>……</p>
<p>mSemaphoreInitialized = true;</p>
<p>    mSharedMessage-&gt;consumed = false;</p>
<p>    mSharedMessage-&gt;type = type;</p>
<p>    mSharedMessage-&gt;deviceId = deviceId;</p>
<p>mSharedMessage-&gt;source = source;</p>
<p>……</p>
<p>}</p>
<p>利用publisher中的publishInputEvent将input event写入共享内存。这边产生了事件，另外一边必然会有个地方回去消费这个事件。注意到上面的代码中，最后发送了一个sendDispatchS</p>
<p>ignal。</p>
<p>Framework/base/libs/ui/InputTransport.cpp</p>
<p>status_t InputPublisher::sendDispatchSignal() {</p>
<p>……</p>
<p>return mChannel-&gt;sendSignal(INPUT_SIGNAL_DISPATCH);</p>
<p>……</p>
<p>}</p>
<p>这个函数直接调用了inputChannel的sendSignal方法。继续找到inputChannel的sendSignal实现。</p>
<p>Framework/base/libs/ui/InputTransport.cpp</p>
<p>status_t InputChannel::sendSignal(char signal) {</p>
<p>……</p>
<p>do {</p>
<p>        nWrite = ::write(mSendPipeFd, &amp; signal, 1);</p>
<p>    } while (nWrite == -1 &amp;&amp; errno == EINTR);</p>
<p>……</p>
<p>}</p>
<p>而在注册InputChannel的时候就曾经注册了当Looper接收到了信号的一个回调函数。</p>
<p>Framework/base/services/input/InputDispatcher.cpp</p>
<p>status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel,</p>
<p>        const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) {</p>
<p>……</p>
<p>mLooper-&gt;addFd(receiveFd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);</p>
<p>……</p>
<p>}</p>
<p>在handleReceiveCallback中，作为回调函数然后调用InputConsumer的consume函数来消费从inputReader中读取过来的InputEvent。</p>
<p>Framework/base/core/jni/android_view_InputQueue.cpp</p>
<p>int NativeInputQueue::handleReceiveCallback(int receiveFd, int events, void* data) {</p>
<p>……</p>
<p>status = connection-&gt;inputConsumer.consume(&amp; connection-&gt;inputEventFactory, &amp; inputEvent);</p>
<p>……</p>
<p>}</p>
<p>回过头来看之前的InputReader线程，在inputManager的start方法被调用了，Input的线程也就开始运行了。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>bool InputReaderThread::threadLoop() {</p>
<p>    mReader-&gt;loopOnce();</p>
<p>    return true;</p>
<p>}</p>
<p>在InputReader的loopOnce中会调用EventHub的getevents方法。这个方法会和linux内核的input子系统打交道。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void InputReader::loopOnce() {</p>
<p>……</p>
<p>size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</p>
<p>……</p>
<p>if (count) {</p>
<p>            processEventsLocked(mEventBuffer, count);</p>
<p>        }</p>
<p>……</p>
<p>}</p>
<p>这个函数主要通过EventHub的getEvents来获取input事件。</p>
<p>Framework/base/services/input/EventHub.cpp</p>
<p>size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) {</p>
<p>……</p>
<p>struct input_event readBuffer[bufferSize];</p>
<p>……</p>
<p>for (;;) {</p>
<p>……</p>
<p>if (mNeedToScanDevices) {</p>
<p>            mNeedToScanDevices = false;</p>
<p>            scanDevicesLocked();</p>
<p>            mNeedToSendFinishedDeviceScan = true;</p>
<p>        }</p>
<p>……</p>
<p>在eventHub初始化的时候mNeedToScanDevices的值是ture的，所以会直接进入到scanDevices</p>
<p>Locked。而在内核里面所有的input device在注册的时候都会在linux的文件系统下的/dev/input 下面，所以按照一般的HAL的思想，如果要去操作这个设备，首先还是要打开这个设备节点的。</p>
<p>Framework/base/services/input/EventHub.cpp</p>
<p>void EventHub::scanDevicesLocked() {</p>
<p>    status_t res = scanDirLocked(DEVICE_PATH);</p>
<p>    if(res &lt; 0) {</p>
<p>        LOGE(&quot;scan dir failed for %s\n&quot;, DEVICE_PATH);</p>
<p>    }</p>
<p>}</p>
<p>status_t EventHub::scanDirLocked(const char *dirname)</p>
<p>{</p>
<p>……</p>
<p>openDeviceLocked(devname);</p>
<p>……</p>
<p>}</p>
<p>代码中的while循环会对DEVICE_PATH(/dev/input)下的所有的设备节点调用openDeviceLocked</p>
<p>方法。</p>
<p>Framework/base/services/input/EventHub.cpp</p>
<p>status_t EventHub::openDeviceLocked(const char *devicePath) {</p>
<p>……</p>
<p>int fd = open(devicePath, O_RDWR);</p>
<p>……</p>
<p>InputDeviceIdentifier identifier;</p>
<p>……</p>
<p>if(ioctl(fd, EVIOCGNAME(sizeof(buffer) - 1), &amp;buffer) &lt; 1</p>
<p>……</p>
<p>if(ioctl(fd, EVIOCGVERSION, &amp;driverVersion))</p>
<p>……</p>
<p>if(ioctl(fd, EVIOCGID, &amp;inputId))</p>
<p>……</p>
<p>identifier.bus = inputId.bustype;</p>
<p>identifier.product = inputId.product;</p>
<p>identifier.vendor = inputId.vendor;</p>
<p>identifier.version = inputId.version;</p>
<p>……</p>
<p>Device* device = new Device(fd, deviceId, String8(devicePath), identifier);</p>
<p>……</p>
<p>struct epoll_event eventItem;</p>
<p>    memset(&amp;eventItem, 0, sizeof(eventItem));</p>
<p>    eventItem.events = EPOLLIN;</p>
<p>eventItem.data.u32 = deviceId;</p>
<p>……</p>
<p>mDevices.add(deviceId, device);</p>
<p>    device-&gt;next = mOpeningDevices;</p>
<p>    mOpeningDevices = device;</p>
<p>return 0;</p>
<p>}</p>
<p>首先通过open系统调用得到设备节点的文件描述符，然后新构造一个叫InputDeviceIdentifier类。接着通过对刚才得到的设备节点描述下ioctl的命令获取设备的一些简单信息，譬如：设备的名字，设备驱动的版本号，设备的唯一id，和描述符轮询的方式。得到的这些信息保存在InputDeviceIdentifier类里面。最后又构造了一个Device类，其中设备描述符和刚才的构造InputDeviceIdentifier类作为参数重新构造了Device类。然后在构造成功了Device类又会通过ioctl系统调用获取input设备的一些比较重要的参数。比如：设备上报事件的类型是相对事件还是绝对事件，相对事件一般是指像鼠标滑动，绝对事件就好比触摸屏上报的坐标，设备所属的class等一些比较重要的信息。举一些例子：INPUT_DEVICE_CLASS_KEYBOARD(按键类型)，INPUT_DEVICE_CLASS_CURSOR(带游标类型：鼠标和轨迹球等)，INPUT_DEVICE_CLASS_</p>
<p>TOUCH(触摸类型：单点触摸或多点触摸)，INPUT_DEVICE_CLASS_TOUCH_MT(这个类型特指多</p>
<p>点触摸)等。如果一个设备的驱动没有指明设备的类型的话，那么他在android中上报的数据时不会被处理的。这个函数的最后是将input设备的文件描述符加入到轮询的集合中去，如果接收到事件就会去处理。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void InputReader::loopOnce() {</p>
<p>……</p>
<p>size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</p>
<p>……</p>
<p>if (count) {</p>
<p>            processEventsLocked(mEventBuffer, count);</p>
<p>        }</p>
<p>……</p>
<p>}</p>
<p>回到之前的InputReader的线程中，通过EventHub的getevents方法得到了input事件。函数返回的是获取的事件数目。如果事件不为零或者负数就会调用processEventLocked来处理。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) {</p>
<p>……</p>
<p>            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);</p>
<p>……</p>
<p>case EventHubInterface::DEVICE_ADDED:</p>
<p>                addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</p>
<p>……</p>
<p>case EventHubInterface::DEVICE_REMOVED:</p>
<p>                removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</p>
<p>case EventHubInterface::FINISHED_DEVICE_SCAN:</p>
<p>                handleConfigurationChangedLocked(rawEvent-&gt;when);</p>
<p>}</p>
<p>在处理input的事件时候，如果不是设备的添加，删除和完成扫描的时候。就会调用process</p>
<p>EventsForDeviceLocked来处理。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void InputReader::processEventsForDeviceLocked(int32_t deviceId,</p>
<p>        const RawEvent* rawEvents, size_t count) {</p>
<p>……</p>
<p>device-&gt;process(rawEvents, count);</p>
<p>}</p>
<p>这个函数也很简单直接回调了device的process方法来进行处理，这个device就是在之前的eventHub打开设备时候构造了一个device类。下面来具体看看device的process是如何进行处理的。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void InputDevice::process(const RawEvent* rawEvents, size_t count) {</p>
<p>……</p>
<p>  for (size_t i = 0; i &lt; numMappers; i++) {</p>
<p>                InputMapper* mapper = mMappers[i];</p>
<p>                mapper-&gt;process(rawEvent);</p>
<p>            }</p>
<p>……</p>
<p>}</p>
<p>这里直接调用了mapper的process。那InputMapper是什么时候初始化的呢？前面提到如果设备不是设备的添加或删除的时候就调用processEventsForDeviceLocked来处理。也就是说当设备第一次添加的时候，就会调用addDeviceLocked。InputMapper就是从这个地方注册过来的。具体看下面的代码：</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void InputReader::addDeviceLocked(nsecs_t when, int32_t deviceId) {</p>
<p>……</p>
<p>InputDevice* device = createDeviceLocked(deviceId, name, classes);</p>
<p>……</p>
<p>}</p>
<p>InputDevice* InputReader::createDeviceLocked(int32_t deviceId,const String8&amp; name, uint32_t classes) {</p>
<p>……</p>
<p>InputDevice* device = new InputDevice(&amp;mContext, deviceId, name, classes);</p>
<p>……</p>
<p>if (classes &amp; INPUT_DEVICE_CLASS_SWITCH) {</p>
<p>        device-&gt;addMapper(new SwitchInputMapper(device));</p>
<p>}</p>
<p>……</p>
<p>if (classes &amp; INPUT_DEVICE_CLASS_CURSOR) {</p>
<p>        device-&gt;addMapper(new CursorInputMapper(device));</p>
<p>}</p>
<p>……</p>
<p>if (classes &amp; INPUT_DEVICE_CLASS_TOUCH_MT) {</p>
<p>        device-&gt;addMapper(new MultiTouchInputMapper(device));</p>
<p>    } else if (classes &amp; INPUT_DEVICE_CLASS_TOUCH) {</p>
<p>        device-&gt;addMapper(new SingleTouchInputMapper(device));</p>
<p>}</p>
<p>……</p>
<p>if (classes &amp; INPUT_DEVICE_CLASS_JOYSTICK) {</p>
<p>        device-&gt;addMapper(new JoystickInputMapper(device));</p>
<p>}</p>
<p>return device;</p>
<p>}</p>
<p>从上面的代码可以非常明显的看出，InputMapper是根据inputDevice的class来构造的这么一个类。也就是说如果我们的设备是Switch类就为这个设备构造一个SwitchInputMapper类，我们假设我们现在的事件是由触摸屏上报的事件处理流程。在前面处理的过程中我们就会调用MultiTouchInputMapper的process来继续处理。也就是说当处理到mapper-&gt;process的时候，代码就会根据具体的设备class类型来处理相应的事件。这么多inputMapper，我们就以</p>
<p>MultiTouchInputMapper的流程继续来分析事件的处理流程。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void MultiTouchInputMapper::process(const RawEvent* rawEvent) {</p>
<p>    TouchInputMapper::process(rawEvent);</p>
<p> mMultiTouchMotionAccumulator.process(rawEvent);</p>
<p>}</p>
<p>void MultiTouchMotionAccumulator::process(const RawEvent* rawEvent) {</p>
<p>……</p>
<p>  switch (rawEvent-&gt;scanCode) {</p>
<p>            case ABS_MT_POSITION_X:</p>
<p>                slot-&gt;mInUse = true;</p>
<p>                slot-&gt;mAbsMTPositionX = rawEvent-&gt;value;</p>
<p>……</p>
<p>case ABS_MT_POSITION_Y:</p>
<p>                slot-&gt;mInUse = true;</p>
<p>                slot-&gt;mAbsMTPositionY = rawEvent-&gt;value;</p>
<p>……</p>
<p>case ABS_MT_TOUCH_MAJOR:</p>
<p>                slot-&gt;mInUse = true;</p>
<p>                slot-&gt;mAbsMTTouchMajor = rawEvent-&gt;value;</p>
<p>                break;</p>
<p>……</p>
<p>case ABS_MT_TOUCH_MINOR:</p>
<p>                slot-&gt;mInUse = true;</p>
<p>                slot-&gt;mAbsMTTouchMinor = rawEvent-&gt;value;</p>
<p>                slot-&gt;mHaveAbsMTTouchMinor = true;</p>
<p>……</p>
<p>}</p>
<p>在这个处理过程中将上报的原始事件的一些重要参数都赋值给了一个叫slot的结构的成员。我们知道多点触摸上报的一些参数主要包括：X轴和Y轴的坐标点，ABS_MT_TOUCH_MAJOR代表手指和触摸屏接触面的长轴(如果假定人手指和触摸屏接触面一般都是椭圆)，ABS_MT_T</p>
<p>OUCH_MINOR代表手指和屏幕接触面的短轴等等一些重要的参数都对号入座的赋值给了一个叫slot的结构体成员，具体更多的参数代表什么意思我就不多说了(大家可以参照linux内核文档，多点触摸协议)。</p>
<p>MultiTouchInputMapper的process处理分了两部分，首先是调用了TouchInputMapper的process方法，然后调用了mMultiTouchMotionAccumulator.process来进行处理。先看TouchInputMapper的处理流程。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void TouchInputMapper::process(const RawEvent* rawEvent) {</p>
<p>……</p>
<p>if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;scanCode == SYN_REPORT) {</p>
<p>        sync(rawEvent-&gt;when);</p>
<p>    }</p>
<p>}</p>
<p>在linux内核往上层上报input event的时候是由顺序的，以触摸屏为例，input_report_abs会被用来上报一些绝对事件(如：接触面积半径，X和Y轴的坐标点)，但是在每一次上报完成后都会调用input_sync(input_dev);来表示一次完整的事件上报，换句话说这个rawEvent-&gt;type为EV_SYN的事件就是许多input event的分隔符。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void TouchInputMapper::sync(nsecs_t when) {</p>
<p>……<br>bool havePointerIds = true; </p>
<p>    mCurrentRawPointerData.clear();</p>
<p>syncTouch(when, &amp;havePointerIds);</p>
<p>……</p>
<p>cookPointerData();</p>
<p>……</p>
<p>dispatchHoverExit(when, policyFlags);</p>
<p>dispatchTouches(when, policyFlags);</p>
<p>dispatchHoverEnterAndMove(when, policyFlags);</p>
<p>……</p>
<p>}</p>
<p>通过同步触摸事件，然后调用cookPointerData来计算X和Y的坐标，前后两次上报数据的距离，和根据缩放的大小及方向来判断是不是需要旋转屏幕。然后dispatchTouches中又调用了</p>
<p>disaptchMotion方法。</p>
<p>Framework/base/services/input/InputReader.cpp</p>
<p>void TouchInputMapper::dispatchMotion(nsecs_t when, uint32_t policyFlags, uint32_t source,…</p>
<p>) {</p>
<p>……</p>
<p>getListener()-&gt;notifyMotion(&amp;args);</p>
<p>}</p>
<p>通过getLister的方法得到InputListener并调用其notifyMotion。</p>
<p>void QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) {</p>
<p>    mArgsQueue.push(new NotifyMotionArgs(*args));</p>
<p>}</p>
<p>在构造了一个NotifyMotionArgs类之后，我们回到之前的InputReader的loopOnce方法中，</p>
<p>在最后调用了mQueuedListener-&gt;flush();Flush函数就是要把mArgsQueue中的所有NotifyArgs进行处理。为描述方便，先看看其代码：</p>
<p>Framework/base/services/input/InputLisenter.cpp</p>
<p>void QueuedInputListener::flush() {</p>
<p>    size_t count = mArgsQueue.size();</p>
<p>    for (size_t i = 0; i &lt; count; i++) {</p>
<p>        NotifyArgs* args = mArgsQueue[i];</p>
<p>        args-&gt;notify(mInnerListener);</p>
<p>        delete args;</p>
<p>    }</p>
<p>    mArgsQueue.clear();</p>
<p>}</p>
<p>继续在NotifyArgs中调用了其notify的方法。还是在这个文件中可以看看我们NotifyMotion</p>
<p>Args的notify方法。</p>
<p>Framework/base/services/input/InputLisenter.cpp</p>
<p>void NotifyMotionArgs::notify(const sp&lt;InputListenerInterface&gt;&amp; listener) const {</p>
<p>    listener-&gt;notifyMotion(this);</p>
<p>}</p>
<p>在InputDispatcher.h中InputDispatcherInterface是继承InputListenerInterface，父类调用了子类的虚函数notifyMotion的实例化。在inputDispacher的notifyMotion中继续，这就重新回到了我们上面分析的InputDispatch线程的代码。正好完成了一边生产事件而在另一边消费事件。</p>
<p>1.2 Input子系统在linux内核分析</p>
<p>1.2.1 Input设备在内核中的注册过程</p>
<p>在linux系统中描述一个input设备可以用input_dev，在编写一个input设备驱动时，通常就需要为你的input设备分配这样一个结构体，然后input_allocate_device分配内存，初始化dev</p>
<p>结构体。</p>
<p>Kernel/drivers/input/input.c</p>
<p>struct input_dev *input_allocate_device(void)</p>
<p>{</p>
<p>    struct input_dev *dev;</p>
<p>    dev = kzalloc(sizeof(struct input_dev), GFP_KERNEL);</p>
<p>    if (dev) {</p>
<p>        dev-&gt;dev.type = &amp;input_dev_type;</p>
<p>        dev-&gt;dev.class = &amp;input_class;</p>
<p>        device_initialize(&amp;dev-&gt;dev);</p>
<p>        mutex_init(&amp;dev-&gt;mutex);</p>
<p>        spin_lock_init(&amp;dev-&gt;event_lock);</p>
<p>        INIT_LIST_HEAD(&amp;dev-&gt;h_list);</p>
<p>        INIT_LIST_HEAD(&amp;dev-&gt;node);</p>
<p>        __module_get(THIS_MODULE);</p>
<p>    }   </p>
<p>    return dev;</p>
<p>}</p>
<p>分配好了input_dev结构体所要的内存后，将dev的成员赋值初始化后，然后就可以调用内核API input_register_device来向input子系统注册。</p>
<p>Kernel/drivers/input/input.c</p>
<p>int input_register_device(struct input_dev *dev)</p>
<p>{</p>
<p>……</p>
<p>error = device_add(&amp;dev-&gt;dev);</p>
<p>……</p>
<p>list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</p>
<p>……</p>
<p>list_for_each_entry(handler, &amp;input_handler_list, node)</p>
<p>        input_attach_handler(dev, handler);</p>
<p>……</p>
<p>}</p>
<p>设备的注册还是和所有的linux设备注册一样调用device_add将设备注册进linux设备模型。</p>
<p>同时将设备添加到linux内核全局链表input_dev_list。然后通过list_for_each_entry来为设备找到属于自己的handler。介绍下linux的input子系统的三个重要概念：input_dev(代表一个input设备)，input_handler(响应并处理input事件)，input_handle(像个红娘一样将input设备和对应的input_handler连接在一起，其中就包含一个input_dev和input_handler的链表)。</p>
<p>1.2.2 Input_handler的注册过程</p>
<p>一般来说input_handler的注册会在input_dev之前来注册，常见的input_handler有：mousedev</p>
<p>handler(处理来自鼠标类的input事件)，joydev_handler(处理摇杆类事件)，kdev_handler(处理来自键盘类事件)，evdev_handler(响应绝大部门的事件，默认的input处理事件)。先看input的handler的注册函数API input_register_handler。</p>
<p>Kernel/drivers/input/input.c</p>
<p>int input_register_handler(struct input_handler *handler)</p>
<p>{</p>
<p>……</p>
<p>  INIT_LIST_HEAD(&amp;handler-&gt;h_list);</p>
<p>    if (handler-&gt;fops != NULL) {</p>
<p>        if (input_table[handler-&gt;minor &gt;&gt; 5]) {</p>
<p>            retval = -EBUSY;</p>
<p>            goto out;</p>
<p>        }</p>
<p>        input_table[handler-&gt;minor &gt;&gt; 5] = handler;</p>
<p>}</p>
<p>……</p>
<p>list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</p>
<p>list_for_each_entry(dev, &amp;input_dev_list, node) input_attach_handler(dev, handler);</p>
<p>……</p>
<p>}</p>
<p>函数先初始化了input handler在linux内核链表，然后如果handler的文件操作不为空就会为这个handler分配一个次设备号，从handler-&gt;minor &gt;&gt; 5，handler通过32为倍数来区分的，</p>
<p>换句话说每个handler处理的input event不能超过32。现在可以看到无论是设备的注册还是handler注册都会调用input_attach_handler。</p>
<p>static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</p>
<p>{</p>
<p>……</p>
<p>id = input_match_device(handler, dev);</p>
<p>……</p>
<p>error = handler-&gt;connect(handler, dev, id);</p>
<p>……</p>
<p>}</p>
<p>每个handler在注册的时候都有自己的id_table，如果设备和input handler能够匹配成功的话，就会调用input handler的connect函数。在input_match_device中会将input device的id.bus</p>
<p>type,id.vendor,id.product和id.version首先匹配。然后会去match的evbit,keybit,relbit,absbit等。</p>
<p>Kernel/drivers/input/input.c</p>
<p>static const struct input_device_id *input_match_device(struct input_handler *handler,</p>
<p>                            struct input_dev *dev)</p>
<p>{</p>
<p>……</p>
<p>for (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) {</p>
<p>        if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</p>
<p>            if (id-&gt;bustype != dev-&gt;id.bustype)</p>
<p>                continue;</p>
<p>……</p>
<p>MATCH_BIT(evbit,  EV_MAX);</p>
<p>……</p>
<p>  if (!handler-&gt;match || handler-&gt;match(handler, dev))</p>
<p>            return id;</p>
<p>}</p>
<p>}</p>
<p>如果handler和device能够match的话，就会调用handler的match回调函数，但是在linux input</p>
<p>Handler中不是所以的handler都实现了这个回调函数，只有joydev handler实现了。在看看evdev handler的id_table。</p>
<p>Kernel/driver/input/evdev.c</p>
<p>static const struct input_device_id evdev_ids[] = {</p>
<p>        { .driver_info = 1 },   /* Matches all devices */</p>
<p>        { },                    /* Terminating zero entry */</p>
<p>};</p>
<p>可以看到evdev是作为一个通用的handler去处理input device的事件。也就是说一旦有设备注册就会去调用evdev的connect函数。</p>
<p>Kernel/driver/input/evdev.c</p>
<p>static int evdev_connect(struct input_handler *handler, struct input_dev *dev  const struct input_device_id *id)</p>
<p>{</p>
<p>……</p>
<p>evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);</p>
<p>……</p>
<p>evdev-&gt;handle.dev = input_get_device(dev);</p>
<p>evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev)</p>
<p>evdev-&gt;handle.handler = handler;</p>
<p>evdev-&gt;handle.private = evdev;</p>
<p>evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);</p>
<p>evdev-&gt;dev.class = &amp;input_class;</p>
<p>evdev-&gt;dev.parent = &amp;dev-&gt;dev;</p>
<p>evdev-&gt;dev.release = evdev_free;</p>
<p>device_initialize(&amp;evdev-&gt;dev);</p>
<p>error = input_register_handle(&amp;evdev-&gt;handle);</p>
<p>……</p>
<p>error = device_add(&amp;evdev-&gt;dev);</p>
<p>……</p>
<p>}</p>
<p>这里面又有个设备注册的过程，重新创建了一个evdev设备，存在于/dev/input/eventX。这就是上面提到的Android上层需要直接操作的文件节点，就是在这个时候注册的。Input_register_handle也只是将匹配好的input设备和input handler分别加到自己的input设备链表和handler链表。</p>
<p>1.2.3 Linux input事件上报流程</p>
<p>一般input事件在底层上报都是通过中断方式，按键或者触摸。以一个具体的触摸屏的驱动为例分析下事件的上报过程。</p>
<p>input_report_abs(dev, ABS_X, MTOUCH_GET_XC(mtouch-&gt;data));</p>
<p>input_report_abs(dev, ABS_Y, MTOUCH_MAX_YC - MTOUCH_GET_YC(mtouch-&gt;data));</p>
<p>input_report_key(dev, BTN_TOUCH, MTOUCH_GET_TOUCHED(mtouch-&gt;data));</p>
<p>input_sync(dev)</p>
<p>上面就是一具体触摸屏接收到中断信号，调用中断处理函数来处理事件所调用的方法来完成一次上报事件，以input_sync来表示一次完成的事件上报。在input.h的头文件中这个函数都会统一调用input_event来进行处理。</p>
<p>Kernel/driver/input/input.c</p>
<p>void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</p>
<p>{</p>
<p>……</p>
<p>input_handle_event(dev, type, code, value);</p>
<p>……</p>
<p>}</p>
<p>static void input_handle_event(struct input_dev *dev,</p>
<p>                               unsigned int type, unsigned int code, int value)</p>
<p>{</p>
<p>……</p>
<p>int disposition = INPUT_IGNORE_EVENT;</p>
<p>……</p>
<p>if (disposition &amp; INPUT_PASS_TO_HANDLERS)</p>
<p>                input_pass_event(dev, type, code, value);</p>
<p>……</p>
<p>}</p>
<p>在input_handle_event函数中会有个disposition的变量来判定事件是交由谁来处理，有交给device来处理，handler处理和device和handler共同处理。一般大部分情况都是交给handler来处理。也就是说会又input_pass_event函数来继续处理。</p>
<p>Kernel/driver/input/input.c</p>
<p>static void input_pass_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</p>
<p>{</p>
<p>……</p>
<p>handle = rcu_dereference(dev-&gt;grab);</p>
<p>        if (handle)</p>
<p>                handle-&gt;handler-&gt;event(handle, type, code, value);</p>
<p>……</p>
<p>}</p>
<p>在之前的handler或者device注册的时候，每当一个device和handler发生匹配都会注册一个handle，然后将handler和device都加到自己链表中，这时候就可以通过hand来调用handler的event函数。</p>
<p>Kernel/driver/input/evdev.c</p>
<p>static struct input_handler evdev_handler = {</p>
<p>        .event          = evdev_event,</p>
<p>……</p>
<p>}</p>
<p>static void evdev_event(struct input_handle *handle,  unsigned int type, unsigned int code, int value)</p>
<p>{</p>
<p>struct evdev_client *client;</p>
<p>……</p>
<p>client = rcu_dereference(evdev-&gt;grab);</p>
<p>        if (client)</p>
<p>                evdev_pass_event(client, &amp;event);</p>
<p>……</p>
<p>if (type == EV_SYN &amp;&amp; code == SYN_REPORT)</p>
<p>     wake_up_interruptible(&amp;evdev-&gt;wait);</p>
<p>……</p>
<p>}</p>
<p>static void evdev_pass_event(struct evdev_client *client, struct input_event *event)</p>
<p>{</p>
<p>……</p>
<p>client-&gt;buffer[client-&gt;head++] = *event;</p>
<p>……</p>
<p>}</p>
<p>这里有个叫evdev_client的关键结构体，我们比较关注里面的3个结构体成员，client-&gt;buffer这个是用来存放input event事件。而head和client是用来标识input HAL也就是前面eventHub读的时候会不会阻塞的条件。这里有个type==EV_SYN也就是标识同步一次input事件，当每接收到一次input事件，就会去唤醒一次evdev-&gt;wait。说道这里还是看看evdev-&gt;wait是在哪里阻塞的。</p>
<p>Kernel/driver/input/evdev.c</p>
<p>static ssize_t evdev_read(struct file *file, char __user *buffer,size_t count, loff_t *ppos)</p>
<p>{</p>
<p>……</p>
<p>if (!(file-&gt;f_flags &amp; O_NONBLOCK)) {</p>
<p>                retval = wait_event_interruptible(evdev-&gt;wait,</p>
<p>                         client-&gt;packet_head != client-&gt;tail || !evdev-&gt;exist);</p>
<p>                if (retval)</p>
<p>                        return retval;</p>
<p>        }</p>
<p>while (retval + input_event_size() &lt;= count &amp;&amp;</p>
<p>               evdev_fetch_next_event(client, &amp;event)) {</p>
<p>                if (input_event_to_user(buffer + retval, &amp;event))</p>
<p>                        return -EFAULT;</p>
<p>                retval += input_event_size();</p>
<p>        }</p>
<p>static int evdev_fetch_next_event(struct evdev_client *client,</p>
<p>                                  struct input_event *event)</p>
<p>{</p>
<p>……</p>
<p>if (have_event) {</p>
<p>                *event = client-&gt;buffer[client-&gt;tail++];</p>
<p>                client-&gt;tail &amp;= client-&gt;bufsize - 1;</p>
<p>                if (client-&gt;head == client-&gt;tail)</p>
<p>                        wake_unlock(&amp;client-&gt;wake_lock);</p>
<p>        }</p>
<p>……</p>
<p>}</p>
<p>等待队列唤醒的条件是client-&gt;tail和client-&gt;packet_head不相等，初始化的时候两个都为0，</p>
<p>也就是说如果没有input事件上报的话，这个读事件是一直阻塞的。当有input事件上报，就会掉到evdev_pass_event中并且将client-&gt;head++。这样head和tail就不相等了，满足了唤醒条件，然后调用wake_up_interruptible(&amp;evdev-&gt;wait)就可以唤醒之前eventHub读的时候阻塞的进程，通过input_event_to_user。就可以将input事件从内核空间拷贝到用户态空间。从而完成了数据的传递。当然了为了达到同步，每处理完一次事件后，就会继续阻塞使进程睡眠，需要一个同步的工作，evdev_fetch_next_event会将client-&gt;tail++。这样他们有相等了，可以继续满足睡眠的条件，等待下一次的input事件上报将进程唤醒。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Android蓝牙系统</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Android%E8%93%9D%E7%89%99%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Android蓝牙系统</p>
<p>1.1 蓝牙技术简介</p>
<p>蓝牙(Bleuetooth)原是十世纪统一了丹麦的一个国王的名字，现取其“统一”的含义，用来意在统一无线局域网通讯的标准的蓝牙技术。蓝牙技术是爱立信，IBM，Intel等世界5家著名大公司在1998年联合推出的一项无线通讯规范。随后成立的蓝牙技术特殊兴趣组织（SIG）来负责该技术的开发和技术协议的制定，如今全世界已有1800多家公司加盟该组织，最近微软公司也正式加盟并成为SIG组织的领导成员之一。它以低成本的近距离无线连接为基础，为移动通信设备建立一个短程无线连接。其实质内容是建立通用的无线电空中接口，使计算机和通信设备进一步结合，让不同的厂家生产便携式设备在没有电缆或电线相互连接的情况下，能在近距离范围内具有相互通信的一种技术。</p>
<p>1.2 蓝牙技术的特点</p>
<p>Ø         全球范围适用</p>
<p>蓝牙技术使用无需经过许可的工业、科研和医疗(ISM)波段（2.4至2.485 GHz），使用展频、调频、全双工信号，标称速率为1600跳/秒。在大多数国家，无需经过许可便可使用2.4 GHz ISM波段。</p>
<p>Ø         抗干扰</p>
<p>蓝牙技术的适配跳频(AFH)能力的设计目的是为了减少共用2.4 GHz频谱的无线技术之间出现的干扰。该功能会在频谱中寻找并无被占用的频带以供蓝牙技术使用。AFH的工作原理是识别该频谱中的其他设备并避开这些设备所用的频带。跳频功能以1 MHz的频率在79个频段中进行切换，从而获得了较高的抗干扰能力，同时使该频谱中能够实现更加高效的传输。有了跳频功能，尽管其他技术与蓝牙技术同时使用，但蓝牙技术的用户仍能享有优质的性能表现。</p>
<p>Ø         射程</p>
<p>射程根据不同的具体应用而定，尽管核心规格规定了最低射程，但这并非限制，制造商仍可根据其具体用例调整射程应用。</p>
<p>根据具体应用中使用的射频种类，射程将有所不同：</p>
<p>第三类射频 – 射程最高1米或3英尺</p>
<p>第二类射频 – 最常见于移动设备，射程为10米或33英尺</p>
<p>第一类射频 – 主要用于工业用例，射程为100米或300英尺</p>
<p>Ø         低功耗</p>
<p>最常用的射频为第二类，其能耗为2.5 mW。蓝牙技术的设计能耗非常之低。此外，规格允许射频处于非活跃状态时可以断电则进一步降低了能耗。3.0版HS中的通用替代MAC/PHY能够发现高速设备的AMP，并仅在需要进行数据传输时开启射频，实现了节能优势，同时增强了射频的安全性。对于无需高速数据传输率但需要最大限度延长电池寿命的设备而言，蓝牙低耗能技术为其实现了优化效果，其耗电量仅为传统蓝牙技术的1/2至1/100。</p>
<p>1.3 蓝牙技术在android中的应用</p>
<p>1.3.1 蓝牙服务的启动</p>
<p>在前面章节android启动过程中介绍到android服务的启动，init进程中，启动Zygote后，然后由SystemServer启动一系列服务，蓝牙服务就是在这个时候启动的。详细见代码：</p>
<p>/framework/base/services/java/com/android/server/SystemServer.java</p>
<p>if (SystemProperties.get(&quot;ro.kernel.qemu&quot;).equals(&quot;1&quot;)) {</p>
<p>} else {</p>
<p>……</p>
<p>bluetooth = new BluetoothService(context);</p>
<p>……</p>
<p>bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);</p>
<p>……</p>
<p>if (airplaneModeOn == 0 &amp;&amp; bluetoothOn != 0) {</p>
<p>                    bluetooth.enable();</p>
<p> }  </p>
<p>Bluetooth服务的代码首先通过SystemProperties的get方法来判断系统是不是使用模拟器内核，如果是使用模拟器内核来启动android的系统，那么就会跳过蓝牙服务的启动，也就是说Android 4.0模拟器是不支持蓝牙系统的。否则就是一个实在的设备产品(ro.kernel.qemu=0)</p>
<p>就是构造一个bluetooth的服务(BluetoothService)和一个蓝牙耳机服务(BluetoothA2dpService)。</p>
<p>代码段最后一部分是判断开机是否要启用蓝牙，通过函数我们可以看到如果设备的飞行模式是关闭的并且bluetooth的那个开关是在on。就是调用bluetoothService的enable方法使得我们设备开机的时候就将蓝牙开启。飞行模式就是那些使用无线频谱的模块都必须关掉，譬如：wifi,Bluetooth,GPS等。接下来就是BluetoothService的enable方法了。</p>
<p>/framework/base/core/java/android/server/BluetoothService.java</p>
<p>public synchronized boolean enable(boolean saveSetting) {</p>
<p>mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,&quot;Need BLUETOOTH_ADMIN permission&quot;);</p>
<p>if (mIsAirplaneSensitive &amp;&amp; isAirplaneModeOn() &amp;&amp; !mIsAirplaneToggleable) {</p>
<p>            return false;</p>
<p> }   </p>
<p>mBluetoothState.sendMessage(BluetoothAdapterStateMachine.USER_TURN_ON, saveSetting);</p>
<p>        return true;</p>
<p> }   </p>
<p>蓝牙服务的enable的方法会先判断进程有没有操作权限，需要蓝牙管理的权限才能去enable蓝牙模块，然后还会再次判断系统的飞行模式有没有打开，如果此时飞行模式是on的话，那么会返回，还是不能打开服务。在确保拥有权限并且不是出于飞行模式的情况下，就会往蓝牙状态机发送一个USER_TURN_ON的命令。下面介绍一下android中的蓝牙状态机。</p>
<p>Ø         Poweroff</p>
<p>这就是蓝牙模块没有初始化的状态，这时候硬件模块是出于没有上电的状态。</p>
<p>Ø         Warmup</p>
<p>这个状态就是给设备上电，使设备能够从没电到待机状态。</p>
<p>Ø         Hotoff</p>
<p>Hotoff我个人理解就是在模块上电了，出于一种待命的状态，如果收到了turn_on_coninue的命令时候就会去将蓝牙模块切换到工作状态。如果接收到了turn_cold的命令时候，设备就会断电进入poweroff状态。</p>
<p>Ø         Switching</p>
<p>这也是一个中间状态，需要继续接收命令。</p>
<p>Ø         Bluetoothon</p>
<p>这时蓝牙模块出于正常工作的状态。</p>
<p>根据android中蓝牙状态的源码中，具体的各个状态机相互转换图如下：</p>
<p>   n</p>
<p>/framework/base/core/java/android/server/BluetoothAdapterStateMachine.java</p>
<p>private class PowerOff extends State {</p>
<p>public void enter() {</p>
<p>   if (DBG) log(&quot;Enter PowerOff: &quot; + getCurrentMessage().what);</p>
<p>   } </p>
<p>……</p>
<p>case USER_TURN_ON:</p>
<p>broadcastState(BluetoothAdapter.STATE_TURNING_ON);</p>
<p> transitionTo(mWarmUp);</p>
<p>……</p>
<p>if (prepareBluetooth()) {</p>
<p>if ((Boolean) message.obj) {</p>
<p>   persistSwitchSetting(true);</p>
<p>}</p>
<p>deferMessage(obtainMessage(TURN_ON_CONTINUE));</p>
<p>蓝牙状态机初始化时PowerOff的，从上面的BluetoothService的enable函数中USER_TURN_ON命令。从上面代码中可以看出蓝牙状态机在接收到USER_TURN_ON后，首先就像蓝牙适配器广播蓝牙正处于STATE_TRUNING_ON的状态，蓝牙的适配器的蓝牙状态有四个：</p>
<p>分别是,state_off(10),state_turning_on(11),state_on(12),state_turning_off(14)。由于我们刚开机所以蓝牙适配器的状态必然是从10-&gt;11。然后将蓝牙状态机的状态切换到mWaremUp状态。</p>
<p>接下来调用了prepareBluetooth()方法。接下来看看prepareBluetooth方法。代码如下：</p>
<p>/framework/base/core/java/android/server/BluetoothAdapterStateMachine.java</p>
<p>private boolean prepareBluetooth() {</p>
<p>  if (mBluetoothService.enableNative() != 0) {</p>
<p>          return false;</p>
<p>   }</p>
<p>……</p>
<p>int retryCount = 2；</p>
<p>boolean eventLoopStarted = false;</p>
<p>while ((retryCount– &gt; 0) &amp;&amp; !eventLoopStarted) {</p>
<p>mEventLoop.start();</p>
<p>while ((pollCount– &gt; 0) &amp;&amp; !eventLoopStarted) {</p>
<p>         if (mEventLoop.isEventLoopRunning()) {</p>
<p>                 eventLoopStarted = true;</p>
<p>                     break;</p>
<p>      }</p>
<p>在preprareBluetooth方法中，首先就是调用了BluetoothService的enableNative()的方法，只要一看到这种带Native的方法，JNI的代码是少不了的。由于enableNative方法走的路有点多，所以先直接到BluetoothService的代码中寻找enableNative()看个究竟。</p>
<p>framework/base/core/java/android/server/BluetoothService.java</p>
<p>/<em>package</em>/ native int enableNative();</p>
<p>Framework/base/core/jni/ android_server_BluetoothService.cpp</p>
<p>static JNINativeMethod sMethods[] = {</p>
<p>……</p>
<p>{&quot;enableNative&quot;, &quot;()I&quot;, (void *)enableNative},</p>
<p>……</p>
<p>}</p>
<p>static jint enableNative(JNIEnv *env, jobject object) {</p>
<p>return bt_enable();</p>
<p>}</p>
<p>从上面的代码可以看出，BluetoothService的enableNative就是直接调用了JNI的代码，JNI是java native interface的 缩写，中文叫java本地接口。Android上层跑的java代码，而底层代码都是c语言。以android的一贯作风是通过JNI代码调用HAL层，然后就可以直接调用驱动代码或者经由内核达到操作驱动代码。enableNative的代码很简单，就是调用了bt_enable。我们可以继续找到这个函数的实现。</p>
<p>System/bluetooth/bluedroid/bluetooth.c</p>
<p>int bt_enable() {</p>
<p>……</p>
<p>if (set_bluetooth_power(1) &lt; 0) goto out</p>
<p>……</p>
<p>if (property_set(&quot;ctl.start&quot;, &quot;hciattach&quot;) &lt; 0)</p>
<p>……</p>
<p>for (attempt = 1000; attempt &gt; 0;  attempt–) {</p>
<p>hci_sock = create_hci_sock();</p>
<p>……</p>
<p>ret = ioctl(hci_sock, HCIDEVUP, HCI_DEV_ID);</p>
<p>……</p>
<p>}</p>
<p>Set_bluetooth_power()函数会根据蓝牙的硬件开关，也就是hci设备注册的时候会同时在linux内核中注册一个rfkill类，比如我们在电脑键盘上面可能会看见一个按键来开关蓝牙或者wifi之类的。这里会去读这个键值，如果是1代表可以开启蓝牙的，否则是没法使用蓝牙的，在开发过程中如果没这样的按键，可将这行代码拿掉。Propery_set(“ctl.start”,hciattach)。这个函数会去启动hciattach服务，具体这个服务是以二进制文件存储在系统system/bin目录下面的。</p>
<p>我们可以从andriod启动脚本文件找到名字叫hciattach服务。当然这个是针对接串口的蓝牙来说需要启动服务，如果我们的设备是通过USB总线接入系统的话，其实这个服务也是可以不启动的。剩下的代码是一个for循环,先建立一个bluetooth的套接字，然后通过ioctl来和bluez的代码来打开蓝牙设备，可以重试1000次。接下来的代码就要跑到内核的BlueZ了。</p>
<p>Kernel/net/bluetooth/hci_sock.c</p>
<p>static int hci_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg){</p>
<p>……</p>
<p>case HCIDEVUP:</p>
<p>                if (!capable(CAP_NET_ADMIN))</p>
<p>                        return -EACCES;</p>
<p>                return hci_dev_open(arg);</p>
<p>……</p>
<p>}</p>
<p>从上面的ioctl下来的代码可以看出，当函数第二个参数cmd为HCIDEVUP时，就会直接调用hci_dev_open(arg)方法。这个函数就好比我们在终端下面使用蓝牙调试工具hciconfig,执行了</p>
<p>#hciconfig hci0 up。</p>
<p>Kernel/net/bluetooth/hci_core.c</p>
<p>int hci_dev_open(__u16 dev)</p>
<p>{</p>
<p>……</p>
<p>hdev = hci_dev_get(dev);</p>
<p>……</p>
<p>if (hdev-&gt;open(hdev)) {</p>
<p>                ret = -EIO;</p>
<p>                goto done;</p>
<p>  }</p>
<p>}</p>
<p>在kernel的bluez调用hci_dev_open，而在这个函数中又hdev-&gt;open(hdev),这个就是我们驱动注册时候的回调函数open。由于我们平台使用的是usb的蓝牙接入方式，我就以usb的蓝牙驱动为例，看看驱动的open函数。</p>
<p>Kernel/driver/bluetooth/btusb.c</p>
<p>static int btusb_open(struct hci_dev *hdev){</p>
<p>……</p>
<p>err = btusb_submit_intr_urb(hdev, GFP_KERNEL);</p>
<p>……</p>
<p>err = btusb_submit_bulk_urb(hdev, GFP_KERNEL);</p>
<p>……</p>
<p>}</p>
<p>USB hci设备打开后，首先将设备的interface配置为HCI_RUNNING状态，然后为数据传输初始化设备的端点和管道，初始化和填充urb。代码到这，蓝牙设备就算是真正打开了。</p>
<p>回到之前的蓝牙状态机的代码：</p>
<p>/framework/base/core/java/android/server/BluetoothAdapterStateMachine.java</p>
<p>private boolean prepareBluetooth() {</p>
<p>  if (mBluetoothService.enableNative() != 0) {</p>
<p>          return false;</p>
<p>   }</p>
<p>……</p>
<p>int retryCount = 2；</p>
<p>boolean eventLoopStarted = false;</p>
<p>while ((retryCount– &gt; 0) &amp;&amp; !eventLoopStarted) {</p>
<p>mEventLoop.start();</p>
<p>while ((pollCount– &gt; 0) &amp;&amp; !eventLoopStarted) {</p>
<p>         if (mEventLoop.isEventLoopRunning()) {</p>
<p>                 eventLoopStarted = true;</p>
<p>                     break;</p>
<p>      }</p>
<p>mBluetoothService在enableNative()函数主要功能就是通过一系列代码来打开蓝牙设备。如果设备驱动代码没有问题的话，我们enableNative()返回的将会是true。在实际调试蓝牙设备时候，我们可以通过在linux或者android的终端下面使用自带的工具命令(hciconfig),执行：</p>
<h1 id="hciconfig-–a如果驱动能够和设备绑定的话，我们就会看到蓝牙设备的一些比较重要信息，如：蓝牙的物理地址，总线类型，协议类型等。"><a href="#hciconfig-–a如果驱动能够和设备绑定的话，我们就会看到蓝牙设备的一些比较重要信息，如：蓝牙的物理地址，总线类型，协议类型等。" class="headerlink" title="hciconfig –a如果驱动能够和设备绑定的话，我们就会看到蓝牙设备的一些比较重要信息，如：蓝牙的物理地址，总线类型，协议类型等。"></a>hciconfig –a如果驱动能够和设备绑定的话，我们就会看到蓝牙设备的一些比较重要信息，如：蓝牙的物理地址，总线类型，协议类型等。</h1><p>上面的代码接下来会是一个while循环，执行2次。mEventLoop.start()。也就是说调用了EventLoop的start方法。</p>
<p>/framework/base/core/java/android/server/BluetoothEventLoop.java</p>
<p>/* package */ void start() {</p>
<p>   if (!isEventLoopRunningNative()) {</p>
<p>            if (DBG) log(&quot;Starting Event Loop thread&quot;);</p>
<p>            startEventLoopNative();</p>
<p>        }   </p>
<p>}</p>
<p>第一次进入这个函数isEventLoopRunningNative肯定是返回false的，所以直接进入了startEventLoopNative()，前面说过了一般带native的函数结尾的函数都是JNI。看到这里又要进JNI了。</p>
<p>Framework/base/core/jni/android_server_BluetoothEventLoop.cpp</p>
<p>static JNINativeMethod sMethods[] = {</p>
<p>……</p>
<p>{&quot;startEventLoopNative&quot;, &quot;()V&quot;, (void *)startEventLoopNative},</p>
<p>……</p>
<p>}</p>
<p>static jboolean startEventLoopNative(JNIEnv *env, jobject object) {</p>
<p>……</p>
<p>nat-&gt;pollData = (struct pollfd *)malloc(sizeof(struct pollfd) *</p>
<p>            DEFAULT_INITIAL_POLLFD_COUNT);</p>
<p>……</p>
<p>nat-&gt;watchData = (DBusWatch **)malloc(sizeof(DBusWatch *) *</p>
<p>            DEFAULT_INITIAL_POLLFD_COUNT);</p>
<p>……</p>
<p>if (socketpair(AF_LOCAL, SOCK_STREAM, 0, &amp;(nat-&gt;controlFdR))) {</p>
<p>        LOGE(&quot;Error getting BT control socket&quot;);</p>
<p>        goto done;</p>
<p>}</p>
<p>……</p>
<p>if (setUpEventLoop(nat) != JNI_TRUE) {</p>
<p>        LOGE(&quot;failure setting up Event Loop!&quot;);</p>
<p>        goto done;</p>
<p> }</p>
<p>pthread_create(&amp;(nat-&gt;thread), NULL, eventLoopMain, nat);</p>
<p>……</p>
<p>}</p>
<p>为socket文件描述符分配内存数据，同时为DBusWatch结构体分配内存，socketpair创建了一对套接字(AF_LOCAL域中使用)，这个描述符可以是单双工也可以是全双工的，这里是单双工的，也就是只能从这个描述符中读取数据，而不能写数据。如果socketpair的第四个参数是个数组，也可以实现一个描述符读，另外一个描述符写。从而实现全双工。然后就是setUpEventLoop函数，最后就是创建了eventLoopMain的线程。</p>
<p>Framework/base/core/jni/android_server_BluetoothEventLoop.cpp</p>
<p>static jboolean setUpEventLoop(native_data_t *nat) {</p>
<p>……</p>
<p>dbus_threads_init_default();</p>
<p>……</p>
<p>dbus_error_init(&amp;err);</p>
<p>……</p>
<p>if (!dbus_connection_add_filter(nat-&gt;conn, event_filter, nat, NULL)){</p>
<p>            return JNI_FALSE;</p>
<p>        }</p>
<p>……</p>
<p>dbus_bus_add_match(nat-&gt;conn,</p>
<p>                &quot;type=’signal’,interface=’org.freedesktop.DBus’&quot;,   &amp;err);</p>
<p>dbus_bus_add_match(nat-&gt;conn,</p>
<p>   &quot;type=’signal’,interface=’&quot;BLUEZ_DBUS_BASE_IFC&quot;.Adapter’&quot;,&amp;err);</p>
<p>……</p>
<p>}</p>
<p>这里是初始化dbus，是bluez能够挂接上dbus。建立一个dbus连接之后，为这个dbus连接起名，为我们将要进行的消息循环添加匹配条件(就是通过信号名和信号接口名来进行匹配控制的) – dbus_bus_add_match()。我们进入等待循环后，只需要对信号名，信号接口名进行判断就可以分别处理各种信号了。在各个处理分支上。我们可以分离出消息中的参数。对参数类型进行判断和其他的处理。具体对dbus感兴趣的话可以参照：<a href="http://dbus.freedesktop.org./">http://dbus.freedesktop.org。</a></p>
<p>Framework/base/core/jni/android_server_BluetoothEventLoop.cpp</p>
<p>static void *eventLoopMain(void *ptr) {</p>
<p>……</p>
<p>while (1) {</p>
<p>……</p>
<p>if (nat-&gt;pollData[i].fd == nat-&gt;controlFdR) {</p>
<p>while (recv(nat-&gt;controlFdR, &amp;data, sizeof(char), MSG_DONTWAIT) != -1) {</p>
<p>……</p>
<p>switch (data) {</p>
<p>case EVENT_LOOP_EXIT:</p>
<p>   dbus_connection_set_watch_functions(nat-&gt;conn,NULL, NULL, NULL, NULL, NULL);</p>
<p>   tearDownEventLoop(nat);</p>
<p>   nat-&gt;vm-&gt;DetachCurrentThread();</p>
<p>……</p>
<p>case EVENT_LOOP_ADD:</p>
<p>    {</p>
<p>     handleWatchAdd(nat);</p>
<p>         break;</p>
<p>     }</p>
<p>case EVENT_LOOP_REMOVE:</p>
<p>     {</p>
<p>      handleWatchRemove(nat);</p>
<p>          break;</p>
<p>      }</p>
<p>以轮训的方式从socket的描述符中不断的接收数据，如果有数据到来，就根据数据的类型做相应的处理。到这里dbus就和bluez建立连接。还是回到之前我们prepareBluetooth的函数。</p>
<p>/framework/base/core/java/android/server/BluetoothAdapterStateMachine.java</p>
<p>private class PowerOff extends State {</p>
<p>public void enter() {</p>
<p>   if (DBG) log(&quot;Enter PowerOff: &quot; + getCurrentMessage().what);</p>
<p>   } </p>
<p>……</p>
<p>case USER_TURN_ON:</p>
<p>broadcastState(BluetoothAdapter.STATE_TURNING_ON);</p>
<p> transitionTo(mWarmUp);</p>
<p>……</p>
<p>if (prepareBluetooth()) {</p>
<p>if ((Boolean) message.obj) {</p>
<p>   persistSwitchSetting(true);</p>
<p>}</p>
<p>deferMessage(obtainMessage(TURN_ON_CONTINUE));</p>
<p>前面的代码我们分析完了prepareBluetooth()，如果没有问题就进入了persistSwitchSetting()。</p>
<p>然后就是讲蓝牙状态机切换到mWarnUp状态。并向蓝牙状态机发送了一个TURN_ON_CONTINUE的命令。</p>
<p>/framework/base/core/java/android/server/BluetoothAdapterStateMachine.java</p>
<p>private class WarmUp extends State {</p>
<p>……</p>
<p>public boolean processMessage(Message message) {</p>
<p>   log(&quot;WarmUp process message: &quot; + message.what);</p>
<p>……</p>
<p>switch(message.what) {</p>
<p>case TURN_ON_CONTINUE:</p>
<p>这个命令在WarmUp状态里面什么也没做。直接通过deferMessage()到HotOff状态里面重新发送了TURN_ON_CONTINUE的命令。那我们HotOff状态机。</p>
<p>/framework/base/core/java/android/server/BluetoothAdapterStateMachine.java</p>
<p>private class HotOff extends State {</p>
<p>……</p>
<p>public boolean processMessage(Message message) {</p>
<p>    log(&quot;HotOff process message: &quot; + message.what);</p>
<p>……</p>
<p>switch(message.what) {</p>
<p>case TURN_ON_CONTINUE:</p>
<p>        int retryCount = 5</p>
<p>……</p>
<p>mBluetoothService.switchConnectable(true);</p>
<p>transitionTo(mSwitching);</p>
<p>……</p>
<p>}</p>
<p>在HotOff状态机中，接收到TURN_ON_CONTINUE命令后，先调用了BluetoothService的switchConnectable(true);然后将蓝牙的状态机切换到Switching状态。</p>
<p>/framework/base/core/java/android/server/BluetoothService.java</p>
<p>/<em>package</em>/ synchronized void switchConnectable(boolean on) {</p>
<p>        setAdapterPropertyBooleanNative(&quot;Powered&quot;, on ? 1 : 0);</p>
<p>    }</p>
<p>又到了以Native结尾的函数，还是到JNI里面找到它的实现吧。</p>
<p>Framework/base/core/jni/android_server_BluetoothService.cpp</p>
<p>static jboolean setAdapterPropertyNative(JNIEnv *env, jobject object, jstring key,</p>
<p>                                         void *value, jint type) {</p>
<p>……</p>
<p>msg = dbus_message_new_method_call(BLUEZ_DBUS_BASE_IFC,get_adapter_path(env, object),</p>
<p>DBUS_ADAPTER_IFACE, &quot;SetProperty&quot;);</p>
<p>……</p>
<p>dbus_message_append_args(msg, DBUS_TYPE_STRING, &amp;c_key, DBUS_TYPE_INVALID);</p>
<p>dbus_message_iter_init_append(msg, &amp;iter);</p>
<p>……</p>
<p>reply = dbus_connection_send_with_reply(nat-&gt;conn, msg, NULL, -1);</p>
<p>……</p>
<p>}</p>
<p>通过Dbus向bluez发送SetPropery的信息(message)，当成功的时候，我们在另外一端就会收到powerChanged的信号。具体处理如下的代码：</p>
<p>Framework/base/core/java/android/server/BluetoothEventLoop.java</p>
<p>/<em>package</em>/ void onPropertyChanged(String[] propValues) {</p>
<p>……</p>
<p>BluetoothAdapterProperties adapterProperties = mBluetoothService.getAdapterProperties();</p>
<p>……</p>
<p>else if (name.equals(&quot;Pairable&quot;) || name.equals(&quot;Discoverable&quot;)) {</p>
<p> adapterProperties.setProperty(name, propValues[1]);</p>
<p>if (name.equals(&quot;Discoverable&quot;)) {</p>
<p>          mBluetoothState.sendMessage(BluetoothAdapterStateMachine.SCAN_MODE_CHANGED);</p>
<p>            } </p>
<p>……</p>
<p>else if (name.equals(&quot;Powered&quot;)) {</p>
<p>          mBluetoothState.sendMessage(BluetoothAdapterStateMachine.POWER_STATE_CHANGED,</p>
<p>                propValues[1].equals(&quot;true&quot;) ? new Boolean(true) : new Boolean(false));</p>
<p>当有蓝牙AdapterProperies发生变化时，在BluetoothEventLoop.java中就会有个onProperyCha</p>
<p>nged方法来处理。首先通过BluetoothService的getAdapterProperties来获取蓝牙适配器的所有属性，都有哪些属性，在实际开发过程中我们通过调试可以看到按顺序依次是：power，</p>
<p>Pairable，class，device，UUID，Discoverable。通过将power的value设置为true，就会向蓝牙状态发送一个POWER_STATE_CHAGED，通过Discoverable的属性来向蓝牙状态机发送一个</p>
<p>SCAN_MODE_CHANGED的命令。</p>
<p>/framework/base/core/java/android/server/BluetoothAdapterStateMachine.java</p>
<p>case POWER_STATE_CHANGED:</p>
<p>               removeMessages(POWER_DOWN_TIMEOUT);</p>
<p>                    if (!((Boolean) message.obj)) {</p>
<p>                        if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {</p>
<p>                            transitionTo(mHotOff);</p>
<p>                            finishSwitchingOff();</p>
<p>                            if (!mContext.getResources().getBoolean</p>
<p>                            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {</p>
<p>                                deferMessage(obtainMessage(TURN_COLD));</p>
<p>                            }  </p>
<p>                        }  </p>
<p>                    } else {</p>
<p>                        if (mPublicState != BluetoothAdapter.STATE_TURNING_ON) {</p>
<p>                            if (mContext.getResources().getBoolean</p>
<p>                            (com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {</p>
<p>                                recoverStateMachine(TURN_HOT, null);</p>
<p>                            } else {</p>
<p>                                recoverStateMachine(TURN_COLD, null);</p>
<p>                            }  </p>
<p>                        }  </p>
<p>                    }  </p>
<p>在上一个HotOff的时候，已经将蓝牙状态机切换到了Switching了。所以直接在Switching这个状态里面来处理命令。第一个power_state_changed的命令很简单。在蓝牙状态机里面有个叫mPublicState的全局变量来记录蓝牙适配器的状态。如果是power的值为true，那么就将这个变量的值变为STATE_TURNING_ON，否则就是STATE_TURNING_OFF。在前面介绍过了蓝牙适配器总共有四个状态:State_off(10),state_turning_on(11),state_on(12),state_turning_off(</p>
<p>13)。那么继续来看第二个命令，scan_mode_changed。</p>
<p>/framework/base/core/java/android/server/BluetoothAdapterStateMachine.java</p>
<p>case SCAN_MODE_CHANGED:</p>
<p>     if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {</p>
<p>        mBluetoothService.setPairable();</p>
<p>        mBluetoothService.initBluetoothAfterTurningOn();</p>
<p>        transitionTo(mBluetoothOn);</p>
<p>        broadcastState(BluetoothAdapter.STATE_ON);</p>
<p>mBluetoothService.runBluetooth();</p>
<p>}</p>
<p>根据第一个命令，mPublicState的值是STATE_TURNING_ON，这里又要和BluetoothService来交互了，先调用了setPairable和initBluetoothAfterTurningOn，runBluetooth并将蓝牙状态机切换到BluetoothOn的状态。接下来到bluetoothService看这个setPairable方法。</p>
<p>/framework/base/core/java/android/server/BluetoothService.java</p>
<p>/<em>package</em>/ synchronized void setPairable() {</p>
<p>        String pairableString = getProperty(&quot;Pairable&quot;, false);</p>
<p>        if (pairableString == null) {</p>
<p>            Log.e(TAG, &quot;null pairableString&quot;);</p>
<p>            return;</p>
<p>        }   </p>
<p>        if (pairableString.equals(&quot;false&quot;)) {</p>
<p>            setAdapterPropertyBooleanNative(&quot;Pairable&quot;, 1);</p>
<p>        }   </p>
<p>    }   </p>
<p>这个过程和上面的设置POWER的过程是类似的，先通过getPropery获取Pairable的状态，如果是false的话，就需要调用JNI的方法setAdapterPropertyBooleanNative来通过dbus来向bluez来设置蓝牙适配器的Pairable的值。如果设置成功的话，同样还会调用BluetoothEventLoop中的onProperyChanged方法。继续跟进代码initBluetoothAfterTurningOn：</p>
<p>framework/base/core/java/android/server/BluetoothService.java</p>
<p>/<em>package</em>/ void initBluetoothAfterTurningOn() {</p>
<p>String discoverable = getProperty(&quot;Discoverable&quot;, false);</p>
<p>        String timeout = getProperty(&quot;DiscoverableTimeout&quot;, false);</p>
<p>        if (discoverable.equals(&quot;true&quot;) &amp;&amp; Integer.valueOf(timeout) != 0) {</p>
<p>            setAdapterPropertyBooleanNative(&quot;Discoverable&quot;, 0);</p>
<p>        }</p>
<p>mBondState.initBondState();</p>
<p>        initProfileState();</p>
<p>        getProfileProxy();</p>
<p>}</p>
<p>这个函数首先还是像设置power，Parirable的属性差不多，设置Discoverable的属性。当蓝牙模块打开和蓝牙适配器配对(Pairable)之后。剩下的initProfileState可以获取蓝牙的物理地址。</p>
<p>getProfileProxy直接调用了Adapter的getProfileProxy。得到俄ProfileProxy可以是HEADSET，</p>
<p>A2DP，INPUT_DEVICE，PAN，HEALTH。</p>
<p>framework/base/core/java/android/server/BluetoothService.java</p>
<p>/<em>package</em>/ void runBluetooth() {</p>
<p>……</p>
<p>autoConnect();</p>
<p>}</p>
<p>private void autoConnect() {</p>
<p>String[] bonds = getKnownDevices();</p>
<p>        if (bonds == null) {</p>
<p>            return;</p>
<p>        }</p>
<p>……</p>
<p>for (String path : bonds) {</p>
<p>            String address = getAddressFromObjectPath(path);</p>
<p>            BluetoothDeviceProfileState state = mDeviceProfileState.get(address);</p>
<p>            if (state != null) {</p>
<p>                Message msg = new Message();</p>
<p>                msg.what = BluetoothDeviceProfileState.AUTO_CONNECT_PROFILES;</p>
<p>                state.sendMessage(msg);</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>在autoConnect中，就会扫描附近的设备，并获取设备的地址和名字。这是我们看到就是能看到了一系列扫描出来的附近的设备。此时蓝牙的状态出于正常运行。到这里蓝牙模块就在</p>
<p>Android中工作起来了。</p>
<p>1.4 蓝牙开发在android中的调试</p>
<p>1.4.1 内核和驱动的支持</p>
<p>作为是linux内核的Android系统，必须在编译内核过程中将bluez编译的config选上。</p>
<p>CONFIG_BT =y</p>
<p>CONFIG_BT_RFCOMM =y</p>
<p>CONFIG_BT_BNEP = y</p>
<p>CONFIG_BT_CMTP =y</p>
<p>CONFIG_BT_L2CAP=y</p>
<p>CONFIG_BT_SCO=y</p>
<p>然后根据我们的驱动使用的接入方式，常见的有串口(uart)，USB，SDIO总线等。如果我们的驱动能够正常工作工作的话，我们在linux的终端通过下面命令就可以看见hci设备了。</p>
<p>root@android:/ # hciconfig -a                                                 </p>
<p>hci0:   Type: BR/EDR  Bus: USB</p>
<p>        BD Address: 74:2F:68:CE:13:57  ACL MTU: 1022:8  SCO MTU: 183:5</p>
<p>        DOWN</p>
<p>        RX bytes:505 acl:0 sco:0 events:22 errors:0</p>
<p>        TX bytes:99 acl:0 sco:0 commands:22 errors:0</p>
<p>        Features: 0xff 0xfe 0x0d 0xfe 0xd8 0x7f 0x7b 0x87</p>
<p>        Packet type: DM1 DM3 DM5 DH1 DH3 DH5 HV1 HV2 HV3</p>
<p>        Link policy: RSWITCH HOLD SNIFF</p>
<p>        Link mode: SLAVE ACCEPT</p>
<p>如果能够像上面可以看见蓝牙的类型，总线类型，物理地址等信息。说明蓝牙设备已经在内核中注册成功了，但能不能使用还要继续使用下面命令，我们注意到蓝牙模块状态时DOWN的。</p>
<p>root@android:/ # hciconfig hci0 up</p>
<p>root@android:/ # hciconfig -a                                                  </p>
<p>hci0:   Type: BR/EDR  Bus: USB</p>
<p>        BD Address: 74:2F:68:CE:13:57  ACL MTU: 1022:8  SCO MTU: 183:5</p>
<p>        UP RUNNING</p>
<p>        RX bytes:994 acl:0 sco:0 events:42 errors:0</p>
<p>        TX bytes:185 acl:0 sco:0 commands:42 errors:0                          </p>
<p>        Features: 0xff 0xfe 0x0d 0xfe 0xd8 0x7f 0x7b 0x87                      </p>
<p>        Packet type: DM1 DM3 DM5 DH1 DH3 DH5 HV1 HV2 HV3                       </p>
<p>        Link policy: RSWITCH HOLD SNIFF                                        </p>
<p>        Link mode: SLAVE ACCEPT                                                </p>
<p>        Name: ‘Bluetooth USB Host Controller’                                  </p>
<p>        Class: 0x000000                                                         </p>
<p>        Service Classes: Unspecified                                           </p>
<p>        Device Class: Miscellaneous,                                           </p>
<p>        HCI Version: 4.0 (0x6)  Revision: 0x102                                </p>
<p>        LMP Version: 4.0 (0x6)  Subversion: 0x1                                </p>
<p>        Manufacturer: Atheros Communications, Inc. (69)</p>
<p>通过hciconfig hci0 up命令让蓝牙模块的状态从DOWN变成UP状态。这个时候还不能就确定蓝牙驱动是能正常工作的。需要继续看看我们的蓝牙能不能扫描其他的蓝牙设备，如果能够扫描到其他的设备，就可以说明我们的蓝牙设备在内核态是可以正常工作的。</p>
<p>root@android:/ # hcitool scan                                                 </p>
<p>Scanning …</p>
<p>        00:1C:26:D5:3E:D6       DAWEIYAN-MOBL</p>
<p>        00:1E:4C:F3:BC:FA       ZHILONGX-MOBL</p>
<p>        00:1F:3A:F1:94:CD       JUELIUX-MOBL</p>
<p>        00:27:13:D6:66:D9       QWANG29-MOBL2</p>
<p>        50:63:13:C7:83:6D       YANCHAOY-MOBL</p>
<p>        00:1C:26:FD:11:3A       ZWANG16X-MOBL</p>
<p>好了如果能够扫描出设备的物理地址和名字的话，那我们的设备在linux 内核态就ok了。</p>
<p>1.4.2 Android Boradconfig和服务的支持</p>
<p>在BoardConfig.mk中添加：BOARD_HAVE_BLUETOOTH := true。因为在framework中的代码很多函数是需要这个宏的，如果这个宏没有打开的话，很多代码是走不过的。在android的添加蓝牙工作必要的服务，Dbus-daemon，bluetoothd，</p>
<p>/init.rc</p>
<p>service dbus /system/bin/dbus-daemon –system –nofork</p>
<p>    class main                       </p>
<p>    socket dbus stream 660 bluetooth bluetooth         </p>
<p>    user bluetooth                              </p>
<p>group bluetooth net_bt_admin  </p>
<p>service bluetoothd /system/bin/bluetoothd -n</p>
<p>    class main                                   </p>
<p>    socket bluetooth stream 660 bluetooth bluetooth                  </p>
<p>socket dbus_bluetooth stream 660 bluetooth Bluetooth</p>
<p>service  hciattach /system/bin/hciattach  当然这个服务只针对你的蓝牙接入方式是串口的，向我们这里是USB的话，这个服务还是可以省掉的。</p>
<p>service hfag /system/bin/sdptool add –channel=10 HFAG</p>
<p>    user bluetooth</p>
<p>    group bluetooth net_bt_admin</p>
<p>    disabled</p>
<p>oneshot</p>
<p>service hsag /system/bin/sdptool add –channel=11 HSAG</p>
<p>    user bluetooth</p>
<p>    group bluetooth net_bt_admin</p>
<p>    disabled</p>
<p>oneshot</p>
<p>service opush /system/bin/sdptool add –channel=12 OPUSH</p>
<p>    user bluetooth</p>
<p>    group bluetooth net_bt_admin</p>
<p>    disabled</p>
<p>oneshot</p>
<p>service pbap /system/bin/sdptool add –channel=19 PBAP</p>
<p>    user bluetooth</p>
<p>    group bluetooth net_bt_admin</p>
<p>    disabled</p>
<p>    oneshot</p>
<p>好了，到这里蓝牙应该就能正常工作了。上面的代码都是基于当前最新android 4.0。如果在蓝牙开发过程遇到问题的同志欢迎交流。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Java解析xml、解析xml四种方法、DOM、SAX、JDOM、DOM4j、XPath</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Java%E8%A7%A3%E6%9E%90xml%E3%80%81%E8%A7%A3%E6%9E%90xml%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E3%80%81DOM%E3%80%81SAX%E3%80%81JDOM%E3%80%81DOM4j%E3%80%81XPath/</url>
    <content><![CDATA[<p>关键字：Java解析xml、解析xml四种方法、DOM、SAX、JDOM、DOM4j、XPath</p>
<p>【引言】</p>
<p>目前在Java中用于解析XML的技术很多，主流的有DOM、SAX、JDOM、DOM4j，下文主要介绍这4种解析XML文档技术的使用、优缺点及性能测试。</p>
<p>一、【基础知识——扫盲】</p>
<p>sax、dom是两种对xml文档进行解析的方法(没有具体实现，只是接口)，所以只有它们是无法解析xml文档的；jaxp只是api，它进一步封装了sax、dom两种接口，并且提供了DomcumentBuilderFactory/DomcumentBuilder和SAXParserFactory/SAXParser（默认使用xerces解释器）。</p>
<p>二、【DOM、SAX、JDOM、DOM4j简单使用介绍】</p>
<p>1、【DOM(Document Object Model) 】<br>由W3C提供的接口，它将整个XML文档读入内存，构建一个DOM树来对各个节点(Node)进行操作。<br>示例代码：</p>
<p>[html] view plaincopy </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;      &lt;university name=&quot;pku&quot;&gt;         &lt;college name=&quot;c1&quot;&gt;             &lt;class name=&quot;class1&quot;&gt;                 &lt;student name=&quot;stu1&quot; sex=’male’ age=&quot;21&quot; /&gt;                 &lt;student name=&quot;stu2&quot; sex=’female’ age=&quot;20&quot; /&gt;                 &lt;student name=&quot;stu3&quot; sex=’female’ age=&quot;20&quot; /&gt;             &lt;/class&gt;             &lt;class name=&quot;class2&quot;&gt;                 &lt;student name=&quot;stu4&quot; sex=’male’ age=&quot;19&quot; /&gt;                 &lt;student name=&quot;stu5&quot; sex=’female’ age=&quot;20&quot; /&gt;                 &lt;student name=&quot;stu6&quot; sex=’female’ age=&quot;21&quot; /&gt;             &lt;/class&gt;         &lt;/college&gt;         &lt;college name=&quot;c2&quot;&gt;             &lt;class name=&quot;class3&quot;&gt;                 &lt;student name=&quot;stu7&quot; sex=’male’ age=&quot;20&quot; /&gt;             &lt;/class&gt;         &lt;/college&gt;         &lt;college name=&quot;c3&quot;&gt;         &lt;/college&gt;      &lt;/university&gt;    </p>
<p>后文代码中有使用到text.xml（该文档放在src路径下，既编译后在classes路径下），都是指该xml文档。</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.File;      import java.io.FileNotFoundException;      import java.io.FileOutputStream;      import java.io.IOException;      import java.io.InputStream;           import javax.xml.parsers.DocumentBuilder;      import javax.xml.parsers.DocumentBuilderFactory;      import javax.xml.parsers.ParserConfigurationException;      import javax.xml.transform.Transformer;      import javax.xml.transform.TransformerConfigurationException;      import javax.xml.transform.TransformerException;      import javax.xml.transform.TransformerFactory;      import javax.xml.transform.dom.DOMSource;      import javax.xml.transform.stream.StreamResult;           import org.w3c.dom.Document;      import org.w3c.dom.Element;      import org.w3c.dom.Node;      import org.w3c.dom.NodeList;      import org.w3c.dom.Text;      import org.xml.sax.SAXException;           /**      * dom读写xml      * @author whwang      */      public class TestDom {                  public static void main(String[] args) {             read();             //write();         }                  public static void read() {             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();             try {                 DocumentBuilder builder = dbf.newDocumentBuilder();                 InputStream in = TestDom.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.parse(in);                 // root &lt;university&gt;                 Element root = doc.getDocumentElement();                 if (root == null) return;                 System.err.println(root.getAttribute(&quot;name&quot;));                 // all college node                 NodeList collegeNodes = root.getChildNodes();                 if (collegeNodes == null) return;                 for(int i = 0; i &lt; collegeNodes.getLength(); i++) {                     Node college = collegeNodes.item(i);                     if (college != null &amp;&amp; college.getNodeType() == Node.ELEMENT_NODE) {                         System.err.println(&quot;\t&quot; + college.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue());                         // all class node                         NodeList classNodes = college.getChildNodes();                         if (classNodes == null) continue;                         for (int j = 0; j &lt; classNodes.getLength(); j++) {                             Node clazz = classNodes.item(j);                             if (clazz != null &amp;&amp; clazz.getNodeType() == Node.ELEMENT_NODE) {                                 System.err.println(&quot;\t\t&quot; + clazz.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue());                                 // all student node                                 NodeList studentNodes = clazz.getChildNodes();                                 if (studentNodes == null) continue;                                 for (int k = 0; k &lt; studentNodes.getLength(); k++) {                                     Node student = studentNodes.item(k);                                     if (student != null &amp;&amp; student.getNodeType() == Node.ELEMENT_NODE) {                                         System.err.print(&quot;\t\t\t&quot; + student.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue());                                         System.err.print(&quot; &quot; + student.getAttributes().getNamedItem(&quot;sex&quot;).getNodeValue());                                         System.err.println(&quot; &quot; + student.getAttributes().getNamedItem(&quot;age&quot;).getNodeValue());                                     }                                 }                             }                         }                     }                 }             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (FileNotFoundException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }                      }                  public static void write() {             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();             try {                 DocumentBuilder builder = dbf.newDocumentBuilder();                 InputStream in = TestDom.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.parse(in);                 // root &lt;university&gt;                 Element root = doc.getDocumentElement();                 if (root == null) return;                 // 修改属性                 root.setAttribute(&quot;name&quot;, &quot;tsu&quot;);                 NodeList collegeNodes = root.getChildNodes();                 if (collegeNodes != null) {                     for (int i = 0; i &lt;collegeNodes.getLength() - 1; i++) {                         // 删除节点                         Node college = collegeNodes.item(i);                         if (college.getNodeType() == Node.ELEMENT_NODE) {                             String collegeName = college.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue();                             if (&quot;c1&quot;.equals(collegeName) || &quot;c2&quot;.equals(collegeName)) {                                 root.removeChild(college);                             } else if (&quot;c3&quot;.equals(collegeName)) {                                 Element newChild = doc.createElement(&quot;class&quot;);                                 newChild.setAttribute(&quot;name&quot;, &quot;c4&quot;);                                 college.appendChild(newChild);                             }                         }                     }                 }                 // 新增节点                 Element addCollege = doc.createElement(&quot;college&quot;);                 addCollege.setAttribute(&quot;name&quot;, &quot;c5&quot;);                 root.appendChild(addCollege);                 Text text = doc.createTextNode(&quot;text&quot;);                 addCollege.appendChild(text);                                  // 将修改后的文档保存到文件                 TransformerFactory transFactory = TransformerFactory.newInstance();                 Transformer transFormer = transFactory.newTransformer();                 DOMSource domSource = new DOMSource(doc);                 File file = new File(&quot;src/dom-modify.xml&quot;);                 if (file.exists()) {                     file.delete();                 }                 file.createNewFile();                 FileOutputStream out = new FileOutputStream(file);                          StreamResult xmlResult = new StreamResult(out);                 transFormer.transform(domSource, xmlResult);                 System.out.println(file.getAbsolutePath());             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             } catch (TransformerConfigurationException e) {                 e.printStackTrace();             } catch (TransformerException e) {                 e.printStackTrace();             }         }     }    </p>
<p>该代码只要稍做修改，即可变得更加简洁，无需一直写if来判断是否有子节点。<br>2、【SAX (Simple API for XML) 】<br>SAX不用将整个文档加载到内存，基于事件驱动的API(Observer模式)，用户只需要注册自己感兴趣的事件即可。SAX提供EntityResolver, DTDHandler, ContentHandler, ErrorHandler接口，分别用于监听解析实体事件、DTD处理事件、正文处理事件和处理出错事件，与AWT类似，SAX还提供了一个对这4个接口默认的类DefaultHandler（这里的默认实现，其实就是一个空方法），一般只要继承DefaultHandler，重写自己感兴趣的事件即可。<br>示例代码：</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.IOException;      import java.io.InputStream;           import javax.xml.parsers.ParserConfigurationException;      import javax.xml.parsers.SAXParser;      import javax.xml.parsers.SAXParserFactory;           import org.xml.sax.Attributes;      import org.xml.sax.InputSource;      import org.xml.sax.Locator;      import org.xml.sax.SAXException;      import org.xml.sax.SAXParseException;      import org.xml.sax.helpers.DefaultHandler;           /**      *      * @author whwang      */      public class TestSAX {              public static void main(String[] args) {             read();             write();         }                  public static void read() {             try {                 SAXParserFactory factory = SAXParserFactory.newInstance();                 SAXParser parser = factory.newSAXParser();                 InputStream in = TestSAX.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 parser.parse(in, new MyHandler());             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }         }                  public static void write() {             System.err.println(&quot;纯SAX对于写操作无能为力&quot;);         }              }           // 重写对自己感兴趣的事件处理方法      class MyHandler extends DefaultHandler {              @Override         public InputSource resolveEntity(String publicId, String systemId)                 throws IOException, SAXException {             return super.resolveEntity(publicId, systemId);         }              @Override         public void notationDecl(String name, String publicId, String systemId)                 throws SAXException {             super.notationDecl(name, publicId, systemId);         }              @Override         public void unparsedEntityDecl(String name, String publicId,                 String systemId, String notationName) throws SAXException {             super.unparsedEntityDecl(name, publicId, systemId, notationName);         }              @Override         public void setDocumentLocator(Locator locator) {             super.setDocumentLocator(locator);         }              @Override         public void startDocument() throws SAXException {             System.err.println(&quot;开始解析文档&quot;);         }              @Override         public void endDocument() throws SAXException {             System.err.println(&quot;解析结束&quot;);         }              @Override         public void startPrefixMapping(String prefix, String uri)                 throws SAXException {             super.startPrefixMapping(prefix, uri);         }              @Override         public void endPrefixMapping(String prefix) throws SAXException {             super.endPrefixMapping(prefix);         }              @Override         public void startElement(String uri, String localName, String qName,                 Attributes attributes) throws SAXException {             System.err.print(&quot;Element: &quot; + qName + &quot;, attr: &quot;);             print(attributes);         }              @Override         public void endElement(String uri, String localName, String qName)                 throws SAXException {             super.endElement(uri, localName, qName);         }              @Override         public void characters(char[] ch, int start, int length)                 throws SAXException {             super.characters(ch, start, length);         }              @Override         public void ignorableWhitespace(char[] ch, int start, int length)                 throws SAXException {             super.ignorableWhitespace(ch, start, length);         }              @Override         public void processingInstruction(String target, String data)                 throws SAXException {             super.processingInstruction(target, data);         }              @Override         public void skippedEntity(String name) throws SAXException {             super.skippedEntity(name);         }              @Override         public void warning(SAXParseException e) throws SAXException {             super.warning(e);         }              @Override         public void error(SAXParseException e) throws SAXException {             super.error(e);         }              @Override         public void fatalError(SAXParseException e) throws SAXException {             super.fatalError(e);         }                  private void print(Attributes attrs) {             if (attrs == null) return;             System.err.print(&quot;[&quot;);             for (int i = 0; i &lt; attrs.getLength(); i++) {                 System.err.print(attrs.getQName(i) + &quot; = &quot; + attrs.getValue(i));                 if (i != attrs.getLength() - 1) {                     System.err.print(&quot;, &quot;);                 }             }             System.err.println(&quot;]&quot;);         }     }    </p>
<p>3、【JDOM】<br>JDOM与DOM非常类似，它是处理XML的纯JAVA API，API大量使用了Collections类，且JDOM仅使用具体类而不使用接口。　JDOM 它自身不包含解析器。它通常使用 SAX2 解析器来解析和验证输入 XML 文档（尽管它还可以将以前构造的 DOM 表示作为输入）。它包含一些转换器以将 JDOM 表示输出成 SAX2 事件流、DOM 模型或 XML 文本文档<br>示例代码：</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.File;      import java.io.FileOutputStream;      import java.io.IOException;      import java.io.InputStream;      import java.util.List;           import org.jdom.Attribute;      import org.jdom.Document;      import org.jdom.Element;      import org.jdom.JDOMException;      import org.jdom.input.SAXBuilder;      import org.jdom.output.XMLOutputter;           /**      * JDom读写xml      * @author whwang      */      public class TestJDom {         public static void main(String[] args) {             //read();             write();         }                  public static void read() {             try {                 boolean validate = false;                 SAXBuilder builder = new SAXBuilder(validate);                 InputStream in = TestJDom.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.build(in);                 // 获取根节点 &lt;university&gt;                 Element root = doc.getRootElement();                 readNode(root, &quot;&quot;);             } catch (JDOMException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }         }                  @SuppressWarnings(&quot;unchecked&quot;)         public static void readNode(Element root, String prefix) {             if (root == null) return;             // 获取属性             List&lt;Attribute&gt; attrs = root.getAttributes();             if (attrs != null &amp;&amp; attrs.size() &gt; 0) {                 System.err.print(prefix);                 for (Attribute attr : attrs) {                     System.err.print(attr.getValue() + &quot; &quot;);                 }                 System.err.println();             }             // 获取他的子节点             List&lt;Element&gt; childNodes = root.getChildren();             prefix += &quot;\t&quot;;             for (Element e : childNodes) {                 readNode(e, prefix);             }         }                  public static void write() {             boolean validate = false;             try {                 SAXBuilder builder = new SAXBuilder(validate);                 InputStream in = TestJDom.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.build(in);                 // 获取根节点 &lt;university&gt;                 Element root = doc.getRootElement();                 // 修改属性                 root.setAttribute(&quot;name&quot;, &quot;tsu&quot;);                 // 删除                 boolean isRemoved = root.removeChildren(&quot;college&quot;);                 System.err.println(isRemoved);                 // 新增                 Element newCollege = new Element(&quot;college&quot;);                 newCollege.setAttribute(&quot;name&quot;, &quot;new_college&quot;);                 Element newClass = new Element(&quot;class&quot;);                 newClass.setAttribute(&quot;name&quot;, &quot;ccccc&quot;);                 newCollege.addContent(newClass);                 root.addContent(newCollege);                 XMLOutputter out = new XMLOutputter();                 File file = new File(&quot;src/jdom-modify.xml&quot;);                 if (file.exists()) {                     file.delete();                 }                 file.createNewFile();                 FileOutputStream fos = new FileOutputStream(file);                 out.output(doc, fos);             } catch (JDOMException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }         }              }    </p>
<p>4、【DOM4j】<br>dom4j是目前在xml解析方面是最优秀的(Hibernate、Sun的JAXM也都使用dom4j来解析XML)，它合并了许多超出基本 XML 文档表示的功能，包括集成的 XPath 支持、XML Schema 支持以及用于大文档或流化文档的基于事件的处理<br>示例代码：</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.File;      import java.io.FileWriter;      import java.io.IOException;      import java.io.InputStream;      import java.util.List;           import org.dom4j.Attribute;      import org.dom4j.Document;      import org.dom4j.DocumentException;      import org.dom4j.DocumentHelper;      import org.dom4j.Element;      import org.dom4j.ProcessingInstruction;      import org.dom4j.VisitorSupport;      import org.dom4j.io.SAXReader;      import org.dom4j.io.XMLWriter;           /**      * Dom4j读写xml      * @author whwang      */      public class TestDom4j {         public static void main(String[] args) {             read1();             //read2();             //write();         }              public static void read1() {             try {                 SAXReader reader = new SAXReader();                 InputStream in = TestDom4j.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = reader.read(in);                 Element root = doc.getRootElement();                 readNode(root, &quot;&quot;);             } catch (DocumentException e) {                 e.printStackTrace();             }         }                  @SuppressWarnings(&quot;unchecked&quot;)         public static void readNode(Element root, String prefix) {             if (root == null) return;             // 获取属性             List&lt;Attribute&gt; attrs = root.attributes();             if (attrs != null &amp;&amp; attrs.size() &gt; 0) {                 System.err.print(prefix);                 for (Attribute attr : attrs) {                     System.err.print(attr.getValue() + &quot; &quot;);                 }                 System.err.println();             }             // 获取他的子节点             List&lt;Element&gt; childNodes = root.elements();             prefix += &quot;\t&quot;;             for (Element e : childNodes) {                 readNode(e, prefix);             }         }                  public static void read2() {             try {                 SAXReader reader = new SAXReader();                 InputStream in = TestDom4j.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = reader.read(in);                 doc.accept(new MyVistor());             } catch (DocumentException e) {                 e.printStackTrace();             }         }                  public static void write() {             try {                 // 创建一个xml文档                 Document doc = DocumentHelper.createDocument();                 Element university = doc.addElement(&quot;university&quot;);                 university.addAttribute(&quot;name&quot;, &quot;tsu&quot;);                 // 注释                 university.addComment(&quot;这个是根节点&quot;);                 Element college = university.addElement(&quot;college&quot;);                 college.addAttribute(&quot;name&quot;, &quot;cccccc&quot;);                 college.setText(&quot;text&quot;);                                  File file = new File(&quot;src/dom4j-modify.xml&quot;);                 if (file.exists()) {                     file.delete();                 }                 file.createNewFile();                 XMLWriter out = new XMLWriter(new FileWriter(file));                 out.write(doc);                 out.flush();                 out.close();             } catch (IOException e) {                 e.printStackTrace();             }         }     }           class MyVistor extends VisitorSupport {         public void visit(Attribute node) {             System.out.println(&quot;Attibute: &quot; + node.getName() + &quot;=&quot;                     + node.getValue());         }              public void visit(Element node) {             if (node.isTextOnly()) {                 System.out.println(&quot;Element: &quot; + node.getName() + &quot;=&quot;                         + node.getText());             } else {                 System.out.println(node.getName());             }         }              @Override         public void visit(ProcessingInstruction node) {             System.out.println(&quot;PI:&quot; + node.getTarget() + &quot; &quot; + node.getText());         }     }    </p>
<p>三、【性能测试】</p>
<p>环境：AMD4400+ 2.0+GHz主频 JDK6.0<br>运行参数：-Xms400m -Xmx400m<br>xml文件大小：10.7M<br>结果：<br>DOM: &gt;581297ms<br>SAX: 8829ms<br>JDOM: 581297ms<br>DOM4j: 5309ms<br>时间包括IO的，只是进行了简单的测试，仅供参考！！！！</p>
<p>四、【对比】</p>
<p>1、【DOM】<br>DOM是基于树的结构，通常需要加载整文档和构造DOM树，然后才能开始工作。<br>优点：<br>    a、由于整棵树在内存中，因此可以对xml文档随机访问<br>    b、可以对xml文档进行修改操作<br>    c、较sax，dom使用也更简单。<br>缺点：<br>    a、整个文档必须一次性解析完<br>    a、由于整个文档都需要载入内存，对于大文档成本高<br>2、【SAX】<br>SAX类似流媒体，它基于事件驱动的，因此无需将整个文档载入内存，使用者只需要监听自己感兴趣的事件即可。<br>优点：<br>    a、无需将整个xml文档载入内存，因此消耗内存少<br>    b、可以注册多个ContentHandler<br>缺点：<br>    a、不能随机的访问xml中的节点<br>    b、不能修改文档<br>3、【JDOM】<br>JDOM是纯Java的处理XML的API，其API中大量使用Collections类，<br>优点：<br>    a、DOM方式的优点<br>    b、具有SAX的Java规则<br>缺点<br>    a、DOM方式的缺点<br>4、【DOM4J】<br>这4中xml解析方式中，最优秀的一个，集易用和性能于一身。</p>
<p>五、【小插曲XPath】</p>
<p>XPath 是一门在 XML 文档中查找信息的语言， 可用来在 XML 文档中对元素和属性进行遍历。XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 同时被构建于 XPath 表达之上。因此，对 XPath 的理解是很多高级 XML 应用的基础。<br>XPath非常类似对数据库操作的SQL语言，或者说JQuery，它可以方便开发者抓起文档中需要的东西。（dom4j也支持xpath）<br>示例代码：</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.IOException;      import java.io.InputStream;           import javax.xml.parsers.DocumentBuilder;      import javax.xml.parsers.DocumentBuilderFactory;      import javax.xml.parsers.ParserConfigurationException;      import javax.xml.xpath.XPath;      import javax.xml.xpath.XPathConstants;      import javax.xml.xpath.XPathExpression;      import javax.xml.xpath.XPathExpressionException;      import javax.xml.xpath.XPathFactory;           import org.w3c.dom.Document;      import org.w3c.dom.NodeList;      import org.xml.sax.SAXException;           public class TestXPath {              public static void main(String[] args) {             read();         }                  public static void read() {             try {                 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();                 DocumentBuilder builder = dbf.newDocumentBuilder();                 InputStream in = TestXPath.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.parse(in);                 XPathFactory factory = XPathFactory.newInstance();                 XPath xpath = factory.newXPath();                 // 选取所有class元素的name属性                 // XPath语法介绍： <a href="http://w3school.com.cn/xpath/">http://w3school.com.cn/xpath/</a>                 XPathExpression expr = xpath.compile(&quot;//class/@name&quot;);                 NodeList nodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);                 for (int i = 0; i &lt; nodes.getLength(); i++) {                     System.out.println(&quot;name = &quot; + nodes.item(i).getNodeValue());                         }             } catch (XPathExpressionException e) {                 e.printStackTrace();             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }         }              }    </p>
<p>六、【补充】</p>
<p>注意4种解析方法对TextNode（文本节点）的处理：</p>
<p>1、在使用DOM时，调用node.getChildNodes()获取该节点的子节点，文本节点也会被当作一个Node来返回，如：</p>
<p>[html] view plaincopy </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;      &lt;university name=&quot;pku&quot;&gt;         &lt;college name=&quot;c1&quot;&gt;             &lt;class name=&quot;class1&quot;&gt;                 &lt;student name=&quot;stu1&quot; sex=’male’ age=&quot;21&quot; /&gt;                 &lt;student name=&quot;stu2&quot; sex=’female’ age=&quot;20&quot; /&gt;                 &lt;student name=&quot;stu3&quot; sex=’female’ age=&quot;20&quot; /&gt;             &lt;/class&gt;         &lt;/college&gt;      &lt;/university&gt;    </p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.FileNotFoundException;      import java.io.IOException;      import java.io.InputStream;      import java.util.Arrays;           import javax.xml.parsers.DocumentBuilder;      import javax.xml.parsers.DocumentBuilderFactory;      import javax.xml.parsers.ParserConfigurationException;           import org.w3c.dom.Document;      import org.w3c.dom.Element;      import org.w3c.dom.Node;      import org.w3c.dom.NodeList;      import org.xml.sax.SAXException;           /**      * dom读写xml      * @author whwang      */      public class TestDom2 {                  public static void main(String[] args) {             read();         }                  public static void read() {             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();             try {                 DocumentBuilder builder = dbf.newDocumentBuilder();                 InputStream in = TestDom2.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.parse(in);                 // root &lt;university&gt;                 Element root = doc.getDocumentElement();                 if (root == null) return;      //          System.err.println(root.getAttribute(&quot;name&quot;));                 // all college node                 NodeList collegeNodes = root.getChildNodes();                 if (collegeNodes == null) return;                 System.err.println(&quot;university子节点数：&quot; + collegeNodes.getLength());                 System.err.println(&quot;子节点如下：&quot;);                 for(int i = 0; i &lt; collegeNodes.getLength(); i++) {                     Node college = collegeNodes.item(i);                     if (college == null) continue;                     if (college.getNodeType() == Node.ELEMENT_NODE) {                         System.err.println(&quot;\t元素节点：&quot; + college.getNodeName());                     } else if (college.getNodeType() == Node.TEXT_NODE) {                         System.err.println(&quot;\t文本节点：&quot; + Arrays.toString(college.getTextContent().getBytes()));                     }                 }             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (FileNotFoundException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }                      }     }    </p>
<p>输出的结果是： </p>
<p>[java] view plaincopy </p>
<p>university子节点数：3     子节点如下：         文本节点：[10, 9]         元素节点：college         文本节点：[10]    </p>
<p>其中\n的ASCII码为10，\t的ASCII码为9。结果让人大吃一惊，university的子节点数不是1，也不是2，而是3，这3个子节点都是谁呢？为了看得更清楚点，把xml文档改为：</p>
<p>[html] view plaincopy </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;      &lt;university name=&quot;pku&quot;&gt;11         &lt;college name=&quot;c1&quot;&gt;             &lt;class name=&quot;class1&quot;&gt;                 &lt;student name=&quot;stu1&quot; sex=’male’ age=&quot;21&quot; /&gt;                 &lt;student name=&quot;stu2&quot; sex=’female’ age=&quot;20&quot; /&gt;                 &lt;student name=&quot;stu3&quot; sex=’female’ age=&quot;20&quot; /&gt;             &lt;/class&gt;         &lt;/college&gt;22      &lt;/university&gt;    </p>
<p>还是上面的程序，输出结果为： </p>
<p>[java] view plaincopy </p>
<p>university子节点数：3     子节点如下：         文本节点：[49, 49, 10, 9]         元素节点：college         文本节点：[50, 50, 10]    </p>
<p>其中数字1的ASCII码为49，数字2的ASCII码为50。 </p>
<p>2、使用SAX来解析同DOM，当你重写它的public void characters(char[] ch, int start, int length)方法时，你就能看到。</p>
<p>3、JDOM，调用node.getChildren()只返回子节点，不包括TextNode节点（不管该节点是否有Text信息）。如果要获取该节点的Text信息，可以调用node.getText()方法，该方法返回节点的Text信息，也包括\n\t等特殊字符。</p>
<p>4、DOM4j同JDOM</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>Linux SPI框架</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Linux%20SPI%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p> Linux的SPI子系统采用主机驱动和外设驱动分离的思想，首先主机SPI控制器是一种平台设备，因此它以platform的方式注册进内核，外设的信息是以boardinfo形式静态定义的，在创建spi_master时，会根据外设的bus_num和主机的bus_num是否相等，来选择是否将该外设挂接在该SPI主控制器下。先看SPI子系统中几个关键的数据结构：</p>
<p>struct spi_master用来描述一个SPI主控制器</p>
<p>[cpp] view plain copy</p>
<p>struct spi_master {  </p>
<p>struct device    dev;  </p>
<p>    s16    bus_num; /<em>总线编号</em>/  </p>
<p>    u16    num_chipselect;/<em>支持的外设数量</em>/  </p>
<p>    u16    dma_alignment;  </p>
<p>int   (*transfer)(struct spi_device <em>spi, struct spi_message *mesg);/*用于将消息添加到队列</em>/  </p>
<p>void  (*cleanup)(struct spi_device *spi);  </p>
<p>};  </p>
<p>struct spi_device用来描述一个SPI从设备</p>
<p>[cpp] view plain copy</p>
<p>struct spi_device {  </p>
<p>struct device       dev;  </p>
<p>struct spi_master   *master;                 /<em>从设备所属的SPI主控器</em>/  </p>
<p>    u32         max_speed_hz;   /<em>最大传输频率</em>/  </p>
<p>    u8          chip_select;    /<em>片选号，用于区别其他从设备</em>/  </p>
<p>    u8          mode;           /<em>传输模式</em>/  </p>
<p>/<em>各个mode的定义</em>/  </p>
<p>#define SPI_CPHA    0x01             /* clock phase */  </p>
<p>#define SPI_CPOL    0x02             /* clock polarity */  </p>
<p>#define SPI_MODE_0  (0|0)        /* (original MicroWire) */  </p>
<p>#define SPI_MODE_1  (0|SPI_CPHA)  </p>
<p>#define SPI_MODE_2  (SPI_CPOL|0)  </p>
<p>#define SPI_MODE_3  (SPI_CPOL|SPI_CPHA)  </p>
<p>#define SPI_CS_HIGH 0x04         /* chipselect active high? */  </p>
<p>#define SPI_LSB_FIRST   0x08         /* per-word bits-on-wire */  </p>
<p>#define SPI_3WIRE   0x10             /* SI/SO signals shared */  </p>
<p>#define SPI_LOOP    0x20             /* loopback mode */  </p>
<p>    u8          bits_per_word; /<em>每个字的比特数</em>/  </p>
<p>int         irq;           /<em>所使用的中断</em>/  </p>
<p>void            *controller_state;  </p>
<p>void            *controller_data;  </p>
<p>char            modalias[32];  /<em>设备名，在和从设备驱动匹配时会用到</em>/  </p>
<p>};  </p>
<p>struct spi_driver用来描述一个SPI从设备的驱动，它的形式和struct platform_driver是一致的</p>
<p>[cpp] view plain copy</p>
<p>struct spi_driver {  </p>
<p>int         (*probe)(struct spi_device *spi);  </p>
<p>int         (*remove)(struct spi_device *spi);  </p>
<p>void            (*shutdown)(struct spi_device *spi);  </p>
<p>int         (*suspend)(struct spi_device *spi, pm_message_t mesg);  </p>
<p>int         (*resume)(struct spi_device *spi);  </p>
<p>struct device_driver    driver;  </p>
<p>};  </p>
<p>SPI子系统初始化的第一步就是将SPI总线注册进内核，并且在/sys下创建一个spi_master的类，以后注册的从设备都将挂接在该总线下</p>
<p>[cpp] view plain copy</p>
<p>static int __init spi_init(void)  </p>
<p>{  </p>
<p>int status;  </p>
<p>    buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);  </p>
<p>if (!buf) {  </p>
<p>        status = -ENOMEM;  </p>
<p>goto err0;  </p>
<p>    }  </p>
<p>    status = bus_register(&amp;spi_bus_type);//注册SPI总线  </p>
<p>if (status &lt; 0)  </p>
<p>goto err1;  </p>
<p>    status = class_register(&amp;spi_master_class);//注册spi_master类  </p>
<p>if (status &lt; 0)  </p>
<p>goto err2;  </p>
<p>return 0;  </p>
<p>err2:  </p>
<p>    bus_unregister(&amp;spi_bus_type);  </p>
<p>err1:  </p>
<p>    kfree(buf);  </p>
<p>    buf = NULL;  </p>
<p>err0:  </p>
<p>return status;  </p>
<p>}  </p>
<p>我们来看spi_bus_type的定义</p>
<p>[cpp] view plain copy</p>
<p>struct bus_type spi_bus_type = {  </p>
<p>    .name       = &quot;spi&quot;,  </p>
<p>    .dev_attrs  = spi_dev_attrs,  </p>
<p>    .match      = spi_match_device,  </p>
<p>    .uevent     = spi_uevent,  </p>
<p>    .suspend    = spi_suspend,  </p>
<p>    .resume     = spi_resume,  </p>
<p>};  </p>
<p>来看挂接在SPI总线下的从设备和从设备驱动是如何匹配的，也就是spi_match_device函数</p>
<p>[cpp] view plain copy</p>
<p>static int spi_match_device(struct device *dev, struct device_driver *drv)  </p>
<p>{  </p>
<p>const struct spi_device *spi = to_spi_device(dev);  </p>
<p>return strcmp(spi-&gt;modalias, drv-&gt;name) == 0;  </p>
<p>}  </p>
<p>这里可以看到是将struct device_driver中的name字段与struct spi_device中的modalias字段进行匹配</p>
<p>这里已经完成了SPI子系统初始化的第一步，也就是注册SPI总线，这一步是和平台无关的，第二步是和平台相关的初始化 </p>
<p>上节介绍了SPI子系统中的一些重要数据结构和SPI子系统初始化的第一步，也就是注册SPI总线。这节介绍针对于s3c24xx平台的SPI子系统初始化，在看具体的代码之前，先上一张自己画的图，帮助理清初始化的主要步骤</p>
<p>显然，SPI是一种平台特定的资源，所以它是以platform平台设备的方式注册进内核的，因此它的struct platform_device结构是已经静态定义好了的，现在只待它的struct platform_driver注册，然后和platform_device匹配。</p>
<p>初始化的入口：</p>
<p>[html] view plain copy</p>
<p>static int __init s3c24xx_spi_init(void)  </p>
<p>{  </p>
<p>        return platform_driver_probe(&amp;s3c24xx_spi_driver, s3c24xx_spi_probe);  </p>
<p>}  </p>
<p>platform_driver_probe()会调用platform_driver_register()来注册驱动，然后在注册的过程中寻求匹配的platform_device,一旦匹配成功，便会调用probe函数，也就是s3c24xx_spi_probe()，在看这个函数之前，还得介绍几个相关的数据结构。</p>
<p>struct s3c2410_spi_info是一个板级结构，也是在移植时就定义好的，在初始化spi_master时用到，platform_device–&gt;dev–&gt;platform_data会指向这个结构。</p>
<p>[cpp] view plain copy</p>
<p>struct s3c2410_spi_info {  </p>
<p>int          pin_cs;    /* simple gpio cs */  </p>
<p>    unsigned int         num_cs;    /* total chipselects */  </p>
<p>int          bus_num;/* bus number to use. */  </p>
<p>void (*gpio_setup)(struct s3c2410_spi_info *spi, int enable);  </p>
<p>void (*set_cs)(struct s3c2410_spi_info *spi, int cs, int pol);  </p>
<p>};  </p>
<p>struct s3c24xx_spi用来具体描述s3c24xx平台上一个SPI控制器</p>
<p>[cpp] view plain copy</p>
<p>struct s3c24xx_spi {  </p>
<p>/* bitbang has to be first */  </p>
<p>struct spi_bitbang   bitbang;  </p>
<p>struct completion    done;  </p>
<p>void __iomem        *regs;  </p>
<p>int          irq;  </p>
<p>int          len;  </p>
<p>int          count;  </p>
<p>void            (*set_cs)(struct s3c2410_spi_info *spi,  </p>
<p>int cs, int pol);  </p>
<p>/* data buffers */  </p>
<p>const unsigned char *tx;  </p>
<p>    unsigned char       *rx;  </p>
<p>struct clk      *clk;  </p>
<p>struct resource     *ioarea;  </p>
<p>struct spi_master   *master;  </p>
<p>struct spi_device   *curdev;  </p>
<p>struct device       *dev;  </p>
<p>struct s3c2410_spi_info *pdata;  </p>
<p>};  </p>
<p>struct spi_bitbang用于控制实际的数据传输</p>
<p>[cpp] view plain copy</p>
<p>struct spi_bitbang {  </p>
<p>struct workqueue_struct *workqueue;  /<em>工作队列</em>/  </p>
<p>struct work_struct  work;  </p>
<p>    spinlock_t      lock;  </p>
<p>struct list_head    queue;  </p>
<p>    u8          busy;  </p>
<p>    u8          use_dma;  </p>
<p>    u8          flags;      /* extra spi-&gt;mode support */  </p>
<p>struct spi_master   *master;         /<em>bitbang所属的master</em>/  </p>
<p>/<em>用于设置设备传输时的时钟，字长等</em>/  </p>
<p>int (*setup_transfer)(struct spi_device *spi,  </p>
<p>struct spi_transfer *t);  </p>
<p>void    (*chipselect)(struct spi_device *spi, int is_on);  </p>
<p>#define BITBANG_CS_ACTIVE   1   /* normally nCS, active low */  </p>
<p>#define BITBANG_CS_INACTIVE 0  </p>
<p>/<em>针对于平台的传输控制函数</em>/  </p>
<p>int (*txrx_bufs)(struct spi_device *spi, struct spi_transfer *t);  </p>
<p>/* txrx_word<a href="">SPI_MODE_*</a> just looks like a shift register */  </p>
<p>    u32 (*txrx_word[4])(struct spi_device *spi,  </p>
<p>            unsigned nsecs,  </p>
<p>            u32 word, u8 bits);  </p>
<p>};  </p>
<p>下面来看s3c24xx_spi_probe()函数的实现</p>
<p>[cpp] view plain copy</p>
<p>static int __init s3c24xx_spi_probe(struct platform_device *pdev)  </p>
<p>{  </p>
<p>struct s3c2410_spi_info *pdata;  </p>
<p>struct s3c24xx_spi *hw;  </p>
<p>struct spi_master *master;  </p>
<p>struct resource *res;  </p>
<p>int err = 0;  </p>
<p>/<em>创建spi_master，并将spi_master-&gt;private_data指向s3c24xx_spi</em>/  </p>
<p>    master = spi_alloc_master(&amp;pdev-&gt;dev, sizeof(struct s3c24xx_spi));  </p>
<p>if (master == NULL) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;No memory for spi_master\n&quot;);  </p>
<p>        err = -ENOMEM;  </p>
<p>goto err_nomem;  </p>
<p>    }  </p>
<p>    hw = spi_master_get_devdata(master);//获取s3c24xx_spi  </p>
<p>    memset(hw, 0, sizeof(struct s3c24xx_spi));  </p>
<p>    hw-&gt;master = spi_master_get(master);  </p>
<p>    hw-&gt;pdata = pdata = pdev-&gt;dev.platform_data;  </p>
<p>    hw-&gt;dev = &amp;pdev-&gt;dev;  </p>
<p>if (pdata == NULL) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;No platform data supplied\n&quot;);  </p>
<p>        err = -ENOENT;  </p>
<p>goto err_no_pdata;  </p>
<p>    }  </p>
<p>    platform_set_drvdata(pdev, hw);  </p>
<p>    init_completion(&amp;hw-&gt;done);  </p>
<p>/* setup the master state. */  </p>
<p>/<em>片选数和SPI主控制器编号是在platform_data中已经定义好了的</em>/  </p>
<p>    master-&gt;num_chipselect = hw-&gt;pdata-&gt;num_cs;  </p>
<p>    master-&gt;bus_num = pdata-&gt;bus_num;  </p>
<p>/* setup the state for the bitbang driver */  </p>
<p>/<em>设置bitbang的所属master和控制传输的相关函数</em>/  </p>
<p>    hw-&gt;bitbang.master         = hw-&gt;master;  </p>
<p>    hw-&gt;bitbang.setup_transfer = s3c24xx_spi_setupxfer;  </p>
<p>    hw-&gt;bitbang.chipselect     = s3c24xx_spi_chipsel;  </p>
<p>    hw-&gt;bitbang.txrx_bufs      = s3c24xx_spi_txrx;  </p>
<p>    hw-&gt;bitbang.master-&gt;setup  = s3c24xx_spi_setup;  </p>
<p>    dev_dbg(hw-&gt;dev, &quot;bitbang at %p\n&quot;, &amp;hw-&gt;bitbang);  </p>
<p>/* find and map our resources */  </p>
<p>    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);  </p>
<p>if (res == NULL) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;Cannot get IORESOURCE_MEM\n&quot;);  </p>
<p>        err = -ENOENT;  </p>
<p>goto err_no_iores;  </p>
<p>    }  </p>
<p>    hw-&gt;ioarea = request_mem_region(res-&gt;start, (res-&gt;end - res-&gt;start)+1,  </p>
<p>                    pdev-&gt;name);  </p>
<p>if (hw-&gt;ioarea == NULL) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;Cannot reserve region\n&quot;);  </p>
<p>        err = -ENXIO;  </p>
<p>goto err_no_iores;  </p>
<p>    }  </p>
<p>/<em>映射SPI控制寄存器</em>/  </p>
<p>    hw-&gt;regs = ioremap(res-&gt;start, (res-&gt;end - res-&gt;start)+1);  </p>
<p>if (hw-&gt;regs == NULL) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;Cannot map IO\n&quot;);  </p>
<p>        err = -ENXIO;  </p>
<p>goto err_no_iomap;  </p>
<p>    }  </p>
<p>/<em>获取中断号</em>/  </p>
<p>    hw-&gt;irq = platform_get_irq(pdev, 0);  </p>
<p>if (hw-&gt;irq &lt; 0) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;No IRQ specified\n&quot;);  </p>
<p>        err = -ENOENT;  </p>
<p>goto err_no_irq;  </p>
<p>    }  </p>
<p>/<em>注册中断</em>/  </p>
<p>    err = request_irq(hw-&gt;irq, s3c24xx_spi_irq, 0, pdev-&gt;name, hw);  </p>
<p>if (err) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;Cannot claim IRQ\n&quot;);  </p>
<p>goto err_no_irq;  </p>
<p>    }  </p>
<p>    hw-&gt;clk = clk_get(&amp;pdev-&gt;dev, &quot;spi&quot;);  </p>
<p>if (IS_ERR(hw-&gt;clk)) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;No clock for device\n&quot;);  </p>
<p>        err = PTR_ERR(hw-&gt;clk);  </p>
<p>goto err_no_clk;  </p>
<p>    }  </p>
<p>/* setup any gpio we can */  </p>
<p>if (!pdata-&gt;set_cs) {  </p>
<p>if (pdata-&gt;pin_cs &lt; 0) {  </p>
<p>            dev_err(&amp;pdev-&gt;dev, &quot;No chipselect pin\n&quot;);  </p>
<p>goto err_register;  </p>
<p>        }  </p>
<p>        err = gpio_request(pdata-&gt;pin_cs, dev_name(&amp;pdev-&gt;dev));  </p>
<p>if (err) {  </p>
<p>            dev_err(&amp;pdev-&gt;dev, &quot;Failed to get gpio for cs\n&quot;);  </p>
<p>goto err_register;  </p>
<p>        }  </p>
<p>        hw-&gt;set_cs = s3c24xx_spi_gpiocs;//设定片选函数  </p>
<p>        gpio_direction_output(pdata-&gt;pin_cs, 1);  </p>
<p>    } else  </p>
<p>        hw-&gt;set_cs = pdata-&gt;set_cs;  </p>
<p>    s3c24xx_spi_initialsetup(hw);  </p>
<p>/* register our spi controller */  </p>
<p>/* 注册主机SPI控制器 */  </p>
<p>    err = spi_bitbang_start(&amp;hw-&gt;bitbang);  </p>
<p>if (err) {  </p>
<p>        dev_err(&amp;pdev-&gt;dev, &quot;Failed to register SPI master\n&quot;);  </p>
<p>goto err_register;  </p>
<p>    }  </p>
<p>return 0;  </p>
<p> err_register:  </p>
<p>if (hw-&gt;set_cs == s3c24xx_spi_gpiocs)  </p>
<p>        gpio_free(pdata-&gt;pin_cs);  </p>
<p>    clk_disable(hw-&gt;clk);  </p>
<p>    clk_put(hw-&gt;clk);  </p>
<p> err_no_clk:  </p>
<p>    free_irq(hw-&gt;irq, hw);  </p>
<p> err_no_irq:  </p>
<p>    iounmap(hw-&gt;regs);  </p>
<p>[cpp] view plain copy</p>
<p>int spi_bitbang_start(struct spi_bitbang *bitbang)  </p>
<p>{  </p>
<p>int status;  </p>
<p>if (!bitbang-&gt;master || !bitbang-&gt;chipselect)  </p>
<p>return -EINVAL;  </p>
<p>/<em>初始化一个struct work,处理函数为bitbang_work</em>/  </p>
<p>    INIT_WORK(&amp;bitbang-&gt;work, bitbang_work);  </p>
<p>    spin_lock_init(&amp;bitbang-&gt;lock);  </p>
<p>    INIT_LIST_HEAD(&amp;bitbang-&gt;queue);  </p>
<p>/<em>检测bitbang中的函数是否都定义了，如果没定义，则默认使用spi_bitbang_xxx</em>/  </p>
<p>if (!bitbang-&gt;master-&gt;transfer)  </p>
<p>        bitbang-&gt;master-&gt;transfer = spi_bitbang_transfer;  </p>
<p>if (!bitbang-&gt;txrx_bufs) {  </p>
<p>        bitbang-&gt;use_dma = 0;  </p>
<p>        bitbang-&gt;txrx_bufs = spi_bitbang_bufs;  </p>
<p>if (!bitbang-&gt;master-&gt;setup) {  </p>
<p>if (!bitbang-&gt;setup_transfer)  </p>
<p>                bitbang-&gt;setup_transfer =  </p>
<p>                     spi_bitbang_setup_transfer;  </p>
<p>            bitbang-&gt;master-&gt;setup = spi_bitbang_setup;  </p>
<p>            bitbang-&gt;master-&gt;cleanup = spi_bitbang_cleanup;  </p>
<p>        }  </p>
<p>    } else if (!bitbang-&gt;master-&gt;setup)  </p>
<p>return -EINVAL;  </p>
<p>/* this task is the only thing to touch the SPI bits */  </p>
<p>    bitbang-&gt;busy = 0;  </p>
<p>/<em>创建bitbang的工作队列</em>/  </p>
<p>    bitbang-&gt;workqueue = create_singlethread_workqueue(  </p>
<p>            dev_name(bitbang-&gt;master-&gt;dev.parent));  </p>
<p>if (bitbang-&gt;workqueue == NULL) {  </p>
<p>        status = -EBUSY;  </p>
<p>goto err1;  </p>
<p>    }  </p>
<p>/* driver may get busy before register() returns, especially </p>
<p>     * if someone registered boardinfo for devices </p>
<p>     */  </p>
<p>/<em>注册spi_master</em>/  </p>
<p>    status = spi_register_master(bitbang-&gt;master);  </p>
<p>if (status &lt; 0)  </p>
<p>goto err2;  </p>
<p>return status;  </p>
<p>err2:  </p>
<p>    destroy_workqueue(bitbang-&gt;workqueue);  </p>
<p>err1:  </p>
<p>return status;  </p>
<p>}  </p>
<p>下一个关键函数就是spi_register_master(),用于注册spi_master</p>
<p>[cpp] view plain copy</p>
<p>int spi_register_master(struct spi_master *master)  </p>
<p>{  </p>
<p>static atomic_t     dyn_bus_id = ATOMIC_INIT((1&lt;&lt;15) - 1);  </p>
<p>struct device       *dev = master-&gt;dev.parent;  </p>
<p>int         status = -ENODEV;  </p>
<p>int         dynamic = 0;  </p>
<p>if (!dev)  </p>
<p>return -ENODEV;  </p>
<p>/* even if it’s just one always-selected device, there must </p>
<p>     * be at least one chipselect </p>
<p>     */  </p>
<p>if (master-&gt;num_chipselect == 0)//片选数不能为0  </p>
<p>return -EINVAL;  </p>
<p>/* convention:  dynamically assigned bus IDs count down from the max */  </p>
<p>if (master-&gt;bus_num &lt; 0) {  </p>
<p>/* FIXME switch to an IDR based scheme, something like </p>
<p>         * I2C now uses, so we can’t run out of &quot;dynamic&quot; IDs </p>
<p>         */  </p>
<p>        master-&gt;bus_num = atomic_dec_return(&amp;dyn_bus_id);  </p>
<p>        dynamic = 1;  </p>
<p>    }  </p>
<p>/* register the device, then userspace will see it. </p>
<p>     * registration fails if the bus ID is in use. </p>
<p>     */  </p>
<p>    dev_set_name(&amp;master-&gt;dev, &quot;spi%u&quot;, master-&gt;bus_num);  </p>
<p>    status = device_add(&amp;master-&gt;dev);//添加spi_master设备  </p>
<p>if (status &lt; 0)  </p>
<p>goto done;  </p>
<p>    dev_dbg(dev, &quot;registered master %s%s\n&quot;, dev_name(&amp;master-&gt;dev),  </p>
<p>            dynamic ? &quot; (dynamic)&quot; : &quot;&quot;);  </p>
<p>/* populate children from any spi device tables */  </p>
<p>    scan_boardinfo(master);//遍历板级信息，寻找可以挂接在该spi_master下的从设备  </p>
<p>    status = 0;  </p>
<p>done:  </p>
<p>return status;  </p>
<p>}  </p>
<p>[cpp] view plain copy</p>
<p>static void scan_boardinfo(struct spi_master *master)  </p>
<p>{  </p>
<p>struct boardinfo    *bi;  </p>
<p>    mutex_lock(&amp;board_lock);  </p>
<p>    list_for_each_entry(bi, &amp;board_list, list) {  </p>
<p>struct spi_board_info   *chip = bi-&gt;board_info;  </p>
<p>        unsigned        n;  </p>
<p>for (n = bi-&gt;n_board_info; n &gt; 0; n–, chip++) {  </p>
<p>if (chip-&gt;bus_num != master-&gt;bus_num)  </p>
<p>continue;  </p>
<p>/* NOTE: this relies on spi_new_device to </p>
<p>             * issue diagnostics when given bogus inputs </p>
<p>             */  </p>
<p>/<em>bus_num相等则创建新设备</em>/  </p>
<p>            (void) spi_new_device(master, chip);  </p>
<p>        }  </p>
<p>    }  </p>
<p>    mutex_unlock(&amp;board_lock);  </p>
<p>}  </p>
<p>spi_board_info是板级信息，是在移植时就写好的，并且要将其注册</p>
<p>[cpp] view plain copy</p>
<p>struct spi_board_info {  </p>
<p>char        modalias[32];  /<em>名字</em>/  </p>
<p>const void  *platform_data;  </p>
<p>void        *controller_data;  </p>
<p>int     irq;          /<em>中断号</em>/  </p>
<p>    u32     max_speed_hz; /<em>最高传输速率</em>/  </p>
<p>    u16     bus_num;      /<em>所属的spi_master编号</em>/  </p>
<p>    u16     chip_select;  /<em>片选号</em>/  </p>
<p>    u8      mode;         /<em>传输模式</em>/  </p>
<p>};  </p>
<p>最后一步就是将相应的从设备注册进内核</p>
<p>[cpp] view plain copy</p>
<p>struct spi_device *spi_new_device(struct spi_master *master,  </p>
<p>struct spi_board_info *chip)  </p>
<p>{  </p>
<p>struct spi_device   *proxy;  </p>
<p>int         status;  </p>
<p>/* NOTE:  caller did any chip-&gt;bus_num checks necessary. </p>
<p>     * </p>
<p>     * Also, unless we change the return value convention to use </p>
<p>     * error-or-pointer (not NULL-or-pointer), troubleshootability </p>
<p>     * suggests syslogged diagnostics are best here (ugh). </p>
<p>     */  </p>
<p>/<em>创建SPI_device</em>/  </p>
<p>    proxy = spi_alloc_device(master);  </p>
<p>if (!proxy)  </p>
<p>return NULL;  </p>
<p>    WARN_ON(strlen(chip-&gt;modalias) &gt;= sizeof(proxy-&gt;modalias));  </p>
<p>/<em>初始化</em>/  </p>
<p>    proxy-&gt;chip_select = chip-&gt;chip_select;  </p>
<p>    proxy-&gt;max_speed_hz = chip-&gt;max_speed_hz;  </p>
<p>    proxy-&gt;mode = chip-&gt;mode;  </p>
<p>    proxy-&gt;irq = chip-&gt;irq;  </p>
<p>    strlcpy(proxy-&gt;modalias, chip-&gt;modalias, sizeof(proxy-&gt;modalias));  </p>
<p>    proxy-&gt;dev.platform_data = (void *) chip-&gt;platform_data;  </p>
<p>    proxy-&gt;controller_data = chip-&gt;controller_data;  </p>
<p>    proxy-&gt;controller_state = NULL;  </p>
<p>/<em>将新设备添加进内核</em>/  </p>
<p>    status = spi_add_device(proxy);  </p>
<p>if (status &lt; 0) {  </p>
<p>        spi_dev_put(proxy);  </p>
<p>return NULL;  </p>
<p>    }  </p>
<p>return proxy;  </p>
<p>}  </p>
<p>本节以spidev设备驱动为例，来阐述SPI数据传输的过程。spidev是内核中一个通用的设备驱动，我们注册的从设备都可以使用该驱动，只需在注册时将从设备的modalias字段设置为&quot;spidev&quot;,这样才能和spidev驱动匹配成功。我们要传输的数据有时需要分为一段一段的(比如先发送，后读取，就需要两个字段)，每个字段都被封装成一个transfer,N个transfer可以被添加到message中，作为一个消息包进行传输。当用户发出传输数据的请求时，message并不会立刻传输到从设备，而是由之前定义的transfer()函数将message放入一个等待队列中，这些message会以FIFO的方式有workqueue调度进行传输，这样能够避免SPI从设备同一时间对主SPI控制器的竞争。和之前一样，还是习惯先画一张图来描述数据传输的主要过程。</p>
<p>   在使用spidev设备驱动时，需要先初始化spidev. spidev是以字符设备的形式注册进内核的。</p>
<p>[cpp] view plain copy</p>
<p>static int __init spidev_init(void)  </p>
<p>{  </p>
<p>int status;  </p>
<p>/* Claim our 256 reserved device numbers.  Then register a class </p>
<p>     * that will key udev/mdev to add/remove /dev nodes.  Last, register </p>
<p>     * the driver which manages those device numbers. </p>
<p>     */  </p>
<p>    BUILD_BUG_ON(N_SPI_MINORS &gt; 256);  </p>
<p>/<em>将spidev作为字符设备注册</em>/  </p>
<p>    status = register_chrdev(SPIDEV_MAJOR, &quot;spi&quot;, &amp;spidev_fops);  </p>
<p>if (status &lt; 0)  </p>
<p>return status;  </p>
<p>/<em>创建spidev类</em>/  </p>
<p>    spidev_class = class_create(THIS_MODULE, &quot;spidev&quot;);  </p>
<p>if (IS_ERR(spidev_class)) {  </p>
<p>        unregister_chrdev(SPIDEV_MAJOR, spidev_spi.driver.name);  </p>
<p>return PTR_ERR(spidev_class);  </p>
<p>    }  </p>
<p>/<em>注册spidev的driver,可与modalias字段为&quot;spidev&quot;的spi_device匹配</em>/  </p>
<p>    status = spi_register_driver(&amp;spidev_spi);  </p>
<p>if (status &lt; 0) {  </p>
<p>        class_destroy(spidev_class);  </p>
<p>        unregister_chrdev(SPIDEV_MAJOR, spidev_spi.driver.name);  </p>
<p>    }  </p>
<p>return status;  </p>
<p>}  </p>
<p>与相应的从设备匹配成功后，则调用spidev中的probe函数</p>
<p>[cpp] view plain copy</p>
<p>static int spidev_probe(struct spi_device *spi)  </p>
<p>{  </p>
<p>struct spidev_data  *spidev;  </p>
<p>int         status;  </p>
<p>    unsigned long       minor;  </p>
<p>/* Allocate driver data */  </p>
<p>    spidev = kzalloc(sizeof(*spidev), GFP_KERNEL);  </p>
<p>if (!spidev)  </p>
<p>return -ENOMEM;  </p>
<p>/* Initialize the driver data */  </p>
<p>    spidev-&gt;spi = spi;//设定spi  </p>
<p>    spin_lock_init(&amp;spidev-&gt;spi_lock);  </p>
<p>    mutex_init(&amp;spidev-&gt;buf_lock);  </p>
<p>    INIT_LIST_HEAD(&amp;spidev-&gt;device_entry);  </p>
<p>/* If we can allocate a minor number, hook up this device. </p>
<p>     * Reusing minors is fine so long as udev or mdev is working. </p>
<p>     */  </p>
<p>    mutex_lock(&amp;device_list_lock);  </p>
<p>    minor = find_first_zero_bit(minors, N_SPI_MINORS);//寻找没被占用的次设备号  </p>
<p>if (minor &lt; N_SPI_MINORS) {  </p>
<p>struct device *dev;  </p>
<p>/<em>计算设备号</em>/  </p>
<p>        spidev-&gt;devt = MKDEV(SPIDEV_MAJOR, minor);  </p>
<p>/<em>在spidev_class下创建设备</em>/  </p>
<p>        dev = device_create(spidev_class, &amp;spi-&gt;dev, spidev-&gt;devt,  </p>
<p>                    spidev, &quot;spidev%d.%d&quot;,  </p>
<p>                    spi-&gt;master-&gt;bus_num, spi-&gt;chip_select);  </p>
<p>        status = IS_ERR(dev) ? PTR_ERR(dev) : 0;  </p>
<p>    } else {  </p>
<p>        dev_dbg(&amp;spi-&gt;dev, &quot;no minor number available!\n&quot;);  </p>
<p>        status = -ENODEV;  </p>
<p>    }  </p>
<p>if (status == 0) {  </p>
<p>        set_bit(minor, minors);//将minors的相应位置位，表示该位对应的次设备号已被占用  </p>
<p>        list_add(&amp;spidev-&gt;device_entry, &amp;device_list);//将创建的spidev添加到device_list  </p>
<p>    }  </p>
<p>    mutex_unlock(&amp;device_list_lock);  </p>
<p>if (status == 0)  </p>
<p>        spi_set_drvdata(spi, spidev);  </p>
<p>else  </p>
<p>        kfree(spidev);  </p>
<p>return status;  </p>
<p>}  </p>
<p>然后就可以利用spidev模块提供的接口来实现主从设备之间的数据传输了。我们以spidev_write()函数为例来分析数据传输的过程，实际上spidev_read()和其是差不多的，只是前面的一些步骤不一样，可以参照上图。</p>
<p>[cpp] view plain copy</p>
<p>static ssize_t  </p>
<p>spidev_write(struct file *filp, const char __user *buf,  </p>
<p>size_t count, loff_t *f_pos)  </p>
<p>{  </p>
<p>struct spidev_data  *spidev;  </p>
<p>    ssize_t         status = 0;  </p>
<p>    unsigned long       missing;  </p>
<p>/* chipselect only toggles at start or end of operation */  </p>
<p>if (count &gt; bufsiz)  </p>
<p>return -EMSGSIZE;  </p>
<p>    spidev = filp-&gt;private_data;  </p>
<p>    mutex_lock(&amp;spidev-&gt;buf_lock);  </p>
<p>//将用户要发送的数据拷贝到spidev-&gt;buffer  </p>
<p>    missing = copy_from_user(spidev-&gt;buffer, buf, count);  </p>
<p>if (missing == 0) {//全部拷贝成功，则调用spidev_sysn_write()  </p>
<p>        status = spidev_sync_write(spidev, count);  </p>
<p>    } else  </p>
<p>        status = -EFAULT;  </p>
<p>    mutex_unlock(&amp;spidev-&gt;buf_lock);  </p>
<p>return status;  </p>
<p>}  </p>
<p>[cpp] view plain copy</p>
<p>static inline ssize_t  </p>
<p>spidev_sync_write(struct spidev_data *spidev, size_t len)  </p>
<p>{  </p>
<p>struct spi_transfer t = {//设置传输字段  </p>
<p>            .tx_buf     = spidev-&gt;buffer,  </p>
<p>            .len        = len,  </p>
<p>        };  </p>
<p>struct spi_message   m;//创建message  </p>
<p>    spi_message_init(&amp;m);  </p>
<p>    spi_message_add_tail(&amp;t, &amp;m);//将transfer添加到message中  </p>
<p>return spidev_sync(spidev, &amp;m);  </p>
<p>}  </p>
<p>我们来看看struct spi_transfer和struct spi_message是如何定义的</p>
<p>[cpp] view plain copy</p>
<p>struct spi_transfer {  </p>
<p>/* it’s ok if tx_buf == rx_buf (right?) </p>
<p>     * for MicroWire, one buffer must be null </p>
<p>     * buffers must work with dma_*map_single() calls, unless </p>
<p>     *   spi_message.is_dma_mapped reports a pre-existing mapping </p>
<p>     */  </p>
<p>const void  *tx_buf;//发送缓冲区  </p>
<p>void        *rx_buf;//接收缓冲区  </p>
<p>    unsigned    len;    //传输数据的长度  </p>
<p>    dma_addr_t  tx_dma;  </p>
<p>    dma_addr_t  rx_dma;  </p>
<p>    unsigned    cs_change:1; //该位如果为1，则表示当该transfer传输完后，改变片选信号  </p>
<p>    u8      bits_per_word;//字比特数  </p>
<p>    u16     delay_usecs;  //传输后的延时   </p>
<p>    u32     speed_hz;  //指定的时钟  </p>
<p>struct list_head transfer_list;//用于将该transfer链入message  </p>
<p>};  </p>
<p>[cpp] view plain copy</p>
<p>struct spi_message {  </p>
<p>struct list_head    transfers;//用于链接spi_transfer  </p>
<p>struct spi_device   *spi;      //指向目的从设备  </p>
<p>    unsigned        is_dma_mapped:1;  </p>
<p>/* REVISIT:  we might want a flag affecting the behavior of the </p>
<p>     * last transfer … allowing things like &quot;read 16 bit length L&quot; </p>
<p>     * immediately followed by &quot;read L bytes&quot;.  Basically imposing </p>
<p>     * a specific message scheduling algorithm. </p>
<p>     * </p>
<p>     * Some controller drivers (message-at-a-time queue processing) </p>
<p>     * could provide that as their default scheduling algorithm.  But </p>
<p>     * others (with multi-message pipelines) could need a flag to </p>
<p>     * tell them about such special cases. </p>
<p>     */  </p>
<p>/* completion is reported through a callback */  </p>
<p>void            (*complete)(void *context);//用于异步传输完成时调用的回调函数  </p>
<p>void            *context;                  //回调函数的参数  </p>
<p>    unsigned        actual_length;            //实际传输的长度  </p>
<p>int         status;  </p>
<p>/* for optional use by whatever driver currently owns the </p>
<p>     * spi_message …  between calls to spi_async and then later </p>
<p>     * complete(), that’s the spi_master controller driver. </p>
<p>     */  </p>
<p>struct list_head    queue; //用于将该message链入bitbang等待队列  </p>
<p>void            *state;  </p>
<p>};  </p>
<p>继续跟踪源码，进入spidev_sync(),从这一步开始，read和write就完全一样了</p>
<p>[cpp] view plain copy</p>
<p>&lt;span style=&quot;font-size:12px;&quot;&gt;static ssize_t  </p>
<p>spidev_sync(struct spidev_data *spidev, struct spi_message *message)  </p>
<p>{  </p>
<p>    DECLARE_COMPLETION_ONSTACK(done);  </p>
<p>int status;  </p>
<p>    message-&gt;complete = spidev_complete;//设置回调函数  </p>
<p>    message-&gt;context = &amp;done;              </p>
<p>    spin_lock_irq(&amp;spidev-&gt;spi_lock);  </p>
<p>if (spidev-&gt;spi == NULL)  </p>
<p>        status = -ESHUTDOWN;  </p>
<p>else  </p>
<p>        status = spi_async(spidev-&gt;spi, message);//调用spi核心层的函数spi_async()  </p>
<p>    spin_unlock_irq(&amp;spidev-&gt;spi_lock);  </p>
<p>if (status == 0) {  </p>
<p>        wait_for_completion(&amp;done);  </p>
<p>        status = message-&gt;status;  </p>
<p>if (status == 0)  </p>
<p>            status = message-&gt;actual_length;  </p>
<p>    }  </p>
<p>return status;  </p>
<p>}&lt;/span&gt;  </p>
<p>[cpp] view plain copy</p>
<p>static inline int  </p>
<p>spi_async(struct spi_device *spi, struct spi_message *message)  </p>
<p>{  </p>
<p>    message-&gt;spi = spi;  </p>
<p>/<em>调用master的transfer函数将message放入等待队列</em>/  </p>
<p>return spi-&gt;master-&gt;transfer(spi, message);  </p>
<p>}  </p>
<p>s3c24xx平台下的transfer函数是在bitbang_start()函数中定义的，为bitbang_transfer()</p>
<p>[cpp] view plain copy</p>
<p>int spi_bitbang_transfer(struct spi_device *spi, struct spi_message *m)  </p>
<p>{  </p>
<p>struct spi_bitbang  *bitbang;  </p>
<p>    unsigned long       flags;  </p>
<p>int         status = 0;  </p>
<p>    m-&gt;actual_length = 0;  </p>
<p>    m-&gt;status = -EINPROGRESS;  </p>
<p>    bitbang = spi_master_get_devdata(spi-&gt;master);  </p>
<p>    spin_lock_irqsave(&amp;bitbang-&gt;lock, flags);  </p>
<p>if (!spi-&gt;max_speed_hz)  </p>
<p>        status = -ENETDOWN;  </p>
<p>else {  </p>
<p>        list_add_tail(&amp;m-&gt;queue, &amp;bitbang-&gt;queue);//将message添加到bitbang的等待队列  </p>
<p>        queue_work(bitbang-&gt;workqueue, &amp;bitbang-&gt;work);//调度运行work  </p>
<p>    }  </p>
<p>    spin_unlock_irqrestore(&amp;bitbang-&gt;lock, flags);  </p>
<p>return status;  </p>
<p>}  </p>
<p>这里可以看到transfer函数不负责实际的数据传输，而是将message添加到等待队列中。同样在spi_bitbang_start()中，有这样一个定义INIT_WORK(&amp;bitbang-&gt;work, bitbang_work);因此bitbang_work()函数会被调度运行，类似于底半部机制</p>
<p>[cpp] view plain copy</p>
<p>static void bitbang_work(struct work_struct *work)  </p>
<p>{  </p>
<p>struct spi_bitbang  *bitbang =  </p>
<p>        container_of(work, struct spi_bitbang, work);//获取bitbang  </p>
<p>    unsigned long       flags;  </p>
<p>    spin_lock_irqsave(&amp;bitbang-&gt;lock, flags);  </p>
<p>    bitbang-&gt;busy = 1;  </p>
<p>while (!list_empty(&amp;bitbang-&gt;queue)) {//等待队列不为空  </p>
<p>struct spi_message  *m;  </p>
<p>struct spi_device   *spi;  </p>
<p>        unsigned        nsecs;  </p>
<p>struct spi_transfer *t = NULL;  </p>
<p>        unsigned        tmp;  </p>
<p>        unsigned        cs_change;  </p>
<p>int         status;  </p>
<p>int         (*setup_transfer)(struct spi_device *,  </p>
<p>struct spi_transfer *);  </p>
<p>/<em>取出等待队列中的的第一个message</em>/  </p>
<p>        m = container_of(bitbang-&gt;queue.next, struct spi_message,  </p>
<p>                queue);  </p>
<p>        list_del_init(&amp;m-&gt;queue);//将message从队列中删除  </p>
<p>        spin_unlock_irqrestore(&amp;bitbang-&gt;lock, flags);  </p>
<p>/* FIXME this is made-up … the correct value is known to </p>
<p>         * word-at-a-time bitbang code, and presumably chipselect() </p>
<p>         * should enforce these requirements too? </p>
<p>         */  </p>
<p>        nsecs = 100;  </p>
<p>        spi = m-&gt;spi;  </p>
<p>        tmp = 0;  </p>
<p>        cs_change = 1;  </p>
<p>        status = 0;  </p>
<p>        setup_transfer = NULL;  </p>
<p>/<em>遍历message中的所有传输字段,逐一进行传输</em>/  </p>
<p>        list_for_each_entry (t, &amp;m-&gt;transfers, transfer_list) {  </p>
<p>/* override or restore speed and wordsize */  </p>
<p>if (t-&gt;speed_hz || t-&gt;bits_per_word) {  </p>
<p>                setup_transfer = bitbang-&gt;setup_transfer;  </p>
<p>if (!setup_transfer) {  </p>
<p>                    status = -ENOPROTOOPT;  </p>
<p>break;  </p>
<p>                }  </p>
<p>            }  </p>
<p>/<em>调用setup_transfer根据transfer中的信息进行时钟、字比特数的设定</em>/  </p>
<p>if (setup_transfer) {  </p>
<p>                status = setup_transfer(spi, t);  </p>
<p>if (status &lt; 0)  </p>
<p>break;  </p>
<p>            }  </p>
<p>/* set up default clock polarity, and activate chip; </p>
<p>             * this implicitly updates clock and spi modes as </p>
<p>             * previously recorded for this device via setup(). </p>
<p>             * (and also deselects any other chip that might be </p>
<p>             * selected …) </p>
<p>             */  </p>
<p>if (cs_change) {//使能外设的片选  </p>
<p>                bitbang-&gt;chipselect(spi, BITBANG_CS_ACTIVE);  </p>
<p>                ndelay(nsecs);  </p>
<p>            }  </p>
<p>            cs_change = t-&gt;cs_change;//这里确定进行了这个字段的传输后是否要改变片选状态  </p>
<p>if (!t-&gt;tx_buf &amp;&amp; !t-&gt;rx_buf &amp;&amp; t-&gt;len) {  </p>
<p>                status = -EINVAL;  </p>
<p>break;  </p>
<p>            }  </p>
<p>/* transfer data.  the lower level code handles any </p>
<p>             * new dma mappings it needs. our caller always gave </p>
<p>             * us dma-safe buffers. </p>
<p>             */  </p>
<p>if (t-&gt;len) {  </p>
<p>/* REVISIT dma API still needs a designated </p>
<p>                 * DMA_ADDR_INVALID; ~0 might be better. </p>
<p>                 */  </p>
<p>if (!m-&gt;is_dma_mapped)  </p>
<p>                    t-&gt;rx_dma = t-&gt;tx_dma = 0;  </p>
<p>/<em>调用针对于平台的传输函数txrx_bufs</em>/  </p>
<p>                status = bitbang-&gt;txrx_bufs(spi, t);  </p>
<p>            }  </p>
<p>if (status &gt; 0)  </p>
<p>                m-&gt;actual_length += status;  </p>
<p>if (status != t-&gt;len) {  </p>
<p>/* always report some kind of error */  </p>
<p>if (status &gt;= 0)  </p>
<p>                    status = -EREMOTEIO;  </p>
<p>break;  </p>
<p>            }  </p>
<p>            status = 0;  </p>
<p>/* protocol tweaks before next transfer */  </p>
<p>/<em>如果要求在传输完一个字段后进行delay,则进行delay</em>/  </p>
<p>if (t-&gt;delay_usecs)  </p>
<p>                udelay(t-&gt;delay_usecs);  </p>
<p>if (!cs_change)  </p>
<p>continue;  </p>
<p>/<em>最后一个字段传输完毕了，则跳出循环</em>/  </p>
<p>if (t-&gt;transfer_list.next == &amp;m-&gt;transfers)  </p>
<p>break;  </p>
<p>/* sometimes a short mid-message deselect of the chip </p>
<p>             * may be needed to terminate a mode or command </p>
<p>             */  </p>
<p>            ndelay(nsecs);  </p>
<p>            bitbang-&gt;chipselect(spi, BITBANG_CS_INACTIVE);  </p>
<p>            ndelay(nsecs);  </p>
<p>        }  </p>
<p>        m-&gt;status = status;  </p>
<p>        m-&gt;complete(m-&gt;context);  </p>
<p>/* restore speed and wordsize */  </p>
<p>if (setup_transfer)  </p>
<p>            setup_transfer(spi, NULL);  </p>
<p>/* normally deactivate chipselect … unless no error and </p>
<p>         * cs_change has hinted that the next message will probably </p>
<p>         * be for this chip too. </p>
<p>         */  </p>
<p>if (!(status == 0 &amp;&amp; cs_change)) {  </p>
<p>            ndelay(nsecs);  </p>
<p>            bitbang-&gt;chipselect(spi, BITBANG_CS_INACTIVE);  </p>
<p>            ndelay(nsecs);  </p>
<p>        }  </p>
<p>        spin_lock_irqsave(&amp;bitbang-&gt;lock, flags);  </p>
<p>    }  </p>
<p>    bitbang-&gt;busy = 0;  </p>
<p>    spin_unlock_irqrestore(&amp;bitbang-&gt;lock, flags);  </p>
<p>}  </p>
<p>只要bitbang-&gt;queue等待队列不为空，就表示相应的SPI主控制器上还有传输任务没有完成，因此bitbang_work()会被不断地调度执行。 bitbang_work()中的工作主要是两个循环，外循环遍历等待队列中的message,内循环遍历message中的transfer,在bitbang_work()中，传输总是以transfer为单位的。当选定了一个transfer后，便会调用transfer_txrx()函数，进行实际的数据传输，显然这个函数是针对于平台的SPI控制器而实现的，在s3c24xx平台中，该函数为s3c24xx_spi_txrx();</p>
<p>[cpp] view plain copy</p>
<p>static int s3c24xx_spi_txrx(struct spi_device *spi, struct spi_transfer *t)  </p>
<p>{  </p>
<p>struct s3c24xx_spi *hw = to_hw(spi);  </p>
<p>    dev_dbg(&amp;spi-&gt;dev, &quot;txrx: tx %p, rx %p, len %d\n&quot;,  </p>
<p>        t-&gt;tx_buf, t-&gt;rx_buf, t-&gt;len);  </p>
<p>    hw-&gt;tx = t-&gt;tx_buf;//获取发送缓冲区  </p>
<p>    hw-&gt;rx = t-&gt;rx_buf;//获取读取缓存区  </p>
<p>    hw-&gt;len = t-&gt;len;  //获取数据长度  </p>
<p>    hw-&gt;count = 0;  </p>
<p>    init_completion(&amp;hw-&gt;done);//初始化完成量  </p>
<p>/* send the first byte */  </p>
<p>/<em>只发送第一个字节，其他的在中断中发送(读取)</em>/  </p>
<p>    writeb(hw_txbyte(hw, 0), hw-&gt;regs + S3C2410_SPTDAT);  </p>
<p>    wait_for_completion(&amp;hw-&gt;done);  </p>
<p>return hw-&gt;count;  </p>
<p>}  </p>
<p>[cpp] view plain copy</p>
<p>static inline unsigned int hw_txbyte(struct s3c24xx_spi *hw, int count)  </p>
<p>{  </p>
<p>/*如果tx不为空，也就是说当前是从主机向从机发送数据，则直接将tx[count]发送过去， </p>
<p>      如果tx为空，也就是说当前是从从机向主机发送数据，则向从机写入0*/  </p>
<p>return hw-&gt;tx ? hw-&gt;tx[count] : 0;  </p>
<p>}  </p>
<p>负责SPI数据传输的中断函数：</p>
<p>[cpp] view plain copy</p>
<p>static irqreturn_t s3c24xx_spi_irq(int irq, void *dev)  </p>
<p>{  </p>
<p>struct s3c24xx_spi *hw = dev;  </p>
<p>    unsigned int spsta = readb(hw-&gt;regs + S3C2410_SPSTA);  </p>
<p>    unsigned int count = hw-&gt;count;  </p>
<p>/<em>冲突检测</em>/  </p>
<p>if (spsta &amp; S3C2410_SPSTA_DCOL) {  </p>
<p>        dev_dbg(hw-&gt;dev, &quot;data-collision\n&quot;);  </p>
<p>        complete(&amp;hw-&gt;done);  </p>
<p>goto irq_done;  </p>
<p>    }  </p>
<p>/<em>设备忙检测</em>/  </p>
<p>if (!(spsta &amp; S3C2410_SPSTA_READY)) {  </p>
<p>        dev_dbg(hw-&gt;dev, &quot;spi not ready for tx?\n&quot;);  </p>
<p>        complete(&amp;hw-&gt;done);  </p>
<p>goto irq_done;  </p>
<p>    }  </p>
<p>    hw-&gt;count++;  </p>
<p>if (hw-&gt;rx)//读取数据到缓冲区  </p>
<p>        hw-&gt;rx[count] = readb(hw-&gt;regs + S3C2410_SPRDAT);  </p>
<p>    count++;  </p>
<p>if (count &lt; hw-&gt;len)//向从机写入数据  </p>
<p>        writeb(hw_txbyte(hw, count), hw-&gt;regs + S3C2410_SPTDAT);  </p>
<p>else//count == len，一个字段发送完成，唤醒完成量  </p>
<p>        complete(&amp;hw-&gt;done);  </p>
<p> irq_done:  </p>
<p>return IRQ_HANDLED;  </p>
<p>}  </p>
<p>这里可以看到一点，即使tx为空，也就是说用户申请的是从从设备读取数据，也要不断地向从设备写入数据，只不过写入从设备的是无效数据(0)，这样做得目的是为了维持SPI总线上的时钟。至此，SPI框架已分析完毕。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>MCC(移动国家码)和 MNC(移动网络码)</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/MCC(%E7%A7%BB%E5%8A%A8%E5%9B%BD%E5%AE%B6%E7%A0%81)%E5%92%8C%20MNC(%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E7%A0%81)/</url>
    <content><![CDATA[<p>MCC(移动国家码)和 MNC(移动网络码)</p>
<p>国际移动用户识别码（IMSI） international mobile subscriber identity 国际上为唯一识别一个移动用户所分配的号码。　　</p>
<p>    从技术上讲，IMSI可以彻底解决国际漫游问题。但是由于北美目前仍有大量的AMPS系统使用MIN号码，且北美的MDN和MIN采用相同的编号，系统已经无法更改，所以目前国际漫游暂时还是以MIN为主。其中以O和1打头的MIN资源称为IRM(International Roaming MIN)，由IFAST (International Forum on ANSI-41 Standards Technology)统一管理。目前联通申请的IRM资源以09打头。可以看出，随着用户的增长，用于国际漫游的MIN资源将很快耗尽，全球统一采用IMSI标识用户势在必行。</p>
<p>    结构组合</p>
<p>    IMSI共有15位，其结构如下：MCC+MNC+MSIN ，（MNC+MSIN=NMSI）</p>
<p>    MCC：Mobile Country Code，移动国家码，MCC的资源由国际电联（ITU）统一分配和管理，唯一识别移动用户所属的国家，共3位，中国为460;　　</p>
<p>    MNC:Mobile Network Code，移动网络码，共2位，中国移动TD系统使用00，中国联通GSM系统使用01，中国移动GSM系统使用02，中国电信CDMA系统使用03，一个典型的IMSI号码为460030912121001</p>
<p>    MSIN:Mobile Subscriber Identification Number共有10位，其结构如下：09+M0M1M2M3+ABCD　其中的M0M1M2M3和MDN号码中的H0H1H2H3可存在对应关系，ABCD四位为自由分配。可以看出IMSI在MSIN号码前加了MCC即NMSI，可以区别出每个用户的来自的国家，因此可以实现国际漫游。在同一个国家内，如果有多个移动网络运营商，可以通过MNC来进行区别。</p>
<p>MCC(3位)+MNC(2位)</p>
<p>20201,    &quot;Cosmote&quot;,          &quot;GR&quot;</p>
<p>20205,    &quot;Vodafone GR&quot;,      &quot;GR&quot; <br>20210,    &quot;TELESTET&quot;,         &quot;GR&quot; <br>20404,    &quot;Vodafone NL&quot;,      &quot;NL&quot; <br>20408,    &quot;KPN&quot;,              &quot;NL&quot; <br>20412,    &quot;O2 - NL&quot;,          &quot;NL&quot; <br>20416,    &quot;Ben&quot;,              &quot;NL&quot; <br>20420,    &quot;dutchtone&quot;,        &quot;NL&quot; <br>20601,    &quot;Proximus&quot;,         &quot;BE&quot; <br>20610,    &quot;Mobistar&quot;,         &quot;BE&quot; <br>20620,    &quot;Orange&quot;,           &quot;BE&quot; <br>20801,    &quot;Orange&quot;,           &quot;FR&quot; 法国 <br>20810,    &quot;SFR&quot;,              &quot;FR&quot; <br>20820,    &quot;BOUYGTEL&quot;,         &quot;FR&quot; <br>21303,    &quot;Mobiland&quot;,         &quot;AD&quot; <br>21401,    &quot;Vodafone E&quot;,       &quot;ES&quot; <br>21402,    &quot;MoviStar&quot;,         &quot;ES&quot; <br>21403,    &quot;AMENA&quot;,            &quot;ES&quot; <br>21404,    &quot;Xfera&quot;,            &quot;ES&quot; <br>21407,    &quot;MoviStar&quot;,         &quot;ES&quot; <br>21601,    &quot;Pannon GSM&quot;,       &quot;HU&quot; <br>21630,    &quot;Westel&quot;,           &quot;HU&quot; <br>21670,    &quot;Vodafone&quot;,         &quot;HU&quot; <br>21803,    &quot;ERONET&quot;,           &quot;BA&quot; <br>21805,    &quot;Mobilna Srpska&quot;,   &quot;BA&quot; <br>21890,    &quot;GSM BiH&quot;,          &quot;BA&quot; <br>21901,    &quot;CRONET&quot;,           &quot;HR&quot; <br>21910,    &quot;VIP&quot;,              &quot;HR&quot; <br>22001,    &quot;MOBTEL&quot;,           &quot;YU&quot; <br>22002,    &quot;ProMonte&quot;,         &quot;YU&quot; <br>22003,    &quot;Telekom Srbija&quot;,   &quot;YU&quot; <br>22004,    &quot;MONET&quot;,            &quot;YU&quot; <br>22201,    &quot;TIM&quot;,              &quot;IT&quot; <br>22210,    &quot;Vodafone IT&quot;,      &quot;IT&quot; <br>22288,    &quot;WIND&quot;,             &quot;IT&quot; <br>22298,    &quot;Blu SpA&quot;,          &quot;IT&quot; <br>22601,    &quot;CONNEX&quot;,           &quot;RO&quot; <br>22603,    &quot;Cosmorom&quot;,         &quot;RO&quot; <br>22610,    &quot;dialog&quot;,           &quot;RO&quot; <br>22801,    &quot;Swiss GSM&quot;,        &quot;CH&quot; <br>22802,    &quot;sunrise&quot;,          &quot;CH&quot; <br>22803,    &quot;Orange&quot;,           &quot;CH&quot; <br>23001,    &quot;PAEGAS&quot;,           &quot;CZ&quot; <br>23002,    &quot;EUROTEL&quot;,          &quot;CZ&quot; <br>23003,    &quot;OSKAR&quot;,            &quot;CZ&quot; <br>23101,    &quot;GLOBTEL&quot;,          &quot;SK&quot; <br>23102,    &quot;EUROTEL&quot;,          &quot;SK&quot; <br>23201,    &quot;A1&quot;,               &quot;AT&quot; <br>23203,    &quot;T-Mobile&quot;,         &quot;AT&quot; <br>23205,    &quot;ONE&quot;,              &quot;AT&quot; <br>23207,    &quot;tele.ring&quot;,        &quot;AT&quot; <br>23410,    &quot;O2 - UK&quot;,          &quot;GB&quot; <br>23415,    &quot;Vodafone&quot;,         &quot;GB&quot; <br>23430,    &quot;T-Mobile UK&quot;,      &quot;GB&quot; <br>23431,    &quot;T-Mobile UK&quot;,      &quot;GB&quot; <br>23432,    &quot;T-Mobile UK&quot;,      &quot;GB&quot; <br>23433,    &quot;Orange&quot;,           &quot;GB&quot; <br>23450,    &quot;JT GSM&quot;,           &quot;GB&quot; <br>23455,    &quot;GUERNSEY TEL&quot;,     &quot;GB&quot; <br>23458,    &quot;MANX&quot;,             &quot;GB&quot; <br>23801,    &quot;TDK-MOBIL&quot;,        &quot;DK&quot; <br>23802,    &quot;SONOFON&quot;,          &quot;DK&quot; <br>23820,    &quot;Telia&quot;,            &quot;DK&quot; <br>23830,    &quot;Orange&quot;,           &quot;DK&quot; <br>24001,    &quot;Telia S&quot;,          &quot;SE&quot; <br>24007,    &quot;IQ&quot;,               &quot;SE&quot; <br>24008,    &quot;Vodafone&quot;,         &quot;SE&quot; <br>24201,    &quot;TELENOR&quot;,          &quot;NO&quot; <br>24202,    &quot;NetCom&quot;,           &quot;NO&quot; <br>24403,    &quot;Telia&quot;,            &quot;FI&quot; <br>24405,    &quot;RADIOLINJA&quot;,       &quot;FI&quot; <br>24409,    &quot;FINNET&quot;,           &quot;FI&quot; <br>24412,    &quot;2G&quot;,               &quot;FI&quot; <br>24414,    &quot;AMT&quot;,              &quot;FI&quot; <br>24491,    &quot;SONERA&quot;,           &quot;FI&quot; <br>24601,    &quot;OMNITEL&quot;,          &quot;LT&quot; <br>24602,    &quot;Bite GSM&quot;,         &quot;LT&quot; <br>24603,    &quot;TELE2&quot;,            &quot;LT&quot; <br>24701,    &quot;LMT GSM&quot;,          &quot;LV&quot; <br>24702,    &quot;BALTCOM&quot;,          &quot;LV&quot; <br>24801,    &quot;EMT GSM&quot;,          &quot;EE&quot; <br>24802,    &quot;RLE&quot;,              &quot;EE&quot; <br>24803,    &quot;Q GSM&quot;,            &quot;EE&quot; <br>25001,    &quot;MTS&quot;,              &quot;RU&quot; <br>25002,    &quot;NorthWest GSM&quot;,    &quot;RU&quot; <br>25003,    &quot;NCC&quot;,              &quot;RU&quot; <br>25005,    &quot;SCS&quot;,              &quot;RU&quot; <br>25007,    &quot;SMARTS&quot;,           &quot;RU&quot; <br>25010,    &quot;DTC&quot;,              &quot;RU&quot; <br>25011,    &quot;Orensot&quot;,          &quot;RU&quot; <br>25012,    &quot;Far East&quot;,         &quot;RU&quot; <br>25013,    &quot;Kuban GSM&quot;,        &quot;RU&quot; <br>25016,    &quot;NTC&quot;,              &quot;RU&quot; <br>25017,    &quot;Ermak RMS&quot;,        &quot;RU&quot; <br>25028,    &quot;EXTEL&quot;,            &quot;RU&quot; <br>25039,    &quot;Uraltel&quot;,          &quot;RU&quot; <br>25044,    &quot;NC-GSM&quot;,           &quot;RU&quot; <br>25091,    &quot;Sonic Duo&quot;,        &quot;RU&quot; <br>25092,    &quot;Primtel&quot;,          &quot;RU&quot; <br>25093,    &quot;JSC Telecom XXI&quot;,  &quot;RU&quot; <br>25099,    &quot;Bee Line&quot;,         &quot;RU&quot; <br>25501,    &quot;UMC&quot;,              &quot;UA&quot; <br>25502,    &quot;WellCOM&quot;,          &quot;UA&quot; <br>25503,    &quot;Kyivstar&quot;,         &quot;UA&quot; <br>25505,    &quot;Golden Telecom&quot;,   &quot;UA&quot; <br>25701,    &quot;VELCOM&quot;,           &quot;BY&quot; <br>25901,    &quot;VOXTEL&quot;,           &quot;MD&quot; <br>25902,    &quot;MOLDCELL&quot;,         &quot;MD&quot; <br>26001,    &quot;Plus GSM&quot;,         &quot;PL&quot; <br>26002,    &quot;Era GSM&quot;,          &quot;PL&quot; <br>26003,    &quot;IDEA&quot;,             &quot;PL&quot; <br>26201,    &quot;T-Mobile&quot;,         &quot;DE&quot; <br>26202,    &quot;Vodafone D2&quot;,      &quot;DE&quot; <br>26203,    &quot;E-Plus&quot;,           &quot;DE&quot; <br>26207,    &quot;O2 - DE&quot;,          &quot;DE&quot; <br>26213,    &quot;Mobilcom&quot;,         &quot;DE&quot; <br>26601,    &quot;GIBTEL&quot;,           &quot;GI&quot; <br>26801,    &quot;Vodafone&quot;,         &quot;PT&quot; <br>26803,    &quot;OPTIMUS&quot;,          &quot;PT&quot; <br>26806,    &quot;TMN&quot;,              &quot;PT&quot; <br>27001,    &quot;LUXGSM&quot;,           &quot;LU&quot; <br>27077,    &quot;TANGO&quot;,            &quot;LU&quot; <br>27201,    &quot;Vodafone IRL&quot;,     &quot;IE&quot; <br>27202,    &quot;O2 - IRL&quot;,         &quot;IE&quot; <br>27203,    &quot;METEOR&quot;,           &quot;IE&quot; <br>27401,    &quot;SIMINN&quot;,           &quot;IS&quot; <br>27402,    &quot;TAL&quot;,              &quot;IS&quot; <br>27404,    &quot;Viking&quot;,           &quot;IS&quot; <br>27601,    &quot;AMC&quot;,              &quot;AL&quot; <br>27602,    &quot;Vodafone&quot;,         &quot;AL&quot; <br>27801,    &quot;Vodafone Malta&quot;,   &quot;MT&quot; <br>27821,    &quot;go mobile&quot;,        &quot;MT&quot; <br>28001,    &quot;CYTAGSM&quot;,          &quot;CY&quot; <br>28201,    &quot;GEOCELL&quot;,          &quot;GE&quot; <br>28202,    &quot;Magti GSM&quot;,        &quot;GE&quot; <br>28203,    &quot;GEO 03&quot;,           &quot;GE&quot; <br>28301,    &quot;ARMGSM&quot;,           &quot;AM&quot; <br>28401,    &quot;M-TEL GSM&quot;,        &quot;BG&quot; <br>28601,    &quot;TURKCELL&quot;,         &quot;TR&quot; <br>28602,    &quot;TELSIM&quot;,           &quot;TR&quot; <br>28603,    &quot;ARIA&quot;,             &quot;TR&quot; <br>28604,    &quot;AYCELL&quot;,           &quot;TR&quot; <br>28801,    &quot;FT GSM&quot;,           &quot;FO&quot; <br>29001,    &quot;TELE Greenland&quot;,   &quot;GR&quot; <br>29340,    &quot;SI.MOBIL&quot;,         &quot;SI&quot; <br>29341,    &quot;MOBITEL&quot;,          &quot;SI&quot; <br>29401,    &quot;MOBIMAK&quot;,          &quot;MK&quot; <br>29501,    &quot;TELECOM&quot;,          &quot;LI&quot; <br>29502,    &quot;MONTEL&quot;,           &quot;LI&quot; <br>29505,    &quot;FL1&quot;,              &quot;LI&quot; <br>29577,    &quot;LI TANGO&quot;,         &quot;LI&quot; <br>30237,    &quot;Microcell&quot;,        &quot;CA&quot; <br>30272,    &quot;Rogers AT&amp;T&quot;,      &quot;CA&quot; <br>31001,    &quot;Cellnet&quot;,          &quot;US&quot;  美国 <br>31011,    &quot;Wireless 2000&quot;,    &quot;US&quot; <br>31015,    &quot;Cingular&quot;,         &quot;US&quot; <br>31016,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31017,    &quot;Cingular&quot;,         &quot;US&quot; <br>31018,    &quot;Cingular&quot;,         &quot;US&quot; <br>31020,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31021,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31022,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31023,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31024,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31025,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31026,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31027,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31031,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31034,    &quot;WestLink&quot;,         &quot;US&quot; <br>31035,    &quot;Carolina&quot;,         &quot;US&quot; <br>31038,    &quot;AT&amp;T Wireless&quot;,    &quot;US&quot; <br>31041,    &quot;Cingular&quot;,         &quot;US&quot; <br>31046,    &quot;TMP Corp&quot;,         &quot;US&quot; <br>31058,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31061,    &quot;Epic Touch&quot;,       &quot;US&quot; <br>31063,    &quot;AmeriLink&quot;,        &quot;US&quot; <br>31064,    &quot;Einstein PCS&quot;,     &quot;US&quot; <br>31066,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31067,    &quot;Wireless 2000&quot;,    &quot;US&quot; <br>31068,    &quot;NPI Wireless&quot;,     &quot;US&quot; <br>31069,    &quot;Conestoga&quot;,        &quot;US&quot; <br>31074,    &quot;Telemetrix&quot;,       &quot;US&quot; <br>31076,    &quot;PTSI&quot;,             &quot;US&quot; <br>31077,    &quot;Iowa Wireless&quot;,    &quot;US&quot; <br>31078,    &quot;Airlink PCS&quot;,      &quot;US&quot; <br>31079,    &quot;PinPoint&quot;,         &quot;US&quot; <br>31080,    &quot;T-Mobile&quot;,         &quot;US&quot; <br>31098,    &quot;AWS&quot;,              &quot;US&quot; <br>31114,    &quot;Sprocket&quot;,         UNKNOWN_COUNTRY_CODE <br>31601,    &quot;Nextel&quot;,           UNKNOWN_COUNTRY_CODE <br>33805,    &quot;Digicel&quot;,          &quot;JM&quot; <br>34001,    &quot;Orange &quot;,          &quot;FW&quot; <br>34020,    &quot;Bouygues&quot;,         &quot;FW&quot; <br>34430,    &quot;APUA PCS&quot;,         &quot;AG&quot; <br>35001,    &quot;Telecom&quot;,          &quot;BM&quot; <br>36251,    &quot;Telcell GSM&quot;,      &quot;AN&quot; <br>36801,    &quot;C_Com&quot;,            &quot;CU&quot; <br>37001,    &quot;Orange&quot;,           &quot;DO&quot; <br>40001,    &quot;AZERCELL GSM&quot;,     &quot;AZ&quot; <br>40002,    &quot;BAKCELL GSM 2000&quot;, &quot;AZ&quot; <br>40101,    &quot;K-MOBILE&quot;,         &quot;KZ&quot; <br>40102,    &quot;K’CELL&quot;,           &quot;KZ&quot; <br>40401,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40402,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40403,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40404,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40405,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40407,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40409,    &quot;Reliance&quot;,         &quot;IN&quot; <br>40410,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40411,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40412,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40413,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40414,    &quot;Spice&quot;,            &quot;IN&quot; <br>40415,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40416,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40418,    &quot;Reliance&quot;,         &quot;IN&quot; <br>40419,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40420,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40421,    &quot;BPL Mobile&quot;,       &quot;IN&quot; <br>40422,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40424,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40427,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40429,    &quot;Aircel&quot;,           &quot;IN&quot; <br>40430,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40431,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40434,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40436,    &quot;Reliance&quot;,         &quot;IN&quot; <br>40437,    &quot;Aircel&quot;,           &quot;IN&quot; <br>40438,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40440,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40441,    &quot;RPG&quot;,              &quot;IN&quot; <br>40443,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40444,    &quot;Spice&quot;,            &quot;IN&quot; <br>40445,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40446,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40449,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40450,    &quot;Reliance&quot;,         &quot;IN&quot; <br>40451,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40452,    &quot;Reliance&quot;,         &quot;IN&quot; <br>40453,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40454,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40455,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40456,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40457,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40458,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40459,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40460,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40462,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40464,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40466,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40467,    &quot;Reliance&quot;,         &quot;IN&quot; <br>40468,    &quot;DOLPHIN&quot;,          &quot;IN&quot; <br>40469,    &quot;MTNL&quot;,             &quot;IN&quot; <br>40470,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40471,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40472,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40473,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40474,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40475,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40476,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40477,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40478,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40479,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40480,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40481,    &quot;Cellone&quot;,          &quot;IN&quot; <br>40482,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40483,    &quot;Reliance&quot;,         &quot;IN&quot; <br>40484,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40485,    &quot;Reliance&quot;,         &quot;IN&quot; <br>40486,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40487,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40488,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40489,    &quot;IDEA&quot;,             &quot;IN&quot; <br>40490,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40492,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40493,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40494,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40495,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40496,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40497,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40498,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40551,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40552,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40553,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40554,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40555,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40556,    &quot;Airtel&quot;,           &quot;IN&quot; <br>40566,    &quot;Hutch&quot;,            &quot;IN&quot; <br>40567,    &quot;Hutch&quot;,            &quot;IN&quot; <br>41001,    &quot;Mobilink&quot;,         &quot;PK&quot; <br>41302,    &quot;DIALOG&quot;,           &quot;LK&quot; <br>41303,    &quot;CELLTEL&quot;,          &quot;LK&quot; <br>41401,    &quot;MM 900&quot;,           &quot;MM&quot; <br>41501,    &quot;Cellis&quot;,           &quot;LB&quot; <br>41503,    &quot;LibanCell&quot;,        &quot;LB&quot; <br>41601,    &quot;Fastlink&quot;,         &quot;JO&quot; <br>41677,    &quot;MobileCom&quot;,        &quot;JO&quot; <br>41702,    &quot;Spacetel&quot;,         &quot;SY&quot; <br>41709,    &quot;MOBILE SYRIA&quot;,     &quot;SY&quot; <br>41902,    &quot;MTCNet&quot;,           &quot;KW&quot; <br>41903,    &quot;WATANIYA&quot;,         &quot;KW&quot; <br>42001,    &quot;Al-Jawal&quot;,         &quot;SA&quot; <br>42007,    &quot;EAE&quot;,              &quot;SA&quot; <br>42102,    &quot;Spacetel&quot;,         &quot;YE&quot; <br>42202,    &quot;OMAN MOBILE&quot;,      &quot;OM&quot; <br>42402,    &quot;ETISALAT&quot;,         &quot;AE&quot; <br>42501,    &quot;Orange&quot;,           &quot;IL&quot; <br>42505,    &quot;JAWWAL&quot;,           &quot;IL&quot; <br>42601,    &quot;MOBILE PLUS&quot;,      &quot;BH&quot; <br>42701,    &quot;QATARNET&quot;,         &quot;QA&quot; <br>42899,    &quot;MobiCom&quot;,          &quot;MN&quot; <br>42901,    &quot;NTC&quot;,              &quot;NP&quot; <br>43211,    &quot;TCI&quot;,              &quot;IR&quot; <br>43214,    &quot;KISH&quot;,             &quot;IR&quot; <br>43401,    &quot;Buztel&quot;,           &quot;UZ&quot; <br>43402,    &quot;Uzmacom&quot;,          &quot;UZ&quot; <br>43404,    &quot;UZB DAEWOO-GSM&quot;,   &quot;UZ&quot; <br>43405,    &quot;Coscom&quot;,           &quot;UZ&quot; <br>43701,    &quot;BITEL&quot;,            &quot;KG&quot; <br>43801,    &quot;BCTI&quot;,             &quot;TM&quot; <br>45201,    &quot;MOBIFONE&quot;,         &quot;VN&quot; <br>45202,    &quot;VINAFONE&quot;,         &quot;VN&quot; <br>45400,    &quot;CSL&quot;,              &quot;HK&quot;  香港电讯 <br>45401,    &quot;NEW WORLD&quot;,        &quot;HK&quot; <br>45402,    &quot;CSL&quot;,              &quot;HK&quot;  香港电讯 <br>45404,    &quot;Orange&quot;,           &quot;HK&quot; <br>45406,    &quot;SMC&quot;,              &quot;HK&quot;  数码通 <br>45410,    &quot;NEW WORLD&quot;,        &quot;HK&quot;  新世界传动网 <br>45412,    &quot;PEOPLES&quot;,          &quot;HK&quot;  万众电话 <br>45416,    &quot;SUNDAY&quot;,           &quot;HK&quot; <br>45418,    &quot;HK TELECOM&quot;,       &quot;HK&quot;  香港电讯 <br>45500,    &quot;SmarTone&quot;,         UNKNOWN_COUNTRY_CODE //macau <br>45501,    &quot;CTMGSM&quot;,           UNKNOWN_COUNTRY_CODE <br>45503,    &quot;HT Macau&quot;,         UNKNOWN_COUNTRY_CODE <br>45601,    &quot;MobiTel&quot;,          &quot;KH&quot; <br>45602,    &quot;SAMART-GSM&quot;,       &quot;KH&quot; <br>45701,    &quot;LAO GSM&quot;,          &quot;LA&quot; <br>46000,    &quot;CHINA MOBILE&quot;,     &quot;CN&quot;  中国移动TD <br>46001,    &quot;CHN-CUGSM&quot;,        &quot;CN&quot;  中国联通 <br>46002,    &quot;CHINA MOBILE&quot;,     &quot;CN&quot;  中国移动GSM </p>
<p>46003,    &quot;CHINA TELECOM&quot;,    &quot;CN&quot;  中国电信CDMA<br>46601,    &quot;Far EasTone&quot;,      &quot;TW&quot;  远传电讯 <br>46606,    &quot;TUNTEX&quot;,           &quot;TW&quot; <br>46668,    &quot;ACeS&quot;,             &quot;TW&quot; <br>46688,    &quot;KGT&quot;,              &quot;TW&quot;  和信电讯 <br>46692,    &quot;Chunghwa&quot;,         &quot;TW&quot;  中华电讯 <br>46693,    &quot;MobiTai&quot;,          &quot;TW&quot;  东信电讯 <br>46697,    &quot;TWN GSM&quot;,          &quot;TW&quot;  台湾大哥大 <br>46699,    &quot;TransAsia&quot;,        &quot;TW&quot;  泛亚电讯 <br>47001,    &quot;GrameemPhone&quot;,     &quot;BD&quot; <br>47002,    &quot;AKTEL&quot;,            &quot;BD&quot; <br>47003,    &quot;ShebaWorld&quot;,       &quot;BD&quot; <br>47019,    &quot;Mobile 2000&quot;,      &quot;BD&quot; <br>47201,    &quot;DHIMOBILE&quot;,        &quot;MV&quot; <br>50212,    &quot;Maxis Mobile&quot;,     &quot;MY&quot; <br>50213,    &quot;TM Touch&quot;,         &quot;MY&quot; <br>50216,    &quot;DiGi&quot;,             &quot;MY&quot; <br>50217,    &quot;ADAM&quot;,             &quot;MY&quot; <br>50219,    &quot;CELCOM&quot;,           &quot;MY&quot; <br>50501,    &quot;MobileNet&quot;,        &quot;AU&quot; <br>50502,    &quot;OPTUS&quot;,            &quot;AU&quot; <br>50503,    &quot;Vodafone&quot;,         &quot;AU&quot; <br>50508,    &quot;One.Tel&quot;,          &quot;AU&quot; <br>51000,    &quot;ACeS&quot;,             &quot;ID&quot; <br>51001,    &quot;SATELINDOCEL&quot;,     &quot;ID&quot; <br>51008,    &quot;LIPPO TEL&quot;,        &quot;ID&quot; <br>51010,    &quot;TELKOMSEL&quot;,        &quot;ID&quot; <br>51011,    &quot;GSM-XL&quot;,           &quot;ID&quot; <br>51021,    &quot;INDOSAT&quot;,          &quot;ID&quot; <br>51501,    &quot;ISLACOM&quot;,          &quot;PH&quot; <br>51502,    &quot;Globe&quot;,            &quot;PH&quot; <br>51503,    &quot;SMART&quot;,            &quot;PH&quot; <br>51505,    &quot;Digitel&quot;,          &quot;PH&quot; <br>51511,    &quot;ACeS&quot;,             &quot;PH&quot; <br>52001,    &quot;AIS GSM&quot;,          &quot;TH&quot; <br>52015,    &quot;ACT Mobile&quot;,       &quot;TH&quot; <br>52018,    &quot;WP-1800&quot;,          &quot;TH&quot; <br>52020,    &quot;ACeS&quot;,             &quot;TH&quot; <br>52023,    &quot;HELLO&quot;,            &quot;TH&quot; <br>52099,    &quot;Orange&quot;,           &quot;TH&quot; <br>52501,    &quot;ST-GSM-SGP&quot;,       &quot;SG&quot; <br>52502,    &quot;ST-GSM1800-SGP&quot;,   &quot;SG&quot; <br>52503,    &quot;M1-GSM-SGP&quot;,       &quot;SG&quot; <br>52504,    &quot;SGP-M1-3GSM&quot;,      &quot;SG&quot; <br>52505,    &quot;STARHUB-SGP&quot;,      &quot;SG&quot; <br>52811,    &quot;BRU TSTCom&quot;,       &quot;BN&quot; <br>53001,    &quot;Vodafone&quot;,         &quot;NZ&quot; <br>53901,    &quot;Tonga Comm.&quot;,      &quot;TO&quot; <br>54100,    &quot;ACeS&quot;,             &quot;VU&quot; <br>54101,    &quot;SMILE&quot;,            &quot;VU&quot; <br>54201,    &quot;Vodafone&quot;,         &quot;FJ&quot; <br>54411,    &quot;Blue Sky&quot;,         &quot;AS&quot; <br>54601,    &quot;MOBILIS&quot;,          &quot;NC&quot; <br>54720,    &quot;VINI&quot;,             &quot;PF&quot; <br>55001,    &quot;FSM&quot;,              &quot;FM&quot; <br>60201,    &quot;MobiNiL&quot;,          &quot;EG&quot; <br>60202,    &quot;CLICK GSM&quot;,        &quot;EG&quot; <br>60301,    &quot;AMN&quot;,              &quot;DZ&quot; <br>60400,    &quot;Meditel&quot;,          &quot;MA&quot; <br>60401,    &quot;IAM&quot;,              &quot;MA&quot; <br>60502,    &quot;TUNICELL&quot;,         &quot;TN&quot; <br>60801,    &quot;ALIZE&quot;,            &quot;SN&quot; <br>60802,    &quot;SENTEL&quot;,           &quot;SN&quot; <br>61001,    &quot;MALITEL&quot;,          &quot;ML&quot; <br>61101,    &quot;MOBILIS&quot;,          &quot;GN&quot; <br>61102,    &quot;LAGUI&quot;,            &quot;GN&quot; <br>61201,    &quot;CORA&quot;,             &quot;CI&quot; <br>61203,    &quot;Ivoiris&quot;,          &quot;CI&quot; <br>61205,    &quot;TELECEL&quot;,          &quot;CI&quot; <br>61302,    &quot;CELTEL&quot;,           &quot;BF&quot; <br>61402,    &quot;CELTEL&quot;,           &quot;NE&quot; <br>61501,    &quot;TOGOCEL&quot;,          &quot;TG&quot; <br>61601,    &quot;LIBERCOM&quot;,         &quot;BJ&quot; <br>61602,    &quot;Telecel Benin&quot;,    &quot;BJ&quot; <br>61603,    &quot;BENINCELL&quot;,        &quot;BJ&quot; <br>61701,    &quot;CELLPLUS&quot;,         &quot;MU&quot; <br>61710,    &quot;EMTEL&quot;,            &quot;MU&quot; <br>61801,    &quot;Omega&quot;,            &quot;LR&quot; <br>62001,    &quot;SPACEFON&quot;,         &quot;GH&quot; <br>62002,    &quot;ONEtouch&quot;,         &quot;GH&quot; <br>62003,    &quot;MOBITEL&quot;,          &quot;GH&quot; <br>62100,    &quot;MTN&quot;,              &quot;NG&quot; <br>62120,    &quot;ECONET&quot;,           &quot;NG&quot; <br>62130,    &quot;MTN&quot;,              &quot;NG&quot; <br>62140,    &quot;NITEL GSM&quot;,        &quot;NG&quot; <br>62201,    &quot;CELTEL&quot;,           &quot;TD&quot; <br>62202,    &quot;LIBERTIS&quot;,         &quot;TD&quot; <br>62401,    &quot;MTN-CAM&quot;,          &quot;CM&quot; <br>62402,    &quot;MOBILIS&quot;,          &quot;CM&quot; <br>62501,    &quot;CPV MOVEL&quot;,        &quot;CV&quot; <br>62801,    &quot;LIBERTIS&quot;,         &quot;GA&quot; <br>62802,    &quot;GO Celtel&quot;,        &quot;GA&quot; <br>62803,    &quot;CELTEL&quot;,           &quot;GA&quot; <br>62901,    &quot;CELTEL&quot;,           &quot;CG&quot; <br>62910,    &quot;LIBERTIS&quot;,         &quot;CG&quot; <br>63001,    &quot;CELLNET&quot;,          &quot;CD&quot; <br>63002,    &quot;CELTEL&quot;,           &quot;CD&quot; <br>63004,    &quot;CELLCO&quot;,           &quot;CD&quot; <br>63089,    &quot;OASIS&quot;,            &quot;CD&quot; <br>63301,    &quot;SEYCEL&quot;,           &quot;SC&quot; <br>63310,    &quot;AIRTEL&quot;,           &quot;SC&quot; <br>63401,    &quot;MobiTel&quot;,          &quot;MZ&quot; <br>63510,    &quot;Rwandacell&quot;,       &quot;RW&quot; <br>63601,    &quot;ETMTN&quot;,            &quot;ET&quot; <br>63701,    &quot;BARAKAAT&quot;,         &quot;SO&quot; <br>63902,    &quot;Safaricom&quot;,        &quot;KE&quot; <br>63903,    &quot;KENCELL&quot;,          &quot;KE&quot; <br>64001,    &quot;TRITEL&quot;,           &quot;TZ&quot; <br>64002,    &quot;MobiTel&quot;,          &quot;TZ&quot; <br>64003,    &quot;ZANTEL&quot;,           &quot;TZ&quot; <br>64004,    &quot;Vodacom&quot;,          &quot;TZ&quot; <br>64005,    &quot;CELTEL&quot;,           &quot;TZ&quot; <br>64101,    &quot;CelTel&quot;,           &quot;UG&quot; <br>64110,    &quot;MTN-UGANDA&quot;,       &quot;UG&quot; <br>64111,    &quot;UTL TELECEL&quot;,      &quot;UG&quot; <br>64201,    &quot;Spacetel&quot;,         &quot;BI&quot; <br>64202,    &quot;SAFARIS&quot;,          &quot;BI&quot; <br>64301,    &quot;mCel&quot;,             UNKNOWN_COUNTRY_CODE <br>64501,    &quot;ZAMCELL&quot;,          UNKNOWN_COUNTRY_CODE <br>64502,    &quot;TELECEL&quot;,          UNKNOWN_COUNTRY_CODE <br>64601,    &quot;Madacom&quot;,          &quot;MG&quot; <br>64602,    &quot;ANTARIS&quot;,          &quot;MG&quot; <br>64700,    &quot;Orange Reunion&quot;,   &quot;RE&quot; <br>64710,    &quot;SFR Reunion&quot;,      &quot;RE&quot; <br>64801,    &quot;NET*ONE&quot;,          &quot;ZW&quot; <br>64803,    &quot;TELECEL&quot;,          &quot;ZW&quot; <br>64804,    &quot;ECONET&quot;,           &quot;ZW&quot; <br>64901,    &quot;MTC&quot;,              &quot;NA&quot; <br>65001,    &quot;CALLPOINT 90&quot;,     &quot;MW&quot; <br>65010,    &quot;CelTel&quot;,           &quot;MW&quot; <br>65101,    &quot;Vodacom&quot;,          &quot;LS&quot; <br>65201,    &quot;MASCOM&quot;,           &quot;BW&quot; <br>65202,    &quot;VISTA&quot;,            &quot;BW&quot; <br>65310,    &quot;SwaziMTN&quot;,         &quot;SZ&quot; <br>65501,    &quot;Vodacom&quot;,          &quot;ZA&quot; <br>65507,    &quot;Cell C (Pty) Ltd&quot;, &quot;ZA&quot; <br>65510,    &quot;MTN&quot;,              &quot;ZA&quot; <br>70601,    &quot;PERSONAL&quot;,         &quot;SV&quot; <br>70602,    &quot;DIGICEL&quot;,          &quot;SV&quot; <br>71610,    &quot;TIM&quot;,              &quot;PE&quot; <br>72207,    &quot;UNIFON&quot;,           &quot;AR&quot; <br>72234,    &quot;Telecom Personal&quot;, &quot;AR&quot; <br>72235,    &quot;PORT-HABLE&quot;,       &quot;AR&quot; <br>72402,    &quot;TIM BRASIL&quot;,       &quot;BR&quot; <br>72403,    &quot;TIM BRASIL&quot;,       &quot;BR&quot; <br>72404,    &quot;TIM BRASIL&quot;,       &quot;BR&quot; <br>72405,    &quot;Claro&quot;,            &quot;BR&quot; <br>72416,    &quot;BrTCel&quot;,           &quot;BR&quot; <br>73001,    &quot;ENTEL PCS&quot;,        &quot;CL&quot; <br>73010,    &quot;ENTEL PCS&quot;,        &quot;CL&quot; <br>73401,    &quot;INFONET&quot;,          &quot;VE&quot; <br>73402,    &quot;DIGITEL&quot;,          &quot;VE&quot; <br>73601,    &quot;NUEVATEL&quot;,         &quot;BO&quot; <br>73602,    &quot;ENTEL&quot;,            &quot;BO&quot; <br>74401,    &quot;VOX&quot;,              &quot;PY&quot; <br>74402,    &quot;PY 02&quot;,            &quot;PY&quot; <br>74601,    &quot;ICMS&quot;,             &quot;SR&quot; <br>90105,    &quot;Thuraya&quot;,          UNKNOWN_COUNTRY_CODE </p>
<p>MCC<br>202, &quot;Greece&quot;,   &quot;GR&quot;, &quot;希腊&quot; <br>204, &quot;Netherlands, The&quot;, &quot;NL&quot;， &quot;荷兰&quot; <br>206, &quot;Belgium&quot;,  &quot;BE&quot;, &quot;比利时&quot; <br>208, &quot;France&quot;,  &quot;FR&quot;, &quot;法国&quot; <br>213, &quot;Andorra&quot;,  &quot;AD&quot;, &quot;安道尔共和国&quot; <br>214, &quot;Spain&quot;,  &quot;ES&quot;, &quot;西班牙&quot; <br>216, &quot;Hungary&quot;,  &quot;HU&quot;, &quot;匈牙利&quot; <br>218, &quot;Bosnia and Herzegovina&quot;, &quot;BA&quot;, &quot;&quot; <br>219, &quot;Croatia&quot;,  &quot;HR&quot;, &quot;克罗地亚&quot; <br>220, &quot;Serbia and Montenegro&quot;, &quot;CS&quot;, &quot;塞尔维亚和黑山&quot; <br>222, &quot;Italy&quot;,  &quot;IT&quot;, &quot;意大利&quot; <br>226, &quot;Romania&quot;,  &quot;RO&quot;, &quot;罗马尼亚&quot; <br>228, &quot;Switzerland&quot;, &quot;CH&quot;, &quot;瑞士&quot; <br>230, &quot;Czech Republic&quot;, &quot;CZ&quot;, &quot;捷克&quot; <br>231, &quot;Slovakia&quot;, &quot;SK&quot;, &quot;斯洛伐克&quot; <br>232, &quot;Austria&quot;,  &quot;AT&quot;, &quot;奥地利&quot; <br>234, &quot;United Kingdom&quot;, &quot;GB&quot;, &quot;英国&quot; <br>238, &quot;Denmark&quot;,  &quot;DK&quot;, &quot;丹麦&quot; <br>240, &quot;Sweden&quot;,  &quot;SE&quot;, &quot;瑞典&quot; <br>242, &quot;Norway&quot;,  &quot;NO&quot;, &quot;挪威&quot; <br>244, &quot;Finland&quot;,  &quot;FI&quot;, &quot;芬兰&quot; <br>246, &quot;Lithuania&quot;, &quot;LT&quot;, &quot;立陶宛&quot; <br>247, &quot;Latvia&quot;,  &quot;LV&quot;, &quot;拉脱维亚&quot; <br>248, &quot;Estonia&quot;,  &quot;EE&quot;, &quot;爱沙尼亚&quot; <br>250, &quot;Russia&quot;,  &quot;RU&quot;, &quot;俄罗斯&quot; <br>255, &quot;Ukraine&quot;,  &quot;UA&quot;, &quot;乌克兰&quot; <br>257, &quot;Belarus&quot;,  &quot;BY&quot;, &quot;&quot; <br>259, &quot;Moldova&quot;,  &quot;MD&quot;, &quot;&quot; <br>260, &quot;Poland&quot;,  &quot;PL&quot;, &quot;波兰&quot; <br>262, &quot;Germany&quot;,  &quot;DE&quot;, &quot;德国&quot; <br>266, &quot;Gibraltar&quot;, &quot;GI&quot;, &quot;直布罗陀&quot; <br>268, &quot;Portugal&quot;, &quot;PT&quot;, &quot;葡萄牙&quot; <br>270, &quot;Luxembourg&quot;, &quot;LU&quot;, &quot;卢森堡&quot; <br>272, &quot;Ireland&quot;,  &quot;IE&quot;, &quot;爱尔兰&quot; <br>274, &quot;Iceland&quot;,  &quot;IS&quot;, &quot;冰岛&quot; <br>276, &quot;Albania&quot;,  &quot;AL&quot;, &quot;阿尔巴尼亚&quot; <br>278, &quot;Malta&quot;,  &quot;MT&quot;, &quot;马耳他&quot; <br>280, &quot;Cyprus&quot;,  &quot;CY&quot;, &quot;塞浦路斯&quot; <br>282, &quot;Georgia&quot;,  &quot;GE&quot;, &quot;乔治亚州&quot; <br>283, &quot;Armenia&quot;,  &quot;AM&quot;, &quot;亚美尼亚&quot; <br>284, &quot;Bulgaria&quot;, &quot;BG&quot;, &quot;保加利亚&quot; <br>286, &quot;Turkey&quot;,  &quot;TR&quot;, &quot;土耳其&quot; <br>288, &quot;Faroe Islands&quot;, &quot;FO&quot;, &quot;&quot; <br>290, &quot;Greenland&quot;, &quot;GL&quot;, &quot;格陵兰岛&quot; <br>293, &quot;Slovenia&quot;, &quot;SI&quot;, &quot;斯洛文尼亚&quot; <br>294, &quot;Macedonia, Former Yugoslav Republic of&quot;,&quot;MK&quot;, &quot;&quot; <br>295, &quot;Liechtenstein&quot;, &quot;LI&quot;, &quot;&quot; <br>302, &quot;Canada&quot;,  &quot;CA&quot;, &quot;加拿大&quot; <br>310, &quot;United States&quot;, &quot;US&quot;, &quot;美国&quot; <br>334, &quot;Mexico&quot;,  &quot;MX&quot;, &quot;墨西哥&quot; <br>338, &quot;Jamaica&quot;,  &quot;JM&quot;, &quot;牙买加&quot; <br>340, &quot;French West Indies&quot;, &quot;FW&quot;, &quot;&quot; <br>342, &quot;Barbados&quot;, &quot;BB&quot;, &quot;&quot; <br>344, &quot;Antigua and Barbuda&quot;, &quot;AG&quot;, &quot;&quot; <br>346, &quot;Cayman Islands&quot;, &quot;KY&quot;, &quot;&quot; <br>350, &quot;Bermuda&quot;,  &quot;BM&quot;, &quot;百慕大&quot; <br>352, &quot;Grenada&quot;,  &quot;GD&quot;, &quot;&quot; <br>362, &quot;Netherlands Antillies&quot;, &quot;AN&quot;, &quot;&quot; <br>363, &quot;Aruba&quot;,  &quot;AW&quot;, &quot;&quot; <br>368, &quot;Cuba&quot;,  &quot;CU&quot;, &quot;古巴&quot; <br>370, &quot;Dominican Republic&quot;, &quot;DO&quot;, &quot;&quot; <br>374, &quot;Trinidad and Tobago&quot;, &quot;TT&quot;, &quot;&quot; <br>400, &quot;Azerbaijan&quot;, &quot;AZ&quot;, &quot;&quot; <br>401, &quot;Kazakhstan&quot;, &quot;KZ&quot;, &quot;哈萨克&quot; <br>402, &quot;Bhutan&quot;,  &quot;BT&quot;, &quot;不丹&quot; <br>404, &quot;India&quot;,  &quot;IN&quot;, &quot;印度&quot; <br>410, &quot;Pakistan&quot;, &quot;PK&quot;, &quot;巴基斯坦&quot; <br>412, &quot;Afghanistan&quot;, &quot;AF&quot;, &quot;阿富汗&quot; <br>413, &quot;Sri Lanka&quot;, &quot;LK&quot;, &quot;&quot; <br>414, &quot;Myanmar&quot;,  &quot;MM&quot;, &quot;缅甸&quot; <br>415, &quot;Lebanon&quot;,  &quot;LB&quot;, &quot;黎巴嫩&quot; <br>416, &quot;Jordan&quot;,  &quot;JO&quot;, &quot;约旦&quot; <br>417, &quot;Syria&quot;,  &quot;SY&quot;, &quot;叙利亚&quot; <br>418, &quot;Iraq&quot;,  &quot;IQ&quot;, &quot;伊拉克&quot; <br>419, &quot;Kuwait&quot;,  &quot;KW&quot;, &quot;科威特&quot; <br>420, &quot;Saudi Arabia&quot;, &quot;SA&quot;, &quot;&quot; <br>421, &quot;Yemen&quot;,  &quot;YE&quot;, &quot;也门&quot; <br>422, &quot;Oman&quot;,  &quot;OM&quot;, &quot;阿曼&quot; <br>424, &quot;United Arab Emirates&quot;,&quot;AE&quot;, &quot;阿拉伯联合酋长国&quot; <br>425, &quot;Israel&quot;,  &quot;IL&quot;, &quot;以色列&quot; <br>426, &quot;Bahrain&quot;,  &quot;BH&quot;, &quot;巴林岛&quot; <br>427, &quot;Qatar&quot;,  &quot;QA&quot;, &quot;卡塔尔&quot; <br>428, &quot;Mongolia&quot;, &quot;MN&quot;, &quot;蒙古&quot; <br>429, &quot;Nepal&quot;,  &quot;NP&quot;, &quot;尼泊尔&quot; <br>432, &quot;Iran&quot;,  &quot;IR&quot;, &quot;伊朗&quot; <br>434, &quot;Uzbekistan&quot;, &quot;UZ&quot;, &quot;乌兹别克斯坦&quot; <br>437, &quot;Kyrgyzstan&quot;, &quot;KG&quot;, &quot;&quot; <br>438, &quot;Turkmenistan&quot;,&quot;TM&quot;, &quot;土库曼斯坦&quot; <br>452, &quot;Vietnam&quot;,  &quot;VN&quot;, &quot;越南&quot; <br>454, &quot;Hong Kong&quot;, &quot;HK&quot;, &quot;香港&quot; <br>456, &quot;Cambodia&quot;, &quot;KH&quot;, &quot;柬埔寨&quot; <br>457, &quot;Laos&quot;,  &quot;LA&quot;, &quot;老挝&quot; <br>460, &quot;China&quot;,  &quot;CN&quot;, &quot;中国&quot; <br>466, &quot;Taiwan&quot;,  &quot;TW&quot;, &quot;台湾&quot; <br>467, &quot;North Korea&quot;, &quot;KP&quot;, &quot;南韩&quot; <br>470, &quot;Bangladesh&quot;, &quot;BD&quot;, &quot;孟加拉国&quot; <br>472, &quot;Maldives&quot;, &quot;MV&quot;, &quot;马尔代夫&quot; <br>502, &quot;Malaysia&quot;, &quot;MY&quot;, &quot;马来西亚&quot; <br>505, &quot;Australia&quot;, &quot;AU&quot;, &quot;澳大利亚&quot; <br>510, &quot;Indonesia&quot;, &quot;ID&quot;, &quot;印尼&quot; <br>515, &quot;Philippines&quot;, &quot;PH&quot;, &quot;菲律宾&quot; <br>520, &quot;Thailand&quot;, &quot;TH&quot;, &quot;泰国&quot; <br>525, &quot;Singapore&quot;, &quot;SG&quot;, &quot;新加坡&quot; <br>528, &quot;Brunei&quot;,  &quot;BN&quot;, &quot;汶莱&quot; <br>530, &quot;New Zealand&quot;, &quot;NZ&quot;, &quot;&quot; <br>539, &quot;Tonga&quot;,  &quot;TO&quot;, &quot;东加&quot; <br>541, &quot;Vanuatu&quot;,  &quot;VU&quot;, &quot;&quot; <br>542, &quot;Fiji Islands&quot;,&quot;FJ&quot;, &quot;&quot; <br>544, &quot;American Samoa&quot;, &quot;AS&quot;, &quot;萨摩亚&quot;  <br>546, &quot;New Caledonia&quot;,&quot;NC&quot;, &quot;&quot; <br>547, &quot;French Polynesia&quot;,&quot;PF&quot;, &quot;波利尼西亚&quot;  <br>550, &quot;Micronesia&quot;, &quot;FM&quot;, &quot;&quot; <br>602, &quot;Egypt&quot;,  &quot;EG&quot;, &quot;埃及&quot; <br>603, &quot;Algeria&quot;,  &quot;DZ&quot;, &quot;阿尔及利亚&quot; <br>604, &quot;Morocco&quot;,  &quot;MA&quot;, &quot;摩洛哥&quot; <br>605, &quot;Tunisia&quot;,  &quot;TN&quot;, &quot;突尼斯&quot; <br>607, &quot;Gambia, The&quot;, &quot;GM&quot;, &quot;冈比亚&quot; <br>608, &quot;Senegal&quot;,  &quot;SN&quot;, &quot;塞内加尔&quot; <br>609, &quot;Mauritania&quot;, &quot;MR&quot;, &quot;&quot; <br>610, &quot;Mali&quot;,  &quot;ML&quot;, &quot;马里&quot; <br>611, &quot;Guinea&quot;,  &quot;GN&quot;, &quot;几内亚&quot; <br>612, &quot;C?te d’Ivoire&quot;, &quot;CI&quot;, &quot;&quot; <br>613, &quot;Burkina Faso&quot;, &quot;BF&quot;, &quot;&quot; <br>614, &quot;Niger&quot;,  &quot;NE&quot;, &quot;&quot; <br>615, &quot;Togo&quot;,  &quot;TG&quot;, &quot;多哥&quot; <br>616, &quot;Benin&quot;,  &quot;BJ&quot;, &quot;贝南&quot; <br>617, &quot;Mauritius&quot;, &quot;MU&quot;, &quot;毛里求斯&quot; <br>618, &quot;Liberia&quot;,  &quot;LR&quot;, &quot;利比里亚&quot; <br>620, &quot;Ghana&quot;,  &quot;GH&quot;, &quot;加纳&quot; <br>621, &quot;Nigeria&quot;,  &quot;NG&quot;, &quot;尼日利亚&quot; <br>622, &quot;Chad&quot;,  &quot;TD&quot;, &quot;乍得&quot; <br>623, &quot;Central African Republic&quot;,&quot;CF&quot;, &quot;中非&quot; <br>624, &quot;Cameroon&quot;, &quot;CM&quot;, &quot;喀麦隆&quot; <br>625, &quot;Cape Verde&quot;, &quot;CV&quot;, &quot;&quot; <br>626, &quot;S?o Tomé and Príncipe&quot;, &quot;ST&quot;, &quot;&quot; <br>627, &quot;Equatorial Guinea&quot;, &quot;GQ&quot;, &quot;&quot; <br>628, &quot;Gabon&quot;,  &quot;GA&quot;, &quot;加蓬&quot; <br>629, &quot;Congo&quot;,  &quot;CG&quot;, &quot;刚果&quot; <br>630, &quot;Congo (DRC)&quot;, &quot;CD&quot;, &quot;刚果&quot; <br>631, &quot;Angola&quot;,  &quot;AO&quot;, &quot;安哥拉&quot; <br>633, &quot;Seychelles&quot;, &quot;SC&quot;, &quot;&quot; <br>634, &quot;Mozambique&quot;, &quot;MZ&quot;, &quot;莫桑比克&quot; <br>634, &quot;Sudan&quot;,  &quot;SD&quot;, &quot;苏丹&quot; <br>635, &quot;Rwanda&quot;,  &quot;RW&quot;, &quot;卢安达&quot; <br>636, &quot;Ethiopia&quot;, &quot;ET&quot;, &quot;埃塞俄比亚&quot; <br>637, &quot;Somalia&quot;,  &quot;SO&quot;, &quot;索马里&quot; <br>639, &quot;Kenya&quot;,  &quot;KE&quot;, &quot;肯尼亚&quot; <br>640, &quot;Tanzania&quot;, &quot;TZ&quot;, &quot;坦桑尼亚&quot; <br>641, &quot;Uganda&quot;,  &quot;UG&quot;, &quot;乌干达&quot; <br>642, &quot;Burundi&quot;,  &quot;BI&quot;, &quot;布隆迪&quot; <br>646, &quot;Madagascar&quot;, &quot;MG&quot;, &quot;马达加斯加&quot; <br>647, &quot;Reunion&quot;,  &quot;RE&quot;, &quot;&quot; <br>648, &quot;Zimbabwe&quot;, &quot;ZW&quot;, &quot;津巴布韦&quot; <br>649, &quot;Namibia&quot;,  &quot;NA&quot;, &quot;纳米比亚&quot; <br>650, &quot;Malawi&quot;,  &quot;MW&quot;, &quot;马拉维&quot; <br>651, &quot;Lesotho&quot;,  &quot;LS&quot;, &quot;&quot; <br>652, &quot;Botswana&quot;, &quot;BW&quot;, &quot;&quot; <br>653, &quot;Swaziland&quot;, &quot;SZ&quot;, &quot;&quot; <br>654, &quot;Zambia&quot;,  &quot;ZM&quot;, &quot;赞比亚&quot; <br>655, &quot;South Africa&quot;,&quot;ZA&quot;, &quot;南非&quot; <br>702, &quot;Belize&quot;,  &quot;BZ&quot;, &quot;&quot; <br>706, &quot;El Salvador&quot;, &quot;SV&quot;, &quot;&quot; <br>710, &quot;Nicaragua&quot;, &quot;NI&quot;, &quot;尼加拉瓜&quot; <br>712, &quot;Costa Rica&quot;, &quot;CR&quot;, &quot;&quot; <br>716, &quot;Peru&quot;,  &quot;PE&quot;, &quot;秘鲁&quot; <br>722, &quot;Argentina&quot;, &quot;AR&quot;, &quot;阿根廷&quot; <br>724, &quot;Brazil&quot;,  &quot;BR&quot;, &quot;巴西&quot; <br>730, &quot;Chile&quot;,  &quot;CL&quot;, &quot;智利&quot; <br>734, &quot;Venezuela&quot;, &quot;VE&quot;, &quot;委内瑞拉&quot; <br>736, &quot;Bolivia&quot;,  &quot;BO&quot;, &quot;玻利维亚&quot; <br>744, &quot;Paraguay&quot;, &quot;PY&quot;, &quot;巴拉圭&quot; <br>746, &quot;Suriname&quot;, &quot;SR&quot;, &quot;&quot;  </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>SDP协议介绍</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>SDP协议介绍</p>
<p>一、SDP协议介绍</p>
<p>SDP 完全是一种会话描述格式 ― 它不属于传输协议 ― 它只使用不同的适当的传输协议，包括会话通知协议（SAP）、会话初始协议（SIP）、实时流协议（RTSP）、MIME 扩展协议的电子邮件以及超文本传输协议（HTTP）。SDP协议是也是基于文本的协议，这样就能保证协议的可扩展性比较强，这样就使其具有广泛的应用范围。SDP 不支持会话内容或媒体编码的协商，所以在流媒体中只用来描述媒体信息。媒体协商这一块要用RTSP来实现．</p>
<p>二、SDP协议格式</p>
<p>SDP描述由许多文本行组成，文本行的格式为&lt;类型&gt;=&lt;值&gt;，&lt;类型&gt;是一个字母，&lt;值&gt;是结构化的文本串，其格式依&lt;类型&gt;而定。</p>
<p>＜type＞=&lt;value&gt;[CRLF]</p>
<p>常见的fields有：</p>
<p>三、SDP协议例子：</p>
<p>下面是一个helix 流媒体服务器的RTSP协议中的SDP协议：</p>
<p>v=0 //SDP version</p>
<p>// o field定义的源的一些信息。其格式为：o=&lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt;</p>
<p>o=- 1271659412 1271659412 IN IP4 10.56.136.37 s=&lt;No title&gt;</p>
<p>i=&lt;No author&gt; &lt;No copyright&gt;  //session的信息</p>
<p>c=IN IP4 0.0.0.0 //connect 的信息，分别描述了：网络协议，地址的类型，连接地址。</p>
<p>c=IN IP4 0.0.0.0</p>
<p>t=0 0 //时间信息，分别表示开始的时间和结束的时间，一般在流媒体的直播的时移中见的比较多。</p>
<p>a=SdpplinVersion:1610641560 //描述性的信息</p>
<p>a=StreamCount:integer;2 //用来描述媒体流的信息，表示有两个媒体流。integer表示信息的格式为整数。</p>
<p>a=control:*</p>
<p>a=DefaultLicenseValue:integer;0 //License信息</p>
<p>a=FileType:string;&quot;MPEG4&quot; ////用来描述媒体流的信息说明当前协商的文件是mpeg4格式的文件</p>
<p>a=LicenseKey:string;&quot;license.Summary.Datatypes.RealMPEG4.Enabled&quot;</p>
<p>a=range:npt=0-72.080000  //用来表示媒体流的长度</p>
<p>m=audio 0 RTP/AVP 96 //做为媒体描述信息的重要组成部分描述了媒体信息的详细内容：表示session的audio是通过RTP来格式传送的，其payload值为96传送的端口还没有定。</p>
<p>b=as:24 //audio 的bitrate</p>
<p>b=RR:1800</p>
<p>b=RS:600</p>
<p>a=control:streamid=1  //通过媒体流1来发送音频</p>
<p>a=range:npt=0-72.080000 //说明媒体流的长度。</p>
<p>a=length:npt=72.080000</p>
<p>a=rtpmap:96 MPEG4-GENERIC/32000/2 //rtpmap的信息，表示音频为AAC的其sample为32000</p>
<p>a=fmtp:96 profile-level-id=15;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3;config=1210 //config为AAC的详细格式信息</p>
<p>a=mimetype:string;&quot;audio/MPEG4-GENERIC&quot;</p>
<p>a=Helix-Adaptation-Support:1</p>
<p>a=AvgBitRate:integer;48000</p>
<p>a=HasOutOfOrderTS:integer;1</p>
<p>a=MaxBitRate:integer;48000</p>
<p>a=Preroll:integer;1000</p>
<p>a=OpaqueData:buffer;&quot;A4CAgCIAAAAEgICAFEAVABgAAAC7gAAAu4AFgICAAhKIBoCAgAEC&quot;</p>
<p>a=StreamName:string;&quot;Audio Track&quot;</p>
<p>下面是video的信息基本和audio的信息相对称，这里就不再说了。</p>
<p>m=video 0 RTP/AVP 97</p>
<p>b=as:150</p>
<p>b=RR:11250</p>
<p>b=RS:3750</p>
<p>a=control:streamid=2</p>
<p>a=range:npt=0-72.080000</p>
<p>a=length:npt=72.080000</p>
<p>a=rtpmap:97 MP4V-ES/2500</p>
<p>a=fmtp:97 profile-level-id=1;</p>
<p>a=mimetype:string;&quot;video/MP4V-ES&quot;</p>
<p>a=Helix-Adaptation-Support:1</p>
<p>a=AvgBitRate:integer;300000</p>
<p>a=HasOutOfOrderTS:integer;1</p>
<p>a=Height:integer;240 //影片的长度</p>
<p>a=MaxBitRate:integer;300000</p>
<p>a=MaxPacketSize:integer;1400</p>
<p>a=Preroll:integer;1000</p>
<p>a=Width:integer;320  //影片的宽度</p>
<p>a=OpaqueData:buffer;&quot;AzcAAB8ELyARAbd0AAST4AAEk+AFIAAAAbDzAAABtQ7gQMDPAAABAAAAASAAhED6KFAg8KIfBgEC&quot;</p>
<p>a=StreamName:string;&quot;Video Track&quot;</p>
<p>SDP协议学习笔记</p>
<p>在SIP协议的包含的内容是SDP时，应该把Content-Type设置成application/sdp。</p>
<p>SDP:Session Description Protocol</p>
<p>SDP格式:<br>      Session description<br>         v=  (protocol version)<br>         o=  (owner/creator and session identifier)<br>         s=  (session name)<br>         i=* (session information)<br>         u=* (URI of description)<br>         e=* (email address)<br>         p=* (phone number)<br>         c=* (connection information - not required if included in all media)<br>         b=* (zero or more bandwidth information lines)<br>         One or more time descriptions (&quot;t=&quot; and &quot;r=&quot; lines, see below)<br>         z=* (time zone adjustments)<br>         k=* (encryption key)<br>         a=* (zero or more session attribute lines)<br>         Zero or more media descriptions</p>
<p>      Time description<br>         t=  (time the session is active)<br>         r=* (zero or more repeat times)</p>
<p>      Media description, if present<br>         m=  (media name and transport address)<br>         i=* (media title)<br>         c=* (connection information - optional if included at<br>              session-level)<br>         b=* (zero or more bandwidth information lines)<br>         k=* (encryption key)<br>         a=* (zero or more media attribute lines)</p>
<p>以上带&quot;*&quot;号的是可选的,其余的是必须的。一般顺序也按照上面的顺序来排列。</p>
<p>a=*是sdp协议扩展属性定义，除上面以外的，分解时其它的都可以扔掉。<br>a=charset属性指定协议使用的字符集。一般的是ISO-10646。</p>
<p>示例：<br>v=&lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt;<br>   其中：nettype是IN,代表internet,addrtype是IP4或IP6。unicast-address任务创建计算机的地址。<br>   整个这个属性，是唯一表示一个任务。</p>
<p>e=123@126.com 或 p=+1 616 555-6011<br>对于一个任务只能两者之中的一个，表示会议控制者的联系方式。邮件地址可以是[email]<a href="mailto:&#106;&#46;&#x64;&#111;&#101;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#106;&#46;&#x64;&#111;&#101;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a>[/email] (Jane Doe)形式，括号里面的是描述联系人的名称，或者Jane Doe &lt;[email]<a href="mailto:&#106;&#46;&#x64;&#x6f;&#101;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#106;&#46;&#x64;&#x6f;&#101;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a>[/email]&gt;，前面的是联系人的名称。</p>
<p>c=&lt;nettype&gt; &lt;addrtype&gt; &lt;connection-address&gt;<br>这个连接数据，可以是传话级别的连接数据，或者是单独一个媒体数据的连接数据。在是多播时，connection-address就该是一个多播组地址，当是单播时，connection-address就该是一个单播地址。对于addrtype是IP4的情况下，connection-address不仅包含IP地址，并且还要包含a time to live value(TTL 0-255)，如：c=IN IP4 224.2.36.42/128，IP6没有这个TTL值。还允许象这样的&lt;base multicast address&gt;[/&lt;ttl&gt;]/&lt;number of addresses&gt;格式的connection-address。如：c=IN IP4 224.2.1.1/127/3等同于包含c=IN IP4 224.2.1.1/127, c=IN IP4 224.2.1.2/127, c=IN IP4 224.2.1.3/127三行内容。</p>
<p>b=&lt;bwtype&gt;:&lt;bandwidth&gt; bwtype可以是CT或AS，CT方式是设置整个会议的带宽，AS是设置单个会话的带宽。缺省带宽是千比特每秒。<br>t=&lt;start-time&gt; &lt;stop-time&gt;，这个可以有行，指定多个不规则时间段，如果是规则的时间段，则r=属性可以使用。start-time和stop- time都遵从NTP(Network Time Protocol),是以秒为单位，自从1900以来的时间。要转换为UNIX时间，减去2208988800。如果stop-time设置为0,则会话没有时间限制。如果start-time也设置为0，则会话被认为是永久的。</p>
<p>r=&lt;repeat-interval&gt; &lt;active duration&gt; &lt;offsets from start-time&gt;重复次数在时间表示里面可以如下表示：<br>      d - days (86400 seconds)<br>      h - hours (3600 seconds)<br>      m - minutes (60 seconds)<br>      s - seconds (allowed for completeness)<br>z=&lt;adjustment time&gt; &lt;offset&gt; &lt;adjustment time&gt; &lt;offset&gt; ….<br>k=&lt;method&gt;<br>k=&lt;method&gt;:&lt;encryption key&gt;<br>a=&lt;attribute&gt;<br>a=&lt;attribute&gt;:&lt;value&gt;<br>m=&lt;media&gt; &lt;port&gt; &lt;proto&gt; &lt;fmt&gt; …<br>m=&lt;media&gt; &lt;port&gt;/&lt;number of ports&gt; &lt;proto&gt; &lt;fmt&gt; …<br>其中：&lt;media&gt;可以是，&quot;audio&quot;,&quot;video&quot;, &quot;text&quot;, &quot;application&quot; and &quot;message&quot;。&lt;port&gt;是媒体传送的端口号，它依赖于c=和&lt;proto&gt;。&lt;proto&gt; 可以是，udp，RTP/AVP和RTP/SAVP。</p>
<p>a=cat:&lt;category&gt;分类，根据分类接收者隔离相应的会话<br>a=keywds:&lt;keywords&gt;关键字，根据关键字隔离相应的会话<br>a=tool:&lt;name and version of tool&gt;创建任务描述的工具的名称及版本号<br>a=ptime:&lt;packet time&gt;在一个包里面的以毫秒为单位的媒体长度<br>a=maxptime:&lt;maximum packet time&gt;以毫秒为单位，能够压缩进一个包的媒体量。<br>a=rtpmap:&lt;payload type&gt; &lt;encoding name&gt;/&lt;clock rate&gt; [/&lt;encoding   parameters&gt;]<br>a=recvonly<br>a=sendrecv<br>a=sendonly<br>a=inactive，<br>a=orient:&lt;orientation&gt;其可能的值，&quot;portrait&quot;, &quot;landscape&quot; and &quot;seascape&quot; 。<br>a=type:&lt;conference type&gt;,建议值是，&quot;broadcast&quot;, &quot;meeting&quot;, &quot;moderated&quot;, &quot;test&quot; and &quot;H332&quot;。<br>a=charset:&lt;character set&gt;<br>a=sdplang:&lt;language tag&gt;指定会话或者是媒体级别使用的语言<br>a=framerate:&lt;frame rate&gt;设置最大视频帧速率<br>a=quality:&lt;quality&gt;值是0-10<br>a=fmtp:&lt;format&gt; &lt;format specific parameters&gt;</p>
<p>在SIP协议的包含的内容是SDP时，应该把Content-Type设置成application/sdp。</p>
<p>SDP（Session Description Protocol）模型介绍</p>
<p>如果有哪里描述有误，或不准确，欢迎各位网友指正，可以及时讨论并修正。</p>
<p>情态动词术语解释：</p>
<p>&quot;MUST&quot;，必须、一定要；</p>
<p>&quot;MUST NOT&quot;，禁止；</p>
<p>&quot;REQUIRED&quot;，需要；</p>
<p>&quot;SHALL&quot;、&quot;SHOULD&quot;，应该；</p>
<p>&quot;SHALL NOT&quot;、&quot;SHOULD NOT&quot;，不应该；</p>
<p>&quot;RECOMMENDED&quot;，推荐；</p>
<p>&quot;MAY&quot;，可以</p>
<p>以上情态动词术语可参考RFC2119[3]，这些动词要求我们在产品实现时，需要遵守或灵活变更约束。</p>
<p>术语</p>
<p>媒体流（Media Stream），或称为媒体类型（Media Type），即我们通常所说的音频流、视频流等，所有通信实体要进行媒体交互之前都必须进行媒体注的协商</p>
<p>媒体格式（Media Format），每种媒体流都有不同的编码格式，像音频有G711、G712编码，视频有H261、H264等，像现在所谓的高清视频采用是720P、1070P等。</p>
<p>单一会话（Unitcast Session）</p>
<p>多会话（Multicast Sessions）</p>
<p>单一媒体流（Unitcast Streams）</p>
<p>多媒体流（Multicast Streams）</p>
<p>SDP（Session Description Protocol）</p>
<p>SDP（会话描述协议），用于两个会话实体之间的媒体协商，并达成一致，属信令语言族，采用文本（字符）描述形式。rfc3264协议[1]主要概述一个请求/响应模型（offer/answer，以下叙述采用英文），包括请求/响应的实体和不同阶段的操作行为，如初始协商过程和重协商过程，并简单介绍消息中各种参数的含义。具体各个参数的详细说明见rfc2327协议[2]。本文主要参照3264协议，大部分为直译，附加自己经验和理解。</p>
<p>图1 SDP模型组网图</p>
<p>1实体、消息</p>
<p>Offer/Answer模型包括两个实体，一个是请求主体Offerer，另外一个是响应实体Answerer，两个实体只是在逻辑上进行区分，在一定条件可以转换。例如，手机A发起媒体协商请求，那么A就是Offerer，反之如果A为接收请求则为Offerer。</p>
<p>Offerer发给Answerer的请求消息称为请求offer，内容包括媒体流类型、各个媒体流使用的编码集，以及将要用于接收媒体流的IP和端口。</p>
<p>Answerer收到offer之后，回复给Offerer的消息称为响应，内容包括要使用的媒体编码，是否接收该媒体流以及告诉Offerer其用于接收媒体流的IP和端口。</p>
<p>2 SDP各个参数简单介绍</p>
<p>下面示例摘自3264协议[1]</p>
<p>v=0                                                                              </p>
<p>o=carol 28908764872 28908764872 IN IP4 100.3.6.6        //会话ID号和版本</p>
<p>s=-                                     //用于传递会话主题</p>
<p>t=0 0                                   //会话时间，一般由其它信令消息控制，因此填0</p>
<p>c=IN IP4 192.0.2.4              //描述本端将用于传输媒体流的IP</p>
<p>m=audio 0 RTP/AVP 0 1 3     //媒体类型 端口号 本端媒体使用的编码标识（Payload）集</p>
<p>a=rtpmap:0 PCMU/8000 //rtpmap映射表，各种编码详细描述参数，包括使用带宽（bandwidth）</p>
<p>a=rtpmap:1 1016/8000</p>
<p>a=rtpmap:3 GSM/8000</p>
<p>a=sendonly     //说明本端媒体流的方向，取值包括sendonly/recvonly/sendrecv/inactive</p>
<p>a=ptime:20                           //说明媒体流打包时长</p>
<p>m=video 0 RTP/AVP 31 34</p>
<p>a=rtpmap:31 H261/90000</p>
<p>a=rtpmap:34 H263/90000</p>
<p>3 实体行为、操作过程</p>
<p>3.1 初始协商的Offer请求</p>
<p>实体A &lt;-&gt; 实体B，实体首先发起Offer请求，内容如2节所示，对于作何一个媒体流/媒体通道，这时实体A必须：</p>
<p>a.       如果媒体流方向标为recvonly/sendrecv，即a=recvonly或a=sendrecv，则A必须（MUST）准备好在这个IP和端口上接收实体B发来的媒体流；</p>
<p>b.       如果媒体流方向标为sendonly/inactive，即a=recvonly或a=sendrecv，则A不需要进行准备。</p>
<p>3.2 Answer响应</p>
<p>实体B收到A的请求offer后，根据自身支持的媒体类型和编码策略，回复响应。</p>
<p>a. 如果实体B回复的响应中的媒体流数量和顺序必须（MUST）和请求offer一致，以便实体A进行甄别和决策。即m行的数量和顺序必须一致，B不能（MUST NOT）擅自增加或删除媒体流。如果B不支持某个媒体流，可以在对应的端口置0，但不能不带这个m行描述。</p>
<p>b. 对于某种媒体，实体B必须（MUST）从请求offer中选出A支持且自己也支持的该媒体的编码标识集，并且可以（MAY）附带自己支持的其它类型编码。</p>
<p>c. 对于响应消息中各个媒体的方向：</p>
<p>如果请求某媒体流的方向为sendonly，那么响应中对应媒体的方向必须为recvonly；</p>
<p>如果请求某媒体流的方向为recvonly，那么响应中对应媒体的方向必须为sendonly；</p>
<p>如果请求某媒体流的方向为sendrecv，那么响应中对应媒体的方向可以为sendrecv/sendonly/recvonly/inactive中的一种；</p>
<p>如果请求某媒体流的方向为inactive，那么响应中对应媒体的方向必须为inactive；</p>
<p>d.       响应answer里提供IP和端口，指示Offerer本端期望用于接收媒体流的IP和端口，一旦响应发出之后，Offerer必须（MUST）准备好在这个IP和端口上接收实体A发来的媒体流。</p>
<p>e.       如果请求offer中带了ptime（媒体流打包间隔）的a行或带宽的a行，则响应answer也应该（SHOULD）相应的携带。</p>
<p>f.        实体B Offerer应该（SHOULD）使用实体A比较期望的编码生成媒体流发送。一般来说对于m行，如m=video 0 RTP/AVP 31 34，排充越靠前的编码表示该实体越希望以这个编码作为载体，这里示例31(H261)，34（H263）中H261为A更期望使用的编码类型。同理，当实体A收到响应answer后也是这样理解的。</p>
<p>3.3 实体收到响应后的处理</p>
<p>当实体A收到B回复的响应后，可以（MAY）开始发送媒体流，如果媒体流方向为sendonly/sendrecv，</p>
<p>a.       必须（MUST）使用answer列举的媒体类型/编码生成媒体发送；</p>
<p>b.       应该（SHOULD）使用answer中的ptime和bandwidth来打包发送媒体流；</p>
<p>c.       可以（MAY）立即停止监听端口，该端口为offer支持answer不支持的媒体所使用的端口。</p>
<p>4 修改媒体流（会话）</p>
<p>修改媒体流的offer-answer操作必须基于之前协商的媒体形式（音频、视频等），不能（MUST NOT）对已有媒体流进行删减。</p>
<p>4.1 删除媒体流</p>
<p>如果实体认定新的会话不支持之前媒商的某个媒体，新的offer只须对这种媒体所在m行的端口置0，但不能不描述这种媒体，即不带对应m行。当answerer收到响应之后，处理同初始协商一样。</p>
<p>4.2 增加媒体流</p>
<p>如果实体打算新增媒体流，在offer里只须加上描述即可或者占用之前端口被置0的媒体流，即用新的媒体描述m行替换旧的。当answerer收到offer请求后，发现有新增媒体描述，或者过于端口被置0的媒体行被新的媒体描述替换，即知道当前为新增媒体流，处理同初始协商。</p>
<p>4.3 修改媒体流</p>
<p>修改媒体注主要是针对初始协商结果，如果有变更即进入修改流程处理，可能的变更包括IP地址、端口，媒体格式（编码），媒体类型（音、视频），媒体属性（ptime，bandwidth，媒体流方向变更等）。</p>
<p>参考文档</p>
<p>[1] RFC3264，An Offer/Answer Model with the Session Description Protocol (SDP)</p>
<p>[2] RFC2327，SDP: Session Description Protocol</p>
<p>[3] RFC2119，Key words for use in RFCs to Indicate Requirement Levels</p>
<p>SDP: Session Description Protocol(会话描述协议)<br>(RFC2327)</p>
<ol>
<li><p>概述<br>SDP也是MMUSIC工作组的一个产品,在MBONE内容中用得很多。其目的就是在媒体会话中，传递媒体流信息，允许会话描述的接收者去参与会话。 SDP基本上在internet上工作。他定义了绘画描述的统一格式,但并不定义多播地址的分配和SDP消息的传输,也不支持媒体编码方案的协商,这些功能均由下层传送协议完成.典型的会话传送协议包括:SAP(Session Announcement Protocol 会话公告协议),SIP,RTSP,HTTP,和使用MIME的E-Mail.(注意:对SAP只能包含一个会话描述,其它会话传诵协议的SDP可包含多个绘画描述)<br>SDP包括以下一些方面：<br>1） 会话的名称和目的<br>2） 会话存活时间<br>3） 包含在会话中的媒体信息，包括：<br>媒体类型(video, audio, etc)<br>传输协议(RTP/UDP/IP, H.320, etc)<br>媒体格式(H.261 video, MPEG video, etc)<br>多播或远端（单播）地址和端口<br>4） 为接收媒体而需的信息(addresses, ports, formats and so on)<br>5） 使用的带宽信息<br>6） 可信赖的接洽信息（Contact information）</p>
</li>
<li><p>协议<br>Session description //格式及举例<br>v=   (protocol version) //v=0<br>       o=   (owner/creator and session identifier). //o=&lt;用户名&gt;&lt;会话id&gt;&lt;版本&gt;&lt;网络类<br>//型&gt;&lt;地址类型&gt;&lt;地址&gt;<br>//o=sname 1234567890 0987654321 IN<br>//IP4 126.15.64.3<br>       s=   (session name) //会话名<br>       i=* (session information) //会话信息<br>       u=* (URI of description) //u=<a href="http://www.zte.com.cn/staff/sdp.ps">http://www.zte.com.cn/staff/sdp.ps</a><br>       e=* (email address) //e=zte@isi.edu(general text如：王生)<br>//或e=Mr. Wang&lt;[email]<a href="mailto:&#x77;&#x61;&#110;&#x67;&#64;&#122;&#116;&#101;&#x2e;&#99;&#x6f;&#109;">&#x77;&#x61;&#110;&#x67;&#64;&#122;&#116;&#101;&#x2e;&#99;&#x6f;&#109;</a>[/email]&gt;<br>       p=* (phone number) //p=+86-0755-26773000-7110(wang)<br>//or p=+1 617 253 6011<br>       c=* (connection information -如已经包含在所有媒体中则该行不需要)<br>//c=&lt;网络类型&gt;&lt;地址信息&gt;&lt;连接地址&gt;<br>//多点会议包括TTL<br>//连接地址: &lt;base multicast<br>//address&gt;/&lt;ttl&gt;/&lt;number of addresses&gt;<br>//c=IN IP4 224.2.13.23/127<br>//c=IN IP4 224.2.1.1/127/3<br>       b=* (bandwidth information) //b=&lt;修改量（CT Conference Total<br>//IAS Application-specific Max)&gt;:&lt;带宽<br>//值（kb/s）&gt;<br>//b=CT:120<br>One or more time descriptions (see below)<br>       z=* (time zone adjustments) //时区调整<br>       k=* (encryption key) //k=&lt;方法&gt;:&lt;密钥&gt;或k=&lt;方法&gt;<br>       a=* (zero or more session attribute lines) //a=&lt;属性&gt;   或a=&lt;属性&gt;:&lt;值&gt;<br>Zero or more media descriptions (see below)<br>各行严格按顺序,其中:<br>时间描述：<br>       t=   (time the session is active) //&lt;开始时间&gt;&lt;结束时间&gt;，单位秒，十<br>//进制NTP<br>//t=2873397468 2873404969<br>       r=* (zero or more repeat times) //&lt;重复时间&gt;&lt;活动持续时间<br>//以开始时刻为参考的偏移列表&gt;单位秒<br>//r=604800 3666 90000 或写成<br>//r=7d 1h 0 25h<br>媒体描述：<br>       m=   (media name and transport address) //m=&lt;媒体&gt;&lt;端口&gt;&lt;传送&gt;&lt;格式列表&gt;<br>//m=audio 49170 RTP/AVP 0 3<br>//协议为RTP，剖面为AVP<br>//参考rtp-parameters.txt<br>       i=* (media title媒体称呼) //<br>       c=* (connection information – 如已经包含在会话级描述则为可选)<br>       b=* (bandwidth information) //同c<br>       k=* (encryption key) //会话级为摸认值,同c<br>       a=* (zero or more media attribute lines) //两种形式：(也同c)（见后说明）<br>//a=&lt;attribute&gt;如：<br>// a=recvonly<br>//a=&lt;attribute&gt;:&lt;value&gt;<br>注：v,o,s,t,m为必须的,其他项为可选。<br>如果SDP语法分析器不能识别某一类型(Type),则整个描述丢失;<br>如果”a=”的某属性值不理解,则予以丢失<br>整个协议区分大小写<br>“=”两侧不允许有空格<br>会话级的描述就是媒体级描述的缺省值<br>所有均格式为&lt;type&gt;=&lt;value&gt;</p>
</li>
<li><p>SDP在IP电话中的使用<br>SDP用于构建INVITE和200 OK响应消息的消息体,供主\被叫用户交换媒体信息.</p>
</li>
<li><p>媒体流的配置</p>
</li>
</ol>
<ol>
<li>主被叫的媒体描述必须完全对应:主被叫的第n个媒体流(“m=”)对应,都包含”a=rtpmap”.这样的目的是易于适应静态净荷类型到动态净荷类型的转换.</li>
<li>如被叫不想接收主叫提出的某个媒体流则在响应中设置该媒体流的端口号为0.并且,必须返回对应的媒体流行.</li>
</ol>
<ol start="2">
<li>单播SDP值的设定</li>
</ol>
<ol>
<li>对于只发媒体流,端口号无意义,应设为0.</li>
<li>每个媒体流的净载荷类型例表应传送两个信息:能接受/发送的编译码,和用以标识这些编译码的RTP净载荷类型号.</li>
<li>如对于某一媒体流,主/被叫没有公共的媒体格式,被叫仍然要求返回媒体流的”m=”行,端口好为0,同时,不列净载荷类型.</li>
<li>如果所有媒体流均无公共的媒体格式,则被叫回送400响应(坏请求),并加入304警告头字段(无媒体类型)</li>
</ol>
<ol start="3">
<li>多播操作</li>
</ol>
<ol>
<li>接受和发送的多播地址是相同的</li>
<li>被叫不允许改变媒体流的只发,只收,或收/发特性</li>
<li>如果被叫不支持多播,则回送400响应和330警告(多播不可用)</li>
</ol>
<ol start="4">
<li>延时媒体流<br>由于主叫可能实际上是一个和其他协议(如H.323)互同的协议的网关,与S其互同的协议要求呼叫建立后进行媒体协商.这样,主叫可以先发不带SDP的INVITE,呼叫建立后可以通过ACK或重新发一个INVITE请求修改被叫的会话描述(SDP).</li>
<li>媒体流保持<br>如果要求对方进入HOLD,即暂时停止发送一个或多个媒体流,这可以用Re-INVITE,其会话描述和原来的请求或响应中的描述相同,只是,”c=”行中的保持媒体流的地址置为”0.0.0.0”,还有就是Re_INVITE中的Cseq得递增.</li>
<li>对应于SIP中有3个实体字段:</li>
</ol>
<ol>
<li>Content-Type: 指明消息体类型,有两种:<br>i. Application/sdp:表示是SDP会话描述<br>ii. Text/html:表示是普通文本或HTML格式的描述</li>
<li>Content-Encoding:补充说明消息体类型,使用户可以采用压缩编码编辑消息体</li>
<li>Content-Length:给出消息体的字节数</li>
</ol>
<ol start="7">
<li>SDP各type的详细解释:<br>协议版本 v = SDP版本目前为0,没有子版本<br>会话源 o = &lt;用户名&gt;用户在发起主机上登录名,如果主机不支持用户标识的概念,则为”-”<br>&lt;会话id&gt;一般为数字串,其分配由创建工具决定,建议用网络时间协议(NTP)时<br>戳,以确保唯一性.<br>&lt;版本&gt;该会话公告的版本,供公告代理服务器检测同一会话的若干个公告哪个<br>是最新公告.基本要求是会话数据修改后该版本值递增,建议用NTP时戳<br>&lt;网络类型&gt;为文本串”IN”<br>&lt;地址类型&gt;”IP4”(可为域名或点分十进制)/”IP6”(域名或压缩文本地址形式)<br>&lt;地址&gt;<br>会话名 s= ISO 10646字符表示的会话名<br>会话信息   v= ISO 10646字符表示的会话信息<br>URI    u= 能提供会议进一步信息的URI地址<br>E妹地址   e= 给出会议负责人的联系信息,他不一定是创建会议公告的人<br>电话号码   p= 给出会议负责人的联系信息,他不一定是创建会议公告的人(国际通用形式)<br>连接数据   c=媒体连接数据，会话级为媒体级的摸认值<br>带宽    b= 给出会话或媒体所用带宽，单位为kbit/s.修饰语：CT(会议总带宽，表示所有<br>地点所有媒体的总带宽)，AS(应用特定最大带宽，表示一个地点单一媒体带宽)<br>时间描述   t= 见上<br>   r= 见上<br>时区调整   z= 见上<br>加密密钥    k=已定义的方法有<br>      k=clear:&lt;加密密钥&gt;密钥没有变换<br>k=base64:&lt;编码密钥&gt;已编码，因为它含有SDP禁用的字符<br>k=uri:&lt;获得密钥的URI&gt;<br>k=prompt。SDP没有提供密钥但该会话或媒体流是要求加密的。<br>属性    a=一个m=行可有多个a=行，SDP建议扩展如下：(具体见[1].Page419)<br>会话级： a=cat:&lt;类别&gt;//给出点分层次式会话分类号,供接收方筛选会话<br>a=keywds:&lt;关键词&gt;//供接收方筛选会话<br>a=tool:&lt;工具名和版本号&gt;//创建会话描述的工具名和版本号<br>a=recvonly/sendrecv/sendonly//收发模式<br>a=type:&lt;会议类型&gt;//有:广播,聚会,主席主持,测试,H.323<br>a=charset:&lt;字符集&gt;//显示会话名和信息数据的字符集<br>a=sdplang:&lt;语言标记&gt;//描述所有语言<br>a=lang:&lt;语言标记&gt;//会话描述的缺省语言或媒体描述的语言<br>a=framerate:&lt;帧速率&gt;//单位:帧/秒<br>a=quality:&lt;质量&gt;//视频的建议质量(10/5/0)<br>a=fmtp:&lt;格式&gt;&lt; 格式特定参数&gt;//定义指定格式的附加参数<br>媒体级：a=ptime:&lt;分组时间&gt;//媒体分组的时长(单位:秒)<br>a=recvonly/sendrecv/sendonly//收发模式<br>a=orient:&lt;白板方向&gt;//指明白板在屏莫上的方向<br>a=sdplang:&lt;语言标记&gt;//描述所有语言<br>a=lang:&lt;语言标记&gt;//会话描述的缺省语言或媒体描述的语言<br>媒体描述     m= &lt;媒体&gt;有5种类型：音频/视频/应用(如白板信息)/数据(不向用户显示的)/控制<br>&lt;端口&gt;媒体流发往传输层的端口。取决于c=行规定的网络类型和接下来的传<br>送层协议：对UDP为1024-65535；对分层编码应用（c=行没有多播地址），<br>要给出多播端口数，如：m=video 49170/2 RTP/AVP 31（表示：端口49170<br>和49171为第一对RTP/RTCP端口，49172和49173为第二对的端口）。<br>&lt;传送层协议&gt;与c=行的地址类型有关。对大多的媒体在RTP/UDP上传送，定<br>义2种：RTP/AVP：IETF RTP协议，音/视频应用文档。在UDP上传诵。<br>Udp：UDP协议。<br>&lt;格式列表&gt;对音/视频，就是音/视频应用文档中规定媒体净荷类型。列表中都<br>有可能用，但第一个为缺省值，分为静态绑定和动态绑定：静态绑定即使媒体编码方式有净荷类型号完全确定，动态绑定则媒体编码方式如时钟频率，音频信道数等）没有完全确定，需要进一步的属性说明。分别举例如下：<br>Alaw的PCM编码单信道Audio，其净荷类型号为8，把它发往UDP端口49232，则：m=audio 49232 RTP/AVP 8<br>16bit线性编码，双声道立体声，抽样速率16kHz，其动态净荷类型号98，则：m=audio 49232 RTP/AVP 98<br>a=rtpmap:98 L16/16000/2<br>说明：1）a=rtpmap:&lt;净荷类型号&gt;&lt;编码名&gt;/&lt;时钟速率&gt;[/&lt;编码参数&gt;]<br>    对音频，编码参数为音频信道数；对视频没有定义<br>2）SDP允许rtpmap规定实验性编码格式，但编码名必须以X-起，<br>表示此格式还没正式登记。</li>
<li>SDP Grammar<br>announcement =        proto-version<br>                     origin-field<br>                     session-name-field<br>                     information-field<br>                     uri-field<br>                     email-fields<br>                     phone-fields<br>                     connection-field<br>                     bandwidth-fields<br>                     time-fields<br>                     key-field<br>                     attribute-fields<br>                     media-descriptions<br>proto-version =    &quot;v=&quot; 1<em>DIGIT CRLF<br>                     ;this memo describes version 0<br>origin-field =        &quot;o=&quot; username space<br>                     sess-id space sess-version space<br>                     nettype space addrtype space<br>                     addr CRLF<br>session-name-field =   &quot;s=&quot; text CRLF<br>information-field = [&quot;i=&quot; text CRLF]<br>uri-field =           [&quot;u=&quot; uri CRLF]<br>email-fields =        <em>(&quot;e=&quot; email-address CRLF)<br>phone-fields =        *(&quot;p=&quot; phone-number CRLF)<br>connection-field = [&quot;c=&quot; nettype space addrtype space<br>                     connection-address CRLF]<br>                     ;a connection field must be present<br>                     ;in every media description or at the<br>                     ;session-level<br>bandwidth-fields = *(&quot;b=&quot; bwtype &quot;:&quot; bandwidth CRLF)<br>time-fields =       1</em>( &quot;t=&quot; start-time space stop-time<br>                     <em>(CRLF repeat-fields) CRLF)<br>                     [zone-adjustments CRLF]<br>repeat-fields =    &quot;r=&quot; repeat-interval space typed-time<br>                     1</em>(space typed-time)<br>zone-adjustments = time space [&quot;-&quot;] typed-time<br>                     *(space time space [&quot;-&quot;] typed-time)<br>key-field =           [&quot;k=&quot; key-type CRLF]<br>key-type =          &quot;prompt&quot; |<br>                     &quot;clear:&quot; key-data |<br>                     &quot;base64:&quot; key-data |<br>                     &quot;uri:&quot; uri<br>key-data =          email-safe | &quot;~&quot; | &quot;<br>attribute-fields = *(&quot;a=&quot; attribute CRLF)<br>media-descriptions =   *( media-field<br>                     information-field<br>                     *(connection-field)<br>                     bandwidth-fields<br>                     key-field<br>                     attribute-fields )<br>media-field =       &quot;m=&quot; media space port [&quot;/&quot; integer]<br>                     space proto 1</em>(space fmt) CRLF<br>media =             1*(alpha-numeric)<br>                     ;typically &quot;audio&quot;, &quot;video&quot;, &quot;application&quot;<br>                     ;or &quot;data&quot;<br>fmt =                 1*(alpha-numeric)<br>                     ;typically an RTP payload type for audio<br>                     ;and video media<br>proto =             1*(alpha-numeric)<br>                     ;typically &quot;RTP/AVP&quot; or &quot;udp&quot; for IP4<br>port =             1*(DIGIT)<br>                     ;should in the range &quot;1024&quot; to &quot;65535&quot; inclusive<br>                     ;for UDP based media<br>attribute =           (att-field &quot;:&quot; att-value) | att-field<br>att-field =           1*(alpha-numeric)<br>att-value =           byte-string<br>sess-id =          1*(DIGIT)<br>                     ;should be unique for this originating username/host<br>sess-version =        1*(DIGIT)<br>                     ;0 is a new session<br>connection-address =   multicast-address<br>                     | addr<br>multicast-address = 3*(decimal-uchar &quot;.&quot;) decimal-uchar &quot;/&quot; ttl</li>
</ol>
<p>[ &quot;/&quot; integer ]<br>                     ;multicast addresses may be in the range<br>                     ;224.0.0.0 to 239.255.255.255<br>ttl =                 decimal-uchar<br>start-time =       time | &quot;0&quot;<br>stop-time =           time | &quot;0&quot;<br>time =             POS-DIGIT 9*(DIGIT)<br>                     ;sufficient for 2 more centuries<br>repeat-interval =     typed-time<br>typed-time =       1*(DIGIT) [fixed-len-time-unit]<br>fixed-len-time-unit = &quot;d&quot; | &quot;h&quot; | &quot;m&quot; | &quot;s&quot;<br>bwtype =              1*(alpha-numeric)<br>bandwidth =           1*(DIGIT)<br>username =          safe<br>                     ;pretty wide definition, but doesn’t include space<br>email-address =    email | email &quot;(&quot; email-safe &quot;)&quot; |<br>                     email-safe &quot;&lt;&quot; email &quot;&gt;&quot;<br>email =             ;defined in RFC822<br>uri=                ;defined in RFC1630<br>phone-number =        phone | phone &quot;(&quot; email-safe &quot;)&quot; |<br>                     email-safe &quot;&lt;&quot; phone &quot;&gt;&quot;<br>phone =             &quot;+&quot; POS-DIGIT 1*(space | &quot;-&quot; | DIGIT)<br>                     ;there must be a space or hyphen between the<br>                     ;international code and the rest of the number.<br>nettype =          &quot;IN&quot;<br>                     ;list to be extended<br>addrtype =          &quot;IP4&quot; | &quot;IP6&quot;<br>                     ;list to be extended<br>addr =             FQDN | unicast-address<br>FQDN =             4*(alpha-numeric|&quot;-&quot;|&quot;.&quot;)<br>                     ;fully qualified domain name as specified in RFC1035<br>unicast-address =     IP4-address | IP6-address<br>IP4-address =       b1 &quot;.&quot; decimal-uchar &quot;.&quot; decimal-uchar &quot;.&quot; b4<br>b1 =                decimal-uchar<br>                     ;less than &quot;224&quot;; not &quot;0&quot; or &quot;127&quot;<br>b4 =                decimal-uchar<br>                     ;not &quot;0&quot;<br>IP6-address =       ;to be defined<br>text =             byte-string<br>                     ;default is to interpret this as IS0-10646 UTF8<br>                     ;ISO 8859-1 requires a &quot;a=charset:ISO-8859-1&quot;<br>                     ;session-level attribute to be used<br>byte-string =       1*(0x01..0x09|0x0b|0x0c|0x0e..0xff)<br>                     ;any byte except NUL, CR or LF<br>decimal-uchar =    DIGIT<br>                     | POS-DIGIT DIGIT<br>                     | (&quot;1&quot; 2*(DIGIT))<br>                     | (&quot;2&quot; (&quot;0&quot;|&quot;1&quot;|&quot;2&quot;|&quot;3&quot;|&quot;4&quot;) DIGIT)<br>                     | (&quot;2&quot; &quot;5&quot; (&quot;0&quot;|&quot;1&quot;|&quot;2&quot;|&quot;3&quot;|&quot;4&quot;|&quot;5&quot;))<br>integer =          POS-DIGIT <em>(DIGIT)<br>alpha-numeric =    ALPHA | DIGIT<br>DIGIT =             &quot;0&quot; | POS-DIGIT<br>POS-DIGIT =           &quot;1&quot;|&quot;2&quot;|&quot;3&quot;|&quot;4&quot;|&quot;5&quot;|&quot;6&quot;|&quot;7&quot;|&quot;8&quot;|&quot;9&quot;<br>ALPHA =             &quot;a&quot;|&quot;b&quot;|&quot;c&quot;|&quot;d&quot;|&quot;e&quot;|&quot;f&quot;|&quot;g&quot;|&quot;h&quot;|&quot;i&quot;|&quot;j&quot;|&quot;k&quot;|<br>                     &quot;l&quot;|&quot;m&quot;|&quot;n&quot;|&quot;o &quot;|&quot;p&quot;|&quot;q&quot;|&quot;r&quot;|&quot;s&quot;|&quot;t&quot;|&quot;u&quot;|&quot;v&quot;|<br>                     &quot;w&quot;|&quot;x&quot;|&quot;y&quot;|&quot;z&quot;|&quot;A&quot;|&quot;B&quot;|&quot;C &quot;|&quot;D&quot;|&quot;E&quot;|&quot;F&quot;|&quot;G&quot;|<br>                     &quot;H&quot;|&quot;I&quot;|&quot;J&quot;|&quot;K&quot;|&quot;L&quot;|&quot;M&quot;|&quot;N&quot;|&quot;O&quot;|&quot;P&quot;|&quot; Q&quot;|&quot;R&quot;|<br>                     &quot;S&quot;|&quot;T&quot;|&quot;U&quot;|&quot;V&quot;|&quot;W&quot;|&quot;X&quot;|&quot;Y&quot;|&quot;Z&quot;<br>email-safe =       safe | space | tab<br>safe =             alpha-numeric |<br>                     &quot;’&quot; | &quot;’&quot; | &quot;-&quot; | &quot;.&quot; | &quot;/&quot; | &quot;:&quot; | &quot;?&quot; | &quot;&quot;&quot; |<br>                     &quot;#&quot; | &quot;$&quot; | &quot;&amp;&quot; | &quot;</em>&quot; | &quot;;&quot; | &quot;=&quot; | &quot;@&quot; | &quot;[&quot; |<br>                     &quot;]&quot; | &quot;^&quot; | &quot;_&quot; | &quot;`&quot; | &quot;{&quot; | &quot;|&quot; | &quot;}&quot; | &quot;+&quot; |<br>                     &quot;~&quot; | &quot;<br>space =             %d32<br>tab =                 %d9<br>CRLF =             %d13.10</p>
<p>常见的如下：</p>
<p>a=rtpmap:103 ISAC/16000<br>a=rtpmap:102 iLBC/8000<br>a=rtpmap:3 GSM/8000<br>a=rtpmap:106 telephone-event/8000<br>a=rtpmap:13 CN/8000<br>a=rtpmap:117 red/8000<br>a=rtpmap:18 G729a/8000<br>a=rtpmap:0 PCMU/8000<br>a=rtpmap:2 G726-32/8000<br>a=rtpmap:4 G723/8000<br>a=rtpmap:8 PCMA/8000<br>a=rtpmap:96 G726-40/8000<br>a=rtpmap:97 G726-24/8000<br>a=rtpmap:98 G726-16/8000<br>a=rtpmap:100 NSE/8000<br>a=rtpmap:101 telephone-event/8000<br>a=rtpmap:0 pcmu/8000<br>a=rtpmap:8 pcma/8000<br>a=rtpmap:3 gsm/8000<br>a=rtpmap:18 G729/8000<br>a=rtpmap:98 iLBC/8000<br>a=rtpmap:97 speex/8000<br>a=rtpmap:101 telephone-event/8000</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>TCPIP</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/TCPIP/</url>
    <content><![CDATA[<p>TCP/IP整理资料</p>
<p>第一章 概述</p>
<p>1、英文缩写全称：</p>
<p>NII：国家信息基础设施</p>
<p>CNII：我国的国家信息基础设施</p>
<p>GII：全球信息基础设施</p>
<p>IAB：因特网体系结构委员会（Internet Architecture Board）</p>
<p>ICCB：因特网配置控制委员会</p>
<p>IETF：因特网工程任务组（Internet Engineering Task Force）</p>
<p>IRTF：因特网研究任务组（Internet Research Task Force）</p>
<p>IESG：因特网工程指导组（Internet Engineering Steering Group）</p>
<p>InterNIC：因特网网络信息中心（Internet Network Information Center） </p>
<p>CNNIC：中国互联网络信息中心（China Internet Network Information Center）</p>
<p>ICANN：因特网名称与数字地址分配机构 (Internet Corporation for Assigned Names and Numbers)</p>
<p>WWW协会W3C（World Wide Web Consortium）</p>
<p>2、RFC：请求注解（Request For Comments），是一系列关于因特网的技术文档</p>
<p>RFC2821: 简单邮件传输协议</p>
<p>RFC2616: 超文本传输协议</p>
<p>第二章 计算机网络与因特网体系结构</p>
<p>1、OSI：开放系统互连参考模型</p>
<p>ISO：国际标准化组织 </p>
<p>2、计算机网络的分类 </p>
<p>按照网络的拓扑结构，网络可以划分为总线型网，星型网，环型网和格状网。</p>
<p>按照网络的覆盖范围，网络可以划分为：</p>
<p>广域网（Wide Area Network，WAN）</p>
<p>城域网（Metropolitan Area Network，MAN）</p>
<p>局域网（Local Area Network，LAN）</p>
<p>个域网（Personal Area Network，PAN）</p>
<p>3、网络协议</p>
<p>协议包括三个要素：语法、语义、同步规则</p>
<p>通常采用分层的网络协议，分层的好处：</p>
<p>网络协议的分层有利于将复杂的问题分解成多个简单的问题，从而分而治之；</p>
<p>分层可以屏蔽下层的变化，新的底层技术的引入，不会对上层的应用协议产生影响；</p>
<p>分层有利于网络的互联，进行协议转换时只需考虑某一个或几个层次而不是所有层次。</p>
<p>4、SAP：服务访问点</p>
<p>服务是垂直的，协议是水平的</p>
<p>5、OSI各层</p>
<p>（1）物理层：</p>
<p>物理层涉及网络接口和传输介质的机械、电气、功能和规程方面的特性。具体包括接口和介质的物理特性、二进制位的编码解码、传输速率、位同步、传输模式、物理拓扑、线路连接等。物理层的数据单位是二进制位（Bit）。</p>
<p>（2）数据链路层</p>
<p>数据链路层将不可靠的物理层转变成一个无差错的链路。具体功能包括数据成帧、介质访问控制、物理寻址、差错控制、流量控制等。数据链路层的数据单位是帧（Frame）。</p>
<p>数据链路层又分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p>
<p>（3）网络层</p>
<p>网络层负责分组（Packet）从源主机到目的主机的端到端传输过程。具体功能包括跨网络逻辑寻址、路由选择、流量控制、拥塞控制等。网络层涉及的数据单位是分组。</p>
<p>*以上三层属于通信支持层。</p>
<p>（4）传输层</p>
<p>传输层负责整个报文（Message）在不同主机进程间的传输。具体功能包括连接控制、流量控制、差错控制、报文的分段和组装、主机进程寻址等。传输层关注的是报文的完整和有序问题。传输层实现了高层与通信子网的隔离层。 </p>
<p>（5）会话层</p>
<p>会话层负责网络会话的控制。具体功能包括会话的建立、维护和交互过程中的同步。</p>
<p>（6）表示层</p>
<p>表示层负责信息的表示和转换。具体功能包括数据的加密/解密、压缩/解压、与标准格式间的转换等。</p>
<p>（7）应用层</p>
<p>应用层负责向用户提供访问网络资源的接口。应用层包括一些常用的应用程序和服务，如电子邮件、文件传输、网络虚拟终端、WWW服务、目录服务等。</p>
<p>*顶上的三层是用户支持层。</p>
<p>6、WiMAX：工业贸易联盟组织，被广义地理解为IEEE 802.16标准系列的别称，是一个与无线城域网标准相关的组织，又是无线城域网的技术标准。</p>
<p>  Wi-Fi：致力于推进IEEE 802.11标准的联盟，被用作IEEE 802.11标准系列的别称。 </p>
<p>• WiMAX=WMAN（无限城域网）技术</p>
<p>• Wi-Fi=WLAN（无线局域网）技术</p>
<p>7、因特网使用TCP/IP协议，分为4个协议层</p>
<p>• 网络接口层实际上包含OSI模型的物理层和链路层，TCP/IP并未对这层进行定义，因此它支持现有的各种底层网络技术和标准。</p>
<p>• 网络层又称为互联网层或IP层，该层处理IP数据报的传输、路由选择、流量控制和拥塞控制。该层包含因特网协议IP，因特网控制报文协议ICMP，因特网组管理协议IGMP， 地址解析协议ARP，反向地址解析协议RARP等协议</p>
<p>• 传输层为两台主机上的应用程序提供端到端的进程通信。包含传输控制协议TCP和用户数据报协议UDP。</p>
<p>• 应用层为用户提供一些常用的网络应用接口。该层包含大量的应用协议。</p>
<p>8、OSI/RM（简称OSI）与TCP/IP的关系 </p>
<p>OSI/RM与TCP/IP协议层次的对应关系：</p>
<p>除了层次结构的差异外，ISO/OSI与TCP/IP还存在下列差异。 </p>
<p>IOS/OSI</p>
<p>TCP/IP</p>
<p>IOS/OSI是抽象的概念模型</p>
<p>TCP/IP是具体协议与实现</p>
<p>IOS/OSI复杂、效率低、大而全</p>
<p>TCP/IP单纯、简单、实用</p>
<p>IOS/OSI力量单薄，产品少</p>
<p>TCP/IP得到产业界的支持，应用广</p>
<p>IOS/OSI进展缓慢</p>
<p>TCP/IP完善速度快（IPv6）</p>
<p>9、TCP/IP是一个协议簇，其构成如图2-17所示</p>
<p>第三章 IP地址</p>
<p>1、IP结构可以表示为：</p>
<p>网络号（Network-Number）</p>
<p>主机号（Host-number）</p>
<p>网络号的长度决定因特网能包含多少个网络，</p>
<p>主机号的长度决定每个网络能容纳多少台主机。</p>
<p>IP地址的分类（IPv4规定，IP地址32位）</p>
<p>0              8</p>
<p>     32</p>
<p>A类</p>
<p>0</p>
<p>网络号</p>
<p>主机号</p>
<p>B类</p>
<p>1</p>
<p>0</p>
<p>网络号</p>
<p>主机号</p>
<p>C类</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>网络号</p>
<p>主机号</p>
<p>D类</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>组标识符</p>
<p>E类</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>保留</p>
<p>• A类地址第一个字节的最高位固定为0，另外7比特的网络号可以标识27 = 128个网络（0～127），但其中0一般不用，127用作环回地址。所以可表示126个A类网络。A类地址的24比特主机号可以标识16 777 216台主机（224  =16777216），但主机号为全0时用于表示本网络，主机号为全1时用于表示广播地址，这两个主机号不能用来标识主机。所以，每个A类网络最多可以容纳16 777 214台主机。A类地址用于大型网。A类地址的第一个字节的取值范围为0～127。</p>
<p>• A类地址范围   0.0.0.0  ~ 127.255.255.255</p>
<p>• B类地址第一个字节的最高2比特固定为10，另外14比特的网络号可以标识214= 16384个B类网络。16比特主机号可以标识65 536台主机（216 =65536），由于主机号不能为全0和全1。所以，每个B类网络最多可以容纳65 534台主机。B类地址用于中型网。B类地址的第一个字节的取值范围为128～191。 </p>
<p>• B类地址范围 128.0.0.0-191.255.255.255</p>
<p>• C类地址第一个字节的最高3比特固定为110，另外21比特的网络号可以标识221 =2097152个C类网络。8比特主机号可以标识256台主机(28 =256)，由于主机号不能为全0和全1。所以，每个C类网络最多可以容纳254台主机。C类地址用于小型网。C类地址的第一个字节的取值范围为192～223。</p>
<p>• C类地址范围 192.0.0.0  ~ 223.255.255.255</p>
<p>• D类地址为组播地址（multicasting）。D类地址最高4比特固定为1110 ，范围为224.0.0.0～239.255.255.255。每个地址对应一个组，发往某一组播地址的数据将被该组中的所有成员设备接收。D类地址不能分配给主机，只能作为信息的目的地址。D类地址的第一个字节的取值范围为224～239。</p>
<p>• D类地址范围 224.0.0.0  ~ 239.255.255.255</p>
<p>• E类地址为保留地址，可以用于实验目的。E类地址最高5比特固定为11110。E类地址的第一个字节的取值范围为240～255。 </p>
<p>• E类地址范围 240.0.0.0  ~ 247.255.255.255</p>
<p>2、特殊IP地址（能用来指派给设备的网络接口）</p>
<p>   包括：网络地址、直接广播地址、有限广播地址、本网络地址、环回地址</p>
<p>．网络地址</p>
<p>因特网上每个网络也有一个IP地址，其主机号部分全为“0”。该类地址用于标识网络，不能分配给主机或其它设备。网络地址的使用可以减小路由表的规模。</p>
<p>．直接广播地址</p>
<p>    TCP/IP规定，主机号各位全为“1”的IP地址用于广播，叫作广播地址，不能分配给设备。直接广播是向某个网络上所有的主机发送报文。直接广播地址只能作为信息的目的地址。</p>
<p>．受限广播地址</p>
<p>TCP/IP规定，32比特全为“1”的IP地址用于本网络内的广播。受限广播地址的点分十进制表示为：255.255.255.255。受限广播地址只能作为信息的目的地址。</p>
<p>．本网络地址</p>
<p>TCP/IP规定，网络号各位全部为“0”时表示本网络。本网络地址分为两种情况：本网络特定主机地址和本网络本主机地址。本网络特定主机地址只能作为目的地址。本网络本主机地址的点分十进制表示为：0.0.0.0。本网络本主机地址只能作为源地址。</p>
<p>无盘工作站启动时没有IP地址，此时发送的信息采用网络号和主机号都为“0”的本网络本主机地址作为源地址。 </p>
<p>．环回地址</p>
<p>环回地址（Loopback Address）是用于网络软件测试以及本机进程之间通信的特殊地址。 A类网络地址127被用作环回地址。当使用环回地址作为目标地址发送数据时，数据将不会被发送到网络上，而是回送给本机的有关进程。 </p>
<p>3、IP地址配置原则</p>
<p>同一物理网络上的所有设备应该具有相同的网络号；</p>
<p>   因特网上的网络号必须是惟一的；</p>
<p>   在一个网络中主机号必须是惟一的；</p>
<p>   主机号不能为全“0”(主机号为全“0”表示网络)；</p>
<p>   主机号不能为全“1”(主机号为全“1”是广播地址)；</p>
<p>   网络号不能为全“0”(“0”表示本地网)；</p>
<p>   网络号不能为全“1”；   </p>
<p>   网络号不能以127开头(127是环回地址)。</p>
<p>4、DHCP（Dynamic Host Configuration Protocol）动态主机配置协议。该协议自动进行IP地址分配，确保不会出现地址重复。</p>
<p>5、子网划分及子网掩码 </p>
<p>² 划分子网的原因：</p>
<p>（1）A类网络和B类网络的地址空间都很大，不进一步进行划分，地址很难得到有效的利用。</p>
<p>（2）将一个大的网络划分为多个与单位部门相对应的小的子网络，便于进行管理。</p>
<p>（3）划分子网，并使用路由器连接子网，可以隔离广播和通信，减少网络拥塞。</p>
<p>（4）出于安全方面的考虑，希望将管理网络和服务网络分开。</p>
<p>² 划分子网的方法是将IP地址的主机号拿出一部分来标识子网。</p>
<p>² 子网地址</p>
<p>IP地址的网络号加子网号可以惟一地标识一个子网，这两部分合起来再加上全“0”的主机号就形成子网地址</p>
<p>² 子网掩码</p>
<p>对应于网络号和子网号的所有比特都被设为1，而对应于主机号的所有比特都被设为0。</p>
<p>² 获得子网地址的方法</p>
<p>将IP地址和子网掩码进行按位“与”运算。</p>
<p>² 子网地址中子网号和主机号的获得：（这取决于所需子网的数量和子网的规模）</p>
<p>假设网络的主机号的长度为p比特，如果从p比特主机号中拿出m比特来划分子网，则剩下n=p-m比特用于标识主机。 m比特决定子网的最大个数，n比特决定子网的最大规模。</p>
<p>子网的m比特可以标识2m个子网，但一般不建议使用m比特全“0”和全“1”的子网。这样，m比特实际可以划分2m -2个可用的子网。</p>
<p>主机的n比特可以标识2n台主机，但n比特为全“0”时用于标识子网，为全“1”时用于表示子网广播地址。这样，n比特主机号实际可以标识2n -2台主机。 </p>
<p>例题，见P56-57</p>
<p>6、超网</p>
<p>网络号（Network-number）</p>
<p>主机号（Host-number）</p>
<p>N位</p>
<p>超网号（Supernet-number）</p>
<p>主机号（Host-number）</p>
<p>超网的IP地址结构</p>
<p>² 超网掩码</p>
<p>对应于超网号的所有比特都被设为1，对应于主机号的所有比特都被设为0。</p>
<p>² 获得超网地址的方法也是将IP地址和超网掩码进行按位“与”运算。</p>
<p>² 在构造超网时，须注意以下3点：</p>
<p>（1）待合并的地址块必须是连续的。</p>
<p>（2）待合并的地址块的数量必须是2n（n=1，2，…）。</p>
<p>（3）被合并的C类地址块的第一个地址的第三字节的值必须是待合并的地址块数量的整数倍。</p>
<p>² 构造超网时，从网络号的最低位起拿出n比特作为主机号来合并2n个地址块，写出超网掩码，将其与各个IP地址按位“与”得超网地址。</p>
<p>7、无类地址</p>
<p>² 对每个无类地址块的要求是：地址块由2n个连续的IP地址构成，地址块的起始地址必须是能够被2n整除的地址。</p>
<p>² 在无类地址中常采用的是斜线表示法（Slash Notation），其格式为：W.X.Y.Z/n。斜线前面是IP地址，斜线后面是前缀长度。前缀是指IP地址中的网络号部分，因此前缀长度是指掩码中连续“1”的个数。 如：11.126.60.41/27</p>
<p>8、网络地址转换（NAT）</p>
<p>第四章 地址解析（逻辑地址（IP地址）与物理地址之间的映射）</p>
<p>4.1地址解析协议ARP (Address Resolution Protocol)：用于从IP地址到物理地址的映射</p>
<p>1. 源主机与目的主机位于同一子网</p>
<p>（1）发送站检查本地ARP高速缓存</p>
<p>当试图确定同一子网上目的主机的物理地址时，ARP首先检查本地的ARP高速缓存，看是否含有目的主机的IP地址与物理地址的映射。如果包含，则取出目的主机的物理地址，将IP数据报封装成帧后通过网络底层发往此物理地址。</p>
<p>（2）向目的主机发送ARP请求</p>
<p>若ARP高速缓存不包含目的主机的地址映射，主机就会形成一个ARP请求，以物理广播地址作为目的地址在本子网上广播，并等待目的主机的应答。</p>
<p>（3）目的站将请求者的地址信息写入高速缓存</p>
<p>由于ARP请求是子网上的广播，因而该子网上的每台主机都会收到广播，并将自己的IP地址和该ARP请求中的目的主机IP地址进行比较。如果不匹配，则ARP请求被忽略；如果匹配，则目的主机就将发送方的地址映射关系写入到本机的ARP高速缓存中。</p>
<p>（4）向请求者发送ARP响应</p>
<p>然后目的主机就向请求主机以单播方式发出一个ARP应答（此时目的主机已经知道了请求主机的物理地址）。</p>
<p> （5）请求方更新ARP高速缓存</p>
<p>请求主机收到ARP应答后，将目的主机的地址映射其写入它的ARP高速缓存。至此，双方都已知道了对方的地址映射，完成了地址解析，下面就可以进行两主机之间的通信了</p>
<p>2. 源主机与目的主机位于不同的子网</p>
<p>（1）检查本地高速缓存</p>
<p>当一台设备确认目的IP地址不属于本子网时，它会根据本身的路由表找到去往目的网络的路由器的IP地址。然后根据此IP地址确定路由器该端口的硬件地址，ARP首先检查本地的ARP高速缓存，确定它是否含有路由器对应端口的IP地址与物理地址的映射。如果包含，则ARP取出路由器端口的硬件地址，并以此物理地址为目的地址完成数据帧的封装和传输。</p>
<p>（2）向下一跳路由器发送ARP请求</p>
<p>如果在ARP高速缓存中没有发现路由器IP地址的映射，则主机A必须向该路由器发送ARP请求广播，并等待答复。该ARP请求包含发送者的IP地址和硬件地址，以及路由器的IP地址。</p>
<p>（3）刷新ARP缓存</p>
<p>由于ARP请求是子网上的广播，因而网络上的每台设备都能接收到该数据包，并将自己的IP地址和该ARP请求中所指定的IP地址相比较。若不匹配，则忽略；若相匹配，则刷新本地ARP高速缓存。当路由器有多个网络接口时，每个接口都维护各自的高速缓存。</p>
<p>（4）路由器将ARP应答传给源主机</p>
<p>路由器向源主机发出一个ARP应答，应答给出了路由器与主机A所在网络的接口的IP地址解析。</p>
<p>（5）源主机刷新自己的ARP高速缓存</p>
<p>源主机刷新自己的ARP高速缓存，使其包含从ARP应答中得到的路由器的IP地址-物理地址映射。</p>
<p>（6）源主机向路由器发送数据</p>
<p>完成路由器地址的解析后，将数据传给路由器。</p>
<p>（7）路由器进行转发前查询ARP高速缓存</p>
<p>数据被传送到路由器后，路由器根据IP数据报中目的主机的IP地址和路由表确定数据是否已到达最后一跳路由器。若不是，则继续向下一跳路由器转发；否则，可以直接发往目的主机。</p>
<p>（8）向目的主机发送ARP请求</p>
<p>如果在路由器的ARP高速缓存中没有找到目的主机的地址映射，则路由器就必须向通往目的网络的接口广播一个ARP请求，并等待答复。</p>
<p>（ 9）刷新ARP高速缓存</p>
<p>目的子网上的所有主机均能接收到ARP广播，并将自己的IP地址与ARP请求中所指定的IP地址进行比较。如果不相匹配，则抛弃该ARP请求；如果匹配，则目的主机刷新它的ARP高速缓存表目。</p>
<p>（10）目的主机将ARP应答发送回路由器  </p>
<p>目的主机向路由器发回一个ARP应答。应答中包含对目的主机地址的解析结果。</p>
<p>（11）路由器刷新高速缓存</p>
<p>路由器收到应答后，刷新自己的高速缓存，使其包含目的主机的地址映射。</p>
<p>（12）路由器向目的主机转发数据</p>
<p>完成目的主机地址的解析后，路由器根据目的主机的物理地址进行物理数据帧的封装，然后将数据传给目的主机。</p>
<p>注意：数据包在从源主机到目的主机的转发过程中数据包的分组首部的IP地址是不发生变化的，而帧首部的物理地址在每一跳都会发生变化。</p>
<p>4.2 反向地址解析协议RARP (Reverse ARP)：用于从物理地址到IP地址的映射</p>
<p>RARP过程：</p>
<p>（1）无盘计算机以广播方式发出携带本机物理地址的RARP请求帧。注意这里是帧的广播，即目的MAC地址为全“1”。</p>
<p>（2）网上所有的计算机均收到该请求，但只有RARP服务器会根据请求者的物理地址查地址映射表，然后形成应答。应答以单播方式发送。</p>
<p>ARP和RARP的不同之处：</p>
<p>• ARP是根据另一个设备的IP地址求其物理地址，而RARP则是根据设备或其他设备的物理地址求其IP地址。</p>
<p>• ARP不需要专门的服务器，而RARP需要有RARP服务器完成解析 。</p>
<p>4.3 地址解析报文 </p>
<p>1、</p>
<p>以太网：硬件类型=1</p>
<p>IP协议：协议类型=0x0800</p>
<p>操作：ARP请求=1      ARP响应=2</p>
<p>      RARP请求=3    RARP响应=4</p>
<p>2、ARP/RARP报文是直接封装在物理帧中进行传输的。</p>
<p>• 在发送ARP广播或者RARP广播时，帧的目的地址字段放的是48个1(以太网的广播地址)。</p>
<p>• 由于ARP和RARP报文较短（28个字节），后面必须增加18个字节的填充字段PAD，以达到以太网最小帧长度的要求。</p>
<p>第五章 IP协议</p>
<p>1、网络层的作用：通过IP地址实现了底层物理地址的统一；并通过IP数据报实现了底层物理数据帧的统一。网络层通过以上两个统一向上屏蔽了网络底层的差异。</p>
<p>2、ARP和RARP报文不被封装在IP数据报中，而ICMP和IGMP的数据则要封装在IP数据报中进行传输。</p>
<p>3、 IP协议特点：不可靠、无连接的传输协议，提供的是尽力而为的传输服务，所以IP协议效率非常高，实现起来也较简单</p>
<p>4、IP数据报传输：IP数据报最终要通过底层物理网络的帧来传输，为此传送时要进行封装(encapsulation）：将数据报封装到底层物理网络的帧</p>
<p>5、IP协议不对数据报的数据部分进行校验。</p>
<p>原因：上层传输层是端到端的协议，由传输层对数据部分进行端到端的校验比网络层进行点到点的校验开销小得多，在通信线路较好的情况尤其如此。另外，上层协议可以根据对数据可靠性的要求，还选择进行校验或不校验，甚至可以选择采用何种校验方法，这给系统带来很大的灵活性。</p>
<p>IP协议只对数据报的首部进行校验。原因：</p>
<p>– IP首部内容属于网络层的内容，不可能由上层协议处理。</p>
<p>– IP首部中的部分字段在点到点的传递过程中是不断变化的，因此必须在相邻点之间完成校验。</p>
<p>6、IP数据报格式</p>
<p>服务类型：D：时延  T：吞吐量 R：可靠性  C：代价</p>
<p>校验和的求解：见P85</p>
<p>7、数据分片与重组 </p>
<p>² 最大传输单元MTU：指可以封装在一个帧中的最大数据长度。</p>
<p>² 数据报分片</p>
<p> 与分片相关的字段是标识字段、标志字段和片偏移字段。</p>
<p>1)数据报标识字段(16b长)是分片所属数据报的关键信息，也是分片重组的依据。各分片的标识字段和原数据报相同。 </p>
<p>2)标志字段由3位构成，低两位有效，最高位未使用；中间的D位表示是否允许该数据报进行分片(0表示允许分片)；最低的M位表示该片是否是分片的最后一片(0表示最后一个分片) 。</p>
<p> 3)片偏移字段以8个字节为单位指出本片中起始数据在原始数据报数据区中的偏移量。由于各分片独立传输，其到达信宿机的顺序无法保证，信宿机将根据片偏移字段实现数据报的重组。</p>
<p>分片必须满足两个条件：</p>
<p>• 前面各片尽可能大，但必须能被帧封装，</p>
<p>• 片中数据的大小必须为8字节的整数倍，否则IP无法表达其偏移量。 </p>
<p>² 重组（分片的重组只能在信宿机上进行）</p>
<p>8、IP数据报选项</p>
<p>选项：选项码（1字节），选项长度（1字节），选项数据（字节数由长度决定）</p>
<p>选项码：复制位（1比特）、选项类（2比特）、选项号（5比特）</p>
<p>选项类：两位IP选项类字段定义了四种选项类型，00用于IP数据报路径的控制和测试；10用于时间戳的测试；01类和11类未用。每一选项类又由选项号进行细分，其中00类中常用的有5个选项号，10类中只有1个选项号。</p>
<p>选项类  选项号  长度字段        含义</p>
<p>   0000000无         单字节结束选项</p>
<p>   0000001无       单字节填充选项</p>
<p>   0000011     有        宽松源路由</p>
<p>   0000111     有        记录路径</p>
<p>   0001001有        严格源路由</p>
<p>   1000100有        时间戳</p>
<p>第6章  差错与控制报文协议</p>
<p>6.1  因特网控制报文协议（ICMP）</p>
<p>• 位置：ICMP与IP协议位于同一层（IP层），但ICMP协议位于IP协议之上，所以ICMP报文是封装在IP数据报中进行传输的。 </p>
<p>• 作用：ICMP协议是IP协议的补充，用于IP层的差错报告、拥塞控制、路径控制以及路由器或主机信息的获取。（不仅用于传输差错报告，而且大量用于传输控制报文）</p>
<p>6.2  ICMP报文格式与类型</p>
<p>分类：</p>
<p>6.3  ICMP差错报告报文</p>
<p>• ICMP差错报告报文的数据区包含出错的IP数据报的首部及其前64位数据，这些信息有助于信源或管理人员发现错误原因。</p>
<p>• ICMP差错报告具有以下特点：</p>
<p>   1）只报告差错，但不负责纠正，纠错留给高层协议去处理。</p>
<p>   2）只向信源报告差错。</p>
<p>   3）差错报告作为一般数据传输，不享受特别优先权和可靠性。</p>
<p>   4）产生差错报告的同时，会丢弃出错的IP数据报。</p>
<p>• 以下情况不会产生ICMP差错报告：</p>
<p>1）ICMP差错报文本身不会再产生ICMP差错报告。</p>
<p>2）IP数据报的非第一个分片不会产生ICMP差错报告。</p>
<p>3）组播报文不会产生ICMP差错报告。</p>
<p>4）特殊地址127.0.0.0和0.0.0.0的报文不会产生ICMP差错报告。 </p>
<p>ICMP差错报告可分为：信宿不可达报告，数据报超时报告，数据报参数错报告。</p>
<p>6.3.1  信宿不可达报告 </p>
<p>当路由器无法根据路由表转发数据报时或信宿机无法向上层协议或端口提交数据报时，将丢弃当前的数据报，并向信源产生信宿不可达差错报告。</p>
<p>6.3.2  数据报超时报告</p>
<p>• 数据报首部的TTL值用于防止数据报因路由表出错而无休止地在网络中传输。当TTL值减为0时，路由器会丢弃当前的数据报，并向源主机发送一个ICMP数据报超时报告。</p>
<p>• 另外，在信宿进行分片重组时会启动重组定时器，一旦重组定时器超时，信宿机就会丢弃当前正在重组的数据报，并向源主机发送一个ICMP数据报超时报告。</p>
<p>6.3.3  数据报参数错报告</p>
<p>数据报参数错报告是由于数据报首部中字段值不明确或空缺而引起的。一旦路由器或信宿机发现此种错误，便抛弃该数据报，并向信源发送数据报参数错报文。</p>
<p>6.4  ICMP控制报文</p>
<p>ICMP控制报文包括源抑制报文和重定向报文</p>
<p>• 源抑制报文——用于拥塞控制</p>
<p>• 重定向报文——用于路径控制</p>
<p>6.4.1  源抑制报文</p>
<p>ICMP利用源抑制的方法来进行拥塞控制。通过源抑制来减缓信源发出数据报的速率。</p>
<p>源抑制包括三个阶段：发现拥塞阶段、解决拥塞阶段和恢复阶段。</p>
<p>6.4.2  重定向报文</p>
<p>    ICMP重定向报文就是解决主机路由表的更新问题的。</p>
<p>主机路由表所给出的去往某信宿下一跳路由器可能并非是去往信宿的最佳下一跳路由器，当下一跳路由器收到数据报后，该路由器根据它的路由表判断本路由器是否是去往信宿的最佳选择，如果不是，该路由器仍然会向信宿网络转发该数据报，但同时会向信源产生一个ICMP重定向报文，通知信源修改它的路由表，重定向报文中将给出信源的最佳下一跳路由器的入口IP地址。</p>
<p>6.5  ICMP请求与应答报文对</p>
<p>• 可以由因特网上任何主机或路由器向其他主机或路由器发送ICMP请求报文并获得应答。</p>
<p>• 通过ICMP请求与应答报文对，网络管理人员、用户或应用程序可以对网络进行检测，可了解：</p>
<p>– 设备的可达性</p>
<p>– 地址掩码的设置</p>
<p>– 时钟的同步等情况</p>
<p>• 方便对网络进行故障诊断和控制。</p>
<p>6.5.1  回应请求与应答报文</p>
<p>作用：不仅用来测试设备的可达性，还可以测试设备中IP协议的工作情况。</p>
<p>6.5.2  时间戳请求与应答报文（用于设备时钟的同步）</p>
<p>请求方与应答方的时钟差异的估算：首先要计算出时间戳请求和应答的往返延迟，然后据此计算出单程传输延迟，最后由两设备的时间戳和单程传输延迟计算出两台设备之间的时间差，将此作为实现设备时钟同步的依据。</p>
<p>往返延迟时间可以用下式计算：</p>
<p>往返时间＝(t当前－t初始)－(t发送－t接收)</p>
<p>假设传输请求的时延和传输应答的时延相同，那么单程时延就等于往返时间的一半。</p>
<p>  两设备时间差＝t接收－(t初始＋单程时延) </p>
<p>6.5.3  地址掩码请求与应答报文</p>
<p>作用：可使得一台设备获得某一台设备所在子网的子网掩码。</p>
<p>应用：无盘机通过RARP获得自己的IP地址后，可以利用ICMP地址掩码请求来获得所在子网的子网掩码。</p>
<p>6.5.4  路由器请求与通告报文</p>
<p>作用：用来获得路由器的地址和路由器是否工作等信息。</p>
<p>6.6  ICMP报文封装</p>
<p>ICMP协议将上层的请求转变为ICMP报文，然后封装在IP协议中进行发送。IP数据报首部中的协议字段为“1” 时表示数据报的数据为ICMP报文。</p>
<p>第7章  IP路由</p>
<p>7.1  直接传递与间接传递</p>
<p>• 直接传递是指在物理网络内部直接传到最终信宿的传输过程。</p>
<p>• 间接传递是指当信源和信宿位于不同物理网络时，所经过的一些中间传递过程。</p>
<p>  因此，数据报传递由一个直接传递和零到多个间接传递所组成。</p>
<p>7.2  IP路由</p>
<p>Ø 路由表的使用。即根据路由表进行路由选择。主机和路由器上的IP协议负责使用路由表，完成数据报传送的路由选择。</p>
<p>Ø 路由表的建立与刷新。路由表要随着网络的变化而变化，以反映网络的真实情况。路由器路由表的建立与刷新由专门的路由协议负责；而主机路由表的建立与刷新可由ICMP路由器请求与通告报文和ICMP重定向报文实现。 </p>
<p>路由表的刷新： ICMP重定向报文为主机路由表进行刷新；网络层和应用层的动态路由协议负责对路由器的路由表进行刷新。</p>
<p>7.3  路由表</p>
<p>1、路由表的功能是指明数据报去往某信宿应该使用哪条路径。</p>
<p>2、 路由表是一个二维表，每个表项由多个字段构成。最基本的信息：信宿地址+去往信宿的路径。</p>
<p>3、在路由表中使用信宿网络地址，而不采用信宿主机地址的好处：</p>
<p>1）可以大大减小路由表的规模。</p>
<p>2）与网络的抽象拓扑结构相对应。网络的抽象结构中只有网络，没有主机。</p>
<p>3）增强了路由表对网络变化的适应性。主机的增加和删去不会对路由表产生任何影响。</p>
<p>4）减轻了路由表维护以及路由选择的开销，同时也简化了路由设备的设计和实现。</p>
<p>3、在路由表中只采用下一跳地址而不用完整路径的好处：</p>
<p>1）减小了路由表的规模。</p>
<p>2）去掉了路由表中关于相同路径的冗余信息。</p>
<p>3）使路由表变得简单，便于维护。</p>
<p>4、路由表中除了信宿地址和下一跳地址外，通常还包括子网掩码、去往下一跳的输出接口和度量。</p>
<p>5、路由表中的特殊表项</p>
<p>• 特定主机路由：用主机地址作为信宿地址的表项，表项的子网掩码为255.255.255.255。 目的：网络管理人员可以给去往某台特定主机的信息设置路由，用于安全性和网络测试。</p>
<p>• 默认路由：用0.0.0.0作为信宿地址的表项，且子网掩码也为0.0.0.0。默认路由一般作为路由表的最后一条表项，可将去往多个网络的表项合为一个表项。目的：进一步隐藏细节、缩小路由表。</p>
<p>7.4  静态路由 </p>
<p>静态路由方式：路由器只能发现和它直接相连的网络，而不能发现没有直接连接的那些网络，此时需要以手工方式在路由表中添加表项。</p>
<p>静态路由的不足：在大型网络上手工编辑路由表是一件非常困难的工作，不仅工作量大，而且不能及时地反映网络的频繁变化，还可能造成难以管理的冗余路径。</p>
<p>7.5  动态路由</p>
<p>动态路由：路由器使用路由协议进行路由表的动态建立和刷新。</p>
<p>路由协议进行路由选择的原则：最短路径优先。</p>
<p>路由器自动获取网络路径信息的算法有两种：</p>
<p>– 向量—距离算法(又称为距离—向量算法)</p>
<p>– 链路—状态算法。</p>
<p>1、 向量—距离算法的优点：简单，易于实现。</p>
<p>– 缺点：</p>
<p>– 收敛速度慢：当网络某处结构发生变化时，变化信息的传输和扩散需要一段时间，因此在所有的路由器获得这种变化信息之前，部分路由表不能正确地反映网络的真实情况，即在收敛过程中，各路由器的路由表是不一致的。因此，该算法不适合结构频繁变化的或大型的网络。</p>
<p>– 信息交换量较大：相邻路由器每次交换路由信息时，传输的是整个路由表，而且所有的路由器都要参与信息的交换。</p>
<p>2、链路—状态(Link-Status，简称L-S)算法，又称最短路径优先(Shortest Path First，SPF)算法。</p>
<p>3、动态路由协议包括两种：内部网关协议(IGP)和外部网关协议(EGP)。</p>
<p>• 内部网关协议用于自治系统内部的路径信息交换和路由表刷新。常用的有：</p>
<p>– 路由信息协议RIP(Routing Information Protocol)</p>
<p>– 开放最短路径优先OSPF(Open Shortest Path First)协议。</p>
<p>• 外部网关协议用于自治系统之间的路径信息交换和路由表刷新。常用的有：</p>
<p>– 外部网关协议EGP(Exterior Gateway Protocol)</p>
<p>– 边界网关协议BGP (Border Gateway Protocol)</p>
<p>7.5.1  路由信息协议(RIP)</p>
<p>• RIP协议采用V-D算法进行路径信息交换和路由表刷新。RIP要求路由器每30秒钟向相邻路由器广播一个V-D报文，报文中的V-D信息来自于本地的路由表。</p>
<p>1、RIP协议解决的问题</p>
<p>RIP协议在V-D算法的基础上，增加了对路由环路、相同距离路径、失效路径以及慢收敛问题的处理。</p>
<p>• 路由环路问题：由于V-D算法收敛慢，所有路由器不能同时或接近同时地完成路由表的更新，因此有可能会产生路由环路。 解决办法：RIP规定，一条有效路径的距离(路径上的跳数)不能超过15，距离为16时表示此路径不存在。</p>
<p>• 相同距离路径问题：若去往某一网络存在多条相同距离的路径，RIP采用先入为主的原则，路由器以最先收到的路径报文决定下一跳，后来收到的相同距离的路径报文不会引起路由表的刷新。</p>
<p>• 失效路径问题：RIP协议为每条路由表项设置一个定时器，如果发现某一条路由在3分钟(6个周期)内没有收到与它相关的路径信息，就将该路由的度量值设置成16，并标注为删除。标注后并不立即删除，等过一段时间，该路径失效信息被传播开去后，才将该路由从路由表中删除。</p>
<p>2、为了防止计数到无穷，可以采用以下三种技术。</p>
<p>1）水平分割法(Split Horizon)</p>
<p>   路由器从某个接口收到的更新信息不允许再从这个接口发回去。</p>
<p>2）保持法(Hold Down)</p>
<p>• 计数到无穷的发生是因为在R1将不可达信息发出去之前先收到了来自R2的V-D报文，所产生的刷新操作导致不可达信息丢失。</p>
<p>• 为了解决这一问题，保持法要求路由器在得知某网络不可到达后的一段时间内，保持此信息不变，路由器在保持时间内不接受关于此网络的任何可达性信息。这样，保证有充足的时间将路径失效信息传播出去。</p>
<p>3）毒性逆转法(Poison Reverse)</p>
<p>• 毒性逆转法是水平分割法的一种变型。当从某一接口发出V-D报文时，凡是从这一接口进来的信息，V-D报文中对应表项的距离值都设为无穷(16)，以免对邻机的路由表产生错误的刷新。 </p>
<p>3、RIP报文及其传输：RIP是应用层协议，RIP报文被封装在UDP数据报中传输。RIP接收方进程使用UDP 520端口。</p>
<p>4、RIPv1简单，易于实现。但存在以下不足：</p>
<p>1）RIPv1不支持子网；</p>
<p>2）RIPv1没有报文鉴别机制；</p>
<p>3）RIPv1采用广播方式进行路由通告；</p>
<p>4）RIPv1只能用于小型网络，因为最大路径长度15限制了它在大型网络上的应用。</p>
<p>RFC 1388中对RIPv1进行了扩充，扩充后的RIP协议称为RIPv2。</p>
<p>5、RIPv2可以传送子网掩码，可以支持可变长子网掩码和无类别域间路由CIDR。</p>
<p>RIPv2提供了简单的报文鉴别机制，采用口令方式。</p>
<p>RIPv2支持组播，使用组播传送路由通告，组播地址224.0.0.9对应所有支持RIPv2的路由器</p>
<p>7.5.2  开放最短路径优先（OSPF）</p>
<p>• 好处：区域的划分不仅使得广播得到了更好的管理，而且使OSPF能够支持大规模的网络。并且层次概念的引入，减少了每一个路由器需要知道的信息总量。</p>
<p>• 在区域的边界一般至少有一个边界路由器(ABR)。作用：汇总该区域的信息，并送往其他区域。</p>
<p>• 在每个自治系统的所以区域中都有一个主干区域，其他区域都连到主干区域上。主干区域中的路由器称为主干路由器。</p>
<p>• 每个区域有一个区域标识，区域标识也采用点分十进制数表示，主干区域的标识是0.0.0.0。 </p>
<p>• OSPF采用链路—状态协议</p>
<p>• OSPF是网络层协议，OSPF报文直接使用IP数据包进行封装。在其IP首部，对应的协议字段的值为89。</p>
<p>• OSPF特点：</p>
<p>    1）支持服务类型路由。OSPF可根据目的IP地址和该数据所要求的服务类型进行路由选择。</p>
<p>    2）能够给路由器每个接口指派费用。费用可以是吞吐率、传输延迟、可靠性等性能。</p>
<p>   3）能够提供负载均衡。当去往一个目的地址存在多个相同费用的路由时，OSPF可以在这些路由上平均分配流量。</p>
<p>4） OSPF的层次结构支持扩展，易于管理。</p>
<p>    5）支持特定主机路由、特定子网、分类网络路由以及无类网络路由。</p>
<p>    6）支持CIDR，可以节约IP地址。</p>
<p>    7）支持多种鉴别机制，不同的区域可以使用不同的鉴别方法。</p>
<p>    8）采用组播，减少不参与OSPF的系统的负载。</p>
<p>        由于OSPF具有强大的功能和灵活的扩展性，势必逐步取代RIP协议。</p>
<p>7.5.3  边界网关协议（BGP）</p>
<p>用于在自治系统之间交换路由信息。</p>
<p>采用的是与向量—距离算法类似的向量—路径算法。</p>
<p>• BGP协议位于应用层，使用TCP作为传输层协议。两个路由器在交换BGP路由信息时必须先建立一条TCP连接。</p>
<p>第8章  传输层协议</p>
<p>传输层通过TCP和UDP协议向上层提供统一的两种类型的服务。  </p>
<p>8.1  进程间通信</p>
<p>TCP/IP采用端口来标识主机上的通信进程。</p>
<p>端口：端口是应用层与传输层的服务访问点。从通信角度看，端口是通信进程的标识，进程与端口建立关联后，传输层传给该端口的数据都会被相应的进程所接收。</p>
<p>• 网络中要全局唯一标识一个进程必须采用一个三元组：（协议，主机地址，端口号）</p>
<p>• 网络通信的本质是两个进程之间的通信，并且通信双方采用的传输层协议是相同的，所以可以用一个五元组来描述这个通信：（协议, 本地主机地址, 本地端口号, 远地主机地址, 远地端口号）  </p>
<p>因特网通信通常采用客户机/服务器模型</p>
<p>• 每一个标准的服务器进程都拥有一个熟知的端口号：TCP和UDP规定，0～1023的端口号用作熟知端口，又称为保留端口。如，FTP服务器控制进程固定使用TCP 21端口， FTP服务器数据进程固定使用TCP 20端口， SMTP服务器进程使用TCP 25端口，DHCP服务器进程使用UDP 67端口。</p>
<p>• TCP传输的数据单元称为TCP段。TCP段不定长，被封装在IP数据报中传输。</p>
<p>• 但IP协议是无连接的、不可靠的，不能保证数据的按序到达，还可能造成数据的丢失或毁坏，但在其上的TCP通过一系列处理后(例如流量控制，拥塞控制和差错控制等)，TCP向上层提供的是可靠的、无差错的传输服务。</p>
<p>8.2  TCP段格式</p>
<p>8.3  TCP连接的建立和拆除</p>
<p>8.3.1 TCP连接的建立</p>
<p>超时重传</p>
<p>解决重复连接的办法：采用序号字段对主机发出的所有TCP段进行编号，序号字段为段数据部分第一个字节的字节编号。</p>
<p>建立连接由三次握手完成。拆除连接由四次握手完成。</p>
<p>第一次握手：由客户向服务器发出SYN段，该段首部的同步标志SYN置1，还包括了客户的初始序号SEQ（例如SEQ=26500）。</p>
<p>第二次握手：服务器收到请求后，发回SYN + ACK段，该段首部中的同步标志SYN置1，首部中的确认标志ACK置1，表示对所接收的段的确认，同时确认号字段给出准备接收的对方下一段序号,该段还给出了服务器的初始序号。此时完成了一个方向上连接。</p>
<p>第三次握手：客户向服务器发出ACK段，段首部中的确认标志ACK置1，表示对接收信息的确认，同时确认号字段被设置为收到的段序号加1(ACK 29011)。此时完成了另一个方向上的连接。</p>
<p>拆除：</p>
<p>解决：TCP采用四次握手来断开连接。可以将断开连接操作视为在两个方向上分别断开半连接的操作。</p>
<p>一方发出断开连接请求后并不马上拆除连接，而是等待收到对方确认报文后，才拆除半连接（即不发数据了但还可接收数据）。对方发送完数据后，对方再发送断开连接请求，并在收到应答后断开另一个方向上的半连接。</p>
<p>8.4  TCP流量控制</p>
<p>• TCP主要特点是高可靠性。表现在：TCP传输一个无报文丢失、重复和失序的正确的数据流。</p>
<p>• TCP采用的可靠性技术：</p>
<p>– 流量控制</p>
<p>– 拥塞控制</p>
<p>– 差错控制</p>
<p>8.8  用户数据报协议UDP</p>
<p>是TCP/IP传输层的另一个协议</p>
<p>TCP可靠，UDP高效</p>
<p>UDP同IP协议一样提供无连接数据报传输，因此UDP在IP协议上只增加了进程通信能力，还提供了简单的差错控制。UDP不提供流量控制，也不对UDP数据报进行确认。 </p>
<p>UDP提供无连接的服务。</p>
<p>表8-1  TCP和UDP的特点比较</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>android 4</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/android%204.2/</url>
    <content><![CDATA[<p>修改android  为平板模式</p>
<p>device\rockchip\rk30sdk\device.mk</p>
<p>ro.rk.systembar.tabletUI=true \</p>
<p>或者</p>
<p>修改out\target\product\rk30sdk\system\build.prop</p>
<p>ro.rk.systembar.tabletUI=true \</p>
<p>修改设置里面的渐变色背景图</p>
<p>frameworks\base\core\res\res\drawable\background_holo_dark.xml</p>
<p>            android:startColor=&quot;#ff1a1a1a&quot;</p>
<p>            android:endColor=&quot;#ff1a1a1a&quot;</p>
<p>修改锁屏界面 解锁部分</p>
<p>frameworks\base\core\res\res\values\arrays.xml</p>
<p>frameworks\base\core\res\res\layout\keyguard_glow_pad_view.xml</p>
<p>整个应用程序的 宽高</p>
<p>&lt;!– AppsCustomize –&gt;</p>
<p>    &lt;dimen name=&quot;apps_customize_cell_width&quot;&gt;126dp&lt;/dimen&gt;</p>
<p>    &lt;dimen name=&quot;apps_customize_cell_height&quot;&gt;126dp&lt;/dimen&gt;</p>
<p>修改锁屏界面 添加桌面插件</p>
<p>packages\apps\Calendar\res\xml\appwidget_info.xml</p>
<p>修改桌面切换到app 的速度</p>
<p>packages\apps\Launcher2\res\values\config.xml</p>
<p> &lt;integer name=&quot;config_appsCustomizeZoomInTime&quot;&gt;350&lt;/integer&gt;</p>
<p>    &lt;integer name=&quot;config_appsCustomizeZoomOutTime&quot;&gt;600&lt;/integer&gt;</p>
<p>    &lt;integer name=&quot;config_appsCustomizeZoomScaleFactor&quot;&gt;7&lt;/integer&gt;</p>
<p>    &lt;integer name=&quot;config_appsCustomizeFadeInTime&quot;&gt;250&lt;/integer&gt;</p>
<p>    &lt;integer name=&quot;config_appsCustomizeFadeOutTime&quot;&gt;200&lt;/integer&gt;</p>
<p>    &lt;integer name=&quot;config_appsCustomizeWorkspaceShrinkTime&quot;&gt;300&lt;/integer&gt;</p>
<p>    &lt;integer name=&quot;config_appsCustomizeWorkspaceAnimationStagger&quot;&gt;40&lt;/integer&gt;</p>
<p>    &lt;integer name=&quot;config_workspaceAppsCustomizeAnimationStagger&quot;&gt;100&lt;/integer&gt;</p>
<p>修改  应用程序和小部件 切换的速度</p>
<p>packages\apps\Launcher2\src\com\android\launcher2\AppsCustomizeTabHost.java</p>
<p>diff –git a/packages/apps/Launcher2/src/com/android/launcher2/AppsCustomizeTabHost.java b/packages/apps/Launcher2/src/com/android/launcher2/AppsCustomizeTabHost.java</p>
<p>index 5eb8483..404c494 100755</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/AppsCustomizeTabHost.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/AppsCustomizeTabHost.java</p>
<p>@@ -249,7 +249,7 @@ public class AppsCustomizeTabHost extends TabHost implements LauncherTransitiona</p>
<p>                     PagedViewWidget.setDeletePreviewsWhenDetachedFromWindow(false);</p>
<p>                     mAppsCustomizePane.removeView(child);</p>
<p>                     PagedViewWidget.setDeletePreviewsWhenDetachedFromWindow(true);</p>
<ul>
<li>                   mAnimationBuffer.setAlpha(1f);</li>
</ul>
<ul>
<li>                   mAnimationBuffer.setAlpha(0f);</li>
</ul>
<p>                     mAnimationBuffer.setVisibility(View.VISIBLE);</p>
<p>                     LayoutParams p = new FrameLayout.LayoutParams(child.getMeasuredWidth(),</p>
<p>                             child.getMeasuredHeight());</p>
<p>修改开机第一屏方向</p>
<p>kernel\drivers\video\rockchip\rk_fb.c</p>
<p>FB_ROTATE_UR //方向不改变</p>
<p>FB_ROTATE_UD//上下颠倒</p>
<p>FB_ROTATE_CW//顺时针旋转90度</p>
<p>FB_ROTATE_CCW//逆时针旋转90度</p>
<p>if  defined(CONFIG_LOGO_LINUX_BMP)</p>
<p>if(fb_prepare_bmp_logo(fb_inf-&gt;fb[0], FB_ROTATE_CCW)) {</p>
<p>/* Start display and show logo on boot */</p>
<p>fb_set_cmap(&amp;fb_inf-&gt;fb[0]-&gt;cmap, fb_inf-&gt;fb[0]);</p>
<p>fb_show_bmp_logo(fb_inf-&gt;fb[0], FB_ROTATE_CCW);</p>
<p>fb_inf-&gt;fb[0]-&gt;fbops-&gt;fb_pan_display(&amp;(fb_inf-&gt;fb[0]-&gt;var), fb_inf-&gt;fb[0]);</p>
<p>}</p>
<p>#else</p>
<p>if(fb_prepare_logo(fb_inf-&gt;fb[0], FB_ROTATE_CCW)) {</p>
<p>/* Start display and show logo on boot */</p>
<p>fb_set_cmap(&amp;fb_inf-&gt;fb[0]-&gt;cmap, fb_inf-&gt;fb[0]);</p>
<p>fb_show_logo(fb_inf-&gt;fb[0], FB_ROTATE_CCW);</p>
<p>fb_inf-&gt;fb[0]-&gt;fbops-&gt;fb_pan_display(&amp;(fb_inf-&gt;fb[0]-&gt;var), fb_inf-&gt;fb[0]);</p>
<p>}</p>
<p>#endif</p>
<p>fb_inf-&gt;fb[0]-&gt;fbops-&gt;fb_ioctl(fb_inf-&gt;fb[0],RK_FBIOSET_CONFIG_DONE,NULL);</p>
<p>修改默认动画（ANDROID）的方向</p>
<p>frameworks\base\core\res\assets\images</p>
<p>修改低电 电压图标方向</p>
<p>kernel\drivers\video\fbmem.c</p>
<p>#ifdef CONFIG_LOGO_LOWERPOWER_WARNING</p>
<p>if(1 ==  get_battery_status()){</p>
<p>/<em>yu del</em>/// y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,</p>
<p>y = fb_show_logo_line(info, FB_ROTATE_UR, fb_logo.logo, 0,</p>
<p>    1);</p>
<p>}else{</p>
<p>y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,</p>
<p>     num_online_cpus());</p>
<p>}</p>
<p>#else</p>
<p>y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,</p>
<p>     num_online_cpus());</p>
<p>#endif</p>
<p>摄像头状态栏 不随方向转动</p>
<p>packages\apps\Gallery2\AndroidManifest.xml</p>
<p>                android:windowSoftInputMode=&quot;stateAlwaysHidden|adjustPan&quot;</p>
<ul>
<li>android:screenOrientation=&quot;landscape&quot;&gt;</li>
</ul>
<p>去掉setting hdmi 1080p</p>
<p>packages\apps\Settings\res\values\arrays.xml</p>
<p>    &lt;string-array name=&quot;hdmi_resolution_entries&quot;&gt;</p>
<p> -       &lt;item&gt;1920x1080p_50Hz &lt;/item&gt;</p>
<p> -       &lt;item&gt;1920x1080p_60Hz&lt;/item&gt;</p>
<p>        &lt;item&gt;1280x720p_50Hz&lt;/item&gt;</p>
<p>        &lt;item&gt;1280x720p_60Hz&lt;/item&gt;</p>
<p>        &lt;item&gt;720x576p_50Hz &lt;/item&gt;</p>
<p>        &lt;item&gt;720x480p_60Hz &lt;/item&gt;</p>
<p>    &lt;/string-array&gt;</p>
<p>    &lt;string-array name=&quot;hdmi_resolution_values&quot;&gt;</p>
<ul>
<li><p>       &lt;item&gt;1&lt;/item&gt;</p>
</li>
<li><p>       &lt;item&gt;2&lt;/item&gt;</p>
</li>
</ul>
<p>        &lt;item&gt;3&lt;/item&gt;</p>
<p>        &lt;item&gt;4&lt;/item&gt;</p>
<p>        &lt;item&gt;5&lt;/item&gt;</p>
<p>        &lt;item&gt;6&lt;/item&gt;</p>
<p>    &lt;/string-array&gt;</p>
<p>packages\apps\Settings\res\xml\hdmi_settings.xml</p>
<p>&lt;ListPreference</p>
<p> android:key=&quot;hdmi_resolution&quot;</p>
<p>          android:title=&quot;@string/hdmi_resolution_title&quot;</p>
<p>          android:persistent=&quot;true&quot;</p>
<p> android:dependency=&quot;hdmi&quot;</p>
<p>          android:entries=&quot;@array/hdmi_resolution_entries&quot;</p>
<p>          android:entryValues=&quot;@array/hdmi_resolution_values&quot;</p>
<p>          android:defaultValue=&quot;3&quot;/&gt;</p>
<p>packages\apps\Settings\res\xml\hdmi_settings_timeout.xml</p>
<p>&lt;ListPreference</p>
<p> android:key=&quot;hdmi_resolution&quot;</p>
<p>          android:title=&quot;@string/hdmi_resolution_title&quot;</p>
<p>          android:persistent=&quot;true&quot;</p>
<p> android:dependency=&quot;hdmi&quot;</p>
<p>          android:entries=&quot;@array/hdmi_resolution_entries&quot;</p>
<p>          android:entryValues=&quot;@array/hdmi_resolution_values&quot;</p>
<p>          android:defaultValue=&quot;3&quot;/&gt;</p>
<p>packages\apps\Settings\src\com\android\settings\HdmiReceiver.java</p>
<p>   SharedPreferences preferences = context.getSharedPreferences(&quot;Settings&quot;, context.MODE_PRIVATE);</p>
<p>            int enable = preferences.getInt(&quot;enable&quot;, 1);</p>
<p>int resol = preferences.getInt(&quot;resolution&quot;, 3); //2 改成 3</p>
<p>设置   显示 添加 从不休眠  选项</p>
<p>packages\apps\Settings\res\values\strings.xml</p>
<ul>
<li>&lt;string name=&quot;nevertimeout&quot;&gt;Never timeout &lt;/string&gt;</li>
</ul>
<p>packages\apps\Settings\res\values-zh-rCN\strings.xml</p>
<ul>
<li>&lt;string name=&quot;nevertimeout&quot;&gt;永不休眠&lt;/string&gt;</li>
</ul>
<p>packages\apps\Settings\res\xml\display_settings.xml</p>
<p>把</p>
<p>        &lt;ListPreference</p>
<p>                android:key=&quot;screen_timeout&quot;</p>
<p>                android:title=&quot;@string/screen_timeout&quot;</p>
<p>                android:summary=&quot;@string/screen_timeout_summary&quot;</p>
<p>                android:persistent=&quot;false&quot;</p>
<p>                android:entries=&quot;@array/screen_timeout_entries&quot;</p>
<p>                android:entryValues=&quot;@array/screen_timeout_values&quot; /&gt;</p>
<p>改成</p>
<p>        &lt;ListPreference</p>
<p>                android:key=&quot;screen_timeout&quot;</p>
<p>                android:title=&quot;@string/screen_timeout&quot;</p>
<p>                android:summary=&quot;@string/screen_timeout_summary&quot;</p>
<p>                android:persistent=&quot;false&quot;</p>
<p>                android:entries=&quot;@array/dream_timeout_entries&quot;</p>
<p>                android:entryValues=&quot;@array/dream_timeout_values&quot; /&gt;</p>
<p>packages\apps\Settings\src\com\android\settings\DisplaySettings.java</p>
<p>        mScreenTimeoutPreference = (ListPreference) findPreference(KEY_SCREEN_TIMEOUT);</p>
<p>        final long currentTimeout = Settings.System.getLong(resolver, SCREEN_OFF_TIMEOUT,</p>
<p>                FALLBACK_SCREEN_TIMEOUT_VALUE);</p>
<ul>
<li><p>       if(currentTimeout &gt; 1800000)</p>
</li>
<li><p>mScreenTimeoutPreference.setValue(String.valueOf(0));</p>
</li>
<li><p>else</p>
</li>
</ul>
<p>mScreenTimeoutPreference.setValue(String.valueOf(currentTimeout));</p>
<p>            } else {</p>
<p>                int best = 0;</p>
<p>                for (int i = 0; i &lt; values.length; i++) {</p>
<p>                    long timeout = Long.parseLong(values[i].toString());</p>
<p>                    if (currentTimeout &gt;= timeout) {</p>
<p>                        best = i;</p>
<p>                    }</p>
<p>                }</p>
<ul>
<li><p>if(currentTimeout &gt; 1800000 || currentTimeout &lt;=0){     </p>
</li>
<li><p>summary = preference.getContext().getString(R.string.nevertimeout ,&quot;&quot;);</p>
</li>
<li><p>}</p>
</li>
<li><p>else</p>
</li>
</ul>
<p>                summary = preference.getContext().getString(R.string.screen_timeout_summary,</p>
<p>                        entries[best]);</p>
<p>    public boolean onPreferenceChange(Preference preference, Object objValue) {</p>
<p>        final String key = preference.getKey();</p>
<p>        if (KEY_SCREEN_TIMEOUT.equals(key)) {</p>
<p>            int value = Integer.parseInt((String) objValue);</p>
<p>            try {</p>
<ul>
<li><p>if(value &lt;= 0)</p>
</li>
<li><p>Settings.System.putInt(getContentResolver(), SCREEN_OFF_TIMEOUT, Integer.MAX_VALUE);</p>
</li>
<li><p>else</p>
</li>
</ul>
<p>                Settings.System.putInt(getContentResolver(), SCREEN_OFF_TIMEOUT, value);</p>
<p>hdmi 添加中文  屏幕休眠</p>
<p>packages\apps\Settings\res\values-zh-rCN\arrays.xml</p>
<p>  &lt;string-array name=&quot;security_settings_premium_sms_values&quot;&gt;</p>
<p>    &lt;item msgid=&quot;7389829271787670252&quot;&gt;&quot;询问&quot;&lt;/item&gt;</p>
<p>    &lt;item msgid=&quot;5077768429488260031&quot;&gt;&quot;永不允许&quot;&lt;/item&gt;</p>
<p>    &lt;item msgid=&quot;1417929597727989746&quot;&gt;&quot;始终允许&quot;&lt;/item&gt;</p>
<p>  &lt;/string-array&gt;</p>
<ul>
<li><p> &lt;string-array name=&quot;hdmi_lcd_timeout_entries&quot;&gt;</p>
</li>
<li><p>      &lt;item&gt;10秒&lt;/item&gt;</p>
</li>
</ul>
<p> +      &lt;item&gt;20秒&lt;/item&gt;</p>
<p> +      &lt;item&gt;30秒&lt;/item&gt;</p>
<p> +     &lt;item&gt;永不休眠&lt;/item&gt;</p>
<ul>
<li>&lt;/string-array&gt;</li>
</ul>
<p>修改应用程序列表 背景半透明</p>
<p>diff –git a/res/layout/apps_customize_pane.xml b/res/layout/apps_customize_pane.xml</p>
<p>index 41ba9e2..cbdd76b 100644</p>
<p>— a/res/layout/apps_customize_pane.xml</p>
<p>+++ b/res/layout/apps_customize_pane.xml</p>
<p>@@ -16,14 +16,15 @@</p>
<p> &lt;com.android.launcher2.AppsCustomizeTabHost</p>
<p>     xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;</p>
<p>     xmlns:launcher=&quot;<a href="http://schemas.android.com/apk/res/com.android.launcher">http://schemas.android.com/apk/res/com.android.launcher</a>&quot;</p>
<ul>
<li>   android:background=&quot;#FF000000&quot;&gt;</li>
</ul>
<ul>
<li>   android:background=&quot;#00000000&quot;&gt;</li>
</ul>
<p>     &lt;LinearLayout</p>
<p>         android:id=&quot;@+id/apps_customize_content&quot;</p>
<p>         android:orientation=&quot;vertical&quot;</p>
<p>         android:layout_width=&quot;match_parent&quot;</p>
<p>         android:layout_height=&quot;match_parent&quot;</p>
<p>         android:visibility=&quot;gone&quot;</p>
<ul>
<li>       android:layoutDirection=&quot;ltr&quot;&gt;</li>
</ul>
<ul>
<li><p>       android:layoutDirection=&quot;ltr&quot;</p>
</li>
<li><p>       android:background=&quot;#00000000&quot;&gt;</p>
</li>
</ul>
<p>         &lt;!– The layout_width of the tab bar gets overriden to align the content</p>
<p>              with the text in the tabs in AppsCustomizeTabHost. –&gt;</p>
<p>         &lt;FrameLayout</p>
<p>@@ -31,7 +32,8 @@</p>
<p>             android:layout_width=&quot;wrap_content&quot;</p>
<p>             android:layout_height=&quot;@dimen/apps_customize_tab_bar_height&quot;</p>
<p>             android:layout_marginTop=&quot;@dimen/apps_customize_tab_bar_margin_top&quot;</p>
<ul>
<li>           android:layout_gravity=&quot;center_horizontal&quot;&gt;</li>
</ul>
<ul>
<li><p>           android:layout_gravity=&quot;center_horizontal&quot;</p>
</li>
<li><p>           &gt;</p>
</li>
</ul>
<p>             &lt;com.android.launcher2.FocusOnlyTabWidget</p>
<p>                 android:id=&quot;@android:id/tabs&quot;</p>
<p>                 android:layout_width=&quot;match_parent&quot;</p>
<p>……..</p>
<p> &lt;FrameLayout</p>
<p>                android:id=&quot;@+id/animation_buffer&quot;</p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;match_parent&quot;</p>
<ul>
<li>               android:background=&quot;#50000000&quot;</li>
</ul>
<p>                android:visibility=&quot;gone&quot; /&gt;</p>
<p>diff –git a/src/com/android/launcher2/Launcher.java b/src/com/android/launcher2/Launcher.java</p>
<p>index a4ed91f..4da8632 100644</p>
<p>— a/src/com/android/launcher2/Launcher.java</p>
<p>+++ b/src/com/android/launcher2/Launcher.java</p>
<p>@@ -722,6 +722,7 @@ public final class Launcher extends Activity</p>
<p>         if (mOnResumeState == State.WORKSPACE) {</p>
<p>             showWorkspace(false);</p>
<p>         } else if (mOnResumeState == State.APPS_CUSTOMIZE) {</p>
<ul>
<li>           Log.d(&quot;Launcher&quot;,&quot;onResume APPS_CUSTOMIZE&quot;);</li>
</ul>
<p>             showAllApps(false);</p>
<p>         }</p>
<p>         mOnResumeState = State.NONE;</p>
<p>@@ -2386,7 +2387,7 @@ public final class Launcher extends Activity</p>
<p>         if (isAllAppsVisible()) {</p>
<p>             if (mAppsCustomizeTabHost != null &amp;&amp;</p>
<p>                     !mAppsCustomizeTabHost.isTransitioning()) {</p>
<ul>
<li>               updateWallpaperVisibility(false);</li>
</ul>
<ul>
<li>               updateWallpaperVisibility(true);</li>
</ul>
<p>             }</p>
<p>         }</p>
<p>     }</p>
<p>@@ -2558,7 +2559,8 @@ public final class Launcher extends Activity</p>
<p>                         hideDockDivider();</p>
<p>                     }</p>
<p>                     if (!animationCancelled) {</p>
<ul>
<li>                       updateWallpaperVisibility(false);</li>
</ul>
<ul>
<li><p>                       //modify by dzy for wallpaper visibility</p>
</li>
<li><p>                       updateWallpaperVisibility(true);</p>
</li>
</ul>
<p>                     }</p>
<p>                     // Hide the search bar</p>
<p>@@ -2650,7 +2652,8 @@ public final class Launcher extends Activity</p>
<p>             dispatchOnLauncherTransitionPrepare(toView, animated, false);</p>
<p>             dispatchOnLauncherTransitionStart(toView, animated, false);</p>
<p>             dispatchOnLauncherTransitionEnd(toView, animated, false);</p>
<ul>
<li>           updateWallpaperVisibility(false);</li>
</ul>
<ul>
<li><p>           //modify by dzy for wallpaper visible</p>
</li>
<li><p>           updateWallpaperVisibility(true);</p>
</li>
</ul>
<p>         }</p>
<p>     }</p>
<p>截图方向</p>
<p>frameworks\base\packages\SystemUI\src\com\android\systemui\screenshot\GlobalScreenshot.java</p>
<p>private float getDegreesForRotation(int value) {</p>
<p>        if (mHardwareRotation % 2 != 0) {</p>
<p>            value = (value + mHardwareRotation) % 4;</p>
<p>        }</p>
<p>Log.d(&quot;AAA&quot;,&quot;———-value+=:&quot;+value);</p>
<p>        switch (value) {</p>
<p>        case Surface.ROTATION_90:</p>
<p>            //return 360f - 90f;</p>
<p>            return 360f - 270f;</p>
<p>        case Surface.ROTATION_180:</p>
<p>           // return 360f - 180f;</p>
<p>           return 0f;</p>
<p>        case Surface.ROTATION_270:</p>
<p>            //return 360f - 270f;</p>
<p>            return 360f - 90f;</p>
<p>        }</p>
<p>       // return 0f;</p>
<p>       return 360f - 180f;</p>
<p>    }</p>
<p>修改 状态栏 12小时 时间显示am  pm</p>
<p>frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\policy\Clock.java</p>
<p>private static final int AM_PM_STYLE_NORMAL  = 0;</p>
<p>    private static final int AM_PM_STYLE_SMALL   = 1;</p>
<p>    private static final int AM_PM_STYLE_GONE    = 2;</p>
<p>    private static final int AM_PM_STYLE = AM_PM_STYLE_NORMAL;//AM_PM_STYLE_GONE;</p>
<p>修改锁屏时间显示 am  pm</p>
<p>diff –git a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/ClockView.java b/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/</p>
<p>index 6c701c7..760b608 100755</p>
<p>— a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/ClockView.java</p>
<p>+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/ClockView.java</p>
<p>@@ -35,13 +35,15 @@ import java.lang.ref.WeakReference;</p>
<p> import java.text.DateFormatSymbols;</p>
<p> import java.util.Calendar;</p>
<p> import com.android.internal.R;</p>
<p>-</p>
<p>+import android.util.Log;</p>
<p> /**</p>
<p>  * Displays the time</p>
<p>  */</p>
<p> public class ClockView extends RelativeLayout {</p>
<ul>
<li><p>   private static final String ANDROID_CLOCK_FONT_FILE = &quot;/system/fonts/AndroidClock.ttf&quot;;</p>
</li>
<li><p>   private final static String M12 = &quot;h:mm&quot;;</p>
</li>
</ul>
<p>+//    private static final String ANDROID_CLOCK_FONT_FILE = &quot;/system/fonts/AndroidClock.ttf&quot;;</p>
<ul>
<li>private static final String ANDROID_CLOCK_FONT_FILE = &quot;/system/fonts/DroidSansFallback.ttf&quot;;</li>
</ul>
<p>+//    private final static String M12 = &quot;h:mm&quot;;</p>
<p>+private final static String M12 = &quot;h:mmaa&quot;;</p>
<p>     private final static String M24 = &quot;kk:mm&quot;;</p>
<p>     private Calendar mCalendar;</p>
<p>@@ -154,6 +156,9 @@ public class ClockView extends RelativeLayout {</p>
<p>     protected void onFinishInflate() {</p>
<p>         super.onFinishInflate();</p>
<p>         mTimeView = (TextView) findViewById(R.id.clock_text);</p>
<ul>
<li>       mTimeView.setTextSize(mTimeView.getTextSize()-120);   </li>
</ul>
<p>         mTimeView.setTypeface(Typeface.createFromFile(ANDROID_CLOCK_FONT_FILE));</p>
<p>         mAmPm = new AmPm(this, null);</p>
<p>         mCalendar = Calendar.getInstance();</p>
<p>@@ -209,12 +214,11 @@ public class ClockView extends RelativeLayout {</p>
<p>         updateTime();</p>
<p>     }</p>
<p>机器关机充电电池百分比</p>
<p>system\core\charger\charger.c</p>
<ul>
<li>int batt_per = 10;</li>
</ul>
<p>static void draw_battery(struct charger *charger)</p>
<p>{</p>
<p>    struct animation *batt_anim = charger-&gt;batt_anim;</p>
<p>    struct frame *frame = &amp;batt_anim-&gt;frames[batt_anim-&gt;cur_frame];</p>
<ul>
<li>char str[4]={0};</li>
</ul>
<p>    if (batt_anim-&gt;num_frames != 0) {</p>
<p>        draw_surface_centered(charger, frame-&gt;surface);</p>
<p>        LOGV(&quot;drawing frame #%d name=%s min_cap=%d time=%d\n&quot;,</p>
<p>             batt_anim-&gt;cur_frame, frame-&gt;name, frame-&gt;min_capacity,</p>
<p>             frame-&gt;disp_time);</p>
<p>   +          batt_per = batt_per - 1;</p>
<p>    +         if(batt_per == 0)</p>
<p>     +         {</p>
<p>      +     sprintf(str,&quot;%d%%&quot;,batt_anim-&gt;capacity);     </p>
<p>        +                      gr_color(127,255,0,255); </p>
<p>          +                    draw_text(str, 385, 550);</p>
<p>            +                  batt_per = 1;</p>
<p>              +              }</p>
<p>    }</p>
<p>}</p>
<p>机器的右上角显示电池百分比</p>
<p> diff –git a/frameworks/base/packages/SystemUI/res/layout/status_bar.xml b/frameworks/base/packages/SystemUI/res/layout/status_bar.xml<br>index bf20e9d..c686e95 100644<br>— a/frameworks/base/packages/SystemUI/res/layout/status_bar.xml<br>+++ b/frameworks/base/packages/SystemUI/res/layout/status_bar.xml<br>@@ -100,7 +100,17 @@<br>                     android:layout_height=&quot;wrap_content&quot;<br>                     android:layout_width=&quot;wrap_content&quot;<br>                     android:paddingLeft=&quot;4dip&quot;<br>-                    /&gt;<br>+                   /&gt;<br>+               &lt;TextView<br>+                android:id=&quot;@+id/battery_text&quot;<br>+                android:textAppearance=&quot;@style/TextAppearance.StatusBar.Clock&quot;<br>+                android:layout_width=&quot;wrap_content&quot;<br>+                android:layout_height=&quot;wrap_content&quot;<br>+                android:layout_gravity=&quot;left|center_vertical&quot;<br>+                android:paddingRight=&quot;2dp&quot;<br>+                android:singleLine=&quot;true&quot;<br>+                android:text=&quot;@string/status_bar_settings_settings_button&quot;<br>+                /&gt;<br>             &lt;/LinearLayout&gt;<br>             &lt;com.android.systemui.statusbar.policy.Clock<br>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/stat<br>index 7f92e75..4513a3b 100755<br>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java<br>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java<br>@@ -629,6 +629,7 @@ public class PhoneStatusBar extends BaseStatusBar {<br>         mLocationController = new LocationController(mContext); // will post a notification<br>         mBatteryController = new BatteryController(mContext);<br>         mBatteryController.addIconView((ImageView)mStatusBarView.findViewById(R.id.battery));<br>+               mBatteryController.addLabelView((TextView)mStatusBarView.findViewById(R.id.battery_text));<br>         mNetworkController = new NetworkController(mContext);<br>         mBluetoothController = new BluetoothController(mContext);<br>         final SignalClusterView signalCluster =</p>
<p>android4.2 Launcher2界面两边的渐变的去除方法</p>
<p>diff –git a/packages/apps/Launcher2/res/layout-sw720dp/launcher.xml b/packages/apps/Launcher2/res/layout-sw720dp/launcher.xml</p>
<p>old mode 100644</p>
<p>new mode 100755</p>
<p>index 81a8f37..1ed2fcf</p>
<p>— a/packages/apps/Launcher2/res/layout-sw720dp/launcher.xml</p>
<p>+++ b/packages/apps/Launcher2/res/layout-sw720dp/launcher.xml</p>
<p>@@ -21,15 +21,13 @@</p>
<p>     android:id=&quot;@+id/launcher&quot;</p>
<p>     android:layout_width=&quot;match_parent&quot;</p>
<ul>
<li><p>   android:layout_height=&quot;match_parent&quot;</p>
</li>
<li><p>   android:background=&quot;@drawable/workspace_bg&quot;&gt;</p>
</li>
</ul>
<ul>
<li>   android:layout_height=&quot;match_parent&quot;&gt;</li>
</ul>
<p>     &lt;com.android.launcher2.DragLayer</p>
<p>         xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;</p>
<p>         xmlns:launcher=&quot;<a href="http://schemas.android.com/apk/res/com.android.launcher">http://schemas.android.com/apk/res/com.android.launcher</a>&quot;</p>
<p>         android:id=&quot;@+id/drag_layer&quot;</p>
<ul>
<li>       android:background=&quot;@drawable/workspace_bg&quot;</li>
</ul>
<p>         android:layout_width=&quot;match_parent&quot;</p>
<p>         android:layout_height=&quot;match_parent&quot;</p>
<p>         android:fitsSystemWindows=&quot;true&quot;&gt;</p>
<p>diff –git a/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java b/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>index 9aa3d3d..2d01118 100755</p>
<p>— a/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>+++ b/packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p>
<p>    private void setWorkspaceBackground(boolean workspace) {</p>
<ul>
<li><p>       mLauncherView.setBackground(workspace ?</p>
</li>
<li><p>               mWorkspaceBackgroundDrawable : mBlackBackgroundDrawable);</p>
</li>
</ul>
<ul>
<li><p>     //  mLauncherView.setBackground(workspace ?</p>
</li>
<li><p>     //          mWorkspaceBackgroundDrawable : mBlackBackgroundDrawable);</p>
</li>
</ul>
<p>     }</p>
<p>设置  –  电池 — 无法获取使用数据</p>
<p>packages\apps\Settings\src\com\android\settings\fuelgauge\PowerUsageSummary.java</p>
<p>        if (mPowerProfile.getAveragePower(PowerProfile.POWER_SCREEN_FULL) &lt; 0) {</p>
<p>拔掉耳机音乐停止 或者 拔掉hdmi  音乐停止</p>
<p>packages\apps\Music\AndroidManifest.xml</p>
<p>这可能发生在当一个用户用耳机听音乐时忽然断开了耳机连接．音频从扬声器播放可能不是用户期望的．</p>
<p>你可以通过处理ACTION_AUDIO_BECOMING_NOISYintent 来保证你的应用在此情况下停止播放音乐</p>
<p> &lt;action android:name=&quot;android.media.AUDIO_BECOMING_NOISY&quot; /&gt;</p>
<p>去掉屏幕唤醒时的背景（对焦）</p>
<p>diff –git a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardWidgetFrame.java b/frameworks/base/policy/src/com/android/internal/policy/impl/keyg</p>
<p>index babb9cb..550a793 100644</p>
<p>— a/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardWidgetFrame.java</p>
<p>+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/keyguard/KeyguardWidgetFrame.java</p>
<p>@@ -236,7 +236,7 @@ public class KeyguardWidgetFrame extends FrameLayout {</p>
<p>         if (ENABLE_HOVER_OVER_DELETE_DROP_TARGET_OVERLAY) {</p>
<p>             canvas.save();</p>
<p>         }</p>
<ul>
<li>       drawBg(canvas);</li>
</ul>
<ul>
<li>       //drawBg(canvas);</li>
</ul>
<p>         super.dispatchDraw(canvas);</p>
<p>         drawGradientOverlay(canvas);</p>
<p>         if (ENABLE_HOVER_OVER_DELETE_DROP_TARGET_OVERLAY) {</p>
<p>(END)</p>
<p>音乐播放   超过两秒之后 点击  上一曲 就是上一曲而不是本曲的开头</p>
<p>packages\apps\Music\src\com\android\music\MediaPlaybackActivity.java</p>
<p>    private View.OnClickListener mPrevListener = new View.OnClickListener() {</p>
<p>        public void onClick(View v) {</p>
<p>            if (mService == null) return;</p>
<p>            try {</p>
<p>             -                   if (mService.position() &lt; 2000) {</p>
<p>      +      if (true){</p>
<p>      + if(mService.getRepeatMode() == 1){</p>
<p>      + mService.seek(0);</p>
<p>      +           mService.play();</p>
<p>      + }else{</p>
<p>                    mService.prev();</p>
<p>      + }</p>
<p>                } else {</p>
<p>                    mService.seek(0);</p>
<p>                    mService.play();</p>
<p>packages\apps\Music\src\com\android\music\MediaPlaybackService.java</p>
<p>    public int onStartCommand(Intent intent, int flags, int startId) {</p>
<p>        mServiceStartId = startId;</p>
<p>        mDelayedStopHandler.removeCallbacksAndMessages(null);</p>
<p>        if (intent != null) {</p>
<p>            String action = intent.getAction();</p>
<p>            String cmd = intent.getStringExtra(&quot;command&quot;);</p>
<p>            MusicUtils.debugLog(&quot;onStartCommand &quot; + action + &quot; / &quot; + cmd);</p>
<p>            if (CMDNEXT.equals(cmd) || NEXT_ACTION.equals(action)) {</p>
<p>                gotoNext(true);</p>
<p>            } else if (CMDPREVIOUS.equals(cmd) || PREVIOUS_ACTION.equals(action)) {</p>
<p>                -   position() &lt; 2000) {</p>
<p>                +  if (true){</p>
<p>拔tf卡时 如果是本机音乐  音乐不停止播放</p>
<p>packages\apps\Music\src\com\android\music\MediaPlaybackActivity.java</p>
<ul>
<li>  import android.content.SharedPreferences;</li>
</ul>
<p>    private ServiceConnection osc = new ServiceConnection() {</p>
<p>            public void onServiceConnected(ComponentName classname, IBinder obj) {</p>
<p>                mService = IMediaPlaybackService.Stub.asInterface(obj);</p>
<p>                startPlayback();</p>
<p>                try {</p>
<p>                    // Assume something is playing when the service says it is,</p>
<p>                    // but also if the audio ID is valid but the service is paused.</p>
<p>                    if (mService.getAudioId() &gt;= 0 || mService.isPlaying() ||</p>
<p>                            mService.getPath() != null) {</p>
<p>//加上下面一段代码</p>
<p>//get the current music ‘s real path </p>
<p>if(mService.getPath() != null){</p>
<p>                Uri uri = Uri.parse(mService.getPath());</p>
<p>ContentResolver cr = getContentResolver();  </p>
<p>                         Cursor c = cr.query(uri, null, null, null, null);</p>
<p>                         String strPath = null;</p>
<p>                         if(c != null)</p>
<p>                         {</p>
<p>                                while(c.moveToNext())</p>
<p>                                 {</p>
<p>                                         strPath = c.getString(1);</p>
<p>                                         break;</p>
<p>                                }</p>
<p>                                c.close();</p>
<p>                        }</p>
<p>if(strPath != null)</p>
<p>                         {</p>
<p>                                 SharedPreferences pf = getSharedPreferences(&quot;current&quot;, 0);</p>
<p>                                 SharedPreferences.Editor editor = pf.edit();</p>
<p>                                 editor.putString(&quot;CurrentMusic&quot;, strPath);</p>
<p>                                 editor.commit();</p>
<p>                         }</p>
<p>}</p>
<p>                //   Log.d(&quot;edward&quot;,&quot;DisplayPath:=&quot;+strPath);</p>
<p>//结束</p>
<p>packages\apps\Music\src\com\android\music\MediaPlaybackService.java</p>
<p>    public void closeExternalStorageFiles(String storagePath) {</p>
<p>        // stop playback and clean up if the SD card is going to be unmounted.</p>
<p>       // Log.d(&quot;edward&quot;,&quot;storagePath:=&quot;+storagePath);</p>
<p> //加以下代码      </p>
<p>        SharedPreferences spf = getSharedPreferences(&quot;current&quot;, 0);</p>
<p>              String music = spf.getString(&quot;CurrentMusic&quot;, &quot;null&quot;);</p>
<p>               if(!music.contains(storagePath))</p>
<p>               {</p>
<p>                       return;</p>
<p>               }</p>
<p>//结束</p>
<p>        stop(true);</p>
<p>if (mPlayer != null)</p>
<p>hdmi  休眠 背光修改</p>
<p>kernel\arch\arm\mach-rk30\board-rk3168-86v.c</p>
<p>static struct rk29_bl_info rk29_bl_info = {</p>
<p>  .min_brightness = 0,     </p>
<p>frameworks\base\core\res\res\values\config.xml</p>
<p>&lt;integer name=&quot;config_screenBrightnessSettingMinimum&quot;&gt;0&lt;/integer&gt;</p>
<p>packages\apps\Settings\src\com\android\settings\BrightnessPreference.java</p>
<p>public BrightnessPreference(Context context, AttributeSet attrs) {</p>
<p>        super(context, attrs);</p>
<p>        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</p>
<ul>
<li>     //  mScreenBrightnessMinimum = pm.getMinimumScreenBrightnessSetting();</li>
</ul>
<p> +     mScreenBrightnessMinimum = pm.getMinimumScreenBrightnessSetting() + 45;</p>
<p>frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\policy\BrightnessController.java</p>
<p>mMinimumBacklight = pm.getMinimumScreenBrightnessSetting() + 45;</p>
<p>packages\apps\Settings\src\com\android\settings\widget\SettingsAppWidgetProvider.java</p>
<p>if (brightnessMode == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {</p>
<p>      -        //      brightness = pm.getMinimumScreenBrightnessSetting();</p>
<p>       +                 brightness = pm.getMinimumScreenBrightnessSetting();</p>
<p>                    brightnessMode = Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL;</p>
<p>                } else if (brightness &lt; pm.getDefaultScreenBrightnessSetting()) {</p>
<p>                    brightness = pm.getDefaultScreenBrightnessSetting();</p>
<p>                } else if (brightness &lt; pm.getMaximumScreenBrightnessSetting()) {</p>
<p>                    brightness = pm.getMaximumScreenBrightnessSetting();</p>
<p>                } else {</p>
<p>                    brightnessMode = Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC;</p>
<p>          -    //     brightness = pm.getMinimumScreenBrightnessSetting();</p>
<p>           +         brightness = pm.getMinimumScreenBrightnessSetting();</p>
<p>                }</p>
<p>单屏模式 壁纸不滚动</p>
<p>packages/apps/Launcher2/src/com/android/launcher2/Workspace.java</p>
<p>final boolean enableWallpaperEffects = isHardwareAccelerated();<br>改成：<br>final boolean enableWallpaperEffects = false;</p>
<p>客户的壁纸是1280 x 1280为了确保壁纸不被放大 显得模糊</p>
<p>packages\apps\Launcher2\src\com\android\launcher2\Workspace.java</p>
<p> protected void setWallpaperDimension() {</p>
<p>…….</p>
<p>if (LauncherApplication.isScreenLarge()) {</p>
<p>            mWallpaperWidth = 1280;//(int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));</p>
<p>            mWallpaperHeight = maxDim;</p>
<p>        } else {</p>
<p>8846 pmu 关机有时开不起来</p>
<p>kernel\arch\arm\mach-rk30\board-rk3168-86v.c</p>
<p>static void rk30_pm_power_off(void)</p>
<p>{</p>
<p>/<em>yu del</em>/ //act8846_device_shutdown();</p>
<p>修改应用程序背景—–加统一的背景托盘</p>
<p>packages\apps\Launcher2\src\com\android\launcher2\Utilities.java</p>
<p>import android.graphics.BitmapFactory;</p>
<p>import android.graphics.Matrix; </p>
<p>static Bitmap createIconBitmap(Drawable icon, Context context) {</p>
<p>…….</p>
<p>final boolean debug = false;</p>
<p>            if (debug) {</p>
<p>                // draw a big box for the icon for debugging</p>
<p>                canvas.drawColor(sColors[sColorIndex]);</p>
<p>                if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;</p>
<p>                Paint debugPaint = new Paint();</p>
<p>                debugPaint.setColor(0xffcccc00);</p>
<p>                canvas.drawRect(left, top, left+width, top+height, debugPaint);</p>
<p>            }</p>
<p>//yu add</p>
<p>if (true) </p>
<p>            {</p>
<p>                Bitmap backBitmap = BitmapFactory.decodeResource(context.getResources(),</p>
<p>                        R.drawable.icon_blue_bg);</p>
<p>                int backWidth = backBitmap.getWidth();</p>
<p>                int backHeight = backBitmap.getHeight();</p>
<p>                if(backWidth != sIconWidth || backHeight != sIconHeight)</p>
<p>                {</p>
<p>                    Matrix matrix = new Matrix();</p>
<p>                    matrix.postScale((float)sIconWidth/backWidth, (float)sIconHeight/backHeight);</p>
<p>                    canvas.drawBitmap(Bitmap.createBitmap(backBitmap, 0, 0, backWidth, backHeight, matrix, true),</p>
<p>                            0.0f, 0.0f, null);</p>
<p>                }else</p>
<p>                {</p>
<p>                    canvas.drawBitmap(backBitmap, 0.0f, 0.0f, null);</p>
<p>                }</p>
<p>            }</p>
<p>//yu add end</p>
<p>            sOldBounds.set(icon.getBounds());</p>
<p>            icon.setBounds(left, top, left+width, top+height);</p>
<p>            icon.draw(canvas);</p>
<p>            icon.setBounds(sOldBounds);</p>
<p>            canvas.setBitmap(null);</p>
<p>            return bitmap;</p>
<p>        }</p>
<p> 设置—Andriod键盘设置—高级设置–按键音量设置显示“-100”</p>
<p>packages\inputmethods\LatinIME\java\src\com\android\inputmethod\latin\SettingsValues.java</p>
<p>public static float getCurrentKeypressSoundVolume(final SharedPreferences prefs,</p>
<p>            final Resources res) {</p>
<p>        // TODO: use mVibrationDurationSettingsRawValue instead of reading it again here</p>
<p>        final float volume = prefs.getFloat(Settings.PREF_KEYPRESS_SOUND_VOLUME, -1.0f);</p>
<p>        if (volume &gt;= 0) {</p>
<p>            return volume;</p>
<p>        }</p>
<ul>
<li><p>if (volume &lt; 0) {</p>
</li>
<li><p>           return 0;</p>
</li>
</ul>
<p>  +      }</p>
<p>        return Float.parseFloat(ResourceUtils.getDeviceOverrideValue(</p>
<p>                res, R.array.keypress_volumes, &quot;-1.0f&quot;));</p>
<p>    }</p>
<p>取消长按home功能（相对应的statusbar/phone/phoneStatusBar.java也有此功能 ）</p>
<p>diff –git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java b/frameworks/base/packages/SystemUI/src/com/android/system</p>
<p>index 66bba81..22da1cd 100755</p>
<p>— a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java</p>
<p>@@ -212,15 +212,15 @@ public class TabletStatusBar extends BaseStatusBar implements</p>
<p>         public boolean onTouch(View v, MotionEvent event) {</p>
<p>             switch(event.getAction()) {</p>
<p>                 case MotionEvent.ACTION_DOWN:</p>
<ul>
<li><p>                   if (!shouldDisableNavbarGestures() &amp;&amp; !inKeyguardRestrictedInputMode()) {</p>
</li>
<li><p>                       mHandler.removeCallbacks(mShowSearchPanel);</p>
</li>
<li><p>                       mHandler.postDelayed(mShowSearchPanel, mShowSearchHoldoff);</p>
</li>
<li><p>                   }</p>
</li>
</ul>
<ul>
<li><p>                //   if (!shouldDisableNavbarGestures() &amp;&amp; !inKeyguardRestrictedInputMode()) {</p>
</li>
<li><p>                //       mHandler.removeCallbacks(mShowSearchPanel);</p>
</li>
<li><p>                //       mHandler.postDelayed(mShowSearchPanel, mShowSearchHoldoff);</p>
</li>
<li><p>                //   }</p>
</li>
</ul>
<p>                 break;</p>
<p>                 case MotionEvent.ACTION_UP:</p>
<p>                 case MotionEvent.ACTION_CANCEL:</p>
<ul>
<li>                   mHandler.removeCallbacks(mShowSearchPanel);</li>
</ul>
<ul>
<li>               //    mHandler.removeCallbacks(mShowSearchPanel);</li>
</ul>
<p>                 break;</p>
<p>             }</p>
<p>             return false;</p>
<p>添加3g dongle 支持列表</p>
<p>packages\apps\Settings\res\xml\wireless_settings.xml</p>
<p>&lt;PreferenceScreen</p>
<p>android:key=&quot;_3g_dongle_supportlists&quot;</p>
<p>android:title=&quot;@string/_3g_dongle_supportlist&quot;&gt;</p>
<p>       &lt;/PreferenceScreen&gt;</p>
<p>packages\apps\Settings\res\values\string.xml</p>
<p>&lt;string name=&quot;_3g_dongle_supportlist&quot; translatable=&quot;false&quot;&gt;3G dongle support list&lt;/string&gt;</p>
<p>packages\apps\Settings\src\com\android\settings\WirelessSettings.java</p>
<p>+import android.net.Uri;</p>
<p>+import java.io.File;</p>
<p>+import android.util.Log;</p>
<p>    private static final String KEY_MOBILE_NETWORK_SETTINGS = &quot;mobile_network_settings&quot;;</p>
<p>    private static final String KEY_TOGGLE_NSD = &quot;toggle_nsd&quot;; //network service discovery</p>
<p>    private static final String KEY_CELL_BROADCAST_SETTINGS = &quot;cell_broadcast_settings&quot;;</p>
<p>    private static final String KEY_ETHERNET_SETTINGS = &quot;ethernet_settings&quot;;</p>
<ul>
<li>private static final String KEY_3G_DONGLE_SETTINGS = &quot;_3g_dongle_supportlists&quot;;</li>
</ul>
<p>    private NfcEnabler mNfcEnabler;</p>
<p>    private NfcAdapter mNfcAdapter;</p>
<p>    private NsdEnabler mNsdEnabler;</p>
<ul>
<li>private PreferenceScreen dongleSupport;</li>
</ul>
<p>    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {</p>
<p>        if (preference == mAirplaneModePreference &amp;&amp; Boolean.parseBoolean(</p>
<p>                SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {</p>
<p>            // In ECM mode launch ECM app dialog</p>
<p>            startActivityForResult(</p>
<p>                new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),</p>
<p>                REQUEST_CODE_EXIT_ECM);</p>
<p>            return true;</p>
<p>  +      }else if(preference == dongleSupport){</p>
<ul>
<li><p>Intent intent = new Intent();</p>
</li>
<li><p>     intent.setClassName(&quot;com.android.htmlviewer&quot;,&quot;com.android.htmlviewer.HTMLViewerActivity&quot;);</p>
</li>
<li><p>    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
</li>
<li><p>   Uri uri = Uri.fromFile(new File(&quot;/system/media/donglesupportlist.html&quot;));</p>
</li>
</ul>
<p> +   intent.setDataAndType(uri, &quot;text/plain&quot;);    </p>
<p>  +  getActivity().startActivity(intent);</p>
<p>}</p>
<p>    public void onCreate(Bundle savedInstanceState) {</p>
<p>        super.onCreate(savedInstanceState);</p>
<p>        mHasAirplane = false;</p>
<p>        mHasAirplane = getResources()</p>
<p>                .getBoolean(R.bool.config_airplane_capable);</p>
<p>        addPreferencesFromResource(R.xml.wireless_settings);        </p>
<p>        final Activity activity = getActivity();</p>
<p>        mAirplaneModePreference = (CheckBoxPreference) findPreference(KEY_TOGGLE_AIRPLANE);</p>
<p>        if(mHasAirplane) {</p>
<p>            findPreference(KEY_MOBILE_NETWORK_SETTINGS).setDependency(KEY_TOGGLE_AIRPLANE);</p>
<p>        } else {            </p>
<p>            getPreferenceScreen().removePreference(mAirplaneModePreference);</p>
<p>        }</p>
<p>        CheckBoxPreference nfc = (CheckBoxPreference) findPreference(KEY_TOGGLE_NFC);</p>
<p>        PreferenceScreen androidBeam = (PreferenceScreen) findPreference(KEY_ANDROID_BEAM_SETTINGS);</p>
<p>        CheckBoxPreference nsd = (CheckBoxPreference) findPreference(KEY_TOGGLE_NSD);</p>
<ul>
<li><p>   dongleSupport = (PreferenceScreen) findPreference(KEY_3G_DONGLE_SETTINGS);</p>
</li>
<li><p>String isShow = SystemProperties.get(&quot;ro.bx.dongleSupportList&quot;,&quot;false&quot;);</p>
</li>
<li><p>Log.d(&quot;edward&quot;,&quot;show dongleSupportList = &quot;+isShow);</p>
</li>
<li><p>if(isShow.equals(&quot;false&quot;)){</p>
</li>
<li><p>getPreferenceScreen().removePreference(dongleSupport);</p>
</li>
<li><p>}</p>
</li>
</ul>
<p>out\target\product\rk2928sdk\system\build.prop</p>
<p>ro.bx.dongleSupportList=true</p>
<p>上层反左右声道</p>
<p>\hardware\rk29\audio\alsa_pcm.c</p>
<p>#define LR_TO_RL  1</p>
<p>int pcm_write(struct pcm *pcm, void *data, unsigned count)</p>
<p>{</p>
<p>    struct snd_xferi x;</p>
<p>    if (pcm-&gt;flags &amp; PCM_IN)</p>
<p>        return -EINVAL;</p>
<p>    x.buf = data;</p>
<p>    x.frames = (pcm-&gt;flags &amp; PCM_MONO) ? (count / 2) : (count / 4); </p>
<p>//增加</p>
<p>#if LR_TO_RL</p>
<p>if(!(pcm-&gt;flags &amp; PCM_MONO))</p>
<p>{</p>
<p>short *leftCh = (short *)data; </p>
<p>short *rightCh = leftCh + 1;</p>
<p>int index = 0;</p>
<p>for( index = 0; index &lt; x.frames;index++)</p>
<p>{</p>
<p>*leftCh =  *leftCh ^ *rightCh;</p>
<p>*rightCh = *leftCh ^ *rightCh;</p>
<p>*leftCh = *leftCh ^ *rightCh;</p>
<p>leftCh++;</p>
<p>rightCh++;</p>
<p>}</p>
<p>}</p>
<p>#endif</p>
<p>修改默认蓝牙的名称</p>
<p>device\common\libbt_mtk6622\bdroid_buildcfg.h</p>
<p>或者</p>
<p>device\rockchip\rk30sdk\bluetooth\bdroid_buildcfg.h</p>
<p>#define BTM_DEF_LOCAL_NAME &quot;PH70DR8NSCN&quot;</p>
<p>以按键的方向为标准</p>
<p>修改竖屏游戏时 方向为靠近按键的方向</p>
<p>build.prop</p>
<p>ro.sf.fakerotation=false</p>
<p>ro.sf.hwrotation=0</p>
<p>修改插入hdmi 本机的方向</p>
<p>frameworks\base\policy\src\com\android\internal\policy\impl\PhoneWindowManager.java</p>
<p>else if (mHdmiPlugged &amp;&amp; mHdmiRotationLock) {</p>
<p>                // Ignore sensor when plugged into HDMI.</p>
<p>                // Note that the dock orientation overrides the HDMI orientation.</p>
<p>             /<em>yu add</em>/   mHdmiRotation = Surface.ROTATION_270;</p>
<p>                preferredRotation = mHdmiRotation;</p>
<p>                return mHdmiRotation;</p>
<p>…….</p>
<p>修改 横屏游戏时的方向</p>
<p> } else {</p>
<p>                // No overriding preference.</p>
<p>                // We will do exactly what the application asked us to do.</p>
<p>              //yu del  preferredRotation = -1;</p>
<p>                preferredRotation = Surface.ROTATION_270;</p>
<p>开机logo  为800 x1280</p>
<p>动画为 800 x1280   desc 800 1280</p>
<p>如果是使用默认  低电警告</p>
<p>kernel\drivers\video\fbmem.c</p>
<p>#ifdef CONFIG_LOGO_LOWERPOWER_WARNING</p>
<p>if(1 == get_battery_status()){</p>
<p>// image.dx = (info-&gt;var.xres/2)-(logo-&gt;width)/2;</p>
<p>// image.dy = (info-&gt;var.yres/2)-(logo-&gt;height)/2;</p>
<p>image.dy = (info-&gt;var.xres/2)-(logo-&gt;height)/2;</p>
<p>image.dx = (info-&gt;var.yres/2)-(logo-&gt;width)/2;</p>
<p>#ifdef CONFIG_LOGO_LOWERPOWER_WARNING</p>
<p>if(1 ==  get_battery_status()){</p>
<p>// y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,</p>
<p>//     1);</p>
<p>y = fb_show_logo_line(info, FB_ROTATE_CW, fb_logo.logo, 0,</p>
<p>    1);</p>
<p>}else{</p>
<p>如果竖屏状态下要显示竖屏的充电图标</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>driverspowerrk30_adc_battery</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/driverspowerrk30_adc_battery.c/</url>
    <content><![CDATA[<p>/* drivers/power/rk30_adc_battery.c</p>
<p> *</p>
<p> * battery detect driver for the rk30 </p>
<p> *</p>
<p> * This software is licensed under the terms of the GNU General Public</p>
<p> * License version 2, as published by the Free Software Foundation, and</p>
<p> * may be copied, distributed, and modified under those terms.</p>
<p> *</p>
<p> * This program is distributed in the hope that it will be useful,</p>
<p> * but WITHOUT ANY WARRANTY; without even the implied warranty of</p>
<p> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</p>
<p> * GNU General Public License for more details.</p>
<p> *</p>
<p> */</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/err.h&gt;</p>
<p>#include &lt;linux/platform_device.h&gt;</p>
<p>#include &lt;linux/power_supply.h&gt;</p>
<p>#include &lt;linux/regulator/consumer.h&gt;</p>
<p>#include &lt;linux/types.h&gt;</p>
<p>#include &lt;linux/pci.h&gt;</p>
<p>#include &lt;linux/interrupt.h&gt;</p>
<p>#include &lt;asm/io.h&gt;</p>
<p>#include &lt;asm/mach-types.h&gt;</p>
<p>#include &lt;asm/mach/arch.h&gt;</p>
<p>#include &lt;asm/mach/map.h&gt;</p>
<p>#include &lt;mach/gpio.h&gt;</p>
<p>#include &lt;linux/adc.h&gt;</p>
<p>#include &lt;mach/iomux.h&gt;</p>
<p>#include &lt;mach/board.h&gt;</p>
<p>#include &lt;linux/delay.h&gt;</p>
<p>#include &lt;linux/ktime.h&gt;</p>
<p>#include &lt;linux/slab.h&gt;</p>
<p>#include &lt;linux/syscalls.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/wakelock.h&gt;</p>
<p>#if 0</p>
<p>#define DBG(x…)   printk(x)</p>
<p>#else</p>
<p>#define DBG(x…)</p>
<p>#endif</p>
<p>static int rk30_battery_dbg_level = 2;</p>
<p>module_param_named(dbg_level, rk30_battery_dbg_level, int, 0644);</p>
<p>#define pr_bat( args…) \</p>
<p>do { \</p>
<p>if (rk30_battery_dbg_level) { \</p>
<p>pr_info(args); \</p>
<p>} \</p>
<p>} while (0)</p>
<p>/*<strong><strong><strong><strong>**</strong></strong></strong></strong>以下参数可以修改**<strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong>/</p>
<p>#define TIMER_MS_COUNTS 1000 //定时器的长度ms</p>
<p>//以下参数需要根据实际测试调整</p>
<p>#define SLOPE_SECOND_COUNTS               15 //统计电压斜率的时间间隔s</p>
<p>#define DISCHARGE_MIN_SECOND               45 //最快放电电1%时间</p>
<p>#define CHARGE_MIN_SECOND               45 //最快充电电1%时间</p>
<p>#define CHARGE_MID_SECOND               90 //普通充电电1%时间</p>
<p>#define CHARGE_MAX_SECOND               250 //最长充电电1%时间</p>
<p>#define   CHARGE_FULL_DELAY_TIMES          10          //充电满检测防抖时间</p>
<p>#define   USBCHARGE_IDENTIFY_TIMES        5           //插入USB混流，pc识别检测时间</p>
<p>#define NUM_VOLTAGE_SAMPLE                       ((SLOPE_SECOND_COUNTS * 1000) / TIMER_MS_COUNTS)  </p>
<p>#define NUM_DISCHARGE_MIN_SAMPLE         ((DISCHARGE_MIN_SECOND * 1000) / TIMER_MS_COUNTS)  </p>
<p>#define NUM_CHARGE_MIN_SAMPLE         ((CHARGE_MIN_SECOND * 1000) / TIMER_MS_COUNTS)    </p>
<p>#define NUM_CHARGE_MID_SAMPLE         ((CHARGE_MID_SECOND * 1000) / TIMER_MS_COUNTS)     </p>
<p>#define NUM_CHARGE_MAX_SAMPLE         ((CHARGE_MAX_SECOND * 1000) / TIMER_MS_COUNTS)  </p>
<p>#define   NUM_CHARGE_FULL_DELAY_TIMES         ((CHARGE_FULL_DELAY_TIMES * 1000) / TIMER_MS_COUNTS) //充电满状态持续时间长度</p>
<p>#define   NUM_USBCHARGE_IDENTIFY_TIMES      ((USBCHARGE_IDENTIFY_TIMES * 1000) / TIMER_MS_COUNTS) //充电满状态持续时间长度</p>
<p>#define   CHARGE_IS_OK                    1</p>
<p>#define   INVALID_CHARGE_CHECK               -1</p>
<p>#if defined(CONFIG_ARCH_RK3066B)</p>
<p>#define  BAT_DEFINE_VALUE                                     1800</p>
<p>#elif defined(CONFIG_ARCH_RK2928)</p>
<p>#define  BAT_DEFINE_VALUE                                                3300</p>
<p>#else</p>
<p>#define  BAT_DEFINE_VALUE                                     2500</p>
<p>#endif</p>
<p>#define BATT_FILENAME &quot;/data/bat_last_capacity.dat&quot;</p>
<p>static struct wake_lock batt_wake_lock;</p>
<p>struct batt_vol_cal{</p>
<p>u32 disp_cal;</p>
<p>u32 dis_charge_vol;</p>
<p>u32 charge_vol;</p>
<p>};</p>
<p>#ifdef CONFIG_BATTERY_RK30_VOL3V8</p>
<p>#define BATT_MAX_VOL_VALUE                             4120               //满电时的电池电压  </p>
<p>#define BATT_ZERO_VOL_VALUE                            3500               //关机时的电池电压</p>
<p>#define BATT_NOMAL_VOL_VALUE                         3800               </p>
<p>//divider resistance </p>
<p>#define BAT_PULL_UP_R                                         200</p>
<p>#if defined(CONFIG_ARCH_RK3066B)</p>
<p>#define BAT_PULL_DOWN_R                                    100</p>
<p>#else</p>
<p>#define BAT_PULL_DOWN_R                                    200</p>
<p>#endif</p>
<p>static struct batt_vol_cal  batt_table[] = {</p>
<p>/*</p>
<p>{0,3400,3520},{1,3420,3525},{2,3420,3575},{3,3475,3600},{5,3505,3620},{7,3525,3644},</p>
<p>{9,3540,3662},{11,3557,3670},{13,3570,3684},{15,3580,3700},{17,3610,3715},</p>
<p>{19,3630,3720},{21,3640,3748},{23,3652,3756},{25,3662,3775},{27,3672,3790},</p>
<p>{29,3680,3810},{31,3687,3814},{33,3693,3818},{35,3699,3822},{37,3705,3825},</p>
<p>{39,3710,3830},{41,3714,3832},{43,3718,3834},{45,3722,3836},{47,3726,3837},</p>
<p>{49,3730,3839},{51,3734,3841},{53,3738,3842},{55,3742,3844},{57,3746,3844},</p>
<p>{59,3750,3855},{61,3756,3860},{63,3764,3864},{65,3774,3871},{67,3786,3890},</p>
<p>{69,3800,3910},{71,3808,3930},{73,3817,3977},{75,3827,3977},{77,3845,3997},</p>
<p>{79,3950,4030},{81,3964,4047},{83,3982,4064},{85,4002,4080},{87,4026,4096},</p>
<p>{89,4030,4132</p>
<p>*/</p>
<p>/*</p>
<p>{0,3500,3550},{2,3512,3562},{4,3524,3574},{6,3536,3586},{8,3548,3598},</p>
<p>{10,3560,3610},{12,3572,3622},{14,3584,3634},{16,3596,3646},{18,3608,3658},</p>
<p>{20,3620,3670},{22,3632,3682},{24,3644,3694},{26,3656,3706},{28,3668,3718},</p>
<p>{30,3680,3730},{32,3692,3742},{34,3704,3754},{36,3716,3766},{38,3728,3778},</p>
<p>{40,3740,3790},{42,3752,3802},{44,3764,3814},{46,3776,3826},{48,3788,3838},</p>
<p>{50,3800,3850},{52,3812,3862},{54,3824,3874},{56,3836,3886},{58,3848,3898},</p>
<p>{60,3860,3910},{62,3872,3922},{64,3884,3934},{66,3896,3946},{68,3908,3958},</p>
<p>{70,3920,3970},{72,3932,3982},{74,3944,3994},{76,3956,4006},{78,3968,4018},</p>
<p>{80,3980,4030},{82,3992,4042},{84,4004,4054},{86,4016,4066},{88,4028,4078},</p>
<p>{90,4040,4090},{92,4052,4102},{94,4064,4114},{96,4076,4126},{98,4088,4168},</p>
<p>{100,4120,4200},*/</p>
<p>{1,3500,3700},{10,3575,3750},{20,3600,3800},{30,3615,3850},{40,3645,3900},</p>
<p>{50,3680,3950},{60,3730,4000},{70,3785,4050},{80,3850,4100},{90,3935,4150},</p>
<p>{100,4120,4200},</p>
<p>};</p>
<p>#else</p>
<p>#define BATT_MAX_VOL_VALUE                              8284               //Full charge voltage</p>
<p>#define BATT_ZERO_VOL_VALUE                             6800             // power down voltage </p>
<p>#define BATT_NOMAL_VOL_VALUE                          7600                </p>
<p>//定义ADC采样分压电阻，以实际值为准，单位K</p>
<p>#define BAT_PULL_UP_R                                         300 </p>
<p>#define BAT_PULL_DOWN_R                                    100</p>
<p>static struct batt_vol_cal  batt_table[] = {</p>
<p>{0,6800,7400},    {1,6840,7440},    {2,6880,7480},     {3,6950,7450},       {5,7010,7510},    {7,7050,7550},</p>
<p>{9,7080,7580},    {11,7104,7604},   {13,7140,7640},   {15,7160,7660},      {17,7220,7720},</p>
<p>{19,7260,7760},  {21,7280,7780},   {23,7304,7802},   {25,7324,7824},      {27,7344,7844},</p>
<p>{29,7360,7860},  {31,7374,7874},   {33,7386,7886},   {35,7398,7898},      {37,7410,7910},//500</p>
<p>{39,7420,7920},  {41,7424,7928},   {43,7436,7947},   {45,7444,7944},      {47,7450,7958}, //508</p>
<p>{49,7460,7965},  {51,7468,7975},   {53, 7476,7990},  {55,7482,8000},      {57,7492,8005}, // 5 14</p>
<p>{59,7500,8011},  {61,7510,8033},   {63,7528,8044},   {65,7548,8055},      {67,7560,8066},//506</p>
<p>{69,7600,8070},  {71,7618,8075},   {73,7634,8080},   {75,7654,8085},      {77,7690,8100}, //400</p>
<p>{79,7900,8180},  {81,7920,8210},   {83,7964,8211},   {85,8000,8214},      {87,8002,8218},//290</p>
<p>{89,8012, 8220}, {91,8022,8235},   {93,8110,8260},   {95,8140,8290},       {97,8170,8300},  {100,8200 ,8310},//110</p>
<p>};</p>
<p>#endif</p>
<p>#define BATT_NUM  ARRAY_SIZE(batt_table)</p>
<p>#define adc_to_voltage(adc_val)                           ((adc_val * BAT_DEFINE_VALUE * (BAT_PULL_UP_R + BAT_PULL_DOWN_R)) / (1024 * BAT_PULL_DOWN_R))</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>extern int dwc_vbus_status(void);</p>
<p>extern int get_msc_connect_flag(void);</p>
<p>struct rk30_adc_battery_data {</p>
<p>int irq;</p>
<p>//struct timer_list       timer;</p>
<p>struct workqueue_struct *wq;</p>
<p>struct delayed_work    delay_work;</p>
<p>struct work_struct    dcwakeup_work;</p>
<p>struct work_struct                   lowerpower_work;</p>
<p>bool                    resume;</p>
<p>struct rk30_adc_battery_platform_data *pdata;</p>
<p>int                     full_times;</p>
<p>struct adc_client       *client; </p>
<p>int                     adc_val;</p>
<p>int                     adc_samples[NUM_VOLTAGE_SAMPLE+2];</p>
<p>int                     bat_status;</p>
<p>int                     bat_status_cnt;</p>
<p>int                     bat_health;</p>
<p>int                     bat_present;</p>
<p>int                     bat_voltage;</p>
<p>int                     bat_capacity;</p>
<p>int                     bat_change;</p>
<p>int                     old_charge_level;</p>
<p>int                    *pSamples;</p>
<p>int                     gBatCapacityDisChargeCnt;</p>
<p>int                     gBatCapacityChargeCnt;</p>
<p>int          capacitytmp;</p>
<p>int                     poweron_check;</p>
<p>int                     suspend_capacity;</p>
<p>int                     status_lock;</p>
<p>};</p>
<p>static struct rk30_adc_battery_data *gBatteryData;</p>
<p>enum {</p>
<p>BATTERY_STATUS          = 0,</p>
<p>BATTERY_HEALTH          = 1,</p>
<p>BATTERY_PRESENT         = 2,</p>
<p>BATTERY_CAPACITY        = 3,</p>
<p>BATTERY_AC_ONLINE       = 4,</p>
<p>BATTERY_STATUS_CHANGED = 5,</p>
<p>AC_STATUS_CHANGED   = 6,</p>
<p>BATTERY_INT_STATUS    = 7,</p>
<p>BATTERY_INT_ENABLE    = 8,</p>
<p>};</p>
<p>typedef enum {</p>
<p>CHARGER_BATTERY = 0,</p>
<p>CHARGER_USB,</p>
<p>CHARGER_AC</p>
<p>} charger_type_t;</p>
<p>static int rk30_adc_battery_load_capacity(void)</p>
<p>{</p>
<p>char value[4];</p>
<p>int* p = (int *)value;</p>
<p>long fd = sys_open(BATT_FILENAME,O_RDONLY,0);</p>
<p>if(fd &lt; 0){</p>
<p>pr_bat(&quot;rk30_adc_battery_load_capacity: open file /data/bat_last_capacity.dat failed\n&quot;);</p>
<p>return -1;</p>
<p>}</p>
<p>sys_read(fd,(char __user *)value,4);</p>
<p>sys_close(fd);</p>
<p>return (*p);</p>
<p>}</p>
<p>static void rk30_adc_battery_put_capacity(int loadcapacity)</p>
<p>{</p>
<p>char value[4];</p>
<p>int* p = (int *)value;</p>
<p>long fd = sys_open(BATT_FILENAME,O_CREAT | O_RDWR,0);</p>
<p>if(fd &lt; 0){</p>
<p>pr_bat(&quot;rk30_adc_battery_put_capacity: open file /data/bat_last_capacity.dat failed\n&quot;);</p>
<p>return;</p>
<p>}</p>
<p>*p = loadcapacity;</p>
<p>sys_write(fd, (const char __user *)value, 4);</p>
<p>sys_close(fd);</p>
<p>}</p>
<p>static void rk30_adc_battery_charge_enable(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if (pdata-&gt;charge_set_pin != INVALID_GPIO){</p>
<p>gpio_direction_output(pdata-&gt;charge_set_pin, pdata-&gt;charge_set_level);</p>
<p>}</p>
<p>}</p>
<p>static void rk30_adc_battery_charge_disable(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if (pdata-&gt;charge_set_pin != INVALID_GPIO){</p>
<p>gpio_direction_output(pdata-&gt;charge_set_pin, 1 - pdata-&gt;charge_set_level);</p>
<p>}</p>
<p>}</p>
<p>//extern int suspend_flag;</p>
<p>static int rk30_adc_battery_get_charge_level(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int charge_on = 0;</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>#if defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>if (gpio_get_value (pdata-&gt;dc_det_pin) == pdata-&gt;dc_det_level){</p>
<p>charge_on = 1;</p>
<p>}</p>
<p>}</p>
<p>/*</p>
<p>else{</p>
<p>if(pdata-&gt;is_dc_charging)</p>
<p>charge_on =pdata-&gt;is_dc_charging();</p>
<p>}*/</p>
<p>#endif</p>
<p>#if 0</p>
<p>if (pdata-&gt;spport_usb_charging)  //is usb charging </p>
<p>if(pdata-&gt;is_usb_charging)</p>
<p>charge_on = pdata-&gt;is_usb_charging();</p>
<p>#endif</p>
<p>return charge_on;</p>
<p>}</p>
<p>static int  is_charge_ok(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int charge_is_ok = 0;</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if((pdata-&gt;charge_ok_pin == INVALID_GPIO)&amp;&amp; ( pdata-&gt;charging_ok == NULL))</p>
<p>return -1;</p>
<p>if (pdata-&gt;charge_ok_pin != INVALID_GPIO){</p>
<p>if (gpio_get_value(pdata-&gt;charge_ok_pin) == pdata-&gt;charge_ok_level)</p>
<p>{</p>
<p>charge_is_ok =1;</p>
<p>}</p>
<p>}else if( pdata-&gt;charging_ok)</p>
<p>{</p>
<p>charge_is_ok = pdata-&gt;charging_ok();</p>
<p>}</p>
<p>return charge_is_ok;</p>
<p>}</p>
<p>//int old_charge_level;</p>
<p>static int rk30_adc_battery_status_samples(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int charge_level;</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>charge_level = rk30_adc_battery_get_charge_level(bat);</p>
<p>//检测充电状态变化情况</p>
<p>if (charge_level != bat-&gt;old_charge_level){</p>
<p>bat-&gt;old_charge_level = charge_level;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>if(charge_level) {            </p>
<p>rk30_adc_battery_charge_enable(bat);</p>
<p>}</p>
<p>else{</p>
<p>rk30_adc_battery_charge_disable(bat);</p>
<p>}</p>
<p>bat-&gt;bat_status_cnt = 0;        //状态变化开始计数</p>
<p>}</p>
<p>if(charge_level == 0){   </p>
<p>//discharge</p>
<p>bat-&gt;full_times = 0;</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_NOT_CHARGING;</p>
<p>}</p>
<p>else{</p>
<p>//CHARGE</p>
<p>if( is_charge_ok(bat)  ==  INVALID_CHARGE_CHECK){</p>
<p>//if (pdata-&gt;charge_ok_pin == INVALID_GPIO){  //no charge_ok_pin</p>
<p>if (bat-&gt;bat_capacity == 100){</p>
<p>if (bat-&gt;bat_status != POWER_SUPPLY_STATUS_FULL){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>}</p>
<p>}</p>
<p>else{  // pin of charge_ok_pin</p>
<p>if (is_charge_ok(bat) != CHARGE_IS_OK ){</p>
<p>bat-&gt;full_times = 0;</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>}</p>
<p>else{</p>
<p>//检测到充电满电平标志</p>
<p>bat-&gt;full_times++;</p>
<p>if (bat-&gt;full_times &gt;= NUM_CHARGE_FULL_DELAY_TIMES) {</p>
<p>bat-&gt;full_times = NUM_CHARGE_FULL_DELAY_TIMES + 1;</p>
<p>}</p>
<p>if ((bat-&gt;full_times &gt;= NUM_CHARGE_FULL_DELAY_TIMES) &amp;&amp; (bat-&gt;bat_capacity &gt;= 95)){</p>
<p>if (bat-&gt;bat_status != POWER_SUPPLY_STATUS_FULL){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return charge_level;</p>
<p>}</p>
<p>//#define adc_to_voltage(adc_val)                           ((adc_val * BAT_DEFINE_VALUE * (BAT_PULL_UP_R + BAT_PULL_DOWN_R)) / (1024 * BAT_PULL_DOWN_R))</p>
<p>static int rk_adc_voltage(int value)</p>
<p>{</p>
<p>int voltage;</p>
<p>int ref_voltage; //reference_voltage</p>
<p>int pullup_res;</p>
<p>int pulldown_res;</p>
<p>ref_voltage = gBatteryData -&gt;pdata-&gt;reference_voltage;</p>
<p>pullup_res = gBatteryData -&gt;pdata-&gt;pull_up_res;</p>
<p>pulldown_res = gBatteryData -&gt;pdata-&gt;pull_down_res;</p>
<p>if(ref_voltage &amp;&amp; pullup_res &amp;&amp; pulldown_res){</p>
<p>voltage =  ((value * ref_voltage * (pullup_res + pulldown_res)) / (1024 * pulldown_res));</p>
<p>}else{</p>
<p>voltage = adc_to_voltage(value);</p>
<p>}</p>
<p>return voltage;</p>
<p>}</p>
<p>static int *pSamples;</p>
<p>static void rk30_adc_battery_voltage_samples(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int value;</p>
<p>int i,*pStart = bat-&gt;adc_samples, num = 0;</p>
<p>int level = rk30_adc_battery_get_charge_level(bat);</p>
<p>value = bat-&gt;adc_val;</p>
<p>adc_async_read(bat-&gt;client);</p>
<p>*pSamples++ = rk_adc_voltage(value);</p>
<p>bat-&gt;bat_status_cnt++;</p>
<p>if (bat-&gt;bat_status_cnt &gt; NUM_VOLTAGE_SAMPLE)  bat-&gt;bat_status_cnt = NUM_VOLTAGE_SAMPLE + 1;</p>
<p>num = pSamples - pStart;</p>
<p>if (num &gt;= NUM_VOLTAGE_SAMPLE){</p>
<p>pSamples = pStart;</p>
<p>num = NUM_VOLTAGE_SAMPLE;</p>
<p>}</p>
<p>value = 0;</p>
<p>for (i = 0; i &lt; num; i++){</p>
<p>value += bat-&gt;adc_samples[i];</p>
<p>}</p>
<p>bat-&gt;bat_voltage = value / num;</p>
<p>/<em>消除毛刺电压</em>/</p>
<p>if(1 == level){</p>
<p>if(bat-&gt;bat_voltage &gt;= batt_table[BATT_NUM-1].charge_vol+ 10)</p>
<p>bat-&gt;bat_voltage = batt_table[BATT_NUM-1].charge_vol  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= batt_table[0].charge_vol  - 10)</p>
<p>bat-&gt;bat_voltage =  batt_table[0].charge_vol - 10;</p>
<p>}</p>
<p>else{</p>
<p>if(bat-&gt;bat_voltage &gt;= batt_table[BATT_NUM-1].dis_charge_vol+ 10)</p>
<p>bat-&gt;bat_voltage = batt_table[BATT_NUM-1].dis_charge_vol  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= batt_table[0].dis_charge_vol  - 10)</p>
<p>bat-&gt;bat_voltage =  batt_table[0].dis_charge_vol - 10;</p>
<p>}</p>
<p>}</p>
<p>static int rk30_adc_battery_voltage_to_capacity(struct rk30_adc_battery_data *bat, int BatVoltage)</p>
<p>{</p>
<p>int i = 0;</p>
<p>int capacity = 0;</p>
<p>struct batt_vol_cal *p;</p>
<p>p = batt_table;</p>
<p>if (rk30_adc_battery_get_charge_level(bat)){  //charge</p>
<p>if(BatVoltage &gt;= (p[BATT_NUM - 1].charge_vol)){</p>
<p>capacity = 99;</p>
<p>}</p>
<p>else{</p>
<p>if(BatVoltage &lt;= (p[0].charge_vol)){</p>
<p>capacity = 0;</p>
<p>}</p>
<p>else{</p>
<p>for(i = 0; i &lt; BATT_NUM - 1; i++){</p>
<p>if(((p[i].charge_vol) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt; (p[i+1].charge_vol))){</p>
<p>capacity = p[i].disp_cal + ((BatVoltage - p[i].charge_vol) *  (p[i+1].disp_cal -p[i].disp_cal ))/ (p[i+1].charge_vol- p[i].charge_vol);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}  </p>
<p>}</p>
<p>}</p>
<p>else{  //discharge</p>
<p>if(BatVoltage &gt;= (p[BATT_NUM - 1].dis_charge_vol)){</p>
<p>capacity = 100;</p>
<p>}</p>
<p>else{</p>
<p>if(BatVoltage &lt;= (p[0].dis_charge_vol)){</p>
<p>capacity = 0;</p>
<p>}</p>
<p>else{</p>
<p>for(i = 0; i &lt; BATT_NUM - 1; i++){</p>
<p>if(((p[i].dis_charge_vol) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt; (p[i+1].dis_charge_vol))){</p>
<p>capacity =  p[i].disp_cal+ ((BatVoltage - p[i].dis_charge_vol) * (p[i+1].disp_cal -p[i].disp_cal ) )/ (p[i+1].dis_charge_vol- p[i].dis_charge_vol) ;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}  </p>
<p>}</p>
<p>}</p>
<p>    return capacity;</p>
<p>    }</p>
<p>static void rk30_adc_battery_capacity_samples(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int capacity = 0;</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>int timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>//充放电状态变化后，Buffer填满之前，不更新</p>
<p>if (bat-&gt;bat_status_cnt &lt; NUM_VOLTAGE_SAMPLE)  {</p>
<p>bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>bat-&gt;gBatCapacityChargeCnt    = 0;</p>
<p>return;</p>
<p>}</p>
<p>capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>if (rk30_adc_battery_get_charge_level(bat)){</p>
<p>if (capacity &gt; bat-&gt;bat_capacity){</p>
<p>if(capacity &gt; bat-&gt;bat_capacity + 10 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -10;  //5s</p>
<p>else if(capacity &gt; bat-&gt;bat_capacity + 7 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -5; //10s</p>
<p>       else if(capacity &gt; bat-&gt;bat_capacity + 3 )</p>
<p>               timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE - 2; // 13</p>
<p>//实际采样到的容量比显示的容量大，逐级上升</p>
<p>if (++(bat-&gt;gBatCapacityDisChargeCnt) &gt;= timer_of_charge_sample){</p>
<p>bat-&gt;gBatCapacityDisChargeCnt  = 0;</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else{  //   实际的容量比采样比 显示的容量小</p>
<p>           bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>           (bat-&gt;gBatCapacityChargeCnt)++;</p>
<p>pr_bat(&quot;————- is_charge_ok(bat)=%d\n&quot;, is_charge_ok(bat));</p>
<p>            if( is_charge_ok(bat) != INVALID_CHARGE_CHECK){</p>
<p>//if (pdata-&gt;charge_ok_pin != INVALID_GPIO){</p>
<p>//if (gpio_get_value(pdata-&gt;charge_ok_pin) == pdata-&gt;charge_ok_level){</p>
<p>if( is_charge_ok(bat) == CHARGE_IS_OK){</p>
<p>if(capacity &gt; bat-&gt;bat_capacity + 10 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -13;  //  2s</p>
<p>else if(capacity &gt; bat-&gt;bat_capacity + 7 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -10; //10s</p>
<p>else if(capacity &gt; bat-&gt;bat_capacity + 2 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -8; //7s</p>
<p>//检测到电池充满标志，同时长时间内充电电压无变化，开始启动计时充电，快速上升容量</p>
<p>if (bat-&gt;gBatCapacityChargeCnt &gt;= timer_of_charge_sample){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>#if 0</p>
<p>if (capacity &gt; capacitytmp){</p>
<p>//过程中如果电压有增长，定时器复位，防止定时器模拟充电比实际充电快</p>
<p>gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else if (/<em>bat-&gt;bat_capacity &gt;= 85) &amp;&amp;</em>/ (gBatCapacityChargeCnt &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>gBatCapacityChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>#else //  防止电池老化后出现冲不满的情况，</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>//过程中如果电压有增长，定时器复位，防止定时器模拟充电比实际充电快</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;((bat-&gt;gBatCapacityChargeCnt) &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>#endif</p>
<p>}</p>
<p>else{</p>
<p>//没有充电满检测脚，长时间内电压无变化，定时器模拟充电</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>//过程中如果电压有增长，定时器复位，防止定时器模拟充电比实际充电快</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;(bat-&gt;gBatCapacityChargeCnt &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt;= 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}            </p>
<p>}</p>
<p>}    </p>
<p>else{   </p>
<p>//放电时,只允许电压下降</p>
<p>if (capacity &lt; bat-&gt;bat_capacity){</p>
<p>if(capacity + 10 &gt; bat-&gt;bat_capacity  )</p>
<p>       timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -10;  //5s</p>
<p>else if(capacity  + 7 &gt; bat-&gt;bat_capacity )</p>
<p>       timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -5; //10s</p>
<p>       else if(capacity  + 3&gt; bat-&gt;bat_capacity )</p>
<p>               timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 2; // 13</p>
<p>if (++(bat-&gt;gBatCapacityDisChargeCnt) &gt;= timer_of_discharge_sample){</p>
<p>bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &gt; 0){</p>
<p>bat-&gt;bat_capacity– ;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>}</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>bat-&gt;capacitytmp = capacity;</p>
<p>}</p>
<p>//static int poweron_check = 0;</p>
<p>static void rk30_adc_battery_poweron_capacity_check(void)</p>
<p>{</p>
<p>int new_capacity, old_capacity;</p>
<p>new_capacity = gBatteryData-&gt;bat_capacity;</p>
<p>old_capacity = rk30_adc_battery_load_capacity();</p>
<p>printk(&quot;————old_capacity—%d\n&quot;,old_capacity);</p>
<p>printk(&quot;————new_capacity—%d\n&quot;,new_capacity);</p>
<p>if ((old_capacity &lt;= 0) || (old_capacity &gt;= 100)){</p>
<p>old_capacity = new_capacity;</p>
<p>}    </p>
<p>if (gBatteryData-&gt;bat_status == POWER_SUPPLY_STATUS_FULL){</p>
<p>if (new_capacity &gt; 80){</p>
<p>gBatteryData-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>else if (gBatteryData-&gt;bat_status != POWER_SUPPLY_STATUS_NOT_CHARGING){</p>
<p>//chargeing state</p>
<p>//问题：</p>
<p>// //1）长时间关机放置后，开机后读取的容量远远大于实际容量怎么办？</p>
<p>// //2）如果不这样做，短时间关机再开机，前后容量不一致又该怎么办？</p>
<p>// //3）一下那种方式合适？</p>
<p>//gBatteryData-&gt;bat_capacity = new_capacity;</p>
<p>// gBatteryData-&gt;bat_capacity = (new_capacity &gt; old_capacity) ? new_capacity : old_capacity;</p>
<p>if (old_capacity &gt; new_capacity)//放置一段时间了</p>
<p>{</p>
<p>   if((old_capacity - new_capacity) &gt; 10)</p>
<p>   {</p>
<p>       old_capacity=new_capacity;</p>
<p>   }</p>
<p>}else{</p>
<p>            if((new_capacity - old_capacity)&gt;55){ //充电了，电量有所上升</p>
<p>                old_capacity=new_capacity;</p>
<p>            }</p>
<p>        }</p>
<p>        gBatteryData-&gt;bat_capacity = old_capacity; </p>
<p>}else{</p>
<p>if(new_capacity &gt; old_capacity + 35 )</p>
<p>gBatteryData-&gt;bat_capacity = new_capacity;</p>
<p>else</p>
<p>gBatteryData-&gt;bat_capacity = (new_capacity &lt; old_capacity) ? new_capacity : old_capacity;  //avoid the value of capacity increase </p>
<p>}</p>
<p>pr_bat(&quot;capacity = %d, new_capacity = %d, old_capacity = %d\n&quot;,gBatteryData-&gt;bat_capacity, new_capacity, old_capacity);</p>
<p>gBatteryData-&gt;bat_change = 1;</p>
<p>}</p>
<p>#if defined(CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>static int rk30_adc_battery_get_usb_property(struct power_supply *psy, </p>
<p>   enum power_supply_property psp,</p>
<p>   union power_supply_propval *val)</p>
<p>{</p>
<p>charger_type_t charger;</p>
<p>charger =  CHARGER_USB;</p>
<p>switch (psp) {</p>
<p>case POWER_SUPPLY_PROP_ONLINE:</p>
<p>if (psy-&gt;type == POWER_SUPPLY_TYPE_USB)</p>
<p>// val-&gt;intval = get_msc_connect_flag();</p>
<p>if (gBatteryData-&gt;pdata-&gt;spport_usb_charging)  //is usb charging </p>
<p>if(gBatteryData-&gt;pdata-&gt;is_usb_charging)</p>
<p>val-&gt;intval = gBatteryData -&gt;pdata-&gt;is_usb_charging();</p>
<p>printk(&quot;%s:%d\n&quot;,<strong>FUNCTION</strong>,val-&gt;intval);</p>
<p>break;</p>
<p>default:</p>
<p>return -EINVAL;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>static enum power_supply_property rk30_adc_battery_usb_props[] = {</p>
<p>POWER_SUPPLY_PROP_ONLINE,</p>
<p>};</p>
<p>static struct power_supply rk30_usb_supply = </p>
<p>{</p>
<p>.name = &quot;usb&quot;,</p>
<p>.type = POWER_SUPPLY_TYPE_USB,</p>
<p>.get_property   = rk30_adc_battery_get_usb_property,</p>
<p>.properties     = rk30_adc_battery_usb_props,</p>
<p>.num_properties = ARRAY_SIZE(rk30_adc_battery_usb_props),</p>
<p>};</p>
<p>#endif</p>
<p>#if defined(CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>static irqreturn_t rk30_adc_battery_dc_wakeup(int irq, void *dev_id)</p>
<p>{   </p>
<p>queue_work(gBatteryData-&gt;wq, &amp;gBatteryData-&gt;dcwakeup_work);</p>
<p>return IRQ_HANDLED;</p>
<p>}</p>
<p>static int rk30_adc_battery_get_ac_property(struct power_supply *psy,</p>
<p>enum power_supply_property psp,</p>
<p>union power_supply_propval *val)</p>
<p>{</p>
<p>int ret = 0;</p>
<p>charger_type_t charger;</p>
<p>charger =  CHARGER_USB;</p>
<p>switch (psp) {</p>
<p>case POWER_SUPPLY_PROP_ONLINE:</p>
<p>if (psy-&gt;type == POWER_SUPPLY_TYPE_MAINS)</p>
<p>{</p>
<p>if (rk30_adc_battery_get_charge_level(gBatteryData))</p>
<p>{</p>
<p>val-&gt;intval = 1;</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>val-&gt;intval = 0;</p>
<p>}</p>
<p>}</p>
<p>DBG(&quot;%s:%d\n&quot;,<strong>FUNCTION</strong>,val-&gt;intval);</p>
<p>break;</p>
<p>default:</p>
<p>ret = -EINVAL;</p>
<p>break;</p>
<p>}</p>
<p>return ret;</p>
<p>}</p>
<p>static enum power_supply_property rk30_adc_battery_ac_props[] = </p>
<p>{</p>
<p>POWER_SUPPLY_PROP_ONLINE,</p>
<p>};</p>
<p>static struct power_supply rk30_ac_supply = </p>
<p>{</p>
<p>.name = &quot;ac&quot;,</p>
<p>.type = POWER_SUPPLY_TYPE_MAINS,</p>
<p>.get_property   = rk30_adc_battery_get_ac_property,</p>
<p>.properties     = rk30_adc_battery_ac_props,</p>
<p>.num_properties = ARRAY_SIZE(rk30_adc_battery_ac_props),</p>
<p>};</p>
<p>static void rk30_adc_battery_dcdet_delaywork(struct work_struct *work)</p>
<p>{</p>
<p>int ret;</p>
<p>struct rk30_adc_battery_platform_data *pdata;</p>
<p>int irq;</p>
<p>int irq_flag;</p>
<p>pdata    = gBatteryData-&gt;pdata;</p>
<p>irq        = gpio_to_irq(pdata-&gt;dc_det_pin);</p>
<p>irq_flag = gpio_get_value (pdata-&gt;dc_det_pin) ? IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;</p>
<p>rk28_send_wakeup_key(); // wake up the system</p>
<p>free_irq(irq, NULL);</p>
<p>ret = request_irq(irq, rk30_adc_battery_dc_wakeup, irq_flag, &quot;ac_charge_irq&quot;, NULL);// reinitialize the DC irq </p>
<p>if (ret) {</p>
<p>free_irq(irq, NULL);</p>
<p>}</p>
<p>power_supply_changed(&amp;rk30_ac_supply);</p>
<p>gBatteryData-&gt;bat_status_cnt = 0;        //the state of battery is change</p>
<p>}</p>
<p>#endif</p>
<p>static int rk30_adc_battery_get_status(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_status);</p>
<p>}</p>
<p>static int rk30_adc_battery_get_health(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return POWER_SUPPLY_HEALTH_GOOD;</p>
<p>}</p>
<p>static int rk30_adc_battery_get_present(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_voltage &lt; BATT_MAX_VOL_VALUE) ? 0 : 1;</p>
<p>}</p>
<p>static int rk30_adc_battery_get_voltage(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_voltage );</p>
<p>}</p>
<p>static int rk30_adc_battery_get_capacity(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_capacity);</p>
<p>}</p>
<p>static int rk30_adc_battery_get_property(struct power_supply *psy,</p>
<p>enum power_supply_property psp,</p>
<p>union power_supply_propval *val)</p>
<p>{</p>
<p>int ret = 0;</p>
<p>switch (psp) {</p>
<p>case POWER_SUPPLY_PROP_STATUS:</p>
<p>val-&gt;intval = rk30_adc_battery_get_status(gBatteryData);</p>
<p>DBG(&quot;gBatStatus=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_HEALTH:</p>
<p>val-&gt;intval = rk30_adc_battery_get_health(gBatteryData);</p>
<p>DBG(&quot;gBatHealth=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_PRESENT:</p>
<p>val-&gt;intval = rk30_adc_battery_get_present(gBatteryData);</p>
<p>DBG(&quot;gBatPresent=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_VOLTAGE_NOW:</p>
<p>val -&gt;intval = rk30_adc_battery_get_voltage(gBatteryData);</p>
<p>DBG(&quot;gBatVoltage=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>// case POWER_SUPPLY_PROP_CURRENT_NOW:</p>
<p>// val-&gt;intval = 1100;</p>
<p>// break;</p>
<p>case POWER_SUPPLY_PROP_CAPACITY:</p>
<p>val-&gt;intval = rk30_adc_battery_get_capacity(gBatteryData);</p>
<p>DBG(&quot;gBatCapacity=%d%%\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_TECHNOLOGY:</p>
<p>val-&gt;intval = POWER_SUPPLY_TECHNOLOGY_LION;</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:</p>
<p>val-&gt;intval = BATT_MAX_VOL_VALUE;</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:</p>
<p>val-&gt;intval = BATT_ZERO_VOL_VALUE;</p>
<p>break;</p>
<p>default:</p>
<p>ret = -EINVAL;</p>
<p>break;</p>
<p>}</p>
<p>return ret;</p>
<p>}</p>
<p>static enum power_supply_property rk30_adc_battery_props[] = {</p>
<p>POWER_SUPPLY_PROP_STATUS,</p>
<p>POWER_SUPPLY_PROP_HEALTH,</p>
<p>POWER_SUPPLY_PROP_PRESENT,</p>
<p>POWER_SUPPLY_PROP_VOLTAGE_NOW,</p>
<p>// POWER_SUPPLY_PROP_CURRENT_NOW,</p>
<p>POWER_SUPPLY_PROP_TECHNOLOGY,</p>
<p>POWER_SUPPLY_PROP_CAPACITY,</p>
<p>POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,</p>
<p>POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,</p>
<p>};</p>
<p>static struct power_supply rk30_battery_supply = </p>
<p>{</p>
<p>.name = &quot;battery&quot;,</p>
<p>.type = POWER_SUPPLY_TYPE_BATTERY,</p>
<p>.get_property   = rk30_adc_battery_get_property,</p>
<p>.properties     = rk30_adc_battery_props,</p>
<p>.num_properties = ARRAY_SIZE(rk30_adc_battery_props),</p>
<p>};</p>
<p>#ifdef CONFIG_PM</p>
<p>static void rk30_adc_battery_resume_check(void)</p>
<p>{</p>
<p>int i;</p>
<p>int level,oldlevel;</p>
<p>int new_capacity, old_capacity;</p>
<p>struct rk30_adc_battery_data *bat = gBatteryData;</p>
<p>bat-&gt;old_charge_level = -1;</p>
<p>pSamples = bat-&gt;adc_samples;</p>
<p>adc_sync_read(bat-&gt;client);                             //start adc sample</p>
<p>level = oldlevel = rk30_adc_battery_status_samples(bat);//init charge status</p>
<p>for (i = 0; i &lt; NUM_VOLTAGE_SAMPLE; i++) {               //0.3 s   </p>
<p>mdelay(1);</p>
<p>rk30_adc_battery_voltage_samples(bat);              //get voltage</p>
<p>level = rk30_adc_battery_status_samples(bat);       //check charge status</p>
<p>if (oldlevel != level){</p>
<p>   oldlevel = level;                               //if charge status changed, reset sample</p>
<p>   i = 0;</p>
<p>}        </p>
<p>}</p>
<p>new_capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>old_capacity =gBatteryData-&gt; suspend_capacity;</p>
<p>if (bat-&gt;bat_status != POWER_SUPPLY_STATUS_NOT_CHARGING){</p>
<p>//chargeing state</p>
<p>bat-&gt;bat_capacity = (new_capacity &gt; old_capacity) ? new_capacity : old_capacity;</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;bat_capacity = (new_capacity &lt; old_capacity) ? new_capacity : old_capacity;  // aviod the value of capacity increase    dicharge</p>
<p>}</p>
<p>}</p>
<p>static int rk30_adc_battery_suspend(struct platform_device *dev, pm_message_t state)</p>
<p>{</p>
<p>int irq;</p>
<p>gBatteryData-&gt;suspend_capacity = gBatteryData-&gt;bat_capacity;</p>
<p>cancel_delayed_work(&amp;gBatteryData-&gt;delay_work);</p>
<p>if( gBatteryData-&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>irq = gpio_to_irq(gBatteryData-&gt;pdata-&gt;batt_low_pin);</p>
<p>enable_irq(irq);</p>
<p>    enable_irq_wake(irq);</p>
<p>    }</p>
<p>return 0;</p>
<p>}</p>
<p>static int rk30_adc_battery_resume(struct platform_device *dev)</p>
<p>{</p>
<p>int irq;</p>
<p>gBatteryData-&gt;resume = true;</p>
<p>queue_delayed_work(gBatteryData-&gt;wq, &amp;gBatteryData-&gt;delay_work, msecs_to_jiffies(100));</p>
<p>if( gBatteryData-&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>irq = gpio_to_irq(gBatteryData-&gt;pdata-&gt;batt_low_pin);</p>
<p>    disable_irq_wake(irq);</p>
<p>disable_irq(irq);</p>
<p>    }</p>
<p>return 0;</p>
<p>}</p>
<p>#else</p>
<p>#define rk30_adc_battery_suspend NULL</p>
<p>#define rk30_adc_battery_resume NULL</p>
<p>#endif</p>
<p>unsigned long AdcTestCnt = 0;</p>
<p>static void rk30_adc_battery_timer_work(struct work_struct *work)</p>
<p>{</p>
<p>#ifdef CONFIG_PM</p>
<p>if (gBatteryData-&gt;resume) {</p>
<p>rk30_adc_battery_resume_check();</p>
<p>gBatteryData-&gt;resume = false;</p>
<p>}</p>
<p>#endif</p>
<p>rk30_adc_battery_status_samples(gBatteryData);</p>
<p>if (gBatteryData-&gt;poweron_check){   </p>
<p>gBatteryData-&gt;poweron_check = 0;</p>
<p>rk30_adc_battery_poweron_capacity_check();</p>
<p>}</p>
<p>rk30_adc_battery_voltage_samples(gBatteryData);</p>
<p>rk30_adc_battery_capacity_samples(gBatteryData);</p>
<p>if( 0 == gBatteryData -&gt;pdata -&gt;charging_sleep){</p>
<p>if( 1 == rk30_adc_battery_get_charge_level(gBatteryData)){  // charge</p>
<p>if(0 == gBatteryData-&gt;status_lock ){</p>
<p>wake_lock(&amp;batt_wake_lock);  //lock</p>
<p>gBatteryData-&gt;status_lock = 1; </p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>if(1 == gBatteryData-&gt;status_lock ){</p>
<p>wake_unlock(&amp;batt_wake_lock);  //unlock</p>
<p>gBatteryData-&gt;status_lock = 0; </p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>/<em>update battery parameter after adc and capacity has been changed</em>/</p>
<p>if(gBatteryData-&gt;bat_change){</p>
<p>gBatteryData-&gt;bat_change = 0;</p>
<p>rk30_adc_battery_put_capacity(gBatteryData-&gt;bat_capacity);</p>
<p>power_supply_changed(&amp;rk30_battery_supply);</p>
<p>#if  defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>if (gBatteryData-&gt;pdata-&gt;dc_det_pin == INVALID_GPIO){</p>
<p>power_supply_changed(&amp;rk30_ac_supply);</p>
<p>}</p>
<p>#endif</p>
<p>}</p>
<p>if (rk30_battery_dbg_level){</p>
<p>if (++AdcTestCnt &gt;= 2)</p>
<p>{</p>
<p>AdcTestCnt = 0;</p>
<p>pr_bat(&quot;Status = %d, RealAdcVal = %d, RealVol = %d,gBatVol = %d, gBatCap = %d, RealCapacity = %d, dischargecnt = %d, chargecnt = %d\n&quot;, </p>
<p>gBatteryData-&gt;bat_status, gBatteryData-&gt;adc_val, rk_adc_voltage(gBatteryData-&gt;adc_val), </p>
<p>gBatteryData-&gt;bat_voltage, gBatteryData-&gt;bat_capacity, gBatteryData-&gt;capacitytmp, gBatteryData-&gt;gBatCapacityDisChargeCnt,gBatteryData-&gt; gBatCapacityChargeCnt);</p>
<p>}</p>
<p>}</p>
<p>queue_delayed_work(gBatteryData-&gt;wq, &amp;gBatteryData-&gt;delay_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>}</p>
<p>static int rk30_adc_battery_io_init(struct rk30_adc_battery_platform_data *pdata)</p>
<p>{</p>
<p>int ret = 0;</p>
<p>if (pdata-&gt;io_init) {</p>
<p>pdata-&gt;io_init();</p>
<p>return 0;</p>
<p>}</p>
<p>//charge control pin</p>
<p>if (pdata-&gt;charge_set_pin != INVALID_GPIO){</p>
<p>    ret = gpio_request(pdata-&gt;charge_set_pin, NULL);</p>
<p>    if (ret) {</p>
<p>    printk(&quot;failed to request dc_det gpio\n&quot;);</p>
<p>    goto error;</p>
<p>    }</p>
<p>    gpio_direction_output(pdata-&gt;charge_set_pin, 1 - pdata-&gt;charge_set_level);</p>
<p>}</p>
<p>//dc charge detect pin</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>    ret = gpio_request(pdata-&gt;dc_det_pin, NULL);</p>
<p>    if (ret) {</p>
<p>    printk(&quot;failed to request dc_det gpio\n&quot;);</p>
<p>    goto error;</p>
<p>    }</p>
<p>    gpio_pull_updown(pdata-&gt;dc_det_pin, GPIOPullUp);//important</p>
<p>    ret = gpio_direction_input(pdata-&gt;dc_det_pin);</p>
<p>    if (ret) {</p>
<p>    printk(&quot;failed to set gpio dc_det input\n&quot;);</p>
<p>    goto error;</p>
<p>    }</p>
<p>}</p>
<p>//charge ok detect</p>
<p>if (pdata-&gt;charge_ok_pin != INVALID_GPIO){</p>
<p>  ret = gpio_request(pdata-&gt;charge_ok_pin, NULL);</p>
<p>    if (ret) {</p>
<p>    printk(&quot;failed to request charge_ok gpio\n&quot;);</p>
<p>    goto error;</p>
<p>    }</p>
<p>    gpio_pull_updown(pdata-&gt;charge_ok_pin, GPIOPullUp);//important</p>
<p>    ret = gpio_direction_input(pdata-&gt;charge_ok_pin);</p>
<p>    if (ret) {</p>
<p>    printk(&quot;failed to set gpio charge_ok input\n&quot;);</p>
<p>    goto error;</p>
<p>    }</p>
<p>}</p>
<p>//batt low pin</p>
<p>if( pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>  ret = gpio_request(pdata-&gt;batt_low_pin, NULL);</p>
<p>    if (ret) {</p>
<p>    printk(&quot;failed to request batt_low_pin gpio\n&quot;);</p>
<p>    goto error;</p>
<p>    }</p>
<p>    gpio_pull_updown(pdata-&gt;batt_low_pin, GPIOPullUp); </p>
<p>    ret = gpio_direction_input(pdata-&gt;batt_low_pin);</p>
<p>    if (ret) {</p>
<p>    printk(&quot;failed to set gpio batt_low_pin input\n&quot;);</p>
<p>    goto error;</p>
<p>    }</p>
<p>}</p>
<p>return 0;</p>
<p>error:</p>
<p>return -1;</p>
<p>}</p>
<p>extern void kernel_power_off(void);</p>
<p>static void rk30_adc_battery_check(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int i;</p>
<p>int level,oldlevel;</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>//printk(&quot;%s–%d:\n&quot;,<strong>FUNCTION</strong>,<strong>LINE</strong>);</p>
<p>bat-&gt;old_charge_level = -1;</p>
<p>bat-&gt;capacitytmp = 0;</p>
<p>bat-&gt;suspend_capacity = 0;</p>
<p>pSamples = bat-&gt;adc_samples;</p>
<p>adc_sync_read(bat-&gt;client);                             //start adc sample</p>
<p>level = oldlevel = rk30_adc_battery_status_samples(bat);//init charge status</p>
<p>bat-&gt;full_times = 0;</p>
<p>for (i = 0; i &lt; NUM_VOLTAGE_SAMPLE; i++){                //0.3 s</p>
<p>mdelay(1);</p>
<p>rk30_adc_battery_voltage_samples(bat);              //get voltage</p>
<p>//level = rk30_adc_battery_status_samples(bat);       //check charge status</p>
<p>level = rk30_adc_battery_get_charge_level(bat);</p>
<p>if (oldlevel != level){</p>
<p>oldlevel = level;                               //if charge status changed, reset sample</p>
<p>i = 0;</p>
<p>}        </p>
<p>}</p>
<p>bat-&gt;bat_capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);  //init bat_capacity</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_NOT_CHARGING;</p>
<p>if (rk30_adc_battery_get_charge_level(bat)){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>if (pdata-&gt;charge_ok_pin != INVALID_GPIO){</p>
<p>if (gpio_get_value(pdata-&gt;charge_ok_pin) == pdata-&gt;charge_ok_level){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>#if 0</p>
<p>#if 1</p>
<p>rk30_adc_battery_poweron_capacity_check();</p>
<p>#else</p>
<p>gBatteryData-&gt;poweron_check = 1;</p>
<p>#endif</p>
<p>gBatteryData-&gt;poweron_check = 0;</p>
<p>#endif</p>
<p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>//开机采样到的电压和上次关机保存电压相差较大，怎么处理？</p>
<p>if (bat-&gt;bat_capacity &gt; old_capacity)</p>
<p>{</p>
<p>if ((bat-&gt;bat_capacity - old_capacity) &gt; 20)</p>
<p>{</p>
<p>}</p>
<p>}</p>
<p>else if (bat-&gt;bat_capacity &lt; old_capacity)</p>
<p>{</p>
<p>if ((old_capacity &gt; bat-&gt;bat_capacity) &gt; 20)</p>
<p>{</p>
<p>}</p>
<p>}</p>
<p>*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>if (bat-&gt;bat_capacity == 0) bat-&gt;bat_capacity = 1;</p>
<p>if(1==gBatteryData -&gt; pdata-&gt;low_voltage_protection)</p>
<p>if ((bat-&gt;bat_voltage &lt;= batt_table[0].dis_charge_vol+ 50)&amp;&amp;(bat-&gt;bat_status != POWER_SUPPLY_STATUS_CHARGING)){</p>
<p>kernel_power_off();</p>
<p>}</p>
<p>}</p>
<p>static void rk30_adc_battery_callback(struct adc_client *client, void *param, int result)</p>
<p>{</p>
<p>#if 0</p>
<p>struct rk30_adc_battery_data  *info = container_of(client, struct rk30_adc_battery_data,</p>
<p>client);</p>
<p>info-&gt;adc_val = result;</p>
<p>#endif</p>
<p>if (result &lt; 0){</p>
<p>pr_bat(&quot;adc_battery_callback    resule &lt; 0 , the value &quot;);</p>
<p>return;</p>
<p>}</p>
<p>else{</p>
<p>gBatteryData-&gt;adc_val = result;</p>
<p>pr_bat(&quot;result = %d, gBatteryData-&gt;adc_val = %d\n&quot;, result, gBatteryData-&gt;adc_val );</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>#if 1</p>
<p>static void rk30_adc_battery_lowerpower_delaywork(struct work_struct *work)</p>
<p>{</p>
<p>int irq;</p>
<p>if( gBatteryData-&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>irq = gpio_to_irq(gBatteryData-&gt;pdata-&gt;batt_low_pin);</p>
<p>disable_irq(irq);</p>
<p>}</p>
<p>printk(&quot;lowerpower\n&quot;);</p>
<p>  rk28_send_wakeup_key(); // wake up the system</p>
<p>return;</p>
<p>}</p>
<p>static irqreturn_t rk30_adc_battery_low_wakeup(int irq,void *dev_id)</p>
<p>{</p>
<p>queue_work(gBatteryData-&gt;wq, &amp;gBatteryData-&gt;lowerpower_work);</p>
<p>return IRQ_HANDLED;</p>
<p>}</p>
<p>#endif</p>
<p>static int rk30_adc_battery_probe(struct platform_device *pdev)</p>
<p>{</p>
<p>int    ret;</p>
<p>int    irq;</p>
<p>int    irq_flag;</p>
<p>struct adc_client                   *client;</p>
<p>struct rk30_adc_battery_data          *data;</p>
<p>struct rk30_adc_battery_platform_data *pdata = pdev-&gt;dev.platform_data;</p>
<p>data = kzalloc(sizeof(*data), GFP_KERNEL);</p>
<p>if (data == NULL) {</p>
<p>ret = -ENOMEM;</p>
<p>goto err_data_alloc_failed;</p>
<p>}</p>
<p>memset(data, 0, sizeof(struct rk30_adc_battery_data));</p>
<p>gBatteryData = data;</p>
<p>platform_set_drvdata(pdev, data);</p>
<p>    data-&gt;pdata = pdata;</p>
<p>data-&gt;status_lock = 0;</p>
<p>ret = rk30_adc_battery_io_init(pdata);</p>
<p>if (ret) {</p>
<p>goto err_io_init;</p>
<p>}</p>
<p>memset(data-&gt;adc_samples, 0, sizeof(int)*(NUM_VOLTAGE_SAMPLE + 2));</p>
<p>//register adc for battery sample</p>
<p>if(0 == pdata-&gt;adc_channel)</p>
<p>client = adc_register(0, rk30_adc_battery_callback, NULL);  //pdata-&gt;adc_channel = ani0</p>
<p>else</p>
<p>client = adc_register(pdata-&gt;adc_channel, rk30_adc_battery_callback, NULL);  </p>
<p>if(!client)</p>
<p>goto err_adc_register_failed;</p>
<p>//variable init</p>
<p>data-&gt;client  = client;</p>
<p>data-&gt;adc_val = adc_sync_read(client);</p>
<p>ret = power_supply_register(&amp;pdev-&gt;dev, &amp;rk30_battery_supply);</p>
<p>if (ret){</p>
<p>printk(KERN_INFO &quot;fail to battery power_supply_register\n&quot;);</p>
<p>goto err_battery_failed;</p>
<p>}</p>
<p>#if defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>ret = power_supply_register(&amp;pdev-&gt;dev, &amp;rk30_usb_supply);</p>
<p>if (ret){</p>
<p>printk(KERN_INFO &quot;fail to usb power_supply_register\n&quot;);</p>
<p>goto err_usb_failed;</p>
<p>}</p>
<p>#endif</p>
<p>  wake_lock_init(&amp;batt_wake_lock, WAKE_LOCK_SUSPEND, &quot;batt_lock&quot;);</p>
<p>data-&gt;wq = create_singlethread_workqueue(&quot;adc_battd&quot;);</p>
<p>INIT_DELAYED_WORK(&amp;data-&gt;delay_work, rk30_adc_battery_timer_work);</p>
<p>//Power on Battery detect</p>
<p>rk30_adc_battery_check(data);</p>
<p>if(1 == pdata-&gt;save_capacity ){</p>
<p>queue_delayed_work(data-&gt;wq, &amp;data-&gt;delay_work, msecs_to_jiffies(TIMER_MS_COUNTS*10));</p>
<p>gBatteryData-&gt;poweron_check = 1;</p>
<p>}else{</p>
<p>queue_delayed_work(data-&gt;wq, &amp;data-&gt;delay_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>gBatteryData-&gt;poweron_check = 0;</p>
<p>}</p>
<p>#if  defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>ret = power_supply_register(&amp;pdev-&gt;dev, &amp;rk30_ac_supply);</p>
<p>if (ret) {</p>
<p>printk(KERN_INFO &quot;fail to ac power_supply_register\n&quot;);</p>
<p>goto err_ac_failed;</p>
<p>}</p>
<p>//init dc dectet irq &amp; delay work</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>INIT_WORK(&amp;data-&gt;dcwakeup_work, rk30_adc_battery_dcdet_delaywork);</p>
<p>irq = gpio_to_irq(pdata-&gt;dc_det_pin);        </p>
<p>irq_flag = gpio_get_value (pdata-&gt;dc_det_pin) ? IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;</p>
<p>    ret = request_irq(irq, rk30_adc_battery_dc_wakeup, irq_flag, &quot;ac_charge_irq&quot;, NULL);</p>
<p>    if (ret) {</p>
<p>    printk(&quot;failed to request dc det irq\n&quot;);</p>
<p>    goto err_dcirq_failed;</p>
<p>    }</p>
<p>    enable_irq_wake(irq);  </p>
<p>}</p>
<p>#endif</p>
<p>#if 1</p>
<p>// batt low irq lowerpower_work</p>
<p>if( pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>INIT_WORK(&amp;data-&gt;lowerpower_work, rk30_adc_battery_lowerpower_delaywork);</p>
<p>irq = gpio_to_irq(pdata-&gt;batt_low_pin);</p>
<p>    ret = request_irq(irq, rk30_adc_battery_low_wakeup, IRQF_TRIGGER_LOW, &quot;batt_low_irq&quot;, NULL);</p>
<p>    if (ret) {</p>
<p>    printk(&quot;failed to request batt_low_irq irq\n&quot;);</p>
<p>    goto err_lowpowerirq_failed;</p>
<p>    }</p>
<p>disable_irq(irq);</p>
<p>    }</p>
<p>#endif</p>
<p>printk(KERN_INFO &quot;rk30_adc_battery: driver initialized\n&quot;);</p>
<p>return 0;</p>
<p>#if defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>err_usb_failed:</p>
<p>power_supply_unregister(&amp;rk30_usb_supply);</p>
<p>#endif</p>
<p>err_ac_failed:</p>
<p>#if defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>power_supply_unregister(&amp;rk30_ac_supply);</p>
<p>#endif</p>
<p>err_battery_failed:</p>
<p>power_supply_unregister(&amp;rk30_battery_supply);</p>
<p>err_dcirq_failed:</p>
<p>free_irq(gpio_to_irq(pdata-&gt;dc_det_pin), data);</p>
<p>#if 1</p>
<p> err_lowpowerirq_failed:</p>
<p>free_irq(gpio_to_irq(pdata-&gt;batt_low_pin), data);</p>
<p>#endif</p>
<p>err_adc_register_failed:</p>
<p>err_io_init:    </p>
<p>err_data_alloc_failed:</p>
<p>kfree(data);</p>
<p>printk(&quot;rk30_adc_battery: error!\n&quot;);</p>
<p>return ret;</p>
<p>}</p>
<p>static int rk30_adc_battery_remove(struct platform_device *pdev)</p>
<p>{</p>
<p>struct rk30_adc_battery_data *data = platform_get_drvdata(pdev);</p>
<p>struct rk30_adc_battery_platform_data *pdata = pdev-&gt;dev.platform_data;</p>
<p>cancel_delayed_work(&amp;gBatteryData-&gt;delay_work);</p>
<p>#if defined(CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>power_supply_unregister(&amp;rk30_usb_supply);</p>
<p>#endif</p>
<p>#if defined(CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>power_supply_unregister(&amp;rk30_ac_supply);</p>
<p>#endif</p>
<p>power_supply_unregister(&amp;rk30_battery_supply);</p>
<p>free_irq(gpio_to_irq(pdata-&gt;dc_det_pin), data);</p>
<p>kfree(data);</p>
<p>return 0;</p>
<p>}</p>
<p>static struct platform_driver rk30_adc_battery_driver = {</p>
<p>.probe = rk30_adc_battery_probe,</p>
<p>.remove = rk30_adc_battery_remove,</p>
<p>.suspend = rk30_adc_battery_suspend,</p>
<p>.resume = rk30_adc_battery_resume,</p>
<p>.driver = {</p>
<p>.name = &quot;rk30-battery&quot;,</p>
<p>.owner = THIS_MODULE,</p>
<p>}</p>
<p>};</p>
<p>static int __init rk30_adc_battery_init(void)</p>
<p>{</p>
<p>return platform_driver_register(&amp;rk30_adc_battery_driver);</p>
<p>}</p>
<p>static void __exit rk30_adc_battery_exit(void)</p>
<p>{</p>
<p>platform_driver_unregister(&amp;rk30_adc_battery_driver);</p>
<p>}</p>
<p>//subsys_initcall(rk30_adc_battery_init);//subsys_initcall(rk30_adc_battery_init);</p>
<p>module_init(rk30_adc_battery_init);//subsys_initcall(rk30_adc_battery_init);</p>
<p>module_exit(rk30_adc_battery_exit);</p>
<p>MODULE_DESCRIPTION(&quot;Battery detect driver for the rk30&quot;);</p>
<p>MODULE_AUTHOR(&quot;luowei <a href="mailto:&#x6c;&#x77;&#64;&#114;&#111;&#99;&#107;&#45;&#x63;&#104;&#x69;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#109;">&#x6c;&#x77;&#64;&#114;&#111;&#99;&#107;&#45;&#x63;&#104;&#x69;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#109;</a>&quot;);</p>
<p>MODULE_LICENSE(&quot;GPL&quot;);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>pck_type 打包</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/pck_type%20%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<ul>
<li>FILENAME  :   </li>
<li>AUTHOR    :   <a href="mailto:&#x66;&#101;&#x6e;&#x67;&#x6a;&#108;&#48;&#x32;&#x36;&#x40;&#49;&#x32;&#54;&#x2e;&#99;&#x6f;&#x6d;">&#x66;&#101;&#x6e;&#x67;&#x6a;&#108;&#48;&#x32;&#x36;&#x40;&#49;&#x32;&#54;&#x2e;&#99;&#x6f;&#x6d;</a></li>
<li>DATA      :   2007-1-3</li>
<li>MODIFY    :   </li>
<li>HISTORY   :   </li>
<li>DESC      :   pck_type 打包</li>
<li>COPYRIGHT :   深圳永辉昌 2007</li>
<li><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>#include &quot;config.h&quot;<br>#include &quot;ezxml.h&quot;<br>#include &quot;readDB.h&quot;<br>#include &quot;pck_type.h&quot;<br>#include &quot;command.h&quot;<br>#ifdef __cplusplus<br>extern &quot;C&quot; {<br>#endif<br>extern HANDLE                             g_carportHandle ;     //诊断串口句柄<br>extern DEFAULT_MSGATTR                      g_defaultMsgAttr;     //MSG项的缺省参数<br>int unpack_mbuf(int type, U8 *buf, int bufsize)<br>{<br>//分裂<br>int pos = 0;<br>//int times = 0;<br>U8 rbuf[256];<br>int len = 0;<br>int num;<br>while(pos + buf[3+pos] +5 &lt;= bufsize)<br>  {<pre><code> num = unpack_buf(type, buf+pos, buf[pos+3]+5);</code></pre>
memcpy(rbuf+len, buf+pos,num);<br>len += num;<br>pos += buf[3+pos] + 5;<br>}<br>  memcpy(buf, rbuf, len);<br>return len;<br>}<br>int unpack_buf(int type,U8 <em>buf, int bufsize)<br>{<br>if((buf[4]&amp;0xf0) == 0xf0)<br>  {<br>return 0;<br>}<br>switch(type)<br>  {<br>case 0: return unpack_buf0(buf,bufsize);<br>case 1: return unpack_buf1(buf,bufsize);<br>case 2: return unpack_buf2(buf,bufsize);<br>case 3: return unpack_buf3(buf,bufsize);<br>case 4: return unpack_buf4(buf,bufsize);<br>case 5: return unpack_buf5(buf,bufsize);<br>case 6: return unpack_buf6(buf,bufsize);//解包方式同方式零,但校验位CRC校验<br>case 7: return unpack_buf7(buf,bufsize);//解包方式同方式零,但校验位为一字节和<br>case 8: return unpack_buf8(buf,bufsize);<br>case 9: return unpack_buf9(buf,bufsize);<br>case 0x0a: return unpack_bufa(buf,bufsize);<br>case 0x0b: return unpack_bufb(buf,bufsize);<br>case 0x0c: return unpack_bufc(buf,bufsize);<br>case 0x0d: return unpack_bufd(buf,bufsize);<br>case 0x0e: return unpack_bufe(buf,bufsize);<br>case 0x0f: return unpack_buff(buf,bufsize);<br>case 0x13: return unpack_buf13(buf,bufsize);<br>case 0x14: return unpack_buf14(buf,bufsize);<br>}<br>return 0;<br>}<br>/</em><br>FMT:格式头<br>TGT:发送ID<br>SRC:接收ID<br>LEN:命令数据长度<br>SID:命令头，一般是SID+DATA表示一条完整的命令<br>DATA:命令内容<br>CS:一字节校验和<br>0x00:直接打包，无校验<br>0x01:KWP2000格式1 Fmt    + Sid + Data + CS        (0x80+len)<br>0x02:KWP2000格式2 Fmt + Tgt + Src + Sid + Data + CS     (0x80+len)<br>0x03:KWP2000格式3 Fmt + Len + Sid + Data + CS          (80)<br>0x04:KWP2000格式4 Fmt + Tgt + Src + Len + Sid + Data + CS    (80)<br>0x05:KWP2000格式5 Fmt + Tgt + Src + Sid + Data + CS       (68) Tgt:0x6A<br>0X06:主要是通用VPW协议，打包方式同方式零,但校验位CRC校验<br>0X07:KWP2000格式，打包方式同方式零,校验位是一字节和<br>0x08:马自达老协议打包方式 FMT + TGT + SRC + SID + DATA + CS (0x04+LEN*0x10)<br>0x09:OBDII,TGT=6A,校验位CRC校验<br>0x0a:福特，加C4的头,校验位CRC校验<br>0x0b:OBDII,68,6a,f1,其它同打包方式9<br>0x0c:打包方式同方式零,加长度和一字节校验和 LEN + SID + DATA + CS<br>0x0d:打包方式同方式2, FMT + TGT + SRC + SID + DATA + CS (0xc0+len)<br>0x0e:打包方式同方式零,第三位是数据长度，最后两位是前面全部字节的和，低字节在前,高字节在后(主要用于奔驰协议)<br>0x0f:打包方式同方式0，第二位是长度，校验位为一字节和取补<br>0x13:打包方式同方式0，最后一位是异或校验<br>0x14:打包方式同方式0，倒数第二位是异或校验,最后一位是一字节和取反</li>
<li>/<br>int pack_type(ezxml_t xml, U8 *u8buf ,int bufsize)<br>{<br>switch(getPackType(xml))<br>  {<br>case 0: return pack_type0(xml,u8buf, bufsize);<br>case 1: return pack_type1(xml,u8buf, bufsize);<br>case 2: return pack_type2(xml,u8buf, bufsize);<br>case 3: return pack_type3(xml,u8buf, bufsize);<br>case 4: return pack_type4(xml,u8buf, bufsize);<br>case 5: return pack_type5(xml,u8buf, bufsize);<br>case 6: return pack_type6(xml,u8buf, bufsize);<br>case 7: return pack_type7(xml,u8buf, bufsize);<br>case 8: return pack_type8(xml,u8buf, bufsize);<br>case 9: return pack_type9(xml,u8buf, bufsize);<br>case 0x0a: return pack_typea(xml,u8buf, bufsize);<br>case 0x0b: return pack_typeb(xml,u8buf, bufsize);<br>case 0x0c: return pack_typec(xml,u8buf, bufsize);<br>case 0x0d: return pack_typed(xml,u8buf, bufsize);<br>case 0x0e: return pack_typee(xml,u8buf, bufsize);<br>case 0x0f: return pack_typef(xml,u8buf, bufsize);<br>case 0x13: return pack_type13(xml,u8buf, bufsize);<br>case 0x14: return pack_type14(xml,u8buf, bufsize);<br>}<br>return 0;<br>}<br>int getPackType(ezxml_t msgxml)<br>{<br>char *pck_type = (char *)ezxml_attr(msgxml, &quot;PCK_TYPE&quot;);<br>if(pck_type)<br>return getHex(pck_type);      <br>return g_defaultMsgAttr.m_PCK_TYPE;<br>}<br>int unpack_bufb(U8 *buf, int bufsize)<br>{<br>int m=0;<br>int i,j,k;<br>int l=285;int n;<br>//int number=0;<br>if(bufsize &lt; 9)<br>return 0;<br>for(i=5; i&lt;bufsize; i++)<br>  {<pre><code> buf[m++] = buf[i];</code></pre>
}<br>  m=bufsize-5;<br>buf[m-1] = buf[m-2];<br>buf[m-2] = 0;<br>if(m==9||m==8||m==13||m==7||m==11||m==10||m==6||m==12)<br>  {  <pre><code> buf[m-2]=0x0a;</code></pre>
if(m==8)<pre><code>    buf[m-2]=0xf6;</code></pre>
if(m==13)<pre><code>    buf[m-2]=0xe2;</code></pre>
if(m==7)<pre><code>    buf[m-2]=0x10;</code></pre>
if(m==11)<pre><code>    buf[m-2]=0x7c;</code></pre>
if(m==10)<pre><code>    buf[m-2]=0xe9;</code></pre>
if(m==12)<pre><code>    buf[m-2]=0xfe;</code></pre>
if(m==6)<pre><code>    buf[m-2]=0x59;</code></pre>
j=buf[0];<br>for(i=1;i&lt;m-1;i++)<pre><code> &#123;</code></pre>
//MessageBox(&quot;ok&quot;);<br>for(k=0;k&lt;8;k++)<pre><code>    &#123;
       j=j&amp;lt;&amp;lt;1;</code></pre>
n=(buf[i]&gt;&gt;(7-k))&amp;0x01;<br>j+=n;<br>if(j&gt;255)<pre><code>          j=j^l;</code></pre>
}<pre><code> &#125;
 buf[m-2]=j;</code></pre>
}<br>if(buf[m-1]!=buf[m-2])<br>return 0;<br>else<br>     return m-2;<br>}<br>int unpack_bufa(U8 *buf, int bufsize)<br>{<br>int m=0;<br>int i,j,k;<br>int l=285;int n;<br>//int number=0;<br>if(bufsize &lt; 9)<br>return 0;<br>for(i=5; i&lt;bufsize; i++)<br>  {<pre><code> buf[m++] = buf[i];</code></pre>
}<br>  m=bufsize-5;<br>buf[m-1] = buf[m-2];<br>buf[m-2] = 0;<br>if(m==9||m==8||m==13||m==7||m==11||m==10||m==6||m==12)<br>  {  <pre><code> buf[m-2]=0x0a;</code></pre>
if(m==8)<pre><code>    buf[m-2]=0xf6;</code></pre>
if(m==13)<pre><code>    buf[m-2]=0xe2;</code></pre>
if(m==7)<pre><code>    buf[m-2]=0x10;</code></pre>
if(m==11)<pre><code>    buf[m-2]=0x7c;</code></pre>
if(m==10)<pre><code>    buf[m-2]=0xe9;</code></pre>
if(m==12)<pre><code>    buf[m-2]=0xfe;</code></pre>
if(m==6)<pre><code>    buf[m-2]=0x59;</code></pre>
j=buf[0];<br>for(i=1;i&lt;m-1;i++)<pre><code> &#123;</code></pre>
//MessageBox(&quot;ok&quot;);<br>for(k=0;k&lt;8;k++)<pre><code>    &#123;
       j=j&amp;lt;&amp;lt;1;</code></pre>
n=(buf[i]&gt;&gt;(7-k))&amp;0x01;<br>j+=n;<br>if(j&gt;255)<pre><code>          j=j^l;</code></pre>
}<pre><code> &#125;
 buf[m-2]=j;</code></pre>
}<br>if(buf[m-1]!=buf[m-2])<br>return 0;<br>else<br>     return m-2;<br>}<br>int unpack_buf9(U8 *buf, int bufsize)<br>{<br>int m=0;<br>int i,j,k;<br>int l=285;int n;<br>//int number=0;<br>if(bufsize &lt; 9)<br>return 0;<br>for(i=5; i&lt;bufsize; i++)<br>  {<pre><code> buf[m++] = buf[i];</code></pre>
}<br>  m=bufsize-5;<br>buf[m-1] = buf[m-2];<br>buf[m-2] = 0;<br>if(m==9||m==8||m==13||m==7||m==11||m==10||m==6||m==12)<br>  {  <pre><code> buf[m-2]=0x0a;</code></pre>
if(m==8)<pre><code>    buf[m-2]=0xf6;</code></pre>
if(m==13)<pre><code>    buf[m-2]=0xe2;</code></pre>
if(m==7)<pre><code>    buf[m-2]=0x10;</code></pre>
if(m==11)<pre><code>    buf[m-2]=0x7c;</code></pre>
if(m==10)<pre><code>    buf[m-2]=0xe9;</code></pre>
if(m==12)<pre><code>    buf[m-2]=0xfe;</code></pre>
if(m==6)<pre><code>    buf[m-2]=0x59;</code></pre>
j=buf[0];<br>for(i=1;i&lt;m-1;i++)<pre><code> &#123;</code></pre>
//MessageBox(&quot;ok&quot;);<br>for(k=0;k&lt;8;k++)<pre><code>    &#123;
       j=j&amp;lt;&amp;lt;1;</code></pre>
n=(buf[i]&gt;&gt;(7-k))&amp;0x01;<br>j+=n;<br>if(j&gt;255)<pre><code>          j=j^l;</code></pre>
}<pre><code> &#125;
 buf[m-2]=j;</code></pre>
}<br>if(buf[m-1]!=buf[m-2])<br>return 0;<br>else<br>     return m-2;<br>}<br>int unpack_buf8(U8 *buf, int bufsize)<br>{<br>int m=0;<br>int i,j;<br>int n = 0;<br>U8 u8buf[128];<br>int number = 0 ;<br>if(bufsize &lt; 9)<br>return 0;<br>for(i=5; i&lt;bufsize; i++)<br>  {<pre><code> buf[m++] = buf[i];</code></pre>
}<br>  m=bufsize-5;<br>if(m &gt; (buf[0]/16+2))<br>  {<pre><code> number = m;</code></pre>
for(j = 0; number &gt;1; )<pre><code> &#123;
    memcpy(u8buf, buf+j, number);</code></pre>
n = u8buf[0]/16+1;<br>u8buf[n] = 0;<br>for(i = 0; i&lt;n-1; i++)<pre><code>    &#123;
       u8buf[n] += u8buf[i];</code></pre>
}<br>if(u8buf[n]!=u8buf[n-1])<br>return 0;<br>number = number-n;<br>j = j+n;<br>}<br>return m-1;<br>}<br>else<br>{<pre><code> buf[m] = 0;</code></pre>
for(i = 0; i&lt;m-2; i++)<pre><code> &#123;
    buf[m] += buf[i];</code></pre>
}<br>if(buf[m]!=buf[m-2])<br>return 0;<br>}<br>return m-2;<br>}<br>int unpack_buf7(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>U8 cs=0;<br>if(bufsize &lt; 5)<br>return 0;<br>for(i=5; i&lt;bufsize; i++)<br>  {<pre><code> buf[number++] = buf[i];</code></pre>
}<br>  number–;<br>for(i=0;i&lt;number-1;i++)<pre><code> cs+=buf[i];</code></pre>
if(cs!=buf[number-1])<br>return 0;<br>return number;<br>}<br>int unpack_buf6(U8 *buf, int bufsize)<br>{<br>int m=0;<br>int i,j,k;<br>int l=285;int n;<br>if(bufsize &lt; 5)<br>return 0;<br>for(i=5; i&lt;bufsize; i++)<br>  {<pre><code> buf[m++] = buf[i];</code></pre>
}<br>  m=bufsize-5;<br>buf[m-1]=buf[m-2];<br>if(m==9||m==8||m==13||m==7||m==11||m==10||m==6||m==12)<br>  {  <pre><code> buf[m-2]=0x0a;</code></pre>
if(m==8)<pre><code>    buf[m-2]=0xf6;</code></pre>
if(m==13)<pre><code>    buf[m-2]=0xe2;</code></pre>
if(m==7)<pre><code>    buf[m-2]=0x10;</code></pre>
if(m==11)<pre><code>    buf[m-2]=0x7c;</code></pre>
if(m==10)<pre><code>    buf[m-2]=0xe9;</code></pre>
if(m==12)<pre><code>    buf[m-2]=0xfe;</code></pre>
if(m==6)<pre><code>    buf[m-2]=0x59;</code></pre>
j=buf[0];<br>for(i=1;i&lt;m-1;i++)<pre><code> &#123;</code></pre>
//MessageBox(&quot;ok&quot;);<br>for(k=0;k&lt;8;k++)<pre><code>    &#123;
       j=j&amp;lt;&amp;lt;1;</code></pre>
n=(buf[i]&gt;&gt;(7-k))&amp;0x01;<br>j+=n;<br>if(j&gt;255)<pre><code>          j=j^l;</code></pre>
}<pre><code> &#125;
 buf[m-2]=j;</code></pre>
}<br>if(buf[m-2]!=buf[m-1])<br>return 0;<br>else<br>     return m-1;<br>}<br>int unpack_buf5(U8 *buf, int bufsize)<br>{<br>int number = 0;<br>int i;<br>if(bufsize &lt; 9)<br>return 0;<br>if(buf[5] != 0x48)<br>return 0;<br>for(i=8; i&lt;bufsize; i++)<br>  {<pre><code> buf[number++] = buf[i];</code></pre>
}<br>return number-1;<br>}<br>int unpack_buf4(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>U8 len;<br>//U8 hex = 0;<br>if(bufsize &lt; 8)<br>return 0;<br>//长度校验<br>len = buf[5]&amp;0x3f;<br>if(len==0)<br>  {<pre><code> len=buf[8];</code></pre>
number=9;<br>}<br>else<br>number=8;<br>if(bufsize &lt; number+ len+1)<br>return 0;<br>//校验和校验<br>  //for(i = 0; i&lt; len+3;i++)<br>  //{<br>  // hex += buf[5+i];<br>  //}<br>  //if(hex != buf[5+i])<br>  // return 0;<br>for(i=0; i&lt;len; i++)<br>  {<pre><code> buf[i]= buf[number+i];</code></pre>
}<br>  buf[i] = ‘\0’;<br>return len;<br>}<br>int unpack_buf3(U8 *buf, int bufsize)<br>{<br>int number = 0;<br>int i;<br>int len;<br>if(bufsize &lt; 7)<br>return 0;<br>len = buf[5]&amp;0x3f;    //去掉最高两位<br>if(len==0)<br>  {<pre><code> len=buf[6];</code></pre>
number=6;<br>}<br>else<br>number=5;<br>if(bufsize &lt; number + len+1)<br>return 0;<br>//校验和校验<br>  //for(i = 0; i&lt; len+1;i++)<br>  //{<br>  // hex += buf[5+i];<br>  //}<br>  //if(hex != buf[5+i])<br>  // return 0;<br>for(i=0; i&lt;len;i++)<br>  {<pre><code> buf[i] = buf[number+i];</code></pre>
}<br>return len;<br>}<br>int unpack_buf2(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>U8 len;<br>//U8 hex = 0;<br>if(bufsize &lt; 8)<br>return 0;<br>//长度校验<br>len = buf[5]&amp;0x3f;<br>if(len==0)<br>  {<pre><code> len=buf[8];</code></pre>
number=9;<br>}<br>else<br>number=8;<br>if(bufsize &lt; number+ len+1)<br>return 0;<br>//校验和校验<br>  //for(i = 0; i&lt; len+3;i++)<br>  //{<br>  // hex += buf[5+i];<br>  //}<br>  //if(hex != buf[5+i])<br>  // return 0;<br>for(i=0; i&lt;len; i++)<br>  {<pre><code> buf[i]= buf[number+i];</code></pre>
}<br>  buf[i] = ‘\0’;<br>return len;<br>}<br>int unpack_buf1(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>U8 len;<br>if(bufsize &lt; 7)<br>return 0;<br>len = buf[5]&amp;0x3f;    //去掉最高两位<br>if(len==0)<br>  {<pre><code> len=buf[6];</code></pre>
number=6;<br>}<br>else<br>number=5;<br>if(bufsize &lt; number+1 + len)<br>return 0;<br>//校验和校验<br>  //for(i = 0; i&lt; len+1;i++)<br>  //{<br>  // hex += buf[5+i];<br>  //}<br>  //if(hex != buf[5+i])<br>  // return 0;<br>for(i=0; i&lt;len;i++)<br>  {<pre><code> buf[i] = buf[number+i];</code></pre>
}<br>  buf[i] = ‘\0’;<br>return len;<br>}<br>int unpack_buf0(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>if(bufsize &lt; 5)<br>return 0;<br>for(i=5; i&lt;bufsize; i++)<br>  {<pre><code> buf[number++] = buf[i];</code></pre>
}<br>  buf[i] = ‘\0’;<br>return number-1;<br>}<br>int unpack_buf13(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>if(bufsize &lt; 5)<br>return 0;<br>for(i=5; i&lt;bufsize; i++)<br>  {<pre><code> buf[number++] = buf[i];</code></pre>
}<br>//计算校验位 异或<br>buf[number] = buf[0];<br>for(i=1;i&lt;number;i++)<br>  {<pre><code> buf[number] ^= buf[i];</code></pre>
}<br>if(buf[number] != buf[number-1])<br>  {<br>return 0;<br>}<br>return number-1;<br>}<br>int unpack_buf14(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>if(bufsize &lt; 5)<br>return 0;<br>for(i=5; i&lt;bufsize; i++)<br>  {<pre><code> buf[number++] = buf[i];</code></pre>
}<br>//计算校验位 异或<br>buf[number] = buf[0];<br>for(i=1;i&lt;number-2;i++)<br>  {<pre><code> buf[number] ^= buf[i];</code></pre>
}<br>if(buf[number] != buf[number-2])<br>  {<br>return 0;<br>}<br>return number-1;<br>}<br>int unpack_bufc(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>if(bufsize &lt; 6)<br>return 0;<br>if(buf[5] == buf[3] - 3)<br>  {<pre><code> number = buf[5];//number为长度</code></pre>
number+=2;<br>memcpy(buf,buf+5,number);<br>//计算校验和<br>buf[number] = 0x00;<br>for(i=0;i&lt;number-1;i++)<pre><code>    buf[number] += buf[i];</code></pre>
if(buf[number] != buf[number-1])<pre><code> &#123;
    memcpy(buf,buf+1,number-2);</code></pre>
return 0;<br>}<br>else<br>{<pre><code>    memcpy(buf,buf+1,number-2);</code></pre>
return number-2;<br>}<br>  }<br>else<br>     return 0;<br>}<br>//暂时以方式2解包<br>int unpack_bufd(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>U8 len;<br>//U8 hex = 0;<br>if(bufsize &lt; 8)<br>return 0;<br>//长度校验<br>len = buf[5]&amp;0x3f;<br>if(len==0)<br>  {<pre><code> len=buf[8];</code></pre>
number=9;<br>}<br>else<br>number=8;<br>if(bufsize &lt; number+ len+1)<br>return 0;<br>//校验和校验<br>  //for(i = 0; i&lt; len+3;i++)<br>  //{<br>  // hex += buf[5+i];<br>  //}<br>  //if(hex != buf[5+i])<br>  // return 0;<br>for(i=0; i&lt;len; i++)<br>  {<pre><code> buf[i]= buf[number+i];</code></pre>
}<br>  buf[i] = ‘\0’;<br>return len;<br>}<br>int unpack_buff(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>U8 len;<br>if(bufsize &lt; 8)<br>return 0;<br>number=5;<br>//长度校验<br>len = buf[6];<br>//if(bufsize &lt; len+6)<br>  // return 0;<br>  //校验和校验<br>  //for(i = 0; i&lt; len+3;i++)<br>  //{<br>  // hex += buf[5+i];<br>  //}<br>  //if(hex != buf[5+i])<br>  // return 0;<br>for(i=0; i&lt;len; i++)<br>  {<pre><code> buf[i]= buf[number+i];</code></pre>
}<br>  buf[i] = ‘\0’;<br>return len;<br>}<br>//解包只校验了数据长度<br>int unpack_bufe(U8 *buf, int bufsize)<br>{<br>int number=0;<br>int i;<br>int dnumber=0;<br>if(bufsize &lt; 5)<br>return 0;<br>if(buf[07] != bufsize-6)<br>return 0;<br>for(i=5; i&lt;bufsize-3; i++)<br>  {<pre><code> buf[number++] = buf[i];</code></pre>
dnumber += buf[i];<br>}<br>while(i&lt;bufsize)<br>  {<pre><code> buf[number++] = buf[i++];</code></pre>
}<br>if(buf[number-3] == (dnumber&amp;0x00FF) &amp;&amp; buf[number-2] == (dnumber&amp;0xFF00)&gt;&gt;8)<br>return number-1;<br>else<br>     return 0;<br>}<br>int pack_typeb(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 8;<br>char <em>p;<br>int i;<br>char *p0 ;<br>//int l=285;<br>int m,j,k,n,l;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>m = getHexEx(p0,u8buf+number);<br>//头<br>p = (char</em>)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>p=(char*)ezxml_attr(xml,&quot;TGT&quot;);<br>if(p)<pre><code> u8buf[6] = getHex(p);</code></pre>
else<br>u8buf[6] = g_defaultMsgAttr.m_TGT;<br>if(u8buf[6] == 0x6a)<br>  {<pre><code> u8buf[5] = 0x68;</code></pre>
u8buf[6] = 0x6a;<br>p =(char*)ezxml_attr(xml,&quot;SRC&quot;);<br>if(p)<pre><code>    u8buf[7] = getHex(p);</code></pre>
else<br>u8buf[7] = g_defaultMsgAttr.m_SRC;<br>}<br>else<br>     return 0;<br>//u8buf[5] = m*0x10 + 0x34;<br>m+=4;<br>number = m ;<br>number +=5;<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>//CRC校验<br>l=285;<br>if(m==8||m==7||m==12||m==6||m==10||m==9||m==5||m==11)<br>  {  <pre><code> u8buf[number-1]=0x0a;</code></pre>
if(m==7)<pre><code>    u8buf[number-1]=0xf6;</code></pre>
if(m==12)<pre><code>    u8buf[number-1]=0xe2;</code></pre>
if(m==6)<pre><code>    u8buf[number-1]=0x10;</code></pre>
if(m==10)<pre><code>    u8buf[number-1]=0x7c;</code></pre>
if(m==9)<pre><code>    u8buf[number-1]=0xe9;</code></pre>
if(m==11)<pre><code>    u8buf[number-1]=0xfe;</code></pre>
if(m==5)<pre><code>    u8buf[number-1]=0x59;</code></pre>
j=u8buf[5];<br>for(i=6;i&lt;number;i++)<pre><code> &#123;</code></pre>
//MessageBox(&quot;ok&quot;);<br>for(k=0;k&lt;8;k++)<pre><code>    &#123;
       j=j&amp;lt;&amp;lt;1;</code></pre>
n=(u8buf[i]&gt;&gt;(7-k))&amp;0x01;<br>j+=n;<br>if(j&gt;255)<pre><code>          j=j^l;</code></pre>
}<pre><code> &#125;
 u8buf[number-1]=j;</code></pre>
}<br>  u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_typea(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 8;<br>int i;<br>char <em>p;<br>char *p0 ;<br>int l=285;<br>int m,j,k,n;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>m = getHexEx(p0,u8buf+number);<br>//头<br>p = (char</em>)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>p=(char*)ezxml_attr(xml,&quot;TGT&quot;);<br>if(p)<pre><code> u8buf[6] = getHex(p);</code></pre>
else<br>u8buf[6] = g_defaultMsgAttr.m_TGT;<br>p =(char*)ezxml_attr(xml,&quot;SRC&quot;);<br>if(p)<pre><code> u8buf[7] = getHex(p);</code></pre>
else<br>u8buf[7] = g_defaultMsgAttr.m_SRC;<br>getHexEx(p0,u8buf+number);<br>u8buf[5] = 0xc4;<br>number = m ;<br>number += 8;<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>m += 3;    <br>//CRC校验<br>if(m==8||m==7||m==12||m==6||m==10||m==9||m==5||m==11)<br>  {  <pre><code> u8buf[number-1]=0x0a;</code></pre>
if(m==7)<pre><code>    u8buf[number-1]=0xf6;</code></pre>
if(m==12)<pre><code>    u8buf[number-1]=0xe2;</code></pre>
if(m==6)<pre><code>    u8buf[number-1]=0x10;</code></pre>
if(m==10)<pre><code>    u8buf[number-1]=0x7c;</code></pre>
if(m==9)<pre><code>    u8buf[number-1]=0xe9;</code></pre>
if(m==11)<pre><code>    u8buf[number-1]=0xfe;</code></pre>
if(m==5)<pre><code>    u8buf[number-1]=0x59;</code></pre>
j=u8buf[5];<br>for(i=6;i&lt;number;i++)<pre><code> &#123;</code></pre>
//MessageBox(&quot;ok&quot;);<br>for(k=0;k&lt;8;k++)<pre><code>    &#123;
       j=j&amp;lt;&amp;lt;1;</code></pre>
n=(u8buf[i]&gt;&gt;(7-k))&amp;0x01;<br>j+=n;<br>if(j&gt;255)<pre><code>          j=j^l;</code></pre>
}<pre><code> &#125;
 u8buf[number-1]=j;</code></pre>
}<br>  u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type9(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 8;<br>char <em>p;<br>int i;<br>char *p0 ;<br>//int l=285;<br>int m,j,k,n,l;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>m = getHexEx(p0,u8buf+number);<br>//头<br>p = (char</em>)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>p=(char*)ezxml_attr(xml,&quot;TGT&quot;);<br>if(p)<pre><code> u8buf[6] = getHex(p);</code></pre>
else<br>u8buf[6] = g_defaultMsgAttr.m_TGT;<br>if(u8buf[6] == 0x6a)<br>  {<pre><code> u8buf[5] = 0x61;</code></pre>
u8buf[6] = 0x6a;<br>p =(char*)ezxml_attr(xml,&quot;SRC&quot;);<br>if(p)<pre><code>    u8buf[7] = getHex(p);</code></pre>
else<br>u8buf[7] = g_defaultMsgAttr.m_SRC;<br>}<br>else<br>     return 0;<br>//u8buf[5] = m*0x10 + 0x34;<br>m+=4;<br>number = m ;<br>number +=5;<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>//CRC校验<br>l=285;<br>if(m==8||m==7||m==12||m==6||m==10||m==9||m==5||m==11)<br>  {  <pre><code> u8buf[number-1]=0x0a;</code></pre>
if(m==7)<pre><code>    u8buf[number-1]=0xf6;</code></pre>
if(m==12)<pre><code>    u8buf[number-1]=0xe2;</code></pre>
if(m==6)<pre><code>    u8buf[number-1]=0x10;</code></pre>
if(m==10)<pre><code>    u8buf[number-1]=0x7c;</code></pre>
if(m==9)<pre><code>    u8buf[number-1]=0xe9;</code></pre>
if(m==11)<pre><code>    u8buf[number-1]=0xfe;</code></pre>
if(m==5)<pre><code>    u8buf[number-1]=0x59;</code></pre>
j=u8buf[5];<br>for(i=6;i&lt;number;i++)<pre><code> &#123;</code></pre>
//MessageBox(&quot;ok&quot;);<br>for(k=0;k&lt;8;k++)<pre><code>    &#123;
       j=j&amp;lt;&amp;lt;1;</code></pre>
n=(u8buf[i]&gt;&gt;(7-k))&amp;0x01;<br>j+=n;<br>if(j&gt;255)<pre><code>          j=j^l;</code></pre>
}<pre><code> &#125;
 u8buf[number-1]=j;</code></pre>
}<br>  u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type8(ezxml_t xml, U8 <em>u8buf, int bufsize)<br>{<br>int number = 8;<br>int i;<br>char <em>p;<br>char *p0 ;<br>//int l=285;<br>int m;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>m = getHexEx(p0,u8buf+number);<br>u8buf[5] = m</em>0x10 + 0x34;<br>number = m ;<br>number += 9;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char</em>)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>p=(char*)ezxml_attr(xml,&quot;TGT&quot;);<br>if(p)<pre><code> u8buf[6] = getHex(p);</code></pre>
else<br>u8buf[6] = g_defaultMsgAttr.m_TGT;<br>p =(char*)ezxml_attr(xml,&quot;SRC&quot;);<br>if(p)<pre><code> u8buf[7] = getHex(p);</code></pre>
else<br>u8buf[7] = g_defaultMsgAttr.m_SRC;<br>//校验和<br>u8buf[number-1] = 0;<br>for(i = 5; i&lt;number-1; i++)<br>  {<pre><code> u8buf[number-1] += u8buf[i];</code></pre>
}<br>  u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type7(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char <em>p;<br>char *p0 ;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>number+=getHexEx(p0,u8buf+number);<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char</em>)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>u8buf[number-1]=0;<br>for(i=5;i&lt;number-1;i++)<pre><code> u8buf[number-1]+=u8buf[i];</code></pre>
//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type6(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char <em>p;<br>char *p0 ;<br>int l=285;<br>int m,j,k,n;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>number=getHexEx(p0,u8buf+number);<br>number+=5;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char</em>)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>m=number-5;<br>//CRC校验<br>if(m==8||m==7||m==12||m==6||m==10||m==9||m==5||m==11)<br>  {  <pre><code> u8buf[number-1]=0x0a;</code></pre>
if(m==7)<pre><code>    u8buf[number-1]=0xf6;</code></pre>
if(m==12)<pre><code>    u8buf[number-1]=0xe2;</code></pre>
if(m==6)<pre><code>    u8buf[number-1]=0x10;</code></pre>
if(m==10)<pre><code>    u8buf[number-1]=0x7c;</code></pre>
if(m==9)<pre><code>    u8buf[number-1]=0xe9;</code></pre>
if(m==11)<pre><code>    u8buf[number-1]=0xfe;</code></pre>
if(m==5)<pre><code>    u8buf[number-1]=0x59;</code></pre>
j=u8buf[5];<br>for(i=6;i&lt;number;i++)<pre><code> &#123;</code></pre>
//MessageBox(&quot;ok&quot;);<br>for(k=0;k&lt;8;k++)<pre><code>    &#123;
       j=j&amp;lt;&amp;lt;1;</code></pre>
n=(u8buf[i]&gt;&gt;(7-k))&amp;0x01;<br>j+=n;<br>if(j&gt;255)<pre><code>          j=j^l;</code></pre>
}<pre><code> &#125;
 u8buf[number-1]=j;</code></pre>
}<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type5(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char *p;<br>char *p0 ;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>u8buf[number++] = 0x68;<br>u8buf[number++] = 0x6a;<br>p = (char *)ezxml_attr(xml,&quot;SRC&quot;);<br>if(p)<pre><code> u8buf[number++] = getHex(p);</code></pre>
else<br>u8buf[number++] = g_defaultMsgAttr.m_SRC;<br>number+=getHexEx(p0,u8buf+number);<br>/<em>u8buf[number++] = getHex(p0);<br>  while(p = (char</em>)strstr(p0,&quot;,&quot;))<br>  {<br>     u8buf[number++] = getHex(p+1);<br>     p0 = p+1;<br>     if(number &gt;= bufsize)<br>        break;<br>  }*/<br>  //校验<br>u8buf[number] = 0;<br>for(i = 5; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  number++;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type4(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char <em>p;<br>char *p0 ;<br>U8 buf[256];<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>u8buf[number++] = 0x80;<br>p=(char</em>)ezxml_attr(xml,&quot;TGT&quot;);<br>if(p)<pre><code> u8buf[number++] = getHex(p);</code></pre>
else<br>u8buf[number++] = g_defaultMsgAttr.m_TGT;<br>p =(char*)ezxml_attr(xml,&quot;SRC&quot;);<br>if(p)<pre><code> u8buf[number++] = getHex(p);</code></pre>
else<br>u8buf[number++] = g_defaultMsgAttr.m_SRC;<br>u8buf[number++] =getHexEx(ezxml_txt(xml),buf);<br>number+=getHexEx(p0,u8buf+number);<br>/<em>u8buf[number++] = getHex(p0);<br>  while(p = (char</em>)strstr(p0,&quot;,&quot;))<br>  {<br>     u8buf[number++] = getHex(p+1);<br>     p0 = p+1;<br>     if(number &gt;= bufsize)<br>        break;<br>  }<br>  */<br>u8buf[number] = 0;<br>for(i = 5; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  number++;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type3(ezxml_t xml, U8 <em>u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char *p;<br>char *p0 ;<br>U8  buf[256];<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>u8buf[number++] = 0x80;<br>u8buf[number++] = getHexEx(ezxml_txt(xml),buf);<br>number+=getHexEx(p0,u8buf+number);<br>/*u8buf[number++] = getHex(p0);<br>  while(p = (char</em>)strstr(p0,&quot;,&quot;))<br>  {<br>     u8buf[number++] = getHex(p+1);<br>     p0 = p+1;<br>     if(number &gt;= bufsize)<br>        break;<br>  }<br>  */<br>u8buf[number] = 0;<br>for(i = 5; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  number++;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type2(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char <em>p;<br>char *p0 ;<br>U8 buf[256];<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>u8buf[number++] = 0x80 + getHexEx(ezxml_txt(xml),buf);<br>p=(char</em>)ezxml_attr(xml,&quot;TGT&quot;);<br>if(p)<pre><code> u8buf[number++] = getHex(p);</code></pre>
else<br>u8buf[number++] = g_defaultMsgAttr.m_TGT;<br>p =(char*)ezxml_attr(xml,&quot;SRC&quot;);<br>if(p)<pre><code> u8buf[number++] = getHex(p);</code></pre>
else<br>u8buf[number++] = g_defaultMsgAttr.m_SRC;<br>number+=getHexEx(p0,u8buf+number);<br>/<em>u8buf[number++] = getHex(p0);<br>  while(p = (char</em>)strstr(p0,&quot;,&quot;))<br>  {<br>     u8buf[number++] = getHex(p+1);<br>     p0 = p+1;<br>     if(number &gt;= bufsize)<br>        break;<br>  }</li>
<li>/<br>  //校验<br>u8buf[number] = 0;<br>for(i = 5; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  number++;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type1(ezxml_t xml, U8 <em>u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char *p;<br>char *p0 ;<br>U8 buf[256];<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>u8buf[number++] = 0x80 + getHexEx(ezxml_txt(xml),buf);<br>number+=getHexEx(p0,u8buf+number);<br>/*u8buf[number++] = getHex(p0);<br>  while(p = (char</em>)strstr(p0,&quot;,&quot;))<br>  {<br>     u8buf[number++] = getHex(p+1);<br>     p0 = p+1;<br>     if(number &gt;= bufsize)<br>        break;<br>  }<br>  */<br>  //校验<br>u8buf[number] = 0;<br>for(i = 5; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  number++;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type0(ezxml_t xml, U8 <em>u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char *p;<br>char *p0 ;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>number+=getHexEx(p0,u8buf+number);<br>/*u8buf[number++] = getHex(p0);<br>  while(p = (char</em>)strstr(p0,&quot;,&quot;))<br>  {<br>     if(strlen(p+1)&gt;0)<br>        u8buf[number++] = getHex(p+1);<br>     p0 = p+1;<br>     if(number &gt;= bufsize)<br>        break;<br>  }</li>
<li>/<br>  //头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type13(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char <em>p;<br>char *p0 ;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>number+=getHexEx(p0,u8buf+number);<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char</em>)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//处理校验位 异或<br>u8buf[number-1] = u8buf[5];<br>for(i=6;i&lt;number-1;i++)<br>  {<pre><code> u8buf[number-1] ^= u8buf[i];</code></pre>
}<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_type14(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 6;<br>int i;<br>char <em>p;<br>char *p0 ;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>number+=getHexEx(p0,u8buf+5);<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char</em>)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//处理校验位 异或<br>u8buf[number-1] = u8buf[5];<br>for(i=6;i&lt;number-1;i++)<br>  {<pre><code> u8buf[number-1] ^= u8buf[i];</code></pre>
}<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_typec(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 6;<br>int i;<br>char <em>p;<br>char *p0;<br>int len=0;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>len = getHexEx(p0,u8buf+number);<br>number+=len+1;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char</em>)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>u8buf[5] = len;<br>//校验和<br>u8buf[number-1] = 0;<br>for(i = 5; i&lt;number-1; i++)<br>  {<pre><code> u8buf[number-1] += u8buf[i];</code></pre>
}<br>//一字节取反<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_typed(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char <em>p;<br>char *p0 ;<br>U8 buf[256];<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>u8buf[number++] = 0xC0 + getHexEx(ezxml_txt(xml),buf);<br>p=(char</em>)ezxml_attr(xml,&quot;TGT&quot;);<br>if(p)<pre><code> u8buf[number++] = getHex(p);</code></pre>
else<br>u8buf[number++] = g_defaultMsgAttr.m_TGT;<br>p =(char*)ezxml_attr(xml,&quot;SRC&quot;);<br>if(p)<pre><code> u8buf[number++] = getHex(p);</code></pre>
else<br>u8buf[number++] = g_defaultMsgAttr.m_SRC;<br>number+=getHexEx(p0,u8buf+number);<br>u8buf[number] = 0;<br>for(i = 5; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  number++;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_typef(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char *p;<br>char *p0 ;<br>//检查<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>//处理<br>number += getHexEx(p0,u8buf+number);<br>if(u8buf[6]+5==number)<pre><code> number=number-1;</code></pre>
//校验<br>u8buf[number] = 0;<br>for(i = 5; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number]=~u8buf[number]+1;<br>number++;<br>//头<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int pack_typee(ezxml_t xml, U8 *u8buf, int bufsize)<br>{<br>int number = 5;<br>int i;<br>char *p;<br>char *p0 ;<br>U8 buf[256];<br>U8 len;<br>int dnumber=0;<br>if(xml == NULL)<br>return 0;<br>p0 = (char *)ezxml_txt(xml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>len = getHexEx(ezxml_txt(xml),buf);<br>if(buf[02]==len)<br>  {<br>//计算校验和<br>for(i=0;i&lt;len-2;i++)<pre><code> &#123;
    dnumber += buf[i];</code></pre>
}<pre><code> buf[len-2] = dnumber&amp;amp;0x00FF;</code></pre>
buf[len-1] = (dnumber&amp;0xFF00)&gt;&gt;8;<br>for(i=0;i&lt;len;i++)<pre><code> &#123;
    u8buf[number++] = buf[i];</code></pre>
}<br>  }<br>else<br>     return 0;<br>u8buf[0] = 0xa5;<br>u8buf[1] = 0xa5;<br>u8buf[2] = (number-4) / 0x100;<br>u8buf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(xml,&quot;ORD&quot;);<br>if(p)<pre><code> u8buf[4] = getHex(p);</code></pre>
else<br>u8buf[4] = g_defaultMsgAttr.m_ORD;<br>//校验和<br>u8buf[number] = 0;<br>for(i = 2; i&lt;number; i++)<br>  {<pre><code> u8buf[number] += u8buf[i];</code></pre>
}<br>  u8buf[number] = ~u8buf[number];    <br>return number+1;<br>}<br>int crcVerify(U8 *buf, int len)<br>{<br>int i;<br>int j;<br>int l;<br>int k;<br>int n;<br>if(len==9||len==8||len==13||len==7||len==11||len==10||len==6||len==12)<br>  {  <pre><code> buf[len-1]=0x0a;</code></pre>
if(len==8)<pre><code>    buf[len-1]=0xf6;</code></pre>
if(len==13)<pre><code>    buf[len-1]=0xe2;</code></pre>
if(len==7)<pre><code>    buf[len-1]=0x10;</code></pre>
if(len==11)<pre><code>    buf[len-1]=0x7c;</code></pre>
if(len==10)<pre><code>    buf[len-1]=0xe9;</code></pre>
if(len==12)<pre><code>    buf[len-1]=0xfe;</code></pre>
if(len==6)<pre><code>    buf[len-1]=0x59;</code></pre>
l=285;<br>j=buf[1];<br>for(i=2;i&lt;len;i++)<pre><code> &#123;</code></pre>
//lenessageBox(&quot;ok&quot;);<br>for(k=0;k&lt;8;k++)<pre><code>    &#123;
       j=j&amp;lt;&amp;lt;1;</code></pre>
n=(buf[i]&gt;&gt;(7-k))&amp;0x01;<br>j+=n;<br>if(j&gt;255)<pre><code>          j=j^l;</code></pre>
}<pre><code> &#125;
 buf[len-1]=j;</code></pre>
}<br>else<br>     return 0;<br>return 1;<br>}<br>int autoFillCrc(char* strHex)<br>{<br>size_t i;<br>U8 buf[256];<br>int buflen = 0;<br>for(i=0; i&lt;strlen(strHex); i+=3)<br>  {<pre><code> buf[buflen++] =getHex(strHex+i); </code></pre>
if(buflen &gt; 255)<br>return 0;<br>}<br>if(!crcVerify(buf, buflen))<br>return 0;<br>sprintf(strHex+3*(buflen-1),&quot;%02x&quot;,buf[buflen-1]);<br>return 1;<br>}<br>int kwptype(ezxml_t msgxml,U8 *recvbuf)<br>{<br>int number;<br>int pack_t;<br>int i;<br>//int dpos = 0;<br>U8 nTempData=0;<br>if(msgxml != NULL)<br>  {<pre><code> pack_t = getPackType(msgxml);</code></pre>
number = pack_type(msgxml, recvbuf , 256);<br>Uart_ClearInput(g_carportHandle);<br>Uart_ClearOutput(g_carportHandle);      <br>Device_SendBuf(g_carportHandle, recvbuf , number);<br>}<br>else<br>{<pre><code> pack_t = 0;</code></pre>
}<br>if((recvbuf[4]&amp;0xf0)==0x20)<br>  {<pre><code> number = Device_ReadBuf(g_carportHandle, recvbuf, 256, 5000);                                              </code></pre>
}<br>else<br>{<pre><code> number = Device_ReadBuf(g_carportHandle, recvbuf, 256, g_defaultMsgAttr.m_AnswerFrameTimeOut*50);                                              </code></pre>
}<br>if(!number)<br>return 0;<br>for(i=5;i&lt;number-2;i++)<br>  {<pre><code> nTempData +=recvbuf[i];</code></pre>
}<br>if(nTempData != recvbuf[i])<br>return 0;<br>if((ezxml_attr(msgxml, &quot;DPOS&quot;))&amp;&amp;(getHex(ezxml_attr(msgxml, &quot;DPOS&quot;))&gt;0))<br>  {<br>//dpos计算数据流的逆向偏移位,此处不能为负值<br>     /<em>dpos = getHex(ezxml_attr(msgxml, &quot;DPOS&quot;));<br>     if(0&lt;dpos&lt;9)<br>     {<br>     Debug_vc(&quot;DPOS=%02X\r\n&quot;,dpos);<br>     memcpy(recvbuf+dpos,recvbuf, number);<br>     }</em>/<br>number = unpack_buf(0, recvbuf, number);<br>}<br>else<br>{<pre><code> number = unpack_buf(pack_t, recvbuf, number);</code></pre>
}<br>return number;<br>}<br>//有长度控制的命令,如02 07 09, 其中02为长度,09为02+07<br>int lentype1(ezxml_t msgxml,U8 <em>recvbuf)<br>{<br>int number;<br>int snumber;<br>int i;<br>int j,k=0;<br>char *p;<br>char *p0 ;<br>U8 sbuf[50];<br>U8 rbuf[50];<br>U8 buf[256];<br>U8 uTempBuf=0;<br>memset(sbuf,0,sizeof(sbuf));<br>snumber=getHexEx(ezxml_txt(msgxml),buf);<br>if(msgxml == NULL)<br>return 0;<br>p0 = (char</em>)ezxml_txt(msgxml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>number = snumber+5;<br>//头<br>sbuf[0] = 0xa5;<br>sbuf[1] = 0xa5;<br>sbuf[2] = (number-4) / 0x100;<br>sbuf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(msgxml,&quot;ORD&quot;);<br>if(p)<pre><code> sbuf[4] = getHex(p);</code></pre>
for(i=0; i &lt; snumber; i++)<br>  {<pre><code> sbuf[i+5]=buf[i];</code></pre>
}<br>  sbuf[number]=0;<br>for(j=2;j&lt;number;j++)<pre><code> sbuf[number]+=sbuf[j];</code></pre>
sbuf[number] = ~sbuf[number];  <br>Uart_ClearInput(g_carportHandle);<br>Uart_ClearOutput(g_carportHandle);<br>Device_SendBuf(g_carportHandle,sbuf ,number+1);<br>if((sbuf[4]&amp;0xf0)==0x20)<br>  {<pre><code> number = Device_ReadBuf(g_carportHandle, rbuf, 256, 5000);                                              </code></pre>
}<br>else<br>{<pre><code> number = Device_ReadBuf(g_carportHandle, rbuf, 256, g_defaultMsgAttr.m_AnswerFrameTimeOut*50);                                              </code></pre>
}<br>if(!number)<br>return 0;<br>if((rbuf[0] != 0xa5) &amp;&amp; (rbuf[1] != 0xa5))<br>return 0;<br>if(number &lt; 5)<br>return 0;<br>if(rbuf[3] == number -5)<br>  {<br>if(rbuf[5] == number-7)<pre><code> &#123;</code></pre>
for(i=0; i&lt;rbuf[5]; ++i)<pre><code>    &#123;
       uTempBuf += rbuf[i+5]; </code></pre>
}<br>if(uTempBuf != rbuf[i+5])<br>return 0;<br>for(j=5;j&lt;number-1;j++)<pre><code>    &#123;  
       recvbuf[k]=rbuf[j];</code></pre>
k++;<br>}<pre><code>    recvbuf[k]=&#39;\0&#39;;</code></pre>
return k;<br>}<br>else<br>        return 0;<br>}<br>else<br>     return 0;<br>}<br>//有长度控制的命令,如韩国大宇f4,56,01,b5格式命令,第二位表示长度,长度为56-52. b5为取补.<br>int lentype2(ezxml_t msgxml,U8 <em>recvbuf)<br>{<br>int number;<br>int snumber;<br>int i;<br>int j,k=0;<br>char *p;<br>char *p0 ;<br>U8 sbuf[250];<br>U8 rbuf[250];<br>U8 buf[256];<br>U8 uTempBuf=0;<br>memset(sbuf,0,sizeof(sbuf));<br>snumber=getHexEx(ezxml_txt(msgxml),buf);<br>if(msgxml == NULL)<br>return 0;<br>p0 = (char</em>)ezxml_txt(msgxml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>number = snumber+5;<br>//头<br>sbuf[0] = 0xa5;<br>sbuf[1] = 0xa5;<br>sbuf[2] = (number-4) / 0x100;<br>sbuf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(msgxml,&quot;ORD&quot;);<br>if(p)<pre><code> sbuf[4] = getHex(p);</code></pre>
for(i=0; i &lt; snumber; i++)<br>  {<pre><code> sbuf[i+5]=buf[i];</code></pre>
}<br>  sbuf[number]=0;<br>for(j=2;j&lt;number;j++)<pre><code> sbuf[number]+=sbuf[j];</code></pre>
sbuf[number] = ~sbuf[number];  <br>Uart_ClearInput(g_carportHandle);<br>Uart_ClearOutput(g_carportHandle);<br>Device_SendBuf(g_carportHandle,sbuf ,number+1);<br>if((sbuf[4]&amp;0xf0)==0x20)<br>  {<pre><code> number = Device_ReadBuf(g_carportHandle, rbuf, 256, 5000);                                              </code></pre>
}<br>else<br>{<pre><code> number = Device_ReadBuf(g_carportHandle, rbuf, 256, g_defaultMsgAttr.m_AnswerFrameTimeOut*50);                                              </code></pre>
}<br>if(!number)<br>return 0;<br>if((rbuf[0] != 0xa5) &amp;&amp; (rbuf[1] != 0xa5))<br>return 0;<br>if(number &lt; 5)<br>return 0;<br>if(rbuf[6] == number+0x52-6)<br>  {<br>for(i=0; i&lt;number-7; ++i)<pre><code> &#123;
    uTempBuf += rbuf[i+5]; </code></pre>
}<pre><code> uTempBuf = ~uTempBuf +1;</code></pre>
if(uTempBuf != rbuf[i+5])<br>return 0;<br>for(j=5;j&lt;number-1;j++)<pre><code> &#123;  
    recvbuf[k]=rbuf[j];</code></pre>
k++;<br>}<pre><code> recvbuf[k]=&#39;\0&#39;;</code></pre>
return k;<br>}<br>else<br>     return 0;<br>}<br>//有长度控制的命令,如01 82 83, 其中01为长度,83为01+82<br>int lentype3(ezxml_t msgxml,U8 <em>recvbuf)<br>{<br>int number;<br>int snumber;<br>int i;<br>int j,k=0;<br>char *p;<br>char *p0 ;<br>U8 sbuf[50];<br>U8 rbuf[50];<br>U8 buf[256];<br>U8 uTempBuf=0;<br>memset(sbuf,0,sizeof(sbuf));<br>snumber=getHexEx(ezxml_txt(msgxml),buf);<br>if(msgxml == NULL)<br>return 0;<br>p0 = (char</em>)ezxml_txt(msgxml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>number = snumber+5;<br>//头<br>sbuf[0] = 0xa5;<br>sbuf[1] = 0xa5;<br>sbuf[2] = (number-4) / 0x100;<br>sbuf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(msgxml,&quot;ORD&quot;);<br>if(p)<pre><code>    sbuf[4] = getHex(p);</code></pre>
for(i=0; i &lt; snumber; i++)<br>  {<pre><code> sbuf[i+5]=buf[i];</code></pre>
}<br>  sbuf[number]=0;<br>for(j=2;j&lt;number;j++)<pre><code> sbuf[number]+=sbuf[j];</code></pre>
sbuf[number] = ~sbuf[number];  <br>Uart_ClearInput(g_carportHandle);<br>Uart_ClearOutput(g_carportHandle);<br>Device_SendBuf(g_carportHandle,sbuf ,number+1);<br>if((sbuf[4]&amp;0xf0)==0x20)<br>  {<pre><code> number = Device_ReadBuf(g_carportHandle, rbuf, 256, 5000);                                              </code></pre>
}<br>else<br>{<pre><code> number = Device_ReadBuf(g_carportHandle, rbuf, 256, g_defaultMsgAttr.m_AnswerFrameTimeOut*50);                                              </code></pre>
}<br>if(!number)<br>return 0;<br>if((rbuf[0] != 0xa5) &amp;&amp; (rbuf[1] != 0xa5))<br>return 0;<br>if(number &lt; 5)<br>return 0;<br>if(rbuf[3] == number -5)<br>  {<br>if(rbuf[5] == number-8)<pre><code> &#123;</code></pre>
for(i=0; i&lt;rbuf[5]+1; ++i)<pre><code>    &#123;
       uTempBuf += rbuf[i+5]; </code></pre>
}<br>if(uTempBuf != rbuf[i+5])<br>return 0;<br>for(j=5;j&lt;number-1;j++)<pre><code>    &#123;  
       recvbuf[k]=rbuf[j];</code></pre>
k++;<br>}<pre><code>    recvbuf[k]=&#39;\0&#39;;</code></pre>
return k;<br>}<br>else<br>        return 0;<br>}<br>else<br>     return 0;<br>}<br>//有长度控制的命令,如03 13 16, 其中03为长度,16为03+13<br>int lentype4(ezxml_t msgxml,U8 <em>recvbuf)<br>{<br>int number;<br>int snumber;<br>int i;<br>int j,k=0;<br>char *p;<br>char *p0 ;<br>U8 sbuf[50];<br>U8 rbuf[50];<br>U8 buf[256];<br>U8 uTempBuf=0;<br>memset(sbuf,0,sizeof(sbuf));<br>snumber=getHexEx(ezxml_txt(msgxml),buf);<br>if(msgxml == NULL)<br>return 0;<br>p0 = (char</em>)ezxml_txt(msgxml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>number = snumber+5;<br>//头<br>sbuf[0] = 0xa5;<br>sbuf[1] = 0xa5;<br>sbuf[2] = (number-4) / 0x100;<br>sbuf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(msgxml,&quot;ORD&quot;);<br>if(p)<pre><code>    sbuf[4] = getHex(p);</code></pre>
for(i=0; i &lt; snumber; i++)<pre><code> &#123;
    sbuf[i+5]=buf[i];</code></pre>
}<pre><code> sbuf[number]=0;</code></pre>
for(j=2;j&lt;number;j++)<pre><code>    sbuf[number]+=sbuf[j];</code></pre>
sbuf[number] = ~sbuf[number];  <br>Uart_ClearInput(g_carportHandle);<br>Uart_ClearOutput(g_carportHandle);<br>Device_SendBuf(g_carportHandle,sbuf ,number+1);<br>if((sbuf[4]&amp;0xf0)==0x20)<pre><code> &#123;
    number = Device_ReadBuf(g_carportHandle, rbuf, 256, 5000);                                              </code></pre>
}<br>else<br>{<pre><code>    number = Device_ReadBuf(g_carportHandle, rbuf, 256, g_defaultMsgAttr.m_AnswerFrameTimeOut*50);                                              </code></pre>
}<br>if(!number)<br>return 0;<br>if((rbuf[0] != 0xa5) &amp;&amp; (rbuf[1] != 0xa5))<br>return 0;<br>if(number &lt; 5)<br>return 0;<br>if(rbuf[3] == number-5)  // &gt;FF情况下不行<br>{<br>if(rbuf[5] == number-6)<pre><code>    &#123;</code></pre>
for(i=0; i&lt;rbuf[5]-1; ++i)<pre><code>       &#123;
          uTempBuf += rbuf[i+5]; </code></pre>
}<br>if(uTempBuf != rbuf[i+5])<br>return 0;<br>for(j=5;j&lt;number-1;j++)<pre><code>       &#123;  
          recvbuf[k]=rbuf[j];</code></pre>
k++;<br>}<pre><code>       recvbuf[k]=&#39;\0&#39;;</code></pre>
return k;<br>}<br>else<br>           return 0;<br>}<br>else<br>        return 0;<br>}<br>//有长度控制的命令,如01 13 14, 其中01为长度,14为13+01<br>int lentype5(ezxml_t msgxml,U8 <em>recvbuf)<br>{<br>int number;<br>int snumber;<br>int i;<br>int j,k=0;<br>char *p;<br>char *p0 ;<br>U8 sbuf[50];<br>U8 rbuf[50];<br>U8 buf[256];<br>U8 uTempBuf=0;<br>memset(sbuf,0,sizeof(sbuf));<br>snumber=getHexEx(ezxml_txt(msgxml),buf);<br>if(msgxml == NULL)<br>return 0;<br>p0 = (char</em>)ezxml_txt(msgxml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>number = snumber+5;<br>//头<br>sbuf[0] = 0xa5;<br>sbuf[1] = 0xa5;<br>sbuf[2] = (number-4) / 0x100;<br>sbuf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(msgxml,&quot;ORD&quot;);<br>if(p)<pre><code>    sbuf[4] = getHex(p);</code></pre>
for(i=0; i &lt; snumber; i++)<pre><code> &#123;
    sbuf[i+5]=buf[i];</code></pre>
}<pre><code> sbuf[number]=0;</code></pre>
for(j=2;j&lt;number;j++)<pre><code>    sbuf[number]+=sbuf[j];</code></pre>
sbuf[number] = ~sbuf[number];  <br>Uart_ClearInput(g_carportHandle);<br>Uart_ClearOutput(g_carportHandle);<br>Device_SendBuf(g_carportHandle,sbuf ,number+1);<br>if((sbuf[4]&amp;0xf0)==0x20)<pre><code> &#123;
    number = Device_ReadBuf(g_carportHandle, rbuf, 256, 5000);                                              </code></pre>
}<br>else<br>{<pre><code>    number = Device_ReadBuf(g_carportHandle, rbuf, 256, g_defaultMsgAttr.m_AnswerFrameTimeOut*50);                                              </code></pre>
}<br>if(!number)<br>return 0;<br>if((rbuf[0] != 0xa5) &amp;&amp; (rbuf[1] != 0xa5))<br>return 0;<br>if(number &lt; 5)<br>return 0;<br>if(rbuf[3] == number -5)             //  &gt;FF情况下不行<br>{<br>if(rbuf[5] == number-8)<pre><code>    &#123;</code></pre>
for(i=0; i&lt;rbuf[5]+1; ++i)<pre><code>       &#123;
          uTempBuf += rbuf[i+5]; </code></pre>
}<br>if(uTempBuf != rbuf[i+5])<br>return 0;<br>for(j=5;j&lt;number-1;j++)<pre><code>       &#123;  
          recvbuf[k]=rbuf[j];</code></pre>
k++;<br>}<pre><code>       recvbuf[k]=&#39;\0&#39;;</code></pre>
return k;<br>}<br>else<br>           return 0;<br>}<br>else<br>        return 0;<br>}<br>//有长度控制的命令,如03 13 ea, 其中03为长度,ea为前面取补<br>int lentype6(ezxml_t msgxml,U8 <em>recvbuf)<br>{<br>int number;<br>int snumber;<br>int i;<br>int j,k=0;<br>char *p;<br>char *p0 ;<br>U8 sbuf[50];<br>U8 rbuf[50];<br>U8 buf[256];<br>U8 uTempBuf=0;<br>memset(sbuf,0,sizeof(sbuf));<br>snumber=getHexEx(ezxml_txt(msgxml),buf);<br>if(msgxml == NULL)<br>return 0;<br>p0 = (char</em>)ezxml_txt(msgxml);<br>if(strlen(p0) &lt; 2)<br>return 0;<br>number = snumber+5;<br>//头<br>sbuf[0] = 0xa5;<br>sbuf[1] = 0xa5;<br>sbuf[2] = (number-4) / 0x100;<br>sbuf[3] = (number-4) % 0x100;<br>p = (char*)ezxml_attr(msgxml,&quot;ORD&quot;);<br>if(p)<pre><code>    sbuf[4] = getHex(p);</code></pre>
for(i=0; i &lt; snumber; i++)<pre><code> &#123;
    sbuf[i+5]=buf[i];</code></pre>
}<pre><code> sbuf[number]=0;</code></pre>
for(j=2;j&lt;number;j++)<pre><code>    sbuf[number]+=sbuf[j];</code></pre>
sbuf[number] = ~sbuf[number];  <br>Uart_ClearInput(g_carportHandle);<br>Uart_ClearOutput(g_carportHandle);<br>Device_SendBuf(g_carportHandle,sbuf ,number+1);<br>if((sbuf[4]&amp;0xf0)==0x20)<pre><code> &#123;
    number = Device_ReadBuf(g_carportHandle, rbuf, 256, 5000);                                              </code></pre>
}<br>else<br>{<pre><code>    number = Device_ReadBuf(g_carportHandle, rbuf, 256, g_defaultMsgAttr.m_AnswerFrameTimeOut*50);                                              </code></pre>
}<br>if(!number)<br>return 0;<br>if((rbuf[0] != 0xa5) &amp;&amp; (rbuf[1] != 0xa5))<br>return 0;<br>if(number &lt; 5)<br>return 0;<br>if(rbuf[3] == number-5)  // &gt;FF情况下不行<br>{<br>if(rbuf[5] == number-6)<pre><code>    &#123;</code></pre>
for(i=0; i&lt;rbuf[5]-1; ++i)<pre><code>       &#123;
          uTempBuf += rbuf[i+5]; </code></pre>
}<pre><code>       uTempBuf = (~uTempBuf)+1;</code></pre>
if(uTempBuf != rbuf[i+5])<br>return 0;<br>for(j=5;j&lt;number-1;j++)<pre><code>       &#123;  
          recvbuf[k]=rbuf[j];</code></pre>
k++;<br>}<pre><code>       recvbuf[k]=&#39;\0&#39;;</code></pre>
return k;<br>}<br>else<br>           return 0;<br>}<br>else<br>        return 0;<br>}<br>#ifdef __cplusplus<br>}<br>#endif </li>
</ul>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>修改Android解锁界面</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E4%BF%AE%E6%94%B9Android%E8%A7%A3%E9%94%81%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>修改Android解锁界面 2012-05-05 11:13:01</p>
<p>分类： 嵌入式</p>
<p>背景  <br>   先说说背景吧，这是本人从WinCE系统转到Android之后，接到的第一个任务就是修改Android原生的解锁界面，之前看了两个星期的书和网络博客，Java的也有、Android应用开发的也有、Linux开发的也有、Android框架介绍的也有。然后写了几个APK试了了一下，觉得自己有能力了，便充满自信地找到组长接任务。组长没有说什么，拿出一个竞争对手公司的样机，玩了几下拿个我，说道：这是竞争对手公司的方案，他们的解锁效果不错，很方便，你看看能不能也做出来。<br>   说实话接到这个任务当时真的有点失望，心里面一直想，当初做WinCE做的几乎全是驱动，整天和寄存器、指针、协议打交道，现在转到Android，做这些应用的东西真的不太习惯。不过转头一想，不管什么东西，要做就要做好，慢慢来嘛，于是拿走样机回到工位上，安心开始研究。<br>   样机解锁界面效果类似如下 <br> 其实这也是我后面做出的效果，样机因为没有ROOT不好调试截图,功能是将解锁的图标添加了最近运行的运用的图标，这样的话更方便用户去使用</p>
<p>1.分析 <br>1.1.Android锁屏功能分析</p>
<p>Android锁屏相关的代码在以下几个路径：</p>
<p>锁屏的具体实现：</p>
<p>其中的主要代码如下：</p>
<p>锁屏控件的View类</p>
<p>\frameworks\base\policy\src\com\android\internal\policy\impl</p>
<p>\frameworks\base\core\java\com\android\internal\widget\multiwaveview</p>
<p>锁屏控件使用到的资源</p>
<p>\frameworks\base\core\res\res\values-sw600dp-land\arrays.xml</p>
<p>\frameworks\base\core\res\res\drawableXXX</p>
<p>Android上常用的锁屏方法有以下几种：默认锁屏方式（LockScreen）、SIM卡解锁方式（SimUnlockScreen）、图案解锁方式（PatternUnlockScreen）、密码解锁方式（PasswordUnlockScreen）、账号解锁方式（AccountUnlockScreen），这些解锁方式都有对应的源码实现，我们这里讨论的是最常用的默认解锁方式，在Android4.0之后，解锁控件变为“波纹解锁”，即如概述介绍的那样，通过控制中心的圆圈来实现解锁，这种解锁方式，实际上可以进一步增强。</p>
<p>1.1.1.  Android启动后从窗口管理器运行到解锁界面的动作：</p>
<p>1.开机启动后执行到PhoneWindowManager.systemReady()。</p>
<p>2.调用KeyguardViewMediator.onSystemReady()进行待机锁屏及解锁逻辑。</p>
<p>3.KeyguardViewMediator是整个待机解锁屏业务的调度器，负责调度锁屏界面的相关动作及查询解锁屏状态。</p>
<p>1.1.2.  KeyguardViewMediator的作用</p>
<p>1.查询锁屏状态，及当前处于锁屏状态还是已解锁状态，PhoneWindowManager持有KeyguardViewMediator的引用，当用户触摸屏幕或者按下某个键是，PhoneWindowManager会通过KeyguardViewMediator查询锁屏状态（锁定/解锁），进行不同的响应处理。如果处于锁定状态，系统输入事件会受到限制。</p>
<p>2.响应电源事件（黑/亮屏）。判断锁屏界面应该处于什么状态（显示或者重置）。手机黑屏后，锁屏界面马上就会显示出来，以便下一次亮屏后，马上就能显示锁屏界面，而不会出现闪烁或延时。</p>
<p>3.其他应用程序或者服务也可以请求禁止锁屏（通过调用KeyguardViewMediator的setKeyguardEnabled(boolean)方法）。例如接听来电界面。</p>
<p>KeyguardViewMediator类在WindowManagerPolicy（在手机系统中是PhoneWindowManager实例）初始化时被创建，并运行在它的线程上，锁屏的UI界面也是在这个线程上创建及显示的。KeyguardViewMediator类提供的状态查询api可以被诸如android.view.WindowManager、com.android.server.InputManager等其它线程调用，所以，KeyguardViewMediator类上的这些api方法都是线程同步的（synchronized）。</p>
<p>1.1.3.  KeyguardViewMediator可以进行的调度操作</p>
<p>1) 点亮屏幕pokeWakelock();</p>
<p>2) 报告锁屏权限验证是否成功keyguardDone(boolean);</p>
<p>3) 响应SIM卡状态变化并对锁屏界面做相应的调整onSimStateChanged（）。</p>
<p>4) 调度待机锁屏UI界面的管理,包括:</p>
<p>1.显示handleShow ()、</p>
<p>2.隐藏handleHide ()、</p>
<p>3.重置handleReset ()、</p>
<p>4.点亮屏幕handleWakeWhenReady()等。</p>
<p>KeyguardViewMediator实现这部分调度是通过持有一个KeyguardViewManager来实现的。总之KeyguardUpdateMonitor是所有会影响整个待机解/锁屏业务的事件的监控器。(除了作为监控器，它还发挥着类似上下文的作用，也许我们应该把这个类命名为(KeyguardContext)。它监控诸如时间改变、电池状态改变、时区改变、SIM卡状态变化、电话状态变化、电话信号变化等事件。它是一个观察者模式的被观察对象。观察者通过调用KeyguardUpdateMonitor的以下方法进行注册，观察自己感兴趣的变化。</p>
<p>registerInfoCallback(InfoCallback)registerSimStateCallback(SimStateCallback)</p>
<p>KeyguardUpdateMonitor的观察者包括KeyguardViewMediator、LockScreen、PatternUnlockScreen、AccountUnlockScreen、PasswordUnlockScreen、SimUnlockScreen等。观察者通过调用KeyguardUpdateMonitor的removeCallback(Object)取消观察。</p>
<p>KeyguardViewManager负责管理待机屏UI界面的创建、显示、隐藏、重置以及通过一个回调KeyguardViewCallback通知调度器KeyguardViewMediator进行相关的调度。</p>
<p>LockPatternKeyguardView（KeyguardViewBase）是所有锁屏和解锁UI界面的宿主。它有2个模式Mode. LockScreen和Mode. UnlockScreen。它负责根据当前上下文环境切换当前应该显示的待机屏。</p>
<p>它提供一个回调给当前显示的待机屏并处理其回调，如果回调动作是自己处理不了的，则继续报告给KeyguardViewMediator进行处理。</p>
<p>锁屏界面就是LockScreen；解锁界面包括SIM卡解锁SimUnlockScreen、图案解锁PatternUnlockScreen、密码解锁PasswordUnlockScreen、帐号解锁AccountUnlockScreen</p>
<p>解锁成功后，锁屏流程转到KeyguardViewMediator的keyguardDone(boolean, boolean) 进行后续的流程（如转到Launcher桌面）。</p>
<p>1.2. 解锁界面布局</p>
<p>解锁界面布局在LockScreen类的构造函数中进行，LockScreen构造函数内容如下：</p>
<p>点击(此处)折叠或打开</p>
<p>LockScreen(Context context, Configuration configuration, LockPatternUtils lockPatternUtils,</p>
<p>            KeyguardUpdateMonitor updateMonitor,</p>
<p>            KeyguardScreenCallback callback) {</p>
<p>super(context);</p>
<p>        mLockPatternUtils = lockPatternUtils;</p>
<p>        mUpdateMonitor = updateMonitor;</p>
<p>        mCallback = callback;</p>
<p>        mEnableMenuKeyInLockScreen = shouldEnableMenuKey();</p>
<p>        mCreationOrientation = configuration.orientation;</p>
<p>        mKeyboardHidden = configuration.hardKeyboardHidden;</p>
<p>if (LockPatternKeyguardView.DEBUG_CONFIGURATION) {</p>
<p>Log.v(TAG, &quot;***** CREATING LOCK SCREEN&quot;, new RuntimeException());</p>
<p>Log.v(TAG, &quot;Cur orient=&quot; + mCreationOrientation</p>
<p>+ &quot; res orient=&quot; + context.getResources().getConfiguration().orientation);</p>
<p>}</p>
<p>final LayoutInflater inflater = LayoutInflater.from(context);</p>
<p>if (DBG) Log.v(TAG, &quot;Creation orientation = &quot; + mCreationOrientation);</p>
<p>if (mCreationOrientation != Configuration.ORIENTATION_LANDSCAPE) {</p>
<p>inflater.inflate(R.layout.keyguard_screen_tab_unlock, this, true);</p>
<p>} else {</p>
<p>inflater.inflate(R.layout.keyguard_screen_tab_unlock_land, this, true);</p>
<p>}</p>
<p>        mStatusViewManager = new KeyguardStatusViewManager(this, mUpdateMonitor, mLockPatternUtils,</p>
<p>                mCallback, false);</p>
<p>        setFocusable(true);</p>
<p>        setFocusableInTouchMode(true);</p>
<p>        setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);</p>
<p>        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</p>
<p>        mSilentMode = isSilentMode();</p>
<p>        mUnlockWidget = findViewById(R.id.unlock_widget);</p>
<p>if (mUnlockWidget instanceof SlidingTab) {</p>
<p>            SlidingTab slidingTabView = (SlidingTab) mUnlockWidget;</p>
<p>            slidingTabView.setHoldAfterTrigger(true, false);</p>
<p>            slidingTabView.setLeftHintText(R.string.lockscreen_unlock_label);</p>
<p>            slidingTabView.setLeftTabResources(</p>
<p>                    R.drawable.ic_jog_dial_unlock,</p>
<p>                    R.drawable.jog_tab_target_green,</p>
<p>                    R.drawable.jog_tab_bar_left_unlock,</p>
<p>                    R.drawable.jog_tab_left_unlock);</p>
<p>            SlidingTabMethods slidingTabMethods = new SlidingTabMethods(slidingTabView);</p>
<p>            slidingTabView.setOnTriggerListener(slidingTabMethods);</p>
<p>            mUnlockWidgetMethods = slidingTabMethods;</p>
<p>} else if (mUnlockWidget instanceof WaveView) {</p>
<p>            WaveView waveView = (WaveView) mUnlockWidget;</p>
<p>            WaveViewMethods waveViewMethods = new WaveViewMethods(waveView);</p>
<p>            waveView.setOnTriggerListener(waveViewMethods);</p>
<p>            mUnlockWidgetMethods = waveViewMethods;</p>
<p>} else if (mUnlockWidget instanceof MultiWaveView) {</p>
<p>            MultiWaveView multiWaveView = (MultiWaveView) mUnlockWidget;</p>
<p>            MultiWaveViewMethods multiWaveViewMethods = new MultiWaveViewMethods(multiWaveView);</p>
<p>            multiWaveView.setOnTriggerListener(multiWaveViewMethods);</p>
<p>            mUnlockWidgetMethods = multiWaveViewMethods;</p>
<p>} else {</p>
<p>throw new IllegalStateException(&quot;Unrecognized unlock widget: &quot; + mUnlockWidget);</p>
<p>}</p>
<p>// Update widget with initial ring state</p>
<p>        mUnlockWidgetMethods.updateResources(context);</p>
<p>if (DBG) Log.v(TAG, &quot;*** LockScreen accel is &quot;</p>
<p>+ (mUnlockWidget.isHardwareAccelerated() ? &quot;on&quot;:&quot;off&quot;));</p>
<p>}</p>
<p>通过添加打印发现在480分辨率下采用的Layout文件为\layout-sw480dp\keyguard_screen_tab_unlock_land.xml，此文件的内容如下：</p>
<p>点击(此处)折叠或打开</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</p>
<p>&lt;!–</p>
<p>**</p>
<p>** Copyright 2009, The Android Open Source Project</p>
<p>**</p>
<p>** Licensed under the Apache License, Version 2.0 (the &quot;License&quot;)</p>
<p>** you may not use this file except in compliance with the License.</p>
<p>** You may obtain a copy of the License at</p>
<p>**</p>
<p>** <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>**</p>
<p>** Unless required by applicable law or agreed to in writing, software</p>
<p>** distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</p>
<p>** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>
<p>** See the License for the specific language governing permissions and</p>
<p>** limitations under the License.</p>
<p>*/</p>
<p>–&gt;</p>
<p>&lt;!– This is the general lock screen which shows information about the</p>
<p>  state of the device, as well as instructions on how to get past it</p>
<p>  depending on the state of the device.–&gt;</p>
<p>&lt;LinearLayout xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;</p>
<p>    xmlns:tabunlock=&quot;<a href="http://schemas.android.com/apk/res/com.android.tabunlock">http://schemas.android.com/apk/res/com.android.tabunlock</a>&quot;</p>
<p>    android:layout_width=&quot;match_parent&quot;</p>
<p>    android:layout_height=&quot;match_parent&quot;</p>
<p>    android:orientation=&quot;horizontal&quot;</p>
<p>    android:id=&quot;@+id/root&quot;&gt;</p>
<p>&lt;!– left side: status and music –&gt;</p>
<p>&lt;RelativeLayout</p>
<p>        android:layout_height=&quot;match_parent&quot;</p>
<p>        android:layout_weight=&quot;1&quot;</p>
<p>        android:layout_width=&quot;0dip&quot;</p>
<p>        android:gravity=&quot;center&quot;&gt;</p>
<p>&lt;RelativeLayout android:id=&quot;@+id/transport_bg_protect&quot;</p>
<p>            android:layout_width=&quot;512dip&quot;</p>
<p>            android:layout_height=&quot;wrap_content&quot;&gt;</p>
<p>&lt;!– Music transport control underneath –&gt;</p>
<p>&lt;include android:id=&quot;@+id/transport&quot;</p>
<p>                layout=&quot;@layout/keyguard_transport_control&quot;</p>
<p>                android:layout_row=&quot;0&quot;</p>
<p>                android:layout_column=&quot;0&quot;</p>
<p>                android:layout_rowSpan=&quot;3&quot;</p>
<p>                android:layout_columnSpan=&quot;1&quot;</p>
<p>                android:layout_gravity=&quot;fill&quot;</p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;512dip&quot;</p>
<p>/&gt;</p>
<p>&lt;include layout=&quot;@layout/keyguard_screen_status_land&quot;</p>
<p>                android:layout_width=&quot;match_parent&quot;</p>
<p>                android:layout_height=&quot;wrap_content&quot;</p>
<p>                android:layout_marginLeft=&quot;50dip&quot;</p>
<p>                android:layout_marginTop=&quot;50dip&quot;</p>
<p>                android:layout_marginBottom=&quot;82dip&quot;</p>
<p>                android:layout_marginRight=&quot;64dip&quot;</p>
<p>                android:layout_alignParentTop=&quot;true&quot;</p>
<p>                android:layout_alignParentLeft=&quot;true&quot;/&gt;</p>
<p>&lt;/RelativeLayout&gt;</p>
<p>&lt;/RelativeLayout&gt;</p>
<p>&lt;!– right side –&gt;</p>
<p>&lt;RelativeLayout</p>
<p>        android:layout_height=&quot;match_parent&quot;</p>
<p>        android:layout_weight=&quot;1&quot;</p>
<p>        android:layout_width=&quot;0dip&quot;</p>
<p>        android:gravity=&quot;center_horizontal|center_vertical&quot;&gt;</p>
<p>&lt;TextView</p>
<p>            android:id=&quot;@+id/screenLocked&quot;</p>
<p>            android:layout_width=&quot;wrap_content&quot;</p>
<p>            android:layout_height=&quot;wrap_content&quot;</p>
<p>            android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;</p>
<p>            android:gravity=&quot;center&quot;</p>
<p>            android:layout_marginTop=&quot;12dip&quot;</p>
<p>            android:layout_alignParentLeft=&quot;true&quot;</p>
<p>            android:layout_alignParentTop=&quot;true&quot;</p>
<p>            android:drawablePadding=&quot;4dip&quot;/&gt;</p>
<p>&lt;com.android.internal.widget.multiwaveview.MultiWaveView</p>
<p>            android:id=&quot;@+id/unlock_widget&quot;</p>
<p>            android:layout_width=&quot;match_parent&quot;</p>
<p>            android:layout_height=&quot;match_parent&quot;</p>
<p>            android:layout_rowSpan=&quot;7&quot;</p>
<p>            android:layout_gravity=&quot;center_vertical|center_horizontal&quot;</p>
<p>            android:targetDrawables=&quot;@array/lockscreen_targets_with_camera&quot;</p>
<p>            android:targetDescriptions=&quot;@array/lockscreen_target_descriptions_with_camera&quot;</p>
<p>            android:directionDescriptions=&quot;@array/lockscreen_direction_descriptions&quot;</p>
<p>            android:handleDrawable=&quot;@drawable/ic_lockscreen_handle&quot;</p>
<p>            android:waveDrawable=&quot;@drawable/ic_lockscreen_outerring&quot;</p>
<p>            android:outerRadius=&quot;@dimen/multiwaveview_target_placement_radius&quot;</p>
<p>            android:snapMargin=&quot;@dimen/multiwaveview_snap_margin&quot;</p>
<p>            android:hitRadius=&quot;@dimen/multiwaveview_hit_radius&quot;</p>
<p>            android:rightChevronDrawable=&quot;@drawable/ic_lockscreen_chevron_right&quot;</p>
<p>            android:feedbackCount=&quot;3&quot;</p>
<p>            android:vibrationDuration=&quot;20&quot;</p>
<p>            android:horizontalOffset=&quot;0dip&quot;</p>
<p>            android:verticalOffset=&quot;0dip&quot;</p>
<p>/&gt;</p>
<p>&lt;!– emergency call button shown when sim is PUKd and tab_selector is hidden –&gt;</p>
<p>&lt;Button</p>
<p>            android:id=&quot;@+id/emergencyCallButton&quot;</p>
<p>            android:layout_width=&quot;wrap_content&quot;</p>
<p>            android:layout_height=&quot;wrap_content&quot;</p>
<p>            android:layout_marginRight=&quot;80dip&quot;</p>
<p>            android:layout_marginBottom=&quot;80dip&quot;</p>
<p>            android:layout_alignParentRight=&quot;true&quot;</p>
<p>            android:layout_alignParentBottom=&quot;true&quot;</p>
<p>            android:drawableLeft=&quot;@drawable/ic_emergency&quot;</p>
<p>            style=&quot;@style/Widget.Button.Transparent&quot;</p>
<p>            android:drawablePadding=&quot;8dip&quot;</p>
<p>            android:visibility=&quot;gone&quot;/&gt;</p>
<p>&lt;/RelativeLayout&gt;&gt;</p>
<p>&lt;/LinearLayout&gt;</p>
<p>   从文件中可以看出，解锁界面的数字时钟、充电状态、波纹解锁等控件均在其中布局，对解锁控件的大小修改也是通过修改该文件进行的。</p>
<p>1.3. MultiWaveView控件分析</p>
<p>对于Android4.0默认的LockScreen，采用的是MultiWaveView控件，LockScreen中创建该控件的代码如下：</p>
<p>点击(此处)折叠或打开</p>
<p>mUnlockWidget = findViewById(R.id.unlock_widget);</p>
<p>if (mUnlockWidget instanceof SlidingTab) {</p>
<p>            SlidingTab slidingTabView = (SlidingTab) mUnlockWidget;</p>
<p>            slidingTabView.setHoldAfterTrigger(true, false);</p>
<p>            slidingTabView.setLeftHintText(R.string.lockscreen_unlock_label);</p>
<p>            slidingTabView.setLeftTabResources(</p>
<p>                    R.drawable.ic_jog_dial_unlock,</p>
<p>                    R.drawable.jog_tab_target_green,</p>
<p>                    R.drawable.jog_tab_bar_left_unlock,</p>
<p>                    R.drawable.jog_tab_left_unlock);</p>
<p>            SlidingTabMethods slidingTabMethods = new SlidingTabMethods(slidingTabView);</p>
<p>            slidingTabView.setOnTriggerListener(slidingTabMethods);</p>
<p>            mUnlockWidgetMethods = slidingTabMethods;</p>
<p>} else if (mUnlockWidget instanceof WaveView) {</p>
<p>            WaveView waveView = (WaveView) mUnlockWidget;</p>
<p>            WaveViewMethods waveViewMethods = new WaveViewMethods(waveView);</p>
<p>            waveView.setOnTriggerListener(waveViewMethods);</p>
<p>            mUnlockWidgetMethods = waveViewMethods;</p>
<p>} else if (mUnlockWidget instanceof MultiWaveView) {</p>
<p> MultiWaveView multiWaveView = (MultiWaveView) mUnlockWidget;</p>
<p>            MultiWaveViewMethods multiWaveViewMethods = new MultiWaveViewMethods(multiWaveView);</p>
<p>            multiWaveView.setOnTriggerListener(multiWaveViewMethods);</p>
<p>            mUnlockWidgetMethods = multiWaveViewMethods;</p>
<p>} else {</p>
<p>throw new IllegalStateException(&quot;Unrecognized unlock widget: &quot; + mUnlockWidget);</p>
<p>}</p>
<p>这是LockScreen的构造函数中的代码，函数根据R.id.unlock_widget定义的类型选择不同的控件类，其中第一种是Android2.3的滑动解锁类，第二种的简单的波纹解锁类，第三种才是我们使用的MultiWaveView类，函数并创建了一个MultiWaveViewMethods类，这个类实际上是为了更好地使用而进行的封装，它的代码如下：</p>
<p>点击(此处)折叠或打开</p>
<p>class MultiWaveViewMethods implements MultiWaveView.OnTriggerListener,</p>
<p>            UnlockWidgetCommonMethods {</p>
<p>private final MultiWaveView mMultiWaveView;</p>
<p>private boolean mCameraDisabled;</p>
<p>        MultiWaveViewMethods(MultiWaveView multiWaveView) {</p>
<p>            mMultiWaveView = multiWaveView;</p>
<p>final boolean cameraDisabled = mLockPatternUtils.getDevicePolicyManager()</p>
<p>.getCameraDisabled(null);</p>
<p>if (cameraDisabled) {</p>
<p>Log.v(TAG, &quot;Camera disabled by Device Policy&quot;);</p>
<p>                mCameraDisabled = true;</p>
<p>} else {</p>
<p>// Camera is enabled if resource is initially defined for MultiWaveView</p>
<p>// in the lockscreen layout file</p>
<p>                mCameraDisabled = mMultiWaveView.getTargetResourceId()</p>
<p>!= R.array.lockscreen_targets_with_camera;</p>
<p>}</p>
<p>}</p>
<p>public void updateResources() {</p>
<p>int resId;</p>
<p>if (mCameraDisabled) {</p>
<p>// Fall back to showing ring/silence if camera is disabled by DPM…</p>
<p>                resId = mSilentMode ? R.array.lockscreen_targets_when_silent</p>
<p>: R.array.lockscreen_targets_when_soundon;</p>
<p>} else {</p>
<p>                resId = R.array.lockscreen_targets_with_camera;</p>
<p>}</p>
<p>            mMultiWaveView.setTargetResources(resId);</p>
<p>}</p>
<p>public void onGrabbed(View v, int handle) {</p>
<p>}</p>
<p>public void onReleased(View v, int handle) {</p>
<p>}</p>
<p>public void onTrigger(View v, int target) {</p>
<p>if (target == 0 || target == 1) { // 0 = unlock/portrait, 1 = unlock/landscape</p>
<p>                mCallback.goToUnlockScreen();</p>
<p>} else if (target == 2 || target == 3) { // 2 = alt/portrait, 3 = alt/landscape</p>
<p>if (!mCameraDisabled) {</p>
<p>// Start the Camera</p>
<p>                    Intent intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);</p>
<p>                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
<p>                    mContext.startActivity(intent);</p>
<p>                    mCallback.goToUnlockScreen();</p>
<p>} else {</p>
<p>                    toggleRingMode();</p>
<p>                    mUnlockWidgetMethods.updateResources();</p>
<p>                    mCallback.pokeWakelock();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public void onGrabbedStateChange(View v, int handle) {</p>
<p>// Don’t poke the wake lock when returning to a state where the handle is</p>
<p>// not grabbed since that can happen when the system (instead of the user)</p>
<p>// cancels the grab.</p>
<p>if (handle != MultiWaveView.OnTriggerListener.NO_HANDLE) {</p>
<p>                mCallback.pokeWakelock();</p>
<p>}</p>
<p>}</p>
<p>这个类有两个方法特别重要，一个是更新MultiWaveView的资源，即public void updateResources()，另一个是对解锁后的响应，即public void onTrigger(View v, int target)，这方法传入的第二个参数为解锁选择的图标编号，图标是从右向左逆时针编号的，即最右边的图标编号为0，在此函数中即可进行解锁的处理，选择是进入主界面还是启动其他的Activity。Android4.0默认target = 0对应的是进入主界面，</p>
<p>target = 2或者target = 3启动Camera，其解锁界面的图标是每次都是使用固定的资源，在完成解锁后按下Power键或者系统再次进入锁定状态，LockScreen都会再构造一次，会重新布局并加载资源，因此可以使每次解锁界面都不一样。</p>
<p>2. 实现<br>2.1. 获取最近运行程序</p>
<p>在Android中可以通过ActivityManager获取到最近运行的Activity，详细的用法如下：</p>
<p>输入参数是需要查询的最大最近运行任务个数，查询的方式（默认采用ActivityManager.RECENT_IGNOR_UNAVAILABLE），返回ActivityManager.RecentTaskInfo对象，其定义如下：</p>
<p>其中的baseIntent为启动最近运行任务的Intent，通过它我们可以很方便地获取Activity的图标并启动最近运行的Activity。</p>
<p>相关的代码如下：</p>
<p>final ActivityManager am = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);           </p>
<p>List&lt;ActivityManager.RecentTaskInfo&gt; recentLs = am.getRecentTasks(7, ActivityManager.RECENT_IGNORE_UNAVAILABLE);</p>
<p>2.1.1. 获取Activity图标的方法</p>
<p>通过PackManager我们可以很方便地获取到Activity的图标，对应的代码如下：</p>
<p>final PackageManager pm = context.getPackageManager(); </p>
<p>pm.getActivityIcon(recentLs.get(i).baseIntent)</p>
<p>2.2.          修改/system/build.prop文件</p>
<p>这个文件中包含了大量Android中的配置信息，其中也有和显示分辨率相关的，修改的方法如下：</p>
<p>1.通过ADB将文件获取到主机任意文件夹。</p>
<p>adb pull /system/build.prop</p>
<p>2.用编辑软件打开build.prop，找到如下行</p>
<p>2.将ro.sf.lcd_density=120修改为=160或者直接删除掉这一行（这样就使用默认160）。</p>
<p>3.执行</p>
<p>adb push build.prop /system/</p>
<p>2.3. 修改MultiWaveView控件</p>
<p>修改以下位置的源文件：</p>
<p>Z:\exdroid\android4.0.1\frameworks\base\core\java\com\android\internal\widget\multiwaveview\MultiWaveView.java</p>
<p>重载setTargetResources方法，重载后的方法如下：</p>
<p>点击(此处)折叠或打开</p>
<p>public void setTargetResources(ArrayList&lt;Drawable&gt; drawables)</p>
<p>{</p>
<p>       Resources res = getContext().getResources();</p>
<p>int count = drawables.size();</p>
<p>ArrayList&lt;TargetDrawable&gt; targetDrawables = new ArrayList&lt;TargetDrawable&gt;(count);</p>
<p>for (int i = 0; i &lt; count; i++) {</p>
<p>            Drawable drawable = drawables.get(i);</p>
<p>            targetDrawables.add(new TargetDrawable(res, drawable));</p>
<p>Log.v(TAG,&quot;Add a Drawable&quot;);</p>
<p>}</p>
<p>        mTargetDrawables = targetDrawables;</p>
<p>        updateTargetPositions();</p>
<p>}</p>
<p>重载后的方法支持直接传入图片链表。这个方法是提供给LockScreen调用的</p>
<p>2.4.修改LockScreen.java文件</p>
<p>重载其中的MultiWaveViewMethods类的updateResources方法，重载后的方法如下：</p>
<p>点击(此处)折叠或打开</p>
<p>public void updateResources(Context context) </p>
<p>{ </p>
<p>ArrayList&lt;Drawable&gt; drawableAl = new ArrayList();</p>
<p>final ActivityManager am = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE); </p>
<p>final PackageManager pm = context.getPackageManager(); </p>
<p>              drawableAl.add(getView().getResources().getDrawable(R.drawable.ic_lockscreen_unlock));</p>
<p>List&lt;ActivityManager.RecentTaskInfo&gt; recentLs = am.getRecentTasks(7, ActivityManager.RECENT_IGNORE_UNAVAILABLE);</p>
<p>for(int i=0;i&lt;recentLs.size();i++)</p>
<p>{</p>
<p>try</p>
<p>{</p>
<p>                       drawableAl.add(pm.getActivityIcon(recentLs.get(i).baseIntent));</p>
<p>                       mIntentList.add(recentLs.get(i).baseIntent);</p>
<p>}</p>
<p>catch(Exception e)</p>
<p>{</p>
<p>Log.v(TAG,&quot;Catch Exception&quot;);</p>
<p>}</p>
<p>}</p>
<p>              mMultiWaveView.setTargetResources(drawableAl);</p>
<p>}</p>
<p>重载后的updateResources函数实际上先获取最近运行的任务列表，再获取任务图标，最后用获取的图标设置MultiWaveView控件。</p>
<p>修改解锁响应onTigger：</p>
<p>点击(此处)折叠或打开</p>
<p>public void onTrigger(View v, int target) {</p>
<p>Log.v(TAG,&quot;onTrigger = &quot; + target);</p>
<p>if(target ==0)</p>
<p>{</p>
<p>                   mCallback.goToUnlockScreen();</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>if(mIntentList.get(target-1)!=null)</p>
<p>{</p>
<p>                       Intent intent = mIntentList.get(target-1);</p>
<p>                       mContext.startActivity(intent);</p>
<p>                       mCallback.goToUnlockScreen();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>这样解锁事件的响应被修改成0号图标解锁，其余启动对应的Activity。</p>
<p>2.5. 调整解锁圆圈大小</p>
<p>启动应用程序的功能实现了，但是解锁圆圈的大小还是太大，特别是在更改dpi之后，圆圈几乎占据了半个显示屏，显得并不雅观。</p>
<p>实际上，解锁圆圈的资源就是/framework/cors/res/res/drawable-xxx中的unlock_ring.png，对于不同分辨率的设备，会采用不同的大小。我们可以通过修改位图的大小来进行更改，但在实际测试中修改了所有的unlock_ring.png，也未见解锁图标变小。</p>
<p>决定采用代码配合更改图案大小的功能，如图：</p>
<p>mOuterRing为外圆圈的资源，mOuterRadius为解锁圆圈的活动半径，修改代码后直接从图片获取，这样将采用drawable-sw480dp-mdpi下的图片，通过PhotoShop等软件将圆圈图片缩小，最终显示出的圆圈就变小了。</p>
<p>3. 关于Android屏幕的知识（摘自网上）<br>3.1. density</p>
<p>density表示每英寸有多少个显示点(逻辑值)，它的单位是dpi：dot per inch，通常屏幕大时，density就大，屏幕小时，density就小，通常:</p>
<p>屏幕实际分辨率为240px*400px时，density=120</p>
<p>屏幕实际分辨率为320px*533px，density=160</p>
<p>屏幕实际分辨率为480px*800px，density=240</p>
<p>3.2. 分辨率</p>
<p>是整个屏是多少点，比如800x480，它是软件的显示单位，实际上会因为不同的显示屏的像素大小不同，造成density不同。</p>
<p>3.3. 资源目录名称</p>
<p>res/xxx-hdpi          当density为240时，使用此目录下的资源</p>
<p>res/xxx-mdpi          当density为160时，使用此目录下的资源</p>
<p>res/xxx-ldpi          当density为120时，使用此目录下的资源</p>
<p>res/xxx                不常后缀，为默认设置，同xxx-mdpi</p>
<p>3.4. 资源单位（xml文件中定义大小的单位）</p>
<p>a)dp=dip=dx (Density independent pixel)</p>
<p>基于屏幕密度的抽象单位，设备无关的点，用于说明与密度无关的尺寸和位置。这些单位是相对于一个160dpi的屏幕，所有一个dp是160dpi屏幕上的一个点。</p>
<p>b)px (Pixel)</p>
<p>px指软件的单位点，设备相关的点</p>
<p>3.5. 获取屏幕信息的相关代码片段</p>
<p>public static String getDisplayMetrics(Context cx) {</p>
<p>String str = &quot;&quot;;</p>
<p>  DisplayMetrics dm = new DisplayMetrics();</p>
<p>  dm = cx.getApplicationContext().getResources().getDisplayMetrics();</p>
<p>int screenWidth = dm.widthPixels;</p>
<p>int screenHeight = dm.heightPixels;</p>
<p>float density = dm.density;</p>
<p>float xdpi = dm.xdpi;</p>
<p>float ydpi = dm.ydpi;</p>
<p>  str += &quot;The absolute width:&quot; + String.valueOf(screenWidth) + &quot;pixels\n&quot;;</p>
<p>  str += &quot;The absolute heightin:&quot; + String.valueOf(screenHeight)</p>
<p>+ &quot;pixels\n&quot;;</p>
<p>  str += &quot;The logical density of the display.:&quot; + String.valueOf(density)</p>
<p>+ &quot;\n&quot;;</p>
<p>  str += &quot;X dimension :&quot; + String.valueOf(xdpi) + &quot;pixels per inch\n&quot;;</p>
<p>  str += &quot;Y dimension :&quot; + String.valueOf(ydpi) + &quot;pixels per inch\n&quot;;</p>
<p>return str;</p>
<p>}</p>
<p>3.6.  获取状态栏和标题栏的高度</p>
<p>点击(此处)折叠或打开</p>
<p>TextView tv1;</p>
<p>@Override</p>
<p>protected void onCreate(Bundle savedInstanceState) {</p>
<p>super.onCreate(savedInstanceState);</p>
<p>  setContentView(R.layout.layout_test2);</p>
<p>  tv1 = (TextView) findViewById(R.id.TextView01);</p>
<p>  tv1.post(new Runnable(){</p>
<p>public void run()</p>
<p>{</p>
<p>      processLayout();</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>private void processLayout(){</p>
<p>  Rect rect= new Rect();</p>
<p>Window window= getWindow();</p>
<p>  tv1.getWindowVisibleDisplayFrame(rect);</p>
<p>//状态栏高度</p>
<p>int statusBarHeight= rect.top;</p>
<p>int contentViewTop= window.findViewById(Window.ID_ANDROID_CONTENT).getTop();</p>
<p>//标题栏高度</p>
<p>int titleBarHeight= contentViewTop - statusBarHeight;</p>
<p>//测试结果：ok之后 100多 ms 才运行了</p>
<p>Log.v(&quot;test&quot;, &quot;=-init-= statusBarHeight=&quot;+statusBarHeight+</p>
<p>&quot; contentViewTop=&quot;+contentViewTop+</p>
<p>&quot; titleBarHeight=&quot;+titleBarHeight); </p>
<p>}</p>
<p>4.总结 <br>    也算是费了一些功夫，总算是把First Task完成得差不多了，毕业一年以来都是在做WinCE驱动，虽然在大学里面学过一点Linux的知识，但是初次转到Android还是有点不适应，好在有网络这个好东西，Android学习才不是那么难，但是感觉也不能太依靠网络。从长期来看，在消费电子这一块，智能系统的进化将会越来越快，这对我等的考验会越来越大。但是当今世界就是一个不断学习的世界，今后要多把自己的学习总结出来，这样进步才会更快。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>深层次分析linux2</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90linux2.6input%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>在linux下，按键、触摸屏、鼠标等都可以利用input接口函数来实现设备驱动。</p>
<p>从上图可知：</p>
<p>输入子系统由三部分构成：</p>
<p>1 驱动</p>
<p>2 输入子系统</p>
<p>3 处理函数</p>
<p>其中2,3都是内核已经完成，我们要完成的就是1驱动</p>
<p>设备用input_dev结构体描述，使用input子系统实现输入设备驱动的时候，驱动的核心工作是向系统报告按键、触摸屏、键盘、鼠标等输入事件（event，通过input_event结构体描述），不再需要关心文件操作接口，因为input子系统已经完成了文件操作接口。驱动报告的事件经过InputCore和Eventhandler最终到达用户空间。</p>
<p>Input_dev 结构中比较重要的域有：</p>
<p>Name:名字</p>
<p>Evbit:设备所支持的事件类型</p>
<p>Keybit：按键类型</p>
<p>注册输入设备的函数为：</p>
<p>int input_register_device(struct input_dev *dev)</p>
<p>注销输入设备的函数为：</p>
<p>void input_unregister_device(struct input_dev *dev)</p>
<p>设备所支持的事件类型有：</p>
<p>EV_RST Reset EV_KEY 按键</p>
<p>EV_REL 相对坐标EV_ABS绝对坐标</p>
<p>EV_MSC 其它EV_LED LED</p>
<p>EV_SND 声音EV_REP Repeat</p>
<p>EV_FF 力反馈</p>
<p>并使用set_bit(EV_KEY, button_dev.evbit)告知结构体支持哪种设备类型</p>
<p>用于报告EV_KEY、EV_REL和EV_ABS事件的函数分别为：</p>
<p>void input_report_key(struct input_dev *dev,unsigned int code, int value)</p>
<p>void input_report_rel(struct input_dev *dev,unsigned int code, int value)</p>
<p>void input_report_abs(struct input_dev *dev,unsigned int code, int value)</p>
<p>code：</p>
<p>事件的代码。如果事件的类型是EV_KEY，该代码code为设备键盘代码。代码值0<del>127为键盘上的按键代码，0x110</del>0x116为鼠标上按键代码，其中0x110(BTN_LEFT)为鼠标左键，0x111(BTN_RIGHT)为鼠标右键,0x112(BTN_ MIDDLE)为鼠标中键。其它代码含义请参看include/linux/input.h文件</p>
<p>value</p>
<p>事件的值。如果事件的类型是EV_KEY,当按键按下时值为1,松开时值为0。</p>
<p>input_sync()用于事件同步，它告知事件的接收者：驱动已经发出了一个完整的报告。</p>
<p>在中断中，使用input_report_key等函数想用户空间报告，在应用程序中直接读取状态。</p>
<p>输入子系统的设备文件名默认为event0 – event31主设备号默认为13，类似于misc混杂设备。</p>
<p>下面基于mini2440的input输入按键驱动代码：</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/kernel.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/init.h&gt;</p>
<p>#include &lt;linux/delay.h&gt;</p>
<p>#include &lt;linux/poll.h&gt;</p>
<p>#include &lt;linux/irq.h&gt;</p>
<p>#include &lt;asm/irq.h&gt;</p>
<p>#include &lt;linux/interrupt.h&gt;</p>
<p>#include &lt;asm/uaccess.h&gt;</p>
<p>#include &lt;mach/regs-gpio.h&gt;</p>
<p>#include &lt;mach/hardware.h&gt;</p>
<p>#include &lt;linux/platform_device.h&gt;</p>
<p>#include &lt;linux/cdev.h&gt;</p>
<p>#include &lt;linux/miscdevice.h&gt;</p>
<p>#include &lt;linux/input.h&gt;</p>
<p>struct input_dev *button_dev;</p>
<p>struct button_irq_desc {</p>
<p>int irq;</p>
<p>int pin;</p>
<p>int pin_setting;</p>
<p>int number;</p>
<p>char *name;   </p>
<p>};</p>
<p>static struct button_irq_desc button_irqs [] = {</p>
<p>{IRQ_EINT8 , S3C2410_GPG0 ,  S3C2410_GPG0_EINT8  , 0, &quot;KEY0&quot;}, </p>
<p>{IRQ_EINT11, S3C2410_GPG3 ,  S3C2410_GPG3_EINT11 , 1, &quot;KEY1&quot;},</p>
<p>{IRQ_EINT13, S3C2410_GPG5 ,  S3C2410_GPG5_EINT13 , 2, &quot;KEY2&quot;},</p>
<p>{IRQ_EINT14, S3C2410_GPG6 ,  S3C2410_GPG6_EINT14 , 3, &quot;KEY3&quot;},</p>
<p>{IRQ_EINT15, S3C2410_GPG7 ,  S3C2410_GPG7_EINT15 , 4, &quot;KEY4&quot;},</p>
<p>{IRQ_EINT19, S3C2410_GPG11,  S3C2410_GPG11_EINT19, 5, &quot;KEY5&quot;},</p>
<p>};</p>
<p>static int key_values = 0;</p>
<p>static irqreturn_t buttons_interrupt(int irq, void *dev_id)</p>
<p>{</p>
<p>struct button_irq_desc *button_irqs = (struct button_irq_desc *)dev_id;</p>
<p>int down;</p>
<p>udelay(0);</p>
<p>down = !s3c2410_gpio_getpin(button_irqs-&gt;pin);   //down: 1(按下)，0（弹起）</p>
<p>if (!down) {</p>
<p>/<em>报告事件</em>/</p>
<p>key_values = button_irqs-&gt;number;</p>
<p>//printk(&quot;====&gt;rising key_values=%d\n&quot;,key_values);</p>
<p>if(key_values==0)</p>
<p>    input_report_key(button_dev, KEY_1, 0);</p>
<p>if(key_values==1)</p>
<p>    input_report_key(button_dev, KEY_2, 0);</p>
<p>if(key_values==2)</p>
<p>    input_report_key(button_dev, KEY_3, 0);</p>
<p>if(key_values==3)</p>
<p>    input_report_key(button_dev, KEY_4, 0);</p>
<p>if(key_values==4)</p>
<p>    input_report_key(button_dev, KEY_5, 0);</p>
<p>if(key_values==5)</p>
<p>    input_report_key(button_dev, KEY_6, 0);</p>
<p>input_sync(button_dev);     </p>
<p>   }</p>
<p>else {</p>
<p>key_values = button_irqs-&gt;number;</p>
<p>//printk(&quot;====&gt;falling key_values=%d\n&quot;,key_values);</p>
<p>if(key_values==0)</p>
<p>input_report_key(button_dev, KEY_1, 1);</p>
<p>if(key_values==1)</p>
<p>input_report_key(button_dev, KEY_2, 1);</p>
<p>if(key_values==2)</p>
<p>input_report_key(button_dev, KEY_3, 1);</p>
<p>if(key_values==3)</p>
<p>input_report_key(button_dev, KEY_4, 1);</p>
<p>if(key_values==4)</p>
<p>input_report_key(button_dev, KEY_5, 1);</p>
<p>if(key_values==5)</p>
<p>input_report_key(button_dev, KEY_6, 1);</p>
<p>input_sync(button_dev);     </p>
<p>}</p>
<p>return IRQ_RETVAL(IRQ_HANDLED);</p>
<p>}</p>
<p>static int s3c24xx_request_irq(void)</p>
<p>{</p>
<p>int i;</p>
<p>int err = 0;</p>
<p>for (i = 0; i &lt; sizeof(button_irqs)/sizeof(button_irqs[0]); i++) {</p>
<p>if (button_irqs[i].irq &lt; 0) {</p>
<p>continue;</p>
<p>}</p>
<p>     /* IRQ_TYPE_EDGE_FALLING,IRQ_TYPE_EDGE_RISING,IRQ_TYPE_EDGE_BOTH */</p>
<p>err = request_irq(button_irqs[i].irq, buttons_interrupt, IRQ_TYPE_EDGE_BOTH,</p>
<p>button_irqs[i].name, (void *)&amp;button_irqs[i]);</p>
<p>if (err)</p>
<p>break;</p>
<p>}</p>
<p>if (err) {</p>
<p>i–;</p>
<p>for (; i &gt;= 0; i–) {</p>
<p>    if (button_irqs[i].irq &lt; 0) {</p>
<p>continue;</p>
<p>    }</p>
<p>    disable_irq(button_irqs[i].irq);</p>
<p>free_irq(button_irqs[i].irq, (void *)&amp;button_irqs[i]);</p>
<p>}</p>
<p>return -EBUSY;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>static int __init dev_init(void)</p>
<p>{</p>
<p>/<em>request irq</em>/</p>
<p>s3c24xx_request_irq();</p>
<p>/* Initialise input stuff */</p>
<p>button_dev = input_allocate_device();</p>
<p>if (!button_dev) {</p>
<p>printk(KERN_ERR &quot;Unable to allocate the input device !!\n&quot;);</p>
<p>return -ENOMEM;</p>
<p>}</p>
<p>button_dev-&gt;name = &quot;s3c2440_button&quot;;</p>
<p>button_dev-&gt;id.bustype = BUS_RS232;</p>
<p>button_dev-&gt;id.vendor = 0xDEAD;</p>
<p>button_dev-&gt;id.product = 0xBEEF;</p>
<p>button_dev-&gt;id.version = 0x0100;</p>
<p>button_dev-&gt;evbit[0] = BIT_MASK(EV_KEY) | BIT(EV_SYN);</p>
<p>//set_bit(EV_KEY, button_dev-&gt;evbit)//支持EV_KEY事件</p>
<p>set_bit(KEY_1,   button_dev-&gt;keybit);</p>
<p>set_bit(KEY_2,   button_dev-&gt;keybit);</p>
<p>set_bit(KEY_3,   button_dev-&gt;keybit);</p>
<p>set_bit(KEY_4,   button_dev-&gt;keybit);</p>
<p>set_bit(KEY_5,   button_dev-&gt;keybit);</p>
<p>set_bit(KEY_6,   button_dev-&gt;keybit);</p>
<p>//printk(&quot;KEY_RESERVED=%d ,KEY_1=%d&quot;,KEY_RESERVED,KEY_1);</p>
<p>input_register_device(button_dev);   //注册input设备</p>
<p>printk (&quot;initialized\n&quot;);</p>
<p>return 0;</p>
<p>}</p>
<p>static void __exit dev_exit(void)</p>
<p>{</p>
<p>    int i;</p>
<p>for (i = 0; i &lt; sizeof(button_irqs)/sizeof(button_irqs[0]); i++) {</p>
<p>if (button_irqs[i].irq &lt; 0) {</p>
<p>        continue;</p>
<p>}</p>
<p>free_irq(button_irqs[i].irq, (void *)&amp;button_irqs[i]);</p>
<p>}</p>
<p>input_unregister_device(button_dev);</p>
<p>}</p>
<p>module_init(dev_init);</p>
<p>module_exit(dev_exit);</p>
<p>MODULE_LICENSE(&quot;GPL&quot;);</p>
<p>MODULE_AUTHOR(&quot;David Xie&quot;);</p>
<p>应用程序：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys/ioctl.h&gt;</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/stat.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;sys/select.h&gt;</p>
<p>#include &lt;sys/time.h&gt;</p>
<p>#include &lt;errno.h&gt;</p>
<p>#include &lt;linux/input.h&gt;</p>
<p>int main(void)</p>
<p>{</p>
<p>int buttons_fd;</p>
<p>int key_value,i=0,count;</p>
<p>struct input_event ev_key;</p>
<p>buttons_fd = open(&quot;/dev/event0&quot;, O_RDWR);</p>
<p>if (buttons_fd &lt; 0) {</p>
<p>perror(&quot;open device buttons&quot;);</p>
<p>exit(1);</p>
<p>}</p>
<p>for (;;) {</p>
<p>count = read(buttons_fd,&amp;ev_key,sizeof(struct input_event));</p>
<p>//     printf(&quot;count=%d\n&quot;,count);</p>
<p>for(i=0; i&lt;(int)count/sizeof(struct input_event); i++)</p>
<p>if(EV_KEY==ev_key.type)</p>
<p>printf(&quot;type:%d,code:%d,value:%d\n&quot;, ev_key.type,ev_key.code-1,ev_key.value);</p>
<p>if(EV_SYN==ev_key.type)</p>
<p>printf(&quot;syn event\n\n&quot;);</p>
<p>}</p>
<p>close(buttons_fd);</p>
<p>return 0;</p>
<p>}</p>
<p>加载内核模块：</p>
<p>多了event0设备文件</p>
<p>运行应用程序：</p>
<p>、</p>
<p>下面我们分析input子系统源码：</p>
<p>在分析源代码之前，我们要先了解几个主要的结构：</p>
<p>Input_dev是代表一个输入设备。</p>
<p>struct input_dev {<br> const char *name;<br> const char <em>phys;<br> const char *uniq;<br> struct input_id id;  /*ID域</em>/</p>
<p> unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; /<em>设备所支持的事件类型</em>/<br> unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];/<em>键值</em>/<br> unsigned long relbit[BITS_TO_LONGS(REL_CNT)];<br> unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];<br> unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];<br> unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];<br> unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];<br> unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];<br> unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</p>
<p> unsigned int keycodemax;<br> unsigned int keycodesize;<br> void *keycode;<br> int (*setkeycode)(struct input_dev *dev, int scancode, int keycode);<br> int (*getkeycode)(struct input_dev *dev, int scancode, int *keycode);</p>
<p> struct ff_device *ff;</p>
<p> unsigned int repeat_key;<br> struct timer_list timer;</p>
<p> int sync;</p>
<p> int abs[ABS_MAX + 1];<br> int rep[REP_MAX + 1];</p>
<p> unsigned long key[BITS_TO_LONGS(KEY_CNT)];<br> unsigned long led[BITS_TO_LONGS(LED_CNT)];<br> unsigned long snd[BITS_TO_LONGS(SND_CNT)];<br> unsigned long sw[BITS_TO_LONGS(SW_CNT)];</p>
<p> int absmax[ABS_MAX + 1];<br> int absmin[ABS_MAX + 1];<br> int absfuzz[ABS_MAX + 1];<br> int absflat[ABS_MAX + 1];<br> int absres[ABS_MAX + 1];</p>
<p> int (*open)(struct input_dev *dev);  <br> void (*close)(struct input_dev *dev);<br> int (*flush)(struct input_dev *dev, struct file *file);<br> int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);</p>
<p> struct input_handle *grab;   /<em>用于连接input_handler和input_dev的结构</em>/</p>
<p> spinlock_t event_lock;<br> struct mutex mutex;</p>
<p> unsigned int users;<br> bool going_away;</p>
<p> struct device dev;</p>
<p> struct list_head h_list;   /<em>链表连接input_handle</em>/<br> struct list_head node;/<em>链表连接下一个input_dev</em>/<br>};</p>
<p> input_handler表示一个Input设备对应的handler</p>
<p>struct input_handler {</p>
<p> void <em>private;<br> /<em>事件处理函数</em>/<br> void (<em>event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);<br> /*用来连接handler和dev的函数</em>/<br> int (<em>connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);<br> void (*disconnect)(struct input_handle *handle);<br> void (*start)(struct input_handle *handle);<br> /*操作函数集</em>/<br> const struct file_operations *fops;<br> /*次设备号</em>/<br> int minor;<br> const char <em>name;<br> /<em>用来识别驱动是否能够处理的表</em>/<br> const struct input_device_id *id_table;<br> /*用来识别驱动不能处理的表(黑名单)</em>/<br> const struct input_device_id *blacklist;<br> /<em>用来连接handle</em>/<br> struct list_head h_list;<br> /<em>用来连接下一个hanlder</em>/<br> struct list_head node;<br>};</p>
<p>input_handle是用来连接input_handler和input_dev的结构</p>
<p> /<em>用于连接input_dev和input_hander</em>/<br>struct input_handle {</p>
<p> void *private; /<em>私有指针</em>/<br> /<em>打开计数</em>/<br> int open;   <br> const char *name;</p>
<p> struct input_dev <em>dev;  /<em>依附的input_dev结构</em>/<br> struct input_handler *handler; /*依附的handler</em>/</p>
<p> struct list_head d_node; /<em>连接dev</em>/<br> struct list_head h_node;/<em>连接handler</em>/<br>};</p>
<p>在内核中，因为Input是作为子系统存在，跟其子系统一样，首先会执行input.c的input_init,(如rtc子系统在加载具体设备驱动程序之前会加载rtc_init,iic子系统会加载iic_init)。</p>
<p>其中input_init的标志是subsys_initcall(input_init);“优先级”比module_init更高。</p>
<p>static int __init input_init(void)<br>{<br> int err;<br> /<em>填充input_abs_bypass数组</em>/<br> input_init_abs_bypass();<br> /<em>注册input类，在/sys/class/input</em>/<br> err = class_register(&amp;input_class);<br> if (err) {<br>  printk(KERN_ERR &quot;input: unable to register input_dev class\n&quot;);<br>  return err;<br> }<br> /<em>在Proc建立相关文件</em>/<br> err = input_proc_init();<br> if (err)<br>  goto fail1;<br> /<em>注册cdev结构 主设备号是13</em>/<br> err = register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);<br> if (err) {<br>  printk(KERN_ERR &quot;input: unable to register char major %d&quot;, INPUT_MAJOR);<br>  goto fail2;<br> }</p>
<p> return 0;</p>
<p> fail2: input_proc_exit();<br> fail1: class_unregister(&amp;input_class);<br> return err;<br>}</p>
<p>有上可知 input_init主要功能（1）填充input_abs_bypass数组并注册input类（2）在proc目录下建立交互文件（3）注册cdev，主设备号为13</p>
<p>我们在查看input_fops结构：</p>
<p>static const struct file_operations input_fops = {<br> .owner = THIS_MODULE,<br> .open = input_open_file,<br>};<br>只有open函数，为什么呢，我们查看input_open_file的源码：</p>
<p>static int input_open_file(struct inode *inode, struct file *file)<br>{<br> struct input_handler *handler;<br> const struct file_operations *old_fops, *new_fops = NULL;<br> int err;</p>
<p> lock_kernel();<br> /* No load-on-demand here? */<br> /<em>通过次设备号左移5位找到handler结构，也就是次设备号0-31对应的handler结构都一样 <br> 32-63一样，依次类推</em>/<br> handler = input_table[iminor(inode) &gt;&gt; 5];<br>  /<em>获取handler中的fops</em>/<br> if (!handler || !(new_fops = fops_get(handler-&gt;fops))) {<br>  err = -ENODEV;<br>  goto out;<br> }</p>
<p> /*<br>  * That’s <em>really</em> odd. Usually NULL -&gt;open means &quot;nothing special&quot;,<br>  * not &quot;no device&quot;. Oh, well…<br>  */<br>  /<em>如果open函数指针为空</em>/<br> if (!new_fops-&gt;open) {<br>  fops_put(new_fops);<br>  err = -ENODEV;<br>  goto out;<br> }<br> old_fops = file-&gt;f_op;<br> file-&gt;f_op = new_fops;<br> /<em>执行handler的open函数</em>/<br> err = new_fops-&gt;open(inode, file);<br> if (err) {<br>  fops_put(file-&gt;f_op);<br>  file-&gt;f_op = fops_get(old_fops);<br> }<br> fops_put(old_fops);<br>out:<br> unlock_kernel();<br> return err;<br>}</p>
<p>由上可知：open函数最终会调用对应handler的open函数。</p>
<p>子系统初始化之后，下面就是事件的驱动了，在这里我们支持的是按键，对应的驱动是evdev.c</p>
<p>static int __init evdev_init(void)<br>{<br> return input_register_handler(&amp;evdev_handler);<br>}</p>
<p>static struct input_handler evdev_handler = {<br> .event  = evdev_event,<br> .connect = evdev_connect,<br> .disconnect = evdev_disconnect,<br> .fops  = &amp;evdev_fops,<br> .minor  = EVDEV_MINOR_BASE,<br> .name  = &quot;evdev&quot;,<br> .id_table = evdev_ids,<br>};</p>
<p>int input_register_handler(struct input_handler *handler)<br>{<br> struct input_dev *dev;<br> int retval;</p>
<p> retval = mutex_lock_interruptible(&amp;input_mutex);<br> if (retval)<br>  return retval;</p>
<p> INIT_LIST_HEAD(&amp;handler-&gt;h_list);<br> /<em>将handler存于input_handler数组</em>/<br> if (handler-&gt;fops != NULL) {<br>  if (input_table[handler-&gt;minor &gt;&gt; 5]) {<br>   retval = -EBUSY;<br>   goto out;<br>  }<br>  input_table[handler-&gt;minor &gt;&gt; 5] = handler;<br> }<br> /<em>将hander添加到input_handler_list</em>/<br> list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);<br> /<em>遍历整个input_dev_list</em>/<br> list_for_each_entry(dev, &amp;input_dev_list, node)<br>  input_attach_handler(dev, handler);</p>
<p> input_wakeup_procfs_readers();</p>
<p> out:<br> mutex_unlock(&amp;input_mutex);<br> return retval;<br>}</p>
<p>事件层注册完之后</p>
<p>下面就是具体按键驱动的注册了：</p>
<p>首先：</p>
<p>struct input_dev <em>input_allocate_device(void)<br>{<br> struct input_dev *dev;<br> /*分配内存空间</em>/<br> dev = kzalloc(sizeof(struct input_dev), GFP_KERNEL);<br> if (dev) {<br>  /<em>填充结构</em>/<br>  dev-&gt;dev.type = &amp;input_dev_type;<br>  dev-&gt;dev.class = &amp;input_class;<br>  /<em>设备初始化，在/sys/device目录下建立目录</em>/<br>  device_initialize(&amp;dev-&gt;dev);<br>  mutex_init(&amp;dev-&gt;mutex);<br>  spin_lock_init(&amp;dev-&gt;event_lock);<br>  INIT_LIST_HEAD(&amp;dev-&gt;h_list);<br>  INIT_LIST_HEAD(&amp;dev-&gt;node);</p>
<p>  __module_get(THIS_MODULE);<br> }</p>
<p> return dev;<br>}</p>
<p>input_allocate_device分配一个input_dev,并在/sys/device下建立目录。</p>
<p>下面注册dev结构</p>
<p>int input_register_device(struct input_dev <em>dev)<br>{<br> static atomic_t input_no = ATOMIC_INIT(0);<br> struct input_handler *handler;<br> const char *path;<br> int error;<br> /</em> 对每个输入设备都设置EV_SYN位 <em>/<br> __set_bit(EV_SYN, dev-&gt;evbit);<br> /</em><br>  * If delay and period are pre-set by the driver, then autorepeating<br>  * is handled by the driver itself and we don’t do it in input.c.<br>  */<br> /<em>初始化内核定时器</em>/<br> init_timer(&amp;dev-&gt;timer);<br> if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) {<br>  dev-&gt;timer.data = (long) dev;<br>  dev-&gt;timer.function = input_repeat_key;<br>  dev-&gt;rep[REP_DELAY] = 250;<br>  dev-&gt;rep[REP_PERIOD] = 33;<br> }</p>
<p> if (!dev-&gt;getkeycode)<br>  dev-&gt;getkeycode = input_default_getkeycode;</p>
<p> if (!dev-&gt;setkeycode)<br>  dev-&gt;setkeycode = input_default_setkeycode;</p>
<p> dev_set_name(&amp;dev-&gt;dev, &quot;input%ld&quot;,<br>       (unsigned long) atomic_inc_return(&amp;input_no) - 1);<br> /<em>添加设备到device</em>/<br> error = device_add(&amp;dev-&gt;dev);<br> if (error)<br>  return error;<br>  /<em>获取kobj路径</em>/<br> path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);<br> printk(KERN_INFO &quot;input: %s as %s\n&quot;,<br>  dev-&gt;name ? dev-&gt;name : &quot;Unspecified device&quot;, path ? path : &quot;N/A&quot;);<br> kfree(path);<br> /<em>互斥锁上锁</em>/<br> error = mutex_lock_interruptible(&amp;input_mutex);<br> if (error) {<br>  device_del(&amp;dev-&gt;dev);<br>  return error;<br> }<br> /<em>将dev结构加入到input_dev_list链表头</em>/<br> list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);<br> /<em>遍历整个input_handler_list链表，通过判断handler的id域和dev的id域是否匹配，如果匹配将handler和dev联系起来</em>/<br> list_for_each_entry(handler, &amp;input_handler_list, node)<br>  input_attach_handler(dev, handler);<br> /<em>唤醒等待队列</em>/<br> input_wakeup_procfs_readers();<br> /<em>互斥锁解锁</em>/<br> mutex_unlock(&amp;input_mutex);</p>
<p> return 0;<br>}</p>
<p>input_register_device的主要作用是</p>
<p>（1）      对形参Input_dev结构的一些默认参数做填充，包括支持的事件类型，timer函数，getkeycode函数指针，setkeycode函数指针，并且对dev域的name填充。</p>
<p>（2）      device_add 添加设备到device核心</p>
<p>（3）      将该Input_dev结构加入到input_dev_list链表</p>
<p>（4）      遍历整个input_handler_list链表，找到一个handler的id_table和input_dev的id一直的handler结构，并将此hanlder和此input_dev结构联系起来</p>
<p>对(4)要重点分析：</p>
<p>list_for_each_entry(handler, &amp;input_handler_list, node)</p>
<p>input_attach_handler(dev, handler);</p>
<p>list_for_each_entry之前已经讲过，就是对input_handler_list整个链表进行遍历。</p>
<p>static int input_attach_handler(struct input_dev *dev, struct input_handler <em>handler)<br>{<br> const struct input_device_id *id;<br> int error;<br> /*如果该dev的id在handler的blacklist已经登记，则跳过</em>/<br> if (handler-&gt;blacklist &amp;&amp; input_match_device(handler-&gt;blacklist, dev))<br>  return -ENODEV;<br> /<em>找到handler的id_table和dev的id一致的id_table结构</em>/<br> id = input_match_device(handler-&gt;id_table, dev);<br> if (!id)<br>  return -ENODEV;<br> /<em>通过ID将input和handler联系起来了</em>/<br> error = handler-&gt;connect(handler, dev, id);<br> if (error &amp;&amp; error != -ENODEV)<br>  printk(KERN_ERR<br>   &quot;input: failed to attach handler %s to device %s, &quot;<br>   &quot;error: %d\n&quot;,<br>   handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</p>
<p> return error;<br>}</p>
<p>当handler的id_table和dev的id一致就执行handler的connect函数将dev和handler联系起来。执行handler的connect函数。那么在这里对应的就是evdev_handler的evdev_connect函数。</p>
<p>static int evdev_connect(struct input_handler <em>handler, struct input_dev *dev,<br>    const struct input_device_id *id)<br>{<br> struct evdev *evdev;<br> int minor;<br> int error;<br> /*找到evdev_table中第一个为NULL的元素</em>/<br> for (minor = 0; minor &lt; EVDEV_MINORS; minor++)<br>  if (!evdev_table[minor])<br>   break;<br> /<em>如果evdev_table中每个元素存在则退出</em>/<br> if (minor == EVDEV_MINORS) {<br>  printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);<br>  return -ENFILE;<br> }<br> /<em>分配内存</em>/<br> evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);<br> if (!evdev)<br>  return -ENOMEM;</p>
<p> INIT_LIST_HEAD(&amp;evdev-&gt;client_list);<br> spin_lock_init(&amp;evdev-&gt;client_lock);<br> mutex_init(&amp;evdev-&gt;mutex);<br> init_waitqueue_head(&amp;evdev-&gt;wait);</p>
<p> dev_set_name(&amp;evdev-&gt;dev, &quot;event%d&quot;, minor);<br> evdev-&gt;exist = 1;<br> evdev-&gt;minor = minor;</p>
<p> evdev-&gt;handle.dev = input_get_device(dev);<br> evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);<br> evdev-&gt;handle.handler = handler;<br> evdev-&gt;handle.private = evdev;</p>
<p> evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);<br> evdev-&gt;dev.class = &amp;input_class;<br> evdev-&gt;dev.parent = &amp;dev-&gt;dev;<br> evdev-&gt;dev.release = evdev_free;<br> device_initialize(&amp;evdev-&gt;dev);<br> /<em>将hanlde handler input_dev三者联系起来</em>/<br> error = input_register_handle(&amp;evdev-&gt;handle);<br> if (error)<br>  goto err_free_evdev;<br> /<em>将evdev填充到evdev_table</em>/<br> error = evdev_install_chrdev(evdev);<br> if (error)<br>  goto err_unregister_handle;<br> /<em>添加设备</em>/<br> error = device_add(&amp;evdev-&gt;dev);<br> if (error)<br>  goto err_cleanup_evdev;</p>
<p> return 0;</p>
<p> err_cleanup_evdev:<br> evdev_cleanup(evdev);<br> err_unregister_handle:<br> input_unregister_handle(&amp;evdev-&gt;handle);<br> err_free_evdev:<br> put_device(&amp;evdev-&gt;dev);<br> return error;<br>}</p>
<p>由上：evdev_connect的函数主要功能：（1）分配一个evdev，并将它填充到evdev_table中（方便以后调用），（2）调用input_register_handle将hander handle input_dev连接起来，其中handle分别和input_dev和handler相连。（3）调用device_add添加设备。</p>
<p>调用完evdev_connect之后handle handler input_dev之间就通过链表关联起来了。</p>
<p>对于(2)要分析一下：</p>
<p>int input_register_handle(struct input_handle *handle)<br>{<br> struct input_handler *handler = handle-&gt;handler;<br> struct input_dev *dev = handle-&gt;dev;<br> int error;</p>
<p> /*<br>  * We take dev-&gt;mutex here to prevent race with<br>  * input_release_device().<br>  */<br> error = mutex_lock_interruptible(&amp;dev-&gt;mutex);<br> if (error)<br>  return error;<br> /<em>将handle连接到input的头部</em>/<br> list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);<br> mutex_unlock(&amp;dev-&gt;mutex);</p>
<p> /*<br>  * Since we are supposed to be called from -&gt;connect()<br>  * which is mutually exclusive with -&gt;disconnect()<br>  * we can’t be racing with input_unregister_handle()<br>  * and so separate lock is not needed here.<br>  */<br>  /<em>将handle连接到handler的尾部</em>/<br> list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);<br> /<em>如果存在start域，则执行start</em>/<br> if (handler-&gt;start)<br>  handler-&gt;start(handle);</p>
<p> return 0;<br>}</p>
<p>通过input_register_handle就将handler handle input_dev3个结构通过链表联系起来了。</p>
<p>当上面这些步骤完成之前，驱动就在内核注册好了，驱动程序加载完后，在/dev/input目录下就生成了even0设备，它的主设备号是13，次设备号为64.</p>
<p>当应用程序使用open函数打开/dev/input/even0设备时，在内核中Input子系统，open对应的驱动时input.c的input_open_file函数：</p>
<p>static int input_open_file(struct inode *inode, struct file *file)<br>{<br> struct input_handler *handler;<br> const struct file_operations *old_fops, *new_fops = NULL;<br> int err;</p>
<p> lock_kernel();<br> /* No load-on-demand here? */<br> /<em>通过次设备号左移5位找到handler结构，也就是次设备号0-31对应的handler结构都一样 <br> 32-63一样，依次类推</em>/<br> handler = input_table[iminor(inode) &gt;&gt; 5];<br>  /<em>获取handler中的fops</em>/<br> if (!handler || !(new_fops = fops_get(handler-&gt;fops))) {<br>  err = -ENODEV;<br>  goto out;<br> }</p>
<p> /*<br>  * That’s <em>really</em> odd. Usually NULL -&gt;open means &quot;nothing special&quot;,<br>  * not &quot;no device&quot;. Oh, well…<br>  */<br>  /<em>如果open函数指针为空</em>/<br> if (!new_fops-&gt;open) {<br>  fops_put(new_fops);<br>  err = -ENODEV;<br>  goto out;<br> }<br> old_fops = file-&gt;f_op;<br> file-&gt;f_op = new_fops;<br> /<em>执行handler的open函数</em>/<br> err = new_fops-&gt;open(inode, file);<br> if (err) {<br>  fops_put(file-&gt;f_op);<br>  file-&gt;f_op = fops_get(old_fops);<br> }<br> fops_put(old_fops);<br>out:<br> unlock_kernel();<br> return err;<br>}</p>
<p>input_open_file主要做了以下事情：（1）通过此设备号右移5位（因为Input_register_handler中次设备号左移5位存储于Input_table中）获取handler结构，在此处就是evdev_handler。（2）如果evdev_handler的open函数存在就执行evdev_handler的open函数。</p>
<p>上面已经提到：evdev_handler的fops：下面就执行evdev_handler的fops的open了。</p>
<p>static int evdev_open(struct inode <em>inode, struct file <em>file)<br>{<br> struct evdev *evdev;<br> /*evdev_client结构对应一个具体的设备</em>/<br> struct evdev_client *client;<br> /*次设备号减去64=0</em>/<br> int i = iminor(inode) - EVDEV_MINOR_BASE;<br> int error;</p>
<p> if (i &gt;= EVDEV_MINORS)<br>  return -ENODEV;</p>
<p> error = mutex_lock_interruptible(&amp;evdev_table_mutex);<br> if (error)<br>  return error;<br> /<em>获取储存在evdev_table的evdev结构</em>/<br> evdev = evdev_table[i];<br> if (evdev)<br>  get_device(&amp;evdev-&gt;dev);<br> mutex_unlock(&amp;evdev_table_mutex);</p>
<p> if (!evdev)<br>  return -ENODEV;</p>
<p> client = kzalloc(sizeof(struct evdev_client), GFP_KERNEL);<br> if (!client) {<br>  error = -ENOMEM;<br>  goto err_put_evdev;<br> }</p>
<p> spin_lock_init(&amp;client-&gt;buffer_lock);<br> client-&gt;evdev = evdev;<br> /<em>通过链表将client置于evdev的链表头</em>/<br> evdev_attach_client(evdev, client);</p>
<p> error = evdev_open_device(evdev);<br> if (error)<br>  goto err_free_client;<br> /<em>将client置于file的私有指针域</em>/<br> file-&gt;private_data = client;<br> return 0;</p>
<p> err_free_client:<br> evdev_detach_client(evdev, client);<br> kfree(client);<br> err_put_evdev:<br> put_device(&amp;evdev-&gt;dev);<br> return error;<br>}</p>
<p>evdev_open函数主要做了以下事情：（1）通过次设备号获取evdev结构（2）分配一个endev_client结构并将client-&gt;evdev指向获取的evdev结构（3）调用evdev_attach_client函数将client置于evdev的链表头（4）调用evdev_open_device函数</p>
<p>evdev_open_device函数：</p>
<p>{</p>
<p>int retval;</p>
<p>retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);</p>
<p>if (retval)</p>
<p>return retval;</p>
<p>if (!evdev-&gt;exist)</p>
<p>retval = -ENODEV;</p>
<p>else if (!evdev-&gt;open++) {</p>
<p>retval = input_open_device(&amp;evdev-&gt;handle);</p>
<p>if (retval)</p>
<p>evdev-&gt;open–;</p>
<p>}</p>
<p>mutex_unlock(&amp;evdev-&gt;mutex);</p>
<p>return retval;</p>
<p>}</p>
<p>函数调用input_open_device函数</p>
<p>int input_open_device(struct input_handle *handle)</p>
<p>{</p>
<p>struct input_dev *dev = handle-&gt;dev;</p>
<p>int retval;</p>
<p>retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</p>
<p>if (retval)</p>
<p>return retval;</p>
<p>if (dev-&gt;going_away) {</p>
<p>retval = -ENODEV;</p>
<p>goto out;</p>
<p>}</p>
<p>/<em>open计数加一</em>/</p>
<p>handle-&gt;open++;</p>
<p>/<em>当用户第一次调用时会调用dev的open函数</em>/</p>
<p>if (!dev-&gt;users++ &amp;&amp; dev-&gt;open)</p>
<p>retval = dev-&gt;open(dev);</p>
<p>if (retval) {</p>
<p>dev-&gt;users–;</p>
<p>if (!–handle-&gt;open) {</p>
<p>/*</p>
<p> * Make sure we are not delivering any more events</p>
<p> * through this handle</p>
<p> */</p>
<p>synchronize_rcu();</p>
<p>}</p>
<p>}</p>
<p>out:</p>
<p>mutex_unlock(&amp;dev-&gt;mutex);</p>
<p>return retval;</p>
<p>}</p>
<p>因为在本按键驱动中，没有设置button_dev的open域，所以这里input_open_device无意义。</p>
<p>下面就是read函数监听键值了：</p>
<p>Read函数对应的驱动程序是 evdev.c的evdev_read。</p>
<p>static ssize_t evdev_read(struct file *file, char __user <em>buffer, size_t count, loff_t *ppos)<br>{<br> /*获得client结构</em>/<br> struct evdev_client <em>client = file-&gt;private_data;<br> struct evdev *evdev = client-&gt;evdev;<br> struct input_event event;<br> int retval;<br> /*如果读取的字符数小于input_event结构的大小</em>/<br> if (count &lt; input_event_size())<br>  return -EINVAL;<br> /<em>如果头结点等于尾节点而且打开标志是不阻塞的，那么直接返回</em>/<br> if (client-&gt;head == client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp;<br>     (file-&gt;f_flags &amp; O_NONBLOCK))<br>  return -EAGAIN;<br> /<em>条件为假阻塞，直到为真为止</em>/<br> retval = wait_event_interruptible(evdev-&gt;wait,<br>  client-&gt;head != client-&gt;tail || !evdev-&gt;exist);<br> if (retval)<br>  return retval;</p>
<p> if (!evdev-&gt;exist)<br>  return -ENODEV;<br> while (retval + input_event_size() &lt;= count &amp;&amp;<br>        evdev_fetch_next_event(client, &amp;event)) {</p>
<p>  if (input_event_to_user(buffer + retval, &amp;event))<br>   return -EFAULT;</p>
<p>  retval += input_event_size();<br> }</p>
<p> return retval;<br>}</p>
<p>这里有必要提一下evdev_read函数中的client结构：</p>
<p>这里有必要提一下evdev_read函数中的client结构：</p>
<p>struct evdev_client {<br> /<em>存放事件的buffer</em>/<br> struct input_event buffer[EVDEV_BUFFER_SIZE];<br> /<em>事件头结点</em>/<br> int head;<br> /<em>事件尾节点</em>/<br> int tail;<br> spinlock_t buffer_lock; /* protects access to buffer, head and tail <em>/<br> struct fasync_struct *fasync;<br> /*evdev结构指针</em>/<br> struct evdev *evdev;<br> /<em>指向handler的链表</em>/<br> struct list_head node;<br>};</p>
<p>这个结构中的head tail相当于一个循环队列，只有当head不等于tail的时候才表示buffer里面不为空。那么当调用evdev_read时运行到retval = wait_event_interruptible(evdev-&gt;wait,client-&gt;head != client-&gt;tail || !evdev-&gt;exist);时evdev_read会阻塞。这样就会等待按键。</p>
<p>当按下键值，进入中断函数，调用input_report_key报告event。</p>
<p>static inline void input_report_key(struct input_dev *dev, unsigned int code, int value)<br>{<br> input_event(dev, EV_KEY, code, !!value);<br>}</p>
<p>void input_event(struct input_dev *dev,<br>   unsigned int type, unsigned int code, int value)<br>{<br> unsigned long flags;<br> /<em>判断evbit是否是事件所支持</em>/<br> if (is_event_supported(type, dev-&gt;evbit, EV_MAX)) {</p>
<p>  spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);<br>  add_input_randomness(type, code, value);<br>  /<em>事件处理函数</em>/<br>  input_handle_event(dev, type, code, value);<br>  spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);<br> }<br>}</p>
<p>函数最终调用input_handle_event</p>
<p>input_handle_event函数再根据type类型做相应处理，该驱动去type为EV_KEY，<br>static void input_handle_event(struct input_dev *dev,<br>          unsigned int type, unsigned int code, int value)<br>{<br> int disposition = INPUT_IGNORE_EVENT;</p>
<p> switch (type) {</p>
<p> case EV_SYN:<br>  switch (code) {<br>  case SYN_CONFIG:<br>   disposition = INPUT_PASS_TO_ALL;<br>   break;</p>
<p>  case SYN_REPORT:<br>   if (!dev-&gt;sync) {<br>    dev-&gt;sync = 1;<br>    disposition = INPUT_PASS_TO_HANDLERS;<br>   }<br>   break;<br>  case SYN_MT_REPORT:<br>   dev-&gt;sync = 0;<br>   disposition = INPUT_PASS_TO_HANDLERS;<br>   break;<br>  }<br>  break;</p>
<p> case EV_KEY:<br>  /<em>再次判断keybit是否是小于最大键值</em>/<br>  if (is_event_supported(code, dev-&gt;keybit, KEY_MAX) &amp;&amp;<br>      !!test_bit(code, dev-&gt;key) != value) {</p>
<p>   if (value != 2) {<br>    __change_bit(code, dev-&gt;key);<br>    if (value)<br>     input_start_autorepeat(dev, code);<br>    else<br>     input_stop_autorepeat(dev);<br>   }</p>
<p>   disposition = INPUT_PASS_TO_HANDLERS;<br>  }<br>  break;</p>
<p> case EV_SW:<br>  if (is_event_supported(code, dev-&gt;swbit, SW_MAX) &amp;&amp;<br>      !!test_bit(code, dev-&gt;sw) != value) {</p>
<p>   __change_bit(code, dev-&gt;sw);<br>   disposition = INPUT_PASS_TO_HANDLERS;<br>  }<br>  break;</p>
<p> case EV_ABS:<br>  if (is_event_supported(code, dev-&gt;absbit, ABS_MAX)) {</p>
<p>   if (test_bit(code, input_abs_bypass)) {<br>    disposition = INPUT_PASS_TO_HANDLERS;<br>    break;<br>   }</p>
<p>   value = input_defuzz_abs_event(value,<br>     dev-&gt;abs[code], dev-&gt;absfuzz[code]);</p>
<p>   if (dev-&gt;abs[code] != value) {<br>    dev-&gt;abs[code] = value;<br>    disposition = INPUT_PASS_TO_HANDLERS;<br>   }<br>  }<br>  break;</p>
<p> case EV_REL:<br>  if (is_event_supported(code, dev-&gt;relbit, REL_MAX) &amp;&amp; value)<br>   disposition = INPUT_PASS_TO_HANDLERS;</p>
<p>  break;</p>
<p> case EV_MSC:<br>  if (is_event_supported(code, dev-&gt;mscbit, MSC_MAX))<br>   disposition = INPUT_PASS_TO_ALL;</p>
<p>  break;</p>
<p> case EV_LED:<br>  if (is_event_supported(code, dev-&gt;ledbit, LED_MAX) &amp;&amp;<br>      !!test_bit(code, dev-&gt;led) != value) {</p>
<p>   __change_bit(code, dev-&gt;led);<br>   disposition = INPUT_PASS_TO_ALL;<br>  }<br>  break;</p>
<p> case EV_SND:<br>  if (is_event_supported(code, dev-&gt;sndbit, SND_MAX)) {</p>
<p>   if (!!test_bit(code, dev-&gt;snd) != !!value)<br>    __change_bit(code, dev-&gt;snd);<br>   disposition = INPUT_PASS_TO_ALL;<br>  }<br>  break;</p>
<p> case EV_REP:<br>  if (code &lt;= REP_MAX &amp;&amp; value &gt;= 0 &amp;&amp; dev-&gt;rep[code] != value) {<br>   dev-&gt;rep[code] = value;<br>   disposition = INPUT_PASS_TO_ALL;<br>  }<br>  break;</p>
<p> case EV_FF:<br>  if (value &gt;= 0)<br>   disposition = INPUT_PASS_TO_ALL;<br>  break;</p>
<p> case EV_PWR:<br>  disposition = INPUT_PASS_TO_ALL;<br>  break;<br> }</p>
<p> if (disposition != INPUT_IGNORE_EVENT &amp;&amp; type != EV_SYN)<br>  dev-&gt;sync = 0;</p>
<p> if ((disposition &amp; INPUT_PASS_TO_DEVICE) &amp;&amp; dev-&gt;event)<br>  dev-&gt;event(dev, type, code, value);</p>
<p> if (disposition &amp; INPUT_PASS_TO_HANDLERS)<br>  input_pass_event(dev, type, code, value);<br>}</p>
<p>input_handle_event最终调用：input_pass_event</p>
<p>static void input_pass_event(struct input_dev *dev,<br>        unsigned int type, unsigned int code, int value)<br>{<br> struct input_handle *handle;</p>
<p> rcu_read_lock();</p>
<p> handle = rcu_dereference(dev-&gt;grab);<br> /<em>最终调用handler的event函数</em>/<br> if (handle)<br>  handle-&gt;handler-&gt;event(handle, type, code, value);<br> else<br>  list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node)<br>   if (handle-&gt;open)<br>    handle-&gt;handler-&gt;event(handle,<br>       type, code, value);<br> rcu_read_unlock();<br>}</p>
<p>input_pass_event再调用evdev_event</p>
<p>static void evdev_event(struct input_handle *handle,<br>   unsigned int type, unsigned int code, int value)<br>{<br> struct evdev *evdev = handle-&gt;private;<br> struct evdev_client *client;<br> struct input_event event;</p>
<p> do_gettimeofday(&amp;event.time);<br> /<em>将按键信息存于event结构</em>/<br> event.type = type;<br> event.code = code;<br> event.value = value;</p>
<p> rcu_read_lock();<br> /<em>获得client结构</em>/<br> client = rcu_dereference(evdev-&gt;grab);<br> if (client)<br>  evdev_pass_event(client, &amp;event);<br> else<br>  list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)<br>   evdev_pass_event(client, &amp;event);</p>
<p> rcu_read_unlock();</p>
<p> wake_up_interruptible(&amp;evdev-&gt;wait);<br>}</p>
<p>evdev_event会调用evdev_pass_event函数：</p>
<p>static void evdev_pass_event(struct evdev_client <em>client,<br>        struct input_event <em>event)<br>{<br> /</em><br>  * Interrupts are disabled, just acquire the lock<br>  */<br> spin_lock(&amp;client-&gt;buffer_lock);<br> /<em>将事件结构存在buffer中并且head加一</em>/<br> client-&gt;buffer[client-&gt;head++] = *event;<br> /*溢出处理</em>/<br> client-&gt;head &amp;= EVDEV_BUFFER_SIZE - 1;<br> spin_unlock(&amp;client-&gt;buffer_lock);</p>
<p> kill_fasync(&amp;client-&gt;fasync, SIGIO, POLL_IN);<br>}</p>
<p>从evdev_pass_event函数我们可以得到：将事件结构存在buffe,client的head指针加一，那么head加一之后，也就是报告键值完毕了，回到了evdev_read函数中：此时的head是不等于tail的，所以唤醒等待队列：</p>
<p>下面就会执行evdev_read的evdev_fetch_next_event函数：</p>
<p>static int evdev_fetch_next_event(struct evdev_client *client,</p>
<p>  struct input_event *event)</p>
<p>{</p>
<p>int have_event;</p>
<p>spin_lock_irq(&amp;client-&gt;buffer_lock);</p>
<p>have_event = client-&gt;head != client-&gt;tail;</p>
<p>if (have_event) {</p>
<p>/<em>获取事件指针并且tail加一</em>/</p>
<p>*event = client-&gt;buffer[client-&gt;tail++];</p>
<p>/<em>溢出处理</em>/</p>
<p>client-&gt;tail &amp;= EVDEV_BUFFER_SIZE - 1;</p>
<p>}</p>
<p>spin_unlock_irq(&amp;client-&gt;buffer_lock);</p>
<p>return have_event;</p>
<p>}</p>
<p>evdev_fetch_next_event将client的尾节点加一(这时候head和tail又相等了)。</p>
<p>随后evdev_read调用input_event_to_user</p>
<p>int input_event_to_user(char __user *buffer,<br>   const struct input_event *event)<br>{<br> if (copy_to_user(buffer, event, sizeof(struct input_event)))<br>  return -EFAULT;</p>
<p> return 0;<br>}</p>
<p>这样就将按键事件结构event传递到了用户空间。</p>
<p>总结：由上我们看出，input子系统的确是很复杂的。下面画一个简单的流程图。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>锁屏界面</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E9%94%81%E5%B1%8F%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>禁止系统锁界面</p>
<p>&lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot;/&gt;</p>
<p>mKeyguardManager = (KeyguardManager)Class.this.getSystemService(Context.KEYGUARD_SERVICE);  </p>
<p>        mKeyguardLock = mKeyguardManager.newKeyguardLock(&quot;my_lockscreen&quot;);   </p>
<p>        mKeyguardLock.disableKeyguard();  </p>
<p>PhoneWindowManager.java中的interceptKeyBeforeDispatching</p>
<p>final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;  </p>
<p>for (int i=0; i&lt;typeCount; i++) {  </p>
<p>if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {  </p>
<p>// don’t do anything, but also don’t pass it to the app  </p>
<p>return -1;  </p>
<p>                    }  </p>
<p>                }  </p>
<p>看注释：如果设置了这两个属性的其中一个，就不做任何处理，home键不对这个app生效；</p>
<p>而WINDOW_TYPES_WHERE_HOME_DOESNT_WORK数据的定义如下：</p>
<p>private static final int[] WINDOW_TYPES_WHERE_HOME_DOESNT_WORK = {  </p>
<p>            WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,  </p>
<p>            WindowManager.LayoutParams.TYPE_SYSTEM_ERROR,  </p>
<p>        };  </p>
<p>在这个界面长按power键，关机界面也弹不出来了</p>
<p>在app 的你要屏蔽home 键的activity 中，只需要添加该标志就可以了  </p>
<p>this.getWindow().setFlags(FLAG_HOMEKEY_DISPATCHED, FLAG_HOMEKEY_DISPATCHED);  </p>
<p>如果要使home 键有效，再 clearFlags 即可。  </p>
<p>getWindow().clearFlags(WindowManager.LayoutParams.FLAG_HOMEKEY_DISPATCHED);  </p>
<p>注意：以上代码要加在setContentView（）之前才行；</p>
<p>这个代码来源于PhoneWindowManager.java这个类的interceptKeyBeforeDispatching（）方法中，</p>
<p>if ((flag &amp; WindowManager.LayoutParams.FLAG_HOMEKEY_DISPATCHED) != 0) {  </p>
<p>                   // the window wants to handle the home key, so dispatch it to it.  </p>
<p>                   return 0;  </p>
<p>               }      </p>
<p>这样设置，有的同学感觉好用，有的同学感觉不好用；</p>
<p>原因：android4.0的源码的PhoneWindowManager.java没有添加上述代码，所以不起作用，</p>
<p>而4.1的源码PhoneWindowManager.java中有这个代码，所以好用，这个请大家看看对应的源码是否有上述代码；</p>
<p>4.2 锁界面</p>
<p>frameworks/base/core/res/res/values/arrays.xml</p>
<p> &lt;array name=&quot;lockscreen_targets_when_soundon&quot;&gt;</p>
<p>        &lt;item&gt;@drawable/ic_lockscreen_unlock&lt;/item&gt;</p>
<p>        &lt;item&gt;@drawable/ic_action_assist_generic&lt;/item&gt;</p>
<p>        &lt;item&gt;@drawable/ic_lockscreen_silent&lt;/item&gt;</p>
<p>        &lt;item&gt;@null&lt;/item&gt;</p>
<p>    &lt;/array&gt;</p>
<p>    &lt;array name=&quot;lockscreen_targets_with_camera&quot;&gt;</p>
<p>        &lt;item&gt;@drawable/ic_lockscreen_unlock&lt;/item&gt;</p>
<p>        &lt;item&gt;@drawable/ic_action_assist_generic&lt;/item&gt;</p>
<p>        &lt;item&gt;@drawable/ic_lockscreen_camera&lt;/item&gt;</p>
<p>        &lt;item&gt;@null&lt;/item&gt;</p>
<p>    &lt;/array&gt;</p>
<p>    &lt;array name=&quot;lockscreen_targets_unlock_only&quot;&gt;</p>
<p>        &lt;item&gt;@*android:drawable/ic_lockscreen_unlock&lt;/item&gt;</p>
<p>    &lt;/array&gt;</p>
<p>frameworks/base/core/res/res/layout/keyguard_glow_pad_view.xml</p>
<p>prvandroid:targetDrawables=&quot;@array/lockscreen_targets_unlock_only&quot;</p>
<p>这个圆形的解锁界面，左边是照相机，右边是解锁。下面我们来说说这个功能的具体实现，以及怎么修改成为上下左右四个方向的解锁界面。</p>
<p>Step1：先看LockScreen.java这个类加载的布局</p>
<p>[java] view plaincopyprint?</p>
<p>inflater.inflate(R.layout.keyguard_screen_tab_unlock, this, true);  </p>
<p>然后看对应的布局文件：</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;com.android.internal.widget.multiwaveview.MultiWaveView  </p>
<p>android:id=&quot;@+id/unlock_widget&quot;  </p>
<p>android:orientation=&quot;horizontal&quot;  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;match_parent&quot;  </p>
<p>android:layout_alignParentBottom=&quot;true&quot;  </p>
<p>android:targetDrawables=&quot;@array/lockscreen_targets_with_camera&quot;  </p>
<p>android:targetDescriptions=&quot;@array/lockscreen_target_descriptions_with_camera&quot;  </p>
<p>android:directionDescriptions=&quot;@array/lockscreen_direction_descriptions&quot;  </p>
<p>android:handleDrawable=&quot;@drawable/ic_lockscreen_handle&quot;  </p>
<p>android:waveDrawable=&quot;@drawable/ic_lockscreen_outerring&quot;  </p>
<p>android:outerRadius=&quot;@dimen/multiwaveview_target_placement_radius&quot;  </p>
<p>android:snapMargin=&quot;@dimen/multiwaveview_snap_margin&quot;  </p>
<p>android:hitRadius=&quot;@dimen/multiwaveview_hit_radius&quot;  </p>
<p>android:rightChevronDrawable=&quot;@drawable/ic_lockscreen_chevron_right&quot;  </p>
<p>android:horizontalOffset=&quot;0dip&quot;  </p>
<p>android:verticalOffset=&quot;60dip&quot;  </p>
<p>android:feedbackCount=&quot;3&quot;  </p>
<p>android:vibrationDuration=&quot;20&quot;  </p>
<p>/&gt;  </p>
<p>下面我们来细细研究这些属性的含义：</p>
<p>        空行上面的属性都是android常用的一些属性，相信不用我说了；</p>
<p>   (1) android:targetDrawables=&quot;@array/lockscreen_targets_with_camera&quot;</p>
<p>        这个属性表示目标的图标有几个，android默认是2个，不过我们可以修改这个array的值，我们看看这个值</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;array name=&quot;lockscreen_targets_with_camera&quot;&gt;  </p>
<p>&lt;item&gt;@drawable/ic_lockscreen_unlock&lt;/item&gt;  </p>
<p>&lt;item&gt;@null&lt;/item&gt;  </p>
<p>&lt;item&gt;@drawable/ic_lockscreen_camera&lt;/item&gt;  </p>
<p>&lt;item&gt;@null&lt;/item&gt;  </p>
<p>&lt;/array&gt;  </p>
<p>        我相信你这样表示就应该明白该怎么修改了，这四个item分别对应圆圈的位置是右，上，左，下。</p>
<p>        想加几个图片，这个完全取决你自己，像小米的锁屏是四个，就是修改的这里。其实也没什么的，so easy！</p>
<p>  (2) android:targetDescriptions=&quot;@array/lockscreen_target_descriptions_with_camera&quot;</p>
<p>        这个属性是对应的描述语言，</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;array name=&quot;lockscreen_target_descriptions_with_camera&quot;&gt;  </p>
<p>&lt;item&gt;@string/description_target_unlock&lt;/item&gt;  </p>
<p>&lt;item&gt;@null&lt;/item&gt;  </p>
<p>&lt;item&gt;@string/description_target_camera&lt;/item&gt;  </p>
<p>&lt;item&gt;@null&lt;/item&gt;  </p>
<p>&lt;/array&gt;  </p>
<p>        你要是修改（1）的话，你也就相应的修改这些字符串就可以了。这个没什么可说的了。</p>
<p>  (3) android:directionDescriptions=&quot;@array/lockscreen_direction_descriptions&quot;</p>
<p>       这个属性和（2）差不多，</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;array name=&quot;lockscreen_direction_descriptions&quot;&gt;  </p>
<p>&lt;item&gt;@string/description_direction_right&lt;/item&gt;  </p>
<p>&lt;item&gt;@null&lt;/item&gt;  </p>
<p>&lt;item&gt;@string/description_direction_left&lt;/item&gt;  </p>
<p>&lt;item&gt;@null&lt;/item&gt;  </p>
<p>&lt;/array&gt;  </p>
<p>       这个表示的含义就是：对应四个位置，右，上，左，下这四个位置，提示语言：向哪个方向滑的问题。</p>
<p>  (4) android:handleDrawable=&quot;@drawable/ic_lockscreen_handle&quot;<br>       这个属性对应的就是中间的那个解锁的图标，对应2张图片，一张选中的图片，一张默认没有选中的图片。</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;selector xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;&gt;  </p>
<p>&lt;item  </p>
<p>android:state_enabled=&quot;true&quot;  </p>
<p>android:state_active=&quot;false&quot;  </p>
<p>android:state_focused=&quot;false&quot;  </p>
<p>android:drawable=&quot;@drawable/ic_lockscreen_handle_normal&quot; /&gt;  </p>
<p>&lt;item  </p>
<p>android:state_enabled=&quot;true&quot;  </p>
<p>android:state_active=&quot;true&quot;  </p>
<p>android:state_focused=&quot;false&quot;  </p>
<p>android:drawable=&quot;@drawable/ic_lockscreen_handle_pressed&quot; /&gt;  </p>
<p>&lt;/selector&gt;  </p>
<p>  (5) android:waveDrawable=&quot;@drawable/ic_lockscreen_outerring&quot;</p>
<p>       这个属性对应的就是最外面的圆圈，是用shape属性画出来的。如：</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;shape xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;  </p>
<p>android:shape=&quot;oval&quot;  </p>
<p>&gt;  </p>
<p>&lt;size android:height=&quot;@dimen/keyguard_lockscreen_outerring_diameter&quot; android:width=&quot;@dimen/keyguard_lockscreen_outerring_diameter&quot; /&gt;  </p>
<p>&lt;solid android:color=&quot;#00000000&quot; /&gt;  </p>
<p>&lt;stroke android:color=&quot;#1affffff&quot; android:width=&quot;2dp&quot; /&gt;  </p>
<p>&lt;/shape&gt;  </p>
<p>         以上的这些值都可以修改的。</p>
<p>  (6) android:outerRadius=&quot;@dimen/multiwaveview_target_placement_radius&quot;</p>
<p>       这个属性表示默认圆的半径的大小；</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;!– Default target placement radius for MultiWaveView –&gt;  </p>
<p>&lt;dimen name=&quot;multiwaveview_target_placement_radius&quot;&gt;135dip&lt;/dimen&gt;  </p>
<p>  (7) android:snapMargin=&quot;@dimen/multiwaveview_snap_margin&quot;</p>
<p>       这个属性是默认超越MultiWaveView捕捉到目标半径距离  </p>
<p>[html] view plaincopyprint?</p>
<p>&lt;!– Default distance beyond which MultiWaveView snaps to the target radius –&gt;  </p>
<p>&lt;dimen name=&quot;multiwaveview_snap_margin&quot;&gt;20dip&lt;/dimen&gt;  </p>
<p>  (8) android:hitRadius=&quot;@dimen/multiwaveview_hit_radius&quot;</p>
<p>      这个属性表示：每个单元目标预设距离，MultiWaveView认为选中</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;!– Default distance from each snap target that MultiWaveView considers a &quot;hit&quot; –&gt;  </p>
<p>&lt;dimen name=&quot;multiwaveview_hit_radius&quot;&gt;60dip&lt;/dimen&gt;  </p>
<p>  (9)android:rightChevronDrawable=&quot;@drawable/ic_lockscreen_chevron_right&quot;</p>
<p>     这个属性表示：动态画的波纹的图片，这个属性共有四个，分别为，左，上，右，下四个方位的。</p>
<p>  (10) android:horizontalOffset=&quot;0dip&quot;<br>         android:verticalOffset=&quot;60dip&quot;</p>
<p>        这2个属性表示：距离圆圈水平和垂直的距离。你就明白为什么圆的下方少一块的原因了。</p>
<p>  (11) android:feedbackCount=&quot;3&quot;</p>
<p>         表示：反馈数量3个；</p>
<p>  (12) android:vibrationDuration=&quot;20&quot;</p>
<p>          表示：默认震动的时间，20毫秒；</p>
<p>更多属性请参考：core/res/res/values/attrs.xml中</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;!– =============================== –&gt;  </p>
<p>&lt;!– MultiWaveView class attributes –&gt;  </p>
<p>&lt;!– =============================== –&gt;  </p>
<p>&lt;eat-comment /&gt;  </p>
<p>&lt;declare-styleable name=&quot;MultiWaveView&quot;&gt;  </p>
<p>&lt;!– Reference to an array resource that be shown as targets around a circle. –&gt;  </p>
<p>&lt;attr name=&quot;targetDrawables&quot; format=&quot;reference&quot;/&gt;  </p>
<p>&lt;!– Reference to an array resource that be used as description for the targets around the circle. –&gt;  </p>
<p>&lt;attr name=&quot;targetDescriptions&quot; format=&quot;reference&quot;/&gt;  </p>
<p>&lt;!– Reference to an array resource that be used to announce the directions with targets around the circle. –&gt;  </p>
<p>&lt;attr name=&quot;directionDescriptions&quot; format=&quot;reference&quot;/&gt;  </p>
<p>&lt;!– Sets a drawable as the drag center. –&gt;  </p>
<p>&lt;attr name=&quot;handleDrawable&quot; format=&quot;reference&quot; /&gt;  </p>
<p>&lt;!– Drawable to use for chevron animation on the left. May be null. –&gt;  </p>
<p>&lt;attr name=&quot;leftChevronDrawable&quot; format=&quot;reference&quot; /&gt;  </p>
<p>&lt;!– Drawable to use for chevron animation on the right. May be null. –&gt;  </p>
<p>&lt;attr name=&quot;rightChevronDrawable&quot; format=&quot;reference&quot; /&gt;  </p>
<p>&lt;!– Drawable to use for chevron animation on the top. May be null. –&gt;  </p>
<p>&lt;attr name=&quot;topChevronDrawable&quot; format=&quot;reference&quot; /&gt;  </p>
<p>&lt;!– Drawable to use for chevron animation on the bottom. May be null. –&gt;  </p>
<p>&lt;attr name=&quot;bottomChevronDrawable&quot; format=&quot;reference&quot; /&gt;  </p>
<p>&lt;!– Drawable to use for wave ripple animation. –&gt;  </p>
<p>&lt;attr name=&quot;waveDrawable&quot; format=&quot;reference&quot; /&gt;  </p>
<p>&lt;!– Outer radius of target circle. Icons will be drawn on this circle. –&gt;  </p>
<p>&lt;attr name=&quot;outerRadius&quot; format=&quot;dimension&quot; /&gt;  </p>
<p>&lt;!– Size of target radius. Points within this distance of target center is a &quot;hit&quot;. –&gt;  </p>
<p>&lt;attr name=&quot;hitRadius&quot; format=&quot;dimension&quot; /&gt;  </p>
<p>&lt;!– Tactile feedback duration for actions. Set to ‘0’ for no vibration. –&gt;  </p>
<p>&lt;attr name=&quot;vibrationDuration&quot; format=&quot;integer&quot;/&gt;  </p>
<p>&lt;!– How close we need to be before snapping to a target. –&gt;  </p>
<p>&lt;attr name=&quot;snapMargin&quot; format=&quot;dimension&quot; /&gt;  </p>
<p>&lt;!– Number of waves/chevrons to show in animation. –&gt;  </p>
<p>&lt;attr name=&quot;feedbackCount&quot; format=&quot;integer&quot; /&gt;  </p>
<p>&lt;!– Used to shift center of pattern vertically. –&gt;  </p>
<p>&lt;attr name=&quot;verticalOffset&quot; format=&quot;dimension&quot; /&gt;  </p>
<p>&lt;!– Used to shift center of pattern horizontally. –&gt;  </p>
<p>&lt;attr name=&quot;horizontalOffset&quot; format=&quot;dimension&quot; /&gt;  </p>
<p>&lt;/declare-styleable&gt;  </p>
<p>这些属性能帮助你自定义自己的锁屏，如果不够的话，你也可以自己添加，然后在MultiWaveView.java中添加自己的方法或属性。</p>
<p>我们来说说Android4.2锁屏的流程：咱们一步一步来说：</p>
<p>Step1：先看第一次开机的加载锁屏的过程，通过PhoneWindowManager.java这个类的systemReady（）这个方法，当系统开机准备好的情况下会调用这个方法，如下：</p>
<p>[java] view plaincopyprint?</p>
<p>public void systemReady() {  </p>
<p>if (mKeyguardMediator != null) {  </p>
<p>// tell the keyguard  </p>
<p>           mKeyguardMediator.onSystemReady();  </p>
<p>       }  </p>
<p>synchronized (mLock) {  </p>
<p>           updateOrientationListenerLp();  </p>
<p>           mSystemReady = true;  </p>
<p>           mHandler.post(new Runnable() {  </p>
<p>public void run() {  </p>
<p>                   updateSettings();  </p>
<p>               }  </p>
<p>           });  </p>
<p>       }  </p>
<p>   }  </p>
<p>Step2：看注释就知道下一步该干什么了，告诉锁屏的管理者，我准备好了，该你来控制加载锁屏界面了。接着调用到了KeyguardViewMediator.java这个类的onSystemReady（）方法，如下：</p>
<p>[java] view plaincopyprint?</p>
<p>/** </p>
<p>     * Let us know that the system is ready after startup. </p>
<p>     */  </p>
<p>public void onSystemReady() {  </p>
<p>        mSearchManager = (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);  </p>
<p>synchronized (this) {  </p>
<p>if (DEBUG) Log.d(TAG, &quot;onSystemReady&quot;);  </p>
<p>            mSystemReady = true;  </p>
<p>            mUpdateMonitor.registerCallback(mUpdateCallback);  </p>
<p>// Suppress biometric unlock right after boot until things have settled if it is the  </p>
<p>// selected security method, otherwise unsuppress it.  It must be unsuppressed if it is  </p>
<p>// not the selected security method for the following reason:  if the user starts  </p>
<p>// without a screen lock selected, the biometric unlock would be suppressed the first  </p>
<p>// time they try to use it.  </p>
<p>//  </p>
<p>// Note that the biometric unlock will still not show if it is not the selected method.  </p>
<p>// Calling setAlternateUnlockEnabled(true) simply says don’t suppress it if it is the  </p>
<p>// selected method.  </p>
<p>if (mLockPatternUtils.usingBiometricWeak()  </p>
<p>                    &amp;&amp; mLockPatternUtils.isBiometricWeakInstalled()  </p>
<p>                    || mLockPatternUtils.usingVoiceWeak()  </p>
<p>                    &amp;&amp; FeatureOption.MTK_VOICE_UNLOCK_SUPPORT) {  </p>
<p>if (DEBUG) Log.d(TAG, &quot;suppressing biometric unlock during boot&quot;);  </p>
<p>                mUpdateMonitor.setAlternateUnlockEnabled(false);  </p>
<p>            } else {  </p>
<p>                mUpdateMonitor.setAlternateUnlockEnabled(true);  </p>
<p>            }  </p>
<p>/// M: power-off alarm @{  </p>
<p>if (!KeyguardUpdateMonitor.isAlarmBoot()) {  </p>
<p>                doKeyguardLocked();  </p>
<p>            }  </p>
<p>/// @}  </p>
<p>        }  </p>
<p>// Most services aren’t available until the system reaches the ready state, so we  </p>
<p>// send it here when the device first boots.  </p>
<p>        maybeSendUserPresentBroadcast();  </p>
<p>    }  </p>
<p>Step3：接着由doKeyguardLocked（）这个方法来做启动锁屏界面的预处理，来看看这个方法都做了什么：</p>
<p>[java] view plaincopyprint?</p>
<p>private void doKeyguardLocked() {  </p>
<p>    doKeyguardLocked(null);  </p>
<p>}  </p>
<p>/** </p>
<p> * Enable the keyguard if the settings are appropriate. </p>
<p> */  </p>
<p>private void doKeyguardLocked(Bundle options) {  </p>
<p>// if another app is disabling us, don’t show  </p>
<p>if (!mExternallyEnabled || KeyguardUpdateMonitor.isAlarmBoot()) {  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;doKeyguard: not showing because externally disabled&quot;);  </p>
<p>// note: we <em>should</em> set mNeedToReshowWhenReenabled=true here, but that makes  </p>
<p>// for an occasional ugly flicker in this situation:  </p>
<p>// 1) receive a call with the screen on (no keyguard) or make a call  </p>
<p>// 2) screen times out  </p>
<p>// 3) user hits key to turn screen back on  </p>
<p>// instead, we reenable the keyguard when we know the screen is off and the call  </p>
<p>// ends (see the broadcast receiver below)  </p>
<p>// TODO: clean this up when we have better support at the window manager level  </p>
<p>// for apps that wish to be on top of the keyguard  </p>
<p>return;  </p>
<p>    }  </p>
<p>// if the keyguard is already showing, don’t bother  </p>
<p>if (mKeyguardViewManager.isShowing()) {  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;doKeyguard: not showing because it is already showing&quot;);  </p>
<p>return;  </p>
<p>    }  </p>
<p>// if the setup wizard hasn’t run yet, don’t show  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;doKeyguard: get keyguard.no_require_sim property before&quot;);  </p>
<p>final boolean requireSim = !SystemProperties.getBoolean(&quot;keyguard.no_require_sim&quot;,  </p>
<p>false);  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;doKeyguard: get keyguard.no_require_sim property after&quot;);  </p>
<p>final boolean provisioned = mUpdateMonitor.isDeviceProvisioned();  </p>
<p>final IccCardConstants.State state = mUpdateMonitor.getSimState();  </p>
<p>boolean lockedOrMissing = false;  </p>
<p>/// M: Support GeminiPlus  </p>
<p>for (int i = PhoneConstants.GEMINI_SIM_1; i &lt;= KeyguardUtils.getMaxSimId(); i++) {  </p>
<p>        lockedOrMissing = (lockedOrMissing || isLockedOrMissingGemini(i, requireSim));  </p>
<p>if (lockedOrMissing) {  </p>
<p>break;  </p>
<p>        }  </p>
<p>    }  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;doKeyguard: get sim state after&quot;);  </p>
<p>/// M: MTK MOTA UPDATE when on ics2 keygaurd set none,update to JB,the keyguard will show LockScreen.  </p>
<p>/// MTK MOTA UPDATE when the phone first boot,check the settingDB mirged or not ,because mota update,  </p>
<p>/// the settingdb migrate slow than keygaurd(timing sequence problem) @{  </p>
<p>boolean keyguardDisable = false;  </p>
<p>/////*<strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong>TODO  </p>
<p>boolean motaUpdateFirst = true;//mLockPatternUtils.isDbMigrated();  </p>
<p>if (motaUpdateFirst) {  </p>
<p>/// DB mogi done  </p>
<p>        keyguardDisable = mLockPatternUtils.isLockScreenDisabled();  </p>
<p>    } else {  </p>
<p>/// DB not mogi  </p>
<p>final ContentResolver cr = mContext.getContentResolver();  </p>
<p>        String value = Settings.Secure.getString(cr, &quot;lockscreen.disabled&quot;);  </p>
<p>boolean booleanValue = false;  </p>
<p>if( null!=value ){  </p>
<p>            booleanValue = value.equals(&quot;1&quot;) ? true :false;  </p>
<p>        }  </p>
<p>        keyguardDisable = (!mLockPatternUtils.isSecure()) &amp;&amp; booleanValue;  </p>
<p>    }  </p>
<p>/// @}  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;doKeyguard: keyguardDisable query end&quot;);  </p>
<p>/// M: Add new condition DM lock is not true  </p>
<p>boolean dmLocked = KeyguardUpdateMonitor.getInstance(mContext).dmIsLocked();  </p>
<p>    KeyguardUtils.xlogD(TAG, &quot;lockedOrMissing is &quot; + lockedOrMissing + &quot;, requireSim=&quot; + requireSim  </p>
<p>        + &quot;, provisioned=&quot; + provisioned + &quot;, keyguardisable=&quot; + keyguardDisable + &quot;, dmLocked=&quot; + dmLocked);  </p>
<p>if (!lockedOrMissing &amp;&amp; !provisioned &amp;&amp; !dmLocked) {  </p>
<p>if (DEBUG) Log.d(TAG, &quot;doKeyguard: not showing because device isn’t provisioned&quot;  </p>
<p>                + &quot; and the sim is not locked or missing&quot;);  </p>
<p>return;  </p>
<p>    }  </p>
<p>/// M: Add a new condition DM lock is not on, or user can still bypass dm lock when Keygaurd is disabled  </p>
<p>if (mUserManager.getUsers(true).size() &lt; 2  </p>
<p>            &amp;&amp; keyguardDisable &amp;&amp; !lockedOrMissing &amp;&amp; !KeyguardUpdateMonitor.getInstance(mContext).dmIsLocked()) {  </p>
<p>if (DEBUG) Log.d(TAG, &quot;doKeyguard: not showing because lockscreen is off&quot;);  </p>
<p>return;  </p>
<p>    }  </p>
<p>if (DEBUG) Log.d(TAG, &quot;doKeyguard: showing the lock screen&quot;);  </p>
<p>    showLocked(options);  </p>
<p>}  </p>
<p>Step4、来注意最后调用的这个方法showLocked(options),这个方法是启动锁屏关键的方法，来看看：</p>
<p>[java] view plaincopyprint?</p>
<p>/** </p>
<p>    * Send message to keyguard telling it to show itself </p>
<p>    * @see #handleShow() </p>
<p>    */  </p>
<p>private void showLocked(Bundle options) {  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;showLocked&quot;);  </p>
<p>// ensure we stay awake until we are finished displaying the keyguard  </p>
<p>       mShowKeyguardWakeLock.acquire();  </p>
<p>       Message msg = mHandler.obtainMessage(SHOW, options);  </p>
<p>       mHandler.sendMessage(msg);  </p>
<p>   }  </p>
<p>Step5、这下就通过发送消息来进一步启动锁屏界面，来看看这个mHandler中的SHOW都做了什么：</p>
<p>[java] view plaincopyprint?</p>
<p>public void handleMessage(Message msg) {  </p>
<p>if (DBG_MESSAGE) KeyguardUtils.xlogD(TAG, &quot;handleMessage enter msg name=&quot; + getMessageString(msg));  </p>
<p>switch (msg.what) {  </p>
<p>case SHOW:  </p>
<p>                    handleShow((Bundle) msg.obj);  </p>
<p>break;  </p>
<p>调用的是handleShow()这个方法：</p>
<p>[java] view plaincopyprint?</p>
<p>/** </p>
<p>     * Handle message sent by {@link #showLocked}. </p>
<p>     * @see #SHOW </p>
<p>     */  </p>
<p>private void handleShow(Bundle options) {  </p>
<p>synchronized (KeyguardViewMediator.this) {  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;handleShow enter&quot;);  </p>
<p>if (!mSystemReady) return;  </p>
<p>/// M: if already showing, just return  </p>
<p>if (mShowing) return;  </p>
<p>            mKeyguardViewManager.show(options);  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;handleShow mKeyguardViewManager Show exit&quot;);  </p>
<p>            mShowing = true;  </p>
<p>            mKeyguardDonePending = false;  </p>
<p>            updateActivityLockScreenState();  </p>
<p>            adjustStatusBarLocked();  </p>
<p>            userActivity();  </p>
<p>try {  </p>
<p>                ActivityManagerNative.getDefault().closeSystemDialogs(&quot;lock&quot;);  </p>
<p>            } catch (RemoteException e) {  </p>
<p>            }  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;handleShow query AlarmBoot before&quot;);  </p>
<p>// Do this at the end to not slow down display of the keyguard.  </p>
<p>if (!KeyguardUpdateMonitor.isAlarmBoot()) {  </p>
<p>                playSounds(true);  </p>
<p>            } else {  </p>
<p>new Handler().postDelayed(new Runnable() {  </p>
<p>public void run() {  </p>
<p>                        sendRemoveIPOWinBroadcast();  </p>
<p>                        startAlarm();  </p>
<p>                    }  </p>
<p>                }, 250);  </p>
<p>            }  </p>
<p>            mShowKeyguardWakeLock.release();  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;handleShow exit&quot;);  </p>
<p>        }  </p>
<p>    }  </p>
<p>Step6、接着看mKeyguardViewManager.show(options);这个方法都干了什么：</p>
<p>[java] view plaincopyprint?</p>
<p>/** </p>
<p>    * Show the keyguard.  Will handle creating and attaching to the view manager </p>
<p>    * lazily. </p>
<p>    */  </p>
<p>public synchronized void show(Bundle options) {  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;show(); mKeyguardView=&quot; + mKeyguardView);  </p>
<p>boolean enableScreenRotation = shouldEnableScreenRotation();  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;show() query screen rotation after&quot;);  </p>
<p>/// M: Incoming Indicator for Keyguard Rotation @{  </p>
<p>       KeyguardUpdateMonitor.getInstance(mContext).setQueryBaseTime();  </p>
<p>/// @}  </p>
<p>       maybeCreateKeyguardLocked(enableScreenRotation, false, options);  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;show() maybeCreateKeyguardLocked finish&quot;);  </p>
<p>       maybeEnableScreenRotation(enableScreenRotation);  </p>
<p>// Disable common aspects of the system/status/navigation bars that are not appropriate or  </p>
<p>// useful on any keyguard screen but can be re-shown by dialogs or SHOW_WHEN_LOCKED  </p>
<p>// activities. Other disabled bits are handled by the KeyguardViewMediator talking  </p>
<p>// directly to the status bar service.  </p>
<p>final int visFlags = View.STATUS_BAR_DISABLE_HOME;  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;show:setSystemUiVisibility(&quot; + Integer.toHexString(visFlags)+&quot;)&quot;);  </p>
<p>       mKeyguardHost.setSystemUiVisibility(visFlags);  </p>
<p>       mViewManager.updateViewLayout(mKeyguardHost, mWindowLayoutParams);  </p>
<p>       mKeyguardHost.setVisibility(View.VISIBLE);  </p>
<p>       mKeyguardView.show();  </p>
<p>       mKeyguardView.requestFocus();  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;show() exit; mKeyguardView=&quot; + mKeyguardView);  </p>
<p>   }  </p>
<p>Step7,、这下终于看到如山真面目了，看里面的方法maybeCreateKeyguardLocked（）这个是真正起作用的地方：</p>
<p>[java] view plaincopyprint?</p>
<p>&lt;span style=&quot;font-size:18px;&quot;&gt;private void maybeCreateKeyguardLocked(boolean enableScreenRotation, boolean force,  </p>
<p>            Bundle options) {  </p>
<p>final boolean isActivity = (mContext instanceof Activity); // for test activity  </p>
<p>if (mKeyguardHost != null) {  </p>
<p>            mKeyguardHost.saveHierarchyState(mStateContainer);  </p>
<p>        }  </p>
<p>if (mKeyguardHost == null) {  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;keyguard host is null, creating it…&quot;);  </p>
<p>            mKeyguardHost = new ViewManagerHost(mContext);  </p>
<p>int flags = WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN  </p>
<p>                    | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR  </p>
<p>                    | WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN  </p>
<p>                    | WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;  </p>
<p>/// M: Modify to support DM lock, hide statusbr when dm lock power on @{  </p>
<p>            KeyguardUpdateMonitor monitor = KeyguardUpdateMonitor.getInstance(mContext);  </p>
<p>if (monitor.dmIsLocked()) { //in the first created  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;show(); dmIsLocked &quot;);  </p>
<p>                flags &amp;= ~WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN;  </p>
<p>                flags |= WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;  </p>
<p>                flags |= WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;  </p>
<p>            } else if (KeyguardUpdateMonitor.isAlarmBoot()) {  </p>
<p>if (DEBUG) KeyguardUtils.xlogD(TAG, &quot;show(); AlarmBoot &quot;);  </p>
<p>                flags &amp;= ~WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;  </p>
<p>                flags &amp;= ~WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;  </p>
<p>                flags |= WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN;  </p>
<p>            }  </p>
<p>/// M: @}  </p>
<p>if (!mNeedsInput) {  </p>
<p>                flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;  </p>
<p>            }  </p>
<p>if (ActivityManager.isHighEndGfx()) {  </p>
<p>                flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;  </p>
<p>            }  </p>
<p>final int stretch = ViewGroup.LayoutParams.MATCH_PARENT;  </p>
<p>final int type = isActivity ? WindowManager.LayoutParams.TYPE_APPLICATION  </p>
<p>                    : WindowManager.LayoutParams.TYPE_KEYGUARD;  </p>
<p>            WindowManager.LayoutParams lp = new WindowManager.LayoutParams(  </p>
<p>                    stretch, stretch, type, flags, PixelFormat.TRANSLUCENT);  </p>
<p>            lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;  </p>
<p>            lp.windowAnimations = com.android.internal.R.style.Animation_LockScreen;  </p>
<p>if (ActivityManager.isHighEndGfx()) {  </p>
<p>                lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;  </p>
<p>                lp.privateFlags |=  </p>
<p>                        WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;  </p>
<p>            }  </p>
<p>            lp.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;  </p>
<p>if (isActivity) {  </p>
<p>                lp.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;  </p>
<p>            }  </p>
<p>/// M: Poke user activity when operating Keyguard  </p>
<p>//lp.inputFeatures |= WindowManager.LayoutParams.INPUT_FEATURE_DISABLE_USER_ACTIVITY;  </p>
<p>            lp.setTitle(isActivity ? &quot;KeyguardMock&quot; : &quot;Keyguard&quot;);  </p>
<p>            mWindowLayoutParams = lp;  </p>
<p>            mViewManager.addView(mKeyguardHost, lp);  </p>
<p>        }  </p>
<p>/// M: If force and keyguardView is not null, we should relase memory hold by old keyguardview  </p>
<p>if (force &amp;&amp; mKeyguardView != null) {  </p>
<p>            mKeyguardView.cleanUp();  </p>
<p>        }  </p>
<p>if (force || mKeyguardView == null) {  </p>
<p>            inflateKeyguardView(options);  </p>
<p>            mKeyguardView.requestFocus();  </p>
<p>        }  </p>
<p>        updateUserActivityTimeoutInWindowLayoutParams();  </p>
<p>        mViewManager.updateViewLayout(mKeyguardHost, mWindowLayoutParams);  </p>
<p>        mKeyguardHost.restoreHierarchyState(mStateContainer);  </p>
<p>    }&lt;/span&gt;  </p>
<p>这下通过 mViewManager.addView(mKeyguardHost, lp);这个方法真正地把锁屏界面添加到屏幕上，其实这个就是个view，挡在了手机的屏幕的最上方。而这个mKeyguardHost就是锁屏的根。而第一次加载的时候mKeyguardView为空，调用inflateKeyguardView（），初始化锁屏的view。</p>
<p>Step8、来看看这个inflateKeyguardView（）这个方法都加载了哪个布局：</p>
<p>[java] view plaincopyprint?</p>
<p>private void inflateKeyguardView(Bundle options) {  </p>
<p>/// M: add for power-off alarm @{  </p>
<p>int resId = R.id.keyguard_host_view;  </p>
<p>int layoutId = R.layout.keyguard_host_view;  </p>
<p>if(KeyguardUpdateMonitor.isAlarmBoot()){  </p>
<p>            layoutId = com.mediatek.internal.R.layout.power_off_alarm_host_view;  </p>
<p>            resId = com.mediatek.internal.R.id.keyguard_host_view;  </p>
<p>        }  </p>
<p>/// @}  </p>
<p>        View v = mKeyguardHost.findViewById(resId);  </p>
<p>if (v != null) {  </p>
<p>            mKeyguardHost.removeView(v);  </p>
<p>        }  </p>
<p>// TODO: Remove once b/7094175 is fixed  </p>
<p>if (false) Slog.d(TAG, &quot;inflateKeyguardView: b/7094175 mContext.config=&quot;  </p>
<p>                + mContext.getResources().getConfiguration());  </p>
<p>/// M: Save new orientation  </p>
<p>        mCreateOrientation = mContext.getResources().getConfiguration().orientation;  </p>
<p>final LayoutInflater inflater = LayoutInflater.from(mContext);  </p>
<p>        View view = inflater.inflate(layoutId, mKeyguardHost, true);  </p>
<p>        mKeyguardView = (KeyguardHostView) view.findViewById(resId);  </p>
<p>        mKeyguardView.setLockPatternUtils(mLockPatternUtils);  </p>
<p>        mKeyguardView.setViewMediatorCallback(mViewMediatorCallback);  </p>
<p>// HACK  </p>
<p>// The keyguard view will have set up window flags in onFinishInflate before we set  </p>
<p>// the view mediator callback. Make sure it knows the correct IME state.  </p>
<p>if (mViewMediatorCallback != null) {  </p>
<p>            KeyguardPasswordView kpv = (KeyguardPasswordView) mKeyguardView.findViewById(  </p>
<p>                    R.id.keyguard_password_view);  </p>
<p>if (kpv != null) {  </p>
<p>                mViewMediatorCallback.setNeedsInput(kpv.needsInput());  </p>
<p>            }  </p>
<p>        }  </p>
<p>/// Extract this block to a single function  </p>
<p>        updateKeyguardViewFromOptions(options);  </p>
<p>    }  </p>
<p>这个加载了keyguard_host_view这个layout，来看看这个布局是怎么写的：</p>
<p>[html] view plaincopyprint?</p>
<p>&lt;com.android.internal.policy.impl.keyguard.KeyguardHostView  </p>
<p>xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;  </p>
<p>xmlns:androidprv=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;  </p>
<p>android:id=&quot;@+id/keyguard_host_view&quot;  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;match_parent&quot;  </p>
<p>android:gravity=&quot;center_horizontal&quot;  </p>
<p>android:orientation=&quot;vertical&quot;&gt;  </p>
<p>&lt;com.android.internal.policy.impl.keyguard.SlidingChallengeLayout  </p>
<p>android:id=&quot;@+id/sliding_layout&quot;  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;match_parent&quot;&gt;  </p>
<p>&lt;FrameLayout  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;match_parent&quot;  </p>
<p>androidprv:layout_childType=&quot;mediatekLayerBackground&quot;&gt;  </p>
<p>&lt;/FrameLayout&gt;  </p>
<p>&lt;FrameLayout  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;wrap_content&quot;  </p>
<p>androidprv:layout_childType=&quot;pageDeleteDropTarget&quot;&gt;  </p>
<p>&lt;include layout=&quot;@layout/keyguard_widget_remove_drop_target&quot;  </p>
<p>android:id=&quot;@+id/keyguard_widget_pager_delete_target&quot;  </p>
<p>android:layout_width=&quot;wrap_content&quot;  </p>
<p>android:layout_height=&quot;wrap_content&quot;  </p>
<p>android:layout_gravity=&quot;top|center_horizontal&quot; /&gt;  </p>
<p>&lt;/FrameLayout&gt;  </p>
<p>&lt;FrameLayout  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;match_parent&quot;  </p>
<p>androidprv:layout_childType=&quot;widgets&quot;&gt;  </p>
<p>&lt;include layout=&quot;@layout/keyguard_widget_pager&quot;  </p>
<p>android:id=&quot;@+id/app_widget_container&quot;  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;match_parent&quot;  </p>
<p>android:layout_gravity=&quot;center&quot;/&gt;  </p>
<p>&lt;/FrameLayout&gt;  </p>
<p>&lt;View android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;match_parent&quot;  </p>
<p>androidprv:layout_childType=&quot;scrim&quot;  </p>
<p>android:background=&quot;#99000000&quot; /&gt;  </p>
<p>&lt;FrameLayout  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;match_parent&quot;  </p>
<p>androidprv:layout_childType=&quot;mediatekLayerForeground&quot;&gt;  </p>
<p>&lt;/FrameLayout&gt;  </p>
<p>&lt;com.android.internal.policy.impl.keyguard.KeyguardSecurityContainer  </p>
<p>android:id=&quot;@+id/keyguard_security_container&quot;  </p>
<p>android:layout_width=&quot;wrap_content&quot;  </p>
<p>android:layout_height=&quot;wrap_content&quot;  </p>
<p>android:layout_maxHeight=&quot;@dimen/keyguard_security_height&quot;  </p>
<p>androidprv:layout_childType=&quot;challenge&quot;  </p>
<p>android:padding=&quot;0dp&quot;  </p>
<p>android:gravity=&quot;bottom|center_horizontal&quot;&gt;  </p>
<p>&lt;com.android.internal.policy.impl.keyguard.KeyguardSecurityViewFlipper  </p>
<p>android:id=&quot;@+id/view_flipper&quot;  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;match_parent&quot;  </p>
<p>android:clipToPadding=&quot;false&quot;  </p>
<p>android:paddingTop=&quot;@dimen/keyguard_security_view_margin&quot;  </p>
<p>android:gravity=&quot;center&quot;&gt;  </p>
<p>&lt;/com.android.internal.policy.impl.keyguard.KeyguardSecurityViewFlipper&gt;  </p>
<p>&lt;/com.android.internal.policy.impl.keyguard.KeyguardSecurityContainer&gt;  </p>
<p>&lt;ImageButton  </p>
<p>android:layout_width=&quot;match_parent&quot;  </p>
<p>android:layout_height=&quot;@dimen/kg_widget_pager_bottom_padding&quot;  </p>
<p>androidprv:layout_childType=&quot;expandChallengeHandle&quot;  </p>
<p>android:focusable=&quot;true&quot;  </p>
<p>android:background=&quot;@null&quot;  </p>
<p>android:src=&quot;@drawable/keyguard_expand_challenge_handle&quot;  </p>
<p>android:scaleType=&quot;center&quot;  </p>
<p>android:contentDescription=&quot;@string/keyguard_accessibility_expand_lock_area&quot; /&gt;  </p>
<p>&lt;/com.android.internal.policy.impl.keyguard.SlidingChallengeLayout&gt;  </p>
<p>&lt;/com.android.internal.policy.impl.keyguard.KeyguardHostView&gt;  </p>
<p>而这个KeyguardHostView.java就是锁屏的真正的处理的view，该添加什么样的锁屏，例如：PIN，Pattern，PUK，Password等等，都是由它来控制的，最后会调用到getLayoutIdFor（）这个方法，来启动那种锁屏界面，如下：</p>
<p>[java] view plaincopyprint?</p>
<p>private int getLayoutIdFor(SecurityMode securityMode) {  </p>
<p>switch (securityMode) {  </p>
<p>case None: return R.layout.keyguard_selector_view;  </p>
<p>case Pattern: return R.layout.keyguard_pattern_view;  </p>
<p>case PIN: return R.layout.keyguard_pin_view;  </p>
<p>case Password: return R.layout.keyguard_password_view;  </p>
<p>case Biometric: return R.layout.keyguard_face_unlock_view;  </p>
<p>case Account: return R.layout.keyguard_account_view;  </p>
<p>/// M: Modify Sim unlock layout @{  </p>
<p>//case SimPin: return R.layout.keyguard_sim_pin_view;  </p>
<p>//case SimPuk: return R.layout.keyguard_sim_puk_view;  </p>
<p>case SimPinPukMe1: return com.mediatek.internal.R.layout.keyguard_sim_pin_puk_view;  </p>
<p>case SimPinPukMe2: return com.mediatek.internal.R.layout.keyguard_sim_pin_puk_view;  </p>
<p>/// M: Support GeminiPlus  </p>
<p>case SimPinPukMe3: return com.mediatek.internal.R.layout.keyguard_sim_pin_puk_view;  </p>
<p>case SimPinPukMe4: return com.mediatek.internal.R.layout.keyguard_sim_pin_puk_view;  </p>
<p>/// @}  </p>
<p>/// M: power-off alarm @{  </p>
<p>case AlarmBoot: return com.mediatek.internal.R.layout.power_off_alarm_view;  </p>
<p>/// @}  </p>
<p>///M: add voice unlock view layout  </p>
<p>case Voice: return R.layout.zz_keyguard_voice_unlock_view;  </p>
<p>default:  </p>
<p>return 0;  </p>
<p>        }  </p>
<p>    }  </p>
<p>到这，锁屏已经初始化完了，要想下面接着分析，估计大家应该都能分析过去了；</p>
<p>特别说明：</p>
<p>1、加载锁屏widget的地方在KeyguardHostView.java的onFinishInflate()中，调用的addDefaultWidget()这个方法中添加了单click事件，最后调用到KeyguardActivityLauncher.java的launcherWidgetPicker()这个方法；</p>
<p>2、要想你写的widget能被锁屏widget过滤出来，只需要在wdget的xml中添加一个属性即可：</p>
<p>android:widgetCategory=&quot;home_screen|keyguard&quot;，这样你写的桌面widget，也能在锁屏wiget过滤出来，具体布局需要你微调下；</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>rk30_factory_adc_battery</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk30_factory_adc_battery.c/</url>
    <content><![CDATA[<p>/* drivers/power/rk30_adc_battery.c</p>
<p> *</p>
<p> * battery detect driver for the rk30 </p>
<p> *</p>
<p> * This software is licensed under the terms of the GNU General Public</p>
<p> * License version 2, as published by the Free Software Foundation, and</p>
<p> * may be copied, distributed, and modified under those terms.</p>
<p> *</p>
<p> * This program is distributed in the hope that it will be useful,</p>
<p> * but WITHOUT ANY WARRANTY; without even the implied warranty of</p>
<p> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</p>
<p> * GNU General Public License for more details.</p>
<p> *</p>
<p> */</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/err.h&gt;</p>
<p>#include &lt;linux/platform_device.h&gt;</p>
<p>#include &lt;linux/power_supply.h&gt;</p>
<p>#include &lt;linux/regulator/consumer.h&gt;</p>
<p>#include &lt;linux/types.h&gt;</p>
<p>#include &lt;linux/pci.h&gt;</p>
<p>#include &lt;linux/interrupt.h&gt;</p>
<p>#include &lt;asm/io.h&gt;</p>
<p>#include &lt;asm/mach-types.h&gt;</p>
<p>#include &lt;asm/mach/arch.h&gt;</p>
<p>#include &lt;asm/mach/map.h&gt;</p>
<p>#include &lt;mach/gpio.h&gt;</p>
<p>#include &lt;linux/adc.h&gt;</p>
<p>#include &lt;mach/iomux.h&gt;</p>
<p>#include &lt;mach/board.h&gt;</p>
<p>#include &lt;linux/delay.h&gt;</p>
<p>#include &lt;linux/ktime.h&gt;</p>
<p>#include &lt;linux/slab.h&gt;</p>
<p>#include &lt;linux/syscalls.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/wakelock.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/string.h&gt;</p>
<p>#include &lt;linux/init.h&gt;</p>
<p>#include &lt;linux/earlysuspend.h&gt;</p>
<p>#include &lt;linux/suspend.h&gt;</p>
<p>#ifdef CONFIG_EARLYSUSPEND</p>
<p>/* kernel/power/earlysuspend.c */</p>
<p>extern suspend_state_t get_suspend_state(void);</p>
<p>#endif</p>
<p>static int rk30_battery_dbg_level = 0;</p>
<p>module_param_named(dbg_level, rk30_battery_dbg_level, int, 0644);</p>
<p>#define DBG( args…) \</p>
<p>do { \</p>
<p>if (rk30_battery_dbg_level) { \</p>
<p>pr_info(args); \</p>
<p>} \</p>
<p>} while (0)</p>
<p>#define TIMER_MS_COUNTS  1000 </p>
<p>#define SLOPE_SECOND_COUNTS                15 </p>
<p>#define DISCHARGE_MIN_SECOND                35</p>
<p>#define CHARGE_MIN_SECOND                45 </p>
<p>#define CHARGE_MID_SECOND                90 </p>
<p>#define CHARGE_MAX_SECOND                250</p>
<p>#define   CHARGE_FULL_DELAY_TIMES          10     </p>
<p>#define   USBCHARGE_IDENTIFY_TIMES        2        </p>
<p>#define NUM_VOLTAGE_SAMPLE                        ((SLOPE_SECOND_COUNTS * 1000) / TIMER_MS_COUNTS)  </p>
<p>#define NUM_DISCHARGE_MIN_SAMPLE          ((DISCHARGE_MIN_SECOND * 1000) / TIMER_MS_COUNTS)  </p>
<p>#define NUM_CHARGE_MIN_SAMPLE          ((CHARGE_MIN_SECOND * 1000) / TIMER_MS_COUNTS)     </p>
<p>#define NUM_CHARGE_MID_SAMPLE          ((CHARGE_MID_SECOND * 1000) / TIMER_MS_COUNTS)      </p>
<p>#define NUM_CHARGE_MAX_SAMPLE          ((CHARGE_MAX_SECOND * 1000) / TIMER_MS_COUNTS)   </p>
<p>#define   NUM_CHARGE_FULL_DELAY_TIMES         ((CHARGE_FULL_DELAY_TIMES * 1000) / TIMER_MS_COUNTS) </p>
<p>#define   NUM_USBCHARGE_IDENTIFY_TIMES      ((USBCHARGE_IDENTIFY_TIMES * 1000) / TIMER_MS_COUNTS) </p>
<p>#define   CHARGE_IS_OK                                 1</p>
<p>#define   INVALID_CHARGE_CHECK               -1</p>
<p>#if defined(CONFIG_ARCH_RK3066B)</p>
<p>#define  BAT_DEFINE_VALUE                                      1800</p>
<p>#elif defined(CONFIG_ARCH_RK2928)</p>
<p>#define  BAT_DEFINE_VALUE                                         3300</p>
<p>#else</p>
<p>#define  BAT_DEFINE_VALUE                                      2500</p>
<p>#endif</p>
<p>#define BATTERY_APK </p>
<p>#ifdef  BATTERY_APK</p>
<p>#define BATT_NUM  11</p>
<p>int    battery_dbg_level = 0;</p>
<p>int    battery_test_flag = 0;</p>
<p>int    gVoltageCnt = 3400;</p>
<p>int    gDoubleVoltageCnt = 6800;</p>
<p>unsigned long gSecondsCnt = 0;</p>
<p>char gDischargeFlag[4] = {&quot;on &quot;};</p>
<p>#ifdef CONFIG_BATTERY_RK30_VOL3V8</p>
<p>#define BATT_MAX_VOL_VALUE                             4120               //Full  charge volate  </p>
<p>#define BATT_ZERO_VOL_VALUE                            3600//3500               //power down voltage</p>
<p>#define BATT_NOMAL_VOL_VALUE                         3800            </p>
<p>static int batt_table[2*BATT_NUM+6] =</p>
<p>{</p>
<p>0x4B434F52,0x7461625F,0x79726574,0,200,200,</p>
<p>3495, 3580, 3599, 3626, 3655, 3697, 3751, 3812, 3877, 3920, 4020,  //discharge</p>
<p>3600, 3800, 3842, 3861, 3915, 3980, 4041, 4060, 4080, 4100, 4150   //charge</p>
<p>};</p>
<p>#define adc_to_voltage(adc_val) ((adc_val * BAT_DEFINE_VALUE * (batt_table[4] +batt_table[5])) / (1024 *batt_table[5]))</p>
<p>#else</p>
<p>#define BATT_MAX_VOL_VALUE                              8284               //Full charge voltage</p>
<p>#define BATT_ZERO_VOL_VALUE                             6900             // power down voltage </p>
<p>#define BATT_NOMAL_VOL_VALUE                          7600                </p>
<p>static int batt_table[2*BATT_NUM+6] =</p>
<p>{</p>
<p>0x4B434F52,0x7461625F,0x79726574,1,300,100,</p>
<p>6800, 7242, 7332, 7404, 7470, 7520, 7610, 7744, 7848, 8016, 8284,//discharge</p>
<p>7630, 7754, 7852, 7908, 7956, 8024, 8112, 8220, 8306, 8318, 8328//charge</p>
<p>};</p>
<p>#define adc_to_voltage(adc_val) ((adc_val * BAT_DEFINE_VALUE * (batt_table[4] +batt_table[5])) / (1024 *batt_table[5]))</p>
<p>#endif</p>
<p>#endif</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>enum {</p>
<p>BATTERY_STATUS = 0,</p>
<p>BATTERY_HEALTH = 1,</p>
<p>BATTERY_PRESENT = 2,</p>
<p>BATTERY_CAPACITY = 3,</p>
<p>BATTERY_AC_ONLINE = 4,</p>
<p>BATTERY_STATUS_CHANGED = 5,</p>
<p>AC_STATUS_CHANGED = 6,</p>
<p>BATTERY_INT_STATUS = 7,</p>
<p>BATTERY_INT_ENABLE = 8,</p>
<p>};</p>
<p>typedef enum {</p>
<p>CHARGER_BATTERY = 0,</p>
<p>CHARGER_USB,</p>
<p>CHARGER_AC</p>
<p>} charger_type_t;</p>
<p>struct rk30_adc_battery_data {</p>
<p>int irq;</p>
<p>//struct timer_list       timer;</p>
<p>struct workqueue_struct *wq;</p>
<p>struct delayed_work    delay_work;</p>
<p>struct delayed_work    check_work;</p>
<p>struct work_struct    dcwakeup_work;</p>
<p>struct work_struct                   lowerpower_work;</p>
<p>bool                    resume;</p>
<p>struct rk30_adc_battery_platform_data *pdata;</p>
<p>struct adc_client       *client; </p>
<p>int                     adc_val;</p>
<p>int                     adc_samples[NUM_VOLTAGE_SAMPLE+2];</p>
<p>int                     bat_status;</p>
<p>int                     bat_status_cnt;</p>
<p>int                     bat_health;</p>
<p>int                     bat_present;</p>
<p>int                     bat_voltage;</p>
<p>int                     bat_capacity;</p>
<p>int                     bat_change;</p>
<p>int                     old_charge_level;</p>
<p>int                    *pSamples;</p>
<p>int                     gBatCapacityDisChargeCnt;</p>
<p>int                     gBatCapacityChargeCnt;</p>
<p>int                     gBatCapacityacChargeCnt;</p>
<p>int                     gBatCapacityusbChargeCnt ;</p>
<p>int           gBatCapacityusbdisChargeCnt;</p>
<p>int                  capacitytmp;</p>
<p>int                     suspend_capacity;</p>
<p>int                     gBatUsbChargeCnt;</p>
<p>int                     status_lock;</p>
<p>struct power_supply bat;</p>
<p>struct power_supply usb;</p>
<p>struct power_supply ac;</p>
<p>struct power_supply bk_bat;</p>
<p>int                     poweron_check;</p>
<p>int                     usb_charging;</p>
<p>int                     ac_charging;</p>
<p>int                  charge_check;</p>
<p>int    charge_level;</p>
<p>int                     charge_source_now;</p>
<p>int                     charge_soure_old;</p>
<p>int                     charge_start_capacity;</p>
<p>int                     charge_start_voltage;</p>
<p>int                     start_voltage_status;</p>
<p>int                     charge_up_proprotion;</p>
<p>int                     charge_down_proportion;</p>
<p>int                     voltage_to_local;</p>
<p>unsigned long        suspend_time;</p>
<p>unsigned long resume_time;</p>
<p>int                      adc_value;</p>
<p>int                     full_times;</p>
<p>int     charge_full_flag;</p>
<p>int                     stop_check;</p>
<p>struct notifier_block battery_nb;</p>
<p>int    lower_power_flag;</p>
<p>int     time_to_full;</p>
<p>int     is_data_dir;</p>
<p>};</p>
<p>static struct rk30_adc_battery_data *gBatteryData;</p>
<p>static struct wake_lock batt_wake_lock;</p>
<p>static struct wake_lock batt_wake_lock_detect_lowpower;</p>
<p>static struct wake_lock charge_display_lock;</p>
<p>int system_lowerpower = 0;</p>
<p>extern void kernel_power_off(void);</p>
<p>extern int dwc_vbus_status(void);</p>
<p>extern int get_gadget_connect_flag(void);</p>
<p>extern int dwc_otg_check_dpdm(void);</p>
<p>static int  is_charge_ok(struct rk30_adc_battery_data *bat);</p>
<p>static void rk30_adc_battery_voltage_samples(struct rk30_adc_battery_data *bat);</p>
<p>#ifdef  BATTERY_APK</p>
<p>//#define BAT_ADC_TABLE_LEN               11</p>
<p>static ssize_t bat_param_read(struct device *dev,struct device_attribute *attr, char *buf)</p>
<p>{</p>
<p>int i;</p>
<p>for(i=0;i&lt;BATT_NUM;i++)</p>
<p>printk(&quot;i=%d batt_table=%d\n&quot;,i+6,batt_table[i+6]);</p>
<p>for(i=0;i&lt;BATT_NUM;i++)</p>
<p>printk(&quot;i=%d batt_table=%d\n&quot;,i+17,batt_table[i+17]);</p>
<p>return 0;</p>
<p>}</p>
<p>DEVICE_ATTR(batparam, 0664, bat_param_read,NULL);</p>
<p>static ssize_t rkbatt_show_debug_attrs(struct device *dev,</p>
<p>     struct device_attribute *attr, char *buf) </p>
<p>{  </p>
<p>return sprintf(buf, &quot;%d\n&quot;, battery_dbg_level);</p>
<p>}</p>
<p>static ssize_t rkbatt_restore_debug_attrs(struct device *dev, </p>
<p> struct device_attribute *attr, const char *buf, size_t size)</p>
<p>{</p>
<p>int liTmp;</p>
<p>sscanf(buf, &quot;%d&quot;, &amp;liTmp);</p>
<p>if(liTmp != 0 &amp;&amp; liTmp != 1)</p>
<p>{</p>
<p>dev_err(dev, &quot;rk29adc_restore_debug_attrs err\n&quot;);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>battery_dbg_level = liTmp;</p>
<p>}</p>
<p>return size;</p>
<p>}</p>
<p>static ssize_t rkbatt_show_state_attrs(struct device *dev,</p>
<p>struct device_attribute *attr, char *buf) </p>
<p>{</p>
<p>// struct rk30_adc_battery_platform_data *pdata = gBatteryData-&gt;pdata;</p>
<p>int charge_ok_value =0 ;</p>
<p>charge_ok_value = is_charge_ok(gBatteryData) ;</p>
<p>return sprintf(buf,</p>
<p>&quot;gBatVol=%d,gBatCap=%d,charge_ok=%d,%s\n&quot;,</p>
<p>gBatteryData-&gt;bat_voltage,gBatteryData-&gt;bat_capacity,</p>
<p>charge_ok_value,gDischargeFlag);</p>
<p>}</p>
<p>static ssize_t rkbatt_restore_state_attrs(struct device *dev, </p>
<p>struct device_attribute *attr, const char *buf, size_t size)</p>
<p>{</p>
<p>return size;</p>
<p>}</p>
<p>static ssize_t rkbatt_show_value_attrs(struct device *dev,</p>
<p>   struct device_attribute *attr, char *buf) </p>
<p>{  </p>
<p>return sprintf(buf, &quot;pull_up_res =%d,\npull_down_res=%d\n&quot;, batt_table[4],batt_table[5]);</p>
<p>}</p>
<p>static ssize_t rkbatt_restore_value_attrs(struct device *dev, </p>
<p>struct device_attribute *attr, const char *buf, size_t size)</p>
<p>{</p>
<p>int liUp = 0;</p>
<p>int liDown = 0;</p>
<p>sscanf(buf, &quot;%d,%d&quot;, &amp;liUp,&amp;liDown);</p>
<p>if(liUp != 0 &amp;&amp; liDown != 0)</p>
<p>{</p>
<p>batt_table[4] = liUp;</p>
<p>batt_table[5] = liDown;</p>
<p>}</p>
<p>return size;</p>
<p>}</p>
<p>static ssize_t rkbatt_show_flag_attrs(struct device *dev,</p>
<p>struct device_attribute *attr, char *buf) </p>
<p>{  </p>
<p>return sprintf(buf, &quot;rk29_battery_test_flag=%d\n&quot;, battery_test_flag);</p>
<p>}</p>
<p>static ssize_t rkbatt_restore_flag_attrs(struct device *dev, </p>
<p>   struct device_attribute *attr, const char *buf, size_t size)</p>
<p>{</p>
<p>int liFlag;</p>
<p>sscanf(buf, &quot;%d&quot;, &amp;liFlag);</p>
<p>if(liFlag != 0)</p>
<p>{</p>
<p>battery_test_flag = liFlag;</p>
<p>}</p>
<p>return size;</p>
<p>}</p>
<p>static struct device_attribute rkbatt_attrs[] = {</p>
<p>__ATTR(state, 0664, rkbatt_show_state_attrs, rkbatt_restore_state_attrs),</p>
<p>__ATTR(debug, 0664, rkbatt_show_debug_attrs, rkbatt_restore_debug_attrs),</p>
<p>__ATTR(value, 0555, rkbatt_show_value_attrs, rkbatt_restore_value_attrs),</p>
<p>__ATTR(flag,  0555, rkbatt_show_flag_attrs,  rkbatt_restore_flag_attrs),</p>
<p>};</p>
<p>static int create_sysfs_interfaces(struct device *dev)</p>
<p>{</p>
<p>int liTmep;</p>
<p>for (liTmep = 0; liTmep &lt; ARRAY_SIZE(rkbatt_attrs); liTmep++) {</p>
<p>if (device_create_file(dev, rkbatt_attrs + liTmep)){</p>
<p>goto error;</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>error:</p>
<p>for ( ; liTmep &gt;= 0; liTmep–){</p>
<p>device_remove_file(dev, rkbatt_attrs + liTmep);</p>
<p>}</p>
<p>dev_err(dev, &quot;%s:Unable to create sysfs interface\n&quot;, <strong>func</strong>);</p>
<p>return -1;</p>
<p>}</p>
<p>#endif</p>
<p>static int rk30_adc_battery_load_capacity(void)</p>
<p>{</p>
<p>char value[4];</p>
<p>int* p = (int *)value;</p>
<p>long fd, fdir;</p>
<p>fdir = sys_open(&quot;/metadata&quot;, O_RDONLY | O_DIRECTORY,0 );</p>
<p>if (fdir &lt;0){</p>
<p>fd = sys_open(&quot;/data/bat_last_capacity.dat&quot;,O_RDONLY,0);</p>
<p>gBatteryData -&gt;is_data_dir =1;</p>
<p>}else{</p>
<p>fd = sys_open(&quot;/metadata/bat_last_capacity.dat&quot;,O_RDONLY,0);</p>
<p>gBatteryData -&gt;is_data_dir = 0;</p>
<p>}</p>
<p>if(fd &lt; 0){</p>
<p>DBG(&quot;rk30_adc_battery_load_capacity: open file /data/bat_last_capacity.dat failed\n&quot;);</p>
<p>return -1;</p>
<p>}</p>
<p>sys_read(fd,(char __user *)value,4);</p>
<p>sys_close(fd);</p>
<p>return (*p);</p>
<p>}</p>
<p>static void rk30_adc_battery_put_capacity(int loadcapacity)</p>
<p>{</p>
<p>char value[4];</p>
<p>int* p = (int *)value;</p>
<p>long fd;</p>
<p>if ( gBatteryData -&gt;is_data_dir == 1)</p>
<p>fd = sys_open(&quot;/data/bat_last_capacity.dat&quot;,O_CREAT | O_RDWR,0);</p>
<p>else</p>
<p>fd = sys_open(&quot;/metadata/bat_last_capacity.dat&quot;,O_CREAT | O_RDWR,0);</p>
<p>if(fd &lt; 0){</p>
<p>DBG(&quot;rk30_adc_battery_put_capacity: open file /data/bat_last_capacity.dat failed\n&quot;);</p>
<p>return;</p>
<p>}</p>
<p>*p = loadcapacity;</p>
<p>sys_write(fd, (const char __user *)value, 4);</p>
<p>sys_close(fd);</p>
<p>}</p>
<p>static BLOCKING_NOTIFIER_HEAD(adc_battery_chain_head);</p>
<p>int register_adc_battery_notifier(struct notifier_block *nb)</p>
<p>{</p>
<p>return blocking_notifier_chain_register(&amp;adc_battery_chain_head, nb);</p>
<p>}</p>
<p>EXPORT_SYMBOL_GPL(register_adc_battery_notifier);</p>
<p>int unregister_adc_battery_notifier(struct notifier_block *nb)</p>
<p>{</p>
<p>return blocking_notifier_chain_unregister(&amp;adc_battery_chain_head, nb);</p>
<p>}</p>
<p>EXPORT_SYMBOL_GPL(unregister_adc_battery_notifier);</p>
<p>int adc_battery_notifier_call_chain(unsigned long val)</p>
<p>{</p>
<p>return (blocking_notifier_call_chain(&amp;adc_battery_chain_head, val, NULL)</p>
<p>== NOTIFY_BAD) ? -EINVAL : 0;</p>
<p>}</p>
<p>EXPORT_SYMBOL_GPL(adc_battery_notifier_call_chain);</p>
<p>static void rk_start_charge(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if (pdata-&gt;charge_set_pin != INVALID_GPIO){</p>
<p>gpio_direction_output(pdata-&gt;charge_set_pin, pdata-&gt;charge_set_level);</p>
<p>}</p>
<p>}</p>
<p>static void rk_stop_charge(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if (pdata-&gt;charge_set_pin != INVALID_GPIO){</p>
<p>gpio_direction_output(pdata-&gt;charge_set_pin, 1 - pdata-&gt;charge_set_level);</p>
<p>}</p>
<p>}</p>
<p>static int  get_ac_status(struct rk30_adc_battery_data *bat){</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int status = 0;</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>if (gpio_get_value (pdata-&gt;dc_det_pin) == pdata-&gt;dc_det_level){</p>
<p>status = 1;</p>
<p>}else{</p>
<p>status = 0;</p>
<p>}</p>
<p>}else{</p>
<p>if(pdata-&gt;is_dc_charging){</p>
<p>status = pdata-&gt;is_dc_charging();</p>
<p>}</p>
<p>}</p>
<p>return status;</p>
<p>}</p>
<p>// state of charge  — charge-display</p>
<p>static int  get_usb_status1(struct rk30_adc_battery_data *bat){</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int status = 0;</p>
<p>if(pdata-&gt;is_usb_charging){</p>
<p>status = pdata-&gt;is_usb_charging();</p>
<p>}</p>
<p>return status;</p>
<p>}</p>
<p>//state of charge —-running</p>
<p>static int  get_usb_status2(struct rk30_adc_battery_data *bat){</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int usb_status = 0; // 0–dischage ,1 —usb charge, 2 —ac charge</p>
<p>int vbus_status =  dwc_vbus_status();</p>
<p>if (1 == vbus_status) {</p>
<p>if (0 == get_gadget_connect_flag()){ </p>
<p>if (++bat-&gt;gBatUsbChargeCnt &gt;= NUM_USBCHARGE_IDENTIFY_TIMES){</p>
<p>bat-&gt;gBatUsbChargeCnt = NUM_USBCHARGE_IDENTIFY_TIMES + 1;</p>
<p>usb_status = 2; // non-standard AC charger</p>
<p>if(bat -&gt;pdata -&gt;control_usb_charging)</p>
<p>bat -&gt;pdata -&gt;control_usb_charging(1);</p>
<p>}else{</p>
<p>usb_status = 1; // connect to pc </p>
<p>if(bat -&gt;pdata -&gt;control_usb_charging)</p>
<p>bat -&gt;pdata -&gt;control_usb_charging(0);</p>
<p>}</p>
<p>}else{</p>
<p>usb_status = 1; // connect to pc </p>
<p>if(bat -&gt;pdata -&gt;control_usb_charging)</p>
<p>bat -&gt;pdata -&gt;control_usb_charging(0);</p>
<p>}</p>
<p>}else{</p>
<p>bat-&gt;gBatUsbChargeCnt = 0;</p>
<p>if (2 == vbus_status) {</p>
<p>usb_status = 2; //standard AC charger</p>
<p>if(bat -&gt;pdata -&gt;control_usb_charging)</p>
<p>bat -&gt;pdata -&gt;control_usb_charging(1);</p>
<p>}else{</p>
<p>usb_status = 0; </p>
<p>}</p>
<p>}</p>
<p>return usb_status;</p>
<p>}</p>
<p>static int rk_battery_get_status(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int charge_on = 0;</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int ac_ac_charging = 0, usb_ac_charging = 0;</p>
<p>int i=0;</p>
<p>#if defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>ac_ac_charging = get_ac_status(bat);</p>
<p>if(1 == ac_ac_charging)</p>
<p>charge_on = 1;</p>
<p>#endif</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE) </p>
<p>if (strstr(saved_command_line,&quot;charger&quot;)){</p>
<p>wake_lock(&amp;charge_display_lock);  //lock</p>
<p>if( bat-&gt;pdata-&gt;usb_det_pin  != INVALID_GPIO ){</p>
<p>if( gpio_get_value(bat-&gt;pdata-&gt;usb_det_pin)== bat-&gt;pdata-&gt;usb_det_level){</p>
<p>if(( 1 == usb_ac_charging )||( 1 == ac_ac_charging ))</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>if(( 1 == bat-&gt;usb_charging)||(1 == bat -&gt;ac_charging))</p>
<p>charge_on =1;</p>
<p>return charge_on;</p>
<p>}else{</p>
<p>if(( 0 == usb_ac_charging )&amp;&amp;( 0 == ac_ac_charging ))</p>
<p>bat -&gt; ac_charging = 0;</p>
<p>else</p>
<p>bat-&gt;ac_charging = 1;</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>if(1 == bat-&gt;ac_charging)</p>
<p>charge_on=1;</p>
<p>else</p>
<p>charge_on = 0;</p>
<p>return charge_on;</p>
<p>}</p>
<p>}else{</p>
<p>if(dwc_otg_check_dpdm() == 0){</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>usb_ac_charging = 0;</p>
<p>}else if(dwc_otg_check_dpdm() == 1){</p>
<p>bat-&gt;usb_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(0);</p>
<p>}else if(dwc_otg_check_dpdm() == 2){</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>usb_ac_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(1); </p>
<p>}</p>
<p>if((1 == usb_ac_charging)||(1 == ac_ac_charging))</p>
<p>bat -&gt;ac_charging = 1;</p>
<p>else</p>
<p>bat -&gt;ac_charging = 0;</p>
<p>if(( 0 == bat -&gt;ac_charging )&amp;&amp;(0 == bat-&gt;usb_charging  )){</p>
<p>charge_on = 0;</p>
<p>bat-&gt;bat_change = 1;</p>
<p>}</p>
<p>return charge_on;</p>
<p>}</p>
<p>}</p>
<p>if (charge_on == 0){</p>
<p>usb_ac_charging = get_usb_status2(bat); //0 –discharge, 1—usb charging,2—-AC charging;</p>
<p>if(1 == usb_ac_charging)</p>
<p>bat-&gt;usb_charging = 1;</p>
<p>else</p>
<p>bat-&gt;usb_charging = 0; </p>
<p>}</p>
<p>#endif</p>
<p>if((usb_ac_charging == 2)||(ac_ac_charging == 1))</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>else</p>
<p>bat -&gt; ac_charging = 0;</p>
<p>if((bat-&gt;usb_charging == 1)||(bat -&gt;ac_charging ==1))</p>
<p>charge_on =1;</p>
<p>if(1 == bat-&gt;ac_charging )</p>
<p>bat-&gt;charge_source_now = 1; //ac charge</p>
<p>else if( 1 == bat-&gt;usb_charging){</p>
<p>bat-&gt;charge_source_now = 2; //ac charge</p>
<p>}else{</p>
<p>bat-&gt;charge_soure_old =0;</p>
<p>bat-&gt;charge_source_now=0;</p>
<p>}</p>
<p>if(bat-&gt;charge_source_now != bat-&gt;charge_soure_old){</p>
<p>for (i = 0; i &lt; NUM_VOLTAGE_SAMPLE; i++){                //0.3 s</p>
<p>msleep(1); //mdelay — &gt; msleep</p>
<p>rk30_adc_battery_voltage_samples(bat);              //get new voltage</p>
<p>}</p>
<p>bat-&gt;charge_soure_old = bat-&gt;charge_source_now;</p>
<p>bat-&gt;bat_change = 1;</p>
<p>}</p>
<p>DBG(&quot;ac_status=%d,usb_status=%d bat-&gt;bat_change = %d\n&quot;,bat -&gt; ac_charging, bat-&gt;usb_charging ,bat-&gt;bat_change );</p>
<p>return charge_on;</p>
<p>}</p>
<p>static int  is_charge_ok(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int charge_is_ok = 0;</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if( 1 != bat-&gt;charge_level)</p>
<p>return -1;</p>
<p>if((pdata-&gt;charge_ok_pin == INVALID_GPIO)&amp;&amp; ( pdata-&gt;charging_ok == NULL))</p>
<p>return -1;</p>
<p>if (pdata-&gt;charge_ok_pin != INVALID_GPIO){ </p>
<p>if (gpio_get_value(pdata-&gt;charge_ok_pin) == pdata-&gt;charge_ok_level){</p>
<p>charge_is_ok =1;</p>
<p>}</p>
<p>}else if( pdata-&gt;charging_ok){ </p>
<p>charge_is_ok = pdata-&gt;charging_ok();</p>
<p>}</p>
<p>return charge_is_ok;</p>
<p>}</p>
<p>static int rk30_adc_battery_status_samples(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int charge_level;</p>
<p>charge_level = bat -&gt;charge_level;//rk_battery_get_status(bat);</p>
<p>if (charge_level != bat-&gt;old_charge_level){</p>
<p>bat-&gt;old_charge_level = charge_level;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>#if 0</p>
<p>if(charge_level) {            </p>
<p>rk_start_charge(bat);</p>
<p>}</p>
<p>else{</p>
<p>rk_stop_charge(bat);</p>
<p>}</p>
<p>#endif</p>
<p>bat-&gt;bat_status_cnt = 0;        </p>
<p>}</p>
<p>if(( 1 == charge_level )&amp;&amp;(1 == bat-&gt;charge_full_flag) &amp;&amp; (bat-&gt;bat_capacity &lt; 90)){</p>
<p>rk_start_charge(bat);  //recharge</p>
<p>if(bat-&gt;pdata-&gt;ctrl_charge_led != NULL)</p>
<p>bat-&gt;pdata-&gt;ctrl_charge_led(0);</p>
<p>}else if (charge_level) {</p>
<p>rk_start_charge(bat);</p>
<p>}else{</p>
<p>rk_stop_charge(bat);</p>
<p>}</p>
<p>if(charge_level == 0){   </p>
<p>//discharge</p>
<p>bat-&gt;charge_full_flag = 0;</p>
<p>bat-&gt;full_times = 0;</p>
<p>bat-&gt;time_to_full = 0;</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_NOT_CHARGING;</p>
<p>}else{</p>
<p>//charging</p>
<p>if( is_charge_ok(bat)  ==  INVALID_CHARGE_CHECK){</p>
<p>if (bat-&gt;bat_capacity == 100){</p>
<p>if (bat-&gt;bat_status != POWER_SUPPLY_STATUS_FULL){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>bat-&gt;charge_full_flag = 1;</p>
<p>if(bat-&gt;pdata-&gt;ctrl_charge_led != NULL)</p>
<p>bat-&gt;pdata-&gt;ctrl_charge_led(1);</p>
<p>rk_stop_charge(bat);</p>
<p>}</p>
<p>}else{</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>if((bat-&gt;bat_capacity == 99)&amp;&amp;(bat-&gt;time_to_full == 0)){</p>
<p>bat-&gt;time_to_full = get_seconds();</p>
<p>}else if(bat-&gt;bat_capacity == 99)</p>
<p>{</p>
<p>if(get_seconds() - bat-&gt;time_to_full &gt; 1800){</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>bat-&gt;time_to_full = 0;</p>
<p>}</p>
<p>}</p>
<p>if(bat-&gt;pdata-&gt;ctrl_charge_led != NULL)</p>
<p>bat-&gt;pdata-&gt;ctrl_charge_led(0);</p>
<p>}</p>
<p>}else{  // pin of charge_ok_pin</p>
<p>if (is_charge_ok(bat) != CHARGE_IS_OK ){</p>
<p>bat-&gt;full_times = 0;</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>if((bat-&gt;bat_capacity == 99)&amp;&amp;(bat-&gt;time_to_full == 0)){</p>
<p>bat-&gt;time_to_full = get_seconds();</p>
<p>}else if(bat-&gt;bat_capacity == 99)</p>
<p>{</p>
<p>if(get_seconds() - bat-&gt;time_to_full &gt; 1800){</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>bat-&gt;time_to_full = 0;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}else{</p>
<p>bat-&gt;full_times++;</p>
<p>if (bat-&gt;full_times &gt;= NUM_CHARGE_FULL_DELAY_TIMES) {</p>
<p>bat-&gt;full_times = NUM_CHARGE_FULL_DELAY_TIMES + 1;</p>
<p>}</p>
<p>if ((bat-&gt;full_times &gt;= NUM_CHARGE_FULL_DELAY_TIMES) &amp;&amp; (bat-&gt;bat_capacity &gt;= 99)){</p>
<p>if (bat-&gt;bat_status != POWER_SUPPLY_STATUS_FULL){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>rk_stop_charge(bat);</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return charge_level;</p>
<p>}</p>
<p>static int rk_adc_voltage(struct rk30_adc_battery_data *bat, int value)</p>
<p>{</p>
<p>int voltage;</p>
<p>int ref_voltage; //reference_voltage</p>
<p>int pullup_res;</p>
<p>int pulldown_res;</p>
<p>ref_voltage = bat -&gt;pdata-&gt;reference_voltage;</p>
<p>pullup_res = bat -&gt;pdata-&gt;pull_up_res;</p>
<p>pulldown_res = bat -&gt;pdata-&gt;pull_down_res;</p>
<p>if(ref_voltage &amp;&amp; pullup_res &amp;&amp; pulldown_res){</p>
<p>#if defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3026)</p>
<p>ref_voltage = adc_get_curr_ref_volt();</p>
<p>#endif </p>
<p>voltage =  ((value * ref_voltage * (pullup_res + pulldown_res)) / (1024 * pulldown_res));</p>
<p>DBG(&quot;ref_voltage =%d, voltage=%d \n&quot;, ref_voltage,voltage);</p>
<p>}else{</p>
<p>#if 0</p>
<p>if(bat -&gt;capacitytmp &lt; 5)</p>
<p>ref_voltage = adc_get_curr_ref_volt();</p>
<p>else</p>
<p>ref_voltage = adc_get_def_ref_volt();</p>
<p>#endif</p>
<p>#if defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3026)</p>
<p>ref_voltage = adc_get_curr_ref_volt();</p>
<p>voltage = (value * ref_voltage * (batt_table[4] +batt_table[5])) / (1024 *batt_table[5]); </p>
<p>#else</p>
<p>voltage =voltage = adc_to_voltage(value);</p>
<p>#endif</p>
<p>}</p>
<p>DBG(&quot;ref_voltage =%d, voltage=%d \n&quot;, ref_voltage,voltage);</p>
<p>return voltage;</p>
<p>}</p>
<p>#if defined(CONFIG_MFD_TRS65910) //for trs65910 Trsilicon peter</p>
<p>//low power shutdown</p>
<p>void checklowpowershutdown(void)</p>
<p>{</p>
<p>int adc_val;</p>
<p>int voltage;</p>
<p>adc_val = adc_sync_read(gBatteryData-&gt;client);</p>
<p>voltage = rk_adc_voltage(gBatteryData, adc_val);</p>
<p>printk(&quot;Warning! Checking lowpower adc_val = %d, voltage = %d\n&quot;, adc_val, voltage);</p>
<p>if(voltage &lt;= 3200)</p>
<p>{</p>
<p>printk(&quot;pmic irq lower-power shutdown\n&quot;);</p>
<p>kernel_power_off();</p>
<p>}</p>
<p>}</p>
<p>#endif</p>
<p>static void rk_handle_ripple(struct rk30_adc_battery_data *bat, int status)</p>
<p>{</p>
<p>int *p_table;</p>
<p>if (bat-&gt;pdata-&gt;use_board_table){</p>
<p>p_table = bat-&gt;pdata-&gt;board_batt_table; </p>
<p>if(1 == status){</p>
<p>if(bat-&gt;bat_voltage &gt;= p_table[2*BATT_NUM +5]+ 10)</p>
<p>bat-&gt;bat_voltage = p_table[2*BATT_NUM +5]  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= p_table[BATT_NUM +6]  - 10)</p>
<p>bat-&gt;bat_voltage =  p_table[BATT_NUM +6] - 10;</p>
<p>}</p>
<p>else{</p>
<p>if(bat-&gt;bat_voltage &gt;= p_table[BATT_NUM +5]+ 10)</p>
<p>bat-&gt;bat_voltage = p_table[BATT_NUM +5]  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= p_table[6]  - 10)</p>
<p>bat-&gt;bat_voltage =  p_table[6] - 10;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//static int *pSamples;</p>
<p>static void rk30_adc_battery_voltage_samples(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int value;</p>
<p>int i,*pStart = bat-&gt;adc_samples, num = 0;</p>
<p>int level = bat-&gt;charge_level;</p>
<p>value = bat-&gt;adc_val;</p>
<p>adc_async_read(bat-&gt;client);</p>
<p>*(bat-&gt;pSamples++) = rk_adc_voltage(bat,value);</p>
<p>bat-&gt;bat_status_cnt++;</p>
<p>if (bat-&gt;bat_status_cnt &gt; NUM_VOLTAGE_SAMPLE)  bat-&gt;bat_status_cnt = NUM_VOLTAGE_SAMPLE + 1;</p>
<p>num = bat-&gt;pSamples - pStart;</p>
<p>if (num &gt;= NUM_VOLTAGE_SAMPLE){</p>
<p>bat -&gt;pSamples = pStart;</p>
<p>num = NUM_VOLTAGE_SAMPLE;</p>
<p>}</p>
<p>value = 0;</p>
<p>for (i = 0; i &lt; num; i++){</p>
<p>value += bat-&gt;adc_samples[i];</p>
<p>}</p>
<p>bat-&gt;bat_voltage = value / num;</p>
<p>/*handle  ripple */</p>
<p>if(battery_test_flag == 0)</p>
<p>{</p>
<p>if(0 == bat-&gt;pdata-&gt;use_board_table){</p>
<p>if(1 == level){</p>
<p>if(bat-&gt;bat_voltage &gt;= batt_table[2*BATT_NUM +5]+ 10)</p>
<p>bat-&gt;bat_voltage = batt_table[2*BATT_NUM +5]  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= batt_table[BATT_NUM +6]  - 10)</p>
<p>bat-&gt;bat_voltage =  batt_table[BATT_NUM +6] - 10;</p>
<p>}</p>
<p>else{</p>
<p>if(bat-&gt;bat_voltage &gt;= batt_table[BATT_NUM +5]+ 10)</p>
<p>bat-&gt;bat_voltage = batt_table[BATT_NUM +5]  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= batt_table[6]  - 10)</p>
<p>bat-&gt;bat_voltage =  batt_table[6] - 10;</p>
<p>}</p>
<p>}else{</p>
<p>rk_handle_ripple(bat, level);</p>
<p>}</p>
<p>}else if(battery_test_flag == 2){</p>
<p>if(batt_table[3] == 0){</p>
<p>if(bat-&gt;bat_voltage &lt; 3400){</p>
<p>if((get_seconds() - gSecondsCnt) &gt; 30){</p>
<p>gSecondsCnt = get_seconds();</p>
<p>if((gVoltageCnt - bat-&gt;bat_voltage) &gt; 15){</p>
<p>strncpy(gDischargeFlag, &quot;off&quot; ,4); </p>
<p>}</p>
<p>gVoltageCnt = bat-&gt;bat_voltage;</p>
<p>}</p>
<p>}</p>
<p>if(bat-&gt;bat_voltage &lt; 3400){</p>
<p>bat-&gt;bat_voltage = 3400;</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>if(bat-&gt;bat_voltage &lt; 6800){</p>
<p>if((get_seconds() - gSecondsCnt) &gt; 30){</p>
<p>gSecondsCnt = get_seconds();</p>
<p>if((gDoubleVoltageCnt - bat-&gt;bat_voltage) &gt; 30){</p>
<p>strncpy(gDischargeFlag, &quot;off&quot; ,4); </p>
<p>}</p>
<p>gDoubleVoltageCnt =bat-&gt;bat_voltage;</p>
<p>}</p>
<p>}</p>
<p>if(bat-&gt;bat_voltage &lt; 6800){</p>
<p>bat-&gt;bat_voltage = 6800;</p>
<p>} </p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>static int rk30_adc_battery_voltage_to_capacity(struct rk30_adc_battery_data *bat, int BatVoltage)</p>
<p>{</p>
<p>int i = 0;</p>
<p>int capacity = 0;</p>
<p>int  *p;</p>
<p>if (bat-&gt;pdata-&gt;use_board_table)</p>
<p>p = bat-&gt;pdata-&gt;board_batt_table; </p>
<p>else </p>
<p>p = batt_table;</p>
<p>if (1 == bat-&gt;charge_level){  //charge</p>
<p>if(0 == bat-&gt;start_voltage_status ){</p>
<p>if(BatVoltage &gt;= (p[2*BATT_NUM +5])){</p>
<p>capacity = 100;</p>
<p>} </p>
<p>else{</p>
<p>if(BatVoltage &lt;= (p[BATT_NUM +6])){</p>
<p>capacity = 0;</p>
<p>}</p>
<p>else{</p>
<p>for(i = BATT_NUM +6; i &lt;2*BATT_NUM +5; i++){</p>
<p>if(((p[i]) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt;  (p[i+1]))){</p>
<p>capacity = (i-(BATT_NUM +6))*10 + ((BatVoltage - p[i]) *  10)/ (p[i+1]- p[i]);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}  </p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>DBG(&quot;start_voltage=%d,start_capacity =%d\n&quot;, bat-&gt;charge_start_voltage, bat-&gt;charge_start_capacity);</p>
<p>DBG(&quot;charge_down_proportion =%d,charge_up_proprotion=%d\n&quot;,bat -&gt;charge_down_proportion,bat -&gt;charge_up_proprotion);</p>
<p>for(i = BATT_NUM +6; i &lt;2*BATT_NUM +5; i++)</p>
<p>if(((p[i]) &lt;= bat-&gt;charge_start_voltage) &amp;&amp; (bat-&gt;charge_start_voltage &lt;  (p[i+1]))) </p>
<p>bat-&gt;voltage_to_local = i;</p>
<p>if(BatVoltage &gt;= (p[2*BATT_NUM +5])){</p>
<p>capacity = 100;</p>
<p>}else{ </p>
<p>if(BatVoltage &lt;= (p[BATT_NUM +6])){</p>
<p>capacity = 0;</p>
<p>}else{</p>
<p>if(BatVoltage &lt;bat-&gt;charge_start_voltage){</p>
<p>for(i = BATT_NUM +6; i &lt;2*BATT_NUM +5; i++)</p>
<p>if(((p[i]) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt;  (p[i+1]))){</p>
<p>if( p[i+1] &lt; bat-&gt;charge_start_voltage ){</p>
<p>capacity =bat-&gt;charge_start_capacity - ((p[i+1] -BatVoltage) * bat-&gt;charge_start_capacity/(bat-&gt;voltage_to_local -17+1))/ (p[i+1]- p[i]) - (bat-&gt;voltage_to_local- (i ))*bat-&gt;charge_start_capacity/(bat-&gt;voltage_to_local -17+1);</p>
<p>DBG(&quot;1&lt;&lt;&lt;&lt;&lt;&lt;&lt; %d  bat-&gt;voltage_to_local =%d capacity = %d BatVoltage =%d  p[i] = %d,p[i+1] = %d  \n&quot;, i, bat-&gt;voltage_to_local,capacity,BatVoltage,p[i], p[i+1]);</p>
<p>}</p>
<p>else {</p>
<p>capacity =bat-&gt;charge_start_capacity - ((bat-&gt;charge_start_voltage -BatVoltage) * bat-&gt;charge_start_capacity/(bat-&gt;voltage_to_local -17+1) )/ (bat-&gt;charge_start_voltage - p[i]);</p>
<p>DBG(&quot;2&lt;&lt;&lt;&lt;&lt;&lt; %d   capacity = %d BatVoltage =%d  p[i] = %d,p[i+1] = %d  \n&quot;, i,capacity,BatVoltage,p[i], p[i+1]);</p>
<p>}</p>
<p>break;</p>
<p>}</p>
<p>}else{</p>
<p>if(BatVoltage &gt; bat-&gt;charge_start_voltage){</p>
<p>for(i = BATT_NUM +6; i &lt;2*BATT_NUM +5; i++)</p>
<p>if(((p[i]) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt;  (p[i+1]))){</p>
<p>if( p[i] &gt; bat-&gt;charge_start_voltage ){</p>
<p>capacity = bat-&gt;charge_start_capacity + (i +1- (bat-&gt;voltage_to_local))*(100- bat-&gt;charge_start_capacity )/( 10 -  (bat-&gt;voltage_to_local  - 17)) + (BatVoltage - p[i]) * (100- bat-&gt;charge_start_capacity )/( 10 -  (bat-&gt;voltage_to_local -17))/ (p[i+1]- p[i]);</p>
<p>DBG(&quot;3&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; %d bat-&gt;voltage_to_local =%d  capacity = %d BatVoltage =%d  p[i] = %d,p[i+1] = %d  \n&quot;, i, bat-&gt;voltage_to_local,capacity,BatVoltage,p[i], p[i+1]);</p>
<p>}</p>
<p>else {</p>
<p>      capacity = bat-&gt;charge_start_capacity + (BatVoltage - bat-&gt;charge_start_voltage) * (100- bat-&gt;charge_start_capacity )/( 10 -  (bat-&gt;voltage_to_local-17 )) /(p[i+1] - bat-&gt;charge_start_voltage );</p>
<p>DBG(&quot; 4&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;%d bat-&gt;voltage_to_local =%d  capacity = %d BatVoltage =%d  p[i] = %d,p[i+1] = %d  \n&quot;, i,bat-&gt;voltage_to_local,capacity,BatVoltage,p[i], p[i+1]);</p>
<p>}</p>
<p>break;</p>
<p>}</p>
<p>}else{</p>
<p>if(BatVoltage  ==  bat-&gt;charge_start_voltage)</p>
<p>capacity = bat -&gt;charge_start_capacity;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else{  //discharge</p>
<p>if(BatVoltage &gt;= (p[BATT_NUM +5])){</p>
<p>capacity = 100;</p>
<p>} </p>
<p>else{</p>
<p>if(BatVoltage &lt;= (p[6])){</p>
<p>capacity = 0;</p>
<p>}</p>
<p>else{</p>
<p>for(i = 6; i &lt; BATT_NUM +5; i++){</p>
<p>if(((p[i]) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt; (p[i+1]))){</p>
<p>capacity = (i-6)*10+ ((BatVoltage - p[i]) *10 )/ (p[i+1]- p[i]) ;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}  </p>
<p>}</p>
<p>}</p>
<p>DBG(&quot;real_voltage_to_capacity =%d\n&quot; ,capacity);</p>
<p>    return capacity;</p>
<p>}</p>
<p>static void rk_usb_charger(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int capacity = 0;</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>int timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>if((1 == bat -&gt;charge_level)&amp;&amp;( 0 == bat -&gt;start_voltage_status)){</p>
<p>bat -&gt;charge_start_voltage = bat -&gt;bat_voltage;</p>
<p>bat -&gt;start_voltage_status = 1;</p>
<p>bat -&gt;charge_start_capacity = bat -&gt;bat_capacity;</p>
<p>if(bat -&gt;charge_start_capacity%10 != 0){</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10+1;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10+1;</p>
<p>}else{</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10;</p>
<p>}</p>
<p>}</p>
<p>capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>if (capacity &gt; bat-&gt;bat_capacity){</p>
<p>if(capacity &gt; bat-&gt;bat_capacity + 10 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -10;  //5s</p>
<p>else if(capacity &gt; bat-&gt;bat_capacity + 7 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -5; //10s</p>
<p>       else if(capacity &gt; bat-&gt;bat_capacity + 3 )</p>
<p>               timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE - 2; // 13</p>
<p>if (++(bat-&gt;gBatCapacityusbChargeCnt) &gt;= timer_of_charge_sample){</p>
<p>bat-&gt;gBatCapacityusbChargeCnt  = 0;</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>bat -&gt;gBatCapacityusbdisChargeCnt = 0;//get_suspend_state(void)</p>
<p>}else //if(( get_suspend_state() != PM_SUSPEND_MEM)&amp;&amp;(capacity &lt; bat-&gt;bat_capacity)){</p>
<p>// if((gpio_get_value (bat-&gt;pdata-&gt;back_light_pin) == 1)&amp;&amp;(capacity &lt; bat-&gt;bat_capacity)){</p>
<p>if((capacity &lt; bat-&gt;bat_capacity)){</p>
<p>DBG(&quot;USB CHARGE DOWN\n&quot;);</p>
<p>// if (capacity &lt; bat-&gt;bat_capacity){</p>
<p>if(capacity &lt;10){</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 40; // 13</p>
<p>}else if(capacity &lt; 20){</p>
<p>if(capacity + 3 &gt; bat-&gt;bat_capacity  )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -5;  //5s</p>
<p>else if(capacity  + 7 &gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -10; //10s</p>
<p>else if(capacity  + 10&gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -25; // 13</p>
<p>else</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 35; // 13</p>
<p>}else{</p>
<p>if(capacity + 3 &gt; bat-&gt;bat_capacity  )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -5;  //5s</p>
<p>else if(capacity  + 7 &gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -10; //10s</p>
<p>else if(capacity  + 10&gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 15; // 13</p>
<p>else</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 20; // 13</p>
<p>}</p>
<p>if (++(bat-&gt;gBatCapacityusbdisChargeCnt) &gt;= timer_of_discharge_sample){</p>
<p>bat-&gt;gBatCapacityusbdisChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &gt; 0){</p>
<p>bat-&gt;bat_capacity– ;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>//}</p>
<p>bat-&gt;gBatCapacityusbChargeCnt  = 0;</p>
<p>}</p>
<p>else //if(get_suspend_state() == PM_SUSPEND_MEM){</p>
<p>//if(gpio_get_value (bat-&gt;pdata-&gt;back_light_pin) == 0){</p>
<p>{</p>
<p>bat-&gt;gBatCapacityusbdisChargeCnt = 0;</p>
<p>// (bat-&gt;gBatCapacityusbChargeCnt)++;</p>
<p>if( is_charge_ok(bat) != INVALID_CHARGE_CHECK){</p>
<p>if( is_charge_ok(bat) == CHARGE_IS_OK){</p>
<p>if (++bat-&gt;gBatCapacityusbChargeCnt &gt;= timer_of_charge_sample-30){</p>
<p>bat-&gt;gBatCapacityusbChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &lt;= 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}else{</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;((bat-&gt;gBatCapacityChargeCnt) &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;(bat-&gt;gBatCapacityusbChargeCnt &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityusbChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt;= 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>bat-&gt;capacitytmp = capacity;</p>
<p>}</p>
<p>static void rk_ac_charger(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int capacity = 0;</p>
<p>int timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>if((1 == bat-&gt;charge_level)&amp;&amp;( 0 == bat-&gt;start_voltage_status)){</p>
<p>bat-&gt;charge_start_voltage = bat-&gt;bat_voltage;</p>
<p>bat-&gt;start_voltage_status = 1;</p>
<p>bat-&gt;charge_start_capacity = bat-&gt;bat_capacity;</p>
<p>if(bat -&gt;charge_start_capacity%10 != 0){</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10+1;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10+1;</p>
<p>}else{</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10;</p>
<p>}</p>
<p>}</p>
<p>capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>if (capacity &gt; bat-&gt;bat_capacity){</p>
<p>if(capacity &gt; bat-&gt;bat_capacity + 10 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -10;  //5s</p>
<p>else if(capacity &gt; bat-&gt;bat_capacity + 7 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -5; //10s</p>
<p>       else if(capacity &gt; bat-&gt;bat_capacity + 3 )</p>
<p>               timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE - 2; // 13</p>
<p>if (++(bat-&gt;gBatCapacityacChargeCnt) &gt;= timer_of_charge_sample){</p>
<p>bat-&gt;gBatCapacityacChargeCnt  = 0;</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else{  </p>
<p>           bat-&gt;gBatCapacityacChargeCnt = 0;</p>
<p>           (bat-&gt;gBatCapacityChargeCnt)++;</p>
<p>if( is_charge_ok(bat) != INVALID_CHARGE_CHECK){</p>
<p>if( is_charge_ok(bat) == CHARGE_IS_OK){</p>
<p>if (bat-&gt;gBatCapacityChargeCnt &gt;= timer_of_charge_sample){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}else{</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;((bat-&gt;gBatCapacityChargeCnt) &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}else{</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;(bat-&gt;gBatCapacityChargeCnt &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt;= 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}            </p>
<p>}</p>
<p>bat-&gt;capacitytmp = capacity;</p>
<p>}</p>
<p>static void rk_battery_charger(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int capacity = 0;</p>
<p>int timer_of_discharge_sample = DISCHARGE_MIN_SECOND;</p>
<p>capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>if (capacity &lt; bat-&gt;bat_capacity){</p>
<p>#if 0</p>
<p>if(capacity &lt;10){</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 40; // 13</p>
<p>}else </p>
<p>#endif</p>
<p>if(capacity &lt; 20){</p>
<p>if(capacity + 3 &gt; bat-&gt;bat_capacity  )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -5;  //5s</p>
<p>else if(capacity  + 7 &gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -10; //10s</p>
<p>else if(capacity  + 10&gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -25; // 13</p>
<p>else</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND - 35; // 13</p>
<p>}else{</p>
<p>if(capacity + 3 &gt; bat-&gt;bat_capacity  )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -5;  //5s</p>
<p>else if(capacity  + 7 &gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -10; //10s</p>
<p>else if(capacity  + 10&gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND - 15; // 13</p>
<p>else</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND - 20; // 13</p>
<p>}</p>
<p>if(capacity &lt;= 5)              //get down quickly when lowwer power </p>
<p>timer_of_discharge_sample = 5 ;</p>
<p>if (++(bat-&gt;gBatCapacityDisChargeCnt) &gt;= timer_of_discharge_sample){</p>
<p>bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &gt; 0){</p>
<p>bat-&gt;bat_capacity– ;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>}</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>bat-&gt;gBatCapacityusbdisChargeCnt=0 ;</p>
<p>bat-&gt;gBatCapacityusbChargeCnt =0;</p>
<p>bat-&gt;gBatCapacityacChargeCnt = 0;</p>
<p>bat-&gt;start_voltage_status = 0;</p>
<p>bat-&gt;capacitytmp = capacity;</p>
<p>}</p>
<p>static void rk30_adc_battery_capacity_samples(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>// int capacity = 0;</p>
<p>// int timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>// int timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>if (bat-&gt;bat_status_cnt &lt; NUM_VOLTAGE_SAMPLE)  {</p>
<p>bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>bat-&gt;gBatCapacityChargeCnt    = 0;</p>
<p>bat-&gt;gBatCapacityacChargeCnt = 0;</p>
<p>return;</p>
<p>}</p>
<p>if(1 == bat-&gt;charge_level){</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE) </p>
<p>if(1 == bat-&gt;usb_charging)</p>
<p>rk_usb_charger(bat);</p>
<p>else</p>
<p>rk_ac_charger(bat);</p>
<p>#else</p>
<p>rk_ac_charger(bat);</p>
<p>#endif</p>
<p>}else{</p>
<p>rk_battery_charger(bat);</p>
<p>}</p>
<p>}</p>
<p>//static int poweron_check = 0;</p>
<p>static void rk30_adc_battery_poweron_capacity_check(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int new_capacity, old_capacity;</p>
<p>int cnt = 50 ;</p>
<p>new_capacity = bat -&gt;bat_capacity;</p>
<p>while( cnt – ){</p>
<p>   old_capacity = rk30_adc_battery_load_capacity();</p>
<p>   if( old_capacity &gt;= 0 ){</p>
<p>       break ;</p>
<p>   }</p>
<p>   msleep(100);</p>
<p>}</p>
<p>if ((old_capacity &lt; 0) || (old_capacity &gt; 100)){</p>
<p>old_capacity = new_capacity;</p>
<p>}    </p>
<p>//if(new_capacity &lt;= 1)       // no test</p>
<p>// old_capacity = 0;</p>
<p>if (bat -&gt;bat_status == POWER_SUPPLY_STATUS_FULL){</p>
<p>if (new_capacity &gt; 80){</p>
<p>bat -&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>else if (bat -&gt;bat_status != POWER_SUPPLY_STATUS_NOT_CHARGING){</p>
<p>//chargeing state</p>
<p>if( bat  -&gt;pdata-&gt;is_reboot_charging == 1)</p>
<p>bat -&gt;bat_capacity = (old_capacity &lt; 10) ?(old_capacity+1):old_capacity;</p>
<p>else</p>
<p>bat -&gt;bat_capacity = (new_capacity &gt; old_capacity) ? new_capacity : old_capacity;</p>
<p>}else{</p>
<p>if(new_capacity &gt; old_capacity + 50 )</p>
<p>bat -&gt;bat_capacity = old_capacity + 5;</p>
<p>else</p>
<p>bat -&gt;bat_capacity = (new_capacity &lt; old_capacity) ? new_capacity : old_capacity;  //avoid the value of capacity increase </p>
<p>if(bat-&gt;bat_capacity == 100)</p>
<p>bat-&gt;bat_capacity = 99;</p>
<p>if(bat-&gt;bat_capacity == 0)</p>
<p>bat-&gt;bat_capacity =1;</p>
<p>}</p>
<p>printk(&quot;old_capacity = %d , new_capacity =%d, capacity = %d\n  &quot;,old_capacity,new_capacity ,bat -&gt;bat_capacity);</p>
<p>bat -&gt;bat_change = 1;</p>
<p>}</p>
<p>#define to_battery_usb_device_info(x) container_of((x), \</p>
<p>struct rk30_adc_battery_data, usb);</p>
<p>static int rk30_adc_battery_get_usb_property(struct power_supply *psy, </p>
<p>   enum power_supply_property psp,</p>
<p>   union power_supply_propval *val)</p>
<p>{</p>
<p>struct rk30_adc_battery_data *bat=  to_battery_usb_device_info(psy);</p>
<p>switch (psp) {</p>
<p>case POWER_SUPPLY_PROP_ONLINE:</p>
<p>if (psy-&gt;type == POWER_SUPPLY_TYPE_USB){</p>
<p>val-&gt;intval = bat -&gt;usb_charging;</p>
<p>if (strstr(saved_command_line,&quot;charger&quot;) == NULL){ </p>
<p>if( 1 == bat-&gt;charge_full_flag)</p>
<p>val-&gt;intval = 0;</p>
<p>}</p>
<p>}</p>
<p>break;</p>
<p>default:</p>
<p>return -EINVAL;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>static enum power_supply_property rk30_adc_battery_usb_props[] = {</p>
<p>POWER_SUPPLY_PROP_ONLINE,</p>
<p>};</p>
<p>static struct power_supply rk30_usb_supply = </p>
<p>{</p>
<p>.name = &quot;usb&quot;,</p>
<p>.type = POWER_SUPPLY_TYPE_USB,</p>
<p>.get_property   = rk30_adc_battery_get_usb_property,</p>
<p>.properties     = rk30_adc_battery_usb_props,</p>
<p>.num_properties = ARRAY_SIZE(rk30_adc_battery_usb_props),</p>
<p>};</p>
<p>static irqreturn_t rk30_adc_battery_dc_wakeup(int irq, void *dev_id)</p>
<p>{   </p>
<p>disable_irq_nosync(irq);</p>
<p>queue_work(gBatteryData-&gt;wq, &amp;gBatteryData-&gt;dcwakeup_work);</p>
<p>return IRQ_HANDLED;</p>
<p>}</p>
<p>#define to_battery_ac_device_info(x) container_of((x), \</p>
<p>struct rk30_adc_battery_data, ac);</p>
<p>static int rk30_adc_battery_get_ac_property(struct power_supply *psy,</p>
<p>enum power_supply_property psp,</p>
<p>union power_supply_propval *val)</p>
<p>{</p>
<p>int ret;</p>
<p>struct rk30_adc_battery_data *bat = to_battery_ac_device_info(psy);</p>
<p>switch (psp) {</p>
<p>case POWER_SUPPLY_PROP_ONLINE:</p>
<p>if (psy-&gt;type == POWER_SUPPLY_TYPE_MAINS){</p>
<p>val-&gt;intval = bat -&gt;ac_charging;</p>
<p>if (strstr(saved_command_line,&quot;charger&quot;)  == NULL ){</p>
<p>if( 1 == bat-&gt;charge_full_flag)</p>
<p>val-&gt;intval = 0;</p>
<p>}</p>
<p>}</p>
<p>break;</p>
<p>default:</p>
<p>ret = -EINVAL;</p>
<p>break;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>static enum power_supply_property rk30_adc_battery_ac_props[] = </p>
<p>{</p>
<p>POWER_SUPPLY_PROP_ONLINE,</p>
<p>};</p>
<p>static struct power_supply rk30_ac_supply = </p>
<p>{</p>
<p>.name = &quot;ac&quot;,</p>
<p>.type = POWER_SUPPLY_TYPE_MAINS,</p>
<p>.get_property   = rk30_adc_battery_get_ac_property,</p>
<p>.properties     = rk30_adc_battery_ac_props,</p>
<p>.num_properties = ARRAY_SIZE(rk30_adc_battery_ac_props),</p>
<p>};</p>
<p>static void rk30_adc_battery_dcdet_delaywork(struct work_struct *work)</p>
<p>{</p>
<p>int ret;</p>
<p>struct rk30_adc_battery_platform_data *pdata;</p>
<p>int irq;</p>
<p>int irq_flag;</p>
<p>struct rk30_adc_battery_data  *bat = container_of((work), \</p>
<p>struct rk30_adc_battery_data, dcwakeup_work);</p>
<p>rk28_send_wakeup_key(); // wake up the system</p>
<p>pdata    = bat-&gt;pdata;</p>
<p>irq        = gpio_to_irq(pdata-&gt;dc_det_pin);</p>
<p>free_irq(irq, NULL);</p>
<p>msleep(10);</p>
<p>irq_flag = gpio_get_value (pdata-&gt;dc_det_pin) ? IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;</p>
<p>ret = request_irq(irq, rk30_adc_battery_dc_wakeup, irq_flag, &quot;ac_charge_irq&quot;, NULL);// reinitialize the DC irq </p>
<p>if (ret) {</p>
<p>free_irq(irq, NULL);</p>
<p>}</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>bat -&gt;bat_status_cnt = 0;        //the state of battery is change</p>
<p>}</p>
<p>static int rk30_adc_battery_get_status(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_status);</p>
<p>}</p>
<p>static int rk30_adc_battery_get_health(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return POWER_SUPPLY_HEALTH_GOOD;</p>
<p>}</p>
<p>static int rk30_adc_battery_get_present(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return 1;//(bat-&gt;bat_voltage &lt; BATT_MAX_VOL_VALUE) ? 0 : 1;</p>
<p>}</p>
<p>static int rk30_adc_battery_get_voltage(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_voltage );</p>
<p>}</p>
<p>static int rk30_adc_battery_get_capacity(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_capacity);</p>
<p>}</p>
<p>static int rk30_adc_battery_get_property(struct power_supply *psy,</p>
<p>enum power_supply_property psp,</p>
<p>union power_supply_propval *val)</p>
<p>{ </p>
<p>int ret = 0;</p>
<p>int voltage;</p>
<p>struct rk30_adc_battery_data  *bat = container_of((psy), \</p>
<p>struct rk30_adc_battery_data, bat);</p>
<p>switch (psp) {</p>
<p>case POWER_SUPPLY_PROP_STATUS:</p>
<p>val-&gt;intval = rk30_adc_battery_get_status(bat);</p>
<p>DBG(&quot;gBatStatus=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_HEALTH:</p>
<p>val-&gt;intval = rk30_adc_battery_get_health(bat);</p>
<p>DBG(&quot;gBatHealth=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_PRESENT:</p>
<p>val-&gt;intval = rk30_adc_battery_get_present(bat);</p>
<p>DBG(&quot;gBatPresent=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_VOLTAGE_NOW:</p>
<p>// val -&gt;intval = rk30_adc_battery_get_voltage(bat);</p>
<p>voltage = rk30_adc_battery_get_voltage(bat);</p>
<p>val-&gt;intval = voltage*1000;</p>
<p>DBG(&quot;gBatVoltage=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_CAPACITY:</p>
<p>if(battery_test_flag == 2)</p>
<p>val-&gt;intval = 50;</p>
<p>else</p>
<p>val-&gt;intval = rk30_adc_battery_get_capacity(bat);</p>
<p>DBG(&quot;gBatCapacity=%d%%\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_TECHNOLOGY:</p>
<p>val-&gt;intval = POWER_SUPPLY_TECHNOLOGY_LION; </p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:</p>
<p>val-&gt;intval = BATT_MAX_VOL_VALUE;</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:</p>
<p>val-&gt;intval = BATT_ZERO_VOL_VALUE;</p>
<p>break;</p>
<p>default:</p>
<p>ret = -EINVAL;</p>
<p>break;</p>
<p>}</p>
<p>return ret;</p>
<p>}</p>
<p>static enum power_supply_property rk30_adc_battery_props[] = {</p>
<p>POWER_SUPPLY_PROP_STATUS,</p>
<p>POWER_SUPPLY_PROP_HEALTH,</p>
<p>POWER_SUPPLY_PROP_PRESENT,</p>
<p>POWER_SUPPLY_PROP_VOLTAGE_NOW,</p>
<p>POWER_SUPPLY_PROP_TECHNOLOGY,</p>
<p>POWER_SUPPLY_PROP_CAPACITY,</p>
<p>POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,</p>
<p>POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,</p>
<p>};</p>
<p>static struct power_supply rk30_battery_supply = </p>
<p>{</p>
<p>.name = &quot;battery&quot;,</p>
<p>.type = POWER_SUPPLY_TYPE_BATTERY,</p>
<p>.get_property   = rk30_adc_battery_get_property,</p>
<p>.properties     = rk30_adc_battery_props,</p>
<p>.num_properties = ARRAY_SIZE(rk30_adc_battery_props),</p>
<p>};</p>
<p>#ifdef CONFIG_PM</p>
<p>static void rk30_adc_battery_resume_check(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int i;</p>
<p>int level,oldlevel;</p>
<p>int new_capacity, old_capacity;</p>
<p>// struct rk30_adc_battery_data *bat = gBatteryData;</p>
<p>bat -&gt;old_charge_level = -1;</p>
<p>bat -&gt;pSamples = bat-&gt;adc_samples;</p>
<p>adc_sync_read(bat-&gt;client);                             //start adc sample</p>
<p>level = oldlevel =  rk_battery_get_status(bat);//rk30_adc_battery_status_samples(bat);//init charge status</p>
<p>for (i = 0; i &lt; NUM_VOLTAGE_SAMPLE; i++) {               //0.3 s   </p>
<p>mdelay(1);</p>
<p>rk30_adc_battery_voltage_samples(bat);              //get voltage</p>
<p>level = rk_battery_get_status(bat);// rk30_adc_battery_status_samples(bat);       //check charge status</p>
<p>if (oldlevel != level){ </p>
<p>   oldlevel = level;                               //if charge status changed, reset sample</p>
<p>   i = 0;</p>
<p>}        </p>
<p>}</p>
<p>new_capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>old_capacity =bat-&gt; suspend_capacity;</p>
<p>//if (bat-&gt;bat_status != POWER_SUPPLY_STATUS_NOT_CHARGING){</p>
<p>if( 1 == level ){</p>
<p>//chargeing state</p>
<p>bat-&gt;bat_capacity = (new_capacity &lt; old_capacity) ? new_capacity : old_capacity;</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;bat_capacity = (new_capacity &lt; old_capacity) ? new_capacity : old_capacity;  // aviod the value of capacity increase    dicharge</p>
<p>}</p>
<p>if( bat -&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>if (gpio_get_value(bat -&gt;pdata-&gt;batt_low_pin) == bat -&gt;pdata-&gt;batt_low_level)</p>
<p>bat-&gt;bat_capacity = 0;</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>static int rk30_adc_battery_suspend(struct platform_device *dev, pm_message_t state)</p>
<p>{</p>
<p>int irq;</p>
<p>struct rk30_adc_battery_data *data = platform_get_drvdata(dev);</p>
<p>data -&gt;suspend_capacity = data-&gt;bat_capacity;</p>
<p>data -&gt;suspend_time = get_seconds();</p>
<p>cancel_delayed_work(&amp;data -&gt;delay_work);</p>
<p>if( data -&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>irq = gpio_to_irq(data -&gt;pdata-&gt;batt_low_pin);</p>
<p>enable_irq(irq);</p>
<p>enable_irq_wake(irq);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>static int rk30_adc_battery_resume(struct platform_device *dev)</p>
<p>{</p>
<p>int irq;</p>
<p>struct rk30_adc_battery_data *data = platform_get_drvdata(dev);</p>
<p>        if( data-&gt;bat_capacity &lt; 10 ){</p>
<p>wake_lock_timeout(&amp;batt_wake_lock_detect_lowpower,15*HZ);</p>
<p>data-&gt;bat_change  = 1;</p>
<p>}</p>
<p>data -&gt;resume_time = get_seconds();</p>
<p>data -&gt;resume = true;</p>
<p>queue_delayed_work(data-&gt;wq, &amp;data -&gt;delay_work, msecs_to_jiffies(100));</p>
<p>if( data -&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>irq = gpio_to_irq(data -&gt;pdata -&gt;batt_low_pin);</p>
<p>disable_irq_wake(irq);</p>
<p>disable_irq(irq);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>#else</p>
<p>#define rk30_adc_battery_suspend NULL</p>
<p>#define rk30_adc_battery_resume NULL</p>
<p>#endif</p>
<p>unsigned long AdcTestCnt = 0;</p>
<p>static void rk30_adc_battery_timer_work(struct work_struct *work)</p>
<p>{</p>
<p>struct rk30_adc_battery_data  *bat = container_of((work), \</p>
<p>struct rk30_adc_battery_data, delay_work);</p>
<p>#ifdef CONFIG_PM</p>
<p>if (bat -&gt;resume) {</p>
<p>// if( (bat-&gt;resume_time - bat-&gt;suspend_time) &gt;= 1800 )</p>
<p>rk30_adc_battery_resume_check(bat);</p>
<p>//else</p>
<p>//bat-&gt;bat_capacity = bat-&gt;suspend_capacity;</p>
<p>bat -&gt;resume = false;</p>
<p>bat -&gt;bat_change =1;</p>
<p>}</p>
<p>#endif</p>
<p>bat-&gt;stop_check = 1;</p>
<p>if( 1 == bat -&gt;lower_power_flag ){</p>
<p>bat -&gt;bat_capacity = 0;</p>
<p>bat -&gt;bat_change =1;</p>
<p>}</p>
<p>if (bat -&gt;poweron_check){   </p>
<p>bat -&gt;poweron_check = 0;</p>
<p>rk30_adc_battery_poweron_capacity_check(bat);</p>
<p>}</p>
<p>bat -&gt;charge_level = rk_battery_get_status(bat);</p>
<p>DBG(&quot;bat -&gt;charge_level =%d\n&quot;, bat -&gt;charge_level);</p>
<p>rk30_adc_battery_status_samples(bat);</p>
<p>rk30_adc_battery_voltage_samples(bat);</p>
<p>rk30_adc_battery_capacity_samples(bat);</p>
<p>if( 0 == bat -&gt;pdata -&gt;charging_sleep){</p>
<p>if( 1 == bat-&gt;charge_level){  // charge</p>
<p>if(0 == bat-&gt;status_lock ){ </p>
<p>wake_lock(&amp;batt_wake_lock);  //lock</p>
<p>bat -&gt;status_lock = 1; </p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>if(1 == bat -&gt;status_lock ){ </p>
<p>wake_unlock(&amp;batt_wake_lock);  //unlock</p>
<p>bat -&gt;status_lock = 0; </p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>/<em>update battery parameter after adc and capacity has been changed</em>/</p>
<p>if(bat -&gt;bat_change){</p>
<p>bat -&gt;bat_change= 0;</p>
<p>if (strstr(saved_command_line,&quot;charger&quot;) == NULL){  //when low charging-current,not in charging-displays</p>
<p>if(0 == bat -&gt;bat_capacity){</p>
<p>bat -&gt;ac_charging = 0;</p>
<p>bat -&gt;usb_charging = 0;</p>
<p>}</p>
<p>}</p>
<p>rk30_adc_battery_put_capacity(bat -&gt;bat_capacity);</p>
<p>power_supply_changed(&amp;bat -&gt;bat);</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>power_supply_changed(&amp;bat -&gt;usb);</p>
<p>#endif</p>
<p>}</p>
<p>//if (rk30_battery_dbg_level){</p>
<p>if (++AdcTestCnt &gt;= 2)</p>
<p>{</p>
<p>AdcTestCnt = 0;</p>
<p>DBG(&quot;Status = %d, RealAdcVal = %d, RealVol = %d,gBatVol = %d, gBatCap = %d, RealCapacity = %d, batt_dischargecnt = %d\n,  chargecnt = %d,ac_count = %d, usb_count =%d ,usb_dischargecount =%d\n&quot;, </p>
<p>bat -&gt;bat_status, bat -&gt;adc_val, rk_adc_voltage(bat, bat -&gt;adc_val), </p>
<p>bat -&gt;bat_voltage, bat -&gt;bat_capacity, bat -&gt;capacitytmp, bat -&gt;gBatCapacityDisChargeCnt, bat -&gt;gBatCapacityChargeCnt,</p>
<p>bat -&gt;gBatCapacityacChargeCnt, bat -&gt;gBatCapacityusbChargeCnt, bat -&gt;gBatCapacityusbdisChargeCnt);</p>
<p>}</p>
<p>//}</p>
<p>queue_delayed_work(bat -&gt;wq, &amp;bat -&gt;delay_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>}</p>
<p>static int rk30_adc_battery_io_init(struct rk30_adc_battery_platform_data *pdata)</p>
<p>{</p>
<p>int ret = 0;</p>
<p>if (pdata-&gt;io_init) {</p>
<p>pdata-&gt;io_init();</p>
<p>return 0;</p>
<p>}</p>
<p>//charge control pin</p>
<p>if (pdata-&gt;charge_set_pin != INVALID_GPIO){</p>
<p>ret = gpio_request(pdata-&gt;charge_set_pin, NULL);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to request dc_det gpio\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>gpio_direction_output(pdata-&gt;charge_set_pin, 1 - pdata-&gt;charge_set_level);</p>
<p>}</p>
<p>//dc charge detect pin</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>ret = gpio_request(pdata-&gt;dc_det_pin, NULL);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to request dc_det gpio\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>gpio_pull_updown(pdata-&gt;dc_det_pin, GPIOPullUp);//important</p>
<p>ret = gpio_direction_input(pdata-&gt;dc_det_pin);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to set gpio dc_det input\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>}</p>
<p>//charge ok detect</p>
<p>if (pdata-&gt;charge_ok_pin != INVALID_GPIO){</p>
<p>ret = gpio_request(pdata-&gt;charge_ok_pin, NULL);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to request charge_ok gpio\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>gpio_pull_updown(pdata-&gt;charge_ok_pin, GPIOPullUp);//important</p>
<p>ret = gpio_direction_input(pdata-&gt;charge_ok_pin);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to set gpio charge_ok input\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>}</p>
<p>//batt low pin</p>
<p>if( pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>ret = gpio_request(pdata-&gt;batt_low_pin, NULL);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to request batt_low_pin gpio\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>gpio_pull_updown(pdata-&gt;batt_low_pin, GPIOPullUp); </p>
<p>ret = gpio_direction_input(pdata-&gt;batt_low_pin);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to set gpio batt_low_pin input\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>error:</p>
<p>return -1;</p>
<p>}</p>
<p>extern void kernel_power_off(void);</p>
<p>int get_battery_status(void)</p>
<p>{</p>
<p>return system_lowerpower;</p>
<p>}</p>
<p>static int rk_adc_battery_poweron_status(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int status; </p>
<p>int otg_status = 0;</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if (get_ac_status(bat) ){ </p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>bat -&gt; ac_charging = 1; </p>
<p>if (is_charge_ok(bat)  == 1){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>}</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>otg_status = dwc_otg_check_dpdm();</p>
<p>if( 0 != otg_status ){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>if (is_charge_ok(bat)  == 1){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>if(otg_status == 1){</p>
<p>bat-&gt;usb_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(0);</p>
<p>}else if(otg_status == 2){</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(1); </p>
<p>}else{</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>}</p>
<p>printk(&quot;charge_status = %d\n&quot;,otg_status);</p>
<p>#endif</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>power_supply_changed(&amp;bat -&gt;usb);</p>
<p>#endif</p>
<p>if((bat -&gt; ac_charging == 1)||(bat-&gt;usb_charging == 1)){</p>
<p>bat -&gt;old_charge_level =1;</p>
<p>bat-&gt;charge_level = 1;</p>
<p>status =1;</p>
<p>}else{</p>
<p>bat -&gt;old_charge_level =0;</p>
<p>bat-&gt;charge_level = 0;</p>
<p>status =0;</p>
<p>}</p>
<p>return status; </p>
<p>}</p>
<p>static void rk30_adc_battery_check(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int i;</p>
<p>int level,oldlevel;</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int check_data[NUM_VOLTAGE_SAMPLE];</p>
<p>//bat -&gt;old_charge_level</p>
<p>// pSamples = bat-&gt;adc_samples;</p>
<p>adc_sync_read(bat-&gt;client);                             //start adc sample</p>
<p>DBG(&quot;first_adc_value is  %d \n&quot;,bat-&gt;adc_val );</p>
<p>level = oldlevel =  rk_adc_battery_poweron_status(bat);// rk30_adc_battery_status_samples(bat);//init charge status</p>
<p>for (i = 0; i &lt; NUM_VOLTAGE_SAMPLE; i++){                //0.3 s</p>
<p>mdelay(1);</p>
<p>rk30_adc_battery_voltage_samples(bat);              //get voltage</p>
<p>//level = rk30_adc_battery_status_samples(bat);       //check charge status</p>
<p>#if 0</p>
<p>level = rk_adc_battery_poweron_status(bat);</p>
<p>if (oldlevel != level){</p>
<p>oldlevel = level;                               //if charge status changed, reset sample</p>
<p>i = 0;</p>
<p>}  </p>
<p>#endif</p>
<p>}</p>
<p>for(i=0; i&lt; NUM_VOLTAGE_SAMPLE; i++){</p>
<p>mdelay(10);</p>
<p>check_data[i] = bat-&gt;adc_val;</p>
<p>adc_async_read(bat-&gt;client);</p>
<p>bat-&gt;adc_value += check_data[i];</p>
<p>}</p>
<p>bat-&gt;adc_value  /=  NUM_VOLTAGE_SAMPLE;</p>
<p>bat-&gt;bat_capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);  //init bat_capacity</p>
<p>bat-&gt;capacitytmp = bat-&gt;bat_capacity;</p>
<p>level = rk_adc_battery_poweron_status(bat);</p>
<p>if((1 == level)&amp;&amp;(0 == bat-&gt;start_voltage_status )){</p>
<p>bat-&gt;charge_start_voltage = bat-&gt;bat_voltage;</p>
<p>bat-&gt;start_voltage_status = 1;</p>
<p>bat-&gt;charge_start_capacity = bat-&gt;bat_capacity;</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10+1;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10+1;</p>
<p>}</p>
<p>#if 0 </p>
<p>if (get_ac_status(bat) ){ </p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>bat -&gt; ac_charging = 1; </p>
<p>if (is_charge_ok(bat)  == 1){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>if( 0 != dwc_otg_check_dpdm() ){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>if (is_charge_ok(bat)  == 1){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>if(dwc_otg_check_dpdm() == 1){</p>
<p>bat-&gt;usb_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(0);</p>
<p>}else if(dwc_otg_check_dpdm() == 2){</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(1); </p>
<p>}else{</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>}</p>
<p>#endif</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>power_supply_changed(&amp;bat -&gt;usb);</p>
<p>#endif</p>
<p>if((bat -&gt; ac_charging == 1)||(bat-&gt;usb_charging == 1)){</p>
<p>bat -&gt;old_charge_level =1;</p>
<p>bat-&gt;charge_level = 1;</p>
<p>}</p>
<p>#endif</p>
<p>#if 0</p>
<p>if (bat-&gt;bat_capacity == 0) {</p>
<p>bat-&gt;bat_capacity = 1;</p>
<p>system_lowerpower = 1;</p>
<p>}</p>
<p>#endif</p>
<p>if(0 !=bat -&gt;pdata-&gt;low_voltage_protection ){</p>
<p>if((bat-&gt;bat_voltage &lt;=  bat -&gt;pdata-&gt;low_voltage_protection) &amp;&amp; (bat-&gt;charge_level == 0) )</p>
<p>system_lowerpower = 1;</p>
<p>printk(&quot;protection lower power …..\n&quot;);</p>
<p>}else{</p>
<p>if((bat-&gt;bat_voltage &lt;= BATT_ZERO_VOL_VALUE) &amp;&amp; (bat-&gt;charge_level == 0))</p>
<p>system_lowerpower = 1;</p>
<p>printk(&quot;lower power …..\n&quot;);</p>
<p>} </p>
<p>#if 0</p>
<p>if ((bat-&gt;bat_voltage &lt;= BATT_ZERO_VOL_VALUE)&amp;&amp;(bat-&gt;bat_status != POWER_SUPPLY_STATUS_CHARGING)){</p>
<p>kernel_power_off();</p>
<p>}</p>
<p>#endif</p>
<p>}</p>
<p>static void rk30_adc_battery_callback(struct adc_client *client, void *param, int result)</p>
<p>{</p>
<p>struct rk30_adc_battery_data  *bat = container_of((client), \</p>
<p>struct rk30_adc_battery_data, client);</p>
<p>if (result &lt; 0){</p>
<p>DBG(&quot;adc_battery_callback    resule &lt; 0 , the value &quot;);</p>
<p>return;</p>
<p>}else{</p>
<p>gBatteryData-&gt;adc_val = result;</p>
<p>DBG(&quot;result = %d, gBatteryData-&gt;adc_val = %d\n&quot;, result, gBatteryData-&gt;adc_val );</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>static void rk30_adc_battery_lowerpower_delaywork(struct work_struct *work)</p>
<p>{</p>
<p>int irq;</p>
<p>struct rk30_adc_battery_data  *bat = container_of((work), \</p>
<p>struct rk30_adc_battery_data, lowerpower_work);</p>
<p>if( bat-&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>irq = gpio_to_irq(bat -&gt;pdata -&gt;batt_low_pin);</p>
<p>disable_irq(irq);</p>
<p>}</p>
<p>printk(&quot;lowerpower\n&quot;);</p>
<p>rk28_send_wakeup_key(); // wake up the system </p>
<p>return;</p>
<p>}</p>
<p>static irqreturn_t rk30_adc_battery_low_wakeup(int irq,void *dev_id)</p>
<p>{</p>
<p>queue_work(gBatteryData-&gt;wq, &amp;gBatteryData-&gt;lowerpower_work);</p>
<p>return IRQ_HANDLED;</p>
<p>}</p>
<p>static void rk_lowerpower_check(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int adc_val;</p>
<p>int i;</p>
<p>int check_data[NUM_VOLTAGE_SAMPLE];</p>
<p>for(i=0; i&lt; NUM_VOLTAGE_SAMPLE; i++){</p>
<p>mdelay(10);</p>
<p>adc_async_read(bat-&gt;client);</p>
<p>check_data[i] = bat-&gt;adc_val; </p>
<p>adc_val += check_data[i];</p>
<p>}</p>
<p>adc_val /=NUM_VOLTAGE_SAMPLE;</p>
<p>DBG(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;one&gt;&gt;&gt;%d, two&lt;&lt;&lt;&lt;&lt;%d&lt;&lt;&lt;&lt;\n&quot;,bat-&gt;adc_value,adc_val);</p>
<p>DBG(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;firset-value&gt;&gt;&gt;%d, second-value&lt;&lt;&lt;&lt;&lt;%d&lt;&lt;&lt;&lt;\n&quot;,rk_adc_voltage(bat, bat-&gt;adc_value),rk_adc_voltage(bat, adc_val));</p>
<p>if((adc_val &gt;= bat-&gt;adc_value+15) &amp;&amp;(bat-&gt;bat_status == POWER_SUPPLY_STATUS_NOT_CHARGING ) )//</p>
<p>{</p>
<p>printk(&quot;%d,%d\n&quot;,adc_val,bat-&gt;adc_value);</p>
<p>printk(&quot;lower-power shutdown&quot;);</p>
<p>//kernel_power_off();</p>
<p>}</p>
<p>}</p>
<p>static void rk_adc_battery_check_work(struct work_struct *work)</p>
<p>{</p>
<p>struct rk30_adc_battery_data  *bat = container_of((work), \</p>
<p>struct rk30_adc_battery_data, check_work);</p>
<p>if(1 == get_ac_status(bat)){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>}</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>if(bat-&gt;stop_check != 1)</p>
<p>queue_delayed_work(bat -&gt;wq, &amp;bat -&gt;check_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>}</p>
<p>static void poweron_lowerpoer_handle(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>#if defined CONFIG_LOGO_LOWERPOWER_WARNING ||  defined CONFIG_LOGO_LOWERPOWER_WARNING_BMP</p>
<p>if((1 ==  get_battery_status())&amp;&amp;(0 == rk_battery_get_status(bat))){</p>
<p>printk(&quot;poweron_lowerpoer_handle: lower power \n&quot;);</p>
<p>mdelay (1500);</p>
<p>kernel_power_off();</p>
<p>}</p>
<p>#endif</p>
<p>}</p>
<p>static int battery_notifier_call(struct notifier_block *nb,</p>
<p>unsigned long event, void *data)</p>
<p>{</p>
<p>struct rk30_adc_battery_data *bat=</p>
<p>container_of(nb, struct rk30_adc_battery_data, battery_nb);</p>
<p>switch (event) {</p>
<p>case LCDC_ON:</p>
<p>DBG(&quot;LCDC on \n&quot;);</p>
<p>rk_lowerpower_check(bat);//for lower power protect</p>
<p>break;</p>
<p>case BACKLIGHT_ON:</p>
<p>DBG(&quot;display \n&quot;);</p>
<p>poweron_lowerpoer_handle(bat);</p>
<p>break;</p>
<p>default:</p>
<p>return NOTIFY_OK;</p>
<p>}</p>
<p>return NOTIFY_OK;</p>
<p>}</p>
<p>static int rk30_adc_battery_probe(struct platform_device *pdev)</p>
<p>{</p>
<p>int    ret;</p>
<p>int    irq;</p>
<p>int    irq_flag;</p>
<p>struct adc_client                   *client;</p>
<p>struct rk30_adc_battery_data          *data;</p>
<p>struct rk30_adc_battery_platform_data *pdata = pdev-&gt;dev.platform_data;</p>
<p>#ifdef CONFIG_MACH_RK_FAC</p>
<p>int i;</p>
<p>for(i=0;i&lt;BATT_NUM;i++)</p>
<p>{</p>
<p>batt_table[6+i]=pdata-&gt;chargeArray[i];</p>
<p>batt_table[BATT_NUM+6+i]=pdata-&gt;chargeArray[i];</p>
<p>}</p>
<p>#endif</p>
<p>gSecondsCnt = get_seconds();</p>
<p>data = kzalloc(sizeof(*data), GFP_KERNEL);</p>
<p>if (data == NULL) {</p>
<p>ret = -ENOMEM;</p>
<p>goto err_data_alloc_failed;</p>
<p>}</p>
<p>memset(data, 0, sizeof(struct rk30_adc_battery_data));</p>
<p>gBatteryData = data;</p>
<p>platform_set_drvdata(pdev, data);</p>
<p>data-&gt;pdata = pdata;</p>
<p>data-&gt;status_lock = 0;</p>
<p>data-&gt;old_charge_level = -1;</p>
<p>data-&gt;capacitytmp = 0;</p>
<p>data-&gt;suspend_capacity = 0;</p>
<p>data-&gt;ac_charging = 0;</p>
<p>data-&gt;usb_charging = 0;</p>
<p>data-&gt;full_times = 0;</p>
<p>data-&gt;gBatCapacityDisChargeCnt =0;</p>
<p>data-&gt;gBatCapacityChargeCnt=0;</p>
<p>data-&gt;gBatCapacityusbdisChargeCnt=0 ;</p>
<p>data-&gt;gBatCapacityusbChargeCnt =0;</p>
<p>data-&gt;gBatCapacityacChargeCnt = 0;</p>
<p>data-&gt;charge_source_now = 0;</p>
<p>data-&gt;charge_soure_old = 0;</p>
<p>data-&gt;start_voltage_status = 0;</p>
<p>data-&gt;charge_full_flag =0;</p>
<p>data-&gt;pSamples = data-&gt;adc_samples;</p>
<p>data-&gt;lower_power_flag = 0;</p>
<p>data-&gt;capacitytmp = 0;</p>
<p>data-&gt;time_to_full = 0;</p>
<p>data-&gt;stop_check = 0;</p>
<p>data-&gt;voltage_to_local = 0;</p>
<p>data-&gt;bat_status = POWER_SUPPLY_STATUS_NOT_CHARGING;</p>
<p>wake_lock_init(&amp;batt_wake_lock, WAKE_LOCK_SUSPEND, &quot;batt_lock&quot;); </p>
<p>wake_lock_init(&amp;charge_display_lock, WAKE_LOCK_SUSPEND, &quot;charge_display_lock&quot;); //charge_display_lock</p>
<p>wake_lock_init(&amp;batt_wake_lock_detect_lowpower, WAKE_LOCK_SUSPEND, &quot;lowpower_lock&quot;); </p>
<p>ret = rk30_adc_battery_io_init(pdata);</p>
<p>if (ret) {</p>
<p>ret = -EINVAL;</p>
<p>goto err_io_init;</p>
<p>}</p>
<p>memset(data-&gt;adc_samples, 0, sizeof(int)*(NUM_VOLTAGE_SAMPLE + 2));</p>
<p>//register adc for battery sample</p>
<p>if(0 == pdata-&gt;adc_channel)</p>
<p>client = adc_register(0, rk30_adc_battery_callback, NULL);  //pdata-&gt;adc_channel = ani0</p>
<p>else</p>
<p>client = adc_register(pdata-&gt;adc_channel, rk30_adc_battery_callback, NULL);  </p>
<p>if(!client){</p>
<p>ret = -EINVAL;</p>
<p>goto err_adc_register_failed;</p>
<p>}</p>
<p>data-&gt;wq = create_singlethread_workqueue(&quot;adc_battd&quot;);</p>
<p>//variable init</p>
<p>data-&gt;client  = client;</p>
<p>data-&gt;adc_val = adc_sync_read(client);</p>
<p>data -&gt;bat = rk30_battery_supply;</p>
<p>ret = power_supply_register(&amp;pdev-&gt;dev,&amp;data -&gt;bat);</p>
<p>if (ret){</p>
<p>ret = -EINVAL;</p>
<p>printk(KERN_INFO &quot;fail to battery power_supply_register\n&quot;);</p>
<p>goto err_battery_failed;</p>
<p>}</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE) </p>
<p>data -&gt;usb = rk30_usb_supply;</p>
<p>ret = power_supply_register(&amp;pdev-&gt;dev, &amp;data -&gt;usb);</p>
<p>if (ret){</p>
<p>ret = -EINVAL;</p>
<p>printk(KERN_INFO &quot;fail to usb power_supply_register\n&quot;);</p>
<p>goto err_usb_failed;</p>
<p>}</p>
<p>#endif</p>
<p>data -&gt;ac = rk30_ac_supply;</p>
<p>ret = power_supply_register(&amp;pdev-&gt;dev, &amp;data -&gt;ac);</p>
<p>if (ret) {</p>
<p>ret = -EINVAL;</p>
<p>printk(KERN_INFO &quot;fail to ac power_supply_register\n&quot;);</p>
<p>goto err_ac_failed;</p>
<p>}</p>
<p>#if  defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>//init dc dectet irq &amp; delay work</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>INIT_WORK(&amp;data-&gt;dcwakeup_work, rk30_adc_battery_dcdet_delaywork);</p>
<p>irq = gpio_to_irq(pdata-&gt;dc_det_pin);         </p>
<p>irq_flag = gpio_get_value (pdata-&gt;dc_det_pin) ? IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;</p>
<p>ret = request_irq(irq, rk30_adc_battery_dc_wakeup, irq_flag, &quot;ac_charge_irq&quot;, NULL);</p>
<p>if (ret) {</p>
<p>ret = -EINVAL;</p>
<p>printk(&quot;failed to request dc det irq\n&quot;);</p>
<p>goto err_dcirq_failed;</p>
<p>}</p>
<p>enable_irq_wake(irq);  </p>
<p>}</p>
<p>#endif</p>
<p>#ifdef BATTERY_APK</p>
<p>ret = device_create_file(&amp;pdev-&gt;dev,&amp;dev_attr_batparam);</p>
<p>if(ret){</p>
<p>ret = -EINVAL;</p>
<p>printk(KERN_ERR &quot;failed to create bat param file\n&quot;);</p>
<p>goto err_battery_failed;</p>
<p>}</p>
<p>ret = create_sysfs_interfaces(&amp;pdev-&gt;dev);</p>
<p>if (ret &lt; 0)</p>
<p>{</p>
<p>ret = -EINVAL;</p>
<p>dev_err(&amp;pdev-&gt;dev,   </p>
<p>&quot;device rk30_adc_batterry sysfs register failed\n&quot;);</p>
<p>goto err_sysfs;</p>
<p>}</p>
<p>#endif </p>
<p>//Power on Battery detect</p>
<p>rk30_adc_battery_check(data);</p>
<p>// data-&gt;wq = create_singlethread_workqueue(&quot;adc_battd&quot;);</p>
<p>INIT_DELAYED_WORK(&amp;data-&gt;delay_work, rk30_adc_battery_timer_work);</p>
<p>if(1 == pdata-&gt;save_capacity ){</p>
<p>queue_delayed_work(data-&gt;wq, &amp;data-&gt;delay_work, msecs_to_jiffies(TIMER_MS_COUNTS*10));</p>
<p>data -&gt;poweron_check = 1;</p>
<p>}else{</p>
<p>queue_delayed_work(data-&gt;wq, &amp;data-&gt;delay_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>data -&gt;poweron_check = 0;</p>
<p>}</p>
<p>INIT_DELAYED_WORK(&amp;data-&gt;check_work, rk_adc_battery_check_work);</p>
<p>queue_delayed_work(data -&gt;wq, &amp;data -&gt;check_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>if( pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>if (gpio_get_value(pdata-&gt;batt_low_pin) ==0){</p>
<p>      mdelay(20);    </p>
<p>      if (gpio_get_value(pdata-&gt;batt_low_pin) ==0){</p>
<p>printk(&quot;lower power\n&quot;);</p>
<p>              kernel_power_off(); </p>
<p>      }</p>
<p>}</p>
<p>INIT_WORK(&amp;data-&gt;lowerpower_work, rk30_adc_battery_lowerpower_delaywork); </p>
<p>irq = gpio_to_irq(pdata-&gt;batt_low_pin); </p>
<p>ret = request_irq(irq, rk30_adc_battery_low_wakeup, IRQF_TRIGGER_LOW, &quot;batt_low_irq&quot;, NULL);</p>
<p>if (ret) {</p>
<p>ret = -EINVAL;</p>
<p>printk(&quot;failed to request batt_low_irq irq\n&quot;);</p>
<p>goto err_lowpowerirq_failed;</p>
<p>}</p>
<p>disable_irq(irq);</p>
<p>}</p>
<p>data-&gt;battery_nb.notifier_call = battery_notifier_call;</p>
<p>register_adc_battery_notifier(&amp;data-&gt;battery_nb);</p>
<p>printk(KERN_INFO &quot;rk30_adc_battery: driver initialized\n&quot;);</p>
<p>return 0;</p>
<p>err_sysfs: </p>
<p>err_usb_failed:</p>
<p>power_supply_unregister(&amp;data -&gt;usb);</p>
<p>err_ac_failed:</p>
<p>power_supply_unregister(&amp;data -&gt;ac);</p>
<p>err_battery_failed:</p>
<p>power_supply_unregister(&amp;data -&gt;bat);</p>
<p>err_dcirq_failed:</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>free_irq(gpio_to_irq(pdata-&gt;dc_det_pin), data);</p>
<p>}</p>
<p>#if 1</p>
<p> err_lowpowerirq_failed:</p>
<p>if( pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>free_irq(gpio_to_irq(pdata-&gt;batt_low_pin), data);</p>
<p>}</p>
<p>#endif</p>
<p>err_adc_register_failed:</p>
<p>err_io_init:    </p>
<p>err_data_alloc_failed:</p>
<p>kfree(data);</p>
<p>printk(&quot;rk30_adc_battery: error!\n&quot;);</p>
<p>return ret;</p>
<p>}</p>
<p>static int rk30_adc_battery_remove(struct platform_device *pdev)</p>
<p>{</p>
<p>struct rk30_adc_battery_data *data = platform_get_drvdata(pdev);</p>
<p>struct rk30_adc_battery_platform_data *pdata = pdev-&gt;dev.platform_data;</p>
<p>cancel_delayed_work_sync(&amp;data-&gt;delay_work); </p>
<p>#if  defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>    if (pdata-&gt;dc_det_pin != INVALID_GPIO)</p>
<p>        cancel_delayed_work_sync(&amp;data-&gt;dcwakeup_work);</p>
<p>#endif</p>
<p>        cancel_delayed_work_sync(&amp;data-&gt;check_work);</p>
<p>    if( pdata-&gt;batt_low_pin != INVALID_GPIO)</p>
<p>        cancel_delayed_work_sync(&amp;data-&gt;lowerpower_work);</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>power_supply_unregister(&amp;data -&gt;usb);</p>
<p>#endif</p>
<p>power_supply_unregister(&amp;data -&gt;ac);</p>
<p>power_supply_unregister(&amp;data -&gt;bat);</p>
<p>    if (pdata-&gt;dc_det_pin != INVALID_GPIO)</p>
<p>free_irq(gpio_to_irq(pdata-&gt;dc_det_pin), data);</p>
<p>kfree(data);</p>
<p>return 0;</p>
<p>}</p>
<p>static struct platform_driver rk30_adc_battery_driver = {</p>
<p>.probe = rk30_adc_battery_probe,</p>
<p>.remove = rk30_adc_battery_remove,</p>
<p>.suspend = rk30_adc_battery_suspend,</p>
<p>.resume = rk30_adc_battery_resume,</p>
<p>.driver = {</p>
<p>.name = &quot;rk30-battery&quot;,</p>
<p>.owner = THIS_MODULE,</p>
<p>}</p>
<p>};</p>
<p>static int __init rk30_adc_battery_init(void)</p>
<p>{</p>
<p>return platform_driver_register(&amp;rk30_adc_battery_driver);</p>
<p>}</p>
<p>static void __exit rk30_adc_battery_exit(void)</p>
<p>{</p>
<p>platform_driver_unregister(&amp;rk30_adc_battery_driver);</p>
<p>}</p>
<p>//module_init(rk30_adc_battery_init);//module_init(rk30_adc_battery_init);//</p>
<p>subsys_initcall(rk30_adc_battery_init);</p>
<p>//fs_initcall(rk30_adc_battery_init);</p>
<p>module_exit(rk30_adc_battery_exit);</p>
<p>MODULE_DESCRIPTION(&quot;Battery detect driver for the rk30&quot;);</p>
<p>MODULE_AUTHOR(&quot;luowei <a href="mailto:&#x6c;&#119;&#64;&#114;&#111;&#99;&#107;&#45;&#x63;&#104;&#x69;&#112;&#115;&#46;&#x63;&#111;&#x6d;">&#x6c;&#119;&#64;&#114;&#111;&#99;&#107;&#45;&#x63;&#104;&#x69;&#112;&#115;&#46;&#x63;&#111;&#x6d;</a>&quot;);</p>
<p>MODULE_LICENSE(&quot;GPL&quot;);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>TabletStatusBar</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/TabletStatusBar.java/</url>
    <content><![CDATA[<p>packages\SystemUI\src\com\android\systemui\statusbar\tablet\TabletStatusBar.java</p>
<p>/*</p>
<p> * Copyright (C) 2010 The Android Open Source Project</p>
<p> *</p>
<p> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</p>
<p> * you may not use this file except in compliance with the License.</p>
<p> * You may obtain a copy of the License at</p>
<p> *</p>
<p> *      <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p> *</p>
<p> * Unless required by applicable law or agreed to in writing, software</p>
<p> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</p>
<p> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>
<p> * See the License for the specific language governing permissions and</p>
<p> * limitations under the License.</p>
<p> */</p>
<p>package com.android.systemui.statusbar.tablet;</p>
<p>import android.animation.LayoutTransition;</p>
<p>import android.animation.ObjectAnimator;</p>
<p>import android.app.ActivityManager;</p>
<p>import android.app.ActivityManagerNative;</p>
<p>import android.app.Notification;</p>
<p>import android.app.PendingIntent;</p>
<p>import android.app.StatusBarManager;</p>
<p>import android.content.BroadcastReceiver;</p>
<p>import android.content.Context;</p>
<p>import android.content.Intent;</p>
<p>import android.content.IntentFilter;</p>
<p>import android.content.SharedPreferences;</p>
<p>import android.content.res.Configuration;</p>
<p>import android.content.res.Resources;</p>
<p>import android.graphics.PixelFormat;</p>
<p>import android.graphics.Point;</p>
<p>import android.graphics.drawable.Drawable;</p>
<p>import android.graphics.drawable.LayerDrawable;</p>
<p>import android.inputmethodservice.InputMethodService;</p>
<p>import android.os.IBinder;</p>
<p>import android.os.Message;</p>
<p>import android.os.RemoteException;</p>
<p>import android.os.ServiceManager;</p>
<p>import android.text.TextUtils;</p>
<p>import android.util.Slog;</p>
<p>import android.view.Display;</p>
<p>import android.view.Gravity;</p>
<p>import android.view.IWindowManager;</p>
<p>import android.view.KeyEvent;</p>
<p>import android.view.MotionEvent;</p>
<p>import android.view.SoundEffectConstants;</p>
<p>import android.view.VelocityTracker;</p>
<p>import android.view.View;</p>
<p>import android.view.ViewConfiguration;</p>
<p>import android.view.ViewGroup;</p>
<p>import android.view.ViewGroup.LayoutParams;</p>
<p>import android.view.WindowManager;</p>
<p>import android.view.WindowManagerImpl;</p>
<p>import android.view.accessibility.AccessibilityEvent;</p>
<p>import android.widget.ImageView;</p>
<p>import android.widget.LinearLayout;</p>
<p>import android.widget.RemoteViews;</p>
<p>import android.widget.ScrollView;</p>
<p>import android.widget.TextView;</p>
<p>import android.os.SystemProperties;</p>
<p>import com.android.internal.statusbar.StatusBarIcon;</p>
<p>import com.android.internal.statusbar.StatusBarNotification;</p>
<p>import com.android.systemui.R;</p>
<p>import com.android.systemui.recent.RecentTasksLoader;</p>
<p>import com.android.systemui.recent.RecentsPanelView;</p>
<p>import com.android.systemui.statusbar.BaseStatusBar;</p>
<p>import com.android.systemui.statusbar.CommandQueue;</p>
<p>import com.android.systemui.statusbar.DoNotDisturb;</p>
<p>import com.android.systemui.statusbar.NotificationData;</p>
<p>import com.android.systemui.statusbar.SignalClusterView;</p>
<p>import com.android.systemui.statusbar.StatusBarIconView;</p>
<p>import com.android.systemui.statusbar.NotificationData.Entry;</p>
<p>import com.android.systemui.statusbar.policy.BatteryController;</p>
<p>import com.android.systemui.statusbar.policy.BluetoothController;</p>
<p>import com.android.systemui.statusbar.policy.CompatModeButton;</p>
<p>import com.android.systemui.statusbar.policy.LocationController;</p>
<p>import com.android.systemui.statusbar.policy.NetworkController;</p>
<p>import com.android.systemui.statusbar.policy.NotificationRowLayout;</p>
<p>import com.android.systemui.statusbar.policy.Prefs;</p>
<p>import android.os.storage.StorageManager;</p>
<p>import com.android.internal.statusbar.StatusBarNotification;</p>
<p>import java.io.FileDescriptor;</p>
<p>import java.io.PrintWriter;</p>
<p>import java.util.ArrayList;</p>
<p>import android.content.ServiceConnection;</p>
<p>import android.content.ComponentName;</p>
<p>import android.os.Messenger;</p>
<p>import android.content.BroadcastReceiver;</p>
<p>import android.content.Intent;</p>
<p>import android.content.IntentFilter;</p>
<p>import android.util.Log;</p>
<p>import android.os.Handler;</p>
<p>import android.provider.Settings;</p>
<p>import java.io.File;</p>
<p>import android.widget.Toast;</p>
<p>public class TabletStatusBar extends BaseStatusBar implements</p>
<p>        InputMethodsPanel.OnHardKeyboardEnabledChangeListener,</p>
<p>        RecentsPanelView.OnRecentsPanelVisibilityChangedListener {</p>
<p>    public static final boolean DEBUG = false;</p>
<p>    public static final boolean DEBUG_COMPAT_HELP = false;</p>
<p>    public static final String TAG = &quot;TabletStatusBar&quot;;</p>
<p>    public static  boolean HIDE_TABLET_STATUSBAR=false;</p>
<p>    public static final int MSG_OPEN_NOTIFICATION_PANEL = 1000;</p>
<p>    public static final int MSG_CLOSE_NOTIFICATION_PANEL = 1001;</p>
<p>    public static final int MSG_OPEN_NOTIFICATION_PEEK = 1002;</p>
<p>    public static final int MSG_CLOSE_NOTIFICATION_PEEK = 1003;</p>
<p>    // 1020-1029 reserved for BaseStatusBar</p>
<p>    public static final int MSG_SHOW_CHROME = 1030;</p>
<p>    public static final int MSG_HIDE_CHROME = 1031;</p>
<p>    public static final int MSG_OPEN_INPUT_METHODS_PANEL = 1040;</p>
<p>    public static final int MSG_CLOSE_INPUT_METHODS_PANEL = 1041;</p>
<p>    public static final int MSG_OPEN_COMPAT_MODE_PANEL = 1050;</p>
<p>    public static final int MSG_CLOSE_COMPAT_MODE_PANEL = 1051;</p>
<p>    public static final int MSG_STOP_TICKER = 2000;</p>
<p>    // Fitts’ Law assistance for LatinIME; see policy.EventHole</p>
<p>    private static final boolean FAKE_SPACE_BAR = true;</p>
<p>    // Notification &quot;peeking&quot; (flyover preview of individual notifications)</p>
<p>    final static int NOTIFICATION_PEEK_HOLD_THRESH = 200; // ms</p>
<p>    final static int NOTIFICATION_PEEK_FADE_DELAY = 3000; // ms</p>
<p>    private static final int NOTIFICATION_PRIORITY_MULTIPLIER = 10; // see NotificationManagerService</p>
<p>    private static final int HIDE_ICONS_BELOW_SCORE = Notification.PRIORITY_LOW * NOTIFICATION_PRIORITY_MULTIPLIER;</p>
<p>    // The height of the bar, as definied by the build.  It may be taller if we’re plugged</p>
<p>    // into hdmi.</p>
<p>    int mNaturalBarHeight = -1;</p>
<p>    int mIconSize = -1;</p>
<p>    int mIconHPadding = -1;</p>
<p>    int mNavIconWidth = -1;</p>
<p>    int mMenuNavIconWidth = -1;</p>
<p>    private int mMaxNotificationIcons = 5;</p>
<p>    IWindowManager mWindowManager;</p>
<p>  // storage</p>
<p>    private StorageManager mStorageManager;</p>
<p>    TabletStatusBarView mStatusBarView;</p>
<p>    View mNotificationArea;</p>
<p>    View mNotificationTrigger;</p>
<p>    NotificationIconArea mNotificationIconArea;</p>
<p>    ViewGroup mNavigationArea;</p>
<p>    boolean mNotificationDNDMode;</p>
<p>    NotificationData.Entry mNotificationDNDDummyEntry;</p>
<p>    ImageView mBackButton;</p>
<p>    View mHomeButton;</p>
<p>    View mMenuButton;</p>
<p>    View mRecentButton;</p>
<p>    View mVolumeUpButton;</p>
<p>    View mVolumeDownButton;</p>
<p>    private boolean mAltBackButtonEnabledForIme;</p>
<p>    ViewGroup mFeedbackIconArea; // notification icons, IME icon, compat icon</p>
<p>    InputMethodButton mInputMethodSwitchButton;</p>
<p>    CompatModeButton mCompatModeButton;</p>
<p>    ImageView mScreenshot;</p>
<p>    NotificationPanel mNotificationPanel;</p>
<p>    WindowManager.LayoutParams mNotificationPanelParams;</p>
<p>    NotificationPeekPanel mNotificationPeekWindow;</p>
<p>    ViewGroup mNotificationPeekRow;</p>
<p>    int mNotificationPeekIndex;</p>
<p>    IBinder mNotificationPeekKey;</p>
<p>    LayoutTransition mNotificationPeekScrubLeft, mNotificationPeekScrubRight;</p>
<p>    int mNotificationPeekTapDuration;</p>
<p>    int mNotificationFlingVelocity;</p>
<p>    BatteryController mBatteryController;</p>
<p>    BluetoothController mBluetoothController;</p>
<p>    LocationController mLocationController;</p>
<p>    NetworkController mNetworkController;</p>
<p>    DoNotDisturb mDoNotDisturb;</p>
<p>    ViewGroup mBarContents;</p>
<p>    // hide system chrome (&quot;lights out&quot;) support</p>
<p>    View mShadow;</p>
<p>    NotificationIconArea.IconLayout mIconLayout;</p>
<p>    TabletTicker mTicker;</p>
<p>    View mFakeSpaceBar;</p>
<p>    KeyEvent mSpaceBarKeyEvent = null;</p>
<p>    View mCompatibilityHelpDialog = null;</p>
<p>    // for disabling the status bar</p>
<p>    int mDisabled = 0;</p>
<p>    private InputMethodsPanel mInputMethodsPanel;</p>
<p>    private CompatModePanel mCompatModePanel;</p>
<p>    private int mSystemUiVisibility = 0;</p>
<p>    private int mNavigationIconHints = 0;</p>
<p>    private int mShowSearchHoldoff = 0;</p>
<p>private String isEnableShowVoiceIcon = SystemProperties.get(&quot;ro.rk.systembar.voiceicon&quot;);</p>
<p>    public Context getContext() { return mContext; }</p>
<p>    private Runnable mShowSearchPanel = new Runnable() {</p>
<p>        public void run() {</p>
<p>            showSearchPanel();</p>
<p>        }</p>
<p>    };</p>
<p>    private View.OnTouchListener mHomeSearchActionListener = new View.OnTouchListener() {</p>
<p>        public boolean onTouch(View v, MotionEvent event) {</p>
<p>            switch(event.getAction()) {</p>
<p>                case MotionEvent.ACTION_DOWN:</p>
<p>                    if (!shouldDisableNavbarGestures() &amp;&amp; !inKeyguardRestrictedInputMode()) {</p>
<p>                        mHandler.removeCallbacks(mShowSearchPanel);</p>
<p>                        mHandler.postDelayed(mShowSearchPanel, mShowSearchHoldoff);</p>
<p>                    }</p>
<p>                break;</p>
<p>                case MotionEvent.ACTION_UP:</p>
<p>                case MotionEvent.ACTION_CANCEL:</p>
<p>                    mHandler.removeCallbacks(mShowSearchPanel);</p>
<p>                break;</p>
<p>            }</p>
<p>            return false;</p>
<p>        }</p>
<p>    };</p>
<p>    @Override</p>
<p>    protected void createAndAddWindows() {</p>
<p>        addStatusBarWindow();</p>
<p>        addPanelWindows();</p>
<p>    }</p>
<p>    private void addStatusBarWindow() {</p>
<p>        final View sb = makeStatusBarView();</p>
<p>        final WindowManager.LayoutParams lp = new WindowManager.LayoutParams(</p>
<p>                ViewGroup.LayoutParams.MATCH_PARENT,</p>
<p>                ViewGroup.LayoutParams.MATCH_PARENT,</p>
<p>                WindowManager.LayoutParams.TYPE_NAVIGATION_BAR,</p>
<p>                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</p>
<p>                    | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING</p>
<p>                    | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH,</p>
<p>                // We use a pixel format of RGB565 for the status bar to save memory bandwidth and</p>
<p>                // to ensure that the layer can be handled by HWComposer.  On some devices the</p>
<p>                // HWComposer is unable to handle SW-rendered RGBX_8888 layers.</p>
<p>                PixelFormat.RGB_565);</p>
<p>        // We explicitly leave FLAG_HARDWARE_ACCELERATED out of the flags.  The status bar occupies</p>
<p>        // very little screen real-estate and is updated fairly frequently.  By using CPU rendering</p>
<p>        // for the status bar, we prevent the GPU from having to wake up just to do these small</p>
<p>        // updates, which should help keep power consumption down.</p>
<p>        lp.gravity = getStatusBarGravity();</p>
<p>        lp.setTitle(&quot;SystemBar&quot;);</p>
<p>        lp.packageName = mContext.getPackageName();</p>
<p>        WindowManagerImpl.getDefault().addView(sb, lp);</p>
<p>    }</p>
<p>    protected void addPanelWindows() {</p>
<p>        final Context context = mContext;</p>
<p>        final Resources res = mContext.getResources();</p>
<p>        // Notification Panel</p>
<p>        mNotificationPanel = (NotificationPanel)View.inflate(context,</p>
<p>                R.layout.system_bar_notification_panel, null);</p>
<p>        mNotificationPanel.setBar(this);</p>
<p>        mNotificationPanel.show(false, false);</p>
<p>        mNotificationPanel.setOnTouchListener(</p>
<p>                new TouchOutsideListener(MSG_CLOSE_NOTIFICATION_PANEL, mNotificationPanel));</p>
<p>        // the battery icon</p>
<p>        mBatteryController.addIconView((ImageView)mNotificationPanel.findViewById(R.id.battery));</p>
<p>        mBatteryController.addLabelView(</p>
<p>                (TextView)mNotificationPanel.findViewById(R.id.battery_text));</p>
<p>        // Bt</p>
<p>        mBluetoothController.addIconView(</p>
<p>                (ImageView)mNotificationPanel.findViewById(R.id.bluetooth));</p>
<p>        // network icons: either a combo icon that switches between mobile and data, or distinct</p>
<p>        // mobile and data icons</p>
<p>        final ImageView mobileRSSI =</p>
<p>                (ImageView)mNotificationPanel.findViewById(R.id.mobile_signal);</p>
<p>        if (mobileRSSI != null) {</p>
<p>            mNetworkController.addPhoneSignalIconView(mobileRSSI);</p>
<p>        }</p>
<p>        final ImageView wifiRSSI =</p>
<p>                (ImageView)mNotificationPanel.findViewById(R.id.wifi_signal);</p>
<p>        if (wifiRSSI != null) {</p>
<p>            mNetworkController.addWifiIconView(wifiRSSI);</p>
<p>        }</p>
<p>        mNetworkController.addWifiLabelView(</p>
<p>                (TextView)mNotificationPanel.findViewById(R.id.wifi_text));</p>
<p>        mNetworkController.addDataTypeIconView(</p>
<p>                (ImageView)mNotificationPanel.findViewById(R.id.mobile_type));</p>
<p>        mNetworkController.addMobileLabelView(</p>
<p>                (TextView)mNotificationPanel.findViewById(R.id.mobile_text));</p>
<p>        mNetworkController.addCombinedLabelView(</p>
<p>                (TextView)mBarContents.findViewById(R.id.network_text));</p>
<p>        mStatusBarView.setIgnoreChildren(0, mNotificationTrigger, mNotificationPanel);</p>
<p>        WindowManager.LayoutParams lp = mNotificationPanelParams = new WindowManager.LayoutParams(</p>
<p>                res.getDimensionPixelSize(R.dimen.notification_panel_width),</p>
<p>                getNotificationPanelHeight(),</p>
<p>                WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL,</p>
<p>                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN</p>
<p>                    | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS</p>
<p>                    | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM</p>
<p>                    | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH</p>
<p>                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</p>
<p>                PixelFormat.TRANSLUCENT);</p>
<p>        lp.gravity = Gravity.BOTTOM | Gravity.RIGHT;</p>
<p>        lp.setTitle(&quot;NotificationPanel&quot;);</p>
<p>        lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED</p>
<p>                | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING;</p>
<p>        lp.windowAnimations = com.android.internal.R.style.Animation; // == no animation</p>
<p>//        lp.windowAnimations = com.android.internal.R.style.Animation_ZoomButtons; // simple fade</p>
<p>        WindowManagerImpl.getDefault().addView(mNotificationPanel, lp);</p>
<p>        // Recents Panel</p>
<p>        mRecentTasksLoader = new RecentTasksLoader(context);</p>
<p>        updateRecentsPanel();</p>
<p>        // Search Panel</p>
<p>        mStatusBarView.setBar(this);</p>
<p>        mHomeButton.setOnTouchListener(mHomeSearchActionListener);</p>
<p>        updateSearchPanel();</p>
<p>        // Input methods Panel</p>
<p>        mInputMethodsPanel = (InputMethodsPanel) View.inflate(context,</p>
<p>                R.layout.system_bar_input_methods_panel, null);</p>
<p>        mInputMethodsPanel.setHardKeyboardEnabledChangeListener(this);</p>
<p>        mInputMethodsPanel.setOnTouchListener(new TouchOutsideListener(</p>
<p>                MSG_CLOSE_INPUT_METHODS_PANEL, mInputMethodsPanel));</p>
<p>        mInputMethodsPanel.setImeSwitchButton(mInputMethodSwitchButton);</p>
<p>        mStatusBarView.setIgnoreChildren(2, mInputMethodSwitchButton, mInputMethodsPanel);</p>
<p>        lp = new WindowManager.LayoutParams(</p>
<p>                ViewGroup.LayoutParams.WRAP_CONTENT,</p>
<p>                ViewGroup.LayoutParams.WRAP_CONTENT,</p>
<p>                WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL,</p>
<p>                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN</p>
<p>                    | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM</p>
<p>                    | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH</p>
<p>                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</p>
<p>                PixelFormat.TRANSLUCENT);</p>
<p>        lp.gravity = Gravity.BOTTOM | Gravity.RIGHT;</p>
<p>        lp.setTitle(&quot;InputMethodsPanel&quot;);</p>
<p>        lp.windowAnimations = R.style.Animation_RecentPanel;</p>
<p>        WindowManagerImpl.getDefault().addView(mInputMethodsPanel, lp);</p>
<p>        // Compatibility mode selector panel</p>
<p>        mCompatModePanel = (CompatModePanel) View.inflate(context,</p>
<p>                R.layout.system_bar_compat_mode_panel, null);</p>
<p>        mCompatModePanel.setOnTouchListener(new TouchOutsideListener(</p>
<p>                MSG_CLOSE_COMPAT_MODE_PANEL, mCompatModePanel));</p>
<p>        mCompatModePanel.setTrigger(mCompatModeButton);</p>
<p>        mCompatModePanel.setVisibility(View.GONE);</p>
<p>        mStatusBarView.setIgnoreChildren(3, mCompatModeButton, mCompatModePanel);</p>
<p>        lp = new WindowManager.LayoutParams(</p>
<p>                250,</p>
<p>                ViewGroup.LayoutParams.WRAP_CONTENT,</p>
<p>                WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL,</p>
<p>                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN</p>
<p>                    | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM</p>
<p>                    | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH</p>
<p>                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</p>
<p>                PixelFormat.TRANSLUCENT);</p>
<p>        lp.gravity = Gravity.BOTTOM | Gravity.RIGHT;</p>
<p>        lp.setTitle(&quot;CompatModePanel&quot;);</p>
<p>        lp.windowAnimations = android.R.style.Animation_Dialog;</p>
<p>        WindowManagerImpl.getDefault().addView(mCompatModePanel, lp);</p>
<p>        mRecentButton.setOnTouchListener(mRecentsPanel);</p>
<p>        mPile = (NotificationRowLayout)mNotificationPanel.findViewById(R.id.content);</p>
<p>        mPile.removeAllViews();</p>
<p>        mPile.setLongPressListener(getNotificationLongClicker());</p>
<p>        ScrollView scroller = (ScrollView)mPile.getParent();</p>
<p>        scroller.setFillViewport(true);</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected int getExpandedViewMaxHeight() {</p>
<p>        return getNotificationPanelHeight();</p>
<p>    }</p>
<p>    private int getNotificationPanelHeight() {</p>
<p>        final Resources res = mContext.getResources();</p>
<p>        final Display d = WindowManagerImpl.getDefault().getDefaultDisplay();</p>
<p>        final Point size = new Point();</p>
<p>        d.getRealSize(size);</p>
<p>        return Math.max(res.getDimensionPixelSize(R.dimen.notification_panel_min_height), size.y);</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void start() {</p>
<p>        super.start(); // will add the main bar view</p>
<p> mStorageManager = (StorageManager) mContext.getSystemService(Context.STORAGE_SERVICE);</p>
<p>     mStorageManager.registerListener(new com.android.systemui.usb.StorageNotification(mContext));</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void onConfigurationChanged(Configuration newConfig) {</p>
<p>        loadDimens();</p>
<p>if(&quot;true&quot;.equals(isEnableShowVoiceIcon)){</p>
<p>if ((mDisabled &amp; (StatusBarManager.DISABLE_RECENT</p>
<p>| StatusBarManager.DISABLE_BACK</p>
<p>| StatusBarManager.DISABLE_HOME)) == 0) {</p>
<p>if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) { </p>
<p>mVolumeUpButton.setVisibility(View.VISIBLE);</p>
<p>mVolumeDownButton.setVisibility(View.VISIBLE);</p>
<p>}else {</p>
<p>mVolumeUpButton.setVisibility(View.GONE);</p>
<p>mVolumeDownButton.setVisibility(View.GONE);</p>
<p>}</p>
<p>}</p>
<p>if (newConfig.orientation != Configuration.ORIENTATION_LANDSCAPE) { </p>
<p>mVolumeUpButton.setVisibility(View.GONE);</p>
<p>mVolumeDownButton.setVisibility(View.GONE);</p>
<p>}</p>
<p>}</p>
<p>        mNotificationPanelParams.height = getNotificationPanelHeight();</p>
<p>        WindowManagerImpl.getDefault().updateViewLayout(mNotificationPanel,</p>
<p>                mNotificationPanelParams);</p>
<p>        mRecentsPanel.updateValuesFromResources();</p>
<p>        mShowSearchHoldoff = mContext.getResources().getInteger(</p>
<p>                R.integer.config_show_search_delay);</p>
<p>        updateSearchPanel();</p>
<p>    }</p>
<p>    protected void loadDimens() {</p>
<p>        final Resources res = mContext.getResources();</p>
<p>        mNaturalBarHeight = res.getDimensionPixelSize(</p>
<p>                com.android.internal.R.dimen.navigation_bar_height);</p>
<p>        int newIconSize = res.getDimensionPixelSize(</p>
<p>            com.android.internal.R.dimen.system_bar_icon_size);</p>
<p>        int newIconHPadding = res.getDimensionPixelSize(</p>
<p>            R.dimen.status_bar_icon_padding);</p>
<p>        int newNavIconWidth = res.getDimensionPixelSize(R.dimen.navigation_key_width);</p>
<p>        int newMenuNavIconWidth = res.getDimensionPixelSize(R.dimen.navigation_menu_key_width);</p>
<p>        if (mNavigationArea != null &amp;&amp; newNavIconWidth != mNavIconWidth) {</p>
<p>            mNavIconWidth = newNavIconWidth;</p>
<p>            LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(</p>
<p>                     mNavIconWidth, ViewGroup.LayoutParams.MATCH_PARENT);</p>
<p>            mBackButton.setLayoutParams(lp);</p>
<p>            mHomeButton.setLayoutParams(lp);</p>
<p>            mRecentButton.setLayoutParams(lp);</p>
<p>            mVolumeUpButton.setLayoutParams(lp);</p>
<p>            mVolumeDownButton.setLayoutParams(lp);</p>
<p>        }</p>
<p>        if (mNavigationArea != null &amp;&amp; newMenuNavIconWidth != mMenuNavIconWidth) {</p>
<p>            mMenuNavIconWidth = newMenuNavIconWidth;</p>
<p>            LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(</p>
<p>                     mMenuNavIconWidth, ViewGroup.LayoutParams.MATCH_PARENT);</p>
<p>            mMenuButton.setLayoutParams(lp);</p>
<p>        }</p>
<p>        if (newIconHPadding != mIconHPadding || newIconSize != mIconSize) {</p>
<p>//            Slog.d(TAG, &quot;size=&quot; + newIconSize + &quot; padding=&quot; + newIconHPadding);</p>
<p>            mIconHPadding = newIconHPadding;</p>
<p>            mIconSize = newIconSize;</p>
<p>            reloadAllNotificationIcons(); // reload the tray</p>
<p>        }</p>
<p>        final int numIcons = res.getInteger(R.integer.config_maxNotificationIcons);</p>
<p>        if (numIcons != mMaxNotificationIcons) {</p>
<p>            mMaxNotificationIcons = numIcons;</p>
<p>            if (DEBUG) Slog.d(TAG, &quot;max notification icons: &quot; + mMaxNotificationIcons);</p>
<p>            reloadAllNotificationIcons();</p>
<p>        }</p>
<p>    }</p>
<p>    final Object mScreenshotLock = new Object();</p>
<p>    ServiceConnection mScreenshotConnection = null;</p>
<p>    final Runnable mScreenshotTimeout = new Runnable() {</p>
<p>        @Override public void run() {</p>
<p>            synchronized (mScreenshotLock) {</p>
<p>                if (mScreenshotConnection != null) {</p>
<p>                    mContext.unbindService(mScreenshotConnection);</p>
<p>                    mScreenshotConnection = null;</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>    };</p>
<p>    private void takeScreenshot() {</p>
<p>        String imageDir=Settings.System.getString(mContext.getContentResolver(), Settings.System.SCREENSHOT_LOCATION);</p>
<p>        File file=new File(imageDir+&quot;/Screenshots&quot;);</p>
<p>        String text=null;</p>
<p>        file.mkdir();</p>
<p>        if(!file.exists()){</p>
<p>           if(imageDir.equals(&quot;/mnt/sdcard&quot;)||imageDir.equals(&quot;/storage/sdcard0&quot;)){</p>
<p>                text=mContext.getResources().getString(R.string.sdcard_unmount);</p>
<p>           }else if(imageDir.equals(&quot;/mnt/external_sd&quot;)){</p>
<p>                text=mContext.getResources().getString(R.string.external_sd_unmount);  </p>
<p>           }else if(imageDir.equals(&quot;/mnt/usb_storage&quot;)){</p>
<p>                text=mContext.getResources().getString(R.string.usb_storage_unmount);</p>
<p>           }</p>
<p>           Toast.makeText(mContext, text, 3000).show();</p>
<p>           return;</p>
<p>        }</p>
<p>        synchronized (mScreenshotLock) {</p>
<p>            if (mScreenshotConnection != null) {</p>
<p>                return;</p>
<p>            }</p>
<p>            ComponentName cn = new ComponentName(&quot;com.android.systemui&quot;,</p>
<p>                    &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;);</p>
<p>            Intent intent = new Intent();</p>
<p>            intent.setComponent(cn);</p>
<p>            ServiceConnection conn = new ServiceConnection() {</p>
<p>                @Override</p>
<p>                public void onServiceConnected(ComponentName name, IBinder service) {</p>
<p>                    synchronized (mScreenshotLock) {</p>
<p>                        if (mScreenshotConnection != this) {</p>
<p>                            return;</p>
<p>                        }</p>
<p>                        Messenger messenger = new Messenger(service);</p>
<p>                        Message msg = Message.obtain(null, 1);</p>
<p>                        final ServiceConnection myConn = this;</p>
<p>                        Handler h = new Handler(mHandler.getLooper()) {</p>
<p>                            @Override</p>
<p>                            public void handleMessage(Message msg) {</p>
<p>                                synchronized (mScreenshotLock) {</p>
<p>                                    if (mScreenshotConnection == myConn) {</p>
<p>                                        mContext.unbindService(mScreenshotConnection);</p>
<p>                                        mScreenshotConnection = null;</p>
<p>                                        mHandler.removeCallbacks(mScreenshotTimeout);</p>
<p>                                    }</p>
<p>                                }</p>
<p>                            }</p>
<p>                        };</p>
<p>                        msg.replyTo = new Messenger(h);</p>
<p>                        msg.arg1=0;</p>
<p>                        msg.arg2=1;</p>
<p>                       // if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw())</p>
<p>                       //     msg.arg1 = 1;</p>
<p>                       // if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw())</p>
<p>                       //     msg.arg2 = 1;</p>
<p>                        try {</p>
<p>                            messenger.send(msg);</p>
<p>                        } catch (RemoteException e) {</p>
<p>                        }</p>
<p>                    }</p>
<p>                }</p>
<p>                @Override</p>
<p>                public void onServiceDisconnected(ComponentName name) {}</p>
<p>            };</p>
<p>            if (mContext.bindService(intent, conn, Context.BIND_AUTO_CREATE)) {</p>
<p>                mScreenshotConnection = conn;</p>
<p>                mHandler.postDelayed(mScreenshotTimeout, 10000);</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    private BroadcastReceiver receiver=new BroadcastReceiver() {</p>
<p>                @Override</p>
<p>                public void onReceive(Context context, Intent intent) {</p>
<p>                        // TODO Auto-generated method stub</p>
<p>                        //Log.d(&quot;screenshot&quot;,&quot;onReceiver&quot;);</p>
<p>                        String action=intent.getAction();</p>
<p>                        Log.d(&quot;screenshot&quot;,action);</p>
<p>                        if(action.equals(&quot;rk.android.screenshot.SHOW&quot;)){</p>
<p>                        boolean show=intent.getBooleanExtra(&quot;show&quot;, false);</p>
<p>                         if(show){</p>
<p>                                 Log.d(&quot;screenshot&quot;,&quot;show screenshot button&quot;);</p>
<p>                                mScreenshot.setVisibility(View.VISIBLE);</p>
<p>                         }else{</p>
<p>                                Log.d(&quot;screenshot&quot;,&quot;disable screenshot button&quot;);</p>
<p>                                mScreenshot.setVisibility(View.GONE);</p>
<p>                         }</p>
<p>                        }else{</p>
<p>                            takeScreenshot();</p>
<p>                        }</p>
<p>                }</p>
<p>        };</p>
<p>    public View getStatusBarView() {</p>
<p>        return mStatusBarView;</p>
<p>    }</p>
<p>    protected View makeStatusBarView() {</p>
<p>        final Context context = mContext;</p>
<p>        IntentFilter intentfilter=new IntentFilter();</p>
<p>        intentfilter.addAction(&quot;rk.android.screenshot.SHOW&quot;);</p>
<p>        intentfilter.addAction(&quot;rk.android.screenshot.ACTION&quot;);</p>
<p>        context.registerReceiver(receiver, intentfilter);</p>
<p>        mWindowManager = IWindowManager.Stub.asInterface(</p>
<p>                ServiceManager.getService(Context.WINDOW_SERVICE));</p>
<p>        loadDimens();</p>
<p>        final TabletStatusBarView sb = (TabletStatusBarView)View.inflate(</p>
<p>                context, R.layout.system_bar, null);</p>
<p>        mStatusBarView = sb;</p>
<p>        sb.setHandler(mHandler);</p>
<p>        try {</p>
<p>            // Sanity-check that someone hasn’t set up the config wrong and asked for a navigation</p>
<p>            // bar on a tablet that has only the system bar</p>
<p>            if (mWindowManager.hasNavigationBar()) {</p>
<p>                Slog.e(TAG, &quot;Tablet device cannot show navigation bar and system bar&quot;);</p>
<p>            }</p>
<p>        } catch (RemoteException ex) {</p>
<p>        }</p>
<p>        mBarContents = (ViewGroup) sb.findViewById(R.id.bar_contents);</p>
<p>        // the whole right-hand side of the bar</p>
<p>        mNotificationArea = sb.findViewById(R.id.notificationArea);</p>
<p>        mNotificationArea.setOnTouchListener(new NotificationTriggerTouchListener());</p>
<p>        // the button to open the notification area</p>
<p>        mNotificationTrigger = sb.findViewById(R.id.notificationTrigger);</p>
<p>        // the more notifications icon</p>
<p>        mNotificationIconArea = (NotificationIconArea)sb.findViewById(R.id.notificationIcons);</p>
<p>        // where the icons go</p>
<p>        mIconLayout = (NotificationIconArea.IconLayout) sb.findViewById(R.id.icons);</p>
<p>        ViewConfiguration vc = ViewConfiguration.get(context);</p>
<p>        mNotificationPeekTapDuration = vc.getTapTimeout();</p>
<p>        mNotificationFlingVelocity = 300; // px/s</p>
<p>        mTicker = new TabletTicker(this);</p>
<p>        // The icons</p>
<p>        mLocationController = new LocationController(mContext); // will post a notification</p>
<p>        // watch the PREF_DO_NOT_DISTURB and convert to appropriate disable() calls</p>
<p>        mDoNotDisturb = new DoNotDisturb(mContext);</p>
<p>        mBatteryController = new BatteryController(mContext);</p>
<p>        mBatteryController.addIconView((ImageView)sb.findViewById(R.id.battery));</p>
<p>        mBluetoothController = new BluetoothController(mContext);</p>
<p>        mBluetoothController.addIconView((ImageView)sb.findViewById(R.id.bluetooth));</p>
<p>        mNetworkController = new NetworkController(mContext);</p>
<p>        final SignalClusterView signalCluster =</p>
<p>                (SignalClusterView)sb.findViewById(R.id.signal_cluster);</p>
<p>        mNetworkController.addSignalCluster(signalCluster);</p>
<p>        // The navigation buttons</p>
<p>        mBackButton = (ImageView)sb.findViewById(R.id.back);</p>
<p>        mNavigationArea = (ViewGroup) sb.findViewById(R.id.navigationArea);</p>
<p>        mHomeButton = mNavigationArea.findViewById(R.id.home);</p>
<p>        mMenuButton = mNavigationArea.findViewById(R.id.menu);</p>
<p>        mRecentButton = mNavigationArea.findViewById(R.id.recent_apps);</p>
<p>        mVolumeUpButton = mNavigationArea.findViewById(R.id.add);</p>
<p>        mVolumeDownButton = mNavigationArea.findViewById(R.id.sub);</p>
<p>        mRecentButton.setOnClickListener(mOnClickListener);</p>
<p>        LayoutTransition lt = new LayoutTransition();</p>
<p>        lt.setDuration(250);</p>
<p>        // don’t wait for these transitions; we just want icons to fade in/out, not move around</p>
<p>        lt.setDuration(LayoutTransition.CHANGE_APPEARING, 0);</p>
<p>        lt.setDuration(LayoutTransition.CHANGE_DISAPPEARING, 0);</p>
<p>        lt.addTransitionListener(new LayoutTransition.TransitionListener() {</p>
<p>            public void endTransition(LayoutTransition transition, ViewGroup container,</p>
<p>                    View view, int transitionType) {</p>
<p>                // ensure the menu button doesn’t stick around on the status bar after it’s been</p>
<p>                // removed</p>
<p>                mBarContents.invalidate();</p>
<p>            }</p>
<p>            public void startTransition(LayoutTransition transition, ViewGroup container,</p>
<p>                    View view, int transitionType) {}</p>
<p>        });</p>
<p>        mNavigationArea.setLayoutTransition(lt);</p>
<p>        // no multi-touch on the nav buttons</p>
<p>        mNavigationArea.setMotionEventSplittingEnabled(false);</p>
<p>        // The bar contents buttons</p>
<p>        mFeedbackIconArea = (ViewGroup)sb.findViewById(R.id.feedbackIconArea);</p>
<p>        mInputMethodSwitchButton = (InputMethodButton) sb.findViewById(R.id.imeSwitchButton);</p>
<p>        // Overwrite the lister</p>
<p>        mInputMethodSwitchButton.setOnClickListener(mOnClickListener);</p>
<p>        mCompatModeButton = (CompatModeButton) sb.findViewById(R.id.compatModeButton);</p>
<p>        mCompatModeButton.setOnClickListener(mOnClickListener);</p>
<p>        mCompatModeButton.setVisibility(View.GONE);</p>
<p>        mScreenshot=(ImageView)sb.findViewById(R.id.screenshot);</p>
<p>        mScreenshot.setOnClickListener(new View.OnClickListener() {</p>
<p>                        @Override</p>
<p>                        public void onClick(View v) {</p>
<p>                                // TODO Auto-generated method stub</p>
<p>                                takeScreenshot();</p>
<p>                                //Intent intent=new Intent();</p>
<p>                                //intent.setAction(&quot;rk.android.screenshot.ACTION&quot;);</p>
<p>                                //mContext.sendBroadcast(intent);</p>
<p>                        }</p>
<p>                });</p>
<p>        boolean show=Settings.System.getInt(mContext.getContentResolver(),</p>
<p>                        Settings.System.SCREENSHOT_BUTTON_SHOW, 0)==1;</p>
<p>        if(show){</p>
<p>                mScreenshot.setVisibility(View.VISIBLE);</p>
<p>        }else{</p>
<p>                mScreenshot.setVisibility(View.GONE);</p>
<p>        }</p>
<p>        // for redirecting errant bar taps to the IME</p>
<p>        mFakeSpaceBar = sb.findViewById(R.id.fake_space_bar);</p>
<p>        // &quot;shadows&quot; of the status bar features, for lights-out mode</p>
<p>        mShadow = sb.findViewById(R.id.bar_shadow);</p>
<p>        mShadow.setOnTouchListener(</p>
<p>            new View.OnTouchListener() {</p>
<p>                public boolean onTouch(View v, MotionEvent ev) {</p>
<p>                    if (ev.getAction() == MotionEvent.ACTION_DOWN) {</p>
<p>                        // even though setting the systemUI visibility below will turn these views</p>
<p>                        // on, we need them to come up faster so that they can catch this motion</p>
<p>                        // event</p>
<p>                        mShadow.setVisibility(View.GONE);</p>
<p>                        mBarContents.setVisibility(View.VISIBLE);</p>
<p>                        try {</p>
<p>                            mBarService.setSystemUiVisibility(0, View.SYSTEM_UI_FLAG_LOW_PROFILE);</p>
<p>                        } catch (RemoteException ex) {</p>
<p>                            // system process dead</p>
<p>                        }</p>
<p>                    }</p>
<p>                    return false;</p>
<p>                }</p>
<p>            });</p>
<p>        // tuning parameters</p>
<p>        final int LIGHTS_GOING_OUT_SYSBAR_DURATION = 750;</p>
<p>        final int LIGHTS_GOING_OUT_SHADOW_DURATION = 750;</p>
<p>        final int LIGHTS_GOING_OUT_SHADOW_DELAY    = 0;</p>
<p>        final int LIGHTS_COMING_UP_SYSBAR_DURATION = 200;</p>
<p>//        final int LIGHTS_COMING_UP_SYSBAR_DELAY    = 50;</p>
<p>        final int LIGHTS_COMING_UP_SHADOW_DURATION = 0;</p>
<p>        LayoutTransition xition = new LayoutTransition();</p>
<p>        xition.setAnimator(LayoutTransition.APPEARING,</p>
<p>               ObjectAnimator.ofFloat(null, &quot;alpha&quot;, 0.5f, 1f));</p>
<p>        xition.setDuration(LayoutTransition.APPEARING, LIGHTS_COMING_UP_SYSBAR_DURATION);</p>
<p>        xition.setStartDelay(LayoutTransition.APPEARING, 0);</p>
<p>        xition.setAnimator(LayoutTransition.DISAPPEARING,</p>
<p>               ObjectAnimator.ofFloat(null, &quot;alpha&quot;, 1f, 0f));</p>
<p>        xition.setDuration(LayoutTransition.DISAPPEARING, LIGHTS_GOING_OUT_SYSBAR_DURATION);</p>
<p>        xition.setStartDelay(LayoutTransition.DISAPPEARING, 0);</p>
<p>        ((ViewGroup)sb.findViewById(R.id.bar_contents_holder)).setLayoutTransition(xition);</p>
<p>        xition = new LayoutTransition();</p>
<p>        xition.setAnimator(LayoutTransition.APPEARING,</p>
<p>               ObjectAnimator.ofFloat(null, &quot;alpha&quot;, 0f, 1f));</p>
<p>        xition.setDuration(LayoutTransition.APPEARING, LIGHTS_GOING_OUT_SHADOW_DURATION);</p>
<p>        xition.setStartDelay(LayoutTransition.APPEARING, LIGHTS_GOING_OUT_SHADOW_DELAY);</p>
<p>        xition.setAnimator(LayoutTransition.DISAPPEARING,</p>
<p>               ObjectAnimator.ofFloat(null, &quot;alpha&quot;, 1f, 0f));</p>
<p>        xition.setDuration(LayoutTransition.DISAPPEARING, LIGHTS_COMING_UP_SHADOW_DURATION);</p>
<p>        xition.setStartDelay(LayoutTransition.DISAPPEARING, 0);</p>
<p>        ((ViewGroup)sb.findViewById(R.id.bar_shadow_holder)).setLayoutTransition(xition);</p>
<p>        // set the initial view visibility</p>
<p>        setAreThereNotifications();</p>
<p>        // receive broadcasts</p>
<p>        IntentFilter filter = new IntentFilter();</p>
<p>        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</p>
<p>        filter.addAction(Intent.ACTION_SCREEN_OFF);</p>
<p>        context.registerReceiver(mBroadcastReceiver, filter);</p>
<p>        return sb;</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected WindowManager.LayoutParams getRecentsLayoutParams(LayoutParams layoutParams) {</p>
<p>        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(</p>
<p>                (int) mContext.getResources().getDimension(R.dimen.status_bar_recents_width),</p>
<p>                ViewGroup.LayoutParams.MATCH_PARENT,</p>
<p>                WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL,</p>
<p>                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN</p>
<p>                | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM</p>
<p>                | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH</p>
<p>                | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</p>
<p>                PixelFormat.TRANSLUCENT);</p>
<p>        lp.gravity = Gravity.BOTTOM | Gravity.LEFT;</p>
<p>        lp.setTitle(&quot;RecentsPanel&quot;);</p>
<p>        lp.windowAnimations = com.android.internal.R.style.Animation_RecentApplications;</p>
<p>        lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED</p>
<p>            | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING;</p>
<p>        return lp;</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected WindowManager.LayoutParams getSearchLayoutParams(LayoutParams layoutParams) {</p>
<p>        boolean opaque = false;</p>
<p>        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(</p>
<p>                LayoutParams.MATCH_PARENT,</p>
<p>                LayoutParams.MATCH_PARENT,</p>
<p>                WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL,</p>
<p>                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN</p>
<p>                        | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM</p>
<p>                        | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH,</p>
<p>                (opaque ? PixelFormat.OPAQUE : PixelFormat.TRANSLUCENT));</p>
<p>        if (ActivityManager.isHighEndGfx(mDisplay)) {</p>
<p>            lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</p>
<p>        } else {</p>
<p>            lp.flags |= WindowManager.LayoutParams.FLAG_DIM_BEHIND;</p>
<p>            lp.dimAmount = 0.7f;</p>
<p>        }</p>
<p>        lp.gravity = Gravity.BOTTOM | Gravity.LEFT;</p>
<p>        lp.setTitle(&quot;SearchPanel&quot;);</p>
<p>        // TODO: Define custom animation for Search panel</p>
<p>        lp.windowAnimations = com.android.internal.R.style.Animation_RecentApplications;</p>
<p>        lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED</p>
<p>                | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING;</p>
<p>        return lp;</p>
<p>    }</p>
<p>    protected void updateRecentsPanel() {</p>
<p>        super.updateRecentsPanel(R.layout.system_bar_recent_panel);</p>
<p>        mRecentsPanel.setStatusBarView(mStatusBarView);</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void updateSearchPanel() {</p>
<p>        super.updateSearchPanel();</p>
<p>        mSearchPanelView.setStatusBarView(mStatusBarView);</p>
<p>        mStatusBarView.setDelegateView(mSearchPanelView);</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void showSearchPanel() {</p>
<p>        super.showSearchPanel();</p>
<p>        WindowManager.LayoutParams lp =</p>
<p>            (android.view.WindowManager.LayoutParams) mStatusBarView.getLayoutParams();</p>
<p>        lp.flags &amp;= ~WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;</p>
<p>        WindowManagerImpl.getDefault().updateViewLayout(mStatusBarView, lp);</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void hideSearchPanel() {</p>
<p>        super.hideSearchPanel();</p>
<p>        WindowManager.LayoutParams lp =</p>
<p>            (android.view.WindowManager.LayoutParams) mStatusBarView.getLayoutParams();</p>
<p>        lp.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;</p>
<p>        WindowManagerImpl.getDefault().updateViewLayout(mStatusBarView, lp);</p>
<p>    }</p>
<p>    public int getStatusBarHeight() {</p>
<p>        return mStatusBarView != null ? mStatusBarView.getHeight()</p>
<p>                : mContext.getResources().getDimensionPixelSize(</p>
<p>                        com.android.internal.R.dimen.navigation_bar_height);</p>
<p>    }</p>
<p>    protected int getStatusBarGravity() {</p>
<p>        return Gravity.BOTTOM | Gravity.FILL_HORIZONTAL;</p>
<p>    }</p>
<p>    public void onBarHeightChanged(int height) {</p>
<p>        final WindowManager.LayoutParams lp</p>
<p>                = (WindowManager.LayoutParams)mStatusBarView.getLayoutParams();</p>
<p>        if (lp == null) {</p>
<p>            // haven’t been added yet</p>
<p>            return;</p>
<p>        }</p>
<p>        if (lp.height != height) {</p>
<p>            lp.height = height;</p>
<p>            final WindowManager wm = WindowManagerImpl.getDefault();</p>
<p>            wm.updateViewLayout(mStatusBarView, lp);</p>
<p>        }</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected BaseStatusBar.H createHandler() {</p>
<p>        return new TabletStatusBar.H();</p>
<p>    }</p>
<p>    private class H extends BaseStatusBar.H {</p>
<p>        public void handleMessage(Message m) {</p>
<p>            super.handleMessage(m);</p>
<p>            switch (m.what) {</p>
<p>                case MSG_OPEN_NOTIFICATION_PEEK:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;opening notification peek window; arg=&quot; + m.arg1);</p>
<p>                    if (m.arg1 &gt;= 0) {</p>
<p>                        final int N = mNotificationData.size();</p>
<p>                        if (!mNotificationDNDMode) {</p>
<p>                            if (mNotificationPeekIndex &gt;= 0 &amp;&amp; mNotificationPeekIndex &lt; N) {</p>
<p>                                NotificationData.Entry entry = mNotificationData.get(N-1-mNotificationPeekIndex);</p>
<p>                                entry.icon.setBackgroundColor(0);</p>
<p>                                mNotificationPeekIndex = -1;</p>
<p>                                mNotificationPeekKey = null;</p>
<p>                            }</p>
<p>                        }</p>
<p>                        final int peekIndex = m.arg1;</p>
<p>                        if (peekIndex &lt; N) {</p>
<p>                            //Slog.d(TAG, &quot;loading peek: &quot; + peekIndex);</p>
<p>                            NotificationData.Entry entry =</p>
<p>                                mNotificationDNDMode</p>
<p>                                    ? mNotificationDNDDummyEntry</p>
<p>                                    : mNotificationData.get(N-1-peekIndex);</p>
<p>                            NotificationData.Entry copy = new NotificationData.Entry(</p>
<p>                                    entry.key,</p>
<p>                                    entry.notification,</p>
<p>                                    entry.icon);</p>
<p>                            inflateViews(copy, mNotificationPeekRow);</p>
<p>                            if (mNotificationDNDMode) {</p>
<p>                                copy.content.setOnClickListener(new View.OnClickListener() {</p>
<p>                                    public void onClick(View v) {</p>
<p>                                        SharedPreferences.Editor editor = Prefs.edit(mContext);</p>
<p>                                        editor.putBoolean(Prefs.DO_NOT_DISTURB_PREF, false);</p>
<p>                                        editor.apply();</p>
<p>                                        animateCollapse();</p>
<p>                                        visibilityChanged(false);</p>
<p>                                    }</p>
<p>                                });</p>
<p>                            }</p>
<p>                            entry.icon.setBackgroundColor(0x20FFFFFF);</p>
<p>//                          mNotificationPeekRow.setLayoutTransition(</p>
<p>//                              peekIndex &lt; mNotificationPeekIndex</p>
<p>//                                  ? mNotificationPeekScrubLeft</p>
<p>//                                  : mNotificationPeekScrubRight);</p>
<p>                            mNotificationPeekRow.removeAllViews();</p>
<p>                            mNotificationPeekRow.addView(copy.row);</p>
<p>                            mNotificationPeekWindow.setVisibility(View.VISIBLE);</p>
<p>                            mNotificationPanel.show(false, true);</p>
<p>                            mNotificationPeekIndex = peekIndex;</p>
<p>                            mNotificationPeekKey = entry.key;</p>
<p>                        }</p>
<p>                    }</p>
<p>                    break;</p>
<p>                case MSG_CLOSE_NOTIFICATION_PEEK:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;closing notification peek window&quot;);</p>
<p>                    mNotificationPeekWindow.setVisibility(View.GONE);</p>
<p>                    mNotificationPeekRow.removeAllViews();</p>
<p>                    final int N = mNotificationData.size();</p>
<p>                    if (mNotificationPeekIndex &gt;= 0 &amp;&amp; mNotificationPeekIndex &lt; N) {</p>
<p>                        NotificationData.Entry entry =</p>
<p>                            mNotificationDNDMode</p>
<p>                                ? mNotificationDNDDummyEntry</p>
<p>                                : mNotificationData.get(N-1-mNotificationPeekIndex);</p>
<p>                        entry.icon.setBackgroundColor(0);</p>
<p>                    }</p>
<p>                    mNotificationPeekIndex = -1;</p>
<p>                    mNotificationPeekKey = null;</p>
<p>                    break;</p>
<p>                case MSG_OPEN_NOTIFICATION_PANEL:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;opening notifications panel&quot;);</p>
<p>                    if (!mNotificationPanel.isShowing()) {</p>
<p>                        mNotificationPanel.show(true, true);</p>
<p>                        mNotificationArea.setVisibility(View.INVISIBLE);</p>
<p>                        mTicker.halt();</p>
<p>                    }</p>
<p>                    break;</p>
<p>                case MSG_CLOSE_NOTIFICATION_PANEL:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;closing notifications panel&quot;);</p>
<p>                    if (mNotificationPanel.isShowing()) {</p>
<p>                        mNotificationPanel.show(false, true);</p>
<p>                        mNotificationArea.setVisibility(View.VISIBLE);</p>
<p>                    }</p>
<p>                    break;</p>
<p>                case MSG_OPEN_INPUT_METHODS_PANEL:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;opening input methods panel&quot;);</p>
<p>                    if (mInputMethodsPanel != null) mInputMethodsPanel.openPanel();</p>
<p>                    break;</p>
<p>                case MSG_CLOSE_INPUT_METHODS_PANEL:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;closing input methods panel&quot;);</p>
<p>                    if (mInputMethodsPanel != null) mInputMethodsPanel.closePanel(false);</p>
<p>                    break;</p>
<p>                case MSG_OPEN_COMPAT_MODE_PANEL:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;opening compat panel&quot;);</p>
<p>                    if (mCompatModePanel != null) mCompatModePanel.openPanel();</p>
<p>                    break;</p>
<p>                case MSG_CLOSE_COMPAT_MODE_PANEL:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;closing compat panel&quot;);</p>
<p>                    if (mCompatModePanel != null) mCompatModePanel.closePanel();</p>
<p>                    break;</p>
<p>                case MSG_SHOW_CHROME:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;hiding shadows (lights on)&quot;);</p>
<p>                    mBarContents.setVisibility(View.VISIBLE);</p>
<p>                    mShadow.setVisibility(View.GONE);</p>
<p>                    mSystemUiVisibility &amp;= ~View.SYSTEM_UI_FLAG_LOW_PROFILE;</p>
<p>                    mStatusBarView.setVisibility(View.VISIBLE);</p>
<p>                    notifyUiVisibilityChanged();</p>
<p>                    break;</p>
<p>                case MSG_HIDE_CHROME:</p>
<p>                    if (DEBUG) Slog.d(TAG, &quot;showing shadows (lights out)&quot;);</p>
<p>                    animateCollapse();</p>
<p>                    visibilityChanged(false);</p>
<p>                    mBarContents.setVisibility(View.GONE);</p>
<p>                    mShadow.setVisibility(View.VISIBLE);</p>
<p>                    mSystemUiVisibility |= View.SYSTEM_UI_FLAG_LOW_PROFILE;</p>
<p>                    if(HIDE_TABLET_STATUSBAR){</p>
<p>                        mStatusBarView.setVisibility(View.GONE);</p>
<p>                    }else{</p>
<p>                        mStatusBarView.setVisibility(View.VISIBLE);</p>
<p>                    }</p>
<p>                    notifyUiVisibilityChanged();</p>
<p>                    break;</p>
<p>                case MSG_STOP_TICKER:</p>
<p>                    mTicker.halt();</p>
<p>                    break;</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    public void addIcon(String slot, int index, int viewIndex, StatusBarIcon icon) {</p>
<p>        if (DEBUG) Slog.d(TAG, &quot;addIcon(&quot; + slot + &quot;) -&gt; &quot; + icon);</p>
<p>    }</p>
<p>    public void updateIcon(String slot, int index, int viewIndex,</p>
<p>            StatusBarIcon old, StatusBarIcon icon) {</p>
<p>        if (DEBUG) Slog.d(TAG, &quot;updateIcon(&quot; + slot + &quot;) -&gt; &quot; + icon);</p>
<p>    }</p>
<p>    public void removeIcon(String slot, int index, int viewIndex) {</p>
<p>        if (DEBUG) Slog.d(TAG, &quot;removeIcon(&quot; + slot + &quot;)&quot;);</p>
<p>    }</p>
<p>    public void addNotification(IBinder key, StatusBarNotification notification) {</p>
<p>        if (DEBUG) Slog.d(TAG, &quot;addNotification(&quot; + key + &quot; -&gt; &quot; + notification + &quot;)&quot;);</p>
<p>        addNotificationViews(key, notification);</p>
<p>        final boolean immersive = isImmersive();</p>
<p>        if (false &amp;&amp; immersive) {</p>
<p>            // TODO: immersive mode popups for tablet</p>
<p>        } else if (notification.notification.fullScreenIntent != null) {</p>
<p>            // not immersive &amp; a full-screen alert should be shown</p>
<p>            Slog.w(TAG, &quot;Notification has fullScreenIntent and activity is not immersive;&quot;</p>
<p>                    + &quot; sending fullScreenIntent&quot;);</p>
<p>            try {</p>
<p>                notification.notification.fullScreenIntent.send();</p>
<p>            } catch (PendingIntent.CanceledException e) {</p>
<p>            }</p>
<p>        } else {</p>
<p>            tick(key, notification, true);</p>
<p>        }</p>
<p>        setAreThereNotifications();</p>
<p>    }</p>
<p>    public void removeNotification(IBinder key) {</p>
<p>        if (DEBUG) Slog.d(TAG, &quot;removeNotification(&quot; + key + &quot;)&quot;);</p>
<p>        removeNotificationViews(key);</p>
<p>        mTicker.remove(key);</p>
<p>        setAreThereNotifications();</p>
<p>    }</p>
<p>    public void showClock(boolean show) {</p>
<p>        View clock = mBarContents.findViewById(R.id.clock);</p>
<p>        View network_text = mBarContents.findViewById(R.id.network_text);</p>
<p>        if (clock != null) {</p>
<p>            clock.setVisibility(show ? View.VISIBLE : View.GONE);</p>
<p>        }</p>
<p>        if (network_text != null) {</p>
<p>            network_text.setVisibility((!show) ? View.VISIBLE : View.GONE);</p>
<p>        }</p>
<p>    }</p>
<p>    public void disable(int state) {</p>
<p>        int old = mDisabled;</p>
<p>        int diff = state ^ old;</p>
<p>        mDisabled = state;</p>
<p>        // act accordingly</p>
<p>        if ((diff &amp; StatusBarManager.DISABLE_CLOCK) != 0) {</p>
<p>            boolean show = (state &amp; StatusBarManager.DISABLE_CLOCK) == 0;</p>
<p>            Slog.i(TAG, &quot;DISABLE_CLOCK: &quot; + (show ? &quot;no&quot; : &quot;yes&quot;));</p>
<p>            showClock(show);</p>
<p>        }</p>
<p>        if ((diff &amp; StatusBarManager.DISABLE_SYSTEM_INFO) != 0) {</p>
<p>            boolean show = (state &amp; StatusBarManager.DISABLE_SYSTEM_INFO) == 0;</p>
<p>            Slog.i(TAG, &quot;DISABLE_SYSTEM_INFO: &quot; + (show ? &quot;no&quot; : &quot;yes&quot;));</p>
<p>            mNotificationTrigger.setVisibility(show ? View.VISIBLE : View.GONE);</p>
<p>        }</p>
<p>        if ((diff &amp; StatusBarManager.DISABLE_EXPAND) != 0) {</p>
<p>            if ((state &amp; StatusBarManager.DISABLE_EXPAND) != 0) {</p>
<p>                Slog.i(TAG, &quot;DISABLE_EXPAND: yes&quot;);</p>
<p>                animateCollapse();</p>
<p>                visibilityChanged(false);</p>
<p>            }</p>
<p>        }</p>
<p>        if ((diff &amp; StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {</p>
<p>            mNotificationDNDMode = Prefs.read(mContext)</p>
<p>                        .getBoolean(Prefs.DO_NOT_DISTURB_PREF, Prefs.DO_NOT_DISTURB_DEFAULT);</p>
<p>            if ((state &amp; StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {</p>
<p>                Slog.i(TAG, &quot;DISABLE_NOTIFICATION_ICONS: yes&quot; + (mNotificationDNDMode?&quot; (DND)&quot;:&quot;&quot;));</p>
<p>                mTicker.halt();</p>
<p>            } else {</p>
<p>                Slog.i(TAG, &quot;DISABLE_NOTIFICATION_ICONS: no&quot; + (mNotificationDNDMode?&quot; (DND)&quot;:&quot;&quot;));</p>
<p>            }</p>
<p>            // refresh icons to show either notifications or the DND message</p>
<p>            reloadAllNotificationIcons();</p>
<p>        } else if ((diff &amp; StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) {</p>
<p>            if ((state &amp; StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) {</p>
<p>                mTicker.halt();</p>
<p>            }</p>
<p>        }</p>
<p>        if ((diff &amp; (StatusBarManager.DISABLE_RECENT</p>
<p>                        | StatusBarManager.DISABLE_BACK</p>
<p>                        | StatusBarManager.DISABLE_HOME)) != 0) {</p>
<p>            setNavigationVisibility(state);</p>
<p>            if ((state &amp; StatusBarManager.DISABLE_RECENT) != 0) {</p>
<p>                // close recents if it’s visible</p>
<p>                mHandler.removeMessages(MSG_CLOSE_RECENTS_PANEL);</p>
<p>                mHandler.sendEmptyMessage(MSG_CLOSE_RECENTS_PANEL);</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    private void setNavigationVisibility(int visibility) {</p>
<p>        boolean disableHome = ((visibility &amp; StatusBarManager.DISABLE_HOME) != 0);</p>
<p>        boolean disableRecent = ((visibility &amp; StatusBarManager.DISABLE_RECENT) != 0);</p>
<p>        boolean disableBack = ((visibility &amp; StatusBarManager.DISABLE_BACK) != 0);</p>
<p>        mBackButton.setVisibility(disableBack ? View.INVISIBLE : View.VISIBLE);</p>
<p>        mHomeButton.setVisibility(disableHome ? View.INVISIBLE : View.VISIBLE);</p>
<p>        mRecentButton.setVisibility(disableRecent ? View.INVISIBLE : View.VISIBLE);</p>
<p>if((&quot;true&quot;.equals(isEnableShowVoiceIcon)) &amp;&amp; (mContext.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE)){</p>
<p>mVolumeUpButton.setVisibility(disableRecent ? View.INVISIBLE : View.VISIBLE);</p>
<p>mVolumeDownButton.setVisibility(disableRecent ? View.INVISIBLE : View.VISIBLE);</p>
<p>}</p>
<p>if(Settings.System.getInt(mContext.getContentResolver(),</p>
<p>                        Settings.System.SCREENSHOT_BUTTON_SHOW, 0)==1){</p>
<p>             mScreenshot.setVisibility(disableRecent ? View.INVISIBLE : View.VISIBLE);</p>
<p>}</p>
<p>        mInputMethodSwitchButton.setScreenLocked(</p>
<p>                (visibility &amp; StatusBarManager.DISABLE_SYSTEM_INFO) != 0);</p>
<p>    }</p>
<p>    private boolean hasTicker(Notification n) {</p>
<p>        return n.tickerView != null || !TextUtils.isEmpty(n.tickerText);</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void tick(IBinder key, StatusBarNotification n, boolean firstTime) {</p>
<p>        // Don’t show the ticker when the windowshade is open.</p>
<p>        if (mNotificationPanel.isShowing()) {</p>
<p>            return;</p>
<p>        }</p>
<p>        // If they asked for FLAG_ONLY_ALERT_ONCE, then only show this notification</p>
<p>        // if it’s a new notification.</p>
<p>        if (!firstTime &amp;&amp; (n.notification.flags &amp; Notification.FLAG_ONLY_ALERT_ONCE) != 0) {</p>
<p>            return;</p>
<p>        }</p>
<p>        // Show the ticker if one is requested. Also don’t do this</p>
<p>        // until status bar window is attached to the window manager,</p>
<p>        // because…  well, what’s the point otherwise?  And trying to</p>
<p>        // run a ticker without being attached will crash!</p>
<p>        if (hasTicker(n.notification) &amp;&amp; mStatusBarView.getWindowToken() != null) {</p>
<p>            if (0 == (mDisabled &amp; (StatusBarManager.DISABLE_NOTIFICATION_ICONS</p>
<p>                            | StatusBarManager.DISABLE_NOTIFICATION_TICKER))) {</p>
<p>                mTicker.add(key, n);</p>
<p>                mFeedbackIconArea.setVisibility(View.GONE);</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    // called by TabletTicker when it’s done with all queued ticks</p>
<p>    public void doneTicking() {</p>
<p>        mFeedbackIconArea.setVisibility(View.VISIBLE);</p>
<p>    }</p>
<p>    public void animateExpand() {</p>
<p>        mHandler.removeMessages(MSG_OPEN_NOTIFICATION_PANEL);</p>
<p>        mHandler.sendEmptyMessage(MSG_OPEN_NOTIFICATION_PANEL);</p>
<p>    }</p>
<p>    public void animateCollapse() {</p>
<p>        animateCollapse(CommandQueue.FLAG_EXCLUDE_NONE);</p>
<p>    }</p>
<p>    public void animateCollapse(int flags) {</p>
<p>        if ((flags &amp; CommandQueue.FLAG_EXCLUDE_NOTIFICATION_PANEL) == 0) {</p>
<p>            mHandler.removeMessages(MSG_CLOSE_NOTIFICATION_PANEL);</p>
<p>            mHandler.sendEmptyMessage(MSG_CLOSE_NOTIFICATION_PANEL);</p>
<p>        }</p>
<p>        if ((flags &amp; CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL) == 0) {</p>
<p>            mHandler.removeMessages(MSG_CLOSE_RECENTS_PANEL);</p>
<p>            mHandler.sendEmptyMessage(MSG_CLOSE_RECENTS_PANEL);</p>
<p>        }</p>
<p>        if ((flags &amp; CommandQueue.FLAG_EXCLUDE_SEARCH_PANEL) == 0) {</p>
<p>            mHandler.removeMessages(MSG_CLOSE_SEARCH_PANEL);</p>
<p>            mHandler.sendEmptyMessage(MSG_CLOSE_SEARCH_PANEL);</p>
<p>        }</p>
<p>        if ((flags &amp; CommandQueue.FLAG_EXCLUDE_INPUT_METHODS_PANEL) == 0) {</p>
<p>            mHandler.removeMessages(MSG_CLOSE_INPUT_METHODS_PANEL);</p>
<p>            mHandler.sendEmptyMessage(MSG_CLOSE_INPUT_METHODS_PANEL);</p>
<p>        }</p>
<p>        if ((flags &amp; CommandQueue.FLAG_EXCLUDE_COMPAT_MODE_PANEL) == 0) {</p>
<p>            mHandler.removeMessages(MSG_CLOSE_COMPAT_MODE_PANEL);</p>
<p>            mHandler.sendEmptyMessage(MSG_CLOSE_COMPAT_MODE_PANEL);</p>
<p>        }</p>
<p>    }</p>
<p>    @Override // CommandQueue</p>
<p>    public void setNavigationIconHints(int hints) {</p>
<p>        if (hints == mNavigationIconHints) return;</p>
<p>        if (DEBUG) {</p>
<p>            android.widget.Toast.makeText(mContext,</p>
<p>                &quot;Navigation icon hints = &quot; + hints,</p>
<p>                500).show();</p>
<p>        }</p>
<p>        mNavigationIconHints = hints;</p>
<p>        mBackButton.setAlpha(</p>
<p>            (0 != (hints &amp; StatusBarManager.NAVIGATION_HINT_BACK_NOP)) ? 0.5f : 1.0f);</p>
<p>        mHomeButton.setAlpha(</p>
<p>            (0 != (hints &amp; StatusBarManager.NAVIGATION_HINT_HOME_NOP)) ? 0.5f : 1.0f);</p>
<p>        mRecentButton.setAlpha(</p>
<p>            (0 != (hints &amp; StatusBarManager.NAVIGATION_HINT_RECENT_NOP)) ? 0.5f : 1.0f);</p>
<p>        mBackButton.setImageResource(</p>
<p>            (0 != (hints &amp; StatusBarManager.NAVIGATION_HINT_BACK_ALT))</p>
<p>                ? R.drawable.ic_sysbar_back_ime</p>
<p>                : R.drawable.ic_sysbar_back);</p>
<p>    }</p>
<p>    private void notifyUiVisibilityChanged() {</p>
<p>        try {</p>
<p>            mWindowManager.statusBarVisibilityChanged(mSystemUiVisibility);</p>
<p>        } catch (RemoteException ex) {</p>
<p>        }</p>
<p>    }</p>
<p>    @Override // CommandQueue</p>
<p>    public void setSystemUiVisibility(int vis, int mask) {</p>
<p>       // final int oldVal = mSystemUiVisibility;</p>
<p>       // final int newVal = (oldVal&amp;~mask) | (vis&amp;mask);</p>
<p>      //  final int diff = newVal ^ oldVal;</p>
<p>          if (vis != mSystemUiVisibility) {</p>
<p>            mSystemUiVisibility = vis;</p>
<p>           // if (0 != (diff &amp; View.SYSTEM_UI_FLAG_LOW_PROFILE)) {</p>
<p>                mHandler.removeMessages(MSG_HIDE_CHROME);</p>
<p>                mHandler.removeMessages(MSG_SHOW_CHROME);</p>
<p>                int fs = vis &amp; View.SYSTEM_UI_FLAG_SHOW_FULLSCREEN;</p>
<p>                int lp =  vis &amp; View.SYSTEM_UI_FLAG_LOW_PROFILE;</p>
<p>                if(fs != 0){</p>
<p>                     HIDE_TABLET_STATUSBAR = true;</p>
<p>                }else{</p>
<p>                     HIDE_TABLET_STATUSBAR = false;</p>
<p>                }</p>
<p>                mHandler.sendEmptyMessage((lp!=0||fs != 0) ? MSG_HIDE_CHROME : MSG_SHOW_CHROME);</p>
<p>          //  }</p>
<p>            notifyUiVisibilityChanged();</p>
<p>        }</p>
<p>    }</p>
<p>    public void setLightsOn(boolean on) {</p>
<p>        // Policy note: if the frontmost activity needs the menu key, we assume it is a legacy app</p>
<p>        // that can’t handle lights-out mode.</p>
<p>        if (mMenuButton.getVisibility() == View.VISIBLE) {</p>
<p>            on = true;</p>
<p>        }</p>
<p>        Slog.v(TAG, &quot;setLightsOn(&quot; + on + &quot;)&quot;);</p>
<p>        if (on) {</p>
<p>            setSystemUiVisibility(0, View.SYSTEM_UI_FLAG_LOW_PROFILE);</p>
<p>        } else {</p>
<p>            setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE, View.SYSTEM_UI_FLAG_LOW_PROFILE);</p>
<p>        }</p>
<p>    }</p>
<p>    public void topAppWindowChanged(boolean showMenu) {</p>
<p>        if (DEBUG) {</p>
<p>            Slog.d(TAG, (showMenu?&quot;showing&quot;:&quot;hiding&quot;) + &quot; the MENU button&quot;);</p>
<p>        }</p>
<p>        mMenuButton.setVisibility(showMenu ? View.VISIBLE : View.GONE);</p>
<p>        // See above re: lights-out policy for legacy apps.</p>
<p>        if (showMenu) setLightsOn(true);</p>
<p>        mCompatModeButton.refresh();</p>
<p>        if (mCompatModeButton.getVisibility() == View.VISIBLE) {</p>
<p>            if (DEBUG_COMPAT_HELP</p>
<p>                    || ! Prefs.read(mContext).getBoolean(Prefs.SHOWN_COMPAT_MODE_HELP, false)) {</p>
<p>                showCompatibilityHelp();</p>
<p>            }</p>
<p>        } else {</p>
<p>            hideCompatibilityHelp();</p>
<p>            mCompatModePanel.closePanel();</p>
<p>        }</p>
<p>    }</p>
<p>    private void showCompatibilityHelp() {</p>
<p>        if (mCompatibilityHelpDialog != null) {</p>
<p>            return;</p>
<p>        }</p>
<p>        mCompatibilityHelpDialog = View.inflate(mContext, R.layout.compat_mode_help, null);</p>
<p>        View button = mCompatibilityHelpDialog.findViewById(R.id.button);</p>
<p>        button.setOnClickListener(new View.OnClickListener() {</p>
<p>            @Override</p>
<p>            public void onClick(View v) {</p>
<p>                hideCompatibilityHelp();</p>
<p>                SharedPreferences.Editor editor = Prefs.edit(mContext);</p>
<p>                editor.putBoolean(Prefs.SHOWN_COMPAT_MODE_HELP, true);</p>
<p>                editor.apply();</p>
<p>            }</p>
<p>        });</p>
<p>        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(</p>
<p>                ViewGroup.LayoutParams.MATCH_PARENT,</p>
<p>                ViewGroup.LayoutParams.MATCH_PARENT,</p>
<p>                WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG,</p>
<p>                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN</p>
<p>                    | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS</p>
<p>                    | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,</p>
<p>                PixelFormat.TRANSLUCENT);</p>
<p>        lp.setTitle(&quot;CompatibilityModeDialog&quot;);</p>
<p>        lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED</p>
<p>                | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING;</p>
<p>        lp.windowAnimations = com.android.internal.R.style.Animation_ZoomButtons; // simple fade</p>
<p>        WindowManagerImpl.getDefault().addView(mCompatibilityHelpDialog, lp);</p>
<p>    }</p>
<p>    private void hideCompatibilityHelp() {</p>
<p>        if (mCompatibilityHelpDialog != null) {</p>
<p>            WindowManagerImpl.getDefault().removeView(mCompatibilityHelpDialog);</p>
<p>            mCompatibilityHelpDialog = null;</p>
<p>        }</p>
<p>    }</p>
<p>    public void setImeWindowStatus(IBinder token, int vis, int backDisposition) {</p>
<p>        mInputMethodSwitchButton.setImeWindowStatus(token,</p>
<p>                (vis &amp; InputMethodService.IME_ACTIVE) != 0);</p>
<p>        updateNotificationIcons();</p>
<p>        mInputMethodsPanel.setImeToken(token);</p>
<p>        boolean altBack = (backDisposition == InputMethodService.BACK_DISPOSITION_WILL_DISMISS)</p>
<p>            || ((vis &amp; InputMethodService.IME_VISIBLE) != 0);</p>
<p>        mAltBackButtonEnabledForIme = altBack;</p>
<p>        mCommandQueue.setNavigationIconHints(</p>
<p>                altBack ? (mNavigationIconHints | StatusBarManager.NAVIGATION_HINT_BACK_ALT)</p>
<p>                        : (mNavigationIconHints &amp; ~StatusBarManager.NAVIGATION_HINT_BACK_ALT));</p>
<p>        if (FAKE_SPACE_BAR) {</p>
<p>            mFakeSpaceBar.setVisibility(((vis &amp; InputMethodService.IME_VISIBLE) != 0)</p>
<p>                    ? View.VISIBLE : View.GONE);</p>
<p>        }</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void onRecentsPanelVisibilityChanged(boolean visible) {</p>
<p>        boolean altBack = visible || mAltBackButtonEnabledForIme;</p>
<p>        mCommandQueue.setNavigationIconHints(</p>
<p>                altBack ? (mNavigationIconHints | StatusBarManager.NAVIGATION_HINT_BACK_ALT)</p>
<p>                        : (mNavigationIconHints &amp; ~StatusBarManager.NAVIGATION_HINT_BACK_ALT));</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void setHardKeyboardStatus(boolean available, boolean enabled) {</p>
<p>        if (DEBUG) {</p>
<p>            Slog.d(TAG, &quot;Set hard keyboard status: available=&quot; + available</p>
<p>                    + &quot;, enabled=&quot; + enabled);</p>
<p>        }</p>
<p>        mInputMethodSwitchButton.setHardKeyboardStatus(available);</p>
<p>        updateNotificationIcons();</p>
<p>        mInputMethodsPanel.setHardKeyboardStatus(available, enabled);</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void onHardKeyboardEnabledChange(boolean enabled) {</p>
<p>        try {</p>
<p>            mBarService.setHardKeyboardEnabled(enabled);</p>
<p>        } catch (RemoteException ex) {</p>
<p>        }</p>
<p>    }</p>
<p>    private boolean isImmersive() {</p>
<p>        try {</p>
<p>            return ActivityManagerNative.getDefault().isTopActivityImmersive();</p>
<p>            //Slog.d(TAG, &quot;Top activity is &quot; + (immersive?&quot;immersive&quot;:&quot;not immersive&quot;));</p>
<p>        } catch (RemoteException ex) {</p>
<p>            // the end is nigh</p>
<p>            return false;</p>
<p>        }</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void setAreThereNotifications() {</p>
<p>        if (mNotificationPanel != null) {</p>
<p>            mNotificationPanel.setClearable(isDeviceProvisioned() &amp;&amp; mNotificationData.hasClearableItems());</p>
<p>        }</p>
<p>    }</p>
<p>    private View.OnClickListener mOnClickListener = new View.OnClickListener() {</p>
<p>        public void onClick(View v) {</p>
<p>            if (v == mRecentButton) {</p>
<p>                onClickRecentButton();</p>
<p>            } else if (v == mInputMethodSwitchButton) {</p>
<p>                onClickInputMethodSwitchButton();</p>
<p>            } else if (v == mCompatModeButton) {</p>
<p>                onClickCompatModeButton();</p>
<p>            }</p>
<p>        }</p>
<p>    };</p>
<p>    public void onClickRecentButton() {</p>
<p>        if (DEBUG) Slog.d(TAG, &quot;clicked recent apps; disabled=&quot; + mDisabled);</p>
<p>        if ((mDisabled &amp; StatusBarManager.DISABLE_EXPAND) == 0) {</p>
<p>            int msg = (mRecentsPanel.getVisibility() == View.VISIBLE)</p>
<p>                ? MSG_CLOSE_RECENTS_PANEL : MSG_OPEN_RECENTS_PANEL;</p>
<p>            mHandler.removeMessages(msg);</p>
<p>            mHandler.sendEmptyMessage(msg);</p>
<p>        }</p>
<p>    }</p>
<p>    public void onClickInputMethodSwitchButton() {</p>
<p>        if (DEBUG) Slog.d(TAG, &quot;clicked input methods panel; disabled=&quot; + mDisabled);</p>
<p>        int msg = (mInputMethodsPanel.getVisibility() == View.GONE) ?</p>
<p>                MSG_OPEN_INPUT_METHODS_PANEL : MSG_CLOSE_INPUT_METHODS_PANEL;</p>
<p>        mHandler.removeMessages(msg);</p>
<p>        mHandler.sendEmptyMessage(msg);</p>
<p>    }</p>
<p>    public void onClickCompatModeButton() {</p>
<p>        int msg = (mCompatModePanel.getVisibility() == View.GONE) ?</p>
<p>                MSG_OPEN_COMPAT_MODE_PANEL : MSG_CLOSE_COMPAT_MODE_PANEL;</p>
<p>        mHandler.removeMessages(msg);</p>
<p>        mHandler.sendEmptyMessage(msg);</p>
<p>    }</p>
<p>    private class NotificationTriggerTouchListener implements View.OnTouchListener {</p>
<p>        VelocityTracker mVT;</p>
<p>        float mInitialTouchX, mInitialTouchY;</p>
<p>        int mTouchSlop;</p>
<p>        public NotificationTriggerTouchListener() {</p>
<p>            mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();</p>
<p>        }</p>
<p>        private Runnable mHiliteOnR = new Runnable() { public void run() {</p>
<p>            mNotificationArea.setBackgroundResource(</p>
<p>                com.android.internal.R.drawable.list_selector_pressed_holo_dark);</p>
<p>        }};</p>
<p>        public void hilite(final boolean on) {</p>
<p>            if (on) {</p>
<p>                mNotificationArea.postDelayed(mHiliteOnR, 100);</p>
<p>            } else {</p>
<p>                mNotificationArea.removeCallbacks(mHiliteOnR);</p>
<p>                mNotificationArea.setBackgroundDrawable(null);</p>
<p>            }</p>
<p>        }</p>
<p>        public boolean onTouch(View v, MotionEvent event) {</p>
<p>//            Slog.d(TAG, String.format(&quot;touch: (%.1f, %.1f) initial: (%.1f, %.1f)&quot;,</p>
<p>//                        event.getX(),</p>
<p>//                        event.getY(),</p>
<p>//                        mInitialTouchX,</p>
<p>//                        mInitialTouchY));</p>
<p>            if ((mDisabled &amp; StatusBarManager.DISABLE_EXPAND) != 0) {</p>
<p>                return true;</p>
<p>            }</p>
<p>            final int action = event.getAction();</p>
<p>            switch (action) {</p>
<p>                case MotionEvent.ACTION_DOWN:</p>
<p>                    mVT = VelocityTracker.obtain();</p>
<p>                    mInitialTouchX = event.getX();</p>
<p>                    mInitialTouchY = event.getY();</p>
<p>                    hilite(true);</p>
<p>                    // fall through</p>
<p>                case MotionEvent.ACTION_OUTSIDE:</p>
<p>                case MotionEvent.ACTION_MOVE:</p>
<p>                    // check for fling</p>
<p>                    if (mVT != null) {</p>
<p>                        mVT.addMovement(event);</p>
<p>                        mVT.computeCurrentVelocity(1000); // pixels per second</p>
<p>                        // require a little more oomph once we’re already in peekaboo mode</p>
<p>                        if (mVT.getYVelocity() &lt; -mNotificationFlingVelocity) {</p>
<p>                            animateExpand();</p>
<p>                            visibilityChanged(true);</p>
<p>                            hilite(false);</p>
<p>                            mVT.recycle();</p>
<p>                            mVT = null;</p>
<p>                        }</p>
<p>                    }</p>
<p>                    return true;</p>
<p>                case MotionEvent.ACTION_UP:</p>
<p>                case MotionEvent.ACTION_CANCEL:</p>
<p>                    hilite(false);</p>
<p>                    if (mVT != null) {</p>
<p>                        if (action == MotionEvent.ACTION_UP</p>
<p>                         // was this a sloppy tap?</p>
<p>                         &amp;&amp; Math.abs(event.getX() - mInitialTouchX) &lt; mTouchSlop</p>
<p>                         &amp;&amp; Math.abs(event.getY() - mInitialTouchY) &lt; (mTouchSlop / 3)</p>
<p>                         // dragging off the bottom doesn’t count</p>
<p>                         &amp;&amp; (int)event.getY() &lt; v.getBottom()) {</p>
<p>                            animateExpand();</p>
<p>                            visibilityChanged(true);</p>
<p>                            v.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</p>
<p>                            v.playSoundEffect(SoundEffectConstants.CLICK);</p>
<p>                        }</p>
<p>                        mVT.recycle();</p>
<p>                        mVT = null;</p>
<p>                        return true;</p>
<p>                    }</p>
<p>            }</p>
<p>            return false;</p>
<p>        }</p>
<p>    }</p>
<p>    public void resetNotificationPeekFadeTimer() {</p>
<p>        if (DEBUG) {</p>
<p>            Slog.d(TAG, &quot;setting peek fade timer for &quot; + NOTIFICATION_PEEK_FADE_DELAY</p>
<p>                + &quot;ms from now&quot;);</p>
<p>        }</p>
<p>        mHandler.removeMessages(MSG_CLOSE_NOTIFICATION_PEEK);</p>
<p>        mHandler.sendEmptyMessageDelayed(MSG_CLOSE_NOTIFICATION_PEEK,</p>
<p>                NOTIFICATION_PEEK_FADE_DELAY);</p>
<p>    }</p>
<p>    private class NotificationIconTouchListener implements View.OnTouchListener {</p>
<p>        VelocityTracker mVT;</p>
<p>        int mPeekIndex;</p>
<p>        float mInitialTouchX, mInitialTouchY;</p>
<p>        int mTouchSlop;</p>
<p>        public NotificationIconTouchListener() {</p>
<p>            mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();</p>
<p>        }</p>
<p>        public boolean onTouch(View v, MotionEvent event) {</p>
<p>            boolean peeking = mNotificationPeekWindow.getVisibility() != View.GONE;</p>
<p>            boolean panelShowing = mNotificationPanel.isShowing();</p>
<p>            if (panelShowing) return false;</p>
<p>            int numIcons = mIconLayout.getChildCount();</p>
<p>            int newPeekIndex = (int)(event.getX() * numIcons / mIconLayout.getWidth());</p>
<p>            if (newPeekIndex &gt; numIcons - 1) newPeekIndex = numIcons - 1;</p>
<p>            else if (newPeekIndex &lt; 0) newPeekIndex = 0;</p>
<p>            final int action = event.getAction();</p>
<p>            switch (action) {</p>
<p>                case MotionEvent.ACTION_DOWN:</p>
<p>                    mVT = VelocityTracker.obtain();</p>
<p>                    mInitialTouchX = event.getX();</p>
<p>                    mInitialTouchY = event.getY();</p>
<p>                    mPeekIndex = -1;</p>
<p>                    // fall through</p>
<p>                case MotionEvent.ACTION_OUTSIDE:</p>
<p>                case MotionEvent.ACTION_MOVE:</p>
<p>                    // peek and switch icons if necessary</p>
<p>                    if (newPeekIndex != mPeekIndex) {</p>
<p>                        mPeekIndex = newPeekIndex;</p>
<p>                        if (DEBUG) Slog.d(TAG, &quot;will peek at notification #&quot; + mPeekIndex);</p>
<p>                        Message peekMsg = mHandler.obtainMessage(MSG_OPEN_NOTIFICATION_PEEK);</p>
<p>                        peekMsg.arg1 = mPeekIndex;</p>
<p>                        mHandler.removeMessages(MSG_OPEN_NOTIFICATION_PEEK);</p>
<p>                        if (peeking) {</p>
<p>                            // no delay if we’re scrubbing left-right</p>
<p>                            mHandler.sendMessage(peekMsg);</p>
<p>                        } else {</p>
<p>                            // wait for fling</p>
<p>                            mHandler.sendMessageDelayed(peekMsg, NOTIFICATION_PEEK_HOLD_THRESH);</p>
<p>                        }</p>
<p>                    }</p>
<p>                    // check for fling</p>
<p>                    if (mVT != null) {</p>
<p>                        mVT.addMovement(event);</p>
<p>                        mVT.computeCurrentVelocity(1000); // pixels per second</p>
<p>                        // require a little more oomph once we’re already in peekaboo mode</p>
<p>                        if (!panelShowing &amp;&amp; (</p>
<p>                               (peeking &amp;&amp; mVT.getYVelocity() &lt; -mNotificationFlingVelocity*3)</p>
<p>                            || (mVT.getYVelocity() &lt; -mNotificationFlingVelocity))) {</p>
<p>                            mHandler.removeMessages(MSG_OPEN_NOTIFICATION_PEEK);</p>
<p>                            mHandler.removeMessages(MSG_OPEN_NOTIFICATION_PANEL);</p>
<p>                            mHandler.sendEmptyMessage(MSG_CLOSE_NOTIFICATION_PEEK);</p>
<p>                            mHandler.sendEmptyMessage(MSG_OPEN_NOTIFICATION_PANEL);</p>
<p>                        }</p>
<p>                    }</p>
<p>                    return true;</p>
<p>                case MotionEvent.ACTION_UP:</p>
<p>                case MotionEvent.ACTION_CANCEL:</p>
<p>                    mHandler.removeMessages(MSG_OPEN_NOTIFICATION_PEEK);</p>
<p>                    if (!peeking) {</p>
<p>                        if (action == MotionEvent.ACTION_UP</p>
<p>                                // was this a sloppy tap?</p>
<p>                                &amp;&amp; Math.abs(event.getX() - mInitialTouchX) &lt; mTouchSlop</p>
<p>                                &amp;&amp; Math.abs(event.getY() - mInitialTouchY) &lt; (mTouchSlop / 3)</p>
<p>                                // dragging off the bottom doesn’t count</p>
<p>                                &amp;&amp; (int)event.getY() &lt; v.getBottom()) {</p>
<p>                            Message peekMsg = mHandler.obtainMessage(MSG_OPEN_NOTIFICATION_PEEK);</p>
<p>                            peekMsg.arg1 = mPeekIndex;</p>
<p>                            mHandler.removeMessages(MSG_OPEN_NOTIFICATION_PEEK);</p>
<p>                            mHandler.sendMessage(peekMsg);</p>
<p>                            v.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</p>
<p>                            v.playSoundEffect(SoundEffectConstants.CLICK);</p>
<p>                            peeking = true; // not technically true yet, but the next line will run</p>
<p>                        }</p>
<p>                    }</p>
<p>                    if (peeking) {</p>
<p>                        resetNotificationPeekFadeTimer();</p>
<p>                    }</p>
<p>                    mVT.recycle();</p>
<p>                    mVT = null;</p>
<p>                    return true;</p>
<p>            }</p>
<p>            return false;</p>
<p>        }</p>
<p>    }</p>
<p>    private void reloadAllNotificationIcons() {</p>
<p>        if (mIconLayout == null) return;</p>
<p>        mIconLayout.removeAllViews();</p>
<p>        updateNotificationIcons();</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void updateNotificationIcons() {</p>
<p>        // XXX: need to implement a new limited linear layout class</p>
<p>        // to avoid removing &amp; readding everything</p>
<p>        if (mIconLayout == null) return;</p>
<p>        // first, populate the main notification panel</p>
<p>        loadNotificationPanel();</p>
<p>        final LinearLayout.LayoutParams params</p>
<p>            = new LinearLayout.LayoutParams(mIconSize + 2*mIconHPadding, mNaturalBarHeight);</p>
<p>        // alternate behavior in DND mode</p>
<p>        if (mNotificationDNDMode) {</p>
<p>            if (mIconLayout.getChildCount() == 0) {</p>
<p>                final Notification dndNotification = new Notification.Builder(mContext)</p>
<p>                    .setContentTitle(mContext.getText(R.string.notifications_off_title))</p>
<p>                    .setContentText(mContext.getText(R.string.notifications_off_text))</p>
<p>                    .setSmallIcon(R.drawable.ic_notification_dnd)</p>
<p>                    .setOngoing(true)</p>
<p>                    .getNotification();</p>
<p>                final StatusBarIconView iconView = new StatusBarIconView(mContext, &quot;_dnd&quot;,</p>
<p>                        dndNotification);</p>
<p>                iconView.setImageResource(R.drawable.ic_notification_dnd);</p>
<p>                iconView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);</p>
<p>                iconView.setPadding(mIconHPadding, 0, mIconHPadding, 0);</p>
<p>                mNotificationDNDDummyEntry = new NotificationData.Entry(</p>
<p>                        null,</p>
<p>                        new StatusBarNotification(&quot;&quot;, 0, &quot;&quot;, 0, 0, Notification.PRIORITY_MAX, dndNotification),</p>
<p>                        iconView);</p>
<p>                mIconLayout.addView(iconView, params);</p>
<p>            }</p>
<p>            return;</p>
<p>        } else if (0 != (mDisabled &amp; StatusBarManager.DISABLE_NOTIFICATION_ICONS)) {</p>
<p>            // if icons are disabled but we’re not in DND mode, this is probably Setup and we should</p>
<p>            // just leave the area totally empty</p>
<p>            return;</p>
<p>        }</p>
<p>        int N = mNotificationData.size();</p>
<p>        if (DEBUG) {</p>
<p>            Slog.d(TAG, &quot;refreshing icons: &quot; + N + &quot; notifications, mIconLayout=&quot; + mIconLayout);</p>
<p>        }</p>
<p>        ArrayList&lt;View&gt; toShow = new ArrayList&lt;View&gt;();</p>
<p>        // Extra Special Icons</p>
<p>        // The IME switcher and compatibility mode icons take the place of notifications. You didn’t</p>
<p>        // need to see all those new emails, did you?</p>
<p>        int maxNotificationIconsCount = mMaxNotificationIcons;</p>
<p>        if (mInputMethodSwitchButton.getVisibility() != View.GONE) maxNotificationIconsCount –;</p>
<p>        if (mCompatModeButton.getVisibility()        != View.GONE) maxNotificationIconsCount –;</p>
<p>        final boolean provisioned = isDeviceProvisioned();</p>
<p>        // If the device hasn’t been through Setup, we only show system notifications</p>
<p>        for (int i=0; toShow.size()&lt; maxNotificationIconsCount; i++) {</p>
<p>            if (i &gt;= N) break;</p>
<p>            Entry ent = mNotificationData.get(N-i-1);</p>
<p>            if ((provisioned &amp;&amp; ent.notification.score &gt;= HIDE_ICONS_BELOW_SCORE)</p>
<p>                    || showNotificationEvenIfUnprovisioned(ent.notification)) {</p>
<p>                toShow.add(ent.icon);</p>
<p>            }</p>
<p>        }</p>
<p>        ArrayList&lt;View&gt; toRemove = new ArrayList&lt;View&gt;();</p>
<p>        for (int i=0; i&lt;mIconLayout.getChildCount(); i++) {</p>
<p>            View child = mIconLayout.getChildAt(i);</p>
<p>            if (!toShow.contains(child)) {</p>
<p>                toRemove.add(child);</p>
<p>            }</p>
<p>        }</p>
<p>        for (View remove : toRemove) {</p>
<p>            mIconLayout.removeView(remove);</p>
<p>        }</p>
<p>        for (int i=0; i&lt;toShow.size(); i++) {</p>
<p>            View v = toShow.get(i);</p>
<p>            v.setPadding(mIconHPadding, 0, mIconHPadding, 0);</p>
<p>            if (v.getParent() == null) {</p>
<p>                mIconLayout.addView(v, i, params);</p>
<p>            }</p>
<p>        }</p>
<p>        if(toShow.size()&gt;0)</p>
<p>        {</p>
<p>            mFeedbackIconArea.setVisibility(View.VISIBLE);</p>
<p>        }</p>
<p>    }</p>
<p>    private void loadNotificationPanel() {</p>
<p>        int N = mNotificationData.size();</p>
<p>        ArrayList&lt;View&gt; toShow = new ArrayList&lt;View&gt;();</p>
<p>        final boolean provisioned = isDeviceProvisioned();</p>
<p>        // If the device hasn’t been through Setup, we only show system notifications</p>
<p>        for (int i=0; i&lt;N; i++) {</p>
<p>            Entry ent = mNotificationData.get(N-i-1);</p>
<p>            if (provisioned || showNotificationEvenIfUnprovisioned(ent.notification)) {</p>
<p>                toShow.add(ent.row);</p>
<p>            }</p>
<p>        }</p>
<p>        ArrayList&lt;View&gt; toRemove = new ArrayList&lt;View&gt;();</p>
<p>        for (int i=0; i&lt;mPile.getChildCount(); i++) {</p>
<p>            View child = mPile.getChildAt(i);</p>
<p>            if (!toShow.contains(child)) {</p>
<p>                toRemove.add(child);</p>
<p>            }</p>
<p>        }</p>
<p>        for (View remove : toRemove) {</p>
<p>            mPile.removeView(remove);</p>
<p>        }</p>
<p>        for (int i=0; i&lt;toShow.size(); i++) {</p>
<p>            View v = toShow.get(i);</p>
<p>            if (v.getParent() == null) {</p>
<p>                // the notification panel has the most important things at the bottom</p>
<p>                mPile.addView(v, Math.min(toShow.size()-1-i, mPile.getChildCount()));</p>
<p>            }</p>
<p>        }</p>
<p>        mNotificationPanel.setNotificationCount(toShow.size());</p>
<p>        mNotificationPanel.setSettingsEnabled(isDeviceProvisioned());</p>
<p>        mNotificationPanel.updatePanelModeButtons();</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void workAroundBadLayerDrawableOpacity(View v) {</p>
<p>        Drawable bgd = v.getBackground();</p>
<p>        if (!(bgd instanceof LayerDrawable)) return;</p>
<p>        LayerDrawable d = (LayerDrawable) bgd;</p>
<p>        v.setBackgroundDrawable(null);</p>
<p>        d.setOpacity(PixelFormat.TRANSLUCENT);</p>
<p>        v.setBackgroundDrawable(d);</p>
<p>    }</p>
<p>    public void clearAll() {</p>
<p>        try {</p>
<p>            mBarService.onClearAllNotifications();</p>
<p>        } catch (RemoteException ex) {</p>
<p>            // system process is dead if we’re here.</p>
<p>        }</p>
<p>        animateCollapse();</p>
<p>        visibilityChanged(false);</p>
<p>    }</p>
<p>    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {</p>
<p>        public void onReceive(Context context, Intent intent) {</p>
<p>            String action = intent.getAction();</p>
<p>            if (Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)</p>
<p>                || Intent.ACTION_SCREEN_OFF.equals(action)) {</p>
<p>                int flags = CommandQueue.FLAG_EXCLUDE_NONE;</p>
<p>                if (Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)) {</p>
<p>                    String reason = intent.getStringExtra(&quot;reason&quot;);</p>
<p>                    if (reason != null &amp;&amp; reason.equals(SYSTEM_DIALOG_REASON_RECENT_APPS)) {</p>
<p>                        flags |= CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL;</p>
<p>                    }</p>
<p>                }</p>
<p>                if (Intent.ACTION_SCREEN_OFF.equals(action)) {</p>
<p>                    // If we’re turning the screen off, we want to hide the</p>
<p>                    // recents panel with no animation</p>
<p>                    // TODO: hide other things, like the notification tray,</p>
<p>                    // with no animation as well</p>
<p>                    mRecentsPanel.show(false, false);</p>
<p>                    flags |= CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL;</p>
<p>                }</p>
<p>                animateCollapse(flags);</p>
<p>            }</p>
<p>        }</p>
<p>    };</p>
<p>    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {</p>
<p>        pw.print(&quot;mDisabled=0x&quot;);</p>
<p>        pw.println(Integer.toHexString(mDisabled));</p>
<p>        pw.println(&quot;mNetworkController:&quot;);</p>
<p>        mNetworkController.dump(fd, pw, args);</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected boolean isTopNotification(ViewGroup parent, NotificationData.Entry entry) {</p>
<p>        if (parent == null || entry == null) return false;</p>
<p>        return parent.indexOfChild(entry.row) == parent.getChildCount()-1;</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void haltTicker() {</p>
<p>        mTicker.halt();</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void updateExpandedViewPos(int expandedPosition) {</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected boolean shouldDisableNavbarGestures() {</p>
<p>        return mNotificationPanel.getVisibility() == View.VISIBLE</p>
<p>                || (mDisabled &amp; StatusBarManager.DISABLE_HOME) != 0;</p>
<p>    }</p>
<p>}</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>英语谚语999</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E8%8B%B1%E8%AF%AD%E8%B0%9A%E8%AF%AD999/</url>
    <content><![CDATA[<p>Lying is the first step to the gallows. </p>
<p>说谎是上断头台的第一步。 </p>
<p>Waste not,want not. </p>
<p>俭以防匮。 </p>
<p>From saving comes having. </p>
<p>富有来自节俭。 </p>
<p>A penny saved is a penny gained. </p>
<p>省一文是一文。 </p>
<p>Take care of the pence and the pound will take care of themselves. </p>
<p>金钱积少便成多。 </p>
<p>Frugality is an estate alone. </p>
<p>节俭本身就是一宗财产。 </p>
<p>He that regards not a penny,will lavish a pound. </p>
<p>小钱不知节省，大钱将滥花。 </p>
<p>Small gains bring great wealth. </p>
<p>积小利，成巨富。 </p>
<p>Many a little makes a mickle. </p>
<p>积少便成多。 </p>
<p>As the touchstone tries gold,so gold tries man. </p>
<p>试金之石可试金，正如黄金能试人。 </p>
<p>Courage and resolution are the spirit and soul of virtue. </p>
<p>勇敢和坚决是美德的灵魂。 </p>
<p>The path to glory is always rugged. </p>
<p>光荣之路常坎坷。 </p>
<p>Nothing is difficult to the man who will try. </p>
<p>世上无难事，只要人肯试。 </p>
<p>The fire is the test of gold;adversity of strong man. </p>
<p>烈火试真金，困苦炼壮士。 </p>
<p>Great hopes make great man. </p>
<p>远大的希望造就伟大的人物。 </p>
<p>No way is impossible to courage. </p>
<p>勇士面前无险路。 </p>
<p>A smooth sea never made a skillful mariner. </p>
<p>平静的大海决不能造就出熟练的水手。 </p>
<p>The good seaman is known in bad weather. </p>
<p>坏天气下才能识得出良好的海员；要识好海员，须凭坏天气。 </p>
<p>The best hearts are always the bravest. </p>
<p>行为最勇敢的人心地总是最善良。 </p>
<p>We must not lie down,and cry,God help us. </p>
<p>求神不如求己。 </p>
<p>He that falls today may be up again tomorrow. </p>
<p>今天跌倒的人也许明天就会站起。 </p>
<p>Rome was not built in a day. </p>
<p>罗马并非一日可建成；坚持必成。 </p>
<p>Success belongs to the persevering. </p>
<p>胜利属于坚忍不拔的人。 </p>
<p>We must repeat a thousand and one times that perseverance is the only road to success. </p>
<p>我们要多次重申：不屈不挠是取得胜利的唯一道路。 </p>
<p>Perseverance is failing nineteen times and succeeding the twentieth. </p>
<p>十九次失败，到第二十次获得成功，这就叫坚持。 </p>
<p>Step by step the ladder is ascended. </p>
<p>登梯需要逐级登。 </p>
<p>Adversity leads to prosperity. </p>
<p>困苦通向昌盛。 </p>
<p>Patience and application will carry us through. </p>
<p>忍耐和专心会使我们度过难关。 </p>
<p>Fortune often rewards with interest those that have patience to wait for her. </p>
<p>做事只要有耐心，到头总会有好运；耐心候好运，好运常会来。 </p>
<p>All things will come round to him who will but wait. </p>
<p>只要肯等待，一切都会按时来。 </p>
<p>Constant dropping wears the stone. </p>
<p>滴水不绝可穿石。 </p>
<p>Omelets are not made without breaking of eggs. </p>
<p>鸡蛋不打破，蛋卷做不成；不甘愿吃苦，则预期效果达不到。 </p>
<p>The world is a ladder for some to go up and others to go down. </p>
<p>世界好似一把梯，有人上去有人下。 </p>
<p>There needs a long apprenticeship to understand the mystery of the world’s trade. </p>
<p>要知世事奥秘多，须要长期作学徒。 </p>
<p>Life is sweet. </p>
<p>生活是可爱的；人无不好生(恶死)。 </p>
<p>Where there is life,there is hope. </p>
<p>生命不息，希望长在。 </p>
<p>Life is not all beer and skittles. </p>
<p>人生并不全是吃喝玩乐。 </p>
<p>Much water runs by the mill that the miller knows not of. </p>
<p>眼前发生许多事，有些我们并不知。 </p>
<p>Fortune knocks once at least at every man’s door. </p>
<p>人人都有走运的一天。 </p>
<p>If you are too fortunate,you will not know yourself;if you are too unfortunate,nobody will know you. </p>
<p>运气太好，见人不睬；运气太坏，无人理会。 </p>
<p>Every man is the architect of his own fortune. </p>
<p>每一个人都是自身幸福的建筑师。 </p>
<p>Happy is he who knows his follies in his youth. </p>
<p>记得年轻时所作蠢事的人是幸福的。 </p>
<p>Misfortunes never (seldom) come alone (single). </p>
<p>祸不单行。 </p>
<p>Misfortune is a good teacher. </p>
<p>不幸是良好的教师。 </p>
<p>Misfortunes come at night. </p>
<p>祸常生于不测。 </p>
<p>Misfortunes tell us what fortune is. </p>
<p>恶运临头后，才知幸运贵。 </p>
<p>Adversity makes a man wise,not rich. </p>
<p>患难能使人聪明，但不能使人富有。 </p>
<p>Live and learn. </p>
<p>活到老，学到老。 </p>
<p>It is never too old to learn. </p>
<p>为学不怕年高。 </p>
<p>A man becomes learned by asking questions. </p>
<p>要长学问，就得多问；多问则业精。 </p>
<p>There is no royal road to learning. </p>
<p>学问无坦途。 </p>
<p>He who is ashamed of asking is ashamed of learning. </p>
<p>畏问之人耻于学。 </p>
<p>What is learned in the cradle lasts till the grave. </p>
<p>婴孩时期学到的东西，老死不会忘记。 </p>
<p>Learning makes a good man better and ill man worse. </p>
<p>知识能使好人更好，坏人更坏。 </p>
<p>Soon learnt,soon forgotten. </p>
<p>学得快，忘得快。 </p>
<p>Learn young,learn fair. </p>
<p>为学趁年青，既学须学好。 </p>
<p>A lazy youth,a lousy age. </p>
<p>少时懒惰老来苦。 </p>
<p>He that knows nothing,doubts nothing. </p>
<p>无知即无疑。 </p>
<p>A good name keeps its luster in the dark. </p>
<p>良好的名声在黑暗中也能闪闪发光。 </p>
<p>Fame is a magnifying glass. </p>
<p>名誉是放大镜。 </p>
<p>A good fame is better than a good face. </p>
<p>美名胜于美貌。 </p>
<p>Fame like a river is narrowest at its source and broadest afar off. </p>
<p>名誉如河流，发源处最狭，愈远愈宽广。 </p>
<p>Take honour from me and my life is done. </p>
<p>没有名誉，就没有了生命。 </p>
<p>Beware of him who regards not his reputation. </p>
<p>要谨防不重名誉的人。 </p>
<p>It is better to die with honour than to live in infamy. </p>
<p>光荣的死胜于羞辱的生。 </p>
<p>Adversity successfully overcome is the highest glory. </p>
<p>成功地克服困难是最大的光荣。 </p>
<p>Reputation is often got without merit and lost without fault. </p>
<p>无功得名是常事，无过失名也是常事。 </p>
<p>Your father’s honour is to you but a second-hand honour. </p>
<p>对于你来说，父亲的荣誉只是间接的荣誉。 </p>
<p>Never trust another what you should do yourself. </p>
<p>自己该做的事，决不要委托给旁人做。 </p>
<p>It is an equal failing to trust everybody,and to trust nobody. </p>
<p>信任一切与不信任任何人，同样是弱点。 </p>
<p>Eat a peck of salt with a man before you trust him. </p>
<p>在你信任一个人之前，先要深入了解他。 </p>
<p>If you trust before you try,you may repent before you die. </p>
<p>不经考验就依赖，不到瞑目便的悔。 </p>
<p>Never trust to fine words. </p>
<p>切勿轻信漂亮话。 </p>
<p>Trust not a great weight to a slender thread. </p>
<p>细线挂重物，终究不可靠。 </p>
<p>Be just to all,but trust not all. </p>
<p>要对一切人都公正，但不要对一切人都信任。 </p>
<p>Trust thyself only,and another shall not betray thee. </p>
<p>只要信任你自己，旁人才不出卖你。 </p>
<p>Self-trust is the essence of heroism. </p>
<p>自信为英雄品质之本。 </p>
<p>Confidence is a plant of slow growth. </p>
<p>信任是一种生长缓慢的植物。 </p>
<p>Truth is the daughter of time. </p>
<p>真理是时间的女儿。 </p>
<p>Truth hath a good face,but ill clothes. </p>
<p>真理面目善良；但衣衫褴褛。 </p>
<p>Truth and roses have thorns about them. </p>
<p>真理和玫瑰，身旁都有刺。 </p>
<p>Truth may be blamed,but shall never be shamed. </p>
<p>真理可能会被责难，但绝不会受羞辱。 </p>
<p>Though malice may darken truth,it cannot put it out. </p>
<p>恶意可以糟塌真理；但无法消灭真理。 </p>
<p>Truth will prevail. </p>
<p>真理必胜。 </p>
<p>Truth’s best ornament is nakedness. </p>
<p>不加掩饰乃是真理的最好装饰。 </p>
<p>Facts are stubborn things. </p>
<p>事实是最顽强的东西。 </p>
<p>Sooner or later,the truth comes to light. </p>
<p>真相迟早会大白。 </p>
<p>The truths we least like to hear are those which it is most to our advantage to know. </p>
<p>我们最不愿意听到的事实，往往是我们知道了会大有好处的事实。 </p>
<p>Falsehood like a nettle stings those who meddle with it. </p>
<p>谎言似荨麻，玩弄会刺手。 </p>
<p>There is many a fair thing full false. </p>
<p>有许多说得好听的东西充满了谬误。 </p>
<p>Though a lie be well drest,it is ever overcome. </p>
<p>谎言装扮虽不错，到头总会被揭露。 </p>
<p>A lie begets a lie till they come to generations. </p>
<p>谎言生谎言，谎言世代传。 </p>
<p>A false tongue will hardly speak truth. </p>
<p>假舌不会吐真言。 </p>
<p>False with one can be false with two. </p>
<p>对一个人虚假，也会对两个人虚假。 </p>
<p>He that will lie will steal. </p>
<p>会说谎的人也就会偷窃。 </p>
<p>Gossiping and lying go together. </p>
<p>流言常和谎话并行。 </p>
<p>Equivocation is first cousin to a lie. </p>
<p>含糊其词是谎话的近亲。 </p>
<p>A great talker is a great liar. </p>
<p>最会夸夸其谈的人也最会说谎。 </p>
<p>The greatest liars talk most of themselves. </p>
<p>最爱自吹自擂的人是最大的说谎者。 </p>
<p>Lying rides upon debt’s back. </p>
<p>负债的人谎话多。 </p>
<p>All is not gold that glitters. </p>
<p>闪光未必尽黄金。 </p>
<p>Money is the root of evil. </p>
<p>金钱是罪恶的根源。 </p>
<p>Money makes the mare go. </p>
<p>有钱能使鬼推磨。 </p>
<p>All things are obedient to money. </p>
<p>一切事物都服从于金钱。 </p>
<p>Before gold,even kings take off their hats. </p>
<p>在黄金面前，国王也要脱帽。 </p>
<p>Money is the key that opens all doors. </p>
<p>金钱是打开一切门户的钥匙。 </p>
<p>Beauty is potent,but money is more potent. </p>
<p>美貌固有力，金钱力更大。 </p>
<p>Avarice increases with wealth. </p>
<p>越有钱，越贪钱。 </p>
<p>The money the miser hoards will do him no good. </p>
<p>守财奴积财，对自己毫无好处。 </p>
<p>What is wealth good for,If it brings melancholy? </p>
<p>财富如带忧郁来，有了财富有何用？。 </p>
<p>Gold will not buy anything. </p>
<p>黄金不能买尽一切。 </p>
<p>The chief aim of man is not to get money. </p>
<p>人的主要目的并不是赚钱。 </p>
<p>Those who believe money can do everything are frequently prepared to do everything for money. </p>
<p>相信金钱万能的人，往往会一切为了金钱。 </p>
<p>Wealth makes worship. </p>
<p>财富能使人拜倒。 </p>
<p>Little wealth,little care. </p>
<p>财富少，烦恼也少。 </p>
<p>A moneyless man goes fast through the market. </p>
<p>身上无钱过市快。 </p>
<p>Poverty is not a crime. </p>
<p>贫非罪。 </p>
<p>Poverty is not a disgrace,but theft is a disgrace. </p>
<p>贫穷不可耻，偷窃乃足羞。 </p>
<p>Better be poor than wicked. </p>
<p>宁可做穷人，不可做坏人。 </p>
<p>Poverty is not a sufficient cause for disgrace,but poverty without resolution to help onself,is a disgrace. </p>
<p>贫穷不足为耻，穷而不能自立方可耻。 </p>
<p>Poverty is the mother of health. </p>
<p>贫穷是健康之母。 </p>
<p>Be considerate toward the poor. </p>
<p>应常为穷人着想。 </p>
<p>Poor and content is rich and rich enough. </p>
<p>人能安贫就是富。 </p>
<p>Poverty parteth fellowship. </p>
<p>贫穷断友情。 </p>
<p>Poverty makes a man mean. </p>
<p>贫困使人小气。 </p>
<p>Nothing to be got without pains but poverty. </p>
<p>只有贫穷是可以不劳而获的东西。 </p>
<p>Do not through fear of poverty surrender liberty. </p>
<p>不要因为怕贫困而舍去自由。 </p>
<p>Poverty and love are hard to hide. </p>
<p>贫困与爱情，都难瞒过人。 </p>
<p>Poverty breeds strife. </p>
<p>贫困引起冲突。 </p>
<p>The poor man wants much,the miser everything. </p>
<p>穷人要求多，财迷则样样都要。 </p>
<p>The dainties of the great are the tears of the poor. </p>
<p>富人口中的美味是穷人眼中的泪水。 </p>
<p>Poverty on an old man’s back is a heavy burden. </p>
<p>老而贫困，负担最沉。 </p>
<p>Beggars must (should) be no choosers. </p>
<p>行乞的哪能挑肥拣瘦；饥不择食。 </p>
<p>A lamb is as dear to a poor man as an ox to the rich. </p>
<p>穷人眼中的一只羊，贵似富人一头牛。 </p>
<p>A light purse makes a heavy heart. </p>
<p>钱袋轻时心事重。 </p>
<p>Poor without debt is better than a prince. </p>
<p>穷人无债胜王子。 </p>
<p>Happy is he who owes nothing. </p>
<p>无债一身轻。 </p>
<p>Money borrowed is soon sorrowed. </p>
<p>借钱才到手，立刻便担忧。 </p>
<p>He that goes a borrowing,goes a sorrowing. </p>
<p>向人借债是自寻烦恼。 </p>
<p>Better go to bed supperless than rise in debt. </p>
<p>与其负债起身，不如空腹上床。 </p>
<p>Out of debt,out of danger. </p>
<p>脱债就脱险。 </p>
<p>A pound of care will not pay an ounce of debt. </p>
<p>深忧偿不了小债。 </p>
<p>He is the wisest man who does not think himself so. </p>
<p>不自作聪明便是最聪明。 </p>
<p>Wise men have their mouth in their heart,fools their heart in their mouth. </p>
<p>聪明人嘴在心里，愚蠢人心在嘴边。 </p>
<p>Wise men learn by other men’s mistakes;fools by their own. </p>
<p>聪明人从旁人的错误中吸取教训，愚笨人则从自身的错误中吸取教训。 </p>
<p>He is wise that knows when he’s well enough. </p>
<p>知足为智者。 </p>
<p>A wise man cares not for what he cannot have. </p>
<p>智者不强求。 </p>
<p>He is wise that hath wit enough for his own affairs. </p>
<p>明智者有足够的机智处理自己的事情。 </p>
<p>No man is born wise. </p>
<p>聪明非天生。 </p>
<p>A wise man will make tools of what comes to hand. </p>
<p>能随机应变的人是聪明人。 </p>
<p>A word is enough to the wise. </p>
<p>对明智者一言已足。 </p>
<p>He is the wise man who is the honest man. </p>
<p>正直的人就是有见识的人。 </p>
<p>A wise man thinks all that he says,a fool says all that he thinks. </p>
<p>聪明人想了才说，愚笨的人想着就说。 </p>
<p>The wise hand doth not all that the foolish mouth speaks. </p>
<p>聪明的手不做愚蠢的嘴所说的事。 </p>
<p>A flow of words is no proof of wisdom. </p>
<p>口若悬河，不能证明真有才智。 </p>
<p>It is easy to be wise after the event. </p>
<p>事后的诸葛亮容易做。 </p>
<p>The wise man knows he knows nothing,the fool thinks the knows all. </p>
<p>聪明人自认一无所知，愚笨人自负无所不晓。 </p>
<p>Fools learn nothing from wise men;but wise men learn much from fools. </p>
<p>愚人不能从智者那里学到什么；而智者却能从愚人那里学到很多。 </p>
<p>A fool always comes short of his reckoning. </p>
<p>愚人常短于心计。 </p>
<p>A fool’s heart dances on his lips. </p>
<p>愚人的心挂在唇边。 </p>
<p>A fool always finds a greater fool than himself. </p>
<p>愚人总以为旁人比自己更傻。 </p>
<p>A man may talk like a wise man and yet act like a fool. </p>
<p>一个人可能说话如智者，而行为象愚人。 </p>
<p>The more riches a fool hath,the greater fool he is. </p>
<p>愚人越富越蠢。 </p>
<p>Never challenge a fool to do wrong. </p>
<p>不要怂恿愚人干错事。 </p>
<p>It is better to please a fool than to anger him. </p>
<p>对愚人最好是使他高兴，而不是惹他发怒。 </p>
<p>He is a fool who cannot be angry,but he is a wise man who will not. </p>
<p>不会发怒是蠢人，不愿发怒是聪明人。 </p>
<p>‘Tis altogether vain to learn wisdom and yet live foolishly. </p>
<p>枉自学聪明，却做愚蠢事。 </p>
<p>Wit without learning is like a tree without fruit. </p>
<p>没有学识的机智，犹如没有果实的树。 </p>
<p>No man is wise at all times. </p>
<p>世上无一贯明智的人。 </p>
<p>Many heads are better than one. </p>
<p>几个脑袋总比一个脑袋强；三个臭皮匠，顶个诸葛亮。 </p>
<p>Virtue never grows old. </p>
<p>美德永不老。 </p>
<p>Virtue is the only true nobility. </p>
<p>万事不如美德高。 </p>
<p>Virtue is a jewel of great price. </p>
<p>美德乃是无价宝。 </p>
<p>He that soweth virtue shall reap fame. </p>
<p>播下美德，收获名望。 </p>
<p>To be virtuous is to do good. </p>
<p>行善即是有德。 </p>
<p>Glory is the shadow of virtue. </p>
<p>荣誉是美德的影子。 </p>
<p>There is no virtue that poverty destroyeth not. </p>
<p>没有贫穷不能破坏的美德。 </p>
<p>The first step to virtue is to abstrain from vice. </p>
<p>不作恶是走向美德的第一步。 </p>
<p>No good building without a good foundation. </p>
<p>基础不良的好建筑物是没有的。 </p>
<p>One good turn deserves another. </p>
<p>善行应有善报；善良的行为应得善良行为的报答。 </p>
<p>He that returns good for evil obtains the victory. </p>
<p>胜利属于以德报怨的人。 </p>
<p>We should never remember the benefits we have offered nor forget the favor received. </p>
<p>我有德于人不应记；人有德于我不可忘。 </p>
<p>If they say you are good,ask yourself if it be true. </p>
<p>若有人称赞，自问对不对。 </p>
<p>He who avoids temptation avoids the sin. </p>
<p>不受诱惑就免于罪恶。 </p>
<p>A quiet conscience sleeps in thunder. </p>
<p>问心无愧，打雷也能睡。 </p>
<p>Never be weary of well doing. </p>
<p>不要厌倦做好事。 </p>
<p>Of evil grain,no good seed can come. </p>
<p>坏谷无好种。 </p>
<p>That which is evil is soon learnt. </p>
<p>恶行易学。 </p>
<p>No vice goes alone. </p>
<p>恶事不单行。 </p>
<p>An evil lesson is soon learned. </p>
<p>恶习易染。 </p>
<p>A bad thing never dies. </p>
<p>坏事传千年。 </p>
<p>Evil comes to us by ells and goes away by inches. </p>
<p>罪恶于人，尺进寸退。 </p>
<p>The maintaining of one vice costs more than ten virtues. </p>
<p>保持一桩恶事的代价超过于十件好事。 </p>
<p>They that do nothing learn to do ill. </p>
<p>游手好闲，容易学坏。 </p>
<p>A wicked man is his own hell. </p>
<p>坏人作恶，自造地狱。 </p>
<p>Those who eat best and drink best often do worst. </p>
<p>吃得好，喝得好，坏事常常免不了。 </p>
<p>He who has done ill once will do it again. </p>
<p>一次干坏事，便有第二次。 </p>
<p>There is no going heaven in a sedan. </p>
<p>坐轿上天堂，从来无此事。 </p>
<p>An ill life,an ill end. </p>
<p>恶有恶报。 </p>
<p>A wilful fault has no excuse and deserves no pardon. </p>
<p>不能宽恕故意犯下的错误。 </p>
<p>Zeal without knowledge is fire without light. </p>
<p>没有知识的热心，犹如有火而无光。 </p>
<p>Pardoning the bad is injuring the good. </p>
<p>隐恶败善；原谅坏人即是伤害好人。 </p>
<p>The evil wound is cured but not the evil name. </p>
<p>重伤可治，恶名难去。 </p>
<p>Evil communications corrupt good manners. </p>
<p>不良的交往败坏良好的举止。 </p>
<p>No wrong without remedy. </p>
<p>有过皆可补。 </p>
<p>Virtue flies from the heart of a mercenary man. </p>
<p>唯利是图者，胸中无美德。 </p>
<p>First think,and then speak. </p>
<p>动口先动脑。 </p>
<p>A word spoken is past recalling(The words once spoken can never be recalled). </p>
<p>一言既出，驷马难追。 </p>
<p>While the word is in your mouth,it is your own;when ‘tis once spoken, ‘tis another’s. </p>
<p>话在嘴里，属于自己；话一出口，人家所有。 </p>
<p>Speech is silver,silence is gold. </p>
<p>言语是银，沉默是金。 </p>
<p>Few words are best. </p>
<p>寡言为贵。 </p>
<p>No wisdom like silence. </p>
<p>聪明莫过沉默。 </p>
<p>Least said,soonest mended. </p>
<p>少说为妙。 </p>
<p>Second thoughts are best. </p>
<p>再思而后行。 </p>
<p>Look before you leap. </p>
<p>慎思而后行。 </p>
<p>He is a wise man who speaks little. </p>
<p>智多言语少。 </p>
<p>Fair words butter no parsnips. </p>
<p>美言无补实际。 </p>
<p>The tongue is not made of steel,yet it cuts. </p>
<p>舌头不是钢，一动把人伤。 </p>
<p>Sometimes words hurt more than swords. </p>
<p>言语能伤人，有时胜刀剑。 </p>
<p>A good tongue is a good weapon. </p>
<p>口齿伶俐，是件利器。 </p>
<p>A wise head makes a close mouth. </p>
<p>头脑灵，嘴巴紧。 </p>
<p>It is one thing to speak much and another to speak pertinently. </p>
<p>说得多是一回事，讲得中肯又是一回事。 </p>
<p>Unprofitable eloquence is like the cypress,which is great and tall,but bears no fruit. </p>
<p>无益的雄辩犹如高大的柏树，不会结果。 </p>
<p>Better say nothing than nothing to the purpose. </p>
<p>与其说话不中肯，不如半句也莫吭。 </p>
<p>Many a true word is spoken in jest. </p>
<p>笑语之中吐真言。 </p>
<p>Few words,many deeds. </p>
<p>少说话，多做事。 </p>
<p>Actions speak louder than words. </p>
<p>行动比言语响亮；百说不如一干。 </p>
<p>From words to deeds is a great space. </p>
<p>言行之间，大有距离。 </p>
<p>Deeds,not words. </p>
<p>要行动，不要言词。 </p>
<p>Bare words,no bargain. </p>
<p>空言不能成交易。 </p>
<p>Deeds are fruits,words are but leaves. </p>
<p>行动是果实，言语只是叶子。 </p>
<p>Ill deeds cannot honour. </p>
<p>坏行为不受尊敬。 </p>
<p>Fine words dress ill deeds. </p>
<p>漂亮的言词装饰着恶劣的行为。 </p>
<p>Good words and ill deeds deceive wise and fools. </p>
<p>动听的话和坏行为同样欺骗聪明和愚人。 </p>
<p>Our own actions are our security,not others’ judgements. </p>
<p>我们的行为是自己的保证，并不是旁人的鉴定。 </p>
<p>A man of words and not deeds is like a garden full of weeds. </p>
<p>空有言语而无行动的人，犹如杂草丛生的花园。 </p>
<p>A man is not good or bad for one action. </p>
<p>不能凭一件事判断人的好坏。 </p>
<p>A man apt to promise is apt to forget. </p>
<p>易于许诺的人也易于忘记。 </p>
<p>A man that breaks his word,bids others to be false to him. </p>
<p>人不守信，无异于叫旁人对他失信。 </p>
<p>Easier said than done. </p>
<p>说易行难。 </p>
<p>The greatest talkers are always the least doers. </p>
<p>大言不惭的总是行动最少的人。 </p>
<p>The proof of the pudding is in the eating. </p>
<p>布丁好坏，一尝便知；空谈不如实践。 </p>
<p>Pride goes before a fall. </p>
<p>骄者必败。 </p>
<p>Pride goes before destruction. </p>
<p>骄者必败。 </p>
<p>Pride goeth before,and shame cometh after. </p>
<p>骄傲走在前，羞耻跟在后。 </p>
<p>Pride and grace dwelt never in one place. </p>
<p>傲慢和温雅，永难住一处。 </p>
<p>He that climbs high falls heavily. </p>
<p>爬得高，跌得重。 </p>
<p>Pride must be pinched. </p>
<p>骄傲应收敛。 </p>
<p>The more noble the more humble. </p>
<p>越高贵，越应谦逊。 </p>
<p>Humility often gains more than pride. </p>
<p>谦逊常比傲慢受益更多。 </p>
<p>He who imagines that he has knowledge enough has none. </p>
<p>自命万事通，腹中常空空。 </p>
<p>No man is the worst for knowing the worst of himself. </p>
<p>人并不因为他自知很差就是很差。 </p>
<p>Pride may lurk under a threadbare cloak. </p>
<p>骄傲可能会潜藏在穿旧的斗篷下。 </p>
<p>It is not a sign of humility to declaim against pride. </p>
<p>用慷慨激昂的言语攻击傲慢并不是谦逊的标志。 </p>
<p>He that is full of himself is very empty. </p>
<p>自满之人腹内空。 </p>
<p>Honesty is the best policy. </p>
<p>诚实为上策。 </p>
<p>An honest man’s word is as good as his bond. </p>
<p>诚实人的诺言实际上就是他的保证书。 </p>
<p>Poor but honest. </p>
<p>虽贫穷，要诚实。 </p>
<p>Honesty may be dear bought,but can never be an ill pennyworth. </p>
<p>高价买诚实，永远也值得。 </p>
<p>Knavery may serve,but honesty is best. </p>
<p>欺诈可能有用，诚实却是上策。 </p>
<p>Every man has his weak side. </p>
<p>人人都有自己的弱点。 </p>
<p>He who has no shame has no conscience. </p>
<p>不知羞耻的人不知自疚。 </p>
<p>An honest look covereth many faults. </p>
<p>一副诚实的外表掩盖着许多缺点。 </p>
<p>Once a knave,ever a knave. </p>
<p>一次成无赖，永远是无赖。 </p>
<p>A crafty knave needs no broker. </p>
<p>狡猾的无赖不需要有中间人。 </p>
<p>The honest penny is better than the stolen dollar. </p>
<p>正当得到的一分钱胜于偷来的一元钱。 </p>
<p>One penny with right is better than a thousand without right. </p>
<p>合法取得的一辨士，胜于非法取得的一千辨士。 </p>
<p>The unrighteous penny corrupts the righteous pound. </p>
<p>不正当得来的辨士使正当得来的英镑也受到沾污。 </p>
<p>Love is blind. </p>
<p>爱情是盲目的。 </p>
<p>Love is without reason. </p>
<p>爱情无理智。 </p>
<p>Love is full of trouble. </p>
<p>爱情充满了烦恼。 </p>
<p>Love cannot be compelled. </p>
<p>爱情不能强迫。 </p>
<p>Love begets love. </p>
<p>爱爱相生。 </p>
<p>Love needs no teaching. </p>
<p>爱情不需教导。 </p>
<p>Love at first sight. </p>
<p>一见倾心。 </p>
<p>Love asks faith,and faith firmness. </p>
<p>爱情要求信任，信任要求坚定。 </p>
<p>Love is the touchstone of virtue. </p>
<p>爱情是美德的试金石。 </p>
<p>Love not at the first look. </p>
<p>不要一见钟情。 </p>
<p>Hasty love,soon cold. </p>
<p>爱得匆忙冷得快。 </p>
<p>Love is a sweet torment. </p>
<p>爱情是一种甜蜜的痛苦。 </p>
<p>Love rules his kingdom without a sword. </p>
<p>爱情的王国不用刀剑来统治。 </p>
<p>Love will find out the way. </p>
<p>爱情自会寻出路。 </p>
<p>Love is not to be found in the market. </p>
<p>爱情在市场上找不到。 </p>
<p>Lovers live by love,as larks live by leeks. </p>
<p>情侣靠爱情生活，正象云雀靠韭葱生活一样。 </p>
<p>Old love will not be forgotten. </p>
<p>旧情永难忘；往日的爱情难以忘怀。 </p>
<p>True love kythes(=shows itself)in time of need. </p>
<p>患难显真情。 </p>
<p>Sound love is not soon forgotten. </p>
<p>坚固的爱情不会顷刻忘怀。 </p>
<p>The greatest hate springs from the greatest love. </p>
<p>最大的恨来自最大的爱。 </p>
<p>No love is foul,nor prison fair. </p>
<p>没有肮脏的爱情，也没有美丽的监狱。 </p>
<p>Labour is lihgt where love doth pay. </p>
<p>爱情付报酬，劳苦也轻松。 </p>
<p>Love is the reward of love. </p>
<p>爱就是爱的报酬。 </p>
<p>Love makes all hard hearts gentle. </p>
<p>爱情把一切冷酷之心变成温柔。 </p>
<p>When love puts in,friendship is gone. </p>
<p>爱情进入，友情完结。 </p>
<p>The course of true love never did run smooth. </p>
<p>真爱的道路绝不平坦。 </p>
<p>Love is a sweet tyranny,because the lover endures his torment willingly. </p>
<p>爱情是可爱的虐政，情人们甘受它痛苦的折磨。 </p>
<p>True love is giving,not taking. </p>
<p>真挚的爱是给，不是取。 </p>
<p>Love makes obedience easy. </p>
<p>爱情使顺从成为易事。 </p>
<p>Love is sweet in the beginning,but sour in the end. </p>
<p>爱情先甜后来酸。 </p>
<p>Where love fails,we espy all faults. </p>
<p>爱情一失败，一切毛病都发现。 </p>
<p>Follow love and it will flee,flee love and it will follow thee. </p>
<p>追求爱情它高飞，逃避爱情它跟随。 </p>
<p>When poverty comes in at the door,love flies out of the window. </p>
<p>贫穷一进门，爱情跳窗走。 </p>
<p>Faults are thick while love is thin. </p>
<p>一朝情义淡，样样不顺眼。 </p>
<p>Hatred is blind as well as love. </p>
<p>爱情和仇恨，二者皆盲目。 </p>
<p>Marriage is a lottery. </p>
<p>婚姻是一桩难于预测的事。 </p>
<p>Marry thy like. </p>
<p>跟你情投意合的人结婚。 </p>
<p>Marriage makes or mars a man. </p>
<p>婚姻成全人，也能损害人。 </p>
<p>It is good to marry late or never. </p>
<p>晚婚或不婚，都是好事情。 </p>
<p>Early wed,early dead. </p>
<p>早婚者早夭。 </p>
<p>They that marry in green,their sorrow is soon seen. </p>
<p>年纪轻轻就结婚，为时不久便悔恨。 </p>
<p>A young man married is a man that’s marred. </p>
<p>男子早婚，种下祸根。 </p>
<p>Marry in haste,and repent at leisure. </p>
<p>匆匆结婚，时时悔恨。 </p>
<p>Marry in lent,and you’ll live to repent. </p>
<p>借债结婚，一生悔恨。 </p>
<p>He that marries for wealth,sells his liberty. </p>
<p>为财富而结婚的人，出卖了自己的自由。 </p>
<p>An ill marriage is a spring of ill fortune. </p>
<p>不良的婚姻是恶运的来源。 </p>
<p>Who marrieth for love without money,hath good nights and sorry days. </p>
<p>为了爱情，无钱结婚，夜来欢娱，白天悔恨。 </p>
<p>If you always say &quot;NO&quot;,never be married. </p>
<p>常常说“不”字，永远难结婚。 </p>
<p>Honest men marry soon,wise men not at all. </p>
<p>老实的人早成婚，聪明的人不结婚。 </p>
<p>A good wife and health is a man’s best wealth. </p>
<p>贤妻和健康是男子的至宝。 </p>
<p>A good wife makes a good husband. </p>
<p>有好妻子就有好丈夫；妻贤夫自良。 </p>
<p>Choose a wife rather by your ear than your eye. </p>
<p>选择妻子，最好用耳不用眼。 </p>
<p>Better be half hanged than ill wed. </p>
<p>与其成怨偶，不如守单身。 </p>
<p>He who does not honour his wife,dishonours himself. </p>
<p>不尊重自己妻子的人，自己也不会受人尊重。 </p>
<p>The calmest husbands make the stormiest wives. </p>
<p>有懦弱的丈夫，就有凶悍的妻子。 </p>
<p>It is a sad house where the hen crows louder than the cock. </p>
<p>母鸡司晨家不兴。 </p>
<p>The wife is the key of the house. </p>
<p>妻子是一家之钥；妻贤一家兴。 </p>
<p>The more women look in their glass,the less they look to their house. </p>
<p>妇女照镜越多，照管家务就越少。 </p>
<p>East or west,home is best. </p>
<p>东也好，西也好，还是家中最好；金窝银窝，不如家里的草窝。 </p>
<p>One father can support ten children; ten children cannot support one father. </p>
<p>一个父亲可以供养十个孩子，十个孩子却不能供养一个父亲。 </p>
<p>One father is more than a hundred school-masters. </p>
<p>一个父亲胜于一百个教师。 </p>
<p>Like father,like son. </p>
<p>有其父，必有其子。 </p>
<p>The father buys,the son bigs,the grandchild sells,and his son thigs. </p>
<p>父买、子修建、孙儿卖，重孙街上当乞丐。 </p>
<p>The mother’s breath is aye sweet. </p>
<p>母亲的低语总是甜蜜的。 </p>
<p>Like mother,like daughter. </p>
<p>有其母，必有其女。 </p>
<p>Children are the parents’ riches. </p>
<p>子女是父母的至宝。 </p>
<p>A little child is the sweetest and purest thing in the world. </p>
<p>孩童是世界上最可爱和最纯洁的东西。 </p>
<p>He that hath no children,knows not what is love. </p>
<p>没有孩子的人，不知道什么叫做爱。 </p>
<p>Children learn to creep ere they can go. </p>
<p>孩子要走路，先得学爬行。 </p>
<p>Silly(=good) child is soon ylered(=taught). </p>
<p>好小孩，学得快。 </p>
<p>Boys will be boys. </p>
<p>孩子终归是孩子。 </p>
<p>One boy is more trouble than a dozen girls. </p>
<p>一个男孩比十二个女孩增添的麻烦还多。 </p>
<p>Spare the rod and spoil the child. </p>
<p>省了棍子，惯坏了孩子。 </p>
<p>Naughty boys sometimes make good men. </p>
<p>淘气的男孩有时会成为争气的孩子。 </p>
<p>The child is father of the man. </p>
<p>三岁定到老。 </p>
<p>Happy is he that is happy in childhood. </p>
<p>童年时快乐的人是幸福的。 </p>
<p>Children and fools cannot lie. </p>
<p>孩子和愚人不会扯谎。 </p>
<p>My son is my son till he hath got him a wife, but my daughter’s my daughter all the days of her life. </p>
<p>儿子娶妻后就不是自己的儿子，可是女儿终身都是自己的女儿。 </p>
<p>It is harder to marry a daughter well than to bring her up well. </p>
<p>养女容易嫁女难。 </p>
<p>A maid that laughs is half taken. </p>
<p>少女笑口开，婚事成一半。 </p>
<p>A maiden with many wooers often chooses the worst. </p>
<p>有许多人向她求婚的少女，往往选中最差的一个。 </p>
<p>Maids want nothing but husbands,but when they have them they want everything. </p>
<p>未婚女子不要别的，只要丈夫，有了丈夫以后，一切都要。 </p>
<p>Would you know your daughter,see her in company. </p>
<p>你若想了解女儿，只要看她和什么样的人交往。 </p>
<p>He that would the daughter win,must with the mother first begin. </p>
<p>要想赢得女儿的欢心，必须先从她母亲着手。 </p>
<p>Life without friend is death. </p>
<p>没有朋友的生活便等于死亡。 </p>
<p>Without a friend,the world is wilderness. </p>
<p>没有朋友，世界成了荒野。 </p>
<p>Friendless is the dead. </p>
<p>死者无友。 </p>
<p>A good friend is my nearest relation. </p>
<p>好友即至亲。 </p>
<p>A near friend is better than a fardwelling kinsman. </p>
<p>近友胜远亲。 </p>
<p>A friend to everybody is a friend to nobody. </p>
<p>和任何人都认朋友，结果和任何人都交不成朋友；友多无好友。 </p>
<p>In time of prosperity,friends will be plenty. </p>
<p>走运时候朋友多。 </p>
<p>It is good to have friends in trouble. </p>
<p>在患难中能有朋友是好事。 </p>
<p>Prosperity makes friends and adversity tries them. </p>
<p>富裕招致朋友，困苦考验朋友。 </p>
<p>A friend in need is a friend indeed. </p>
<p>患难时的朋友才是真正的朋友。 </p>
<p>Poverty tries friends. </p>
<p>贫穷考验朋友；人贫见友情。 </p>
<p>Try your friend ere you trust him. </p>
<p>对朋友要先考验，后信任。 </p>
<p>Prove thy friend ere thou have need. </p>
<p>在你需要朋友帮助前，先要考验他们。 </p>
<p>A friend is never known till a man have need. </p>
<p>不到困窘时，永难识真友。 </p>
<p>A faithful friend is hard to find. </p>
<p>忠实朋友实难求。 </p>
<p>Friends are like fiddle-strings,they must not be screwed too tight. </p>
<p>朋友有如琴弦，不能上的太紧。 </p>
<p>Have but few frieds,though many acquaintances. </p>
<p>结交可以多，朋友应宜少。 </p>
<p>All are not friends that speak us fair. </p>
<p>向我们说好话的并不都是好朋友。 </p>
<p>He that hath a full purse never wanted a friend. </p>
<p>金钱满袋，朋友盈门；钱袋装得饱，朋友不会少。 </p>
<p>A friend in court is better than a penny in purse. </p>
<p>朝中有友，胜如囊中有钱。 </p>
<p>It is good to have some friends both in heaven and hell. </p>
<p>天堂上和地狱中都有几个朋友，这乃是一件好事。 </p>
<p>We shall never have friends if we expect to find them without fault. </p>
<p>指望朋友无缺点，永远休想交朋友。 </p>
<p>A friend without faults will never be found. </p>
<p>没有缺点的朋友永不可得。 </p>
<p>A man without a friend is only half a man. </p>
<p>无友的人只能算半个人。 </p>
<p>A friend is not so soon gotten as lost. </p>
<p>失友快，交友慢。 </p>
<p>Friendship cannot stand always on one side. </p>
<p>友谊不能总是在一方。 </p>
<p>Old acquaintance will soon be remembered. </p>
<p>故人一见便相亲。 </p>
<p>He is a good friend that speaks well of us behind our backs. </p>
<p>背后称我好，才算好朋友。 </p>
<p>Friends (the best of friends) must part. </p>
<p>好友终有分手时。 </p>
<p>A friend is best found in adversity. </p>
<p>患难见真交。 </p>
<p>I will be thy friend,but not thy vices’ friend. </p>
<p>我愿意做你的朋友，但不做你那些恶习的朋友。 </p>
<p>False friends are worse than open enemies. </p>
<p>假朋友比真敌人更坏。 </p>
<p>Short acquaintance brings repentance. </p>
<p>浅交致后悔。 </p>
<p>He that lies down (sleeps) with dogs must rise up with fleas. </p>
<p>与恶人交终会变恶；近朱者赤，近墨者黑。 </p>
<p>Better be alone than in bad company. </p>
<p>交损友不如无友。 </p>
<p>Write down the advice of him who loves you,though you like it not at present. </p>
<p>爱你的人的忠告，即使你当时并不喜欢，也得把它记下。 </p>
<p>Hunger knows no friend. </p>
<p>饥饿不认朋友。 </p>
<p>Misery makes strange bedfellows. </p>
<p>难中不择友。 </p>
<p>One enemy can do more hurt than ten friends can do good. </p>
<p>一个敌人为害，胜过十个朋友行好。 </p>
<p>An enemy’s mouth seldom speaks well. </p>
<p>敌人嘴里无好话。 </p>
<p>Believe no tales from the enemy. </p>
<p>敌人之言不可信。 </p>
<p>One enemy is too much. </p>
<p>一个敌人已太多。 </p>
<p>Mickle power makes many enemies. </p>
<p>权高树敌多。 </p>
<p>Do not despise your enemy. </p>
<p>不可轻敌。 </p>
<p>Though thy enemy seem a mouse,yet watch him like a lion. </p>
<p>敌人即使小如鼠，防他也要如防狮。 </p>
<p>If we are bound to forgive an enemy,we are not bound to trust him. </p>
<p>即便我们决心宽恕敌人，也决不能相信敌人。 </p>
<p>He that dallies with enemy gives him leave to kill him. </p>
<p>把敌人看儿戏，无异于准许敌人杀害自己。 </p>
<p>In an enemy spots are soon seen. </p>
<p>敌人身上求疵易。 </p>
<p>If you would make an enemy,lend a man money and ask it of him again. </p>
<p>你若想与人结怨，只须先借钱给他，再向他催讨。 </p>
<p>A courageous foe is better than a cowardly friend. </p>
<p>勇敢的敌人胜过懦怯的朋友。 </p>
<p>An enemy who lies at thy feet begging forgi-veness must not feel thy sword. </p>
<p>对俯伏在你脚下乞怜的敌人，绝不可使他触及你的剑。 </p>
<p>Make your enemy your friend. </p>
<p>要化敌为友。 </p>
<p>Live and let live. </p>
<p>自己活也让别人活。 </p>
<p>As a man lives,so shall he die. </p>
<p>有生必有死。 </p>
<p>We are not born for ourselves. </p>
<p>人生天地间，并非为自己。 </p>
<p>He that hath time hath life. </p>
<p>有时间就有生活。 </p>
<p>He that lives long suffers much. </p>
<p>寿长忧患多。 </p>
<p>They who live longest will see most. </p>
<p>寿命最长的人见识也最广。 </p>
<p>He was born with a silver spoon in his mouth. </p>
<p>他生在富贵人家。 </p>
<p>A man can die but once. </p>
<p>人生只有一回死。 </p>
<p>He that liveth in court dieth upon straw. </p>
<p>生于安乐者常死于贫贱。 </p>
<p>He that liveth wickedly can hardly die honestly. </p>
<p>过着邪恶生活的人不会正直地死去。 </p>
<p>Death pay all debts. </p>
<p>一死了百债。 </p>
<p>Six feet of earth makes all men equal. </p>
<p>墓穴之中，人人平等。 </p>
<p>Death is the grand leveller. </p>
<p>死亡面前，不分贵贱。 </p>
<p>Death meets us everywhere. </p>
<p>人生到处皆可死；死亡和我们到处相遇。 </p>
<p>Death frees us from ills. </p>
<p>死亡使我们解脱不幸。 </p>
<p>We shall lie all alike in our graves. </p>
<p>一朝进坟场，大家都一样。 </p>
<p>In the grave the rich and poor lie equal. </p>
<p>一朝入暮穴，贫富皆一律。 </p>
<p>Death defies the doctor. </p>
<p>死亡蔑视医生。 </p>
<p>There is no medicine against death. </p>
<p>人间哪有不死（回春）药。 </p>
<p>Light come,light go. </p>
<p>易得则易失；来得容易去得快。 </p>
<p>Sometimes gain is to lose. </p>
<p>有时得即是失。 </p>
<p>Merry is he that hath nought to lose. </p>
<p>无物可失的人最逍遥自在。 </p>
<p>Grasp all,lose all. </p>
<p>样样都要，全部失掉。 </p>
<p>What we lose in hake we shall have in herring. </p>
<p>失鳕得鲱；失之东隅，收之桑榆。 </p>
<p>What is lost in the hundred will be found in the shire. </p>
<p>在区里失去的可在州里找回来。 </p>
<p>For a lost thing care nothing. </p>
<p>一物已失，计较无益。 </p>
<p>He who does not gain loses. </p>
<p>不能得益，就是损失。 </p>
<p>Losses make us more cautious. </p>
<p>损失使人更谨慎。 </p>
<p>Who loseth liberty loseth all. </p>
<p>失去自由即失去一切。 </p>
<p>Either win the horse or lose the saddle. </p>
<p>不是全赢，就是全输；孤注一掷。 </p>
<p>All is not lost that is in danger. </p>
<p>在危险中的东西未必全会损失。 </p>
<p>Do not run too fast after gain. </p>
<p>不要见利便狂追。 </p>
<p>Prefer loss to unjust gain. </p>
<p>宁可受损失，休取不义财。 </p>
<p>Lightly gain,quickly lost. </p>
<p>来得容易去得快；不义之财，理无久享。 </p>
<p>Only that which is honestly got is gain. </p>
<p>正当的收入才是真正的收入。 </p>
<p>All is not gain that is put in the purse. </p>
<p>装进钱包里的不一定都是正当的收入。 </p>
<p>Gain got by a lie will burn one’s fingers. </p>
<p>靠欺骗得利，准要吃亏。 </p>
<p>One never loses anything by politeness. </p>
<p>礼多不吃亏；礼多人不怪。 </p>
<p>Hold fast when you have it. </p>
<p>手中之物应紧握。 </p>
<p>There are as good fish in the sea as ever came out of it. </p>
<p>海中好鱼取不尽（指：虽然失去一个机会，还有很多机会）。 </p>
<p>Many a slip (many things fall) between the cup and the lip. </p>
<p>酒杯来到嘴唇边，得饮与否未可知；物未到手前，未能算己有；凡事难以十拿九稳。 </p>
<p>It is an ill wind that blows nobody good. </p>
<p>使人人倒霉的风才是恶风；此失则彼得；害于此则利于彼；没有使所有的人都受害的坏事。 </p>
<p>Health is better than wealth. </p>
<p>健康胜于财富。 </p>
<p>Health is happiness. </p>
<p>健康便是幸福。 </p>
<p>A good healthy body is worth more a crown in gold. </p>
<p>健全的身体比金冕更有价值。 </p>
<p>A sound mind in a sound body. </p>
<p>健康的思想寓于健康的身体。 </p>
<p>A light heart lives long. </p>
<p>心胸开朗，使人寿长。 </p>
<p>A happy heart makes a blooming visage. </p>
<p>心中快乐，容光焕发。 </p>
<p>He who hath good health is young,and he is rich who owes nothing. </p>
<p>健康葆青春，无债即富有。 </p>
<p>Study sickness while you are well. </p>
<p>无病应思有病时。 </p>
<p>The healthful man can give counsel to the sick. </p>
<p>健康的人可以对生病的人提出忠告。 </p>
<p>By the side of sickness health becomes sweet. </p>
<p>和疾病相比较，才能识得健康的可爱。 </p>
<p>Health is not valued till sickness comes. </p>
<p>有病方知健康贵。 </p>
<p>Feed by measure and defy physician. </p>
<p>饮食有节，医生绝迹。 </p>
<p>Often and little eating makes a man fat. </p>
<p>多餐少吃，使人壮硕。 </p>
<p>After dinner sit awhile,after supper walk a mile. </p>
<p>正餐以后，休息片刻；晚餐以后，步行一哩。 </p>
<p>Early to bed and early to rise,makes a man healthy,wealthy and wise. </p>
<p>早睡早起，使人健康、富有而聪明。 </p>
<p>He that will thrive must rise at five. </p>
<p>五点起床，百事兴旺。 </p>
<p>He that goes to bed thirsty rises healthy. </p>
<p>忍渴上床，起身健康。 </p>
<p>He who does not rise early never does a good day’s work. </p>
<p>起床不早，一天的工作干不好。 </p>
<p>Who makes everything right must rise early. </p>
<p>想把事事都做好，就得坚持起身早。 </p>
<p>Go to bed with the lamb and rise with the lark. </p>
<p>随羔羊就寝，与云雀同起。 </p>
<p>Cover your head by day as much as you will,by night as much as you can. </p>
<p>白天戴帽可随意，夜里戴帽是必须。 </p>
<p>A little labour,much health. </p>
<p>适量的劳动大有益于健康。 </p>
<p>Enough is as good as a feast. </p>
<p>饱食有如赴宴。 </p>
<p>Many dishes,many diseases. </p>
<p>食多病多。 </p>
<p>Diseases are the Price of ill pleasures. </p>
<p>疾病是纵欲的代价。 </p>
<p>Desperate diseases must have desperate cures. </p>
<p>毒病要用毒药医。 </p>
<p>He who never was sick dies the first. </p>
<p>小病不生，一病致命。 </p>
<p>Sickness shows us what we are. </p>
<p>疾病使人显本相。 </p>
<p>What can’t be cured must be endured. </p>
<p>不治之症，必须坚忍。 </p>
<p>Hide nothing from thy physician. </p>
<p>不要讳疾忌医。 </p>
<p>Medicines are not meant to live on. </p>
<p>不要靠吃药过生活。 </p>
<p>A disease known is half cured. </p>
<p>病情弄清楚，病根除一半。 </p>
<p>The best physicians are Dr. Diet, Dr. Quiet,and Dr. Merryman. </p>
<p>节食博士，静心博士，欢喜博士，三者都是最好的医师；饮食少，休息好，快乐多是却病延年之方。 </p>
<p>A good surgeon must have an eagle’s eye,a lion’s heart,and a lady’s hand. </p>
<p>良好的外科医生应具有鹰眼、狮心和女性的手。 </p>
<p>Feed sparingly and defy the physician. </p>
<p>饮食有节，医生绝迹。 </p>
<p>Prevention is better than cure. </p>
<p>预防胜于治疗。 </p>
<p>An ounce of prevention is worth a pound of cure. </p>
<p>一分预防胜似十分治疗。 </p>
<p>Bitter pills may have wholesome effect. </p>
<p>良药苦口利于病。 </p>
<p>A good medicine tastes bitter. </p>
<p>良药苦口。 </p>
<p>There is no friend so faithful as a good book. </p>
<p>最忠实的朋友莫过于一本好书。 </p>
<p>Books,like friends,should be few and well chosen. </p>
<p>书籍如朋友，宜少宜精选。 </p>
<p>A book is the same today as it always was and it will never change. </p>
<p>好书千载常如新。 </p>
<p>A good book is a best friend who never turns his back upon us. </p>
<p>好书如至友，永远不相负。 </p>
<p>In books,are embalmed the greatest thoughts of all ages. </p>
<p>伟大思想古今有，载入书中成不朽。 </p>
<p>Some books are to be tasted,others to be swallowed,and some few to be chewed and digested. </p>
<p>一些书可以品味，另外一些书可以吞食，少数的一些可以咀嚼、消化。 </p>
<p>Old wood is best to burn,old book to read. </p>
<p>老柴好烧，老书宜读。 </p>
<p>A book that remains shut is but a block. </p>
<p>书本不去翻，犹如一木块。 </p>
<p>Judge not a book by its cover. </p>
<p>评定一本书，不能凭封面。 </p>
<p>A wicked book is the wickeder because it cannot repent. </p>
<p>坏书因其不能改正错误而更坏。 </p>
<p>A good tale is none the worse for being twice told. </p>
<p>故事好，再讲一遍还是好。 </p>
<p>Law is a bottomless pit. </p>
<p>法律是无底的深渊。 </p>
<p>Ignorance of the law excuses no man. </p>
<p>对法律无知，不能成为任何人的借口。 </p>
<p>Law makers should not be law breakers. </p>
<p>立法者不应成为犯法者；立法应守法。 </p>
<p>Wrong laws make short governance. </p>
<p>不健全的法律统治时间不会长。 </p>
<p>The law is not the same at morning and at night. </p>
<p>早上的法令跟晚上的不一样；朝令夕改。 </p>
<p>New lords,new laws. </p>
<p>新君立新法。 </p>
<p>Laws catch flies and let hornets go free. </p>
<p>法网只捕蝇，黄蜂由它去。 </p>
<p>Where drums beat,laws are silent. </p>
<p>战鼓一响，法律无声。 </p>
<p>An upright judge has more regard to justice than to men. </p>
<p>法官能公正，重法不重人。 </p>
<p>That trial is not fair where affection is the judge. </p>
<p>法官动感情，审判难公正。 </p>
<p>A good lawyer,an evil neighbour. </p>
<p>好律师不是好邻居。 </p>
<p>An old physician,and a young lawyer. </p>
<p>医生老的好，律师年轻的好。 </p>
<p>Do not count your chickens before they are hatched. </p>
<p>鸡蛋还未孵，先别数鸡雏；莫过早乐观。 </p>
<p>Though the fox run,the chicken hath wings. </p>
<p>狐狸虽会跑，小鸡有翅膀。 </p>
<p>Young cocks love no coops. </p>
<p>小公鸡不恋笼。 </p>
<p>A cock is bold on his dunghill. </p>
<p>站在粪堆上，公鸡也称王。 </p>
<p>A barley-corn is better than a diamond to a cock. </p>
<p>对一只公鸡来说，一颗麦粒优于一颗钻石。 </p>
<p>He that will have his farm full,must keep an old cock and a young bull. </p>
<p>想使农庄充裕，就得养一只老公鸡和一头小公牛。 </p>
<p>If the hen does not prate,she will not lay. </p>
<p>不叨叨的母鸡不下蛋。 </p>
<p>It is no good hen that cackles in your house and lays in another’s. </p>
<p>这样的母鸡可不好：在你家里咯咯叫，却到别家去下蛋。 </p>
<p>Fat hens lay few eggs. </p>
<p>肥鸡下蛋稀。 </p>
<p>Grain by grain,and the hen fills her belly. </p>
<p>一颗接一颗，母鸡填饱肚。 </p>
<p>A duck will not always dabble in the same gutter. </p>
<p>一只鸭子不会常在同一条沟中玩水。 </p>
<p>It is a blind silly gooes that comes to the fox’s sermon. </p>
<p>只有盲目的笨鹅才会去听狐狸讲道。 </p>
<p>What is sauce for the goose is sauce for the gander. </p>
<p>适用于甲的也适用于乙。 </p>
<p>All his geese are swans. </p>
<p>他喜欢夸大其词；敝帚自珍。 </p>
<p>All your swans are geese. </p>
<p>你的美好希望（或诺言），全部成了泡影。 </p>
<p>Each bird likes to hear himself sing. </p>
<p>每一只鸟都爱听自己歌唱。 </p>
<p>The bird loves her nest. </p>
<p>鸟爱自己的窝。 </p>
<p>Birds of a feather flock together. </p>
<p>物以类聚，人以群分。 </p>
<p>The bird that can sing and won’t sing must be made to sing. </p>
<p>生来能唱的鸟，不愿唱也得叫它唱。 </p>
<p>The fowler’s pipe sounds sweet until the bird is caught. </p>
<p>捕禽人笛声悠扬，直吹得鸟儿落网。 </p>
<p>He that will take the bird must not scare it. </p>
<p>捕鸟休惊鸟。 </p>
<p>The noisy fowler catches no bird. </p>
<p>捕禽人大肆声张，鸟儿就不会落网。 </p>
<p>Old birds are not caught with new nests. </p>
<p>新网难捕老鸟。 </p>
<p>‘Tis the early bird that catches the worm. </p>
<p>早起的鸟先得虫；捷足先登。 </p>
<p>A bird in the hand is worth two in the bush. </p>
<p>双鸟在林，不如一鸟在手；十赊不如一现。 </p>
<p>A bird is known by its note,and a man by his talk. </p>
<p>鸟以声闻，人以言知。 </p>
<p>It is an ill bird that fouls its own nest. </p>
<p>家丑不可外扬。 </p>
<p>Eagles fly alone,but sheep flock together. </p>
<p>鹰爱独飞羊爱群。 </p>
<p>A kite will never be a good hawk. </p>
<p>鸢永不会变成隼。 </p>
<p>Empty hands no hawk allure. </p>
<p>空手不能诱鹰来。 </p>
<p>The crow thinks his own bird fairest. </p>
<p>乌鸦总以为自己的雏鸟最美。 </p>
<p>A crow is never the whiter for washing herself often. </p>
<p>乌鸦不管怎样经常洗澡，也不会变白。 </p>
<p>Wheresoever the carcase is,there will the ravens be gathered together. </p>
<p>哪里有死尸，乌鸦就成群。 </p>
<p>One swallow does not make a summer. </p>
<p>一燕不能成夏天（不可仅凭一种现象而遽作判断）。 </p>
<p>The snail slides up the tower at last though the swallow mounteth it sooner. </p>
<p>燕子一飞就上塔，蜗牛悄悄爬，最后也上塔。 </p>
<p>The cuckoo comes in April,and stays the month of May;sings a song at Midsummer,and then goes away. </p>
<p>布谷鸟，四月来，五月一直在，仲夏唱支歌，然后就离开。 </p>
<p>If the sky falls,we shall catch larks. </p>
<p>天垮正好抓云雀；不要杞人忧天。 </p>
<p>An owl is the king of the night. </p>
<p>猫头鹰是黑夜之王。 </p>
<p>When the owl sings,the nightingale will hold her peace. </p>
<p>枭鸟唱歌，夜莺屏息。 </p>
<p>Cats hide their paws. </p>
<p>猫儿不露爪。 </p>
<p>A gloved cat catches no mice. </p>
<p>戴手套的猫抓不到老鼠。 </p>
<p>When the cat’s away,the mice will play. </p>
<p>猫儿不在家，老鼠就玩耍；猫儿不在耗子闹。 </p>
<p>Ale will make cat speak. </p>
<p>喝了淡啤酒，猫也会开口；酒后使人说话多。 </p>
<p>A blate cat makes a proud mouse. </p>
<p>猫儿腼腆，老鼠翻天。 </p>
<p>When the weasel and the cat make a marriage,it is a very ill presage. </p>
<p>黄鼠狼跟猫儿成亲，预兆不佳。 </p>
<p>The cat and dog may kiss,yet are none the better friends. </p>
<p>猫狗虽相吻，总难成好友。 </p>
<p>All cats love fish but fear to wet their paws. </p>
<p>猫儿性爱鱼，却怕爪弄湿；想获得珍品的人不愿冒必要的风险。 </p>
<p>A cat may look at a king. </p>
<p>猫也有权看国王；小人物也该有些权利。 </p>
<p>It is said that &quot;cat hath nine lives&quot;,yet care would wear them all out. </p>
<p>据说猫儿有九命，忧虑多时也伤身。 </p>
<p>An old dog bites sore. </p>
<p>老狗咬人咬得狠。 </p>
<p>Beware of a silent dog and still water. </p>
<p>哑狗和静水，二者都得防。 </p>
<p>Barking dogs seldom bite. </p>
<p>爱吠的狗不咬人。 </p>
<p>A dog will not howl if you beat him with a bone. </p>
<p>肉骨头打狗狗不叫。 </p>
<p>Dogs that bark at a distance bite not at hand. </p>
<p>远处狗就叫，近身不会咬。 </p>
<p>If the old dog barks,he gives counsel. </p>
<p>老狗叫，是忠告。 </p>
<p>In every country dogs bite. </p>
<p>天下有狗都咬人。 </p>
<p>Hungry dogs will eat dirty puddings. </p>
<p>饿狗也吃脏布丁；饥不择食。 </p>
<p>Dogs wag their tails not so much in love to you as your bread. </p>
<p>狗儿把尾摇，爱的是面包。 </p>
<p>All are not thieves that dogs bark at. </p>
<p>狗吠的人并非都是小偷。 </p>
<p>Every dog is valiant at his own door. </p>
<p>站在家门口，狗也雄纠纠。 </p>
<p>Every dog is a lion at home. </p>
<p>狗在家中，八面威风。 </p>
<p>While the dog gnaws bone,companions would be none. </p>
<p>狗啃骨头无同伴。 </p>
<p>Two dogs strive for a bone,the third runs away with it. </p>
<p>两狗相争一骨头，第三只狗衔起走。 </p>
<p>Mad dog bites his master. </p>
<p>疯狗咬主人。 </p>
<p>Too much pudding will choke dog. </p>
<p>布丁太多噎死狗。 </p>
<p>Do not give a dog bread every time he wags his tail. </p>
<p>莫因狗尾摇，次次丢面包。 </p>
<p>A living dog is better than a dead lion. </p>
<p>活狗胜于死狮。 </p>
<p>Love me,love my dog. </p>
<p>爱屋及乌。 </p>
<p>Let sleeping dog lie. </p>
<p>勿惊卧狗；切莫惹是生非。 </p>
<p>Help the dog over the stile. </p>
<p>助人度过难关。 </p>
<p>Every dog has his day. </p>
<p>片瓦也有翻身日；人人都有得意时。 </p>
<p>Give a dog a bad name and hang him. </p>
<p>欲加之罪，何患无辞。 </p>
<p>He who has a mind to beat his dog will easily find a stick. </p>
<p>有心打狗好找棍；欲加之罪，何患无辞。 </p>
<p>An old dog cannot alter its way of barking. </p>
<p>老狗难改常吠声。 </p>
<p>When a dog is drowning,every one offers him drink. </p>
<p>待到狗溺水，众人给水喝。 </p>
<p>A swine over fat is the cause of his own bane. </p>
<p>猪死都因身过肥；象以齿焚。 </p>
<p>Pigs may fly,but they are very unlikely birds. </p>
<p>猪儿纵会飞，终究不是鸟。 </p>
<p>Never cast your pearls before swine. </p>
<p>不要把珍贵之物送给不识货的人；勿明珠暗投；勿对牛弹琴。 </p>
<p>You cannot make a silk purse out of a sow’s ear. </p>
<p>猪耳朵做不成丝钱包；巧妇难为无米之炊。 </p>
<p>The cow that’s first up gets the first of the dew. </p>
<p>早起母牛先得露。 </p>
<p>Not all butter that the cow yields. </p>
<p>母牛所产的未必全是黄油。 </p>
<p>Many good cows have evil calves. </p>
<p>很多好母牛，会生坏小犊。 </p>
<p>You cannot sell the cow and sup the milk. </p>
<p>不能既要卖母牛，又想喝牛奶。 </p>
<p>Old oxen have stiff horns. </p>
<p>牛老角硬。 </p>
<p>The ox is never woe,till he to the harrow go. </p>
<p>挂耙去耕地，牛才知辛苦。 </p>
<p>An ox is taken by the horns,and the man by the tongue. </p>
<p>牛因角被执，人因舌陷身。 </p>
<p>If the ox falls,whet your knife. </p>
<p>牛一倒，快磨刀；人遭难，众人踩。 </p>
<p>The black ox has trod on his foot. </p>
<p>祸事临头。 </p>
<p>The ox when weariest treads surest. </p>
<p>牛困走得稳。 </p>
<p>The best horse needs breaking,and the aptest child needs teaching. </p>
<p>最好的马儿要人驯，最伶俐的孩子要人训。 </p>
<p>A horse that will not carry a saddle must have no oats. </p>
<p>不愿加鞍的马，不得吃燕麦。 </p>
<p>A good horse oft needs a good spur. </p>
<p>好马常需好靴刺。 </p>
<p>It is the bridle and spur that makes a good horse. </p>
<p>要把马练好，缰绳靴刺少不了。 </p>
<p>A boisterous horse must have a rough bridle. </p>
<p>烈马要套粗笼头。 </p>
<p>He is a gentle horse that never cast his rider. </p>
<p>驯良的马绝不会把骑手甩倒。 </p>
<p>‘Tis a good horse that never stumbles. </p>
<p>好马不失蹄。 </p>
<p>The fault of the horse is put on the saddle. </p>
<p>马劣动怪马鞍坏。 </p>
<p>Mettle is dangerous in a blind horse. </p>
<p>瞎马鼓勇气，正是危险事。 </p>
<p>Old wood is best to burn,old horse to ride. </p>
<p>老柴好烧，老马好骑。 </p>
<p>Every horse thinks his sack heaviest. </p>
<p>每匹马都认为自己驮的袋子最重。 </p>
<p>You may know the horse by his harness. </p>
<p>观马具可知马性。 </p>
<p>A galled horse will not endure the comb. </p>
<p>擦伤的马不耐梳。 </p>
<p>You can take a horse to the water,but you cannot make him drink. </p>
<p>牵马河边易，逼马饮水难；不要逼人做他不愿做的事。 </p>
<p>Don’t swap horses when crossing a stream. </p>
<p>行至中流不换马；危难之时不宜作大变动。 </p>
<p>An ass endures his burden,but not more than his burden. </p>
<p>驴子能负重，过重也难负。 </p>
<p>Wherever an ass falleth,there will he never fall again. </p>
<p>驴子绝不会在同样的地点跌倒两次。 </p>
<p>The braying of an ass does not reach heaven. </p>
<p>驴子的叫声传不到天上。 </p>
<p>The fault of the ass must not be laid upon the packsaddle. </p>
<p>驴子不乖，休怪驮鞍。 </p>
<p>A horse is neither better nor worse for his trappings. </p>
<p>相马不可凭马饰。 </p>
<p>He who wants a mule without fault,must walk on foot. </p>
<p>指望驴子无缺点，只有自己徒步行。 </p>
<p>A colt you may break,but an old horse you never can. </p>
<p>小驹犹可练，老马最难驯。 </p>
<p>One sheep follows another. </p>
<p>一羊跟一羊（指盲从）。 </p>
<p>If one sheep leap o’er the dyke,all the rest will follow. </p>
<p>一羊跳过沟，众羊跟着跳。 </p>
<p>There is a black sheep in every flock. </p>
<p>败类处处有；害群之马处处有。 </p>
<p>One scabbed sheep will mar a whole flock. </p>
<p>一羊生癣，群羊受害。 </p>
<p>Every time the sheep bleats it loses a mouthful. </p>
<p>羊每叫一次，就少吃一口。 </p>
<p>One butcher does not fear many sheep. </p>
<p>屠夫不怕羊多。 </p>
<p>It is a foolish sheep that makes the wolf his confessor. </p>
<p>蠢羊才向狼忏悔。 </p>
<p>The dust raised by the sheep does not choke the wolf. </p>
<p>羊踩起的灰尘挡不住狼。 </p>
<p>Carrion crows bewail the dead sheep and then eat them. </p>
<p>乌鸦吃死羊，先要哭一场；猫哭老鼠假慈悲。 </p>
<p>The life of the wolf is the death of the lamb. </p>
<p>有活的狼就有死的羔羊。 </p>
<p>As soon goes the young lamb’s skin to the market as the old ewe’s. </p>
<p>老羊皮上了市，小羊皮也跟着来。 </p>
<p>You have no goats,and yet you sell kids. </p>
<p>没有老山羊，还把小羊卖。 </p>
<p>If the beard were all,the goat might preach. </p>
<p>如果长胡就好，山羊也可讲道。 </p>
<p>A lazy sheep thinks its wool heavy. </p>
<p>懒羊自觉羊毛重。 </p>
<p>He that will have a hare to breakfast must hunt overnight. </p>
<p>早餐想吃野兔肉，头晚就须去捕捉。 </p>
<p>If you run after two hares,you will catch neither. </p>
<p>同时追两兔，一只也难捕。 </p>
<p>One should not run with the hare and hunt with the hounds. </p>
<p>不应两面讨好。 </p>
<p>The tortoise wins the race while the hare is sleeping. </p>
<p>兔子睡大觉，乌龟跑第一。 </p>
<p>First catch your hare then cook him. </p>
<p>要兔子肉，先要把兔捉；先抓兔子后烹调（勿谋之过早）。 </p>
<p>The fox is known by his brush. </p>
<p>狐狸只因尾巴大，所以人人认识他。 </p>
<p>The fox smells his own stink first. </p>
<p>狐狸有恶臭，自己先嗅出。 </p>
<p>The fox may grow grey, but never good. </p>
<p>狐狸活到老，永远难变好。 </p>
<p>The tail does often catch the fox. </p>
<p>狐狸被抓，都因尾巴。 </p>
<p>It is an evil sign to see a fox lick a lamb. </p>
<p>狐狸舔羔羊，不是好迹象。 </p>
<p>When the fox preacheth,then beware your geese. </p>
<p>每逢狐狸讲道，当心鹅儿遭殃。 </p>
<p>An old fox is not easily snared. </p>
<p>老狐狸难得陷罗网。 </p>
<p>Old foxes want no tutors. </p>
<p>老狐不须教师教。 </p>
<p>The sleeping fox catches no poultry. </p>
<p>睡着的狐狸捉不到鸡。 </p>
<p>You can have no more of the fox than the skin. </p>
<p>狐狸除了皮，旁的全无用。 </p>
<p>The fox that had lost its tail would persuade others out of theirs. </p>
<p>一条狐狸丢尾巴，就劝旁的也丢它。 </p>
<p>A fox should not be of the jury at a goose’s trial. </p>
<p>审鹅不应狐陪审。 </p>
<p>The fox’s wiles will never enter the lion’s head. </p>
<p>狐狸的诡计永远进不了狮子的头脑。 </p>
<p>The old goose plays not with foxes. </p>
<p>老鹅不跟狐狸耍。 </p>
<p>The wolf and fox are both privateers. </p>
<p>狐狸与狼，抢劫大王。 </p>
<p>The wolf may lose his teeth, but never his nature. </p>
<p>狼牙会掉，狼性难改。 </p>
<p>A thief knows a thief as a wolf knows a wolf. </p>
<p>小偷识小偷，正象狼识狼。 </p>
<p>Hunger fetches the wolf out of the woods. </p>
<p>饥饿引狼出森林。 </p>
<p>Give never the wolf the wether. </p>
<p>莫把阉羊送给狼。 </p>
<p>Who keeps company with the wolf will learn to howl. </p>
<p>与狼相结交，就会学狼嚎。 </p>
<p>The lone sheep is in danger of the wolf. </p>
<p>孤羊逢狼，必然遭殃。 </p>
<p>It is madness for a sheep to treat of peace with a wolf. </p>
<p>跟狼讲和平，此羊必癫狂。 </p>
<p>By little and little the wolf eateth the sheep. </p>
<p>狼吃羊，一只一只进肚肠。 </p>
<p>The death of wolves is the safety of the sheep. </p>
<p>群狼一死众羊安。 </p>
<p>While you trust to the dog,the wolf slips into the sheepfold. </p>
<p>当你认为狗可信，狼已偷偷把羊圈进。 </p>
<p>When the wolf grows old, the crows ride him. </p>
<p>狼老被鸦欺。 </p>
<p>Man is to man either a god or a wolf. </p>
<p>人与人交往，不是上帝就是狼。 </p>
<p>A growing youth has a wolf in his belly. </p>
<p>青年成长时，食量大如狼。 </p>
<p>The lion is known by his claws (paw). </p>
<p>狮以爪闻名。 </p>
<p>The lion is not so fierce as he is painted. </p>
<p>狮子没有画上的凶猛。 </p>
<p>A barking dog is better than a sleeping lion. </p>
<p>吠犬胜于睡狮。 </p>
<p>It is not good to wake a sleeping lion. </p>
<p>睡狮莫惊。 </p>
<p>The lion’s skin is never cheap. </p>
<p>狮皮从不贱。 </p>
<p>Destroy the lion while he is yet but a whelp. </p>
<p>杀狮应在幼小时。 </p>
<p>The tiger that has once tasted blood is never sated with the taste of it. </p>
<p>一次尝到血，虎欲永难遏。 </p>
<p>He who rides a tiger is afraid to dismount. </p>
<p>骑虎难下。 </p>
<p>The leopard can never change its spots. </p>
<p>花豹永不能改变身上的斑点（指：本性难移）。 </p>
<p>Kings and bears oft worry keepers. </p>
<p>国王和熊，常使守护人忧心忡忡。 </p>
<p>He who shareth honey with the bear hath the least part of it. </p>
<p>与熊分蜜糖，只得一点尝。 </p>
<p>Do not sell the bear’s skin before you have caught the bear. </p>
<p>熊未到手休卖皮（勿过早乐观）。 </p>
<p>Where the deer is slain,some of her blood will lie. </p>
<p>鹿死总有血迹留。 </p>
<p>The rage of a wild boar is able to spoil more than one wood. </p>
<p>野猪一怒毁树多。 </p>
<p>An ape’s an ape, a varlet’s a varlet, though they be clad in silk or scarlet. </p>
<p>尽管衣绸穿红，猿猴还是猿猴，侍从还是侍从。 </p>
<p>An army of stags led by a lion would be more formidable than one of lions led by a stag. </p>
<p>一只狮子率领的一群鹿，比一只鹿率领的一头狮子更难对付。 </p>
<p>A bad custom is like a good cake, better broden than kept. </p>
<p>坏习惯象饼子，碎了比保存起来好。 </p>
<p>A bald head is soon shaven. </p>
<p>光脑袋，剃得快。 </p>
<p>A blind man will not thank you for a looking-glass. </p>
<p>瞎子不谢赠镜人。 </p>
<p>A borrowed cloak does not keep one warm. </p>
<p>借来的大氅不暖身。 </p>
<p>A brave retreat is a brave exploit. </p>
<p>勇退即勇绩。 </p>
<p>Accidents will happen in the best regulated families. </p>
<p>即使家规严，丑事总难免。 </p>
<p>A candle lights others and consumes itself. </p>
<p>腊烛照亮了别人，毁灭了自己。 </p>
<p>A constant guest is never welcome. </p>
<p>常来之客不会受欢迎。 </p>
<p>A cracked bell can never sound well (is never sound). </p>
<p>破钟无好音。 </p>
<p>A crown is no cure for the headache. </p>
<p>王冠难治头痛。 </p>
<p>A drowning man will catch at a straw. </p>
<p>溺水者见草也要抓；急何能择。 </p>
<p>After a storm comes a calm. </p>
<p>暴风雨后天平静；雨过天晴。 </p>
<p>After death, the doctor. </p>
<p>人死医生来；雨后送伞。 </p>
<p>A good beginning is half done. </p>
<p>良好的开端，就是成功了一半。 </p>
<p>A good example is the best sermon. </p>
<p>良好的范例是最好的训诫。 </p>
<p>A great ship asks deep waters. </p>
<p>大船要在深水行；英雄要有用武之地。 </p>
<p>A horse stumbles that has four legs. </p>
<p>人有失手日，马有失蹄时。 </p>
<p>A little neglect may breed great mischief. </p>
<p>小失成大害；小误酿大祸。 </p>
<p>A little pot is soon hot. </p>
<p>壶小易热，量小易怒。 </p>
<p>All are brave when the enemy flies. </p>
<p>敌人遁逃时，人人皆勇士。 </p>
<p>All is fish that comes to his net. </p>
<p>到了网中都是鱼；只要到手全都要。 </p>
<p>All is well that ends well. </p>
<p>结果好，就一切都好。 </p>
<p>All roads lead to Rome. </p>
<p>条条大路通罗马。 </p>
<p>Always taking out the meal-tub, and never putting in,soon comes to the bottom. </p>
<p>取粮不储粮，桶底粮也光；坐吃山空。 </p>
<p>A miss is as good as a mile. </p>
<p>失之毫厘，差以千里。 </p>
<p>An empty bag cannot stand upright. </p>
<p>空袋不能直立。 </p>
<p>A new broom sweeps clean. </p>
<p>新官上任三把火。 </p>
<p>A rolling stone gathers no moss. </p>
<p>滚石不粘青苔；转业不积财。 </p>
<p>Art is long, life is short. </p>
<p>艺术恒久，生命短暂。 </p>
<p>A small leak will sink a great ship. </p>
<p>小漏沉大船。 </p>
<p>A stitch in time saves nine. </p>
<p>一针及时省九针；一针不补，十针难缝。 </p>
<p>As the wind blows, you must set your sail. </p>
<p>趁风启帆。 </p>
<p>As we sow, so shall we reap. </p>
<p>种瓜得瓜，种豆得豆。 </p>
<p>A valiant man’s look is more than a coward’s sword. </p>
<p>勇士的神色胜过懦夫的刀剑。 </p>
<p>A vaunter and a liar are near akin. </p>
<p>自诩和说谎，二者正相仿。 </p>
<p>Avarice blinds our eyes. </p>
<p>贪婪障人目。 </p>
<p>A watched pot(pan) is long in boiling. </p>
<p>心急水不沸；盼得越切，来得越迟。 </p>
<p>A wonder lasts but nine days. </p>
<p>新鲜事儿不久长。 </p>
<p>Beard the lion in his den. </p>
<p>老虎头上捉虱；太岁头上动土。 </p>
<p>Beauty is but skin deep. </p>
<p>美丽只是皮相（指：不能以貌取人）。 </p>
<p>Better be the head of a dog than the tail of a lion. </p>
<p>宁为犬首，不作狮尾。 </p>
<p>Better be the head of the yeomanry than the tail of the gentry. </p>
<p>宁作自由民之首，不为贵族之尾。 </p>
<p>Between two stools one goes the ground. </p>
<p>脚踩两只船，早晚要落水。 </p>
<p>Beware beginnings. </p>
<p>慎始为上。 </p>
<p>Blood is thicker than water. </p>
<p>血浓于水（指：亲人比外人亲）。 </p>
<p>Caesar’s wife must be above suspicion. </p>
<p>身为凯撒（罗马大将）妻，必须无可疑（指：与伟大的人物交往的人不可有秽名）。 </p>
<p>Charity begins at home, but should not end there. </p>
<p>施舍先及亲友，但不应限于亲友。 </p>
<p>Companions are odious. </p>
<p>人比人，气死人。 </p>
<p>Content is happiness. </p>
<p>知足常乐。 </p>
<p>Custom is a second nature. </p>
<p>习惯是第二天性。 </p>
<p>Cut your coat according to your cloth. </p>
<p>量布裁衣。 </p>
<p>Danger is next neighbour to security. </p>
<p>危险是安全的紧邻。 </p>
<p>Do as the Romans do. </p>
<p>入境要问俗。 </p>
<p>Do as you would be done by. </p>
<p>你愿别人怎样对待你，你就应该怎样对待别人；己所不欲，勿施于人。 </p>
<p>Do not hallo till you are out of the wood. </p>
<p>未出险境，先莫高兴。 </p>
<p>Don’t put the cart before the horse. </p>
<p>勿本末倒置；勿倒果为因。 </p>
<p>Don’t throw out the baby with the bath water. </p>
<p>切勿良莠不分一起抛。 </p>
<p>Envy assails the noblest, the winds howl around the highest peak. </p>
<p>位高遭人妒，峰高招风怒。 </p>
<p>Every advantage has its disadvantage. </p>
<p>有利必有弊。 </p>
<p>Every cloud has a silver lining. </p>
<p>黑暗之中总有一线光明；祸中有福。 </p>
<p>Every man has his liking. </p>
<p>人各有所好。 </p>
<p>Every one’s faults are not written in their foreheads. </p>
<p>人人有错，隐藏不露。 </p>
<p>Everything hath an end. </p>
<p>万物有始必有终。 </p>
<p>Everything must have a beginning. </p>
<p>凡事皆有始。 </p>
<p>Example is better than precept. </p>
<p>范例胜于教训。 </p>
<p>Fine feathers make fine birds. </p>
<p>好鸟要靠好羽毛；人要衣装，佛靠金装。 </p>
<p>Fire and water have no mercy. </p>
<p>水火无情。 </p>
<p>First come, first served. </p>
<p>先到先招待。 </p>
<p>Fish begins to stink at the head. </p>
<p>鱼腐头先臭（上梁不正下梁歪）。 </p>
<p>Forbidden fruit is sweet. </p>
<p>禁果味甜。 </p>
<p>Force can never destory right. </p>
<p>暴力决不能摧毁正义。 </p>
<p>God’s mill grinds slow but sure. </p>
<p>天网恢恢，疏而不漏。 </p>
<p>Great designs require great consideration. </p>
<p>大计划要慎重考虑。 </p>
<p>Great men have great faults. </p>
<p>伟大的人物也会有巨大的过失。 </p>
<p>Great men’s sons seldom do well. </p>
<p>大人物的子孙少出息。 </p>
<p>Half a loaf is better than no bread. </p>
<p>半片面包总比没有好；有胜于无。 </p>
<p>Haste makes waste. </p>
<p>欲速则不达。 </p>
<p>Hear all parties. </p>
<p>兼听则明。 </p>
<p>He laughs best who laughs last. </p>
<p>谁笑在最后，谁笑的最好（指：不要高兴得过早）。 </p>
<p>He measures another’s corn by his own bushel. </p>
<p>用自己的标准衡量别人；以己度人。 </p>
<p>He should have a long spoon that sups with the devil. </p>
<p>跟坏人打交道，要特别小心。 </p>
<p>He that never rode never fell. </p>
<p>不骑马就不会落马。 </p>
<p>He that would eat the kernel must crack the nut. </p>
<p>要把果仁吃，就得碎果壳。 </p>
<p>History repeats itself. </p>
<p>历史自身常重演。 </p>
<p>Hoist your sail when the wind is fair. </p>
<p>风顺便扯篷。 </p>
<p>Honey is sweet, but the bee stings. </p>
<p>蜜甜蜂螫人。 </p>
<p>Hunger is the best sauce. </p>
<p>饥者口中尽佳肴；饥饿之时，样样好吃。 </p>
<p>If the mountain will not come to Mahomet,Mahomet must go to the mountain. </p>
<p>大山从不向穆罕默德移来，穆罕默德只好向大山走去；他若不迁就你，你只好迁就他。 </p>
<p>If wishes were horses,beggars might ride. </p>
<p>愿望若是马，乞丐也可乘；愿望难成事实。 </p>
<p>Ill air slays sooner than the sword. </p>
<p>污浊的空气杀人比刀还快。 </p>
<p>Ill news never comes too late. </p>
<p>坏消息总是来得快。 </p>
<p>In the kingdom of blind men, the oneeyed is king. </p>
<p>生在盲人国，独眼也称王。 </p>
<p>It is better to be a martyr than a confessor. </p>
<p>与其做忏悔，不如做殉道者。 </p>
<p>It is too late to shut the stalbe door when the steed is stolen. </p>
<p>失马锁厩，为时已晚；贼去关门，为时已迟。 </p>
<p>It never rains but it pours. </p>
<p>不雨则已，一雨倾盆。 </p>
<p>It takes two to make a quarrel. </p>
<p>吵架要有两个人。 </p>
<p>Jack of all trades and master of none. </p>
<p>万事皆通，事事不精（指：杂而不精的人）。 </p>
<p>Joy and sorrow are next-door neighbours. </p>
<p>快乐是忧愁的紧邻。 </p>
<p>Keeping is harder than winning. </p>
<p>成功不易，保持更难。 </p>
<p>Kill the goose that lays the golden eggs. </p>
<p>杀鸡取金蛋；只图眼前需要，断绝将来财源。 </p>
<p>Kill two birds with one stone. </p>
<p>一石双鸟；一箭双雕。 </p>
<p>Kinsman helps kinsman,but woe to him that hath nothing. </p>
<p>亲人帮亲人，无亲来帮愁煞人。 </p>
<p>Like tree, like fruit. </p>
<p>有什么样的树，就有什么样的果。 </p>
<p>Little thieves are hanged, but great ones escape. </p>
<p>大贼脱身去，小贼被吊死。 </p>
<p>Long absent, soon forgotten. </p>
<p>久别易忘。 </p>
<p>Long looked for comes at last. </p>
<p>久久寻找，终会找到。 </p>
<p>Long tarrying takes all thands away. </p>
<p>耽搁太久，会把人家的谢意全送走。 </p>
<p>Losers are always in the wrong. </p>
<p>失败之人受咎多。 </p>
<p>Man is a god or a devil to his neighbour. </p>
<p>一个人对邻居来说，不是上帝，便是魔鬼。 </p>
<p>Many men have many minds. </p>
<p>人多意见多；人多口杂。 </p>
<p>Many wells, many buckets. </p>
<p>井多桶也多。 </p>
<p>Mercy to the eriminal may be eruelty to the people. </p>
<p>对罪犯的仁慈，就是对人民的残忍。 </p>
<p>Merry meet, merry part. </p>
<p>好聚好散。 </p>
<p>Messengers should neither be headed nor hanged. </p>
<p>两国相争，不斩来使。 </p>
<p>Might is right. </p>
<p>强权即公理。 </p>
<p>Might overcomes right. </p>
<p>强权压倒公理。 </p>
<p>Mischief has swift wings. </p>
<p>祸害长有飞翅。 </p>
<p>Misery loves company. </p>
<p>同病相怜。 </p>
<p>Mock not a cobbler for his black thumbs. </p>
<p>莫笑皮匠拇指黑。 </p>
<p>Most things have two handles. </p>
<p>多数事物有两种解释。 </p>
<p>Music is the eye of the ear. </p>
<p>音乐是耳朵的眼睛。 </p>
<p>Necessity and opportunity may make a coward valiant. </p>
<p>需要和机会，可使懦夫变勇敢。 </p>
<p>Necessity is the mother of invention. </p>
<p>需要是发明之母。 </p>
<p>Neither fish nor flesh (nor good red herring). </p>
<p>非驴非马；不伦不类。 </p>
<p>Never judge from appearances. </p>
<p>不可根据外貌判断；不可以貌取人。 </p>
<p>Never too late to mend. </p>
<p>补过不嫌晚。 </p>
<p>No cross, no crown. </p>
<p>没有十字架，就没有王冠；无苦即无乐。 </p>
<p>No man can do two things at once. </p>
<p>一人不能同时做两件事；心无二用。 </p>
<p>No man ever became thoroughly bad all at once. </p>
<p>从来没有骤然变得极坏的人。 </p>
<p>No man is content. </p>
<p>知足的人世上无。 </p>
<p>No mill, no meal. </p>
<p>不磨面就没有面包吃。 </p>
<p>No pleasure without pain. </p>
<p>没有无痛苦的欢乐。 </p>
<p>No rose without a thorn. </p>
<p>玫瑰皆有刺（没有尽善尽美的幸福）。 </p>
<p>No smoke without some fire. </p>
<p>无火不生烟；无风不起浪。 </p>
<p>Nothing venture, nothing have. </p>
<p>不入虎穴，焉得虎子。 </p>
<p>Obedience is the first duty of a soldier. </p>
<p>服从是军人的第一职责。 </p>
<p>Older and wiser. </p>
<p>老而益精；越老越聪明。 </p>
<p>Old bees yield no honey. </p>
<p>老蜂不产蜜。 </p>
<p>Old vessels must leak. </p>
<p>船旧必漏。 </p>
<p>Once a devil, always a devil. </p>
<p>一次做魔鬼，永远是魔鬼。 </p>
<p>One flower makes no garland. </p>
<p>一朵花做不成一个花环。 </p>
<p>One foot is better than two crutches. </p>
<p>一只脚胜过两条拐仗。 </p>
<p>Oppression maketh a wise man mad. </p>
<p>人处压迫下，聪明也会疯。 </p>
<p>Out of sitght, out of mind. </p>
<p>眼不见，心不想。 </p>
<p>Pain is forgotten where gain follows. </p>
<p>一朝得了利，痛苦便忘记。 </p>
<p>Patience is the plaster of all sores. </p>
<p>忍耐是一切痛苦的止痛膏。 </p>
<p>Patient men win the day. </p>
<p>能忍者胜。 </p>
<p>Peace with sword in hand, ‘Tis safest making. </p>
<p>和平时期手执剑，这样做来最保险；有备无患。 </p>
<p>Pen and ink is wit’s plough. </p>
<p>笔墨是才智之犁。 </p>
<p>Penny wise and pound foolish. </p>
<p>小事聪明，大事糊涂。 </p>
<p>Poison is poison though it comes in a golden cup. </p>
<p>纵然装入金杯，毒药还是毒药。 </p>
<p>Pouring oil on the fire is no way to quench it. </p>
<p>加油不是灭火法。 </p>
<p>Praise is not pudding. </p>
<p>恭维不等于布丁；恭维不是实惠。 </p>
<p>Promises are like piecrust, made to be broken. </p>
<p>诺言好似馅饼皮，做来便是为咬碎。 </p>
<p>Promise is debt. </p>
<p>许愿要还，欠债要清；许愿如欠债，欠了便要还。 </p>
<p>Public money is like holy water, every one helps himself to it. </p>
<p>公款如圣水，人人都要尝一嘴。 </p>
<p>Quietness is best. </p>
<p>宁静最好。 </p>
<p>Rain before seven: fine before eleven. </p>
<p>早雨不过午。 </p>
<p>Reading maketh a full man, conference a ready man,and writing an exact man. </p>
<p>Reading使人渊博，会谈使人机敏，写作使人严谨。 </p>
<p>Remember thou art but a man. </p>
<p>记住：你只不过是个“人”而已。 </p>
<p>Revolutions are not made with rosewater. </p>
<p>革命不是玫瑰香水做成的（指：革命不能采用温和的办法）。 </p>
<p>Satan reproves sin. </p>
<p>魔鬼责人之罪（责备他人有罪过，自己同样有过失）。 </p>
<p>Scanderbeg’s sword must have Scanderbeg’s arm. </p>
<p>斯坎德培（阿尔巴尼亚15世纪的民族英雄）的剑，必须要有斯坎德培的臂才能举；宝剑须由烈士擎。 </p>
<p>Shallow streams make most din. </p>
<p>浅流水声响。 </p>
<p>Short pleasure, long lament. </p>
<p>眼前片刻欢，日后长悲痛。 </p>
<p>Silence gives consent. </p>
<p>沉默表示同意。 </p>
<p>Skill and confidence are an unconquered army. </p>
<p>技能和信心是无敌的军队。 </p>
<p>Something is better than nothing. </p>
<p>有总比没有强。 </p>
<p>Soon ripe, soon rotten. </p>
<p>早熟早烂；早慧早夭。 </p>
<p>Sorrow comes unsent for. </p>
<p>悲哀来时不须邀。 </p>
<p>Sport is sweetest when there be no spectators. </p>
<p>旁边无观众，运动最轻松。 </p>
<p>Still waters run deep. </p>
<p>静水流深。 </p>
<p>Straws show which way the wind blows. </p>
<p>草动示风向。 </p>
<p>Talk of the devil, and he is sure to appear. </p>
<p>讲着某人，某人就到；说起曹操，曹操就到。 </p>
<p>Teach your grandmother to suck eggs. </p>
<p>班门弄斧。 </p>
<p>Temperance is the best physic. </p>
<p>节欲是最好的药品。 </p>
<p>The best (greatest) fish keep (swim near) the bottom. </p>
<p>好鱼游水底（指：有价值之物不能轻易得到）。 </p>
<p>The best is oftentimes the enemy of the good. </p>
<p>要求过高，反难成功。 </p>
<p>The mountains have brought forth a mouse. </p>
<p>大山生小鼠（指：费力大而收效小）。 </p>
<p>The pot calls the kettle black. </p>
<p>锅子嫌罐黑；责人严而责己宽；自己有过失而申斥他人。 </p>
<p>There are two sides to every question. </p>
<p>每个问题都有两个方面。 </p>
<p>There is a crook(=affliction,trial) in the lot of every one. </p>
<p>人生总有倒楣事；人生总有不如意处。 </p>
<p>The swan sings when death comes. </p>
<p>死期来到，天鹅歌声美妙。 </p>
<p>The thread breaks where it is weakest. </p>
<p>线断常在最细处。 </p>
<p>The tongue ever turns to the aching teeth. </p>
<p>舌头总是碰着疼牙。 </p>
<p>The used key is always bright. </p>
<p>常用的钥匙常光亮。 </p>
<p>The weakest goes to the wall. </p>
<p>弱者败北。 </p>
<p>The wish is father to the thought. </p>
<p>愿望为思想之父；所望之事，每易信之为真。 </p>
<p>Things done cannot be undone. </p>
<p>事已定局，不能挽回；覆水难收。 </p>
<p>Things unreasonable are never durable. </p>
<p>不合理的事不会长久。 </p>
<p>Too many cooks spoil the broth. </p>
<p>厨子成群，煮坏肉羹。 </p>
<p>Too much liberty spoils all. </p>
<p>自由过了头，一切乱了套。 </p>
<p>Too much spoils, too little is nothing. </p>
<p>过多会坏事，过少不济事。 </p>
<p>Tread on a worm and it will turn. </p>
<p>蚯蚓被踩也会动（指：被逼过甚，最温顺者也会反抗）。 </p>
<p>True praise roots and spreads. </p>
<p>赞词真实，根深传远。 </p>
<p>Two of a trade seldom agree. </p>
<p>同行是冤家；同行相妒。 </p>
<p>Two wrongs don’t make a right. </p>
<p>两个错加不出一个正确来。 </p>
<p>Union is strength. </p>
<p>联合即是力量。 </p>
<p>Vain glory blossoms but never bears. </p>
<p>虚荣能开花，但不会结果。 </p>
<p>Vows made in storms are forgotten in calms. </p>
<p>激动时的誓约，平静时便忘却。 </p>
<p>Walls have ears. </p>
<p>隔墙有耳。 </p>
<p>War is death’s feast. </p>
<p>战争是死亡的筵席。 </p>
<p>War makes thieves, and peace hangs them. </p>
<p>战争造成窃贼，和平把他们吊死。 </p>
<p>Water afar quencheth not fire. </p>
<p>远水救不了近火。 </p>
<p>Weeds want no sowing. </p>
<p>杂草不需种。 </p>
<p>We never know the worth of water till the well is dry. </p>
<p>井干方知水可贵。 </p>
<p>What youth is used to, age remembers. </p>
<p>少年惯为事，老时常记起。 </p>
<p>When Greek meets Greek, then comes the bug of war. </p>
<p>两雄相争，难解难分。 </p>
<p>When the tree is fallen, every one runs to it with his axe. </p>
<p>大树一倒下，人人持斧来。 </p>
<p>When the well is full, it will run over. </p>
<p>井满则水溢。 </p>
<p>When war begins, then hell openeth. </p>
<p>战争一开始，地狱便打开。 </p>
<p>Where there are reeds, there is water. </p>
<p>有芦苇处必有水。 </p>
<p>Where there is a will, there is a way. </p>
<p>有志者事竟成。 </p>
<p>Where the water is shallow, no vessel will ride. </p>
<p>水浅无船行。 </p>
<p>Who swims in sin shall sink in sorrow. </p>
<p>在罪恶中游泳的人，必将在悲哀中沉没。 </p>
<p>Wine in the bottle does not quench thirst. </p>
<p>瓶中之酒不解渴。 </p>
<p>Woe to him that is alone. </p>
<p>孤独的人最可悲。 </p>
<p>You cannot see the wood for trees. </p>
<p>见树不见林。 </p>
<p>An idle youth,a needy age. </p>
<p>少壮不努力，老大徒伤悲。 </p>
<p>Time flies. </p>
<p>时光易逝。 </p>
<p>Time is money. </p>
<p>一寸光阴一寸金。 </p>
<p>Time and tide wait for no man. </p>
<p>岁月无情；岁月易逝；岁月不待人。 </p>
<p>Time tries all. </p>
<p>时间检验一切。 </p>
<p>Time tries truth. </p>
<p>时间检验真理。 </p>
<p>Time past cannot be called back again. </p>
<p>光阴一去不复返。 </p>
<p>All time is no time when it is past. </p>
<p>光阴一去不复返。 </p>
<p>No one can call back yesterday;Yesterday will not be called again. </p>
<p>昨日不复来。 </p>
<p>Tomorrow comes never. </p>
<p>切莫依赖明天。 </p>
<p>One today is worth two tomorrows. </p>
<p>一个今天胜似两个明天。 </p>
<p>The morning sun never lasts a day. </p>
<p>好景不常；朝阳不能光照全日。 </p>
<p>Christmas comes but once a year. </p>
<p>圣诞一年只一度。 </p>
<p>Pleasant hours fly past. </p>
<p>快乐时光去如飞。 </p>
<p>Happiness takes no account of time. </p>
<p>欢娱不惜时光逝。 </p>
<p>Time tames the strongest grief. </p>
<p>时间能缓和极度的悲痛。 </p>
<p>The day is short but the work is much. </p>
<p>工作多，光阴迫。 </p>
<p>Never deter till tomorrow that which you can do today. </p>
<p>今日事须今日毕，切勿拖延到明天。 </p>
<p>Have you somewhat to do tomorrow,do it today. </p>
<p>明天如有事，今天就去做。 </p>
<p>To him that does everything in its proper time,one day is worth three. </p>
<p>事事及时做，一日胜三日。 </p>
<p>To save time is to lengthen life. </p>
<p>节省时间就是延长生命。 </p>
<p>Everything has its time and that time must be watched. </p>
<p>万物皆有时，时来不可失。 </p>
<p>Take time when time cometh,lest time steal away. </p>
<p>时来必须要趁时，不然时去无声息。 </p>
<p>When an opportunity is neglected,it never comes back to you. </p>
<p>机不可失，时不再来；机会一过，永不再来。 </p>
<p>Make hay while the sun shines. </p>
<p>晒草要趁太阳好。 </p>
<p>Strike while the iron is hot. </p>
<p>趁热打铁。 </p>
<p>Work today,for you know not how much you may be hindered tomrrow. </p>
<p>今朝有事今朝做，明朝可能阻碍多。 </p>
<p>Punctuality is the soul of business. </p>
<p>守时为立业之要素。 </p>
<p>Procrastination is the thief of time. </p>
<p>因循拖延是时间的大敌；拖延就是浪费时间。 </p>
<p>Every tide hath ist ebb. </p>
<p>潮涨必有潮落时。 </p>
<p>Knowledge is power. </p>
<p>知识就是力量。 </p>
<p>Wisdom is more to be envied than riches. </p>
<p>知识可羡，胜于财富。 </p>
<p>Wisdom is better than gold or silver. </p>
<p>知识胜过金银， </p>
<p>Wisdom in the mind is better than money in the hand. </p>
<p>胸中有知识，胜于手中有钱。 </p>
<p>Wisdom is a good purchase though we pay dear for it. </p>
<p>为了求知识，代价虽高也值得。 </p>
<p>Doubt is the key of knowledge. </p>
<p>怀疑是知识之钥。 </p>
<p>If you want knowledge,you must toil for it. </p>
<p>若要求知识，须从勤苦得。 </p>
<p>A little knowledge is a dangerous thing. </p>
<p>浅学误人。 </p>
<p>A handful of common sense is worth a bushel of learning. </p>
<p>少量的常识，当得大量的学问。 </p>
<p>Knowledge advances by steps and not by leaps. </p>
<p>知识只能循序渐进，不能跃进。 </p>
<p>Learn wisdom by the follies of others. </p>
<p>从旁人的愚行中学到聪明。 </p>
<p>It is good to learn at another man’s cost. </p>
<p>前车可鉴。 </p>
<p>Wisdom is to the mind what health is to the body. </p>
<p>知识之于精神，一如健康之于肉体。 </p>
<p>Experience is the best teacher. </p>
<p>经验是最好的教师。 </p>
<p>Experience is the father of wisdom and memory the mother. </p>
<p>经验是知识之父，记忆是知识之母。 </p>
<p>Dexterity comes by experience. </p>
<p>熟练来自经验。 </p>
<p>Practice makes perfect. </p>
<p>熟能生巧。 </p>
<p>Experience keeps a dear school,but fools learn in no other. </p>
<p>经验学校学费高，愚人旁处学不到。 </p>
<p>Experience without learning is better than learning without experience. </p>
<p>有经验而无学问，胜于有学问而无经验。 </p>
<p>Wit once bought is worth twice taught. </p>
<p>由经验而得的智慧，胜于学习而得的智慧；一次亲身的体会，胜过两次的教师教导。 </p>
<p>Seeing is believing. </p>
<p>百闻不如一见。 </p>
<p>Business is the salt of life. </p>
<p>事业是生命之盐。 </p>
<p>Business before pleasure. </p>
<p>事业在先，享乐在后。 </p>
<p>Business makes a man as well as tries him. </p>
<p>事业可以考验人，也可以造就人。 </p>
<p>Business neglected is business lost. </p>
<p>忽视职业便是放弃职业。 </p>
<p>Never think yourself above business. </p>
<p>勿自视过高；不要眼高手低；永远不要认为自己是大才小用。 </p>
<p>Business may be troublesome,but idleness is pernicious. </p>
<p>事业虽扰人，懒惰害更大。 </p>
<p>He that thinks his business below him will always be above his business. </p>
<p>自命大才小用，往往眼高手低。 </p>
<p>Do business,but be not a slave to it. </p>
<p>要做事，但不要做事务的奴隶。 </p>
<p>Everybody’s business is nobody’s business. </p>
<p>众人的事就是无人过问的事。 </p>
<p>Work makes the workman. </p>
<p>勤工出巧匠。 </p>
<p>Better master one than engage with ten. </p>
<p>会十事，不如精一事。 </p>
<p>A work ill done must be twice done. </p>
<p>首次做不好，必须重新搞。 </p>
<p>They who cannot do as they would,must do as they can. </p>
<p>不能如愿而行，也须尽力而为。 </p>
<p>If you would have a thing well done,do it yourself. </p>
<p>想把事情来做好，就得亲自动手搞。 </p>
<p>He that doth most at once doth least. </p>
<p>什么都想一次做完，结果一件也做不完；贪多嚼不烂。 </p>
<p>Do as most men do and men will speak well of thee. </p>
<p>照大多数人那样干，人们会把你称赞。 </p>
<p>What may be done at any time will be done at no time. </p>
<p>在任何时候都可做的事情，总是在任何时候都不做的事情。 </p>
<p>Better late than never. </p>
<p>迟做总比不做好。 </p>
<p>Whatever is worth doing at all is worth doing well. </p>
<p>凡是值得做的事，就值得做好。 </p>
<p>The shortest answer is doing the thing. </p>
<p>最简短的回答就是一个“干”字。 </p>
<p>Action is the proper fruit of knowledge. </p>
<p>行动是知识之佳果。 </p>
<p>Finished labours are pleasant. </p>
<p>完成工作是一乐。 </p>
<p>It is lost labour to sow where there is no soil. </p>
<p>没有土壤，播种也是徒劳。 </p>
<p>It is right to put everything in its proper use. </p>
<p>凡事都应用得其所。 </p>
<p>Affairs that are done by due degrees are soon ended. </p>
<p>按部就班，事情很快就做完。 </p>
<p>All work and no play makes Jack a dull boy. </p>
<p>只工作，不玩耍，聪明小孩也变傻。 </p>
<p>Work bears witness who does well. </p>
<p>工作能证明谁做的好。 </p>
<p>It is not work that kills,but worry. </p>
<p>工作不会伤身，伤身乃是忧虑。 </p>
<p>He that will not work shall not eat. </p>
<p>不工作者不得食。 </p>
<p>Business is business. </p>
<p>公事公办。 </p>
<p>Deliberate slowly,execute promptly. </p>
<p>慢慢酌量，快快行动。 </p>
<p>Put your shoulder to the wheel. </p>
<p>努力工作。 </p>
<p>Never do things by halves. </p>
<p>做事不要半途而废。 </p>
<p>In for a penny,in for a pound. </p>
<p>做事一开头，就要做到底；一不做，二不休。 </p>
<p>Many hands make quick work. </p>
<p>人多干活快。 </p>
<p>Many hands make light work. </p>
<p>众擎易举。 </p>
<p>A bad workman quarrels with his tools. </p>
<p>技术拙劣的工人抱怨自己的工具。 </p>
<p>Diligence is the mohter of success. </p>
<p>勤奋是成功之母。 </p>
<p>Idleness is the root of all evil. </p>
<p>懒惰乃万恶之源。 </p>
<p>Care and diligence bring luck. </p>
<p>谨慎和勤奋带来好运。 </p>
<p>Diligence is the mother of good fortune. </p>
<p>勤勉是好运之母。 </p>
<p>Industry is fortune’s right hand,and frugality her left. </p>
<p>勤勉是幸运的右手，世俭是幸运的左手。 </p>
<p>Idleness is the key of beggary. </p>
<p>懒惰出乞丐。 </p>
<p>No root,no fruit. </p>
<p>无根就无果。 </p>
<p>Idle people (folks) have the most labour (take the most pains). </p>
<p>懒人做工作，越懒越费力。 </p>
<p>Sloth is the key of poverty. </p>
<p>惰能致贫。 </p>
<p>Sloth turned the edge of wit. </p>
<p>懒散能磨去才智的锋芒。 </p>
<p>An idle brain is the devil’s workshop. </p>
<p>懒汉的头脑是魔鬼的工厂。 </p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>gc2035</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/gc2035.c/</url>
    <content><![CDATA[<p>/*</p>
<p> * Driver for MT9M001 CMOS Image Sensor from Micron</p>
<p> *</p>
<p> * Copyright (C) 2008, Guennadi Liakhovetski &lt;<a href="mailto:&#107;&#x65;&#x72;&#110;&#x65;&#x6c;&#64;&#112;&#x65;&#x6e;&#103;&#117;&#116;&#114;&#x6f;&#x6e;&#105;&#x78;&#46;&#x64;&#101;">&#107;&#x65;&#x72;&#110;&#x65;&#x6c;&#64;&#112;&#x65;&#x6e;&#103;&#117;&#116;&#114;&#x6f;&#x6e;&#105;&#x78;&#46;&#x64;&#101;</a>&gt;</p>
<p> *</p>
<p> * This program is free software; you can redistribute it and/or modify</p>
<p> * it under the terms of the GNU General Public License version 2 as</p>
<p> * published by the Free Software Foundation.</p>
<p> */</p>
<p>#define lily_debug 0</p>
<p>#include &lt;linux/videodev2.h&gt;</p>
<p>#include &lt;linux/slab.h&gt;</p>
<p>#include &lt;linux/i2c.h&gt;</p>
<p>#include &lt;linux/log2.h&gt;</p>
<p>#include &lt;linux/platform_device.h&gt;</p>
<p>#include &lt;linux/delay.h&gt;</p>
<p>#include &lt;linux/circ_buf.h&gt;</p>
<p>#include &lt;linux/miscdevice.h&gt;</p>
<p>#include &lt;media/v4l2-common.h&gt;</p>
<p>#include &lt;media/v4l2-chip-ident.h&gt;</p>
<p>#include &lt;media/soc_camera.h&gt;</p>
<p>#include &lt;plat/rk_camera.h&gt;</p>
<p>#if lily_debug</p>
<p>#include &lt;linux/proc_fs.h&gt;</p>
<p>struct i2c_client * g_client;</p>
<p>#endif</p>
<p>static int debug;</p>
<p>module_param(debug, int, S_IRUGO|S_IWUSR);</p>
<p>#define dprintk(level, fmt, arg…) do { \</p>
<p>if (debug &gt;= level) \</p>
<p>printk(KERN_WARNING fmt , ## arg); } while (0)</p>
<p>#define SENSOR_TR(format, …) printk(KERN_ERR format, ## __VA_ARGS__)</p>
<p>#define SENSOR_DG(format, …) dprintk(1, format, ## __VA_ARGS__)</p>
<p>#define _CONS(a,b) a##b</p>
<p>#define CONS(a,b) _CONS(a,b)</p>
<p>#define __STR(x) #x</p>
<p>#define _STR(x) __STR(x)</p>
<p>#define STR(x) _STR(x)</p>
<p>#define MIN(x,y)   ((x&lt;y) ? x: y)</p>
<p>#define MAX(x,y)    ((x&gt;y) ? x: y)</p>
<p>/* Sensor Driver Configuration */</p>
<p>#define SENSOR_NAME RK29_CAM_SENSOR_GC2035</p>
<p>#define SENSOR_V4L2_IDENT  V4L2_IDENT_GC2035</p>
<p>#define SENSOR_ID 0x2035</p>
<p>#define SENSOR_MIN_WIDTH    800</p>
<p>#define SENSOR_MIN_HEIGHT   600</p>
<p>#define SENSOR_MAX_WIDTH    1600</p>
<p>#define SENSOR_MAX_HEIGHT   1200</p>
<p>#define SENSOR_INIT_WIDTH 800 /* Sensor pixel size for sensor_init_data array */</p>
<p>#define SENSOR_INIT_HEIGHT  600</p>
<p>#define SENSOR_INIT_WINSEQADR sensor_svga</p>
<p>#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8</p>
<p>#define CONFIG_SENSOR_WhiteBalance 1</p>
<p>#define CONFIG_SENSOR_Brightness 0</p>
<p>#define CONFIG_SENSOR_Contrast      0</p>
<p>#define CONFIG_SENSOR_Saturation    0</p>
<p>#define CONFIG_SENSOR_Effect        1</p>
<p>#define CONFIG_SENSOR_Scene         1</p>
<p>#define CONFIG_SENSOR_DigitalZoom   0</p>
<p>#define CONFIG_SENSOR_Focus         0</p>
<p>#define CONFIG_SENSOR_Exposure      1</p>
<p>#define CONFIG_SENSOR_Flash         1</p>
<p>#define CONFIG_SENSOR_Mirror        0</p>
<p>#define CONFIG_SENSOR_Flip          0</p>
<p>#define CONFIG_SENSOR_I2C_SPEED     250000       /* Hz */</p>
<p>/* Sensor write register continues by preempt_disable/preempt_enable for current process not be scheduled */</p>
<p>#define CONFIG_SENSOR_I2C_NOSCHED   0</p>
<p>#define CONFIG_SENSOR_I2C_RDWRCHK   0</p>
<p>#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\</p>
<p>                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_HIGH |\</p>
<p>                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)</p>
<p>#define COLOR_TEMPERATURE_CLOUDY_DN  6500</p>
<p>#define COLOR_TEMPERATURE_CLOUDY_UP    8000</p>
<p>#define COLOR_TEMPERATURE_CLEARDAY_DN  5000</p>
<p>#define COLOR_TEMPERATURE_CLEARDAY_UP    6500</p>
<p>#define COLOR_TEMPERATURE_OFFICE_DN     3500</p>
<p>#define COLOR_TEMPERATURE_OFFICE_UP     5000</p>
<p>#define COLOR_TEMPERATURE_HOME_DN       2500</p>
<p>#define COLOR_TEMPERATURE_HOME_UP       3500</p>
<p>#define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))</p>
<p>#define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)</p>
<p>#define SENSOR_AF_IS_ERR    (0x00&lt;&lt;0)</p>
<p>#define SENSOR_AF_IS_OK (0x01&lt;&lt;0)</p>
<p>#define SENSOR_INIT_IS_ERR   (0x00&lt;&lt;28)</p>
<p>#define SENSOR_INIT_IS_OK    (0x01&lt;&lt;28)</p>
<p>struct reginfo</p>
<p>{</p>
<p>    u8 reg;</p>
<p>    u8 val;</p>
<p>};</p>
<p>//flash off in fixed time to prevent from too hot , zyc</p>
<p>struct  flash_timer{</p>
<p>    struct soc_camera_device *icd;</p>
<p>struct hrtimer timer;</p>
<p>};</p>
<p>static enum hrtimer_restart flash_off_func(struct hrtimer *timer);</p>
<p>static struct  flash_timer flash_off_timer;</p>
<p>//for user defined if user want to customize the series , zyc</p>
<p>#ifdef CONFIG_GC2035_USER_DEFINED_SERIES</p>
<p>#include &quot;gc2035_user_series.c&quot;</p>
<p>#else</p>
<p>/* init 352X288 SVGA */</p>
<p>static struct reginfo sensor_init_data[] ={</p>
<p>{0xfe,0x80},</p>
<p>{0xfe,0x80},</p>
<p>{0xfe,0x80},</p>
<p>{0xfc,0x06},</p>
<p>{0xf2,0x00},</p>
<p>{0xf3,0x00},</p>
<p>{0xf4,0x00},</p>
<p>{0xf5,0x00},</p>
<p>{0xf9,0xfe}, //[0] pll enable</p>
<p>{0xfa,0x00},</p>
<p>{0xf6,0x00},</p>
<p>{0xf7,0x15}, //pll enable</p>
<p>{0xf8,0x85},</p>
<p>{0xfe,0x00},</p>
<p>{0x82,0x00},</p>
<p>{0xb3,0x60},</p>
<p>{0xb4,0x40},</p>
<p>{0xb5,0x60},</p>
<p>{0x03,0x02},</p>
<p>{0x04,0x80},</p>
<p>//========================measure window,0x</p>
<p>{0xfe,0x00},</p>
<p>{0xec,0x06},//04 2012.10.26</p>
<p>{0xed,0x06},//04 2012.10.26</p>
<p>{0xee,0x62},//60 2012.10.26</p>
<p>{0xef,0x92},//90 2012.10.26</p>
<p>////=============================analog</p>
<p>{0x0a,0x00}, //row start</p>
<p>{0x0c,0x02}, //col start</p>
<p>{0x0d,0x04},</p>
<p>{0x0e,0xc0},</p>
<p>{0x0f,0x06}, //Window setting</p>
<p>{0x10,0x58}, </p>
<p>{0x17,0x17}, //[0]mirror [1]flip</p>
<p>{0x18,0x0a}, //0a 2012.10.26</p>
<p>{0x19,0x0a}, //AD pipe number</p>
<p>{0x1a,0x01}, //CISCTL mode4</p>
<p>{0x1b,0x8b},</p>
<p>{0x1e,0x88}, //analog mode1 [7] tx-high en [5:3]COL_bias</p>
<p>{0x1f,0x08}, //[3] tx-low en//</p>
<p>{0x20,0x05}, //[0]adclk mode,0x[1]rowclk_MODE [2]rsthigh_en</p>
<p>{0x21,0x0f}, //[6:4]rsg</p>
<p>{0x22,0xf0}, //[3:0]vref</p>
<p>{0x23,0xc3}, //f3//ADC_r</p>
<p>{0x24,0x1a}, //16//pad drive</p>
<p>//==============================aec</p>
<p>//AEC</p>
<p>{0xfe,0x01},</p>
<p>{0x11,0x20},//AEC_out_slope,0x</p>
<p>{0x1f,0x80},//max_post_gain</p>
<p>{0x20,0x40},//max_pre_gain</p>
<p>{0x47,0x30},//AEC_outdoor_th</p>
<p>{0x0b,0x10},//</p>
<p>{0x13,0x90},//63//y_target</p>
<p>{0xfe,0x00},</p>
<p>{0xfe,0x00}, </p>
<p>{0xb6,0x03}, //AEC enable</p>
<p>{0xfe,0x00},</p>
<p>////======================BLK</p>
<p>{0x3f,0x00}, //prc close</p>
<p>{0x40,0x77},//</p>
<p>{0x42,0x7f},</p>
<p>{0x43,0x30},</p>
<p>{0x5c,0x08},</p>
<p>{0x5e,0x20},</p>
<p>{0x5f,0x20},</p>
<p>{0x60,0x20},</p>
<p>{0x61,0x20},</p>
<p>{0x62,0x20},</p>
<p>{0x63,0x20},</p>
<p>{0x64,0x20},</p>
<p>{0x65,0x20},</p>
<p>///=================block</p>
<p>{0x80,0xff},//</p>
<p>{0x81,0x26},//38},skin_Y 8c_debug</p>
<p>{0x87,0xb0}, //[7]middle gamma </p>
<p>{0x03,0x05},</p>
<p>{0x04,0x2e}, </p>
<p>{0x84,0x00}, //output put foramat</p>
<p>{0x86,0x03}, //sync plority</p>
<p>{0x8b,0xbc},</p>
<p>{0xb0,0x80}, //globle gain</p>
<p>{0xc0,0x40},//Yuv bypass</p>
<p>//===============================lsc</p>
<p>{0xfe,0x01},</p>
<p>{0xc2,0x14},</p>
<p>{0xc3,0x0b},</p>
<p>{0xc4,0x06},</p>
<p>{0xc8,0x1b},</p>
<p>{0xc9,0x0c},</p>
<p>{0xca,0x00},</p>
<p>{0xbc,0x19},</p>
<p>{0xbd,0x0c},</p>
<p>{0xbe,0x0b},</p>
<p>{0xb6,0x28},</p>
<p>{0xb7,0x18},</p>
<p>{0xb8,0x00},</p>
<p>{0xc5,0x00},</p>
<p>{0xc6,0x00},</p>
<p>{0xc7,0x00},</p>
<p>{0xcb,0x22},</p>
<p>{0xcc,0x0f},</p>
<p>{0xcd,0x07},</p>
<p>{0xbf,0x10},</p>
<p>{0xc0,0x0c},</p>
<p>{0xc1,0x0b},</p>
<p>{0xb9,0x10},</p>
<p>{0xba,0x0f},</p>
<p>{0xbb,0x0c},</p>
<p>{0xaa,0x1a},</p>
<p>{0xab,0x15},</p>
<p>{0xac,0x1c},</p>
<p>{0xad,0x23},</p>
<p>{0xae,0x1e},</p>
<p>{0xaf,0x26},</p>
<p>{0xb0,0x12},</p>
<p>{0xb1,0x0f},</p>
<p>{0xb2,0x14},</p>
<p>{0xb3,0x13},</p>
<p>{0xb4,0x12},</p>
<p>{0xb5,0x1c},</p>
<p>{0xd0,0x2f},</p>
<p>{0xd2,0x39},</p>
<p>{0xd3,0x40},</p>
<p>{0xd8,0x0f},</p>
<p>{0xda,0x24},</p>
<p>{0xdb,0x19},</p>
<p>{0xdc,0x00},</p>
<p>{0xde,0x0a},</p>
<p>{0xdf,0x0b},</p>
<p>{0xd4,0x00},</p>
<p>{0xd6,0x0d},</p>
<p>{0xd7,0x04},</p>
<p>{0xa4,0x00},</p>
<p>{0xa5,0x00},</p>
<p>{0xa6,0x60},</p>
<p>{0xa7,0x06},</p>
<p>{0xa8,0x00},</p>
<p>{0xa9,0x00},</p>
<p>{0xa1,0x80},</p>
<p>{0xa2,0x80},</p>
<p>//=================================cc</p>
<p>{0xfe,0x02},</p>
<p>{0xc0,0x01},</p>
<p>{0xc1,0x40}, //Green_cc for d</p>
<p>{0xc2,0xfc},</p>
<p>{0xc3,0x05},</p>
<p>{0xc4,0xec},</p>
<p>{0xc5,0x42},</p>
<p>{0xc6,0xf8},</p>
<p>{0xc7,0x40},//for cwf </p>
<p>{0xc8,0xf8},</p>
<p>{0xc9,0x06},</p>
<p>{0xca,0xfd},</p>
<p>{0xcb,0x3e},</p>
<p>{0xcc,0xf3},</p>
<p>{0xcd,0x36},//for A</p>
<p>{0xce,0xf6},</p>
<p>{0xcf,0x04},</p>
<p>{0xe3,0x0c},</p>
<p>{0xe4,0x44},</p>
<p>{0xe5,0xe5},</p>
<p>{0xfe,0x00},</p>
<p>//==============================awb</p>
<p>//AWB clear</p>
<p>{0xfe,0x01},</p>
<p>{0x4f,0x00},</p>
<p>{0x4d,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0x10}, // 10</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0x20}, // 20</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0x30},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00}, // 30</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0x40}, // 40</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0x50}, // 50</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0x60}, // 60</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0x70}, // 70</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0x80}, // 80</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0x90}, // 90</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0xa0}, // a0</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0xb0}, // b0</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0xc0}, // c0</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4d,0xd0}, // d0</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x00},</p>
<p>{0x4f,0x01},</p>
<p>/////// awb value////////</p>
<p>{0xfe,0x01},</p>
<p>{0x4f,0x00},</p>
<p>{0x4d,0x30},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x80},</p>
<p>{0x4e,0x80},</p>
<p>{0x4e,0x02},</p>
<p>{0x4e,0x02},</p>
<p>{0x4d,0x40},</p>
<p>{0x4e,0x00},</p>
<p>{0x4e,0x80},</p>
<p>{0x4e,0x80},</p>
<p>{0x4e,0x02},</p>
<p>{0x4e,0x02},</p>
<p>{0x4e,0x02},</p>
<p>{0x4d,0x53},</p>
<p>{0x4e,0x08},</p>
<p>{0x4e,0x04},</p>
<p>{0x4d,0x62},</p>
<p>{0x4e,0x10},</p>
<p>{0x4d,0x72},</p>
<p>{0x4e,0x20},</p>
<p>{0x4f,0x01},</p>
<p>/////awb////</p>
<p>{0xfe,0x01},</p>
<p>{0x50,0x88},//c0//[6]green mode</p>
<p>{0x52,0x40},</p>
<p>{0x54,0x60},</p>
<p>{0x56,0x06},</p>
<p>{0x57,0x20}, //pre adjust</p>
<p>{0x58,0x01}, </p>
<p>{0x5b,0x02}, //AWB_gain_delta</p>
<p>{0x61,0xaa},//R/G stand</p>
<p>{0x62,0xaa},//R/G stand</p>
<p>{0x71,0x00},</p>
<p>{0x74,0x10},//AWB_C_max</p>
<p>{0x77,0x08}, // 0x//AWB_p2_x</p>
<p>{0x78,0xfd}, //AWB_p2_y</p>
<p>{0x86,0x30},</p>
<p>{0x87,0x00},</p>
<p>{0x88,0x04},//06},[1]dark mode</p>
<p>{0x8a,0xc0},//awb move mode</p>
<p>{0x89,0x75},</p>
<p>{0x84,0x08},//auto_window</p>
<p>{0x8b,0x00}, // 0x//awb compare luma</p>
<p>{0x8d,0x70}, //awb gain limit R </p>
<p>{0x8e,0x70},//G</p>
<p>{0x8f,0xf4},//B</p>
<p>{0xfe,0x00},</p>
<p>{0x82,0x02},//awb_en</p>
<p>///==========================asde</p>
<p>{0xfe,0x01},</p>
<p>{0x21,0xbf},</p>
<p>{0xfe,0x02},</p>
<p>{0xa4,0x00},//asde_offset_slope ?§?????￡¤</p>
<p>{0xa5,0x40}, //lsc_th</p>
<p>{0xa2,0xa0}, //lsc_dec_slope</p>
<p>{0xa6,0x80}, //dd_th</p>
<p>{0xa7,0x80}, //ot_th</p>
<p>{0xab,0x31}, //[0]b_dn_effect_dark_inc_or_dec</p>
<p>{0xa9,0x6f}, //[7:4] ASDE_DN_b_slope_high</p>
<p>//[3:0] ASDE_DN_b_slope_low</p>
<p>{0xb0,0x99}, //0x//edge effect slope low</p>
<p>{0xb1,0x34},//edge effect slope low</p>
<p>{0xb3,0x70}, //saturation dec slope  80</p>
<p>{0xb4,0x41}, //ASDE_auto_saturation   anstor add  </p>
<p>{0xde,0xb6},</p>
<p>{0x38,0x0f }, // auto_gray_dec_slope  0f</p>
<p>{0x39,0x40}, //</p>
<p>{0xfe,0x00},</p>
<p>{0x81,0x26},</p>
<p>{0xfe,0x02},</p>
<p>{0x83,0x00},//[6]green_bks_auto [5]gobal_green_bks</p>
<p>{0x84,0x45},//RB offset</p>
<p>///=================YCP</p>
<p>{0xd1,0x40},//saturation_cb</p>
<p>{0xd2,0x40},//saturation_Cr</p>
<p>{0xd3,0x40},//contrast 2012.10.26????§?</p>
<p>{0xd4,0x80},//contrast center 2012.10.26????§?</p>
<p>{0xd5,0xfc},//luma_offset 2012.10.26????§?</p>
<p>{0xdc,0x30},</p>
<p>{0xdd,0xb8},//edge_sa_g,b</p>
<p>{0xfe,0x00},</p>
<p>////=================dndd</p>
<p>{0xfe,0x02},</p>
<p>{0x88,0x15},//dn_b_base</p>
<p>{0x8c,0xf6}, //[2]b_in_dark_inc</p>
<p>{0x89,0x03}, //dn_c_weight</p>
<p>////==================EE 2012.10.26</p>
<p>{0xfe,0x02},</p>
<p>{0x90,0x6c},// EEINTP mode1</p>
<p>{0x97,0x48},// edge effect</p>
<p>////==============RGB Gamma ???§?gamma 2012.10.26</p>
<p>{0xfe,0x02},</p>
<p>{0x15,0x05},</p>
<p>{0x16,0x0b},</p>
<p>{0x17,0x10},</p>
<p>{0x18,0x16},</p>
<p>{0x19,0x24},</p>
<p>{0x1a,0x32},</p>
<p>{0x1b,0x42},</p>
<p>{0x1c,0x4e},</p>
<p>{0x1d,0x64},</p>
<p>{0x1e,0x76},</p>
<p>{0x1f,0x86},</p>
<p>{0x20,0x94},</p>
<p>{0x21,0x9f},</p>
<p>{0x22,0xb4},</p>
<p>{0x23,0xc3},</p>
<p>{0x24,0xce},</p>
<p>{0x25,0xd7},</p>
<p>{0x26,0xe3},</p>
<p>{0x27,0xec},</p>
<p>{0x28,0xf0},   //  0xf7</p>
<p>{0x29,0xf6},   //  0xff </p>
<p>///=================y gamma</p>
<p>//y-gamma</p>
<p>{0x2b,0x00},</p>
<p>{0x2c,0x04},</p>
<p>{0x2d,0x09},</p>
<p>{0x2e,0x18},</p>
<p>{0x2f,0x27},</p>
<p>{0x30,0x37},</p>
<p>{0x31,0x49},</p>
<p>{0x32,0x5c},</p>
<p>{0x33,0x7e},</p>
<p>{0x34,0xa0},</p>
<p>{0x35,0xc0},</p>
<p>{0x36,0xe0},</p>
<p>{0x37,0xf0},   // 0xff</p>
<p>/////1600x1200size// </p>
<p>{0xfe,0x00},//</p>
<p>{0x90,0x01}, //0x//crop enable</p>
<p>{0x95,0x04},//1600x1200</p>
<p>{0x96,0xb0},</p>
<p>{0x97,0x06},</p>
<p>{0x98,0x40},</p>
<p>{0xfe,0x03},</p>
<p>{0x42,0x40}, </p>
<p>{0x43,0x06}, //output buf width 800x2</p>
<p>{0x41,0x02}, // Pclk_polarity</p>
<p>{0x40,0x40},</p>
<p>{0x17,0x00}, //widv </p>
<p>{0xfe,0x00},</p>
<p>////output DVP/////</p>
<p>//Sleep(100},</p>
<p>{0xfe,0x00},</p>
<p>{0x82,0xfe},</p>
<p>{0xf2,0x70}, </p>
<p>{0xf3,0xff},</p>
<p>{0xf4,0x00},</p>
<p>{0xf5,0x30},</p>
<p>{0xfe , 0x00},</p>
<p>{0x0a , 0x00}, //row start</p>
<p>{0x0c , 0x00}, //col start</p>
<p>{0x0d , 0x04},</p>
<p>{0x0e , 0xc0},</p>
<p>{0x0f , 0x06}, //Window setting</p>
<p>{0x10 , 0x58},// </p>
<p>{0xfe,0x00},</p>
<p>{0xec,0x04},</p>
<p>{0xed,0x04},</p>
<p>{0xee,0x60},</p>
<p>{0xef,0x90},</p>
<p>{0x05,0x01},//hb</p>
<p>{0x06,0x11},</p>
<p>{0x07,0x00},//vb</p>
<p>{0x08,0x50},</p>
<p>{0xfe,0x01},</p>
<p>{0x27,0x00},//step</p>
<p>{0x28,0xa0},</p>
<p>{0x29,0x05},//level1</p>
<p>{0x2a,0x00},</p>
<p>{0x2b,0x05},//level2</p>
<p>{0x2c,0x00},</p>
<p>{0x2d,0x05},//6e8//level3</p>
<p>{0x2e,0x00},</p>
<p>{0x2f,0x0f},//level4</p>
<p>{0x30,0x00},</p>
<p>{0xfe,0x00},</p>
<p>{0xb6,0x03},//aec on</p>
<p>/*<strong><strong><strong><strong>****</strong></strong></strong></strong>/</p>
<p>{0xfe,0x00},  </p>
<p>//subsample for svga</p>
<p>{0x0c,0x04}, //col  start</p>
<p>{0x0d,0x04},</p>
<p>{0x0e,0xc0},</p>
<p>{0x0f,0x06},</p>
<p>{0x10,0x56},  //50</p>
<p>{0x99,0x22},</p>
<p>{0x9b,0x00},</p>
<p>{0x9f,0x00},</p>
<p>{0x90,0x01},</p>
<p>{0x95,0x02},</p>
<p>{0x96,0x58},//600</p>
<p>{0x97,0x03},</p>
<p>{0x98,0x20},//800</p>
<p>{0xfe,0x03},</p>
<p>{0x42,0x80}, </p>
<p>{0x43,0x06}, //output buf width</p>
<p>{0x41,0x00}, // delay</p>
<p>{0x40,0x00}, //fifo half full trig</p>
<p>{0x17,0x01}, //widv </p>
<p>{0xfe,0x00},</p>
<p>{0xc8,0x00}, </p>
<p>{0xfa,0x00}, </p>
<p>{0x00,0x00}, </p>
<p>};</p>
<p>static struct reginfo sensor_720p[] =</p>
<p>{</p>
<p>{0xfe ,0x00},</p>
<p>{0x0a ,0xf0}, //row start</p>
<p>{0x0c ,0xa0}, //col start </p>
<p>{0x0d ,0x02},</p>
<p>{0x0e ,0xd8},</p>
<p>{0x0f ,0x05}, //Window setting</p>
<p>{0x10 ,0x18},   </p>
<p>{0xfe,0x00},</p>
<p>{0xec,0x04},</p>
<p>{0xed,0x04},</p>
<p>{0xee,0x50},</p>
<p>{0xef,0x58},</p>
<p>{0x05 , 0x01},//hb</p>
<p>{0x06 , 0xaa},</p>
<p>{0x07 , 0x00},//b</p>
<p>{0x08 , 0xf6},</p>
<p>{0xfe , 0x01},</p>
<p>{0x27 , 0x00},//step</p>
<p>{0x28 , 0xa1},</p>
<p>{0x29 , 0x03},//level1  16 fps</p>
<p>{0x2a , 0xc6},</p>
<p>{0x2b , 0x04},//level2  14</p>
<p>{0x2c , 0x67},</p>
<p>{0x2d , 0x06},//level3   10</p>
<p>{0x2e , 0x4a},</p>
<p>{0x2f , 0x07},//level4  8</p>
<p>{0x30 , 0x8c},</p>
<p>{0x3e,0x40},//0x40 0x00</p>
<p>//measure window</p>
<p>{0xfe,0x00},</p>
<p>{0xb6,0x03},//aec on</p>
<p>{0xec,0x04},</p>
<p>{0xed,0x04},</p>
<p>{0xee,0x50},</p>
<p>{0xef,0x58},</p>
<p>{0x99,0x11},</p>
<p>{0x90 ,0x01},  //crop enable</p>
<p>{0x95 ,0x02},</p>
<p>{0x96 ,0xd0},</p>
<p>{0x97 ,0x05},</p>
<p>{0x98 ,0x00},   </p>
<p>{0xfe ,0x03},</p>
<p>{0x42 ,0x80}, </p>
<p>{0x43 ,0x06}, //output buf width</p>
<p>{0x41 ,0x00}, // delay</p>
<p>{0x40 ,0x00}, //fifo half full trig</p>
<p>{0x17 ,0x01}, //widv </p>
<p>{0xfe ,0x00},</p>
<p>{0xc8,0x00},</p>
<p>{0xfa,0x11},</p>
<p>{0x00 , 0x00},</p>
<p>};</p>
<p>/* 1600X1200 UXGA */</p>
<p>static struct reginfo sensor_uxga[] = </p>
<p>{</p>
<p>{0xfe , 0x00},</p>
<p>{0x0a , 0x00}, //row start</p>
<p>{0x0c , 0x00}, //col start</p>
<p>{0x0d , 0x04},</p>
<p>{0x0e , 0xc0},</p>
<p>{0x0f , 0x06}, //Window setting</p>
<p>{0x10 , 0x58},// </p>
<p>{0x90 , 0x01},  //crop enable</p>
<p>{0x94 , 0x04},// x_start</p>
<p>{0x95 , 0x04},</p>
<p>{0x96 , 0xb0},</p>
<p>{0x97 , 0x06},</p>
<p>{0x98 , 0x40},</p>
<p>{0x99 , 0x11},</p>
<p>{0xc8 , 0x00},</p>
<p>//{0xfa , 0x11},</p>
<p>{0xfe , 0x03},</p>
<p>{0x42 , 0x80}, </p>
<p>{0x43 , 0x06}, //output buf width</p>
<p>{0x41 , 0x00}, // delay</p>
<p>{0x40 , 0x00}, //fifo half full trig</p>
<p>{0x17 , 0x01}, //widv </p>
<p>{0xfe , 0x00},</p>
<p>{0xc8 , 0x00},</p>
<p>{0x00 , 0x00}, </p>
<p>};</p>
<p>/* 1280X1024 SXGA */</p>
<p>static struct reginfo sensor_sxga[] =</p>
<p>{</p>
<p>{0x0, 0x0},</p>
<p>};</p>
<p>/* 800X600 SVGA*/</p>
<p>static struct reginfo sensor_svga[] =</p>
<p>{</p>
<p>{0xfe,0x00},</p>
<p>{0x0a,0x00}, //row start</p>
<p>{0x0c,0x00}, //col start</p>
<p>{0x0d,0x04},</p>
<p>{0x0e,0xc0},</p>
<p>{0x0f,0x06}, //Window setting</p>
<p>{0x10,0x58},// </p>
<p>{0xfe,0x00},</p>
<p>{0xec,0x04},</p>
<p>{0xed,0x04},</p>
<p>{0xee,0x60},</p>
<p>{0xef,0x90},</p>
<p>{0x05,0x01},//hb</p>
<p>{0x06,0x11},</p>
<p>{0x07,0x00},//vb</p>
<p>{0x08,0x50},</p>
<p>{0xfe,0x01},</p>
<p>{0x27,0x00},//step</p>
<p>{0x28,0xa0},</p>
<p>{0x29,0x05},//level1</p>
<p>{0x2a,0x00},</p>
<p>{0x2b,0x06},//level2</p>
<p>{0x2c,0x40},</p>
<p>{0x2d,0x07},//6e8//level3</p>
<p>{0x2e,0x80},</p>
<p>{0x2f,0x0f},//level4</p>
<p>{0x30,0x00},</p>
<p>{0xfe,0x00},</p>
<p>{0xb6,0x03},//aec on</p>
<p>/*<strong><strong><strong><strong>****</strong></strong></strong></strong>/</p>
<p>{0xfe,0x00},  </p>
<p>//subsample for svga</p>
<p>{0x0c,0x04}, //col  start</p>
<p>{0x0d,0x04},</p>
<p>{0x0e,0xc0},</p>
<p>{0x0f,0x06},</p>
<p>{0x10,0x56},  //50</p>
<p>{0x99,0x22},</p>
<p>{0x9b,0x00},</p>
<p>{0x9f,0x00},</p>
<p>{0x90,0x01},</p>
<p>{0x95,0x02},</p>
<p>{0x96,0x58},//600</p>
<p>{0x97,0x03},</p>
<p>{0x98,0x20},//800</p>
<p>{0xfe,0x03},</p>
<p>{0x42,0x80}, </p>
<p>{0x43,0x06}, //output buf width</p>
<p>{0x41,0x00}, // delay</p>
<p>{0x40,0x00}, //fifo half full trig</p>
<p>{0x17,0x01}, //widv </p>
<p>{0xfe,0x00},</p>
<p>{0xc8,0x00}, </p>
<p>{0xfa,0x00}, </p>
<p>{0x00 , 0x00},</p>
<p>/*<strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong>/</p>
<p>};</p>
<p>/* 640X480 VGA */</p>
<p>static struct reginfo sensor_vga[] =</p>
<p>{</p>
<p>{0x00 , 0x00},</p>
<p>};</p>
<p>/* 352X288 CIF */</p>
<p>static struct reginfo sensor_cif[] =</p>
<p>{</p>
<p>    {0x0, 0x0},</p>
<p>};</p>
<p>/* 320*240 QVGA */</p>
<p>static  struct reginfo sensor_qvga[] =</p>
<p>{</p>
<p>    {0x0, 0x0},</p>
<p>};</p>
<p>/* 176X144 QCIF*/</p>
<p>static struct reginfo sensor_qcif[] =</p>
<p>{</p>
<p>    {0x0, 0x0},</p>
<p>};</p>
<p>#endif</p>
<p>static  struct reginfo sensor_ClrFmt_YUYV[]=</p>
<p>{</p>
<p>         {0x0, 0x0},</p>
<p>};</p>
<p>static  struct reginfo sensor_ClrFmt_UYVY[]=</p>
<p>{</p>
<p>           {0x0, 0x0},</p>
<p>};</p>
<p>#if CONFIG_SENSOR_WhiteBalance</p>
<p>static  struct reginfo sensor_WhiteB_Auto[]=</p>
<p>{</p>
<p>                     {0xfe, 0x00},</p>
<p>{0xb3, 0x61},</p>
<p>{0xb4, 0x40},</p>
<p>{0xb5, 0x61},</p>
<p>{0x82, 0xfe},</p>
<p>             {0x0, 0x0},</p>
<p>};</p>
<p>/* Cloudy Colour Temperature : 6500K - 8000K  */</p>
<p>static  struct reginfo sensor_WhiteB_Cloudy[]=</p>
<p>{</p>
<p>                     {0xfe, 0x00},</p>
<p>{0x82, 0xfc},</p>
<p>{0xb3, 0x58},</p>
<p>{0xb4, 0x40},</p>
<p>{0xb5, 0x50},</p>
<p>             {0x0, 0x0},</p>
<p>};</p>
<p>/* ClearDay Colour Temperature : 5000K - 6500K  */</p>
<p>static  struct reginfo sensor_WhiteB_ClearDay[]=</p>
<p>{</p>
<p>    //Sunny</p>
<p>                     {0xfe, 0x00},</p>
<p>{0x82, 0xfc},</p>
<p>{0xb3, 0x58},</p>
<p>{0xb4, 0x40},</p>
<p>{0xb5, 0x50},</p>
<p>             {0x0, 0x0},</p>
<p>};</p>
<p>/* Office Colour Temperature : 3500K - 5000K  */</p>
<p>static  struct reginfo sensor_WhiteB_TungstenLamp1[]=</p>
<p>{</p>
<p>    //Office</p>
<p>                     {0xfe, 0x00},</p>
<p>{0x82, 0xfc},</p>
<p>{0xb3, 0x50},</p>
<p>{0xb4, 0x40},</p>
<p>{0xb5, 0xa8},</p>
<p>{0x0, 0x0},</p>
<p>};</p>
<p>/* Home Colour Temperature : 2500K - 3500K  */</p>
<p>static  struct reginfo sensor_WhiteB_TungstenLamp2[]=</p>
<p>{</p>
<p>    //Home</p>
<p>                     {0xfe, 0x00},</p>
<p>{0x82, 0xfc},</p>
<p>{0xb3, 0xa0},</p>
<p>{0xb4, 0x45},</p>
<p>{0xb5, 0x40},</p>
<p>      {0x0, 0x0},</p>
<p>};</p>
<p>static struct reginfo *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,</p>
<p>    sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,</p>
<p>};</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Brightness</p>
<p>static  struct reginfo sensor_Brightness0[]=</p>
<p>{</p>
<p>    // Brightness -2</p>
<p>       {0x00, 0x00},</p>
<p>};</p>
<p>static  struct reginfo sensor_Brightness1[]=</p>
<p>{</p>
<p>    // Brightness -1</p>
<p>       {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Brightness2[]=</p>
<p>{</p>
<p>    //  Brightness 0</p>
<p>       {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Brightness3[]=</p>
<p>{</p>
<p>    // Brightness +1</p>
<p>       {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Brightness4[]=</p>
<p>{</p>
<p>    //  Brightness +2</p>
<p>       {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Brightness5[]=</p>
<p>{</p>
<p>    //  Brightness +3</p>
<p>{0x00, 0x00}</p>
<p>};</p>
<p>static struct reginfo *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,</p>
<p>    sensor_Brightness4, sensor_Brightness5,NULL,</p>
<p>};</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Effect</p>
<p>static  struct reginfo sensor_Effect_Normal[] =</p>
<p>{</p>
<p>{0xfe, 0x00},</p>
<p>{0x83, 0xe0},</p>
<p>{0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Effect_WandB[] =</p>
<p>{</p>
<p>{0xfe, 0x00},</p>
<p>{0x83, 0x12},</p>
<p>{0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Effect_Sepia[] =</p>
<p>{</p>
<p>{0xfe, 0x00},</p>
<p>{0x83, 0x82},</p>
<p>{0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Effect_Negative[] =</p>
<p>{</p>
<p>    //Negative</p>
<p>{0xfe, 0x00},</p>
<p>{0x83, 0x01},</p>
<p>{0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Effect_Bluish[] =</p>
<p>{</p>
<p>    // Bluish</p>
<p>{0xfe, 0x00},</p>
<p>{0x83, 0x62},</p>
<p>{0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Effect_Green[] =</p>
<p>{</p>
<p>    //  Greenish</p>
<p>{0xfe, 0x00},</p>
<p>{0x83, 0x52},</p>
<p>{0x00, 0x00}</p>
<p>};</p>
<p>static struct reginfo *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_WandB, sensor_Effect_Negative,sensor_Effect_Sepia,</p>
<p>    sensor_Effect_Bluish, sensor_Effect_Green,NULL,</p>
<p>};</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Exposure</p>
<p>static  struct reginfo sensor_Exposure0[]=</p>
<p>{</p>
<p>    //-3</p>
<p>    {0xfe,0x01},</p>
<p>    {0x13,0x40},</p>
<p>    {0xfe,0x00},</p>
<p>       {0x00,0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Exposure1[]=</p>
<p>{</p>
<p>    //-2</p>
<p>{0xfe,0x01},</p>
<p>    {0x13,0x50},</p>
<p>    {0xfe,0x00},</p>
<p>       {0x00,0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Exposure2[]=</p>
<p>{</p>
<p>    //-0.3EV</p>
<p>{0xfe,0x01},</p>
<p>    {0x13,0x60},</p>
<p>    {0xfe,0x00},</p>
<p>       {0x00,0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Exposure3[]=</p>
<p>{</p>
<p>    //default</p>
<p>  {0xfe,0x01},</p>
<p>    {0x13,0x90},</p>
<p>    {0xfe,0x00},</p>
<p>       {0x00,0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Exposure4[]=</p>
<p>{</p>
<p>    // 1</p>
<p>{0xfe,0x01},</p>
<p>    {0x13,0x98},</p>
<p>    {0xfe,0x00},</p>
<p>       {0x00,0x00}};</p>
<p>static  struct reginfo sensor_Exposure5[]=</p>
<p>{</p>
<p>    // 2</p>
<p>  {0xfe,0x01},</p>
<p>    {0x13,0xa8},</p>
<p>    {0xfe,0x00},</p>
<p>       {0x00,0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Exposure6[]=</p>
<p>{</p>
<p>    // 3</p>
<p>  {0xfe,0x01},</p>
<p>    {0x13,0x98},</p>
<p>    {0xfe,0x00},</p>
<p>       {0x00,0x00}</p>
<p>};</p>
<p>static struct reginfo *sensor_ExposureSeqe[] = {sensor_Exposure0, sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,</p>
<p>    sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,NULL,</p>
<p>};</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Saturation</p>
<p>static  struct reginfo sensor_Saturation0[]=</p>
<p>{</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Saturation1[]=</p>
<p>{</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Saturation2[]=</p>
<p>{</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static struct reginfo *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Contrast</p>
<p>static  struct reginfo sensor_Contrast0[]=</p>
<p>{</p>
<p>    //Contrast -3</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Contrast1[]=</p>
<p>{</p>
<p>    //Contrast -2</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Contrast2[]=</p>
<p>{</p>
<p>    // Contrast -1</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Contrast3[]=</p>
<p>{</p>
<p>    //Contrast 0</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Contrast4[]=</p>
<p>{</p>
<p>    //Contrast +1</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Contrast5[]=</p>
<p>{</p>
<p>    //Contrast +2</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_Contrast6[]=</p>
<p>{</p>
<p>    //Contrast +3</p>
<p>    {0x00, 0x00}</p>
<p>};</p>
<p>static struct reginfo *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,</p>
<p>    sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,</p>
<p>};</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Mirror</p>
<p>static  struct reginfo sensor_MirrorOn[]=</p>
<p>{</p>
<p>    {0x17 , 0x14},</p>
<p>    {0x00 , 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_MirrorOff[]=</p>
<p>{</p>
<p>    {0x17 , 0x15},</p>
<p>    {0x00 , 0x00}</p>
<p>};</p>
<p>static struct reginfo *sensor_MirrorSeqe[] = {sensor_MirrorOff, sensor_MirrorOn,NULL,};</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Flip</p>
<p>static  struct reginfo sensor_FlipOn[]=</p>
<p>{</p>
<p>    {0x17 , 0x16},</p>
<p>    {0x00 , 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_FlipOff[]=</p>
<p>{</p>
<p>    {0x17 , 0x17},</p>
<p>    {0x00 , 0x00}</p>
<p>};</p>
<p>static struct reginfo *sensor_FlipSeqe[] = {sensor_FlipOff, sensor_FlipOn,NULL,};</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Scene</p>
<p>static  struct reginfo sensor_SceneAuto[] =</p>
<p>{</p>
<p>{0xfe,0x01},</p>
<p>{0x3e,0x40},  </p>
<p>{0xfe,0x00},</p>
<p>{0x00, 0x00}</p>
<p>};</p>
<p>static  struct reginfo sensor_SceneNight[] =</p>
<p>{</p>
<p>{0xfe,0x01},</p>
<p>{0x3e,0x60},  </p>
<p>{0xfe,0x00},</p>
<p>{0x00, 0x00}</p>
<p>};</p>
<p>static struct reginfo *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight,NULL,};</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_DigitalZoom</p>
<p>static struct reginfo sensor_Zoom0[] =</p>
<p>{</p>
<p>    {0x0, 0x0},</p>
<p>};</p>
<p>static struct reginfo sensor_Zoom1[] =</p>
<p>{</p>
<p>     {0x0, 0x0},</p>
<p>};</p>
<p>static struct reginfo sensor_Zoom2[] =</p>
<p>{</p>
<p>    {0x0, 0x0},</p>
<p>};</p>
<p>static struct reginfo sensor_Zoom3[] =</p>
<p>{</p>
<p>    {0x0, 0x0},</p>
<p>};</p>
<p>static struct reginfo *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL,};</p>
<p>#endif</p>
<p>static const struct v4l2_querymenu sensor_menus[] =</p>
<p>{</p>
<p>#if CONFIG_SENSOR_WhiteBalance</p>
<p>    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 0,  .name = &quot;auto&quot;,  .reserved = 0, }, {  .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 1, .name = &quot;incandescent&quot;,  .reserved = 0,},</p>
<p>    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 2,  .name = &quot;fluorescent&quot;, .reserved = 0,}, {  .id = V4L2_CID_DO_WHITE_BALANCE, .index = 3,  .name = &quot;daylight&quot;, .reserved = 0,},</p>
<p>    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 4,  .name = &quot;cloudy-daylight&quot;, .reserved = 0,},</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Effect</p>
<p>    { .id = V4L2_CID_EFFECT,  .index = 0,  .name = &quot;none&quot;,  .reserved = 0, }, {  .id = V4L2_CID_EFFECT,  .index = 1, .name = &quot;mono&quot;,  .reserved = 0,},</p>
<p>    { .id = V4L2_CID_EFFECT,  .index = 2,  .name = &quot;negative&quot;, .reserved = 0,}, {  .id = V4L2_CID_EFFECT, .index = 3,  .name = &quot;sepia&quot;, .reserved = 0,},</p>
<p>    { .id = V4L2_CID_EFFECT,  .index = 4, .name = &quot;posterize&quot;, .reserved = 0,} ,{ .id = V4L2_CID_EFFECT,  .index = 5,  .name = &quot;aqua&quot;, .reserved = 0,},</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Scene</p>
<p>    { .id = V4L2_CID_SCENE,  .index = 0, .name = &quot;auto&quot;, .reserved = 0,} ,{ .id = V4L2_CID_SCENE,  .index = 1,  .name = &quot;night&quot;, .reserved = 0,},</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Flash</p>
<p>    { .id = V4L2_CID_FLASH,  .index = 0,  .name = &quot;off&quot;,  .reserved = 0, }, {  .id = V4L2_CID_FLASH,  .index = 1, .name = &quot;auto&quot;,  .reserved = 0,},</p>
<p>    { .id = V4L2_CID_FLASH,  .index = 2,  .name = &quot;on&quot;, .reserved = 0,}, {  .id = V4L2_CID_FLASH, .index = 3,  .name = &quot;torch&quot;, .reserved = 0,},</p>
<p>    #endif</p>
<p>};</p>
<p>static  struct v4l2_queryctrl sensor_controls[] =</p>
<p>{</p>
<p>#if CONFIG_SENSOR_WhiteBalance</p>
<p>    {</p>
<p>        .id = V4L2_CID_DO_WHITE_BALANCE,</p>
<p>        .type = V4L2_CTRL_TYPE_MENU,</p>
<p>        .name = &quot;White Balance Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 4,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    },</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Brightness</p>
<p>{</p>
<p>        .id = V4L2_CID_BRIGHTNESS,</p>
<p>        .type = V4L2_CTRL_TYPE_INTEGER,</p>
<p>        .name = &quot;Brightness Control&quot;,</p>
<p>        .minimum = -3,</p>
<p>        .maximum = 2,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    },</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Effect</p>
<p>{</p>
<p>        .id = V4L2_CID_EFFECT,</p>
<p>        .type = V4L2_CTRL_TYPE_MENU,</p>
<p>        .name = &quot;Effect Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 5,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    },</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Exposure</p>
<p>{</p>
<p>        .id = V4L2_CID_EXPOSURE,</p>
<p>        .type = V4L2_CTRL_TYPE_INTEGER,</p>
<p>        .name = &quot;Exposure Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 6,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    },</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Saturation</p>
<p>{</p>
<p>        .id = V4L2_CID_SATURATION,</p>
<p>        .type = V4L2_CTRL_TYPE_INTEGER,</p>
<p>        .name = &quot;Saturation Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 2,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    },</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Contrast</p>
<p>{</p>
<p>        .id = V4L2_CID_CONTRAST,</p>
<p>        .type = V4L2_CTRL_TYPE_INTEGER,</p>
<p>        .name = &quot;Contrast Control&quot;,</p>
<p>        .minimum = -3,</p>
<p>        .maximum = 3,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    },</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Mirror</p>
<p>{</p>
<p>        .id = V4L2_CID_HFLIP,</p>
<p>        .type = V4L2_CTRL_TYPE_BOOLEAN,</p>
<p>        .name = &quot;Mirror Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 1,</p>
<p>        .step = 1,</p>
<p>        .default_value = 1,</p>
<p>    },</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Flip</p>
<p>{</p>
<p>        .id = V4L2_CID_VFLIP,</p>
<p>        .type = V4L2_CTRL_TYPE_BOOLEAN,</p>
<p>        .name = &quot;Flip Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 1,</p>
<p>        .step = 1,</p>
<p>        .default_value = 1,</p>
<p>    },</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Scene</p>
<p>    {</p>
<p>        .id = V4L2_CID_SCENE,</p>
<p>        .type = V4L2_CTRL_TYPE_MENU,</p>
<p>        .name = &quot;Scene Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 1,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    },</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_DigitalZoom</p>
<p>    {</p>
<p>        .id = V4L2_CID_ZOOM_RELATIVE,</p>
<p>        .type = V4L2_CTRL_TYPE_INTEGER,</p>
<p>        .name = &quot;DigitalZoom Control&quot;,</p>
<p>        .minimum = -1,</p>
<p>        .maximum = 1,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    }, {</p>
<p>        .id = V4L2_CID_ZOOM_ABSOLUTE,</p>
<p>        .type = V4L2_CTRL_TYPE_INTEGER,</p>
<p>        .name = &quot;DigitalZoom Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 3,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    },</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Focus</p>
<p>{</p>
<p>        .id = V4L2_CID_FOCUS_RELATIVE,</p>
<p>        .type = V4L2_CTRL_TYPE_INTEGER,</p>
<p>        .name = &quot;Focus Control&quot;,</p>
<p>        .minimum = -1,</p>
<p>        .maximum = 1,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    }, {</p>
<p>        .id = V4L2_CID_FOCUS_ABSOLUTE,</p>
<p>        .type = V4L2_CTRL_TYPE_INTEGER,</p>
<p>        .name = &quot;Focus Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 255,</p>
<p>        .step = 1,</p>
<p>        .default_value = 125,</p>
<p>    },</p>
<p>    #endif</p>
<p>#if CONFIG_SENSOR_Flash</p>
<p>{</p>
<p>        .id = V4L2_CID_FLASH,</p>
<p>        .type = V4L2_CTRL_TYPE_MENU,</p>
<p>        .name = &quot;Flash Control&quot;,</p>
<p>        .minimum = 0,</p>
<p>        .maximum = 3,</p>
<p>        .step = 1,</p>
<p>        .default_value = 0,</p>
<p>    },</p>
<p>#endif</p>
<p>};</p>
<p>static int sensor_probe(struct i2c_client *client, const struct i2c_device_id *did);</p>
<p>static int sensor_video_probe(struct soc_camera_device *icd, struct i2c_client *client);</p>
<p>static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);</p>
<p>static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);</p>
<p>static int sensor_g_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);</p>
<p>static int sensor_s_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);</p>
<p>static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);</p>
<p>static int sensor_resume(struct soc_camera_device *icd);</p>
<p>static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);</p>
<p>static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);</p>
<p>static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);</p>
<p>static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);</p>
<p>static int sensor_deactivate(struct i2c_client *client);</p>
<p>static struct soc_camera_ops sensor_ops =</p>
<p>{</p>
<p>    .suspend                     = sensor_suspend,</p>
<p>    .resume                       = sensor_resume,</p>
<p>    .set_bus_param = sensor_set_bus_param,</p>
<p>    .query_bus_param = sensor_query_bus_param,</p>
<p>    .controls = sensor_controls,</p>
<p>    .menus                         = sensor_menus,</p>
<p>    .num_controls = ARRAY_SIZE(sensor_controls),</p>
<p>    .num_menus = ARRAY_SIZE(sensor_menus),</p>
<p>};</p>
<p>/* only one fixed colorspace per pixelcode */</p>
<p>struct sensor_datafmt {</p>
<p>enum v4l2_mbus_pixelcode code;</p>
<p>enum v4l2_colorspace colorspace;</p>
<p>};</p>
<p>/* Find a data format by a pixel code in an array */</p>
<p>static const struct sensor_datafmt *sensor_find_datafmt(</p>
<p>enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,</p>
<p>int n)</p>
<p>{</p>
<p>int i;</p>
<p>for (i = 0; i &lt; n; i++)</p>
<p>if (fmt[i].code == code)</p>
<p>return fmt + i;</p>
<p>return NULL;</p>
<p>}</p>
<p>static const struct sensor_datafmt sensor_colour_fmts[] = {</p>
<p>{V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},</p>
<p>    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG},</p>
<p>};</p>
<p>typedef struct sensor_info_priv_s</p>
<p>{</p>
<p>    int whiteBalance;</p>
<p>    int brightness;</p>
<p>    int contrast;</p>
<p>    int saturation;</p>
<p>    int effect;</p>
<p>    int scene;</p>
<p>    int digitalzoom;</p>
<p>    int focus;</p>
<p>    int flash;</p>
<p>    int exposure;</p>
<p>bool snap2preview;</p>
<p>bool video2preview;</p>
<p>    unsigned char mirror;                                        /* HFLIP */</p>
<p>    unsigned char flip;                                          /* VFLIP */</p>
<p>    unsigned int winseqe_cur_addr;</p>
<p>    struct sensor_datafmt fmt;</p>
<p>    unsigned int funmodule_state;</p>
<p>} sensor_info_priv_t;</p>
<p>struct sensor</p>
<p>{</p>
<p>    struct v4l2_subdev subdev;</p>
<p>    struct i2c_client *client;</p>
<p>    sensor_info_priv_t info_priv;</p>
<p>    int model; /* V4L2_IDENT_OV* codes from v4l2-chip-ident.h */</p>
<p>#if CONFIG_SENSOR_I2C_NOSCHED</p>
<p>atomic_t tasklock_cnt;</p>
<p>#endif</p>
<p>struct rk29camera_platform_data *sensor_io_request;</p>
<p>    struct rk29camera_gpio_res *sensor_gpio_res;</p>
<p>};</p>
<p>static struct sensor* to_sensor(const struct i2c_client *client)</p>
<p>{</p>
<p>    return container_of(i2c_get_clientdata(client), struct sensor, subdev);</p>
<p>}</p>
<p>static int sensor_task_lock(struct i2c_client *client, int lock)</p>
<p>{</p>
<p>#if CONFIG_SENSOR_I2C_NOSCHED</p>
<p>int cnt = 3;</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>if (lock) {</p>
<p>if (atomic_read(&amp;sensor-&gt;tasklock_cnt) == 0) {</p>
<p>while ((atomic_read(&amp;client-&gt;adapter-&gt;bus_lock.count) &lt; 1) &amp;&amp; (cnt&gt;0)) {</p>
<p>SENSOR_TR(&quot;\n %s will obtain i2c in atomic, but i2c bus is locked! Wait…\n&quot;,SENSOR_NAME_STRING());</p>
<p>msleep(35);</p>
<p>cnt–;</p>
<p>}</p>
<p>if ((atomic_read(&amp;client-&gt;adapter-&gt;bus_lock.count) &lt; 1) &amp;&amp; (cnt&lt;=0)) {</p>
<p>SENSOR_TR(&quot;\n %s obtain i2c fail in atomic!!\n&quot;,SENSOR_NAME_STRING());</p>
<p>goto sensor_task_lock_err;</p>
<p>}</p>
<p>preempt_disable();</p>
<p>}</p>
<p>atomic_add(1, &amp;sensor-&gt;tasklock_cnt);</p>
<p>} else {</p>
<p>if (atomic_read(&amp;sensor-&gt;tasklock_cnt) &gt; 0) {</p>
<p>atomic_sub(1, &amp;sensor-&gt;tasklock_cnt);</p>
<p>if (atomic_read(&amp;sensor-&gt;tasklock_cnt) == 0)</p>
<p>preempt_enable();</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>sensor_task_lock_err:</p>
<p>return -1; </p>
<p>#else</p>
<p>    return 0;</p>
<p>#endif</p>
<p>}</p>
<p>/* sensor register write */</p>
<p>static int sensor_write(struct i2c_client *client, u8 reg, u8 val)</p>
<p>{</p>
<p>    int err,cnt;</p>
<p>    u8 buf[2];</p>
<p>    struct i2c_msg msg[1];</p>
<p>    buf[0] = reg;</p>
<p>    buf[1] = val;</p>
<p>    msg-&gt;addr = client-&gt;addr;</p>
<p>    msg-&gt;flags = client-&gt;flags;</p>
<p>    msg-&gt;buf = buf;</p>
<p>    msg-&gt;len = sizeof(buf);</p>
<p>    msg-&gt;scl_rate = CONFIG_SENSOR_I2C_SPEED;         /* <a href="mailto:&#100;&#100;&#x6c;&#x40;&#114;&#x6f;&#99;&#x6b;&#45;&#99;&#x68;&#105;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;">&#100;&#100;&#x6c;&#x40;&#114;&#x6f;&#99;&#x6b;&#45;&#99;&#x68;&#105;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;</a> : 100kHz */</p>
<p>    msg-&gt;read_type = 0;               /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don’t want include spi_fpga.h */</p>
<p>    cnt = 3;</p>
<p>    err = -EAGAIN;</p>
<p>    while ((cnt– &gt; 0) &amp;&amp; (err &lt; 0)) {                       /* <a href="mailto:&#100;&#100;&#x6c;&#64;&#x72;&#x6f;&#x63;&#107;&#x2d;&#99;&#x68;&#105;&#112;&#x73;&#x2e;&#x63;&#111;&#109;">&#100;&#100;&#x6c;&#64;&#x72;&#x6f;&#x63;&#107;&#x2d;&#99;&#x68;&#105;&#112;&#x73;&#x2e;&#x63;&#111;&#109;</a> :  Transfer again if transent is failed   */</p>
<p>        err = i2c_transfer(client-&gt;adapter, msg, 1);</p>
<p>        if (err &gt;= 0) {</p>
<p>            return 0;</p>
<p>        } else {</p>
<p>        SENSOR_TR(&quot;\n %s write reg(0x%x, val:0x%x) failed, try to write again!\n&quot;,SENSOR_NAME_STRING(),reg, val);</p>
<p>            udelay(10);</p>
<p>        }</p>
<p>    }</p>
<p>    return err;</p>
<p>}</p>
<p>/* sensor register read */</p>
<p>static int sensor_read(struct i2c_client *client, u8 reg, u8 *val)</p>
<p>{</p>
<p>    int err,cnt;</p>
<p>    u8 buf[1];</p>
<p>    struct i2c_msg msg[2];</p>
<p>    buf[0] = reg ;</p>
<p>    msg[0].addr = client-&gt;addr;</p>
<p>    msg[0].flags = client-&gt;flags;</p>
<p>    msg[0].buf = buf;</p>
<p>    msg[0].len = sizeof(buf);</p>
<p>    msg[0].scl_rate = CONFIG_SENSOR_I2C_SPEED;       /* <a href="mailto:&#100;&#100;&#x6c;&#64;&#114;&#111;&#99;&#x6b;&#x2d;&#99;&#104;&#105;&#x70;&#x73;&#x2e;&#99;&#x6f;&#x6d;">&#100;&#100;&#x6c;&#64;&#114;&#111;&#99;&#x6b;&#x2d;&#99;&#104;&#105;&#x70;&#x73;&#x2e;&#99;&#x6f;&#x6d;</a> : 100kHz */</p>
<p>    msg[0].read_type = 2;   /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don’t want include spi_fpga.h */</p>
<p>    msg[1].addr = client-&gt;addr;</p>
<p>    msg[1].flags = client-&gt;flags|I2C_M_RD;</p>
<p>    msg[1].buf = buf;</p>
<p>    msg[1].len = 1;</p>
<p>    msg[1].scl_rate = CONFIG_SENSOR_I2C_SPEED;                       /* <a href="mailto:&#100;&#100;&#108;&#64;&#x72;&#x6f;&#x63;&#x6b;&#x2d;&#99;&#104;&#105;&#112;&#115;&#x2e;&#99;&#111;&#109;">&#100;&#100;&#108;&#64;&#x72;&#x6f;&#x63;&#x6b;&#x2d;&#99;&#104;&#105;&#112;&#115;&#x2e;&#99;&#111;&#109;</a> : 100kHz */</p>
<p>    msg[1].read_type = 2;                             /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don’t want include spi_fpga.h */</p>
<p>    cnt = 3;</p>
<p>    err = -EAGAIN;</p>
<p>    while ((cnt– &gt; 0) &amp;&amp; (err &lt; 0)) {                       /* <a href="mailto:&#x64;&#x64;&#108;&#x40;&#114;&#x6f;&#99;&#x6b;&#45;&#99;&#104;&#x69;&#112;&#115;&#x2e;&#x63;&#111;&#x6d;">&#x64;&#x64;&#108;&#x40;&#114;&#x6f;&#99;&#x6b;&#45;&#99;&#104;&#x69;&#112;&#115;&#x2e;&#x63;&#111;&#x6d;</a> :  Transfer again if transent is failed   */</p>
<p>        err = i2c_transfer(client-&gt;adapter, msg, 2);</p>
<p>        if (err &gt;= 0) {</p>
<p>            *val = buf[0];</p>
<p>            return 0;</p>
<p>        } else {</p>
<p>        SENSOR_TR(&quot;\n %s read reg(0x%x val:0x%x) failed, try to read again! \n&quot;,SENSOR_NAME_STRING(),reg, *val);</p>
<p>            udelay(10);</p>
<p>        }</p>
<p>    }</p>
<p>    return err;</p>
<p>}</p>
<p>/* write a array of registers  */</p>
<p>static int sensor_write_array(struct i2c_client *client, struct reginfo *regarray)</p>
<p>{</p>
<p>    int err = 0, cnt;</p>
<p>    int i = 0;</p>
<p>#if CONFIG_SENSOR_I2C_RDWRCHK    </p>
<p>char valchk;</p>
<p>#endif</p>
<p>cnt = 0;</p>
<p>if (sensor_task_lock(client, 1) &lt; 0)</p>
<p>goto sensor_write_array_end;</p>
<p>    while (regarray[i].reg != 0)</p>
<p>    {</p>
<p>        err = sensor_write(client, regarray[i].reg, regarray[i].val);</p>
<p>        if (err &lt; 0)</p>
<p>        {</p>
<p>            if (cnt– &gt; 0) {</p>
<p>   SENSOR_TR(&quot;%s..write failed current reg:0x%x, Write array again !\n&quot;, SENSOR_NAME_STRING(),regarray[i].reg);</p>
<p>i = 0;</p>
<p>continue;</p>
<p>            } else {</p>
<p>                SENSOR_TR(&quot;%s..write array failed!!!\n&quot;, SENSOR_NAME_STRING());</p>
<p>                err = -EPERM;</p>
<p>goto sensor_write_array_end;</p>
<p>            }</p>
<p>        } else {</p>
<p>        #if CONFIG_SENSOR_I2C_RDWRCHK</p>
<p>sensor_read(client, regarray[i].reg, &amp;valchk);</p>
<p>if (valchk != regarray[i].val)</p>
<p>SENSOR_TR(&quot;%s Reg:0x%x write(0x%x, 0x%x) fail\n&quot;,SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);</p>
<p>#endif</p>
<p>        }</p>
<p>        i++;</p>
<p>    }</p>
<p>sensor_write_array_end:</p>
<p>sensor_task_lock(client,0);</p>
<p>return err;</p>
<p>}</p>
<p>#if CONFIG_SENSOR_I2C_RDWRCHK</p>
<p>static int sensor_check_array(struct i2c_client *client, struct reginfo *regarray)</p>
<p>{</p>
<p>    int cnt;</p>
<p>    int i = 0;</p>
<p>char valchk;</p>
<p>cnt = 0;</p>
<p>valchk = 0;</p>
<p>    while (regarray[i].reg != 0)</p>
<p>    {</p>
<p>sensor_read(client, regarray[i].reg, &amp;valchk);</p>
<p>if (valchk != regarray[i].val)</p>
<p>SENSOR_TR(&quot;%s Reg:0x%x read(0x%x, 0x%x) error\n&quot;,SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);</p>
<p>        i++;</p>
<p>    }</p>
<p>    return 0;</p>
<p>}</p>
<p>#endif</p>
<p>static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)</p>
<p>{</p>
<p>struct soc_camera_link *icl = to_soc_camera_link(icd);</p>
<p>int ret = 0;</p>
<p>    SENSOR_DG(&quot;%s %s  cmd(%d) on(%d)\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,cmd,on);</p>
<p>switch (cmd)</p>
<p>{</p>
<p>case Sensor_PowerDown:</p>
<p>{</p>
<p>    // honghaishen_test</p>
<p>if (icl-&gt;powerdown) {</p>
<p>ret = icl-&gt;powerdown(icd-&gt;pdev, on);</p>
<p>if (ret == RK29_CAM_IO_SUCCESS) {</p>
<p>if (on == 0) {</p>
<p>mdelay(2);</p>
<p>if (icl-&gt;reset)</p>
<p>icl-&gt;reset(icd-&gt;pdev);</p>
<p>}</p>
<p>} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {</p>
<p>ret = -ENODEV;</p>
<p>goto sensor_power_end;</p>
<p>}</p>
<p>}</p>
<p>break;</p>
<p>}</p>
<p>case Sensor_Flash:</p>
<p>{</p>
<p>struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>if (sensor-&gt;sensor_io_request &amp;&amp; sensor-&gt;sensor_io_request-&gt;sensor_ioctrl) {</p>
<p>sensor-&gt;sensor_io_request-&gt;sensor_ioctrl(icd-&gt;pdev,Cam_Flash, on);</p>
<p>                if(on){</p>
<p>                    //flash off after 2 secs</p>
<p>            hrtimer_cancel(&amp;(flash_off_timer.timer));</p>
<p>            hrtimer_start(&amp;(flash_off_timer.timer),ktime_set(0, 800<em>1000</em>1000),HRTIMER_MODE_REL);</p>
<p>                    }</p>
<p>}</p>
<p>            break;</p>
<p>}</p>
<p>default:</p>
<p>{</p>
<p>SENSOR_TR(&quot;%s %s cmd(0x%x) is unknown!&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,cmd);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>sensor_power_end:</p>
<p>return ret;</p>
<p>}</p>
<p>static enum hrtimer_restart flash_off_func(struct hrtimer *timer){</p>
<p>struct flash_timer *fps_timer = container_of(timer, struct flash_timer, timer);</p>
<p>    sensor_ioctrl(fps_timer-&gt;icd,Sensor_Flash,0);</p>
<p>SENSOR_DG(&quot;%s %s !!!!!!&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>);</p>
<p>    return 0;</p>
<p>}</p>
<p>static int sensor_init(struct v4l2_subdev *sd, u32 val)</p>
<p>{</p>
<p>    struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>const struct v4l2_queryctrl *qctrl;</p>
<p>    const struct sensor_datafmt *fmt;</p>
<p>    char value;</p>
<p>    int ret,pid = 0;</p>
<p>    SENSOR_DG(&quot;\n%s..%s.. \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>);</p>
<p>if (sensor_ioctrl(icd, Sensor_PowerDown, 0) &lt; 0) {</p>
<p>ret = -ENODEV;</p>
<p>goto sensor_INIT_ERR;</p>
<p>}</p>
<p>    /* soft reset */</p>
<p>if (sensor_task_lock(client,1)&lt;0)</p>
<p>goto sensor_INIT_ERR;</p>
<p>/* check if it is an sensor sensor */</p>
<p>    ret = sensor_read(client, 0xf0, &amp;value);</p>
<p>    if (ret != 0) {</p>
<p>        SENSOR_TR(&quot;read chip id high byte failed\n&quot;);</p>
<p>        ret = -ENODEV;</p>
<p>        goto sensor_INIT_ERR;</p>
<p>    }</p>
<p>    pid |= (value &lt;&lt; 8);</p>
<p>    ret = sensor_read(client, 0xf1, &amp;value);</p>
<p>    if (ret != 0) {</p>
<p>        SENSOR_TR(&quot;read chip id low byte failed\n&quot;);</p>
<p>        ret = -ENODEV;</p>
<p>        goto sensor_INIT_ERR;</p>
<p>    }</p>
<p>    pid |= (value &amp; 0xff);</p>
<p>    SENSOR_DG(&quot;\n %s  pid = 0x%x\n&quot;, SENSOR_NAME_STRING(), pid);</p>
<p>    if (pid == SENSOR_ID) {</p>
<p>        sensor-&gt;model = SENSOR_V4L2_IDENT;</p>
<p>    } else {</p>
<p>        SENSOR_TR(&quot;error: %s mismatched   pid = 0x%x\n&quot;, SENSOR_NAME_STRING(), pid);</p>
<p>        ret = -ENODEV;</p>
<p>        goto sensor_INIT_ERR;</p>
<p>    }</p>
<p>    ret = sensor_write_array(client, sensor_init_data);</p>
<p>    mdelay(300);</p>
<p>    if (ret != 0)</p>
<p>    {</p>
<p>        SENSOR_TR(&quot;error: %s initial failed\n&quot;,SENSOR_NAME_STRING());</p>
<p>        goto sensor_INIT_ERR;</p>
<p>    }</p>
<p>sensor_task_lock(client,0);</p>
<p>    sensor-&gt;info_priv.winseqe_cur_addr  = (int)SENSOR_INIT_WINSEQADR;</p>
<p>    fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));</p>
<p>    if (!fmt) {</p>
<p>        SENSOR_TR(&quot;error: %s initial array colour fmts is not support!!&quot;,SENSOR_NAME_STRING());</p>
<p>        ret = -EINVAL;</p>
<p>        goto sensor_INIT_ERR;</p>
<p>    }</p>
<p>sensor-&gt;info_priv.fmt = *fmt;</p>
<p>    /* sensor sensor information for initialization  */</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_DO_WHITE_BALANCE);</p>
<p>if (qctrl)</p>
<p>    sensor-&gt;info_priv.whiteBalance = qctrl-&gt;default_value;</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_BRIGHTNESS);</p>
<p>if (qctrl)</p>
<p>    sensor-&gt;info_priv.brightness = qctrl-&gt;default_value;</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_EFFECT);</p>
<p>if (qctrl)</p>
<p>    sensor-&gt;info_priv.effect = qctrl-&gt;default_value;</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_EXPOSURE);</p>
<p>if (qctrl)</p>
<p>        sensor-&gt;info_priv.exposure = qctrl-&gt;default_value;</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_SATURATION);</p>
<p>if (qctrl)</p>
<p>        sensor-&gt;info_priv.saturation = qctrl-&gt;default_value;</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_CONTRAST);</p>
<p>if (qctrl)</p>
<p>        sensor-&gt;info_priv.contrast = qctrl-&gt;default_value;</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_HFLIP);</p>
<p>if (qctrl)</p>
<p>        sensor-&gt;info_priv.mirror = qctrl-&gt;default_value;</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_VFLIP);</p>
<p>if (qctrl)</p>
<p>        sensor-&gt;info_priv.flip = qctrl-&gt;default_value;</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_SCENE);</p>
<p>if (qctrl)</p>
<p>        sensor-&gt;info_priv.scene = qctrl-&gt;default_value;</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);</p>
<p>if (qctrl)</p>
<p>        sensor-&gt;info_priv.digitalzoom = qctrl-&gt;default_value;</p>
<p>    /* <a href="mailto:&#x64;&#100;&#108;&#64;&#x72;&#x6f;&#x63;&#x6b;&#45;&#99;&#104;&#x69;&#x70;&#x73;&#46;&#99;&#111;&#109;">&#x64;&#100;&#108;&#64;&#x72;&#x6f;&#x63;&#x6b;&#45;&#99;&#104;&#x69;&#x70;&#x73;&#46;&#99;&#111;&#109;</a> : if sensor support auto focus and flash, programer must run focus and flash code  */</p>
<p>#if CONFIG_SENSOR_Focus</p>
<p>    sensor_set_focus();</p>
<p>    qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_FOCUS_ABSOLUTE);</p>
<p>if (qctrl)</p>
<p>        sensor-&gt;info_priv.focus = qctrl-&gt;default_value;</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Flash</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_FLASH);</p>
<p>if (qctrl)</p>
<p>        sensor-&gt;info_priv.flash = qctrl-&gt;default_value;</p>
<p>    flash_off_timer.icd = icd;</p>
<p>flash_off_timer.timer.function = flash_off_func;</p>
<p>    #endif</p>
<p>    SENSOR_DG(&quot;\n%s..%s.. icd-&gt;width = %d.. icd-&gt;height %d\n&quot;,SENSOR_NAME_STRING(),((val == 0)?<strong>FUNCTION</strong>:&quot;sensor_reinit&quot;),icd-&gt;user_width,icd-&gt;user_height);</p>
<p>    sensor-&gt;info_priv.funmodule_state |= SENSOR_INIT_IS_OK;</p>
<p>    return 0;</p>
<p>sensor_INIT_ERR:</p>
<p>    sensor-&gt;info_priv.funmodule_state &amp;= ~SENSOR_INIT_IS_OK;</p>
<p>sensor_task_lock(client,0);</p>
<p>sensor_deactivate(client);</p>
<p>    return ret;</p>
<p>}</p>
<p>static int sensor_deactivate(struct i2c_client *client)</p>
<p>{</p>
<p>struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>SENSOR_DG(&quot;\n%s..%s.. Enter\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>);</p>
<p>/* <a href="mailto:&#100;&#x64;&#x6c;&#x40;&#x72;&#x6f;&#x63;&#107;&#x2d;&#99;&#104;&#105;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;">&#100;&#x64;&#x6c;&#x40;&#x72;&#x6f;&#x63;&#107;&#x2d;&#99;&#104;&#105;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;</a> : all sensor output pin must change to input for other sensor */</p>
<p>    if (sensor-&gt;info_priv.funmodule_state &amp; SENSOR_INIT_IS_OK) {</p>
<p>    }</p>
<p>sensor_ioctrl(icd, Sensor_PowerDown, 1);</p>
<p>    msleep(100); </p>
<p>/* <a href="mailto:&#100;&#100;&#108;&#64;&#x72;&#111;&#x63;&#x6b;&#x2d;&#99;&#104;&#105;&#x70;&#115;&#x2e;&#x63;&#111;&#109;">&#100;&#100;&#108;&#64;&#x72;&#111;&#x63;&#x6b;&#x2d;&#99;&#104;&#105;&#x70;&#115;&#x2e;&#x63;&#111;&#109;</a> : sensor config init width , because next open sensor quickly(soc_camera_open -&gt; Try to configure with default parameters) */</p>
<p>icd-&gt;user_width = SENSOR_INIT_WIDTH;</p>
<p>    icd-&gt;user_height = SENSOR_INIT_HEIGHT;</p>
<p>    sensor-&gt;info_priv.funmodule_state &amp;= ~SENSOR_INIT_IS_OK;</p>
<p>return 0;</p>
<p>}</p>
<p>static  struct reginfo sensor_power_down_sequence[]=</p>
<p>{</p>
<p>    {0x00,0x00}</p>
<p>};</p>
<p>static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)</p>
<p>{</p>
<p>    int ret;</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if (pm_msg.event == PM_EVENT_SUSPEND) {</p>
<p>        SENSOR_DG(&quot;\n %s Enter Suspend.. \n&quot;, SENSOR_NAME_STRING());</p>
<p>        ret = sensor_write_array(client, sensor_power_down_sequence) ;</p>
<p>        if (ret != 0) {</p>
<p>            SENSOR_TR(&quot;\n %s..%s WriteReg Fail.. \n&quot;, SENSOR_NAME_STRING(),<strong>FUNCTION</strong>);</p>
<p>            return ret;</p>
<p>        } else {</p>
<p>            ret = sensor_ioctrl(icd, Sensor_PowerDown, 1);</p>
<p>            if (ret &lt; 0) {</p>
<p>   SENSOR_TR(&quot;\n %s suspend fail for turn on power!\n&quot;, SENSOR_NAME_STRING());</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>        }</p>
<p>    } else {</p>
<p>        SENSOR_TR(&quot;\n %s cann’t suppout Suspend..\n&quot;,SENSOR_NAME_STRING());</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>    return 0;</p>
<p>}</p>
<p>static int sensor_resume(struct soc_camera_device *icd)</p>
<p>{</p>
<p>int ret;</p>
<p>    ret = sensor_ioctrl(icd, Sensor_PowerDown, 0);</p>
<p>    if (ret &lt; 0) {</p>
<p>SENSOR_TR(&quot;\n %s resume fail for turn on power!\n&quot;, SENSOR_NAME_STRING());</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>SENSOR_DG(&quot;\n %s Enter Resume.. \n&quot;, SENSOR_NAME_STRING());</p>
<p>    return 0;</p>
<p>}</p>
<p>static int sensor_set_bus_param(struct soc_camera_device *icd,</p>
<p>                                unsigned long flags)</p>
<p>{</p>
<p>    return 0;</p>
<p>}</p>
<p>static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)</p>
<p>{</p>
<p>    struct soc_camera_link *icl = to_soc_camera_link(icd);</p>
<p>    unsigned long flags = SENSOR_BUS_PARAM;</p>
<p>    return soc_camera_apply_sensor_flags(icl, flags);</p>
<p>}</p>
<p>static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)</p>
<p>{</p>
<p>    struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>    mf-&gt;width = icd-&gt;user_width;</p>
<p>mf-&gt;height = icd-&gt;user_height;</p>
<p>mf-&gt;code = sensor-&gt;info_priv.fmt.code;</p>
<p>mf-&gt;colorspace = sensor-&gt;info_priv.fmt.colorspace;</p>
<p>mf-&gt;field = V4L2_FIELD_NONE;</p>
<p>    return 0;</p>
<p>}</p>
<p>static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)</p>
<p>{</p>
<p>    bool ret = false;</p>
<p>if ((mf-&gt;width == 1024) &amp;&amp; (mf-&gt;height == 768)) {</p>
<p>ret = true;</p>
<p>} else if ((mf-&gt;width == 1280) &amp;&amp; (mf-&gt;height == 1024)) {</p>
<p>ret = true;</p>
<p>} else if ((mf-&gt;width == 1600) &amp;&amp; (mf-&gt;height == 1200)) {</p>
<p>ret = true;</p>
<p>} else if ((mf-&gt;width == 2048) &amp;&amp; (mf-&gt;height == 1536)) {</p>
<p>ret = true;</p>
<p>} else if ((mf-&gt;width == 2592) &amp;&amp; (mf-&gt;height == 1944)) {</p>
<p>ret = true;</p>
<p>}</p>
<p>if (ret == true)</p>
<p>SENSOR_DG(&quot;%s %dx%d is capture format\n&quot;, <strong>FUNCTION</strong>, mf-&gt;width, mf-&gt;height);</p>
<p>return ret;</p>
<p>}</p>
<p>static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)</p>
<p>{</p>
<p>    bool ret = false;</p>
<p>if ((mf-&gt;width == 1280) &amp;&amp; (mf-&gt;height == 720)) {</p>
<p>ret = true;</p>
<p>} else if ((mf-&gt;width == 1920) &amp;&amp; (mf-&gt;height == 1080)) {</p>
<p>ret = true;</p>
<p>}</p>
<p>if (ret == true)</p>
<p>SENSOR_DG(&quot;%s %dx%d is video format\n&quot;, <strong>FUNCTION</strong>, mf-&gt;width, mf-&gt;height);</p>
<p>return ret;</p>
<p>}</p>
<p>static  unsigned   int shutter_h,shutter_l;</p>
<p>static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)</p>
<p>{</p>
<p>    int ret1;</p>
<p>    struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    const struct sensor_datafmt *fmt;</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>const struct v4l2_queryctrl *qctrl;</p>
<p>struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    struct reginfo *winseqe_set_addr=NULL;</p>
<p>    int ret=0, set_w,set_h;</p>
<p>#if  1</p>
<p>char value;</p>
<p>unsigned   int pid=0,shutter,temp_reg;</p>
<p>#endif</p>
<p>fmt = sensor_find_datafmt(mf-&gt;code, sensor_colour_fmts,</p>
<p>  ARRAY_SIZE(sensor_colour_fmts));</p>
<p>if (!fmt) {</p>
<p>        ret = -EINVAL;</p>
<p>        goto sensor_s_fmt_end;</p>
<p>    }</p>
<p>if (sensor-&gt;info_priv.fmt.code != mf-&gt;code) {</p>
<p>switch (mf-&gt;code)</p>
<p>{</p>
<p>case V4L2_MBUS_FMT_YUYV8_2X8:</p>
<p>{</p>
<p>winseqe_set_addr = sensor_ClrFmt_YUYV;</p>
<p>break;</p>
<p>}</p>
<p>case V4L2_MBUS_FMT_UYVY8_2X8:</p>
<p>{</p>
<p>winseqe_set_addr = sensor_ClrFmt_UYVY;</p>
<p>break;</p>
<p>}</p>
<p>default:</p>
<p>break;</p>
<p>}</p>
<p>if (winseqe_set_addr != NULL) {</p>
<p>            sensor_write_array(client, winseqe_set_addr);</p>
<p>sensor-&gt;info_priv.fmt.code = mf-&gt;code;</p>
<p>            sensor-&gt;info_priv.fmt.colorspace= mf-&gt;colorspace;            </p>
<p>SENSOR_DG(&quot;%s v4l2_mbus_code:%d set success!\n&quot;, SENSOR_NAME_STRING(),mf-&gt;code);</p>
<p>} else {</p>
<p>SENSOR_TR(&quot;%s v4l2_mbus_code:%d is invalidate!\n&quot;, SENSOR_NAME_STRING(),mf-&gt;code);</p>
<p>}</p>
<p>}</p>
<p>    set_w = mf-&gt;width;</p>
<p>    set_h = mf-&gt;height;</p>
<p>if (((set_w &lt;= 176) &amp;&amp; (set_h &lt;= 144)) &amp;&amp; sensor_qcif[0].reg)</p>
<p>{</p>
<p>winseqe_set_addr = sensor_qcif;</p>
<p>        set_w = 176;</p>
<p>        set_h = 144;</p>
<p>}</p>
<p>else if (((set_w &lt;= 320) &amp;&amp; (set_h &lt;= 240)) &amp;&amp; sensor_qvga[0].reg)</p>
<p>    {</p>
<p>        winseqe_set_addr = sensor_qvga;</p>
<p>        set_w = 320;</p>
<p>        set_h = 240;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 352) &amp;&amp; (set_h&lt;= 288)) &amp;&amp; sensor_cif[0].reg)</p>
<p>    {</p>
<p>        winseqe_set_addr = sensor_cif;</p>
<p>        set_w = 352;</p>
<p>        set_h = 288;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 640) &amp;&amp; (set_h &lt;= 480)) &amp;&amp; sensor_vga[0].reg)</p>
<p>    {</p>
<p>        winseqe_set_addr = sensor_vga;</p>
<p>        set_w = 640;</p>
<p>        set_h = 480;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 800) &amp;&amp; (set_h &lt;= 600)) &amp;&amp; sensor_svga[0].reg)</p>
<p>    {</p>
<p>        winseqe_set_addr = sensor_svga;</p>
<p>        set_w = 800;</p>
<p>        set_h = 600;</p>
<p>    }</p>
<p>else if (((set_w &lt;= 1280) &amp;&amp; (set_h &lt;= 720)) &amp;&amp; sensor_720p[0].reg)</p>
<p>    {</p>
<p>        winseqe_set_addr = sensor_720p;</p>
<p>        set_w = 1280;</p>
<p>        set_h = 720;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 1280) &amp;&amp; (set_h &lt;= 1024)) &amp;&amp; sensor_sxga[0].reg)</p>
<p>    {</p>
<p>        winseqe_set_addr = sensor_sxga;</p>
<p>        set_w = 1280;</p>
<p>        set_h = 1024;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 1600) &amp;&amp; (set_h &lt;= 1200)) &amp;&amp; sensor_uxga[0].reg)</p>
<p>    {</p>
<p>        winseqe_set_addr = sensor_uxga;</p>
<p>        set_w = 1600;</p>
<p>        set_h = 1200;</p>
<p>    }</p>
<p>    else</p>
<p>    {</p>
<p>        winseqe_set_addr = SENSOR_INIT_WINSEQADR;               /* <a href="mailto:&#x64;&#100;&#x6c;&#64;&#x72;&#111;&#x63;&#x6b;&#x2d;&#x63;&#x68;&#105;&#112;&#x73;&#x2e;&#x63;&#111;&#109;">&#x64;&#100;&#x6c;&#64;&#x72;&#111;&#x63;&#x6b;&#x2d;&#x63;&#x68;&#105;&#112;&#x73;&#x2e;&#x63;&#111;&#109;</a> : Sensor output smallest size if  isn’t support app  */</p>
<p>        set_w = SENSOR_INIT_WIDTH;</p>
<p>        set_h = SENSOR_INIT_HEIGHT;</p>
<p>SENSOR_TR(&quot;\n %s..%s Format is Invalidate. pix-&gt;width = %d.. pix-&gt;height = %d\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,mf-&gt;width,mf-&gt;height);</p>
<p>    }</p>
<p>    if ((int)winseqe_set_addr  != sensor-&gt;info_priv.winseqe_cur_addr) {</p>
<p>        #if CONFIG_SENSOR_Flash</p>
<p>        if (sensor_fmt_capturechk(sd,mf) == true) {      /* <a href="mailto:&#100;&#100;&#x6c;&#x40;&#x72;&#x6f;&#99;&#x6b;&#x2d;&#99;&#104;&#x69;&#x70;&#x73;&#x2e;&#99;&#x6f;&#x6d;">&#100;&#100;&#x6c;&#x40;&#x72;&#x6f;&#99;&#x6b;&#x2d;&#99;&#104;&#x69;&#x70;&#x73;&#x2e;&#99;&#x6f;&#x6d;</a> : Capture */</p>
<p>            if ((sensor-&gt;info_priv.flash == 1) || (sensor-&gt;info_priv.flash == 2)) {</p>
<p>                sensor_ioctrl(icd, Sensor_Flash, Flash_On);</p>
<p>                SENSOR_DG(&quot;%s flash on in capture!\n&quot;, SENSOR_NAME_STRING());</p>
<p>            }           </p>
<p>        } else {                                        /* <a href="mailto:&#100;&#100;&#x6c;&#64;&#114;&#111;&#99;&#107;&#x2d;&#x63;&#104;&#105;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;">&#100;&#100;&#x6c;&#64;&#114;&#111;&#99;&#107;&#x2d;&#x63;&#104;&#105;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;</a> : Video */</p>
<p>            if ((sensor-&gt;info_priv.flash == 1) || (sensor-&gt;info_priv.flash == 2)) {</p>
<p>                sensor_ioctrl(icd, Sensor_Flash, Flash_Off);</p>
<p>                SENSOR_DG(&quot;%s flash off in preivew!\n&quot;, SENSOR_NAME_STRING());</p>
<p>            }</p>
<p>        }</p>
<p>        #endif</p>
<p>if ((winseqe_set_addr == sensor_svga)||(winseqe_set_addr == sensor_vga) )</p>
<p>{</p>
<p>sensor_write(client, 0xb6, 0x00);  // AEC ON</p>
<p>sensor_write(client, 0x03, shutter_h);</p>
<p>sensor_write(client, 0x04, shutter_l);</p>
<p>       msleep(50);</p>
<p>printk(&quot;set preview for rewrite 0x03&quot;);</p>
<p>} </p>
<p>        ret |= sensor_write_array(client, winseqe_set_addr);</p>
<p>#if 1</p>
<p>if (winseqe_set_addr == sensor_uxga) { </p>
<p>        sensor_write(client, 0xfe, 0x00);</p>
<p>sensor_write(client, 0xb6, 0x02);  // AEC OFF</p>
<p>sensor_read(client, 0x03, &amp;value);</p>
<p>shutter_h=value;</p>
<p>pid |= (value &lt;&lt; 8);</p>
<p>      sensor_read(client, 0x04, &amp;value);</p>
<p>shutter_l=value;</p>
<p>pid |= (value &amp; 0xff);</p>
<p>shutter=pid;</p>
<p>temp_reg= shutter ; // 2</p>
<p>if(temp_reg &lt; 1) temp_reg = 1;</p>
<p>sensor_write(client, 0x03, ((temp_reg&gt;&gt;8)&amp;0xff));</p>
<p>      sensor_write(client, 0x04, (temp_reg&amp;0xff));</p>
<p>        }</p>
<p>#endif   </p>
<p>        if (ret != 0) {</p>
<p>            SENSOR_TR(&quot;%s set format capability failed\n&quot;, SENSOR_NAME_STRING());</p>
<p>            #if CONFIG_SENSOR_Flash</p>
<p>            if (sensor_fmt_capturechk(sd,mf) == true) {</p>
<p>                if ((sensor-&gt;info_priv.flash == 1) || (sensor-&gt;info_priv.flash == 2)) {</p>
<p>                    sensor_ioctrl(icd, Sensor_Flash, Flash_Off);</p>
<p>                    SENSOR_TR(&quot;%s Capture format set fail, flash off !\n&quot;, SENSOR_NAME_STRING());</p>
<p>                }</p>
<p>            }</p>
<p>            #endif</p>
<p>            goto sensor_s_fmt_end;</p>
<p>        }</p>
<p>        sensor-&gt;info_priv.winseqe_cur_addr  = (int)winseqe_set_addr;</p>
<p>if (sensor_fmt_capturechk(sd,mf) == true) {    /* <a href="mailto:&#x64;&#x64;&#x6c;&#x40;&#x72;&#x6f;&#x63;&#107;&#x2d;&#99;&#104;&#105;&#112;&#x73;&#x2e;&#x63;&#111;&#109;">&#x64;&#x64;&#x6c;&#x40;&#x72;&#x6f;&#x63;&#107;&#x2d;&#99;&#104;&#105;&#112;&#x73;&#x2e;&#x63;&#111;&#109;</a> : Capture */</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_EFFECT);</p>
<p>sensor_set_effect(icd, qctrl,sensor-&gt;info_priv.effect);</p>
<p>if (sensor-&gt;info_priv.whiteBalance != 0) {</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_DO_WHITE_BALANCE);</p>
<p>sensor_set_whiteBalance(icd, qctrl,sensor-&gt;info_priv.whiteBalance);</p>
<p>}</p>
<p>sensor-&gt;info_priv.snap2preview = true;</p>
<p>} else if (sensor_fmt_videochk(sd,mf) == true) { /* <a href="mailto:&#100;&#x64;&#x6c;&#64;&#x72;&#x6f;&#99;&#107;&#x2d;&#99;&#104;&#105;&#x70;&#115;&#46;&#99;&#111;&#x6d;">&#100;&#x64;&#x6c;&#64;&#x72;&#x6f;&#99;&#107;&#x2d;&#99;&#104;&#105;&#x70;&#115;&#46;&#99;&#111;&#x6d;</a> : Video */</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_EFFECT);</p>
<p>sensor_set_effect(icd, qctrl,sensor-&gt;info_priv.effect);</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_DO_WHITE_BALANCE);</p>
<p>sensor_set_whiteBalance(icd, qctrl,sensor-&gt;info_priv.whiteBalance);</p>
<p>sensor-&gt;info_priv.video2preview = true;</p>
<p>} else if ((sensor-&gt;info_priv.snap2preview == true) || (sensor-&gt;info_priv.video2preview == true)) {</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_EFFECT);</p>
<p>sensor_set_effect(icd, qctrl,sensor-&gt;info_priv.effect);</p>
<p>qctrl = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_DO_WHITE_BALANCE);</p>
<p>sensor_set_whiteBalance(icd, qctrl,sensor-&gt;info_priv.whiteBalance);</p>
<p>            msleep(600);</p>
<p>sensor-&gt;info_priv.video2preview = false;</p>
<p>sensor-&gt;info_priv.snap2preview = false;</p>
<p>}</p>
<p>        SENSOR_DG(&quot;\n%s..%s.. icd-&gt;width = %d.. icd-&gt;height %d\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,set_w,set_h);</p>
<p>    }</p>
<p>    else</p>
<p>    {</p>
<p>        SENSOR_DG(&quot;\n %s .. Current Format is validate. icd-&gt;width = %d.. icd-&gt;height %d\n&quot;,SENSOR_NAME_STRING(),set_w,set_h);</p>
<p>    }</p>
<p>mf-&gt;width = set_w;</p>
<p>    mf-&gt;height = set_h;</p>
<p>msleep(100);</p>
<p>sensor_s_fmt_end:</p>
<p>    return ret;</p>
<p>}</p>
<p>static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)</p>
<p>{</p>
<p>    struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>    const struct sensor_datafmt *fmt;</p>
<p>    int ret = 0,set_w,set_h;</p>
<p>fmt = sensor_find_datafmt(mf-&gt;code, sensor_colour_fmts,</p>
<p>  ARRAY_SIZE(sensor_colour_fmts));</p>
<p>if (fmt == NULL) {</p>
<p>fmt = &amp;sensor-&gt;info_priv.fmt;</p>
<p>        mf-&gt;code = fmt-&gt;code;</p>
<p>} </p>
<p>    if (mf-&gt;height &gt; SENSOR_MAX_HEIGHT)</p>
<p>        mf-&gt;height = SENSOR_MAX_HEIGHT;</p>
<p>    else if (mf-&gt;height &lt; SENSOR_MIN_HEIGHT)</p>
<p>        mf-&gt;height = SENSOR_MIN_HEIGHT;</p>
<p>    if (mf-&gt;width &gt; SENSOR_MAX_WIDTH)</p>
<p>        mf-&gt;width = SENSOR_MAX_WIDTH;</p>
<p>    else if (mf-&gt;width &lt; SENSOR_MIN_WIDTH)</p>
<p>        mf-&gt;width = SENSOR_MIN_WIDTH;</p>
<p>    set_w = mf-&gt;width;</p>
<p>    set_h = mf-&gt;height;</p>
<p>if (((set_w &lt;= 176) &amp;&amp; (set_h &lt;= 144)) &amp;&amp; sensor_qcif[0].reg)</p>
<p>{</p>
<p>        set_w = 176;</p>
<p>        set_h = 144;</p>
<p>}</p>
<p>else if (((set_w &lt;= 320) &amp;&amp; (set_h &lt;= 240)) &amp;&amp; sensor_qvga[0].reg)</p>
<p>    {</p>
<p>        set_w = 320;</p>
<p>        set_h = 240;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 352) &amp;&amp; (set_h&lt;= 288)) &amp;&amp; sensor_cif[0].reg)</p>
<p>    {</p>
<p>        set_w = 352;</p>
<p>        set_h = 288;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 640) &amp;&amp; (set_h &lt;= 480)) &amp;&amp; sensor_vga[0].reg)</p>
<p>    {</p>
<p>        set_w = 640;</p>
<p>        set_h = 480;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 800) &amp;&amp; (set_h &lt;= 600)) &amp;&amp; sensor_svga[0].reg)</p>
<p>    {</p>
<p>        set_w = 800;</p>
<p>        set_h = 600;</p>
<p>    }</p>
<p>else if (((set_w &lt;= 1280) &amp;&amp; (set_h &lt;= 720)) &amp;&amp; sensor_720p[0].reg)</p>
<p>    {</p>
<p>        set_w = 1280;</p>
<p>        set_h = 720;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 1280) &amp;&amp; (set_h &lt;= 1024)) &amp;&amp; sensor_sxga[0].reg)</p>
<p>    {</p>
<p>        set_w = 1280;</p>
<p>        set_h = 1024;</p>
<p>    }</p>
<p>    else if (((set_w &lt;= 1600) &amp;&amp; (set_h &lt;= 1200)) &amp;&amp; sensor_uxga[0].reg)</p>
<p>    {</p>
<p>        set_w = 1600;</p>
<p>        set_h = 1200;</p>
<p>    }</p>
<p>    else</p>
<p>    {</p>
<p>        set_w = SENSOR_INIT_WIDTH;</p>
<p>        set_h = SENSOR_INIT_HEIGHT;</p>
<p>    }</p>
<p>mf-&gt;width = set_w;</p>
<p>    mf-&gt;height = set_h;</p>
<p>    mf-&gt;colorspace = fmt-&gt;colorspace;</p>
<p>    return ret;</p>
<p>}</p>
<p> static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)</p>
<p>{</p>
<p>    struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    if (id-&gt;match.type != V4L2_CHIP_MATCH_I2C_ADDR)</p>
<p>        return -EINVAL;</p>
<p>    if (id-&gt;match.addr != client-&gt;addr)</p>
<p>        return -ENODEV;</p>
<p>    id-&gt;ident = SENSOR_V4L2_IDENT;      /* <a href="mailto:&#x64;&#100;&#x6c;&#64;&#x72;&#111;&#x63;&#107;&#x2d;&#x63;&#x68;&#105;&#112;&#x73;&#x2e;&#x63;&#x6f;&#x6d;">&#x64;&#100;&#x6c;&#64;&#x72;&#111;&#x63;&#107;&#x2d;&#x63;&#x68;&#105;&#112;&#x73;&#x2e;&#x63;&#x6f;&#x6d;</a> :  Return gc2035  identifier */</p>
<p>    id-&gt;revision = 0;</p>
<p>    return 0;</p>
<p>}</p>
<p>#if CONFIG_SENSOR_Brightness</p>
<p>static int sensor_set_brightness(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum))</p>
<p>    {</p>
<p>        if (sensor_BrightnessSeqe[value - qctrl-&gt;minimum] != NULL)</p>
<p>        {</p>
<p>            if (sensor_write_array(client, sensor_BrightnessSeqe[value - qctrl-&gt;minimum]) != 0)</p>
<p>            {</p>
<p>                SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>            SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Effect</p>
<p>static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum))</p>
<p>    {</p>
<p>        if (sensor_EffectSeqe[value - qctrl-&gt;minimum] != NULL)</p>
<p>        {</p>
<p>            if (sensor_write_array(client, sensor_EffectSeqe[value - qctrl-&gt;minimum]) != 0)</p>
<p>            {</p>
<p>                SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>            SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Exposure</p>
<p>static int sensor_set_exposure(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum))</p>
<p>    {</p>
<p>        if (sensor_ExposureSeqe[value - qctrl-&gt;minimum] != NULL)</p>
<p>        {</p>
<p>            if (sensor_write_array(client, sensor_ExposureSeqe[value - qctrl-&gt;minimum]) != 0)</p>
<p>            {</p>
<p>                SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>            SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Saturation</p>
<p>static int sensor_set_saturation(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum))</p>
<p>    {</p>
<p>        if (sensor_SaturationSeqe[value - qctrl-&gt;minimum] != NULL)</p>
<p>        {</p>
<p>            if (sensor_write_array(client, sensor_SaturationSeqe[value - qctrl-&gt;minimum]) != 0)</p>
<p>            {</p>
<p>                SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>            SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>    SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Contrast</p>
<p>static int sensor_set_contrast(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum))</p>
<p>    {</p>
<p>        if (sensor_ContrastSeqe[value - qctrl-&gt;minimum] != NULL)</p>
<p>        {</p>
<p>            if (sensor_write_array(client, sensor_ContrastSeqe[value - qctrl-&gt;minimum]) != 0)</p>
<p>            {</p>
<p>                SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>            SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>    SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Mirror</p>
<p>static int sensor_set_mirror(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum))</p>
<p>    {</p>
<p>        if (sensor_MirrorSeqe[value - qctrl-&gt;minimum] != NULL)</p>
<p>        {</p>
<p>            if (sensor_write_array(client, sensor_MirrorSeqe[value - qctrl-&gt;minimum]) != 0)</p>
<p>            {</p>
<p>                SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>            SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>    SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Flip</p>
<p>static int sensor_set_flip(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum))</p>
<p>    {</p>
<p>        if (sensor_FlipSeqe[value - qctrl-&gt;minimum] != NULL)</p>
<p>        {</p>
<p>            if (sensor_write_array(client, sensor_FlipSeqe[value - qctrl-&gt;minimum]) != 0)</p>
<p>            {</p>
<p>                SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>            SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>    SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Scene</p>
<p>static int sensor_set_scene(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum))</p>
<p>    {</p>
<p>        if (sensor_SceneSeqe[value - qctrl-&gt;minimum] != NULL)</p>
<p>        {</p>
<p>            if (sensor_write_array(client, sensor_SceneSeqe[value - qctrl-&gt;minimum]) != 0)</p>
<p>            {</p>
<p>                SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>            SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>    SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_WhiteBalance</p>
<p>static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum))</p>
<p>    {</p>
<p>        if (sensor_WhiteBalanceSeqe[value - qctrl-&gt;minimum] != NULL)</p>
<p>        {</p>
<p>            if (sensor_write_array(client, sensor_WhiteBalanceSeqe[value - qctrl-&gt;minimum]) != 0)</p>
<p>            {</p>
<p>                SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>            SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_DigitalZoom</p>
<p>static int sensor_set_digitalzoom(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int *value)</p>
<p>{</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>const struct v4l2_queryctrl *qctrl_info;</p>
<p>    int digitalzoom_cur, digitalzoom_total;</p>
<p>qctrl_info = soc_camera_find_qctrl(&amp;sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);</p>
<p>if (qctrl_info)</p>
<p>return -EINVAL;</p>
<p>    digitalzoom_cur = sensor-&gt;info_priv.digitalzoom;</p>
<p>    digitalzoom_total = qctrl_info-&gt;maximum;</p>
<p>    if ((value &gt; 0) &amp;&amp; (digitalzoom_cur &gt;= digitalzoom_total))</p>
<p>    {</p>
<p>        SENSOR_TR(&quot;%s digitalzoom is maximum - %x\n&quot;, SENSOR_NAME_STRING(), digitalzoom_cur);</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>    if  ((value &lt; 0) &amp;&amp; (digitalzoom_cur &lt;= qctrl_info-&gt;minimum))</p>
<p>    {</p>
<p>        SENSOR_TR(&quot;%s digitalzoom is minimum - %x\n&quot;, SENSOR_NAME_STRING(), digitalzoom_cur);</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>    if ((value &gt; 0) &amp;&amp; ((digitalzoom_cur + value) &gt; digitalzoom_total))</p>
<p>    {</p>
<p>        value = digitalzoom_total - digitalzoom_cur;</p>
<p>    }</p>
<p>    if ((value &lt; 0) &amp;&amp; ((digitalzoom_cur + value) &lt; 0))</p>
<p>    {</p>
<p>        value = 0 - digitalzoom_cur;</p>
<p>    }</p>
<p>    digitalzoom_cur += value;</p>
<p>    if (sensor_ZoomSeqe[digitalzoom_cur] != NULL)</p>
<p>    {</p>
<p>        if (sensor_write_array(client, sensor_ZoomSeqe[digitalzoom_cur]) != 0)</p>
<p>        {</p>
<p>            SENSOR_TR(&quot;%s..%s WriteReg Fail.. \n&quot;,SENSOR_NAME_STRING(), <strong>FUNCTION</strong>);</p>
<p>            return -EINVAL;</p>
<p>        }</p>
<p>        SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>        return 0;</p>
<p>    }</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Flash</p>
<p>static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)</p>
<p>{    </p>
<p>    if ((value &gt;= qctrl-&gt;minimum) &amp;&amp; (value &lt;= qctrl-&gt;maximum)) {</p>
<p>        if (value == 3) {       /* <a href="mailto:&#100;&#x64;&#108;&#x40;&#x72;&#111;&#99;&#x6b;&#45;&#x63;&#104;&#105;&#x70;&#x73;&#x2e;&#x63;&#111;&#109;">&#100;&#x64;&#108;&#x40;&#x72;&#111;&#99;&#x6b;&#45;&#x63;&#104;&#105;&#x70;&#x73;&#x2e;&#x63;&#111;&#109;</a>: torch */</p>
<p>            sensor_ioctrl(icd, Sensor_Flash, Flash_Torch);   /* Flash On */</p>
<p>        } else {</p>
<p>            sensor_ioctrl(icd, Sensor_Flash, Flash_Off);</p>
<p>        }</p>
<p>        SENSOR_DG(&quot;%s..%s : %x\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>, value);</p>
<p>        return 0;</p>
<p>    }</p>
<p>SENSOR_TR(&quot;\n %s..%s valure = %d is invalidate..    \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,value);</p>
<p>    return -EINVAL;</p>
<p>}</p>
<p>#endif</p>
<p>static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)</p>
<p>{</p>
<p>    struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>    const struct v4l2_queryctrl *qctrl;</p>
<p>    qctrl = soc_camera_find_qctrl(&amp;sensor_ops, ctrl-&gt;id);</p>
<p>    if (!qctrl)</p>
<p>    {</p>
<p>        SENSOR_TR(&quot;\n %s ioctrl id = %d  is invalidate \n&quot;, SENSOR_NAME_STRING(), ctrl-&gt;id);</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>    switch (ctrl-&gt;id)</p>
<p>    {</p>
<p>        case V4L2_CID_BRIGHTNESS:</p>
<p>            {</p>
<p>                ctrl-&gt;value = sensor-&gt;info_priv.brightness;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_SATURATION:</p>
<p>            {</p>
<p>                ctrl-&gt;value = sensor-&gt;info_priv.saturation;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_CONTRAST:</p>
<p>            {</p>
<p>                ctrl-&gt;value = sensor-&gt;info_priv.contrast;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_DO_WHITE_BALANCE:</p>
<p>            {</p>
<p>                ctrl-&gt;value = sensor-&gt;info_priv.whiteBalance;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_EXPOSURE:</p>
<p>            {</p>
<p>                ctrl-&gt;value = sensor-&gt;info_priv.exposure;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_HFLIP:</p>
<p>            {</p>
<p>                ctrl-&gt;value = sensor-&gt;info_priv.mirror;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_VFLIP:</p>
<p>            {</p>
<p>                ctrl-&gt;value = sensor-&gt;info_priv.flip;</p>
<p>                break;</p>
<p>            }</p>
<p>        default :</p>
<p>                break;</p>
<p>    }</p>
<p>    return 0;</p>
<p>}</p>
<p>static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)</p>
<p>{</p>
<p>    struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>    struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    const struct v4l2_queryctrl *qctrl;</p>
<p>    qctrl = soc_camera_find_qctrl(&amp;sensor_ops, ctrl-&gt;id);</p>
<p>    if (!qctrl)</p>
<p>    {</p>
<p>        SENSOR_TR(&quot;\n %s ioctrl id = %d  is invalidate \n&quot;, SENSOR_NAME_STRING(), ctrl-&gt;id);</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>    switch (ctrl-&gt;id)</p>
<p>    {</p>
<p>#if CONFIG_SENSOR_Brightness</p>
<p>        case V4L2_CID_BRIGHTNESS:</p>
<p>            {</p>
<p>                if (ctrl-&gt;value != sensor-&gt;info_priv.brightness)</p>
<p>                {</p>
<p>                    if (sensor_set_brightness(icd, qctrl,ctrl-&gt;value) != 0)</p>
<p>                    {</p>
<p>                        return -EINVAL;</p>
<p>                    }</p>
<p>                    sensor-&gt;info_priv.brightness = ctrl-&gt;value;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Exposure</p>
<p>        case V4L2_CID_EXPOSURE:</p>
<p>            {</p>
<p>                if (ctrl-&gt;value != sensor-&gt;info_priv.exposure)</p>
<p>                {</p>
<p>                    if (sensor_set_exposure(icd, qctrl,ctrl-&gt;value) != 0)</p>
<p>                    {</p>
<p>                        return -EINVAL;</p>
<p>                    }</p>
<p>                    sensor-&gt;info_priv.exposure = ctrl-&gt;value;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Saturation</p>
<p>        case V4L2_CID_SATURATION:</p>
<p>            {</p>
<p>                if (ctrl-&gt;value != sensor-&gt;info_priv.saturation)</p>
<p>                {</p>
<p>                    if (sensor_set_saturation(icd, qctrl,ctrl-&gt;value) != 0)</p>
<p>                    {</p>
<p>                        return -EINVAL;</p>
<p>                    }</p>
<p>                    sensor-&gt;info_priv.saturation = ctrl-&gt;value;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Contrast</p>
<p>        case V4L2_CID_CONTRAST:</p>
<p>            {</p>
<p>                if (ctrl-&gt;value != sensor-&gt;info_priv.contrast)</p>
<p>                {</p>
<p>                    if (sensor_set_contrast(icd, qctrl,ctrl-&gt;value) != 0)</p>
<p>                    {</p>
<p>                        return -EINVAL;</p>
<p>                    }</p>
<p>                    sensor-&gt;info_priv.contrast = ctrl-&gt;value;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_WhiteBalance</p>
<p>        case V4L2_CID_DO_WHITE_BALANCE:</p>
<p>            {</p>
<p>                if (ctrl-&gt;value != sensor-&gt;info_priv.whiteBalance)</p>
<p>                {</p>
<p>                    if (sensor_set_whiteBalance(icd, qctrl,ctrl-&gt;value) != 0)</p>
<p>                    {</p>
<p>                        return -EINVAL;</p>
<p>                    }</p>
<p>                    sensor-&gt;info_priv.whiteBalance = ctrl-&gt;value;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Mirror</p>
<p>        case V4L2_CID_HFLIP:</p>
<p>            {</p>
<p>                if (ctrl-&gt;value != sensor-&gt;info_priv.mirror)</p>
<p>                {</p>
<p>                    if (sensor_set_mirror(icd, qctrl,ctrl-&gt;value) != 0)</p>
<p>                        return -EINVAL;</p>
<p>                    sensor-&gt;info_priv.mirror = ctrl-&gt;value;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Flip</p>
<p>        case V4L2_CID_VFLIP:</p>
<p>            {</p>
<p>                if (ctrl-&gt;value != sensor-&gt;info_priv.flip)</p>
<p>                {</p>
<p>                    if (sensor_set_flip(icd, qctrl,ctrl-&gt;value) != 0)</p>
<p>                        return -EINVAL;</p>
<p>                    sensor-&gt;info_priv.flip = ctrl-&gt;value;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>        default:</p>
<p>            break;</p>
<p>    }</p>
<p>    return 0;</p>
<p>}</p>
<p>static int sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)</p>
<p>{</p>
<p>    const struct v4l2_queryctrl *qctrl;</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>    qctrl = soc_camera_find_qctrl(&amp;sensor_ops, ext_ctrl-&gt;id);</p>
<p>    if (!qctrl)</p>
<p>    {</p>
<p>        SENSOR_TR(&quot;\n %s ioctrl id = %d  is invalidate \n&quot;, SENSOR_NAME_STRING(), ext_ctrl-&gt;id);</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>    switch (ext_ctrl-&gt;id)</p>
<p>    {</p>
<p>        case V4L2_CID_SCENE:</p>
<p>            {</p>
<p>                ext_ctrl-&gt;value = sensor-&gt;info_priv.scene;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_EFFECT:</p>
<p>            {</p>
<p>                ext_ctrl-&gt;value = sensor-&gt;info_priv.effect;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_ZOOM_ABSOLUTE:</p>
<p>            {</p>
<p>                ext_ctrl-&gt;value = sensor-&gt;info_priv.digitalzoom;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_ZOOM_RELATIVE:</p>
<p>            {</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>        case V4L2_CID_FOCUS_ABSOLUTE:</p>
<p>            {</p>
<p>                ext_ctrl-&gt;value = sensor-&gt;info_priv.focus;</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_FOCUS_RELATIVE:</p>
<p>            {</p>
<p>                return -EINVAL;</p>
<p>            }</p>
<p>        case V4L2_CID_FLASH:</p>
<p>            {</p>
<p>                ext_ctrl-&gt;value = sensor-&gt;info_priv.flash;</p>
<p>                break;</p>
<p>            }</p>
<p>        default :</p>
<p>            break;</p>
<p>    }</p>
<p>    return 0;</p>
<p>}</p>
<p>static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)</p>
<p>{</p>
<p>    const struct v4l2_queryctrl *qctrl;</p>
<p>    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>    int val_offset;</p>
<p>    qctrl = soc_camera_find_qctrl(&amp;sensor_ops, ext_ctrl-&gt;id);</p>
<p>    if (!qctrl)</p>
<p>    {</p>
<p>        SENSOR_TR(&quot;\n %s ioctrl id = %d  is invalidate \n&quot;, SENSOR_NAME_STRING(), ext_ctrl-&gt;id);</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>val_offset = 0;</p>
<p>    switch (ext_ctrl-&gt;id)</p>
<p>    {</p>
<p>#if CONFIG_SENSOR_Scene</p>
<p>        case V4L2_CID_SCENE:</p>
<p>            {</p>
<p>                if (ext_ctrl-&gt;value != sensor-&gt;info_priv.scene)</p>
<p>                {</p>
<p>                    if (sensor_set_scene(icd, qctrl,ext_ctrl-&gt;value) != 0)</p>
<p>                        return -EINVAL;</p>
<p>                    sensor-&gt;info_priv.scene = ext_ctrl-&gt;value;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Effect</p>
<p>        case V4L2_CID_EFFECT:</p>
<p>            {</p>
<p>                if (ext_ctrl-&gt;value != sensor-&gt;info_priv.effect)</p>
<p>                {</p>
<p>                    if (sensor_set_effect(icd, qctrl,ext_ctrl-&gt;value) != 0)</p>
<p>                        return -EINVAL;</p>
<p>                    sensor-&gt;info_priv.effect= ext_ctrl-&gt;value;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_DigitalZoom</p>
<p>        case V4L2_CID_ZOOM_ABSOLUTE:</p>
<p>            {</p>
<p>                if ((ext_ctrl-&gt;value &lt; qctrl-&gt;minimum) || (ext_ctrl-&gt;value &gt; qctrl-&gt;maximum))</p>
<p>                    return -EINVAL;</p>
<p>                if (ext_ctrl-&gt;value != sensor-&gt;info_priv.digitalzoom)</p>
<p>                {</p>
<p>                    val_offset = ext_ctrl-&gt;value -sensor-&gt;info_priv.digitalzoom;</p>
<p>                    if (sensor_set_digitalzoom(icd, qctrl,&amp;val_offset) != 0)</p>
<p>                        return -EINVAL;</p>
<p>                    sensor-&gt;info_priv.digitalzoom += val_offset;</p>
<p>                    SENSOR_DG(&quot;%s digitalzoom is %x\n&quot;,SENSOR_NAME_STRING(),  sensor-&gt;info_priv.digitalzoom);</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_ZOOM_RELATIVE:</p>
<p>            {</p>
<p>                if (ext_ctrl-&gt;value)</p>
<p>                {</p>
<p>                    if (sensor_set_digitalzoom(icd, qctrl,&amp;ext_ctrl-&gt;value) != 0)</p>
<p>                        return -EINVAL;</p>
<p>                    sensor-&gt;info_priv.digitalzoom += ext_ctrl-&gt;value;</p>
<p>                    SENSOR_DG(&quot;%s digitalzoom is %x\n&quot;, SENSOR_NAME_STRING(), sensor-&gt;info_priv.digitalzoom);</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Focus</p>
<p>        case V4L2_CID_FOCUS_ABSOLUTE:</p>
<p>            {</p>
<p>                if ((ext_ctrl-&gt;value &lt; qctrl-&gt;minimum) || (ext_ctrl-&gt;value &gt; qctrl-&gt;maximum))</p>
<p>                    return -EINVAL;</p>
<p>                if (ext_ctrl-&gt;value != sensor-&gt;info_priv.focus)</p>
<p>                {</p>
<p>                    val_offset = ext_ctrl-&gt;value -sensor-&gt;info_priv.focus;</p>
<p>                    sensor-&gt;info_priv.focus += val_offset;</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>        case V4L2_CID_FOCUS_RELATIVE:</p>
<p>            {</p>
<p>                if (ext_ctrl-&gt;value)</p>
<p>                {</p>
<p>                    sensor-&gt;info_priv.focus += ext_ctrl-&gt;value;</p>
<p>                    SENSOR_DG(&quot;%s focus is %x\n&quot;, SENSOR_NAME_STRING(), sensor-&gt;info_priv.focus);</p>
<p>                }</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>#if CONFIG_SENSOR_Flash</p>
<p>        case V4L2_CID_FLASH:</p>
<p>            {</p>
<p>                if (sensor_set_flash(icd, qctrl,ext_ctrl-&gt;value) != 0)</p>
<p>                    return -EINVAL;</p>
<p>                sensor-&gt;info_priv.flash = ext_ctrl-&gt;value;</p>
<p>                SENSOR_DG(&quot;%s flash is %x\n&quot;,SENSOR_NAME_STRING(), sensor-&gt;info_priv.flash);</p>
<p>                break;</p>
<p>            }</p>
<p>#endif</p>
<p>        default:</p>
<p>            break;</p>
<p>    }</p>
<p>    return 0;</p>
<p>}</p>
<p>static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)</p>
<p>{</p>
<p>    struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    int i, error_cnt=0, error_idx=-1;</p>
<p>    for (i=0; i&lt;ext_ctrl-&gt;count; i++) {</p>
<p>        if (sensor_g_ext_control(icd, &amp;ext_ctrl-&gt;controls[i]) != 0) {</p>
<p>            error_cnt++;</p>
<p>            error_idx = i;</p>
<p>        }</p>
<p>    }</p>
<p>    if (error_cnt &gt; 1)</p>
<p>        error_idx = ext_ctrl-&gt;count;</p>
<p>    if (error_idx != -1) {</p>
<p>        ext_ctrl-&gt;error_idx = error_idx;</p>
<p>        return -EINVAL;</p>
<p>    } else {</p>
<p>        return 0;</p>
<p>    }</p>
<p>}</p>
<p>static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)</p>
<p>{</p>
<p>    struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    int i, error_cnt=0, error_idx=-1;</p>
<p>    for (i=0; i&lt;ext_ctrl-&gt;count; i++) {</p>
<p>        if (sensor_s_ext_control(icd, &amp;ext_ctrl-&gt;controls[i]) != 0) {</p>
<p>            error_cnt++;</p>
<p>            error_idx = i;</p>
<p>        }</p>
<p>    }</p>
<p>    if (error_cnt &gt; 1)</p>
<p>        error_idx = ext_ctrl-&gt;count;</p>
<p>    if (error_idx != -1) {</p>
<p>        ext_ctrl-&gt;error_idx = error_idx;</p>
<p>        return -EINVAL;</p>
<p>    } else {</p>
<p>        return 0;</p>
<p>    }</p>
<p>}</p>
<p>/* Interface active, can use i2c. If it fails, it can indeed mean, that</p>
<p> * this wasn’t our capture interface, so, we wait for the right one */</p>
<p>static int sensor_video_probe(struct soc_camera_device *icd,</p>
<p>      struct i2c_client *client)</p>
<p>{</p>
<p>    char value;</p>
<p>    int ret,pid = 0;</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>    /* We must have a parent by now. And it cannot be a wrong one.</p>
<p>     * So this entire test is completely redundant. */</p>
<p>    if (!icd-&gt;dev.parent ||</p>
<p>   to_soc_camera_host(icd-&gt;dev.parent)-&gt;nr != icd-&gt;iface)</p>
<p>return -ENODEV;</p>
<p>if (sensor_ioctrl(icd, Sensor_PowerDown, 0) &lt; 0) {</p>
<p>ret = -ENODEV;</p>
<p>goto sensor_video_probe_err;</p>
<p>}</p>
<p>    /* soft reset */</p>
<p>    /* check if it is an sensor sensor */</p>
<p>   // honghaishen_test</p>
<p>    ret = sensor_read(client, 0xf0, &amp;value);</p>
<p>    if (ret != 0) {</p>
<p>        SENSOR_TR(&quot;read chip id high byte failed\n&quot;);</p>
<p>        ret = -ENODEV;</p>
<p>        goto sensor_video_probe_err;</p>
<p>    }</p>
<p>    pid |= (value &lt;&lt; 8);</p>
<p>    ret = sensor_read(client, 0xf1, &amp;value);</p>
<p>    if (ret != 0) {</p>
<p>        SENSOR_TR(&quot;read chip id low byte failed\n&quot;);</p>
<p>        ret = -ENODEV;</p>
<p>        goto sensor_video_probe_err;</p>
<p>    }</p>
<p>    pid |= (value &amp; 0xff);</p>
<p>    SENSOR_DG(&quot;\n %s  pid = 0x%x\n&quot;, SENSOR_NAME_STRING(), pid);</p>
<p>    if (pid == SENSOR_ID) {</p>
<p>        sensor-&gt;model = SENSOR_V4L2_IDENT;</p>
<p>    } else {</p>
<p>        SENSOR_TR(&quot;error: %s mismatched   pid = 0x%x\n&quot;, SENSOR_NAME_STRING(), pid);</p>
<p>        ret = -ENODEV;</p>
<p>        goto sensor_video_probe_err;</p>
<p>    }</p>
<p>sensor-&gt;model = SENSOR_V4L2_IDENT; </p>
<p>    return 0;</p>
<p>sensor_video_probe_err:</p>
<p>    return ret;</p>
<p>}</p>
<p>static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)</p>
<p>{</p>
<p>struct i2c_client *client = v4l2_get_subdevdata(sd);</p>
<p>    struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>#if CONFIG_SENSOR_Flash</p>
<p>    int i;</p>
<p>#endif</p>
<p>    int ret = 0;</p>
<p>SENSOR_DG(&quot;\n%s..%s..cmd:%x \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,cmd);</p>
<p>switch (cmd)</p>
<p>{</p>
<p>case RK29_CAM_SUBDEV_DEACTIVATE:</p>
<p>{</p>
<p>sensor_deactivate(client);</p>
<p>break;</p>
<p>}</p>
<p>case RK29_CAM_SUBDEV_IOREQUEST:</p>
<p>{</p>
<p>sensor-&gt;sensor_io_request = (struct rk29camera_platform_data*)arg;           </p>
<p>            if (sensor-&gt;sensor_io_request != NULL) { </p>
<p>                sensor-&gt;sensor_gpio_res = NULL;</p>
<p>                for (i=0; i&lt;RK29_CAM_SUPPORT_NUMS;i++) {</p>
<p>                    if (sensor-&gt;sensor_io_request-&gt;gpio_res[i].dev_name &amp;&amp; </p>
<p>                        (strcmp(sensor-&gt;sensor_io_request-&gt;gpio_res[i].dev_name, dev_name(icd-&gt;pdev)) == 0)) {</p>
<p>                        sensor-&gt;sensor_gpio_res = (struct rk29camera_gpio_res*)&amp;sensor-&gt;sensor_io_request-&gt;gpio_res[i];</p>
<p>                    }</p>
<p>                }</p>
<p>                if (sensor-&gt;sensor_gpio_res == NULL) {</p>
<p>                    SENSOR_TR(&quot;%s %s obtain gpio resource failed when RK29_CAM_SUBDEV_IOREQUEST \n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>);</p>
<p>                    ret = -EINVAL;</p>
<p>                    goto sensor_ioctl_end;</p>
<p>                }</p>
<p>            } else {</p>
<p>                SENSOR_TR(&quot;%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>);</p>
<p>                ret = -EINVAL;</p>
<p>                goto sensor_ioctl_end;</p>
<p>            }</p>
<p>            /* <a href="mailto:&#100;&#x64;&#108;&#64;&#114;&#x6f;&#x63;&#107;&#x2d;&#x63;&#x68;&#105;&#112;&#115;&#46;&#x63;&#111;&#109;">&#100;&#x64;&#108;&#64;&#114;&#x6f;&#x63;&#107;&#x2d;&#x63;&#x68;&#105;&#112;&#115;&#46;&#x63;&#111;&#109;</a> : if gpio_flash havn’t been set in board-xxx.c, sensor driver must notify is not support flash control </p>
<p>               for this project */</p>
<p>            #if CONFIG_SENSOR_Flash</p>
<p>        if (sensor-&gt;sensor_gpio_res) {</p>
<p>                if (sensor-&gt;sensor_gpio_res-&gt;gpio_flash == INVALID_GPIO) {</p>
<p>                    for (i = 0; i &lt; icd-&gt;ops-&gt;num_controls; i++) {</p>
<p>                if (V4L2_CID_FLASH == icd-&gt;ops-&gt;controls[i].id) {</p>
<p>                //memset((char*)&amp;icd-&gt;ops-&gt;controls[i],0x00,sizeof(struct v4l2_queryctrl));  </p>
<p>                              sensor_controls[i].id=0xffff;        </p>
<p>                }</p>
<p>                    }</p>
<p>                    sensor-&gt;info_priv.flash = 0xff;</p>
<p>                    SENSOR_DG(&quot;%s flash gpio is invalidate!\n&quot;,SENSOR_NAME_STRING());</p>
<p>                }else{ //two cameras are the same,need to deal diffrently ,zyc</p>
<p>                    for (i = 0; i &lt; icd-&gt;ops-&gt;num_controls; i++) {</p>
<p>                           if(0xffff == icd-&gt;ops-&gt;controls[i].id){</p>
<p>                              sensor_controls[i].id=V4L2_CID_FLASH;</p>
<p>                           }               </p>
<p>                    }</p>
<p>                }</p>
<p>        }</p>
<p>            #endif</p>
<p>break;</p>
<p>}</p>
<p>default:</p>
<p>{</p>
<p>SENSOR_TR(&quot;%s %s cmd(0x%x) is unknown !\n&quot;,SENSOR_NAME_STRING(),<strong>FUNCTION</strong>,cmd);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>sensor_ioctl_end:</p>
<p>return ret;</p>
<p>}</p>
<p>static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,</p>
<p>   enum v4l2_mbus_pixelcode *code)</p>
<p>{</p>
<p>if (index &gt;= ARRAY_SIZE(sensor_colour_fmts))</p>
<p>return -EINVAL;</p>
<p>*code = sensor_colour_fmts[index].code;</p>
<p>return 0;</p>
<p>}</p>
<p>static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {</p>
<p>.init = sensor_init,</p>
<p>.g_ctrl = sensor_g_control,</p>
<p>.s_ctrl = sensor_s_control,</p>
<p>.g_ext_ctrls          = sensor_g_ext_controls,</p>
<p>.s_ext_ctrls          = sensor_s_ext_controls,</p>
<p>.g_chip_ident = sensor_g_chip_ident,</p>
<p>.ioctl = sensor_ioctl,</p>
<p>};</p>
<p>static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {</p>
<p>.s_mbus_fmt = sensor_s_fmt,</p>
<p>.g_mbus_fmt = sensor_g_fmt,</p>
<p>.try_mbus_fmt = sensor_try_fmt,</p>
<p>.enum_mbus_fmt = sensor_enum_fmt,</p>
<p>};</p>
<p>static struct v4l2_subdev_ops sensor_subdev_ops = {</p>
<p>.core = &amp;sensor_subdev_core_ops,</p>
<p>.video = &amp;sensor_subdev_video_ops,</p>
<p>};</p>
<p>#if lily_debug</p>
<p>int ov5642_write_proc (struct file *file, const char *buffer,</p>
<p>                      unsigned long count, void *data)</p>
<p>{</p>
<p>char kbuf[14]={0,0,0,0,0,0,0,0,0,0,0,0,0,0};</p>
<p>char vol[10]={0,0,0,0,0,0,0,0,0,0};</p>
<p>char v[4]={0,0,0,0};</p>
<p>unsigned long totime;</p>
<p>unsigned short vol2=0;</p>
<p>char offset = 0;</p>
<p>int32_t rc = 0;</p>
<p>unsigned short vol1=0;</p>
<p>//u16 reg = 0;</p>
<p>char  val = 0;</p>
<p>struct clk *clk = NULL;</p>
<p>char value;</p>
<p>if (count &gt;= 14)</p>
<p>return -EINVAL;</p>
<p>if (copy_from_user(kbuf, buffer, count))</p>
<p>return -EFAULT;</p>
<p>if (‘w’ == kbuf[0]) {</p>
<p>memcpy(vol, kbuf+1, 2);</p>
<p>offset = (char) simple_strtoul(vol, NULL, 16);</p>
<p>memcpy(v,kbuf+3,2);</p>
<p>value = (u8) simple_strtoul(v,NULL,16);</p>
<p>sensor_write(g_client, offset, value);</p>
<p>printk(&quot;honghaishen_test %x %x \n &quot;,offset ,value);</p>
<p>}</p>
<p>else if(‘r’==kbuf[0])</p>
<p>{</p>
<p>memcpy(vol, kbuf+1, 2);</p>
<p>offset = (char) simple_strtoul(vol, NULL, 16);</p>
<p>sensor_read(g_client,offset,&amp;val);</p>
<p>printk(&quot;honghaishen_test read val is %x \n&quot;,val);</p>
<p>}</p>
<p>else if(‘i’==kbuf[0])</p>
<p>{</p>
<p>sensor_write_array(g_client, sensor_init_data);</p>
<p>}</p>
<p>return count;</p>
<p>}</p>
<p>int ov5642_read_proc (char *buffer, char **buffer_location, off_t offset,</p>
<p>                            int buffer_length, int *zero, void *ptr)</p>
<p>{</p>
<p>if(offset &gt; 0)</p>
<p>return 0;</p>
<p>return offset;</p>
<p>}</p>
<p>static void create_ov5642_proc_file(void)</p>
<p>{</p>
<p>struct proc_dir_entry *ov5642_proc_file =</p>
<p>create_proc_entry(&quot;ov5642&quot;, 0666, NULL);</p>
<p>if (ov5642_proc_file) {</p>
<p>ov5642_proc_file-&gt;read_proc = ov5642_read_proc;</p>
<p>ov5642_proc_file-&gt;write_proc = ov5642_write_proc;</p>
<p>} else</p>
<p>printk(KERN_NOTICE &quot;lily:(%d)%s:proc file create failed! \n&quot;,<strong>LINE</strong>,<strong>func</strong>);</p>
<p>}</p>
<p>#endif</p>
<p>static int sensor_probe(struct i2c_client *client,</p>
<p>const struct i2c_device_id *did)</p>
<p>{</p>
<p>    struct sensor *sensor;</p>
<p>    struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    struct i2c_adapter *adapter = to_i2c_adapter(client-&gt;dev.parent);</p>
<p>    struct soc_camera_link *icl;</p>
<p>    int ret;</p>
<p>#if lily_debug</p>
<p>   g_client = client;</p>
<p>#endif</p>
<p>    SENSOR_DG(&quot;\n%s..%s..%d..\n&quot;,<strong>FUNCTION</strong>,<strong>FILE</strong>,<strong>LINE</strong>);</p>
<p>    if (!icd) {</p>
<p>        dev_err(&amp;client-&gt;dev, &quot;%s: missing soc-camera data!\n&quot;,SENSOR_NAME_STRING());</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>#if lily_debug</p>
<p>create_ov5642_proc_file();</p>
<p>#endif</p>
<p>    icl = to_soc_camera_link(icd);</p>
<p>    if (!icl) {</p>
<p>        dev_err(&amp;client-&gt;dev, &quot;%s driver needs platform data\n&quot;, SENSOR_NAME_STRING());</p>
<p>        return -EINVAL;</p>
<p>    }</p>
<p>    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {</p>
<p>        dev_warn(&amp;adapter-&gt;dev,</p>
<p>        &quot;I2C-Adapter doesn’t support I2C_FUNC_I2C\n&quot;);</p>
<p>        return -EIO;</p>
<p>    }</p>
<p>    sensor = kzalloc(sizeof(struct sensor), GFP_KERNEL);</p>
<p>    if (!sensor)</p>
<p>        return -ENOMEM;</p>
<p>    v4l2_i2c_subdev_init(&amp;sensor-&gt;subdev, client, &amp;sensor_subdev_ops);</p>
<p>    /* Second stage probe - when a capture adapter is there */</p>
<p>    icd-&gt;ops = &amp;sensor_ops;</p>
<p>    sensor-&gt;info_priv.fmt = sensor_colour_fmts[0];</p>
<p>#if CONFIG_SENSOR_I2C_NOSCHED</p>
<p>atomic_set(&amp;sensor-&gt;tasklock_cnt,0);</p>
<p>#endif</p>
<p>    ret = sensor_video_probe(icd, client);</p>
<p>    if (ret &lt; 0) {</p>
<p>        icd-&gt;ops = NULL;</p>
<p>        i2c_set_clientdata(client, NULL);</p>
<p>        kfree(sensor);</p>
<p>sensor = NULL;</p>
<p>    }</p>
<p>hrtimer_init(&amp;(flash_off_timer.timer), CLOCK_MONOTONIC, HRTIMER_MODE_REL);</p>
<p>    SENSOR_DG(&quot;\n%s..%s..%d  ret = %x \n&quot;,<strong>FUNCTION</strong>,<strong>FILE</strong>,<strong>LINE</strong>,ret);</p>
<p>    return ret;</p>
<p>}</p>
<p>static int sensor_remove(struct i2c_client *client)</p>
<p>{</p>
<p>    struct sensor *sensor = to_sensor(client);</p>
<p>    struct soc_camera_device *icd = client-&gt;dev.platform_data;</p>
<p>    icd-&gt;ops = NULL;</p>
<p>    i2c_set_clientdata(client, NULL);</p>
<p>    client-&gt;driver = NULL;</p>
<p>    kfree(sensor);</p>
<p>    return 0;</p>
<p>}</p>
<p>static const struct i2c_device_id sensor_id[] = {</p>
<p>{SENSOR_NAME_STRING(), 0 },</p>
<p>{ }</p>
<p>};</p>
<p>MODULE_DEVICE_TABLE(i2c, sensor_id);</p>
<p>static struct i2c_driver sensor_i2c_driver = {</p>
<p>.driver = {</p>
<p>.name = SENSOR_NAME_STRING(),</p>
<p>},</p>
<p>.probe = sensor_probe,</p>
<p>.remove = sensor_remove,</p>
<p>.id_table = sensor_id,</p>
<p>};</p>
<p>static int __init sensor_mod_init(void)</p>
<p>{</p>
<p>    SENSOR_DG(&quot;\n%s..%s.. \n&quot;,<strong>FUNCTION</strong>,SENSOR_NAME_STRING());</p>
<p>    return i2c_add_driver(&amp;sensor_i2c_driver);</p>
<p>}</p>
<p>static void __exit sensor_mod_exit(void)</p>
<p>{</p>
<p>    i2c_del_driver(&amp;sensor_i2c_driver);</p>
<p>}</p>
<p>device_initcall_sync(sensor_mod_init);</p>
<p>module_exit(sensor_mod_exit);</p>
<p>MODULE_DESCRIPTION(SENSOR_NAME_STRING(Camera sensor driver));</p>
<p>MODULE_AUTHOR(&quot;ddl &lt;kernel@rock-chips&gt;&quot;);</p>
<p>MODULE_LICENSE(&quot;GPL&quot;);</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>各种音视频编解码学习详解</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E5%90%84%E7%A7%8D%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>各种音视频编解码学习详解</p>
<p>编解码学习笔记（一）：基本概念</p>
<p>媒体业务是网络的主要业务之间。尤其移动互联网业务的兴起，在运营商和应用开发商中，媒体业务份量极重，其中媒体的编解码服务涉及需求分析、应用开发、释放license收费等等。最近因为项目的关系，需要理清媒体的codec，比较搞的是，在豆丁网上看运营商的规范 标准，同一运营商同样的业务在不同文档中不同的要求，而且有些要求就我看来应当是历史的延续，也就是现在已经很少采用了。所以豆丁上看不出所以然，从 wiki上查。中文的wiki信息量有限，很短，而wiki的英文内容内多，删减版也减肥得太过。我在网上还看到一个山寨的中文wiki，长得很像，红色的，叫“天下维客”。wiki的中文还是很不错的，但是阅读后建议再阅读英文。</p>
<p>　　我对媒体codec做了一些整理和总结，资料来源于wiki，小部分来源于网络博客的收集。网友资料我们将给出来源。如果资料已经转手几趟就没办法，雁过留声，我们只能给出某个轨迹。</p>
<p>基本概念</p>
<p>编解码</p>
<p>　　编解码器（codec）指的是一个能够对一个信号或者一个数据流进行变换的设备或者程序。这里指的变换既包括将 信号或者数据流进行编码（通常是为了传输、存储或者加密）或者提取得到一个编码流的操作，也包括为了观察或者处理从这个编码流中恢复适合观察或操作的形式的操作。编解码器经常用在视频会议和流媒体等应用中。</p>
<p>容器</p>
<p>　　很多多媒体数据流需要同时包含音频数据和视频数据，这时通常会加入一些用于音频和视频数据同步的元数据，例如字幕。这三种数据流可能会被不同的程序，进程或者硬件处理，但是当它们传输或者存储的时候，这三种数据通常是被封装在一起的。通常这种封装是通过视频文件格 式来实现的，例如常见的*.mpg, *.avi, *.mov, *.mp4, *.rm, *.ogg or *.tta. 这些格式中有些只能使用某些编解码器，而更多可以以容器的方式使用各种编解码器。</p>
<p>　　FourCC全称Four-Character Codes，是由4个字符（4 bytes）组成，是一种独立标示视频数据流格式的四字节，在wav、avi档案之中会有一段FourCC来描述这个AVI档案，是利用何种codec来 编码的。因此wav、avi大量存在等于“IDP3”的FourCC。</p>
<p>　　视频是现在电脑中多媒体系统中的重要一环。为了适应储存视频的需要，人们设定了不同的视频文件格式来把视频和音频放在一个文件中，以方便同时回放。视频档实际上都是一个容器里面包裹着不同的轨道，使用的容器的格式关系到视频档的可扩展性。</p>
<p>参数介绍</p>
<p>采样率</p>
<p>　　采样率（也称为采样速度或者采样频率）定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。采样频率的倒数叫作采样周期或采样时间，它是采样之间的时间间隔。注意不要将采样率与比特率（bit rate，亦称“位速率”）相混淆。</p>
<p>　　采样定理表明采样频率必须大于被采样信号带宽的两倍，另外一种等同的说法是奈奎斯特频率必须大于被采样信号的带宽。如果信号的带宽是 100Hz，那么为了避免混叠现象采样频率必须大于200Hz。换句话说就是采样频率必须至少是信号中最大频率分量频率的两倍，否则就不能从信号采样中恢复原始信号。</p>
<p>　　对于语音采样：</p>
<p>8,000 Hz - 电话所用采样率, 对于人的说话已经足够</p>
<p>11,025 Hz</p>
<p>22,050 Hz - 无线电广播所用采样率</p>
<p>32,000 Hz - miniDV 数码视频 camcorder、DAT (LP mode)所用采样率</p>
<p>44,100 Hz - 音频 CD, 也常用于 MPEG-1 音频（VCD, SVCD, MP3）所用采样率</p>
<p>47,250 Hz - Nippon Columbia (Denon)开发的世界上第一个商用 PCM 录音机所用采样率</p>
<p>48,000 Hz - miniDV、数字电视、DVD、DAT、电影和专业音频所用的数字声音所用采样率</p>
<p>50,000 Hz - 二十世纪七十年代后期出现的 3M 和 Soundstream 开发的第一款商用数字录音机所用采样率</p>
<p>50,400 Hz - 三菱 X-80 数字录音机所用所用采样率</p>
<p>96,000 或者 192,000 Hz - DVD-Audio、一些 LPCM DVD 音轨、Blu-ray Disc（蓝光盘）音轨、和 HD-DVD （高清晰度 DVD）音轨所用所用采样率</p>
<p>2.8224 MHz - SACD、 索尼 和 飞利浦 联合开发的称为 Direct Stream Digital 的 1 位 sigma-delta modulation 过程所用采样率。</p>
<p>　　在模拟视频中，采样率定义为帧频和场频，而不是概念上的像素时钟。图像采样频率是传感器积分周期的循环速度。由于积分周期远远小于重复所需时间，采样频率可能与采样时间的倒数不同。</p>
<p>50 Hz - PAL 视频</p>
<p>60 / 1.001 Hz - NTSC 视频</p>
<p>　　当模拟视频转换为数字视频的时候，出现另外一种不同的采样过程，这次是使用像素频率。一些常见的像素采样率有：</p>
<p>13.5 MHz - CCIR 601、D1 video</p>
<p>分辨率</p>
<p>　　分辨率，泛指量测或显示系统对细节的分辨能力。此概念可以用时间、空间等领域的量测。日常用语中之分辨率多用于图像的清晰度。分辨率越高代表图像品质越好，越能表现出更多的细节。但相对的，因为纪录的信息越多，文件也就会越大。目前个人电脑里的图像，可以使用图像 处理软件，调整图像的大小、编修照片等。例如 photoshop，或是photoimpact等软件。</p>
<p>　图像分辨率 ：</p>
<p>　　用以描述图像细节分辨能力，同样适用于数字图像、胶卷图像、及其他类型图像。常用’线每毫米’、 ‘线每英吋’等来衡量。通常，“分辨率”被表示成每一个方向上的像素数量，比如640x480等。而在某些情况下，它也可以同时表示成“每英吋像素” （pixels per inch，ppi）以及图形的长度和宽度。比如72ppi，和8x6英吋。</p>
<p>　视频分辨率 ：</p>
<p>各种电视规格分辨率比较视 频的画面大小称为“分辨率”。数位视频以像素为度量单位，而类比视频以水平扫瞄线数量为度量单位。标清电视频号分辨率为 720/704/640x480i60（NTSC）或768/720x576i50（PAL/SECAM）。新的高清电视（HDTV）分辨率可达 1920x1080p60，即每条水平扫瞄线有1920个像素，每个画面有1080条扫瞄线，以每秒钟60张画面的速度播放。</p>
<p>画面更新率fps</p>
<p>　　Frame rate中文常译为“画面更新率”或“帧率”，是指视频格式每秒钟播放的静态画面数量。典型的画面更新率由早期的每秒6或8张（frame persecond，简称fps），至现今的每秒120张不等。PAL (欧洲，亚洲，澳洲等地的电视广播格式) 与 SECAM (法国，俄国，部分非洲等地的电视广播格式) 规定其更新率为25fps，而NTSC (美国，加拿大，日本等地的电视广播格式) 则规定其更新率为29.97 fps。电影胶卷则是以稍慢的24fps在拍摄，这使得各国电视广播在播映电影时需要一些复杂的转换手续（参考Telecine转换）。要达成最基本的视觉暂留效果大约需要10fps的速度。</p>
<p>压缩方法</p>
<p>有损压缩和无损压缩</p>
<p>　　在视频压缩中有损（Lossy ）和无损（Lossless）的概念与静态图像中基本类似。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损 压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息，而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩，这样才能达到低数据率的目标。丢失的数据率与压缩比有关，压缩比越小，丢失的数据越多，解压缩后的效果一般越差。此外，某些有损压 缩算法采用多次重复压缩的方式，这样还会引起额外的数据丢失。</p>
<p>无损格式，例如WAV，PCM，TTA，FLAC，AU，APE，TAK，WavPack(WV)</p>
<p>有损格式，例如MP3，Windows Media Audio（WMA），Ogg Vorbis（OGG），AAC</p>
<p>帧内压缩和帧间压缩</p>
<p>　　帧内（Intraframe）压缩也称为空间压缩 （Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩时各个帧之间没有相互关系，所以压缩后的视频数据仍可以以帧为单位进行编辑。帧内压缩一般达不到很高的压缩。</p>
<p>　　采用帧间（Interframe）压缩是基于许多视频或 动画的连续前后两帧具有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息，根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporalcompression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。</p>
<p>对称编码和不对称编码</p>
<p>　　对称性（symmetric）是压缩编码的一个关键特 征。对称意味着压缩和解压缩占用相同的计算处理能力和时间，对称算法适合于实时压缩和传送视频，如视频会议应用就以采用对称的压缩编码算法为好。而在电子出版和其它多媒体应用中，一般是把视频预先压缩处理好，尔后再播放，因此可以采用不对称（asymmetric）编码。不对称或非对称意味着压缩时需要花费大量的处理能力和时间，而解压缩时则能较好地实时回放，也即以不同的速度进行压缩和解压缩。一般地说，压缩一段视频的时间比回放（解压缩）该视频的时间 要多得多。例如，压缩一段三分钟的视频片断可能需要10多分钟的时间，而该片断实时回放时间只有三分钟。</p>
<p>除wiki外的资料来源：<a href="http://tech.lmtw.com/csyy/Using/200411/3142.html">http://tech.lmtw.com/csyy/Using/200411/3142.html</a></p>
<p>编解码学习笔记（二）：codec类型</p>
<p>资料（港台将information翻译为资料）压缩是透过去除资料中的冗余资讯而达成。就视讯资料而言，资料中的冗余资讯可以分成四类：</p>
<p>时间上的冗余资讯（temporal redundancy）<br>　　在视讯资料中，相邻的帧（frame）与帧之间通常有很强的关连性，这样的关连性即为时间上的冗余资讯。这即是上一次学习中的帧间压缩。</p>
<p>空间上的冗余资讯（spatial redundancy）<br>　　在同一张帧之中，相邻的像素之 间通常有很强的关连性，这样的关连性即为空间上的冗余资讯。这即是上一次学习中的帧内压缩。</p>
<p>统计上的冗余资讯（statistical redundancy）<br>　　统计上的冗余资讯指的是欲编码的符号（symbol）的机率分布是不均匀（non-uniform）的。</p>
<p>感知上的冗余资讯（perceptual redundancy）<br>　　感知上的冗余资讯是指在人在观看视讯时，人眼无法察觉的资讯。</p>
<p>　　视讯压缩（英文：Video compression）是指运用资料压缩技术将数位视讯资料中的冗余资讯去除，降低表示原始视讯所需的资料量，以便视讯资料的传输与储存。实际上，原始视讯资料的资料量往往过大，例如未经压缩的电视品质视讯资料的位元率高达216Mbps，绝大多数的应用无法处理如此庞大的资料量，因此视讯压缩是必要的。目前最新的视讯编码标准为ITU-T视讯编码专家组（VCEG）和ISO／IEC动态图像专家组（MPEG）联合组成的联合视讯组（JVT，Joint Video Team）所提出的H.264/AVC。</p>
<p>　　一个典型的视讯编码器：在进行当前信号编码时，编码器首先会产生对当前信号做预测的信号，称作预测信号（predicted signal），预测的方式可以是时间上的预测（interprediction），亦即使用先前帧的信号做预测，或是空间上的预测 （intra prediction），亦即使用同一张帧之中相邻像素的信号做预测。得到预测信号后，编码器会将当前信号与预测信号相减得到残余信号（residual signal），并只对残余信号进行编码，如此一来，可以去除一部份时间上或是空间上的冗余资讯。接着，编码器并不会直接对残余信号进行编码，而是先将残余信号经过变换（通常为离散余弦变换）然后量化以 进一步去除空间上和感知上的冗余资讯。量化后得到的量化系数会再透过熵编码，去除统计上的冗余资讯。</p>
<p>视讯编码标准发展</p>
<p>年份</p>
<p>标准</p>
<p>制定组织</p>
<p>解除版权保护<br>（DRM-free ）</p>
<p>主要应用</p>
<p>1984</p>
<p>H.120</p>
<p>ITU-T</p>
<p>是</p>
<p>1990</p>
<p>H.261</p>
<p>ITU-T</p>
<p>是</p>
<p>视讯会议、视讯通话</p>
<p>1993</p>
<p>MPEG-1 第二部份</p>
<p>ISO ／IEC</p>
<p>是</p>
<p>影音光碟（VCD ）</p>
<p>1995</p>
<p>H.262/MPEG-2 第二部份</p>
<p>ISO ／ IEC 、ITU-T</p>
<p>否</p>
<p>DVD影碟（DVD-Video ）、蓝光（Blu-Ray ）影碟、数位视讯广播（DVB ）、SVCD</p>
<p>1996</p>
<p>H.263 [6]</p>
<p>ITU-T</p>
<p>视讯会议、视讯通话、3G 手机视讯（3GP ）</p>
<p>1999</p>
<p>MPEG-4 第二部份</p>
<p>ISO ／IEC</p>
<p>否</p>
<p>2003</p>
<p>H.264/MPEG-4 AVC[1]</p>
<p>ISO ／ IEC 、ITU-T</p>
<p>否</p>
<p>蓝光（Blu-Ray ）影碟、数位视讯广播（DVB ）、iPod 视讯、高画质DVD（HD DVD）</p>
<p>常见的编解码见下表，在以后会分类论述：</p>
<p>视频codec</p>
<p>ISO/IEC</p>
<p>MJPEG · Motion JPEG 2000 · MPEG-1 · MPEG-2 (Part 2 )· MPEG-4 (Part 2/ASP · Part 10/AVC )· HVC</p>
<p>ITU-T</p>
<p>H.120 · H.261 · H.262 · H.263 · H.264 · H.265</p>
<p>其它</p>
<p>AMV · AVS · Bink · CineForm · Cinepak · Dirac · DV · Indeo · Microsoft Video 1 · OMS Video · Pixlet · RealVideo · RTVideo · SheerVideo ·Smacker · Sorenson Video &amp; Sorenson Spark · Theora · VC-1 · VP3 · VP6 · VP7 · VP8 · WMV</p>
<p>音频 codec</p>
<p>ISO/IECMPEG</p>
<p>MPEG-1 Layer III (MP3) · MPEG-1 Layer II · MPEG-1 Layer I · AAC · HE-AAC · MPEG-4 ALS · MPEG-4 SLS · MPEG-4 DST</p>
<p>ITU-T</p>
<p>G.711 · G.718 · G.719 · G.722 · G.722.1 · G.722.2 · G.723 · G.723.1 · G.726 · G.728 · G.729 · G.729.1</p>
<p>其它</p>
<p>AC-3 · AMR · AMR-WB · AMR-WB+ · Apple Lossless · ATRAC · DRA · DTS · FLAC · GSM-HR · GSM-FR · GSM-EFR · iLBC · Monkey’s Audio ·TTA (True Audio)· MT9 · μ-law · Musepack · Nellymoser · OptimFROG · OSQ · RealAudio · RTAudio · SD2 · SHN · SILK · Siren · Speex ·TwinVQ · Vorbis · WavPack · WMA</p>
<p>图像压缩</p>
<p>ISO/IEC/ITU-T</p>
<p>JPEG · JPEG 2000 · JPEG XR · lossless JPEG · JBIG · JBIG2 · PNG · WBMP</p>
<p>Others</p>
<p>APNG · BMP · DjVu · EXR · GIF · ICER · ILBM · MNG · PCX · PGF · TGA · TIFF</p>
<p>媒体容器</p>
<p>通用</p>
<p>3GP · ASF · AVI · Bink · BXF · DMF · DPX · EVO · FLV · GXF · M2TS · Matroska · MPEG-PS · MPEG-TS · MP4 · MXF · Ogg · QuickTime · RealMedia · RIFF · Smacker · VOB</p>
<p>只用于音频</p>
<p>AIFF · AU· WAV</p>
<p>上面的表格，查看某个具体的codec，可以在中文的wiki中查找，但是英文的wiki咨询更为丰富，见下表</p>
<p>Multimedia compression formats</p>
<p>Video compression</p>
<p>ISO/IEC</p>
<p>MJPEG · Motion JPEG 2000 · MPEG-1 · MPEG-2 (Part 2 )· MPEG-4 (Part 2/ASP · Part 10/AVC )· HEVC</p>
<p>ITU-T</p>
<p>H.120 · H.261 · H.262 · H.263 · H.264 · HEVC</p>
<p>Others</p>
<p>AMV · AVS · Bink · CineForm · Cinepak · Dirac · DV · Indeo · Microsoft Video 1 · OMS Video · Pixlet · RealVideo · RTVideo ·SheerVideo · Smacker · Sorenson Video &amp; Sorenson Spark · Theora · VC-1 · VP3 · VP6 · VP7 · VP8 · WMV</p>
<p>Audio compression</p>
<p>ISO/IEC</p>
<p>MPEG-1 Layer III (MP3) · MPEG-1 Layer II · MPEG-1 Layer I · AAC · HE-AAC · MPEG-4 ALS · MPEG-4 SLS · MPEG-4 DST · MPEG-4 HVXC · MPEG-4 CELP</p>
<p>ITU-T</p>
<p>G.711 · G.718 · G.719 · G.722 · G.722.1 · G.722.2 · G.723 · G.723.1 · G.726 · G.728 · G.729 · G.729.1</p>
<p>Others</p>
<p>AC-3 · AMR · AMR-WB · AMR-WB+ · Apple Lossless · ATRAC · DRA · DTS · FLAC · GSM-HR · GSM-FR · GSM-EFR · iLBC · Monkey’s Audio · TTA (True Audio)· MT9 · μ-law · Musepack · Nellymoser · OptimFROG · OSQ · RealAudio · RTAudio · SD2 · SHN · SILK · Siren ·Speex · TwinVQ · Vorbis · WavPack · WMA</p>
<p>Image compression</p>
<p>ISO /IEC /ITU-T</p>
<p>JPEG · JPEG 2000 · JPEG XR · lossless JPEG · JBIG · JBIG2 · PNG · WBMP</p>
<p>Others</p>
<p>APNG · BMP · DjVu · EXR · GIF · ICER · ILBM · MNG · PCX · PGF · TGA · QTVR · TIFF</p>
<p>Media containers</p>
<p>ISO/IEC</p>
<p>MPEG-PS · MPEG-TS · MPEG-4 Part 12 /JPEG 2000 Part 12 · MPEG-4 Part 14</p>
<p>ITU-T</p>
<p>H.222.0</p>
<p>Others</p>
<p>3GP and 3G2 · ASF · AVI · Bink · DivX Media Format · DPX · EVO · Flash Video · GXF · M2TS · Matroska · MXF · Ogg · QuickTime ·RealMedia · REDCODE RAW · RIFF · Smacker · MOD and TOD · VOB · WebM</p>
<p>Audio only</p>
<p>AIFF · AU · WAV</p>
<p>编解码学习笔记（三）：Mpeg系列——Mpeg 1和Mpeg 2</p>
<p>MPEG是Moving Picture Experts Group的简称。这个名字本来的含义是指一个研究视频和音频编码标准的小组。现在我们所说的MPEG泛指又该小组制定的一系列视频编码标准。该小组于 1988年组成，至今已经制定了MPEG-1、MPEG-2、MPEG-3、MPEG-4、MPEG-7等多个标准，MPEG-21正在制定中。</p>
<p>MPEG到目前为止已经制定并正在制定以下和视频相关的标准：</p>
<p>MPEG-1： 第一个官方的视訊音訊压缩标准，随后在Video CD中被采用，其中的音訊压缩的第三级（MPEG-1 Layer 3）简称MP3， 成为比较流行的音訊压缩格式。</p>
<p>MPEG-2： 广播质量的视訊、音訊和传输协议。被用于無線數位電視-ATSC、DVB以及ISDB、数字卫星电视（例如DirecTV）、 数字有线电视信号，以及DVD视频光盘技术中。</p>
<p>MPEG-3： 原本目标是为高解析度电视（HDTV）设计，随后發現MPEG-2已足夠HDTV應用，故 MPEG-3的研發便中止。</p>
<p>MPEG- 4：2003 年发布的视訊压缩标准，主要是扩展MPEG-1、MPEG-2等標準以支援視訊／音訊物件（video/audio &quot;objects&quot;）的編碼、3D內容、低位元率編碼（low bitrate encoding）和數位版權管理（Digital Rights Management），其中第10部分由ISO/IEC和ITU-T联合发布，称为H.264/MPEG-4 Part 10。参见H.264。</p>
<p>MPEG-7：MPEG-7并不是一个视訊压缩标准，它是一个多媒体内容的描述标准。</p>
<p>MPEG-21：MPEG-21是一个正在制定中的标准，它的目标是为未来多媒体的应用提供一个完整的平台。</p>
<p>　　媒体codec在于MPEG-1，MPEG-2，MPEG-4，如上图所示。</p>
<p>图中名称解释：在图中DVD地球人都知道，何为DVB？</p>
<p>DVB：数字视频广播（DVB, Digital VideoBroadcasting），是由“DVB Project”维护的一系列为国际所承认的数字电视公开标准。DVB系统传输方式有如下几种：</p>
<p>·        卫星电视（DVB-S 及 DVB-S2）</p>
<p>·        有线电视（DVB-C）</p>
<p>·        无线电视（DVB-T）</p>
<p>·        手持地面无线（DVB-H）</p>
<p>这些标准定义了传输系统的物理层与数据链路层。设备通过同步并行接口（synchronous parallel interface, SPI），同步串行接口（synchronous serial interface, SSI），或异步串行接口（asynchronousserial interface, ASI）与物理层交互。数据以MPEG-2传输流的方式传输，并要求符合更严格的限制（DVB-MPEG）。对移动终端即时压缩传输数据的标准（DVB- H）目前正处于测试之中。</p>
<p>这些传输方式的主要区别在于使用的调制方式，因为不同它们应用的频率带宽的要求不同。利用高频载波的DVB-S使用QPSK调制方式，利用低频载波的DVB-C使用QAM-64 调制方式，而利用VHF 及 UHF载波的DVB-T使用COFDM调制方式。</p>
<p>除音频与视频传输外，DVB也定义了带回传信道（DVB-RC）的数据通信标准（DVB-DATA）。</p>
<p>DVB的codec，视频为：MPEG-2，MPEG-4 AVC；音频为：MP3，AC-3，AAC，HE-AAC。</p>
<p>MPEG-1</p>
<p>　　MPEG-1作为ISO/IEC11172正式发布。</p>
<p>　　MPEG-1较早的视频编码，质量比较差，主要用于 CD-ROM 存储视频，国内最为大家熟悉的就是 VCD（Video CD），他的视频编码就是采用 MPEG-1。它是为CD光盘介质定制的视频和音频压缩格式。一张70分钟的CD光盘传输速率大约在1.4Mbps。而 MPEG-1采用了块方式的运动补偿、离散余弦变换（DCT）、量化等技术，并为1.2Mbps传输速率进行了优化。MPEG-1 随后被Video CD采用作为内核技术。MPEG-1的输出质量大约和传统录像机VCR，信号质量相当，这也许是Video CD在发达国家未获成功的原因。</p>
<p>　　MPEG-1音频分三层，就是MPEG-1 Layer I, II, III，其中第三层协议也就是MPEG- 1 Layer 3，简称MP3。MP3目前已经成为广泛流传的音频压缩技术。</p>
<p>MPEG-1有下面几个部分：</p>
<p>第一部分（Part 1）：系统；</p>
<p>第二部分（Part 2）：视频；</p>
<p>第三部分（Part 3）：音频；定义level1，level2，level3，并在MPEG-2中定义了扩展。</p>
<p>第四部分（Part 4）：一次性测试；</p>
<p>第五部分（Part 5）：参考软件；</p>
<p>MPEG－１的缺点：</p>
<p>1个音频压缩系统限于两个通道（立体声）</p>
<p>没有为隔行扫描视频提供标准化支持，且压缩率差</p>
<p>只有一个标准化的“profile” （约束参数比特流）， 不适应 更高分辨率的视频。MPEG - 1可以支持4k的视频，但难以提供更高分辨率的视频编码并且标识硬件的支持能力。</p>
<p>支持只有一个颜色空间，4:2:0。</p>
<p>MPEG-2</p>
<p>MPEG-2内容介绍</p>
<p>　　MPEG-2作为ISO/IEC 13818正式发布，通常用来为广播信号提供视频和音频编码，包括卫星电视、有线电视等。MPEG-2经过少量修改后，也成为DVD产品的内核技术。</p>
<p>　　MPEG-2有11部分，具体如下：</p>
<p>第一部（Part 1）：系统-描述视频和音频的同步和多路技术</p>
<p>　　正式名称是 ISO/IEC 13818-1或 ITU-T中的H.222.0</p>
<p>　　MPEG-2的系统描述部分（第1部分）定义了传输流，它用来一套在非可靠介质上传输数字视频信号和音频信号的机制，主要用在广播电视领域。</p>
<p>　　定义了两个不同但相关的容器格式，MPEG transport stream和MPEG program stream，也就是图中的TS和PS。MPEG传输流（TS）为携带可损数字视频和音频，媒体流的开始和结束可以不标识出来，就像广播或者磁带，其中的 例子包括ATSC，DVB，SBTVD 和HDV。MPEG-2系统还定义了MPEG节目流（PS），它为以文件为基础的媒体设计一个容器格式，用于 硬盘驱动器，光盘 和闪存。</p>
<p>　　 MPEG-2 PS（节目流）是为在存储介质保存视频信息而开发的。 MPEG-2 TS（传输流）是为在网络传输视频信息而开发的。目前，MPEG-2 TS最广泛地应用是DVB系统。TS流与PS流的区别在于TS流的包结构是固定度的，而PS流的包结构是可变长度。 PS包与TS包在结构上的这种差异，导致了它们对传输误码具有不同的抵抗能力，因而应用的环境也有所不同。TS码流由于采用了固定长度的包结构，当传输误 码破坏了某一TS包的同步信息时，接收机可在固定的位置检测它后面包中的同步信息，从而恢复同步，避免了信息丢失。而PS包由于长度是变化的，一旦某一 PS包的同步信息丢失，接收机无法确定下一包的同步位置，就会造 成失步，导致严重的信息丢失。因此，在信道环境较为恶劣，传输误码较高时，一般采用TS码流；而在信道环境较好，传输误码较低时，一般采用PS码流由于 TS码流具有较强的抵抗传输误码的能力，因此目前在传输媒体中进行传输的MPEG-2码流基本上都采用了TS码流的包格。</p>
<p>第二部（Part 2）：视频-视频压缩</p>
<p>　　正式名称是 ISO/IEC 13818-2或 ITU-T H.262。</p>
<p>　　提供隔行扫描和非隔行扫描视频信号的压缩编解码器。</p>
<p>　　MPEG-2的第二部分即视频部分和MPEG-1类似，但是它提供对隔行扫描视频显示模式的支持（隔行扫描广泛应用在广播电视领域）。MPEG-2视频并没有对低位速率（小于1Mbps）进行优化，在 3Mbit/s及以上位速率情况下，MPEG-2明显优于MPEG-1。 MPEG-2向后兼容，也即是说，所有符合标准的MPEG-2解码器也能够正常播放MPEG-1视频流。</p>
<p>　　MPEG-2技术也应用在了HDTV传输系统中。MPEG-2 不光运用于 DVD-Video ，现在大部 分 HDTV（高清电视）也采用 MPEG-2 编码，分辨率达到了 1920x1080。由于 MPEG-2 的普及，本来为 HDTV 准备 的 MPEG-3 最终宣告放弃。</p>
<p>　　MPEG-2视频通常包含多个GOP（GroupOf Pictures），每一个GOP包含多个帧（frame）。帧的帧类（frame type）通常包括I-帧（I-frame）、P-帧（P-frame）和B-帧（B-frame）。其中I-帧采用帧内编码，P-帧采用前向估计，B- 帧采用双向估计。一般来说输入视频格式是25（CCIR标准）或者29.97（FCC）帧／秒。</p>
<p>　　MPEG-2支持隔行扫描和逐行扫描。在逐行扫描模式下，编码的基本单元是帧。在隔行扫描模式下，基本编码可以是帧，也可以是场（field）。</p>
<p>　　原始输入图像首先被转换到YCbCr颜色空间。其中Y是亮度，Cb和Cr是两个色度通道。 Cb指蓝色色 度，Cr指红色色度。对于每一通道，首先采用块分区，然后形成“宏块”（macroblocks），宏块构成了编码的基本单元。每一个宏块再分 区成8x8的小块。色度通道分区成小块的数目取决于初始参数设置。例如，在常用的4:2:0格式下，每个色度宏块只采样出一个小块，所以三个通道宏块能够 分区成的小块数目是4+1+1=6个。</p>
<p>　　对于I-帧，整幅图像直接进入编码过程。对于P-帧和B-帧，首先做运动补偿。通常来说，由于相邻帧之间的相关 性很强，宏块可以在前帧和后帧中对应相近的位置找到相似的区域匹配的比较好，这个偏移量作为运动向量被记录下来，运动估计重构的区域的误差被送到编码器中编码。</p>
<p>　　对于每一个8×8小块，离散余弦变换把图像从空间域转换到频域。得到的变换系数被量化并重新组织排列顺序，从而增加长零的可能性。之后做游程编码（run-length code）。最后作哈夫曼编码（Huffman Encoding）。</p>
<p>　　I帧编码是为了减少空间域冗余，P帧和B帧是为了减少时间域冗余。</p>
<p>　　GOP是由固定模式的一系列I帧、P帧、B帧组成。常用的结构由15个帧组成，具有以下形式 IBBPBBPBBPBBPBB。GOP中各个帧的比例的选取和带宽、图像的质量要求有一定关系。例如因为B帧的压缩时间可能是I帧的三倍，所以对于计算 能力不强的某些实时系统，可能需要减少B帧的比例。</p>
<p>　　MPEG-2输出的比特流可以是匀速或者变速的。最大比特率，例如在DVD应用上，可达10.4 Mbit/s。如果要使用固定比特率，量化尺度就需要不断的调节以产生匀速的比特流。但是，提高量化尺度可能带来可视的失真效果。比如马赛克现象。</p>
<p>第三部（Part 3）：音频-音频压缩</p>
<p>　　MPEG-2的第三部分定义了音频压缩标准。MPEG-2 BC（Backwards compatible），后向兼容MPEG-1音频。该部分改进了MPEG-1的音频压缩，支持两通道以上的音频，可高达5.1多声道。MPEG-2音频 压缩部分也保持了向后兼容的特点（也称为MPEG - 2 BC），允许的MPEG - 1音频解码器解码两个主立体声组件。还定义音频MPEG-1 Layer I,II ,III额外的比特率和采样频率。</p>
<p>　　例如mp2，是MPEG-1 Audio level 2，标准有：ISO/IEC 11172-3, ISO/IEC 13818-3。MPEG-1Layer II 定义在 ISO/IEC 11172-3，也就是MPEG-1的第三部分，在 ISO/IEC 13818-3，也就是MPEG-2的第3部分定义扩展。</p>
<p>第四部（Part 4）：测试规范</p>
<p>　　描述测试程序。</p>
<p>第五部（Part 5）：仿真软件</p>
<p>　　描述软件仿真系统。</p>
<p>第六部（Part 6）：DSM-CC(Digital Storage Media Commandand Control)扩展</p>
<p>　　描述DSM-CC（数字存储媒体命令及控制）扩展。</p>
<p>第七部（Part 7）：Advanced Audio Coding (AAC)</p>
<p>　　MPEG-2的第七部分定义了不能向后兼容的音频压缩（也成为MPEG-2 NBC）。也成为MPEG-2 NBC（not-backwards compatible MPEG-1Audio）。该部分提供了更强的音频功能。通常我们所说的MPEG-2 AAC指的就是这一部分。AAC即Advanced Audio Coding。 AAC是比以前的MPEG音频标准的效率，并在某个程度上没有它的前任MPEG-1 Layer3（MP3）复杂，它没有复杂的混合滤波器（hybrid filter bank）。它支持从1到48个通道，采样率从8-96千赫，多渠道，多语种和多节目（multiprogram）能力。AAC也在MPEG-4标准的第 3部分描述。</p>
<p>第八 部（Part 8）：</p>
<p>　　 已取消。</p>
<p>第九部（Part ９）：实时接口扩展</p>
<p>　　实时接口扩展。</p>
<p>第十部（Part 10）：DSM-CC一致性扩展</p>
<p>　　DSM-CC一致性扩展。</p>
<p>第十一部（Part 11） ：IP</p>
<p>　　知识产权管理（IPMP）。XML定义在ISO/IEC23001-3。MPEG-2内核技术大约涉及640个专利，这些专利主要集中在20间公司和一间大学。</p>
<p>MPEG- 2音频</p>
<p>　　MPEG－ ２提供新的音频编码方式。在第３部分和第７部分介绍。</p>
<p>第三部分</p>
<p>　　MPEG-2 BC (backward compatible with MPEG-1 audio formats)，使用一半的取样速率处理低位速率的音频，(MPEG-1 Layer 1/2/3 LSF)，多通道编码达到5.1个通道。</p>
<p>第七部分</p>
<p>　　MPEG-2 NBC (Non-Backward Compatible)，提供MPEG-2AAC，且不能向后兼容， 多通道编码达到 48个通道。</p>
<p>MPEG- 2 profile和level</p>
<p>　　MPEG-2提供广泛的应用， 对于大部分的应用，即不现实的也过于昂贵，去支持整个标准，通常只支持子集，因此标准定义了profile和level来表示这些子集。profile定 义特性相关，例如压缩算法，色度格式等。level定义性能相关，例如最大比特率，最大帧大小等。一个应用程序应当通过profile和level来表示 他的能力。profile和level的组合构成MPEG-2视频编码标准在某种特定应用下的子集。对某一输入格式的图像，采用特定集合的压缩编码工具，产生规定速率范围内的编码码流 。 例如一台DVD播放机可以说，它支持最多的主要profile和主要level（通常写为MP@ML）。</p>
<p>　　MPEG-2主要的profile：</p>
<p>名称</p>
<p>英文</p>
<p>中文</p>
<p>图像编码类型</p>
<p>色度格式 YCbCr</p>
<p>长宽比</p>
<p>伸缩模式</p>
<p>SP</p>
<p>Simple Profile</p>
<p>简单类</p>
<p>I帧、P帧</p>
<p>4:2:0</p>
<p>4:3或16:9</p>
<p>MP</p>
<p>Main Profile</p>
<p>主类</p>
<p>I帧、P帧、B帧</p>
<p>4:2:0</p>
<p>4:3 或16:9</p>
<p>SNR</p>
<p>SNR Scalable profile</p>
<p>信噪比分层类</p>
<p>I帧、P帧、B帧</p>
<p>4:2:0</p>
<p>4:3 或16:9</p>
<p>信噪比可伸缩</p>
<p>Spatial</p>
<p>Spatially scalable profile</p>
<p>空间可分层类</p>
<p>I帧、P帧、B帧</p>
<p>4:2:0</p>
<p>4:3 或16:9</p>
<p>信噪比或空间可伸缩</p>
<p>442P</p>
<p>4:2:2 Profile</p>
<p>I帧、P帧、B帧</p>
<p>4:2:2</p>
<p>HP</p>
<p>High profile</p>
<p>高类</p>
<p>I帧、P帧、B帧</p>
<p>4:2:0或 4:2:2</p>
<p>4:3 或16:9</p>
<p>信噪比或空间可伸缩</p>
<p>　　MPEG-2主要的level：</p>
<p>名称</p>
<p>英文</p>
<p>帧频</p>
<p>最大长×最大宽</p>
<p>每秒最大亮度样本 （约为高×宽×帧频率）</p>
<p>最大比特率 （Mbit/s）</p>
<p>LL</p>
<p>Low Level</p>
<p>23.976, 24, 25, 29.97, 30</p>
<p>352×288</p>
<p>3,041,280</p>
<p>4</p>
<p>ML</p>
<p>Main Level</p>
<p>23.976, 24, 25, 29.97, 30</p>
<p>720×576</p>
<p>10,368,000，例外为：HP中4:2:0为14,475,600，4:2:2为11,059,200</p>
<p>15</p>
<p>H-14</p>
<p>High-1440 level</p>
<p>23.976, 24, 25, 29.97, 30, 50, 59.94, 60</p>
<p>1440×1152</p>
<p>47,001,600，例外为：HP中4:2:0为62,668,800</p>
<p>60</p>
<p>HL</p>
<p>High level</p>
<p>23.976, 24, 25, 29.97, 30, 50, 59.94, 60</p>
<p>1920×1152</p>
<p>62,668,800，例外为：HP中4:2:0为83,558,400</p>
<p>80</p>
<p>组合例子</p>
<p>Profile @ Level</p>
<p>Resolution (px)</p>
<p>Framerate max. (Hz)</p>
<p>Sampling</p>
<p>Bitrate (Mbit/s)</p>
<p>Example Application</p>
<p>SP@LL</p>
<p>176 × 144</p>
<p>15</p>
<p>4:2:0</p>
<p>0.096</p>
<p>Wireless handsets</p>
<p>SP@ML</p>
<p>352 × 288</p>
<p>15</p>
<p>4:2:0</p>
<p>0.384</p>
<p>PDAs</p>
<p>320 × 240</p>
<p>24</p>
<p>MP@LL</p>
<p>352 × 288</p>
<p>30</p>
<p>4:2:0</p>
<p>4</p>
<p>Set-top boxes (STB)</p>
<p>MP@ML</p>
<p>720 × 480</p>
<p>30</p>
<p>4:2:0</p>
<p>15 (DVD: 9.8)</p>
<p>DVD, SD-DVB</p>
<p>720 × 576</p>
<p>25</p>
<p>MP@H-14</p>
<p>1440 × 1080</p>
<p>30</p>
<p>4:2:0</p>
<p>60 (HDV: 25)</p>
<p>HDV</p>
<p>1280 × 720</p>
<p>30</p>
<p>MP@HL</p>
<p>1920 × 1080</p>
<p>30</p>
<p>4:2:0</p>
<p>80</p>
<p>ATSC 1080i, 720p60, HD-DVB (HDTV).</p>
<p>(Bitrate for terrestrial transmission is limited to 19.39Mbit/s)</p>
<p>1280 × 720</p>
<p>60</p>
<p>422P@LL</p>
<p>4:2:2</p>
<p>422P@ML</p>
<p>720 × 480</p>
<p>30</p>
<p>4:2:2</p>
<p>50</p>
<p>Sony IMX using I-frame only, Broadcast &quot;contribution&quot; video (I&amp;P only)</p>
<p>720 × 576</p>
<p>25</p>
<p>422P@H-14</p>
<p>1440 × 1080</p>
<p>30</p>
<p>4:2:2</p>
<p>80</p>
<p>Potential future MPEG-2-based HD products from Sony and Panasonic</p>
<p>1280 × 720</p>
<p>60</p>
<p>422P@HL</p>
<p>1920 × 1080</p>
<p>30</p>
<p>4:2:2</p>
<p>300</p>
<p>Potential future MPEG-2-based HD products from Panasonic</p>
<p>1280 × 720</p>
<p>60</p>
<p>MPEG- 2在DVD上的应用</p>
<p>DVD中采用了 MPEG-2标准并引入如下技术参数限制：</p>
<ul>
<li>分辨率<br>o 720 x 480, 704 x 480, 352 x 480, 352 x 240 像素（NTSC制式）<br>o 720 x 576, 704 x 576, 352 x 576, 352 x 288 像素（PAL制式）</li>
<li>纵横比<br>o 4:3<br>o 16:9</li>
<li>帧率（帧播放速度）<br>o 59.94 场／秒，23.976帧／秒，29.97帧／秒（NTSC）<br>o 50 场／秒，25帧／秒（PAL）</li>
<li>视频+音频 比特率<br>o 平均最大缓冲区 9.8 Mbit/s<br>o 峰值 15 Mbit/s<br>o 最小值 300 Kbit/s</li>
<li>YUV 4:2:0</li>
<li>字幕支持</li>
<li>内嵌字幕支持（NTSC only）</li>
<li>音频<br>o LPCM编码：48kHz或96kHz；16或24-bit；最多可达6声道<br>o MPEG Layer 2 (MP2)：48 kHz，可达5.1声道<br>o 杜比数字-Dolby Digital（DD，也称为AC-3）：48 kHz，32-448kbit/s，可达5.1声道<br>o 数字家庭影院系统-Digital Theater Systems (DTS)：754 kbit/s或1510 kbit/s<br>o NTSC制式DVD必须包含至少一道LPCM或Dolby Digital<br>o PAL制式DVD必须包含至少一道MPEG Layer 2、LPCM或者Dolby Digital</li>
<li>GOP结构<br>o 必须为GOP提供串行的头信息<br>o GOP最大可含帧数目：18 (NTSC) / 15 (PAL)</li>
</ul>
<p>MPEG- 2在DVB上的应用</p>
<p>DVB-MPEG相关技术参数：</p>
<ul>
<li>必须符合以下一种分辨率：<br>o 720 × 480 像素，24/1.001，24，30/1.001或30帧／秒<br>o 640 × 480 像素，24/1.001，24，30/1.001或30帧／秒<br>o 544 × 480 像素，24/1.001，24，30/1.001或30帧／秒<br>o 480 × 480 像素，24/1.001，24，30/1.001或30帧／秒<br>o 352 × 480 像素，24/1.001，24，30/1.001或30帧／秒<br>o 352 × 240 像素，24/1.001，24，30/1.001或30帧／秒<br>o 720 × 576 像素，25帧／秒<br>o 544 × 576 像素，25帧／秒<br>o 480 × 576 像素，25帧／秒<br>o 352 × 576 像素，25帧／秒<br>o 352 × 288 像素，25帧／秒</li>
</ul>
<p>MPEG- 2和NTSC</p>
<p>必须符合以下一种分辨率：<br>o 1920 × 1080 像素，最多60帧／秒（1080i）<br>o 1280 × 720 像素，最多60帧／秒（720p）<br>o 720 × 576 像素，最多50帧／秒，25帧／秒（576i，576p）<br>o 720 × 480 像素，最多60帧／秒，30帧／秒（480i，480p）<br>o 640 × 480 像素，最多60帧／秒<br>注：1080i按 1920×1088像素编码，但是最后8行在显示时抛弃。</p>
<p>对YCbCr的补充资料</p>
<p>YCbCr不是一种绝对色彩空间，是YUV压缩和偏移的版本。右图为UV色版。</p>
<p>Y（Luma，Luminance）视讯，也就是灰阶值。UV 视作表示彩度的 C（Chrominance或Chroma）。主要的采样（subsample）格式有YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1和 YCbCr 4:4:4。YUV的表示法称为 A:B:C 表示法：</p>
<ul>
<li>4:4:4 表示完全取样。</li>
<li>4:2:2 表示 2:1 的水平取样，没有垂直下采样。</li>
<li>4:2:0 表示 2:1 的水平取样，2:1 的垂直下采样。</li>
<li>4:1:1 表示 4:1 的水平取样，没有垂直下采样。</li>
</ul>
<p>最常用Y:UV记录的比重通常 1:1 或2:1，DVD-Video 是以 YUV 4:2:0 的方式记录，也就是我们俗称的I420，YUV4:2:0 并不是说只有U（即 Cb）, V（即 Cr）一定为 0，而是指U：V互相援引，时见时隐，也就是说对于每一个行，只有一个U或者V份量，如果一行是4:2:0的话，下一行就是4:0:2，再下一行是 4:2:0…以此类推。</p>
<p>以上来自wiki资料的整理。</p>
<p>编解码学习笔记（四）：Mpeg系列——Mpeg 4</p>
<p>在上次对MPEG-2的学习整理中，有一个疑惑，双声道理解，就是左右立体声，但是5.1声道是什么？我们经常看到杜比5.1声道的说法。“0.1”声道具体指什么？今天去wiki查了一下，相关内容也整理入我们的学习笔记。本文档资料来源:</p>
<p>wiki</p>
<p><a href="http://baike.baidu.com/view/190268.htm">http://baike.baidu.com/view/190268.htm</a></p>
<p><a href="http://baike.baidu.com/view/25047.htm">http://baike.baidu.com/view/25047.htm</a></p>
<p>5.1声道</p>
<p>　　使用杜比数字技术下，最标准常用的是5.1声道设置，但杜比数字容许一系列不同声道的选择。全部可供选择的声道如下列所示:</p>
<p>单声道（中央）</p>
<p>双声道立体声（左、右），选择性地交叉应用杜比环回</p>
<p>三声道立体声（左、中、右）</p>
<p>双声道立体声加单环回（左、右、环回）</p>
<p>三声道立体声加单环回（左、中、右、环回）</p>
<p>四声道环回立体声（左前、右前、左后、右后）</p>
<p>五声道环回立体声（左前、中、右前、左后、右后）</p>
<p>　　以上所有这些设置可选择性地使用低频效果和杜比数字EX矩阵编码中加入附加后环绕声道。杜比编码技术是向下兼容 的，很多杜比播放器／解码器均备有向下混音作用是发布不同声道至可供使用的扬声器。这包括一些功能例如声音数据通过前扬声器播放（如适用），和当中央扬声器不适用时发布中央频道至左或右扬声器。或当用户只有2.0喇叭时，杜比解码器能把多声道信号混音编码为 2.0立体声。</p>
<p>　　在5.1, 7.1 或其他等文字中，’.1’指的是低频LFE声道。</p>
<p>　　其实5.1声道就是使用5个喇叭和1个超低音扬声器来实现一种身临其境的音乐播放方式，它是由杜比公司开发的，所以叫做“杜比5.1声道”。在5.1声道系统里采用左(L)、中(C)、右(R)、左后(LS)、右后(RS)五个方向输出声音，使人产生犹如身临音乐厅的感觉。五个声道相互独立，其中“.1” 声道，则是一个专门设计的超低音声道。正是因为前后左右都有喇叭，所以就会产生被音乐包围的真实感。如右图所示。</p>
<p>MPEG-4</p>
<p>总体介绍</p>
<p>　　MPEG-4是一套用于音频、视频信息的压缩编码标准， 由国际标准化组织（ISO）和国际电工委员会（IEC）下属的“動態影像专家组”（Moving Picture Experts Group，即MPEG） 制定，第一版在1998年10月通過，第二版在1999年12月通過。MPEG-4格式的主要用途在於網上流媒体、光碟、語音傳送（視訊電話），以及電視廣播。MPEG-4作为ISO/IEC14496正式发布。ISO/IEC 14496-Coding of audio-visual object （AV对象编码）。</p>
<p>　　为了应对网络传输等环境，传统的 MPEG-1/2 已经不能适应，所以促使了 MPEG-4 的诞生。 与 MPEG-1和MPEG-2相比，MPEG-4的特点是其更适于交互AV服务以及远程监控。MPEG-4是第一个使你由被动变为主动(不再只是观看，允许 你加入其中，即有交互性)的动态图像标准，它的另一个特点是其综合性。从根源上说，MPEG-4试图将自然物体与人造物体相溶合 (视觉效果意义上的)。MPEG-4的设计目标还有更广的适应性和更灵活的可扩展性。 MPEG-4 采用了一系列新技术，来满足在低带宽下传输较高视频质量的需求。DivX，XviD，MS MPEG4 都是采用的MPEG-4 视频编码，除了在 DVDRip 上面的应用，3GPP现在也接纳了 MPEG-4 作为视频编码方案。</p>
<p>　　最初MPEG-4的主要目的是用于低比特率下的视频通信，但是作为一个多媒体的编码标准，它的范围最后得到了扩展。在技术方面MPEG-4允许不同的软件/硬件开发商创建多媒体对象来提供更好的适应性、灵活性，为数字电视，动态图像，互联网等业务提供更好的质量。　　</p>
<p>　　MPEG-4提供范围从每秒几k比特到每秒数十兆比特的，它具有下面功能：</p>
<p>改善MPEG-2的编码效率</p>
<p>MPEG-4基于更高的编码效率。同已有的或即将形成的其它标准相比，在相同的比特率下，它基于更高的视觉听觉质量，这就 使得在低带宽的信道上传送视频、音频成为可能。同时MPEG-4还能对同时发生的数据流进行编码。一个场景的多视角或多声道数据流可以高效、同步地合成为 最终数据流。这可用于虚拟三维游戏、三维电影、飞行仿真练习等。</p>
<p>提供混合媒体数据（视频，音频，语音）的编码能力</p>
<p>差错容忍使得内容稳定传输。</p>
<p>当在传输有误码或丢包现象时，MPEG4受到的影响很小，并且能迅速恢复。</p>
<p>提供受众视听场景的互动能力，MPEG-4终端用户提供不同的对象支持各种互动要求。</p>
<p>MPEG-4提供了基于内容的多媒体数据访问工具，如索引、超级链接、上传、下载、删除等。利用这些工具，用户可以方便地 从多媒体数据库中有选择地获取自己所需的与对象有关的内容，并提供了内容的操作和位流编辑功能，可应用于交互式家庭购物，淡入淡出的数字化效果等。 MPEG-4提供了高效的自然或合成的多媒体数据编码方法。它可以把自然场景或对象组合起来成为合成的多媒体数据。</p>
<p>MPEG-4对传输数据网是透明的，它可以兼容各种网络。</p>
<p>MPEG-4提供了易出错环境的鲁棒性，来保证其在许多无线和有线网络以及存储介质中的应用，此外，MPEG-4还支持基于内容的的可分级性，即把内容、质量、复杂性分成许多小块来满足不同用户的不同需求，支持具有不同带宽，不同存储容量的传输信道和接收端。</p>
<p>这些特点无疑会加速多媒体应用的发展，从中受益的应用领域有：因特网多媒体应用；广播电视；交互式视频游戏；实时可视通 信；交互式存储媒体应用；演播室技术及电视后期制作；采用面部动画技术的虚拟会议；多媒体邮件；移动通信条件下的多媒体应用；远程视频监控；通过ATM网 络等进行的远程数据库业务等。</p>
<p>MPEG-4视频编码核心思想</p>
<p>　　在MPEG-4制定之前，MPEG-1、MPEG-2、H.261、H.263都是采用第一代压缩编码技术，着 眼于图像信号的统计特性来设计编码器，属于波形编码的范畴。第一代压缩编码方案把视频序列按时间先后分为一系列帧，每一帧图像又分成宏块以进行运动补偿和编码，这种编码方案存在以下缺陷：</p>
<p>将图像固定地分成相同大小的块，在高压缩比的情况下会出现严重的块效应，即马赛克效应；</p>
<p>不能对图像内容进行访问、编辑和回放等操作；</p>
<p>未充分利用人类视觉系统（HVS，Human Visual System）的特性。</p>
<p>　　MPEG-4则代表了基于模型/对象的第二代压缩编码技术，它充分利用了人眼视觉特性，抓住了图像信息传输的本质，从轮廓、纹理思路出发，支持基于视觉内容的交互功能，这适应了多媒体信息的应用由播放型转向基于内容的访问、检索及操作的发展趋势。</p>
<p>　　AV对象（AVO，AudioVisual Object）是MPEG-4为支持基于内容编码而提出的重要概念。对象是指在一个场景中能够访问和操纵的实体，对象的划分可根据其独特的纹理、运动、形状、模型和高层语义为依据。在MPEG-4中所见的视音频已不再是过去MPEG-1、MPEG-2中图像帧的概念，而是一个个视听场景（AV场景），这些 不同的AV场景由不同的AV对象组成。AV对象是听觉、视觉、或者视听内容的表示单元，其基本单位是原始AV对象，它可以是自然的或合成的声音、图像。原 始AV对象具有高效编码、高效存储与传输以及可交互操作的特性，它又可进一步组成复合AV对象。因此MPEG-4标准的基本内容就是对AV对象进行高效编 码、组织、存储与传输。AV对象的提出，使多媒体通信具有高度交互及高效编码的能力，AV对象编码就是MPEG-4的核心编码技术。</p>
<p>　　MPEG-4实现基于内容交互的首要任务就是把视频/图像分割成不同对象或者把运动对象从背景中分离出来，然后针对不同对象采用相应编码方法，以实现高效压缩。因此视频对象提取即视频对象分割，是MPEG-4视频编码的关键技术，也是新一代视频编码的研究热点和难点。</p>
<p>　　MPEG-4不仅可提供高压缩率，同时也可实现更好的多媒体内容互动性及全方位的存取性，它采用开放的编码系统，可随时加入新的编码算法模块，同时也可根据不同应用需求现场配置解码器，以支持多种多媒体应用。</p>
<p>MPEG－４各部分</p>
<p>　　MPEG-4由一系列的子标准组成，被称为部，包括以下的部分。对于媒体编解码，重点关注Part2,Part 3, Part 10。</p>
<p>第一部（ISO/IEC 14496-1）：系统</p>
<p>　　描述视訊和音訊的同步以及混合方式（Multiplexing，简写为MUX）。定义了 MP4 容器格式, 支持类似 DVD 菜单这样的直观和互动特性等。</p>
<p>第二部（ISO/IEC 14496-２）：视频</p>
<p>　　定义了一个对各种视觉信息（包括视訊、静止纹理、计算机合成图形等等）的编解码器。对视訊部分来说，众多”Profiles”中很常用的一种是Advanced SimpleProfile (ASP)，例如XviD编码就 属于MPEG-4Part 2。包括 3ivx, DivX4/Project Mayo, DivX 5, Envivio,ffmpeg/ffds, mpegable, Nero Digital, QuickTime, Sorenson, XviD 等常见的视频格式, 需要注意的是 Divx 3.11, MS MPEG-4, RV9/10, VP6,WMV9 并不属于标准的 MPEG-4 标准。</p>
<p>第三部（ISO/IEC 14496-３）：音频</p>
<p>　　定义了一个对各种音訊信号进行编码的编解码器的集合。包括高级音訊编码（Advanced Audio Coding，缩写为AAC） 的若干变形和其他一些音频／语音编码工具。即 AAC 音频标准, 包括 LCAAC, HE AAC 等, 支持 5.1 声道编码, 可以用更低的码率实现更好的效果 (相对于 MP3, OGG 等) 。</p>
<p>第四部（ISO/IEC 14496-4）：一致性</p>
<p>　　定义了对本标准其他的部分进行一致性测试的程序。</p>
<p>第五部（ISO/IEC 14496-5）：参考软件</p>
<p>　　提供了用于演示功能和说明本标准其他部分功能的软件。</p>
<p>第六部（ISO/IEC 14496-6）：多媒体传输集成框架</p>
<p>　　即DMIF：Delivery Multimedia IntegrationFramework</p>
<p>第七部（ISO/IEC 14496-7）：优化的参考软件</p>
<p>　　提供了对实现进行优化的例子（这裡的实现指的是第五部分）。</p>
<p>第八部（ISO/IEC 14496-8）：在IP网络上传输</p>
<p>　　定义了在IP网络上传输MPEG-4内容的方式。</p>
<p>第九部（ISO/IEC 14496-9）：参考硬件</p>
<p>　　提供了用于演示怎样在硬件上实现本标准其他部分功能的硬件设计方案。</p>
<p>第十部（ISO/IEC 14496-10）：进阶视频编码，也即ITU H.264，常写为H.264／AVC</p>
<p>　　或称高级视频编码（Advanced Video Coding，缩写为AVC）：定义了一个视频编解码器（codec），AVC和XviD都属于MPEG-4编码，但由于AVC属于MPEG-4Part 10，在技术特性上比属于MPEG-4 Part2的XviD要先进。另外从技术上讲，它和ITU-T H.264标准是一致的，故全称为MPEG-4 AVC/H.264。</p>
<p>第十一部（ISO/IEC 14496-11）：场景描述和应用引擎</p>
<p>　　可用于多种profile（包括2D和3D版本）的互交互媒体。修订了MPEG-4 Part 1:2001以及Part1的两个修订方案。它定义了应用引擎（交付，生命周期，格式，可下载Java字节代码应用程序的行为），二进制场景格式 （BIFS：Binary Format for Scene），可扩展MPEG-4文本格式（一种使用XML描述MPEG-4多媒体内容的文本格式）系统level表述。也就是MPEG-4 Part21中的BIFS，XMT，MPEG-J。</p>
<p>第十二部（ISO/IEC 14496-12）：基于ISO的媒体文件格式</p>
<p>　　定义了一个存储媒体内容的文件格式。</p>
<p>第十三部（ISO/IEC 14496-13）：IP</p>
<p>　　知识产权管理和保护（IPMP for Intellectual Property Management and Protection）拓展。</p>
<p>第十四部（ISO/IEC 14496-14）：MPEG-4文件格式</p>
<p>　　定义了基于第十二部分的用于存储MPEG-4内容的視訊檔案格式。</p>
<p>第十五部（ISO/IEC 14496-15）：AVC文件格式</p>
<p>　　定义了基于第十二部分的用于存储第十部分的视频内容的文件格式。</p>
<p>第十六部（ISO/IEC 14496-16）：动画框架扩展</p>
<p>　　动画框架扩展（AFX : Animation Framework eXtension）。</p>
<p>第十七部（ISO/IEC 14496-17）：同步文本字幕格式</p>
<p>　　尚未完成－2005年1月达成”最终委员会草案”，FCD: Final Committee Draft。</p>
<p>第十八部（ISO/IEC 14496-18）：字体压缩和流式传输（针对公开字体格式）。</p>
<p>第十九部（ISO/IEC 14496-19）：综合用材质流（Synthesized TextureStream）。</p>
<p>第二十部（ISO/IEC 14496-20）：简单场景表示</p>
<p>　　LASeR for Lightweight Scene Representation，尚未完成－2005年1月达成”最终委员会草案”，FCD for Final Committee Draft。</p>
<p>第二十一部（ISO/IEC 14496-21）：用于描绘（Rendering）的MPEG-J拓展</p>
<p>　　尚未完成－2005年1月达成“委员会草案”，CD for Committee Draft）。</p>
<p>Profile和Level</p>
<p>　　MPEG-4提供大量的编码方式和丰富的设置。 和MPEG-2一样，应用一般不可能支持MPEG-4全集，通过profile和level来描述子集。这些子集，通过 “profile”来表明解码器要求，为了避免计算的复杂，每个profile都有一个或者多个“level”。profile和level的有效组合使得编码生成器只需实现标准中所需的子集，同时保持与其他MPEG-4设备的互通。（解码支持范围通常比编码支持范围大），检查其他MPEG-4设备是否符 合标准，即一致性测试。</p>
<p>　　对于H.264/AVC（也就是MPEG-4 Part 4）提供下面的profile：</p>
<p>Feature support in particular profiles</p>
<p>Feature</p>
<p>CBP</p>
<p>BP</p>
<p>XP</p>
<p>MP</p>
<p>HiP</p>
<p>Hi10P</p>
<p>Hi422P</p>
<p>Hi444PP</p>
<p>B slices</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>SI and SP slices</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Flexible macroblock ordering (FMO)</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Arbitrary slice ordering (ASO)</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Redundant slices (RS)</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Data partitioning</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Interlaced coding (PicAFF, MBAFF)</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>CABAC entropy coding</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>8×8 vs. 4×4 transform adaptivity</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Quantization scaling matrices</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Separate Cb and Cr QP control</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Monochrome (4:0:0)</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Chroma formats</p>
<p>4:2:0</p>
<p>4:2:0</p>
<p>4:2:0</p>
<p>4:2:0</p>
<p>4:2:0</p>
<p>4:2:0</p>
<p>4:2:0/4:2:2</p>
<p>4:2:0/4:2:2/4:4:4</p>
<p>Sample depths (bits)</p>
<p>8</p>
<p>8</p>
<p>8</p>
<p>8</p>
<p>8</p>
<p>8 to 10</p>
<p>8 to 10</p>
<p>8 to 14</p>
<p>Separate color plane coding</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>Predictive lossless coding</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>　　level用来表明一个profile的解码器的性能要求的范围，例如最大图片分配了，帧频，比特率等等。对于解码器，一个指定的level要求可以对该level以及低于该level的码流进行解码。（A decoder that conforms to agiven level is required to be capable of decoding all bitstreams that areencoded for that level and for all lower levels. 来源：<a href="http://en.wikipedia.org/wiki/H.264/MPEG-4_AVC%EF%BC%89">http://en.wikipedia.org/wiki/H.264/MPEG-4_AVC）</a></p>
<p>Levels with maximum property values</p>
<p>Level</p>
<p>Max macroblocks</p>
<p>Max video bit rate (VCL)</p>
<p>Examples for high resolution @ <br>frame rate <br>(max stored frames)</p>
<p>per second</p>
<p>per frame</p>
<p>BP, XP, MP <br>(kbit/s)</p>
<p>HiP <br>(kbit/s)</p>
<p>Hi10P <br>(kbit/s)</p>
<p>Hi422P, Hi444PP <br>(kbit/s)</p>
<p>1</p>
<p>1,485</p>
<p>99</p>
<p>64</p>
<p>80</p>
<p>192</p>
<p>256</p>
<p>128×<a href="mailto:&#57;&#54;&#64;&#x33;&#x30;&#x2e;&#57;">&#57;&#54;&#64;&#x33;&#x30;&#x2e;&#57;</a> (8) <br>176×<a href="mailto:&#x31;&#52;&#52;&#64;&#49;&#53;&#x2e;&#x30;">&#x31;&#52;&#52;&#64;&#49;&#53;&#x2e;&#x30;</a> (4)</p>
<p>1b</p>
<p>1,485</p>
<p>99</p>
<p>128</p>
<p>160</p>
<p>384</p>
<p>512</p>
<p>128×<a href="mailto:&#x39;&#54;&#x40;&#x33;&#x30;&#x2e;&#x39;">&#x39;&#54;&#x40;&#x33;&#x30;&#x2e;&#x39;</a> (8) <br>176×<a href="mailto:&#49;&#52;&#x34;&#x40;&#x31;&#53;&#46;&#48;">&#49;&#52;&#x34;&#x40;&#x31;&#53;&#46;&#48;</a> (4)</p>
<p>1.1</p>
<p>3,000</p>
<p>396</p>
<p>192</p>
<p>240</p>
<p>576</p>
<p>768</p>
<p>176×<a href="mailto:&#x31;&#x34;&#x34;&#x40;&#51;&#x30;&#x2e;&#x33;">&#x31;&#x34;&#x34;&#x40;&#51;&#x30;&#x2e;&#x33;</a> (9) <br>320×<a href="mailto:&#x32;&#x34;&#48;&#x40;&#49;&#48;&#x2e;&#48;">&#x32;&#x34;&#48;&#x40;&#49;&#48;&#x2e;&#48;</a> (3) <br>352×<a href="mailto:&#x32;&#56;&#56;&#x40;&#55;&#46;&#53;">&#x32;&#56;&#56;&#x40;&#55;&#46;&#53;</a> (2)</p>
<p>1.2</p>
<p>6,000</p>
<p>396</p>
<p>384</p>
<p>480</p>
<p>1,152</p>
<p>1,536</p>
<p>320×<a href="mailto:&#50;&#x34;&#x30;&#64;&#50;&#x30;&#46;&#48;">&#50;&#x34;&#x30;&#64;&#50;&#x30;&#46;&#48;</a> (7) <br>352×<a href="mailto:&#x32;&#x38;&#x38;&#x40;&#x31;&#x35;&#46;&#x32;">&#x32;&#x38;&#x38;&#x40;&#x31;&#x35;&#46;&#x32;</a> (6)</p>
<p>1.3</p>
<p>11,880</p>
<p>396</p>
<p>768</p>
<p>960</p>
<p>2,304</p>
<p>3,072</p>
<p>320×<a href="mailto:&#50;&#52;&#x30;&#64;&#x33;&#54;&#46;&#48;">&#50;&#52;&#x30;&#64;&#x33;&#54;&#46;&#48;</a> (7) <br>352×<a href="mailto:&#50;&#x38;&#x38;&#64;&#51;&#x30;&#46;&#48;">&#50;&#x38;&#x38;&#64;&#51;&#x30;&#46;&#48;</a> (6)</p>
<p>2</p>
<p>11,880</p>
<p>396</p>
<p>2,000</p>
<p>2,500</p>
<p>6,000</p>
<p>8,000</p>
<p>320×<a href="mailto:&#x32;&#52;&#48;&#x40;&#x33;&#x36;&#46;&#x30;">&#x32;&#52;&#48;&#x40;&#x33;&#x36;&#46;&#x30;</a> (7) <br>352×<a href="mailto:&#x32;&#x38;&#56;&#x40;&#51;&#x30;&#46;&#48;">&#x32;&#x38;&#56;&#x40;&#51;&#x30;&#46;&#48;</a> (6)</p>
<p>2.1</p>
<p>19,800</p>
<p>792</p>
<p>4,000</p>
<p>5,000</p>
<p>12,000</p>
<p>16,000</p>
<p>352×<a href="mailto:&#52;&#56;&#x30;&#x40;&#51;&#48;&#46;&#48;">&#52;&#56;&#x30;&#x40;&#51;&#48;&#46;&#48;</a> (7) <br>352×<a href="mailto:&#x35;&#55;&#54;&#x40;&#50;&#x35;&#x2e;&#x30;">&#x35;&#55;&#54;&#x40;&#50;&#x35;&#x2e;&#x30;</a> (6)</p>
<p>2.2</p>
<p>20,250</p>
<p>1,620</p>
<p>4,000</p>
<p>5,000</p>
<p>12,000</p>
<p>16,000</p>
<p>352×<a href="mailto:&#52;&#x38;&#48;&#64;&#x33;&#48;&#x2e;&#x37;">&#52;&#x38;&#48;&#64;&#x33;&#48;&#x2e;&#x37;</a>(10) <br>352×<a href="mailto:&#53;&#55;&#x36;&#64;&#50;&#53;&#46;&#x36;">&#53;&#55;&#x36;&#64;&#50;&#53;&#46;&#x36;</a> (7) <br>720×<a href="mailto:&#52;&#56;&#x30;&#x40;&#49;&#x35;&#46;&#x30;">&#52;&#56;&#x30;&#x40;&#49;&#x35;&#46;&#x30;</a> (6) <br>720×<a href="mailto:&#x35;&#x37;&#54;&#x40;&#49;&#x32;&#x2e;&#x35;">&#x35;&#x37;&#54;&#x40;&#49;&#x32;&#x2e;&#x35;</a> (5)</p>
<p>3</p>
<p>40,500</p>
<p>1,620</p>
<p>10,000</p>
<p>12,500</p>
<p>30,000</p>
<p>40,000</p>
<p>352×<a href="mailto:&#x34;&#56;&#48;&#x40;&#x36;&#x31;&#46;&#x34;">&#x34;&#56;&#48;&#x40;&#x36;&#x31;&#46;&#x34;</a> (12) <br>352×<a href="mailto:&#x35;&#55;&#54;&#x40;&#x35;&#49;&#x2e;&#49;">&#x35;&#55;&#54;&#x40;&#x35;&#49;&#x2e;&#49;</a> (10) <br>720×<a href="mailto:&#52;&#56;&#48;&#64;&#51;&#x30;&#x2e;&#48;">&#52;&#56;&#48;&#64;&#51;&#x30;&#x2e;&#48;</a> (6) <br>720×<a href="mailto:&#x35;&#55;&#x36;&#x40;&#x32;&#53;&#x2e;&#48;">&#x35;&#55;&#x36;&#x40;&#x32;&#53;&#x2e;&#48;</a> (5)</p>
<p>3.1</p>
<p>108,000</p>
<p>3,600</p>
<p>14,000</p>
<p>17,500</p>
<p>42,000</p>
<p>56,000</p>
<p>720×<a href="mailto:&#52;&#56;&#x30;&#x40;&#56;&#48;&#46;&#x30;">&#52;&#56;&#x30;&#x40;&#56;&#48;&#46;&#x30;</a> (13) <br>720×<a href="mailto:&#53;&#x37;&#54;&#x40;&#54;&#54;&#x2e;&#55;">&#53;&#x37;&#54;&#x40;&#54;&#54;&#x2e;&#55;</a> (11) <br>1280×<a href="mailto:&#x37;&#50;&#x30;&#64;&#51;&#x30;&#x2e;&#48;">&#x37;&#50;&#x30;&#64;&#51;&#x30;&#x2e;&#48;</a> (5)</p>
<p>3.2</p>
<p>216,000</p>
<p>5,120</p>
<p>20,000</p>
<p>25,000</p>
<p>60,000</p>
<p>80,000</p>
<p>1,280×<a href="mailto:&#x37;&#x32;&#48;&#64;&#x36;&#48;&#46;&#x30;">&#x37;&#x32;&#48;&#64;&#x36;&#48;&#46;&#x30;</a> (5) <br>1,280×1,<a href="mailto:&#48;&#50;&#x34;&#x40;&#52;&#50;&#46;&#x32;">&#48;&#50;&#x34;&#x40;&#52;&#50;&#46;&#x32;</a> (4)</p>
<p>4</p>
<p>245,760</p>
<p>8,192</p>
<p>20,000</p>
<p>25,000</p>
<p>60,000</p>
<p>80,000</p>
<p>1,280×<a href="mailto:&#x37;&#x32;&#x30;&#x40;&#54;&#56;&#46;&#x33;">&#x37;&#x32;&#x30;&#x40;&#54;&#56;&#46;&#x33;</a> (9) <br>1,920×1,<a href="mailto:&#48;&#x38;&#48;&#64;&#x33;&#x30;&#x2e;&#49;">&#48;&#x38;&#48;&#64;&#x33;&#x30;&#x2e;&#49;</a> (4) <br>2,048×1,<a href="mailto:&#x30;&#x32;&#52;&#64;&#x33;&#x30;&#x2e;&#x30;">&#x30;&#x32;&#52;&#64;&#x33;&#x30;&#x2e;&#x30;</a> (4)</p>
<p>4.1</p>
<p>245,760</p>
<p>8,192</p>
<p>50,000</p>
<p>62,500</p>
<p>150,000</p>
<p>200,000</p>
<p>1,280×<a href="mailto:&#x37;&#x32;&#48;&#x40;&#x36;&#x38;&#46;&#51;">&#x37;&#x32;&#48;&#x40;&#x36;&#x38;&#46;&#51;</a> (9) <br>1,920×1,<a href="mailto:&#48;&#x38;&#x30;&#x40;&#x33;&#48;&#46;&#49;">&#48;&#x38;&#x30;&#x40;&#x33;&#48;&#46;&#49;</a> (4) <br>2,048×1,<a href="mailto:&#48;&#x32;&#x34;&#64;&#51;&#x30;&#x2e;&#48;">&#48;&#x32;&#x34;&#64;&#51;&#x30;&#x2e;&#48;</a> (4)</p>
<p>4.2</p>
<p>522,240</p>
<p>8,704</p>
<p>50,000</p>
<p>62,500</p>
<p>150,000</p>
<p>200,000</p>
<p>1,920×1,<a href="mailto:&#x30;&#x38;&#48;&#64;&#54;&#x34;&#x2e;&#48;">&#x30;&#x38;&#48;&#64;&#54;&#x34;&#x2e;&#48;</a> (4) <br>2,048×1,<a href="mailto:&#48;&#56;&#48;&#64;&#54;&#x30;&#46;&#x30;">&#48;&#56;&#48;&#64;&#54;&#x30;&#46;&#x30;</a> (4)</p>
<p>5</p>
<p>589,824</p>
<p>22,080</p>
<p>135,000</p>
<p>168,750</p>
<p>405,000</p>
<p>540,000</p>
<p>1,920×1,<a href="mailto:&#x30;&#56;&#x30;&#64;&#55;&#50;&#x2e;&#x33;">&#x30;&#56;&#x30;&#64;&#55;&#50;&#x2e;&#x33;</a> (13) <br>2,048×1,<a href="mailto:&#x30;&#50;&#52;&#x40;&#55;&#50;&#x2e;&#x30;">&#x30;&#50;&#52;&#x40;&#55;&#50;&#x2e;&#x30;</a> (13) <br>2,048×1,<a href="mailto:&#x30;&#x38;&#x30;&#64;&#x36;&#55;&#46;&#x38;">&#x30;&#x38;&#x30;&#64;&#x36;&#55;&#46;&#x38;</a> (12) <br>2,560×1,<a href="mailto:&#x39;&#x32;&#48;&#x40;&#51;&#48;&#x2e;&#55;">&#x39;&#x32;&#48;&#x40;&#51;&#48;&#x2e;&#55;</a> (5) <br>3,680×1,<a href="mailto:&#53;&#51;&#54;&#x40;&#x32;&#54;&#46;&#55;">&#53;&#51;&#54;&#x40;&#x32;&#54;&#46;&#55;</a> (5)</p>
<p>5.1</p>
<p>983,040</p>
<p>36,864</p>
<p>240,000</p>
<p>300,000</p>
<p>720,000</p>
<p>960,000</p>
<p>1,920×1,<a href="mailto:&#x30;&#56;&#x30;&#x40;&#49;&#50;&#48;&#46;&#x35;">&#x30;&#56;&#x30;&#x40;&#49;&#50;&#48;&#46;&#x35;</a> (16) <br>4,096×2,<a href="mailto:&#x30;&#52;&#56;&#64;&#51;&#x30;&#46;&#x30;">&#x30;&#52;&#56;&#64;&#51;&#x30;&#46;&#x30;</a> (5) <br>4,096×2,<a href="mailto:&#x33;&#48;&#52;&#x40;&#x32;&#54;&#46;&#55;">&#x33;&#48;&#52;&#x40;&#x32;&#54;&#46;&#55;</a> (5)</p>
<p>编解码学习笔记（五）：Mpeg系列——AAC音频</p>
<p>　下面资料来自wiki。AAC在MPEG2和MPEG4中定义。</p>
<p>扩展名：.m4a, .m4b, .m4p, .m4v, .m4r, .3gp, .mp4, .aac <br>互联网媒体类型：audio/aac, audio/aacp, audio/3gpp, audio/3gpp2,audio/mp4, audio/MP4A-LATM, audio/mpeg4-generic<br>格式：有损数据压缩 <br>延伸自：MPEG-2 音频 <br>标准：ISO/IEC 13818-7（MPEG-2第7部）, ISO/IEC 14496-3（MPEG-4第3部）</p>
<p>　　AAC（Advanced Audio Coding），中文称为“高级音频编码”，出现于1997年，基于 MPEG-2的音频编码技术。由Fraunhofer IIS、杜比实验室、AT&amp;T、Sony（索尼）等公司共同开发，目的是取代MP3格式。2000年，MPEG-4标准出现后，AAC 重新集成了其特性，加入了SBR技术和PS技术，为了区别于传统的 MPEG-2 AAC 又称为 MPEG-4 AAC。</p>
<p>AAC格式的主要扩展名有三种：</p>
<p>AAC - 使用MPEG-2 Audio Transport Stream( ADTS，参见MPEG-2 )容器，区别于使用MPEG-4容器的MP4/M4A格式，属于传统的AAC编码（FAAC默认的封装，但FAAC亦可输出 MPEG-4 封装的AAC）</p>
<p>MP4 - 使用了MPEG-4 Part 14（第14部分）的简化版即3GPP Media Release 6 Basic (3gp6，参见3GP ) 进行封装的AAC编码（Nero AAC 编码器仅能输出MPEG-4封装的AAC）；</p>
<p>M4A - 为了区别纯音频MP4文件和包含视频的MP4文件而由苹果(Apple)公司使用的扩展名，Apple iTunes 对纯音频MP4文件采用了&quot;.M4A&quot;命名。M4A的本质和音频MP4相同，故音频MP4文件亦可直接更改扩展名为M4A。</p>
<p>　　作为一种高压缩比的音频压缩算法，AAC压缩比通常为18：1，也有资料说为20：1，远胜mp3； 在音质方面，由于采用多声道，和使用低复杂性的描述方式，使其比几乎所有的传统编码方式在同规格的情况下更胜一筹。不过直到2006年， 使用这一格式储存音乐的并不多，可以播放该格式的mp3播放器更是少之又少，目前所知仅有苹果iPod、Sony Walkman（NWZ-A、NWZ-S、NWZ-E、NWZ-X系列）、任天堂NDSi。魅 族M8，此外计算机上很多音乐播放软体都支持AAC（前提是安装过AAC解码器），如苹果iTunes。但在移动电话领域，AAC的支持度已很普 遍，Nokia、Sony Ericsson、Motorola等品牌均在其中高端产品中支持 AAC（一开始主要是LC-AAC，随着移动电话性能的发展，HE-AAC的支持也已广泛）。</p>
<p>　　AAC可以支持多达48个音轨，15个低频（LFE）音轨，5.1多声道支持，更高的采样率（最高可达 96kHz，音频CD为44.1kHz）和更高的采样精度（支持8bit、16bit、24bit、32bit，音频CD为 16bit）以及有多种语言的兼容能力，更高的解码效率，一般来说，AAC可以在对比MP3文件缩小30%的前题下提供更好的音质。</p>
<p>相对于传统的LC-AAC，High Efficiency AAC（HE-AAC或写为 AAC-HE）又称为 &quot;aacPlus v1&quot; 或 &quot;AAC+&quot; - 结合了 SBR (Spectral Band Replication) and AAC技术；适用于低比特率（64kbps以下）；</p>
<p>HE-AAC v2，又称为 &quot;aacPlus v2&quot; - 结合了 Parametric Stereo(参数化立体 声，PS)和 HE-AAC 中的SBR技术。</p>
<p>　　因为&quot;AAC&quot;是一个大家族，他们共分为 9 种规格，以适应不同场合的需要，也正是由于 AAC 的规格（Profile）繁多，导致普通电脑用户感觉十分困扰：</p>
<p>MPEG-2 AAC LC 低复杂度规格（Low Complexity）</p>
<p>MPEG-2 AAC Main 主规格</p>
<p>MPEG-2 AAC SSR 可变采样率规格（Scaleable Sample Rate）</p>
<p>MPEG-4 AAC LC 低复杂度规格（Low Complexity），现在的手机比较常见的 MP4 文件中的音频部份就包括了该规格音频文件</p>
<p>MPEG-4 AAC Main 主规格</p>
<p>MPEG-4 AAC SSR 可变采样率规格（Scaleable Sample Rate）</p>
<p>MPEG-4 AAC LTP 长时期预测规格（Long Term Predicition）</p>
<p>MPEG-4 AAC LD 低延迟规格（Low Delay）</p>
<p>MPEG-4 AAC HE 高效率规格（High Efficiency）</p>
<p>　　上述的规格中，主规格（Main）包含了除增益控制之外的全部功能，其音质最好，而低复杂度规格（LC）则是比较简单，没有了增益控制，但提高了 编码效率，至‘SSR’对‘LC’规格大体是相同，但是多了增益的控制功能，另外，MPEG-4 AAC/LTP/LD/HE，都是用在低比特率下编码，特别是‘HE’是有 Nero ACC 编码器支持，是近来常用的一种编码器，不过通常来说，Main 规格和 LC 规格的音质相差不大，因此目前使用最多的 AAC 规格多数是‘LC’规格，因为要考虑手机目前的存储器能力未达合理水准。</p>
<p>编解码学习笔记（六）：H.26x系列</p>
<p>部分资料来源与wiki以及<a href="http://www.365pr.net/tech_view.asp?id=315%E3%80%82">http://www.365pr.net/tech_view.asp?id=315。</a></p>
<p>H.26x有H.261,H.262，H.263, H.263v2以及H.264，H.261基本上已经不再使用。其中H.262和H.264已经在MPEG系列中介绍，他们分别对应MPEG2的第2部和MPEG-4的第10部。不在整理这方面的资料。</p>
<p>H.261</p>
<p>H.261其速率为64kbps的整数倍（1～30倍）。它最初是 针对在ISDN(综合业务数字网,Integrated Services Digital Network)上双向声像业务(特别是可视电话、视频会议)而设计的。</p>
<p>H.261是最早的运动图像压缩标准，它只对CIF和QCIF两 种图像格式进行处理，每帧图像分成图像层、宏块组(GOB)层、宏块(MB)层、块(Block)层来处理；并详细制定了视频编码的各个部分，包括运动补偿的帧间预测、DCT(离散余弦变换)、量化、熵编码，以及与固定速率的信道相适配的速率控制等部分。实际的编码算法类似于MPEG算法，但不能与后者兼 容。H.261在实时编码时比MPEG所占用的CPU运算量少得多，此算法为了优化带宽占用量，引进了在图像质量与运动幅度之间的平衡折衷机制。也就是说，剧烈运动的图像比相对静止的图像质量要差。因此这种方法是属于恒定码流可变质量编码。</p>
<p>H.261是第一个实用的数字视频编码标准。H.261的设计相当成功，之后的视频编码国际标准基本上都是基于 H.261相同的设计框架，包括 MPEG-1，MPEG-2／H.262，H.263，甚至 H.264。同样，H.261开发委员会（由Sakae Okubo领导，他的日文姓名是大久保荣）的基本的运作方式也被之后的视频编码标准开发组织所继承。H.261使用了混合编码框架，包括了基于运动补偿的 帧间预测，基于离散余弦变换的空域变换编码，量化，zig-zag扫描和熵编码。</p>
<p>实际上H.261标准仅仅规定了如何进行视频的解码（后继的各个视频编码标准也继承了这种做法）。这样的话，实际上开发者在编码器的设计上拥有相当的自由来设计编码算法，只要他们的编码器产生的码流能够被所有按照H.261规范制造的解码器解码就可以了。编码器可以按照自己的需要对输入的视频进行任何预处理，解码器也有自由对输出的视频在显示之前进行任何后处理。去块效应滤波器是一个有效的后处理技术，它能明显的减轻因为使用分块运动补偿编码造成的 块效应（马赛克）–在观看低码率视频（例如网站上的视频新闻）的时候我们都会注意到这种讨厌的效应。因此，在之后的视频编码标准如H.264中就把去块 效应滤波器加为标准的一部分（即使在使用H.264 的时候，再完成解码后再增加一个标准外的去块效应滤波器也能提高主观视频质量）。</p>
<p>后来的视频编码标准都可以说是在H.261的基础上进行逐步改进，引入新功能得到的。现在的视频编码标准比起H.261 来在各性能方面都有了很大的提高，这使得H.261成为了过时的标准，除了在一些视频会议系统和网络视频中为了向后兼容还支持H.261，已经基本上看不到使用H.261的产品了。 但是这并不妨碍H.261成为视频编码领域一个重要的里程碑式的标准。</p>
<p>H.263</p>
<p>H.263最初设计为基于H.324的系统进行传输 （即基于公共交换电话网和其它基于电路交换的网络进行视频会议和视频电话）。后来发现H.263也可以成功的应用与H.323（基于RTP／IP网络的视 频会议系统），H.320（基于综合业务数字网的视频会议系统），RTSP（流式媒体传输系统）和SIP（基于因特网的视频会议）。</p>
<p>基于之前的视频编码国际标准（H.261，MPEG-1和H.262／MPEG-2），H.263的性能有了革命性的提高。它的第一版于1995年 完 成，在所有码率下都优于之前的H.261。 之后还有在1998 年增加了新的功能的第二版H.263+，或者叫H.263v2，以及在2000年完 成的第三版H.263++，即H.263v3。</p>
<p>H.263v2（通常也叫做H.263+或者1998年版H.263）是ITU-TH.263 视频编 码标准第二版的非正式名称。 它保持了原先版本H.263的所有技术，但是通过增加了几个附录显著的提高了编码效率并提供了其它的一些能力，例如增强了抵抗传输信道的数据丢失的能力（Robustness）。H.263+ 项目于1997年底／1998年初完成（这取决于我们怎么定义&quot;完成&quot;）。</p>
<p>H.263v3：接下来一个被称为&quot;H.263++&quot; 的项目被随即推出，在H.263+的基础上增加了更多的新的功能。H.263++于2000年底完成。增加了下面的附录：</p>
<p>Annex A - Inverse transform accuracy specification</p>
<p>Annex B - Hypothetical Reference Decoder</p>
<p>Annex C - Considerations for Multipoint</p>
<p>Annex D - Unrestricted Motion Vector mode</p>
<p>Annex E - Syntax-based Arithmetic Coding mode</p>
<p>Annex F - Advanced Prediction mode</p>
<p>Annex G - PB-frames mode</p>
<p>Annex H - Forward Error Correction for coded video signal</p>
<p>在H.263之后，ITU-T（在与MPEG的合作下）的下一代视频编解码器是H.264，或者叫AVC以及MPEG- 4第 10部分。由于H.264在性能上超越了H.263很多，现在通常认为H.263是一个过时的标准（虽然它的开发完成并不是很久以前的事情）。大多数新的 视频会议产品都已经支持了H.264视频编解码器，就像以前支持H.263和H.261一样。</p>
<p>话虽然如此，H.263在3GPP中仍然占有很高的地位，后继修订的版本，包括运营商的标准一直保留着H.263， 作为必选的要求，地位远远高于H.264，这是个奇怪的现象。一个重要的可能原因是H.263的编码比H.264的要轻载，在手机的modem中提供 H.263的编解码能力，不提供H.264的编解码能力，或者只提供H.264的解码能力不提供编码能力，如果不是智能手机不能在主板的其他芯片（例如 CPU）提供H.264的编解码能力，开发者就没什么办法，H.263可以通过软件来提供，H.264对处理能力的要求很高，目前需要依赖硬件能力提供。因此H.263仍然具有很大的市场，尤其对于小尺寸的手持设备，屏幕分辨率有限，高清无意义。</p>
<p>H.264</p>
<p>H.264等同于MPEG-4的第10部，在这里仍然收集资料进行学习记录。</p>
<p>在H.263之后，ITU-T（在与MPEG的合作下）的下一代视 频编解码器是H.264，或者叫AVC以 及MPEG-4第 10部分。由于H.264在性能上超越了H.263很多，现在通常认为H.263是一个过时的标准（虽然它的开发完成并不是很久以前的事情）。大多数新的 视频会议产品都已经支持了H.264视频编解码器，就像以前支持H.263和H.261一样。</p>
<p>H.264／AVC可工作于多种速率，广泛应用于Internet／intranet上的多媒体流服务、视频点播、可视游戏、低码率移动多媒体通信 (视频 手机等)、交互式多媒体应用、实时多媒体监控、数字电视与演播电视和虚拟视频会议等，大有在上述领域一统天下的趋势，有非常广泛的开发和应用前景。</p>
<p>H.264是一种视频高压缩技术，同时称为MPEG-4 AVC，或MPEG-4 Part10。ITU-T从1998年就H.26L的H.26S两个分组，H.26L研制节目时间较长的高压缩编码技术，H.26S则指短节目标准制订部 门。前面的H.263就是H.26S标准化技术，而H.264标准是在H.26L基础上发展而来的。为了不引起误解，ITU-T推荐使用H.264作为这 一标准的正式名称。H.264集中体现了当今国际视频编码解码技术的最新成果。在相同的重建图像质量下，H.264比其他视频压缩编码具有更高的压缩比、 更好的IP和无线网络信道适应性。</p>
<p>首先，H.264具备超高压缩率，其压缩率为MPEG-2的2 倍，MPEG-4的1.5倍。这样的高压缩率是以编码的大运算量来换取的，H.264的编码处理计算量有MPEG-2的十多倍。不过其解码的运算量并没有上升很多。从CPU频率和内存的高速发展的角度来看，1995年推出MPEG-2时，主流的CPU是奔腾100，内存更是小的可怜。而如今主流CPU的工 作频率比那个时候快了30倍，内存扩大了50多倍。所以H.264编码的大运算现在也不算什么大问题了。</p>
<p>高压缩率使图像的数据量减少，给存储和传输带来了方便。加上基本规格公开的国际标准和公正的许可制度，所以，电视广播、家电和通信三大行业都进入到 H.264的实际运用研发中心。美国高等电视系统会议和日本无线电工业和事务协会都准备把H.264作为地面便携式数字电视广播的编码方式。欧洲数字电视广播标准化团体也正在将H.264作为数字电视的一种编码方式来采用。</p>
<p>家电行业中的视频存储设备厂商也看中了H.264。东芝和NEC推出的下一代采用蓝色激光的光碟HD DVD-ROM，因为容量小于Sony等九大公司的蓝光碟，故将视频压缩编码改用H.264，从而使最终的节目录制时长能与蓝光碟相近。H.264也能使 HDTV节目录像和 SDTV的长时间录像成为可能。因而，生产LSI芯片的厂商也十分重视H.264。D9型DVD碟只有8.5GB，不足以存放2小时的HDTV节目，如用 H.264来压缩就变得有可能。同时，在通讯领域，互联网工程任务已开始将H.264作为实时传输协议流的格式进行标准化。互联网和手机的视频传送也会有 H.264作为编码方式。</p>
<p>相对于MPEG压缩编码H.264的变化之一是在帧内编码I画面中，又加入了帧内预测编码技术，即解码时可用周围数据的差分值来重构画面。在运动预 测块中，H.264采用全面运动预测和I画面帧内预测后，编码量得到减少，但LSI的运算处理量增大。为此，H.264引入了DCT的简化处理技术，来减 轻LSI的负担，画质也有所改善。H.264与MPEG-2和MPEG-4的不同还存在于熵编码块中，H.264的熵编码CAVLC（内容自适应可变长度 码）和CABAC（内容自适应二进制算法编码）能提高纠错能力。而MPEG-2和MPEG-4是霍夫曼编码。另外，还加入了解锁滤波器 （Deblocking Filter），有降低噪声的效果。H.264的整数变换以4×4像素块为单位，已比原来的8×8像素块的块噪声少，再次降低，画质得到了进一步提高。</p>
<p>H.264标准分为三档：基本档次；主要档次（可用于SDTV、HDTV和DVD等）；以及扩展档次（用于网络的视频流）。其中H.264的基本档 次是免费，用户可以无偿使用，现得到美国苹果公司和美国Cisco系统公司、中国联想公司、诺基亚、美国On2技术公司、德国西门子、TI公司等的支持； 其许可体系要比MPEG-4单纯，公正无差别对待用户和专利持有者。H.264替代MPEG-4的呼声很高，除了其高性能外，低额专利费和公正的无差别许 可制度也至关重要。由于技术的日益成熟，半导体厂商已在进行H.264的编码/解码LSI的开发。特别是HDD录像机和DVD录像机等设备中，采用 H.264的实例已很多，更引起了半导体厂商的关心。加之，H.264采用的动画编码方式和音频编码方式具有多样化特性，今后几乎将会是全部厂商的主要规格之一。</p>
<p>编码效率比较</p>
<p>Codec</p>
<p>MPEG-4</p>
<p>H.263</p>
<p>MPEG-2</p>
<p>H.264</p>
<p>39%</p>
<p>49%</p>
<p>64%</p>
<p>MPEG-4</p>
<p>–</p>
<p>17%</p>
<p>43%</p>
<p>H.263</p>
<p>–</p>
<p>–</p>
<p>31%</p>
<p>编解码学习笔记（七）：微软Windows Media系列</p>
<p>资料来源于wiki与 <a href="http://chaoqunz.blog.163.com/blog/static/6154877720084493941186/%E3%80%82">http://chaoqunz.blog.163.com/blog/static/6154877720084493941186/。</a></p>
<p>Microsoft 公司主导的音频视频编码系列，它的出现主要是为了进行网络视频传输，现在已经向HDTV 方面进军，开发了 WMV HD 应用。WMV（Windows Media Video）是微软公司开发的一组数字视频编 解码格式的通称，它是Windows Media架构下的一部分。它最初是为低速率流媒体应用作为专有编解码开发出来的，但是2003年微软公司基于Windows Media Video第9版编解码起草了视频编解码规范并且提交给SMPTE申请作为标准。这个标准在2006年3月作为SMPTE 421M被正式批准，这样Windows Media Video 9编解码就不再是一个专有的技术。早期的变解码版本（7和8）仍然被认为是专有技术，因为它们不在SMPTE 421M标准的涵盖范围内。</p>
<p>微软媒体系列分为WMV（Windows Media Video）和WMA（Windows Media Audio），说白了就是微软的视频和音频。</p>
<p>容器</p>
<p>视频流通常与Windows Media Audio音频流组合在一起并且使用扩展名为.wmv或者.asf的Advanced Streaming Format的文件进行封装。WMV通常使用Advanced StreamingFormat（ASF） 封装，它也可以使用AVI或者Matroska格 式封装。如果是AVI封装的文件结果文件可以是.avi，如果是ASF封装的话则是.wmv或者.asf， 如果是MKV封装的话则是.mkv。当使用VirtualDub编 码器编码和WMV9 VCM编解码实现的时候WMV可以存储在AVI文件中。用于Mac的微软公司媒体播放器不支持所有的WMV编码的文 件，因为它只支持ASF文件 封装，Flip4Mac和QuickTime或 者用于MacOSX的MPlayer可 以播放更多的文件。</p>
<p>WMV</p>
<p>扩展名： .wmv <br>互联网媒体类型： video/x-ms-wmv <br>统一类型标识： com.microsoft.windows-?media-wmv <br>开发者： 微软公司 <br>格式： 数字视频</p>
<p>WMV（Windows Media Video）是微软公司开发的一组数字视频编解码格式的通称，它是Windows Media架构下的一部分。它最初是为低速率流媒体应用作为专有编解码开发出来的，但是2003年微软公司基于Windows Media Video第9版编解码起草了视频编解码规范并且提交给SMPTE申请作为标准。这个标准在2006年3月作为SMPTE 421M被正式批准，这样Windows Media Video 9编解码就不再是一个专有的技术。早期的变解码版本（7和8）仍然被认为是专有技术，因为它们不在SMPTE 421M标准的涵盖范围内。</p>
<p>WMV不是仅仅基于微软公司的自有技术开发的。从第七版（WMV1）开始，微软公司开始使用它自己非标准MPEG- 4 Part 2。但是，由于WMV第九版已经是SMPTE的一个独立标准（421M，也称为VC- 1），有理由相信WMV的发展已经不像之前那样是一个它自己专有的编解码技术。现在VC-1专利共享的企业有16家（2006年4月），微软公司也是 MPEG-4 AVC/H.264专利共享企业中的一家。</p>
<p>正式名称</p>
<p>FourCC</p>
<p>Codec版本</p>
<p>描述</p>
<p>Windows Media Video v7</p>
<p>WMV1</p>
<p>0</p>
<p>Microsoft MPEG-4 Video Codec v3</p>
<p>MP43</p>
<p>1</p>
<p>Windows Media Video v8</p>
<p>WMV2</p>
<p>2</p>
<p>Microsoft MPEG-4 Video Codec v2</p>
<p>MP42</p>
<p>3</p>
<p>Microsoft ISO MPEG-4 Video Codec v1</p>
<p>MP4S</p>
<p>4</p>
<p>Windows Media Video v9</p>
<p>WMV3</p>
<p>5</p>
<p>Windows Media Video v9 Advanced Profile</p>
<p>WMVA</p>
<p>6</p>
<p>deprecated as not VC-1 不完全兼容。</p>
<p>Windows Media Video v9 Advanced Profile</p>
<p>WVC1</p>
<p>7</p>
<p>VC-1完整支持</p>
<p>FourCC全称Four-Character Codes，是由4个字符（4 bytes）组成，是一种独立标示视频数据流格式的四字节，在wav、avi档案之中会有一段FourCC来描述这个AVI档案，是利用何种codec来 编码的。因此wav、avi大量存在等于“IDP3”的FourCC。</p>
<p>Microsoft MPEG-4 v1/v2/v3</p>
<p>常见的有1.0、2.0、3.0三种版本，是基于MPEG-4技术的，其中3.0并不能用于AVI的编码，只能用于生成支持“视频流”技术的ASF文件。</p>
<p>Microsoft MPEG-4 version 1 <br>是微软基础的视频编码，是非标准的MPEG-4，与MPEG-4 Part2不兼容。FourCC:MPG4</p>
<p>Microsoft MPEG-4 version 2 <br>VFW的基础编解码。与V与MPEG-4Part2不兼容。VFW（Video for Windows），是微软推出的关于数字视频的一个软件开发包，VFW的核心是AVI文件标准。AVI(AudioVideo Interleave)文件中的音、视频数据帧交错存放。围绕AVI文件，VFW推出了一整套完整的视频采集、压缩、解压缩、回放和编辑的应用程序接口 (API)。由于AVI文件格式推出较早且在数字视频技术中有广泛的应用，所以VFW仍然有很大的实用价值，而且进一步发展的趋势。在VC++开发环境中 调用VFW和使用其它开发包没有什么不同，只是需要将VFW32.lib 文件加入工程中，但在开放视频捕捉与压缩管理程序时需要其它软件硬件设置。VFW为AVI文件提供了丰富的处理函数和宏定义，AVI文件的特点在于它是典 型的数据流文件，它由视频流、音频流、文本流组成。所以对AVI文件的处理主要是处理文件流。FourCC：MP42</p>
<p>Microsoft MPEG-4 version 3 <br>VFW的基础编解码。与V与MPEG-4Part2不兼容。最终只用于ASF文件。FourCC：MP43</p>
<p>除此之外： <br>Microsoft ISO MPEG-4 version 1 <br>基于DirectX Media Objects (DMO)-based编解码，与MPEG-4 SP（Simple Profile）兼容 。FourCC：MP4S。</p>
<p>Microsoft ISO MPEG-4 version 1.1 <br>与MPEG-4 ASP（AdvancedSimple Profile）兼容。FourCC：M4S2</p>
<p>目前在Windows平台上比较实用的MPEG-4视频编解码器主要有：由微软公司开发的Microsoft MPEG-4 Codec v1/v2 /v3，主要是配合微软公司的流媒体技术使用；在Microsoft MPEG-4 v3的基础上，由DivXNetworks公司开发的 DivX Codec；在OpenDivX的基础，遵循GPL开发的开源XviD Codec。<br>这些codec在windows中以dll方式呈现。</p>
<p>Windows Media Video 7</p>
<p>是DirectXMedia Objects (DMO)-based codec。Microsoft 正式开发的 第一个 Windows Media Video，开始脱离了MPEG-4，和MPEG-4 不兼容，从这一点上可见微软的野心（微软公司开始使用它自己非标准MPEG-4Part 2）。可惜这个版本压缩效果非常烂，打破了微软一飞冲天的美梦，不过它在压缩速度上非常快，现在网络上有很多采用这种格式压缩的 WMV。FourCC：WMV1</p>
<p>Windows Media Video ８</p>
<p>在WMV7 基 础上改进的版本，质量上面进不了不少。是DMO-based codec。FourCC：WMV2.</p>
<p>Windows Media Video 9</p>
<p>微软的重头戏，不光是这一个编码，V9 系列更是一个平台，让微软有足够的能力挑战 MPEG，ITU 等标准化组织。虽然这个版本并没有微软吹得那么厉害，特别 是低码率下比较差，不过跟以前版本相比进步还是非常多的。特别是 WMV HD 的应用，让微软也跻身视频标准领域。<br>DMO-based codec. Video for Windows (VfW/VCM) version also available. FourCC：WMV3</p>
<p>Windows Media Video 9 Advanced Profile</p>
<p>在WMV4的Simple和Main profile levels与VC-1标准中的是相同的。VC-1中的AdvancedProfile采用一个新的WMV编解码，称为WindowsMedia Video 9 Advanced Profile。它提高隔行扫描的内容压缩，并与传输无关，使得他可以封装在MPEG的传输流（TS）中或者采用RTP传输。它与之前的WMV9的 codec是不兼容的。</p>
<p>随着 Windows Media Player 10 推出的编码器，能够更进一步控制WMV9 的质量。但是不能在老版本的 WMP9 上播放，也就是不兼容老版本的 WMP9，真不知微软在搞什么？</p>
<p>FourCC：WVC1，VC-1兼容。FourCC：WMVA，不推荐使用非VC-1兼容方式。我们可以认为WMV9与VC-1兼容。</p>
<p>Windows Media Video 9 Screen</p>
<p>静态屏幕无损压缩编码，质量非常好，压缩率高，只针对如屏幕等变化非常小的环境。WMV Screen是一个screencast编解码器，它可以捕抓动态的屏幕内容，将第三方抓屏程序转换到WMV9 Screen文件中。用于之一是计算机的step-by*step演示视频，第一版本是WMV7 Screen，第二个版本也就是当前的版本是WMV9 Screen，支持CBR和VBR。</p>
<p>Windows Media Video 9 Image</p>
<p>静态图像压缩编码。WMV Image是一个视频幻灯片的编码器，播放多个画面时可根据时间进行平移和过度效果展现。与WMV9相比，具有高压缩率和高态图像质量。由于编解码依赖解 码器（播放器）生成实施视频帧，播放WMV Image文件（即使在普通的1024×768，30fps）要求很高的处理能力。在最新的版本，WMV9.1 Image，使用Photo Story3提高转换效果，耽于原来的WMV9 Image不兼容。</p>
<p>视频质量</p>
<p>微软宣称WMV9提供的压缩率为MPEG-4的2倍，MPEG-2的3倍。微软还宣称WMV9的压缩效率笔WMV8高15%～50%。但是在2005年的一个测试报告中，显示WMV9的压缩效率比WMV8要差。</p>
<p>Windows Media Player 10 Mobile</p>
<p>在wiki上，我们注意到“Windows Media Player 10 Mobile”，显示WMV10将用于移动，可能是Windows Mobile。但是我们没有查到进一步的资料。</p>
<p>WMA</p>
<p>扩展名 .wma <br>互联网媒体类型 audio/x-ms-wma <br>统一类型标识 com.microsoft.windows-?media-wma <br>开发者 微软 <br>格式 数字音频</p>
<p>WMA（Windows Media Audio）是微软公司开发的一种数字音频压缩格式。一些使用Windows Media Audio编码格式编码其所有内容的纯音频ASF文件也使用WMA作为扩展名。WMA格式为微软公司私有，但是随着苹果公司的iTunes对它的支持，这 个格式正在成为MP3格式的竞争对手。它兼容MP3的ID3元数据标签，同时支持额外的标签。</p>
<p>WMA可以用于多种格式的编码文件中。应用程序可以使用Windows MediaFormat SDK进行WMA格式的编码和解码。一些常见的支持WMA的应用程序包括Windows Media Player、Windows Media Encoder、RealPlayer、Winamp等等。其它一些平台，例如Linux和移动设备中的软硬件也支持此格式。</p>
<p>WMA 7之后的WMA支持证书加密，未经许可（即未获得许可证书），即使是非法拷贝到本地，也是无法收听的。同时，微软公司开始时宣称的：同文件比MP3体积小 一倍而音质不变，这也得到了兑现。另外，微软公司在WMA 9大幅改进了其引擎，实际上几乎可以在同文件同音质下比MP3体积少1/3左右，因此非常适合用于网络流媒体。</p>
<p>跟MP3相比，WMA在高位的音质渲染力明显不足，甚至还比MP3更差;与MP3相同，通常的WMA也是有损数据压缩的文件格式，对于有更高要求的用户来说WMA并不是一个适合的格式。但在WMA9版本开始支持无损压缩——Windows Media Audio 9 Lossless（在安装WMP11或Windows Media Format 11之后升级至9.1，无损压缩版本最高支持5.1声道编码）。此外WMA也与MP3一样同为有专利版权的文件格式。支持的设备需要购买使用版权。</p>
<p>Windows Media Audio v1/v2</p>
<p>微软最早的音频编码技术，用于 ASF 中，后来被破解也用在 DivX Audio 中，质量比较差。</p>
<p>Windows Media Audio 7/8/9</p>
<p>随着各种不同的 WMV 而推出的相应的音频编码，质量节节提升，不过还没有达到 64kbps CD音质的神化。</p>
<p>Windows Media Audio 9 Professional</p>
<p>WMA9 中 出现的新编码，主要用于多声道编码和高采样率音频的编码，质量不错。</p>
<p>Windows Media Audio 9 Voice</p>
<p>针对语音的编码，最高 20kbps ，不过和 AMR 相比，效果就太差了。</p>
<p>Windows Media Audio 9 Lossless</p>
<p>无损音频编码，可以完美保留CD原质量，是CD备份的不错选择，不过代价是体积过大。</p>
<p>VC-1</p>
<p>VC-1，全名VC-1视讯编解码器（Video Codec 1），是基于微软WMV9，并推广为工业标准。2003年提出标准化申请，最早名字是VC-9。2006年4月正式通过成为标准。VC-1是SMPTE 421M视频编解码标准的正式名称。HD DVD 和蓝光光碟（Blu-ray Disc）都支援VC-1。微软表示Windows Vista将支援VC-1影像压缩技术的HD DVD规格。电影及电视学会（SMPTE）已采用VC-1为视讯压缩标准。</p>
<p>VC-1是基于Windows Media Video 9压缩技术的影像压缩标准，由三大编解码元件所组成，每一个编解码元件都具有其独自的FourCC编码。</p>
<p>WMV3 ：</p>
<p>即WMV9。VC-1的Simple和Main这两种Profile就是WMV3应用，使得与WMV 9兼容，支持逐行扫描编解码。隔行扫描的编解码也提供，但在很快地，在微软推出WMVAdvanced profile后，不推荐采用。逐行扫描编解码用于YUV4:2:0，隔行的（不推荐）用于YUV4:1:1。</p>
<p>WMV3用于高质量的视频和流媒体。同样的质量，它只是MPEG-2的带宽的1/2～1/3。在商业上用于高清电影和视频的WMV HD，编码为WMV3 Main Profile @ High Level(MP@HL)。</p>
<p>WMVA ：</p>
<p>它是在WMV Advanced Profile被SMPTE吸收为作为VC-1草案之间出现的。它与WVC1之间细微的差役，因此解码器也不一样，2006年起，WMVA被认为是个过时的编码，因为与VC-1不完全兼容。</p>
<p>WVC1 ：</p>
<p>也就是WMV 9 Advanced Profile，实现了个更新的，完全符合的AdvancedProfile的VC-1编码标准。它支持隔行扫描内容，与底层传输无关。</p>
<p>压缩技术整合了MPEG及H.264之优点，采用Biliner和Bicubic方式，次像素（Sub- Pixel）最小可达4分之1像素。VC-1只有4种动作补偿（motion composition），压缩比无法胜过H.264。VC-1在压缩时间上，明显比H.264短了许多，复杂度约只有H.264的50%，对特效电影有 很杰出的效能表现。由于H.264 使用较小尺寸的转换公式与无法调整的量化矩阵，造成不能完整保留影像的高频细节资讯。</p>
<p>wiki上有一篇 VC-1和H.264比较 的文章，很值得看一看。我看到这样的一个段：</p>
<p>VC-1：需付费。Reference decoder 并非免费，不过附赠外部文件</p>
<p>H.264：免费.Reference encoder 和 decoder 也是免费。此外，核查小组及M4IF邮寄名单可在一个可能会收到回答了AVC的有关问题。</p>
<p>除此之外，我们在Google上search H.264 license中也看到了说free的字样。但是，果真如此吗？</p>
<p>版权问题</p>
<p>我一直认为H.264是需要付费的，因此我对上面的表述不确定是否正确。我上网查了一下：也看到“H.264的基本系统无需使用版权 ，具有开放的性质，能很好地适应IP和无线网络的使用，”的字样。基于这些疑问，我上网查了一下。IP总是个麻烦的问题，最好向Andriod那样，提供平台，版权，产品维护都是手机生产厂家的事情。</p>
<p>MPEG LA公司是世界领先的替代技术特许服务提供商，它使用户能够通过单笔交易从多个专利持有人那里购买某项技术标准或平台所必须的全球专利权，而不必分别洽谈各项特许权。只要独立管理的一站式专利特许权能够开启方便之门、帮助用户推广某项技术， MPEG LA公司率先采用的特许模式就能提供解决方案。MPEG LA公司的特许权之一就是MPEG-2数字视频压缩，这一技术帮助产生了消费电子历史上应用最为广泛的标准。包括57个国家逾870个MPEG-2基本专利的MPEG-2专利组合特许权拥有至少1500家被许可人，覆盖目前全球市场上的大多数MPEG-2产品，包括机顶盒、DVD播放器、数字电视机、个人 电脑和DVD视频光盘。作为独立特许经营管理人，MPEG LA公司不与任何标准管理机构相关联，也不是任何专利权持有人的关联人。欲了解更多信息，请登录<a href="http://www.mpegla.com./">http://www.mpegla.com。</a> （<a href="http://www.dvbcn.com/2010-01/28-44547.html%EF%BC%89">http://www.dvbcn.com/2010-01/28-44547.html）</a></p>
<p>我去MEPG-LA网上查阅，发现有AVC/H.264，也就是说这个是需要付费的。在资料中有下面的一张PPT。：</p>
<p>我不是很看得的懂，比如一个H.264的片子，是提供下载片子的内容供应商付钱，还是提供解码器的终端设备商需要付费？又例如使用H.264进行视频电话，小于12分钟不收费，大于12分钟收费？混乱啊。因此知识产权这摊事，还是留个专业的法律人士来负责。</p>
<p>编解码学习笔记（八）：Real系列</p>
<p>下面资料从wiki中整理获取。</p>
<p>Real系列是RealNetworks提供的，分为RealVideo和RealAudio。</p>
<p>RealVideo</p>
<p>RealVideo是一种影片格式由RealNetworks于 1997年所开发，至2006年时已到RealVideo版本10。它从开发伊始就定位为应用为网络上视频播放上的格式。支持多种播放的平台，包含 Windows、Mac、Linux、Solaris以及某些移动电话。相较于其它的视频编解码器，RealVideo通常可以将视频数据压缩得更小。因此它可以在用56Kbps MODEM拨号上网的条件实现不间断的视频播放。</p>
<p>一般的文件扩展名为.rm/.rvm，现在广泛流行的是rmvb格式，即动态编码率的real video。</p>
<p>RealVideo早期使用H.263，在RealVideo8及之后公司采用私有或者不公开的视频格式。官方的的播放器是 RealNetworks RealPlayer SP，最新的版本是v12，在多个平台，包括Windows，Macintosh，和Linux中提供。RealNetworks公司同时也开发了开源的 Helix播放器，但是在Helix项目中没有提供RealVideo，因为Real系列的编解码仍是不公开的。</p>
<p>RealMedia文件可以通过RTSP在网络上传输，但是RTSP只用于建立和管理连接，真正的视频数据是通过 Real自己私有的 RDT（Real Data Transport）协议传输。这种方式引起很大的批评，因为难以在其他播放器和服务器中使用RealVideo，现在一些开源项目，例如MPlayer 已经可以播放RDT流。为了支持实时流，RealVideo和RealAudio通常采用CBR（恒定码速）编码，使得每秒传递的数据相等。后来，公司开发了可变码速，成为RealMedia Variable Bitrate（RMVB），提供更高的水平资料，但是这种格式不适合作为流，因为难以预测某个特定的媒体流需要多少网络资源。带有快速移动和场景变化的视频需要更高的码流，如果码流超出网络所能提供的速率，将会引起中断。</p>
<p>RealNetworks公司说RealVideo和RealAudio编解码的源代码不在RPSL的许可内。在许可源代码在不支持的处理器和操作系统的商用移植中许可。虽然公司拥有大多数的知识产权，但是允许第三方为某个特性享有版权。</p>
<p>RealVideo 1.0</p>
<p>RealVideo的第一个版本在1997年释放，是基于H.263格式。在RealPayer5中提供。FourCC为rv10，rv13</p>
<p>RealVideo G2和RealVideoG2+SVT</p>
<p>也是就要H.263，在RealPlayer6中提供。质量比较糟糕。FourCC为rv20</p>
<p>RealVideo 8</p>
<p>随着 RealPlayer 8 推出的视频格式，是现在主流的网络视频编码之一。编码速度较慢，质量也只能算一般。猜测是基于早期的H.264 draft，在RealPlayer 8中提供，FourCC为rv30。</p>
<p>RealVideo 9</p>
<p>RealNetworks 开 发的新一代编码，质量进步了很多，特别是在底码率下，而且编码速度很快，做到了速与质的很好统一。<br>猜测是基于H.264，在RealPlayer9中提供。FourCC为rv40.</p>
<p>RealVideo 10</p>
<p>在RealVideo 9 基 础上加入了一些参数，如 EHQ 等，更加精确控制码率，和 RealVideo 9 兼容。在RealPlayer10中提供，FourCC为rv40（与RealVideo9相同）</p>
<p>RealAudio</p>
<p>文件名扩展： .ra, .ram</p>
<p>Internet media type：audio/vnd.rn-realaudio,audio/x-pn-realaudio</p>
<p>RealAUdio是RealNetwoks公司私有的宾朋编解码格式，最早在1995年释放。它包括一系列的音频编解码，从古老拨号modem的 低速率格式到高质量的音乐。可用于媒体流，过去很多的互联网电台使用RealAudio作为他们节目的实时音频流，近年使用得较少，让位与其他流行的格 式。</p>
<p>RealAudio文件后缀为.ra。1997年，公司开始提供视频格式成为RealVideo。将音频和视频合并是以哦那个的容器后缀为.rm。然而，最新的版本，使用.ra用于音频文件，使用.rv用于带或不带音频的视频文件，用.rmvb用于可变速率的视频文件。</p>
<p>.ram(Real Audio Metadata)和.smil(SynchronizedMultimedia Integration Language)文件格式用于流媒体中的链接。在很多情况下，网络并不直接链接一个RealAudio文件，而是链接.ram和.smil文件。这是一 个很小的文本文件，包括音频流的链接。当用户点击一个链接，网络浏览器下载.ram和.smil文件，并加载用户的媒体播放器，媒体播放器从文件中读取 pnm或者rtsp的URL，并开始播放流。</p>
<p>RealAudio文件包括多种音频编解码，每个编解码都是用FourCC（Four Character Code）来表示，介绍如下：</p>
<p>lpcJ: IS-54 VSELP (RealAudio 1)</p>
<p>28_8: G.728 LD-CELP (RealAudio 2)</p>
<p>dnet: Dolby AC3 (RealAudio 3)</p>
<p>sipr: Sipro Lab Telecom ACELP-NET (RealAudio 4/5)</p>
<p>cook: G2/Cook Codec (RealAudio 6)</p>
<p>atrc: Sony ATRAC3 (RealAudio 8)</p>
<p>raac: MPEG-4 LC-AAC (RealAudio 9)</p>
<p>racp: MPEG-4 HE-AAC (RealAudio 10)</p>
<p>ralf: RealAudio Lossless Format (RealAudio 10)</p>
<p>编解码学习笔记（九）：QuickTime系列</p>
<p>扩展名 .mov,.qt<br>互联网媒体类型 video/quicktime<br>类型代码 MooV<br>统一类型标识 com.apple.quicktime-movie<br>开发者 苹果公司<br>格式 　媒体容器<br>专门属 音频、视频、文字</p>
<p>　　或者标题可以改为Apple系列。QuickTime 并不是一个编码，而是一个多媒体平台，它的上面有众多编码，这里只针对几个主流的编码器。<br>　　QuickTime技术拥有三种主要的组件：</p>
<p>媒体播放器，苹果计算机在他自己的网站免费让人下载以及内建在他的计算机中。</p>
<p>QuickTime 档案格式-公开文件并且任何人都可以使用，不须权利金。</p>
<p>软件开发工具可用于Macintosh和Windows平台。这些工具允许人们开发他们自己的软件来操作QuickTime以及其它媒体档案。这些对已注册开发人员是 免费的（注册免费）。</p>
<p>　　苹果在Mac OS和Windows平台推出免费之官方媒体播放软件，名字为&quot;QuickTime Player&quot;（早期的版本简单地使用　　了&quot;MoviePlayer&quot;这个名称）。这个播放器也包含一些媒体编辑和媒体创作的特色，但是使用者必须从 Apple购买序列号来打开这些功能，把这个播放器转变为&quot;QuickTimePro&quot;。</p>
<p>QuickTime历史：1991年到1998年：1.x- 2.x</p>
<p>　　苹果电脑于1991年12月2日释出第一个QuickTime的版本，作为System 7上的多媒体附加功能。QuickTime的首席开发者，Bruce Leak，于1991年五月的Worldwide Developers Conference做了第一次的公开展示。他在Mac上展示苹果电脑有名的1984电视广告，在那时候是一种令人印象深刻的突破。Microsoft的 竞争技术-Video for Windows- 在1992年11 月之前都还未出现。</p>
<p>　　第一个版本的QuickTime制定的基本架构，到现在基本上还存在未更改，包含多重电影轨道，可扩充的媒体形态支持，一种开放的文件格式，以及完整的编辑功能。原本的视频codec包含：</p>
<p>Apple视频codec（也称作&quot;Road Pizza&quot;），适合普通现场动作图像。</p>
<p>动画codec，使用简单的run-length图形压缩方式，适合卡通形态的大区域颜色很适合。</p>
<p>图形codec，对于每一点8位（8-bit-per-pixel）的图像优化，包含有抖色en:dithering的图形。</p>
<p>　　苹果电脑在1992年后期发放了Mac操作系统的1.5版本。</p>
<p>　　苹果电脑在1994年二月发布了QuickTime 2.0 for Mac OS版–这个是唯一的一个不免费的版本。在这个版本中加入了对音乐轨迹的支持，音乐轨迹相当于MIDI的数据，这个功能可以驱动sound- synthesis引擎自我创建于QuickTime中（使用的声音许可证来自Roland），或者是任何外部的MIDI设备，因此创建出来的声音只占用 一小部分的电影数据。</p>
<p>　　在接下来的2.1和2.5版本中，QuickTime继续免费。工程师改良了对音乐的支持并增加了sprite轨迹，这个功能可以实现创建复杂的动画，文件大小就只比静态的图片大一点。</p>
<p>　　QuickTime 2.0 for Windows发布于1994年11月。</p>
<p>QuickTime历史：1998 - 2001: 3.0 and 4.0</p>
<p>　　运行于Mac OS的QuickTime 3.0于1998年3月30日发行。其现有的功能是免费的，但如果要获得Apple所提供的具有更多特性的QuickTime Player和Picture Viewer程序，最终用户需要通过购买一个QuickTime Pro 许可证来解除对软件的限制。</p>
<p>　　QuickTime 3.0增加了支持图像导入的组件，从而可以从GIF、JPEG、TIFF和其他文件格式中读取图像。而通过FireWire主要作为视频数据输出的视频输 出组件同样增加了视觉效果，使程序员可以把实时技术运用到视频轨道中。一些效果甚至可以响应用户的鼠标单击，就像是电影本身的交互支持一样。</p>
<p>　　苹果于1999年6 月10日发行了QuickTime 4.0 for Mac OS。它增加了图像导出组件，支持输出成与预导入者可以阅读的相同格式的非GIF格式（或许是因为LZW许可）。它增加了Sorenson video codec的第一个版本，并且支持streaming。</p>
<p>　　QuickTime 4.1于2000年伊始发布，增加了在Mac OS 9及后续版本中播放超过2G的电影；并且终止了对68K Mac的支持。用户获得了操作QuickTime Player viaAppleScript的能力。</p>
<p>QuickTime历史：2001 - present 5.0 and later <br>　　QuickTime 5.0 for Mac OS于2001年4月23日出现。它增加了&quot;皮肤&quot;功能和多处理图像压缩支持。在这一版本中只有拥有QuickTime Pro许可证的用户才可以使用全屏模式，这一做法引起了争议，至今尚未解决。</p>
<p>QuickTime历史：QuickTime 6.x <br>　　QuickTime 6.0 for Mac OS，于2002年7月15日释出，第一次包括Mac OS X使用的版本。</p>
<p>更新至QuickTime 6</p>
<p>释出日期</p>
<p>版本</p>
<p>平台</p>
<p>特色</p>
<p>2002 年 7 月15 日</p>
<p>QuickTime 6</p>
<p>Mac OS 8.6 –Mac OS X ,Windows</p>
<p>MPEG-2 、MPEG-4 以及AAC</p>
<p>2003 年 1 月14 日</p>
<p>QuickTime6.1</p>
<p>Mac OS X</p>
<p>品质与效能的增进</p>
<p>2003 年 3 月31 日</p>
<p>QuickTime 6.1</p>
<p>Windows</p>
<p>修正CAN-2003-0168 安全性弱点</p>
<p>2003 年 4 月29 日</p>
<p>QuickTime 6.2</p>
<p>Mac OS X</p>
<p>对于iTunes 4 的支持、增进的AAC 支持</p>
<p>2003 年 6 月3 日</p>
<p>QuickTime 6.3</p>
<p>Mac OS X, Windows</p>
<p>3GPP 与AMR</p>
<p>2003 年 10 月16 日</p>
<p>QuickTime 6.4</p>
<p>Mac OS X, Windows</p>
<p>Pixlet 编码解码器、集成3GPP</p>
<p>2003 年 12 月18 日</p>
<p>QuickTime 6.5</p>
<p>Mac OS X, Windows</p>
<p>3GPP2 与AMC 移动式多媒体格式</p>
<p>2004 年 4 月28 日</p>
<p>QuickTime 6.5.1</p>
<p>Mac OS X, Windows</p>
<p>Apple Lossless</p>
<p>2004 年 10 月27 日</p>
<p>QuickTime 6.5.2</p>
<p>Mac OS X, Windows （对Windows 98/Me 的最后一个版本）</p>
<p>修正程序错误、安全性更新、以及品质与效能的增进</p>
<p>2005 年 10 月12 日</p>
<p>QuickTime 6.5.3</p>
<p>Mac OS X v10.2.8</p>
<p>QuickTime历史QuickTime 7.x</p>
<p>　　更新至QuickTime 7。</p>
<p>更新至QuickTime 7</p>
<p>释出日期</p>
<p>版本</p>
<p>平台</p>
<p>特色</p>
<p>2005 年 5 月31 日</p>
<p>QuickTime 7.0.1</p>
<p>Mac OS X</p>
<p>修复一个关于Quartz Composer 外挂模块 的安全性问题</p>
<p>2005 年 7 月15 日</p>
<p>QuickTime 7.0.2</p>
<p>Mac OS X</p>
<p>修复程序错误与兼容性的增进</p>
<p>2005 年 9 月7 日</p>
<p>QuickTime 7.0.2</p>
<p>Windows 2000 /XP</p>
<p>第一个非预览版本释出</p>
<p>2005 年 10 月12 日</p>
<p>QuickTime 7.0.3</p>
<p>Mac OS X &amp; Windows 2000 /XP</p>
<p>流 与H.264 的程序错误修复。<br>需要通过iTunes Music Store 支持视频的购买。</p>
<p>2005 年 10 月29 日</p>
<p>QuickTime 7.0.3.50</p>
<p>Windows 2000 /XP</p>
<p>2006 年 1 月10 日</p>
<p>QuickTime 7.0.4</p>
<p>Mac OS X &amp; Windows 2000 /XP</p>
<p>第一个通用二进制 版本。<br>众多的程序错误修复与H.264 效能的改善。</p>
<p>2006 年 5 月11 日</p>
<p>QuickTime 7.1</p>
<p>Mac OS X &amp; Windows 2000 /XP</p>
<p>众多的程序错误修复、对于iLife ‘06 的支持、以及H.264 效能的改善</p>
<p>2006 年 5 月31 日</p>
<p>QuickTime 7.1.1</p>
<p>Mac OS X</p>
<p>2006 年 6 月28 日</p>
<p>QuickTime 7.1.2</p>
<p>Mac OS X</p>
<p>Addresses an issue previewing iDVD projects.</p>
<p>2006 年 9 月12 日</p>
<p>QuickTime 7.1.3</p>
<p>Mac OS X &amp; Windows 2000 /XP</p>
<p>程序错误修复与严重的安全性问题。</p>
<p>　　现时QuickTime的最新版本是QuickTime 7.6，但Windows 2000可以使用的最高版本却是7.1.6。在7.5.5之前的版本，都存在Cross site scriping的安全性问题。<br>QuickTime的历史：QuickTime X</p>
<p>　　QuickTime X（读作Quicktime Ten，当中 的&quot;X&quot;是罗马数字的十）是下一世代的QuickTime，在2008年6 月9日的WWDC上 发表。产品预期会在2009年的年中随同Mac OS X v10.6推出[3]。Version X会使用与iPhone OS相同的媒体技术，并支持更新的编码及更具效益的媒体播放功能。<br>Sorenson Video</p>
<p>Sorenson Video 2：</p>
<p>Sorenson Media 公 司开发的编码器，主要用于QuickTime 4 的视频编码，质量较差。</p>
<p>Sorenson Video 3：</p>
<p>Sorenson Media 公 司随 QuickTime 5发布的编码器，质量很不错，已经成为 QuickTime 的标准视频编码，网络上大部分电影预告片都采用这种编码。</p>
<p>Apple MPEG-4</p>
<p>　　Apple 公司自己开发的 MPEG-4 编码器，随 QuickTime 6 发布，质量很差。</p>
<p>Apple H.264</p>
<p>　　Apple 公司自己开发的 H.264 编码器，随 QuickTime 7 发布，支持 HDTV。</p>
<p>Audio QDesign Music</p>
<p>QDesign Music 1</p>
<p>QDesign 公司开发的音频编码器，这个版本现在已经开不到它的身影了。</p>
<p>QDesign Music 2</p>
<p>QDesign Music 的 第二个版本，也是最后一个版本，在时下这些先进的音频编码面前，它已经没有生命力了，主要应用于网上的电影预告片。</p>
<p>Audio Apple MPEG-4 AAC</p>
<p>　　Apple 公司自己开发 的 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布。</p>
<p>Apple Lossless</p>
<p>　　Apple 公司开 发的无损音频编码，主要应用于 iTunes 抓取 CD。Apple Lossless（AppleLossless Audio Codec、ALAC）为苹果的无损音频压缩编码格式。 在 iTunes 上名称为 Apple Lossless。</p>
<p>　　可将非压缩音频格式（WAV、AIFF）压缩至原先容量的40%至60%左右，编译码速度很快。也因为是无损压缩，听起来与原档案完全一样，不会因解压缩和压缩而改变。</p>
<p>　　它在2004年4月28日公布的iTunes4.5和QuickTime6.5.1 的其中一部份。目前携带型数字多媒体播放器中只有 iPod 可播放。</p>
<p>　　虽为非自由软件或开放原始码软件、但 Apple Lossless 的开放原始码译码器已经释出。</p>
<p>注：上述材料来源于wiki的整理。</p>
<p>编解码学习笔记（十）：Ogg系列</p>
<p>Ogg是一个自由且开放标准的容器格式，由Xiph.Org 基金会所维护。Ogg格式并不受到软件专利的限制，并设计用于有效率地串流媒体和处理高质量的数字多媒体。</p>
<p>　　Ogg意指一种文件格式，可以纳入各式各样自由和开放源代码的编解码器，包含音效、视频、 文字（像字幕）与元数据的处理。</p>
<p>OggTheora</p>
<p>　　Theora是一个免权利金、开放格式的有损影像压缩技术，由Xiph.Org基金会开发，该基金会还开发了著名的声音编码技术Vorbis， 以及多媒体容器档案Ogg。Theora 是由 On2Technologies 公司专属的 VP3 编码器经过开放源代码后衍生而来。Theora 的命名来自于一个电视节目Max Headroom。</p>
<p>　　Theora是一个可 变位速率、以DCT为基础的影像压缩格式。和多数的影像编码格式一样，Theora 使用了色度抽样、block basedmotion compensation 和 8×8 DCT block，也支援视 讯压缩图像类型和 视 讯压缩图像类型，但是不支持使用在 H.264 和 VC-1 的 bi-predictive frames（B-frame），Theora 也不支援 隔 行扫描, variable frame rates, 或 bit-depths larger than 8 bits per component。</p>
<p>　　Theora 的影像流可以储存在任何的容器档案格式中，最常用的是和声音编码Vorbis一起储存在Ogg档案格式中，这种方式可以提供完全开放、免权利金的多媒体档案。此外Theora影像也可以储存在Matroska档 案中。</p>
<p>　　Google官方blog称，Web视频目前没有一个标准，有些网站使用Flash，但这要求用户有Flash播放 器;有些使用Java播放器，但为了在JVM虚拟机中解码视频和音频用户需要一个配置很高的机器;等等诸如此类。</p>
<p>　　好消息是新一代的 HTML 5标准引入了视频元素，Web开发者可以用一种标准的方式指定视频的外观。现在问题变成了使用哪一种视频格式。</p>
<p>　　Google 认为开放标准格式可以成为目前无序的视频格式之争的底线。最后的权益方案不需要最复杂的格式，或者是最大张旗鼓宣传，几乎已成为行业标准的格式，因此他们决定选择支持使用广泛的开源Ogg Theora格式。</p>
<p>　　Theora是On2 Technologies 公司的 VP3 编码器的开源衍生版，Google于去年收购了On2公司。</p>
<p>　　资料来源：<a href="http://tech.it168.com/a2010/0412/872/000000872493.shtml">http://tech.it168.com/a2010/0412/872/000000872493.shtml</a></p>
<p>　　在2002年3月，On2将许可改为下周VP3开源代码为LGPL。在2002年6月，On2将VP3作为 Xiph.Org仅仅和下的一个类似BSD的开源许可。On2还制定了一个不可更改的免版权费的声明，任何人可以用于任何软件，任何的衍生产品以及任何目 的。2002年88月，On2与Xiph.Org签订一项协议，将VP3作为一个新的，免费的视频编解码，成为Theora。On2宣称Theora是 VP3的一个继任者。在2002年10月3日，On2和Xiph宣布Theora最早的Alpha代码释放。</p>
<p>　　比特流格式在2004年冻结（version 1.0 alpha3），有经过了几年的beta版本，Theora第一稳定版本（v1.0）在2008年11月释放。Theora任何版本的视频编码在格式冻结后都与未来的播放器兼容。目前的工作集中在“Thusnelda”分支的bug修复，目前为beta版本，将最后作为Theora1.1版本释放。</p>
<p>　　Theora视频压缩格式基本上与VP3视频压缩格式兼容，包含一个后先兼容的超集。Theora是VP3和 VP3流（有小量语法修订）的超集，VP3流可以不经过重新压缩改为Theora流，但是反过来把成立。VP3视频压缩可以由Theora来实现解码，但 是Theora视频演示通常不能够使用古老的VP3来进行解码。</p>
<p>　　Theora将视频格式建立在开源的基础上，并作为基百科视频内容选择的编码格式。然而，Theora缺少商业支持，并正努力获取分销商尤其是网络分销商接受。</p>
<p>　　Mozilla使用这项技术在Firefox上提供HTML5视频。苹果和微软的HTML5视频都准备采用 MPEG LA管理的H.264。该团体的成员包括微软和苹果，及许多科技公司。</p>
<p>　　这里面的争议关键在于license的问题，H.264是需要给license的。</p>
<p>　　Mozilla则发出以下声明：“我们相信，HTML5视频在多方、开放和无权利金的编/解码器，以同于W3C 授权标准之方式支持下，才符合公众利益。如 果MPGA LA愿意根据W3C标准定义的开放网络条件提供H.264，我们绝对会考虑采用这项技术。本组织坚持我们对Theora的立场。”</p>
<p>　　Opera首席技术官Hakon Wium Lie也提供下列声明；“为了开放网络的成长茁壮，所有媒体(包括视频)，必须在无需支付编/解码器授权费的前提下使用。真正支持一个开放网络的浏览器制造商，必须努力建造一个无授权费的基本影音编/解码器。”</p>
<p>　　微软的公司博客写道：“源代码能否取得，与知识产权之间的区别，在于可取用的源代码是极度必要的。目前，H.264的知识产权，可通过MPEG LA管理的一个定义明确的方案取得。其它编/解码器的权利通常较不清楚。”</p>
<p>Ogg Vorbis</p>
<p>Ogg 的音频编码， 质量非常优秀，特别是低码率下，支持多声道。最高码率能够达到500kbps，是 AAC 的有力竞争者。</p>
<p>　　「Ogg」这个词汇通常意指Ogg Vorbis此一音频文件格式，也就是将Vorbis编码的音效包含在Ogg的容器中所成的格式。在以往，.ogg此一扩展名曾经被用在任何Ogg支持格 式下的内容，但在2007年，Xiph.Org基金会为了向后兼容的考虑，提出请求，将.ogg只留给Vorbis格式来使用。Xiph.Org基金会决定创造一些新的扩展名和媒体格式来描述不同类型的内容，像是只包含音效所用的.oga，包含或不含声音的影片（涵盖 Theora）所用的.ogv和程序所用的.ogx。</p>
<p>　　Vorbis的是一个 开源自由软件 项目负责人是 Xiph.Org基金会。该项目产生的数位音频格式规范和软件实施（编译码器）为有损音频压缩。 Vorbi是最常用的结合与Ogg容器格式，因此通常被称为 Ogg Vorbis格式.</p>
<p>　　Vorbis是一个延续的音频压缩的开发始于 1993年克里斯蒙哥马利.集约发展始于1998年9月后，信弗劳恩霍夫协会 该公司宣布将收取许可费为 MP3音频格式。Vorbis的项目开始作为公司的一部分，Xiph.Org 基金会的Ogg项目（也称为 OggSquish多媒体项目）。克里斯蒙哥马利开始工作的项目，并协助越来越多的其它开发商。他们继续完善源代码 直到Vorbis的文件格式被冻结 2000年5月为 1.0 和一个稳定的版本（1.0）的参考软件发布于 2002年7月19日。</p>
<p>OggSpeex</p>
<p>　　Ogg 的语音编码，专门针对低码率的语音编码。</p>
<p>Ogg FLAC</p>
<p>Ogg 的无损音频编码。</p>
<p>On2 VPX 系列</p>
<p>On2 公司开发了一系列优秀的视频编码，现在应用得最多的恐怕是 NullsoftVideo 的视频，它们就采用了 VP3，VP5，VP6 视频编码。</p>
<p>VP3</p>
<p>　　已经作为开放源代码公布，现在 是 Ogg Theora 项目，当然，Theora 的质量可比 VP3 好多了。</p>
<p>VP4</p>
<p>　　On2 公司当年吹牛全球最好的视频编码，后来证明质量很一般。</p>
<p>VP5</p>
<p>　　至今还很神秘，On2 并没有放出来，只在 NullsoftVideo 里面见到他的身影。</p>
<p>VP6</p>
<p>　　从一开始，On2 就把这个编码器提供给大家下载，质量还是不错的。不过最近似乎又关闭了，主页上只有一个解码器。On2 TrueMotion VP6是一个专有的有损视频编解码格式和视频编解码器。它是TrueMotion视频编解码的具体体现，是一系列由On2开发的视频编解码，通产个用于 Adobe flash，Flash Video和JavaFX媒体文件。</p>
<p>VP7</p>
<p>　　On2 最新的编码器，在 VP6 上有不少进步。在2005年1月，On2宣布推出比VP6有更好的压缩比的新的编解码VP7。在2005ian4月，On2公司许可On2视频编码器9包 括VP6和VP7）用于Macromedia Flash。在2005年8月，Macromedia宣布他们选择VP6作为新的Flash Player8的视频回放的旗舰式编解码。</p>
<p>VP8</p>
<p>　　Google在2009年收购了On2 Technologies，并于2010年5月19日在Google I/O会议上宣布将VP8以BSD许可证的形式开源。。VP8是On2 Technologies继VP3之后宣布开源的第二个编解码器。（Xiph.Org 基金会于2002年接手VP3并将之冠名以Theora，之后以BSD许可证的形式将Theora开源）。要求Google将VP8开源的最大呼声来自于 自由软件基金会。2010年3月12日，自由软件基金会给Google发了一封公开信，请求Google逐渐用开源形式的VP8和HTML 5取代YouTube上的Adobe Flash和H.264。</p>
<p>　　2010年5月19日，WebM启动。WebM包含了来自于Mozilla、Opera、Google以及其他四十多家出版商和计算机软硬件供 应商（包括AMD、NVIDIA）的贡献，旨在大力倡导在HTML5中使用VP8。InternetExplorer 9在安装了适合的编解码器之后也能支持VP8。</p>
<p>注：上述材料来源于wiki的整理。</p>
<p>编解码学习笔记（十一）：Flash Video系列</p>
<p>用于在 Flash 中压缩视频。FLV流媒体格式是一种新的视频格式，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上有效使用等 缺点。一般FLV文件包在SWF PLAYER 的壳里，并且FLV可以很好的保护原始地址，不容易被下载到，从而起到保护版权的作用。</p>
<p>文件名： .flv, .f4v, .f4p, .f4a, .f4b</p>
<p>媒体类型：video/x-flv, video/mp4, video/x-m4v, audio/mp4a-latm, video/3gpp, video/quicktime, audio/mp4</p>
<p>厂家：Adobe Systems (originally developed by Macromedia)</p>
<p>Type of format： Media container</p>
<p>Container for ：Audio, video, text, data Extended from</p>
<p>扩展：FLV: SWF ，F4V: MPEG-4 Part 12</p>
<p>Flash介绍</p>
<p>　　Flash Video是一个文件容器格式，是Adobe Flash播放器版本6-10用于在互联网上传递视频。Flash视频内容也可以封装在SWF文件。Flash视频有两种不同的文件格式：FLV和 F4V。FLV文件中，同SWF文件一样音频和视频数据采用相同方式进行编码。晚出现的F4V，它的格式是基于ISO为基础的媒体文件格式，并在 Flash Player 9 update 3中开始得到支持。这些格式Adobe Flash播放器都能支持，并由Adobe公司开发，其中FLV最找石油Macromedia公司开发的。</p>
<p>　　Flash视频FLV文件所包含的媒体的编码通常采用Sorenson Spark和VP6视频压缩格式。最新发布的Flash播放器支持H.264视频和HE-AAC音频。所有的这些编解码目前受到专利的限制。</p>
<p>　　Sorenson编解码看参考以下两种专用的视频编解码：Sorenson Video或者Sorenson Spark。Sorenson Video也被称为Sorenson Codec，Sorenson Video Quantizer或者SVQ。Sorenson Spark也称为Sorenson H.263。这些编解码都是有Sorenson 媒体公司设计（及以前的Sorenson Vision公司）。Sorenson Video在Apple的QuickTime中使用，SorensonSpark在Adobe Flash（以前的MacromediaFlash）中使用。</p>
<p>　　Flash视频通过广泛使用的Adobe Flash播放器和浏览器的plugin或者其他的第三方程序，使它能在绝大多是的操作系统都可以使用。</p>
<p>通常Flash视频FLV文件包含的视频比特流是一个专有的H.263视频标准的变体，FourCC为 FLV1（Sorenson Spark）。SorensonSpark是一个FLV文件老式编解码，但被广泛应用和兼容，因此它是第一个被Flash Player支持的视频编解码。这是在Flash Player 6和7要求的视频压缩格式。Flash Player 8和更新的版本支持On2 TrueMotion VP6视频比特流回放（FourCC VP6F或者FLV4）。On2 VP6是FlashPlayer 8或者更高版本优先使用的视频压缩格式。On2 VP6可以提供能够提供比Sorenson Spark更高视觉质量，尤其在低比特流中。另外它的计算更为复杂，因此在某些古老的系统配置中无法很好使用。</p>
<p>　　Flash 9 update 3，在2007年12月3日释放，提供了新的Flash视频文件格式F4V，支持H.264视频标准（也即MPEG-4part 10或者AVC），H.264需要更复杂的技术，但是提供更加卓著质量/比特流比例。具体而言，Flash播放器现在支持H.264视频压缩（MPEG- 4 Part 10）,AAC音频压缩（MPEG-3 Part 3），F4V，MP4（MPEG-4 Part14），M4V，3GP和MOV多媒体容器格式，3GPP Timed Text标准（MEPG-4 Part 17）（这是一个标准的的字幕格式，能够部分解析ID3的’ilist’，等同于iTunes使用的metadata存储。不支持MPEG-4 Part 2视频（例如有DivX或者Xvid创建）。Jonathan Gay，一个Flash的主要程序员在接收BBC新闻采访时表示：公司最初想在Flash中使用H.264，但是被每年5百万美金（3.5百万英镑）的专 利许可费而却步。</p>
<p>　　Flash Video FLV文件格式支持两个成为“screenshare‘（Screen Video）编解码的版本，这是一种用于桌面演示的编码格式。这两种格式都是基于tmap平铺方式，可以通过减少色深进行有损编码，并使用zlib压缩。 第二个版本之在Flash播放器8以及更新的版本支持。</p>
<p>　　在Flash视频文件中，通常使用MP3作为音频编码然而，在Flash视频FLV文件通过麦克风录音使用专用 的Nellymoser Asao编解码（Flash Player 10 在2008年发布，也支持开源的Speex编解码）。FLV文件支持不压缩的音频或ADPCM音频格式。最新的Flahs Player 9 支持AAC（HE-AAC/AAC SBR，AAC Main Profile，和AAC-LC）。</p>
<p>　　编码为Flash Video文件有一个编码工具提供，包括Adobe的Flash Professional和Creative Suite产品，On2的Flix编码工具，SorensonSqueeze，FFmepg和其他第三方工具。</p>
<p>容器</p>
<p>　　在2002年发布的Flash Player6增加了对SWF文件格式的支持。在2003年，FlashPlayer7增加了对FLV文件格式的直接支持。由于FLV文件格式的限制，Adobe System公司在2007年提出下面列出的新的文件格式，是基于ISO基本媒体文件格式（MPEG-4 Part 12）。Flash播放器不检查文件的扩展名，而直接查看文件，检查属于那种格式。</p>
<p>文件扩展名</p>
<p>Mime Type</p>
<p>描述</p>
<p>.f4v</p>
<p>video/mp4</p>
<p>Video for Adobe Flash Player</p>
<p>.f4p</p>
<p>video/mp4</p>
<p>Protected Video for Adobe Flash Player</p>
<p>.f4a</p>
<p>video/mp4</p>
<p>Audio for Adobe Flash Player</p>
<p>.f4b</p>
<p>video/mp4</p>
<p>Audio Book for Adobe Flash Player</p>
<p>　　在Flash Player6及以后的版本对SWF文件的支持，使得可以与Adobe Flash媒体服务器通过RTMP来进行音频，视频和数据的交互。Flash媒体服务器的数据支持采用FLV文件格式的文件（MIME类型为 video/x-flv）。从Flash Player 9 Update 3开始创建的SWF文件，Flash Player可以播发新的F4V文件格式。</p>
<p>媒体格式</p>
<p>　　在FLV文件中支持的媒体类型：</p>
<p>视频：On2 VP6，Sorneson Spark（Sorenson H.263），Screen Video，H.264</p>
<p>音频：MP3，ADPCM，Linear PCM，Nellymoser，Speex，AAC，G.711（保留用于互通需求）</p>
<p>　　在F4V文件中支持的媒体类型：</p>
<p>视频：H.264</p>
<p>图像（视频数据的静止帧）：GIF，PNG，JPEG</p>
<p>音频：AAC，HE-AAC，MP3</p>
<p>在Flash Player和Flash Video中支持的音视频压缩格式</p>
<p>Flash Player version</p>
<p>Released</p>
<p>File format</p>
<p>Video compression formats</p>
<p>Audio compression formats</p>
<p>6</p>
<p>2002</p>
<p>SWF</p>
<p>Sorenson Spark, Screen video</p>
<p>MP3, ADPCM, Nellymoser</p>
<p>7</p>
<p>2003</p>
<p>SWF, FLV</p>
<p>Sorenson Spark, Screen video</p>
<p>MP3, ADPCM, Nellymoser</p>
<p>8</p>
<p>2005</p>
<p>SWF, FLV</p>
<p>On2 VP6, Sorenson Spark, Screen video, Screen video 2</p>
<p>MP3, ADPCM, Nellymoser</p>
<p>9.0.115.0</p>
<p>2007</p>
<p>SWF, FLV</p>
<p>On2 VP6, Sorenson Spark, Screen video, Screen video 2, H.264[*]</p>
<p>MP3, ADPCM, Nellymoser, AAC[*]</p>
<p>SWF, F4V, ISO base media file format</p>
<p>H.264</p>
<p>AAC, MP3</p>
<p>10</p>
<p>2008</p>
<p>SWF, FLV</p>
<p>On2 VP6, Sorenson Spark, Screen video, Screen video 2, H.264[*]</p>
<p>MP3, ADPCM, Nellymoser, Speex, AAC[*]</p>
<p>SWF, F4V, ISO base media file format</p>
<p>H.264</p>
<p>AAC, MP3</p>
<p>[*]在FLV文件格式中使用H.264和AAC压缩有一些限制，Flash Player的作者强烈推荐大家使用新的F4V文件格式。</p>
<p>Flash传递的几种方式</p>
<p>一、作为一个标准的flv文件。</p>
<p>二、嵌入SWF文件，使用Flash认证工具（在FlashPlayer ６及以后的版本支持）。</p>
<p>三、通过HTTP的渐进流下载（progressive download）。这种方式使用ActionScript，包括客户端侧的一个外部托管Flash Video文件用于播放。然而，和使用RTMP的媒体流不一样，HTTP“流”不支持实时广播。HTTP流要求一个定制的播放器以及包含每个关键帧精确开 始字节位置以及时间码的特定FlashVideo元数据的加入。使用这些特定的信息，定制Flash Video播放器可以要求在任何指定的关键帧中开始播放。例如，Google Video，Youtube和BitGravity支持渐进流下载，可以在缓存满之前查看视频的任何部分。在服务器侧，这种“假HTTP流“方式实现相当 简单，例如可以采用Apache的PHP模块，使用lighttpd。</p>
<p>四、采用RTMP协议的流，可提供的有Flash媒体服务器（以前称为Flash Communication Server），VCS，Electro Server，Helix Universal Serval，Wowza Pro，用于.NET的WebORB，用于Java的WebORB，以及开源的Red5服务器。在2008年4月，这个协议有流录像提供，不需要重新编码 的screencast软件。</p>
<p>　　RTMP，实时消息协议，Real Time Message Protocol是一个有Adobe System为在互联网的音频，视频和数据流开发的私有协议，运行在Flash播放器和服务器之间。RTMP协议有三个方式：<br>1、 通过在TCP上，使用1935端口的“纯”协议。 <br>2、 用于在穿越防火墙时，在HTTP请求中封装的RTMPT。 <br>3、 在HTTPS的安全连接中使用的RTPMS。</p>
<p>注：上述材料来源于wiki的整理。</p>
<p>编解码学习笔记（十二）：其他编解码</p>
<p>M-JPEG</p>
<p>　　M-JPEG（Motion-JoinPhotographicExpertsGroup）技术即运动静止图像（或逐帧）压缩技术，广泛应用于非线性编辑领域可精确到帧编辑和多层图像处理，把运动的视频序列作为连续的静止图像来处理，这种压缩方式单独完整地压缩每 一帧，在编辑过程中可随机存储每一帧，可进行精确到帧的编辑，此外M-JPEG的压缩和解压缩是对称的，可由相同的硬件和软件实现。</p>
<p>　　同样格式的MPEG视 频压缩不同于帧间压缩，因为压缩比特率比较低，所以编码与 解码相对比较容易，并不需要过多的运算能力，也使得软件或者芯片可以十分容易地对Motion JPEG进行编辑。也因为此，一些移动设备，如数码相机使用MotionJPEG来进行短片的编码。</p>
<p>Motion JPEG 2000</p>
<p>　　JPEG2000是基于小波变换的图像压缩标准，由Joint PhotographicExperts Group组织创建和维护。JPEG2000通常被认为是未来取代JPEG（基于离散余弦变换）的下一代图像压缩标准。JPEG2000文件的副档名通常为.jp2，MIME类型是image/jp2。</p>
<p>　　虽然JPEG2000在技术上有一定的优势，但是到目前为止（2006年），互联网上采用JPEG2000技术 制作的图像文件数量仍然很少，并且大多数的浏览器仍然没有缺省支持JPEG2000图像文件的显示。但是，由于 JPEG2000在无损压缩下仍然能有比较好的压缩率，所以JPEG2000在图像品质要求比较高的医学图像的分析和处理中已经有了一定程度的广泛应用。</p>
<p>DivX</p>
<p>文件名扩展： .divx</p>
<p>类型：DIVX</p>
<p>开发者： DivX，Inc</p>
<p>格式类型：媒体容器，用于MPEG-4 Part 2–compliant video</p>
<p>扩展来源：AVI</p>
<p>　　这是由MPEG－4衍生出的另一种视频编码(压缩)标准，也即通常所说的DVDrip格式，它采用了MPEG4 的压缩算法同时又综合了MPEG-4 与MP3各方面的技术，说白了就是使用DivX压缩技术对DVD盘片的视频图像进行高质量压缩，同时用MP3或AC3对音频进行压缩，然后再将视频与音频 合成并加上相应的外挂字幕文件而形成的视频格式。其画质直逼DVD并且体积只有DVD的数分之一。这种编码对机器的要求也不高，所以DivX视频编码技术 可以说是一种对DVD造成威胁最大的新生视频压缩格式，号称DVD杀手或DVD终结者。</p>
<p>　　DivX，是DivX公司（前身是DivXNetworks公司）的著名品牌，是一种MPEG-4技术视频编译码器（codec），2007年秋以2200万美元收购德国MainConcept。</p>
<p>　　ISO公布了“超低比特率活动图像和语音压缩标准 ”，排序MPEG－4,1998年10月批准第一版，1994年4月又公布了第二版及其校验模型（VM），MPEG－4正式编号是ISO/IEC国际标准 14496，它是一种新型的多媒体标准，它与前标准一个重要区别就在于，是一个基于对象的视编码压缩标准，所定义的码率控制的目标就是获得在给定码率下的最优质量，它为互联网上传输高质量的多媒体视频提供了很好的技术平台。</p>
<p>　　1998年微软开发了第一个在PC上使用的MPEG－4编码器，它包括MS MPEG4V1、MSMPEG4V2、MS MPEG4V3的系列编码内码，其中V1和V2用来制作AVI文件，一直到现在它都是作为Windows的默认组件，不过V1和V2的编码质量不是很好，一直到MS MPEG4V3才开始有好转，画质有了显着的进步，但是不知微软出于什么目的，却将这个MS MPEGV3的视频编码内核封闭，仅仅使其应用于Windows Media流媒体技术上，也就是我们熟悉的ASF流媒体文件中。ASF文件虽然有一些优势，但是由于过分的封闭不能被编辑，末得到广泛应用，这便惹怒了那些个不怕天不怕地的视频黑客和致力于钻研视频编码的高手，后来，这些小组不仅破解了微软的视频编码，而且经过他们的修改，一种新的视频编码诞生了：那就是 广为流传的MPEG编码器－DivX3.11。</p>
<p>　　DivX采用了MS的MPEGV3，改良后并加入自己功能称之为DivX3.11，也是目前互联网上普通采用的 MPEG－4编码器之一。很快，DivX被传得红得发紫，几乎成了业界的标准，但是，同样很快地出现了，DivX的基础技术是非法盗用微软的，微软声称将 对所有推动DivX发展的人、企业进行追究，可是DivX技术的创造者之一罗达（Rota）正全面申请将DivX合法化，这是基于DivX虽然是从 Window的发明出来的，但却没有用过任何微软的技术，更组建新公司DivXNetworks全力推广DivX，看来DivX（俗称压缩电影）蓬勃发展 的大潮是势不可挡了。</p>
<p>　　看来任何吸引眼球的故事在关键时刻都会发生转折，DivX的发展竟也不能脱离这一俗套，就在DivX顺利发展时 期，DivX的技术逐渐成熟，商机无限的时候，一台好戏上演了，DivXNetworks成立初衷就是摆脱微软的技术封闭，因而发起一个完全开放源码的项目，名为 “ Projet Mayo ”，目标是开发一套全新的、开放源码的MPEG4编码软件，由于它完全符合ISO　MPEG标准，又是完全开放源代码，OpenDivXCODEC吸引了 很多软件，视频高手参与，很快便开发出具有更高性能的编码器Encore2等等，就在DivX最辉煌的时期，DXN公司突然封闭了DivX的源代码，并在 Encore2的基础上发布了自有产品DivX4，原来DXN早就给自己留了后门，DivX采取的是LGPL协议，而不是GPL协议，虽说它们都是公共许 可证协议，保障自由使用和修改软件或源码的权利，但LGPL允许私有，DXN就是利用这一协议初其不备的耍出了大刀。</p>
<p>　　接着，很多被DXN公司狠狠涮了一回的软件、视频团体另起门户，逐渐重新聚拢开发力量，高举复仇大旗，在OpenDivX版本基础上，再次开发出一种新的MPEG－4编码–XviD，名字的顺序和DviX刚好相反，仅仅从名字就可以看出Xvid充满了复仇的力量。</p>
<p>　　DivX是近一两年来称霸网络视频的图像压缩编码标准。起初它是以微软MPEG 4视频编码标准为基础修改和开发的，并以免费方式发布。其特点是具有十分不错的压缩比率，可以将一整套DVD质量的影片压缩存放到一张CD-R光盘中。现 在的DivX分为普通版和Pro版，其中后者还有收费版和Adware（广告）版两种，自带DivX Player程序进行播放。用户如果安装了免费的DivX Codec后，也可用Windows Media player观看DivX影片。</p>
<p>注：上述材料来源于wiki的整理。</p>
<p>编解码学习笔记（十三）：容器（上篇）</p>
<p>视频是现在电脑中多媒体系统中的重要一环。为了适应储存视频的需要，人们设定了不同的视频文件格式来把视频和音频放在一个文件中，以方便同时回放。视频档实际上都是一个容器里面包裹着不同的轨道，使用的容器的格式关系到视频档的可扩展性。</p>
<p>　　FourCC全称Four-Character Codes，是由4个字符（4 bytes）组成，是一种独立标示视频数据流格式的四字节，在wav、avi档案之中会有一段FourCC来描述这个AVI档案，是利用何种codec来 编码的。因此wav、avi大量存在等于“IDP3”的FourCC。</p>
<p>ISO/IEC</p>
<p>MPEG-PS · MPEG-TS · MPEG-4 Part 12 /JPEG 2000 Part 12 · MPEG-4 Part 14</p>
<p>ITU-T</p>
<p>H.222.0</p>
<p>Others</p>
<p>3GP and 3G2 · ASF · AVI · Bink · DivX Media Format · DPX · EVO · Flash Video · GXF · M2TS · Matroska · MXF · Ogg · QuickTime File Format ·RealMedia · REDCODE RAW · RIFF · Smacker · MOD and TOD · VOB · WebM</p>
<p>Audio Only</p>
<p>AIFF · AU · WAV</p>
<p>3GP和3G2容器 　</p>
<p>　　3GP（3GPP文件格式）是一个多媒体容器由第三代合作伙伴计划（3GPP）针对3G UMTS多媒体服务定义。它用于3G移动电话，但也可以用于某些2G和4G的电话。3GP在ETSI 3GPP技术规范中定义，他是视频文件格式，并带有讲话/音频媒体类型和带时间信息的文本，用于IMS，MMS，多媒体广播/多播服务（MBMS）和传输端到端的包交换流媒体服务（PSS）。</p>
<p>　　3G2（3GPP2文件格式）是一个多媒体容器有3GPP2为3G CDMA 2000多媒体服务定义。她与3GP文件格式非常相似，但与之相比存在一些扩展和限制。3G2在3GPP2技术规范中定义。</p>
<p>　　3GP和3G2文件格式都是基于在ISO/IEC 14496-12（MPEG-4 Part 12）定义的ISO基础媒体文件格式，但是老板不的3GP文件格式不具有其中某些属性。3GP和3G2与MP4（MPEG-4 Part 14）相似，MP4也是基于MPEP-4 Part 12。3GP和3G2设计目的是为移动电话减少存储和带宽要求，它们是非常相似的标准，但有区别：</p>
<p>3GPP 文件格式用于GSM类电话，文件扩展名：.3gp</p>
<p>3GPP2文件格式用于CDMA类电话，并具有文件扩展名：.3g2</p>
<p>　　3GP文件存贮视频流：MPEG-4 Part2，H.263，MPEG-4 Part 10（AVC/H.264），音频流 AMR-NB, AMR-WB, AMR-WB+,AAC-LC, HE-AAC v1 和 Enhanced aacPlus (HE-AAC v2)。3GPP允许ISO基础文件格式（MPEG-4Part12）中使用AMR和H.263编解码，因为3GPP在ISO基础文件格式中规定了采样条目和模板字段的使用，可以为编解码定义新的box。这些 扩展在ISO基础媒体文家格式（“MP4家族”文件）中由登记授权登记为code-point。对于在3GP文件中存贮MPEG-4媒体，3GP规定参加了MP4和AVC文件格式规范，它们也是基于ISO基础媒体文件格式。MP4和AVC文件格式规范描述在ISO基础媒体文件格式中使用MPEG-4内容。 有些手机使用.mp4作为3GP视频的扩展。</p>
<p>　　3G2文件格式可以存贮与3GP文件格式相同的视频流和觉得部分的音频流。此外3G2可以存在音频流还包括 EVRC，EVRC-B，EVRC- WB，13K（QCELP），SMV，和VMR-WR。3G2规范还定义了在3GPP带时间文件的某些货站。3G2文件格式不支持Enhanced aacPlus (HE-AAC v2) 和AMR-WB+ audiostreams。对于在3G2文件中存在MPEG-4媒体（AAC音频，MPEG-4 Part 2音频，MPEG-4 Part 10/H.264/AVC），3G2规范提及了MP4 文件格式和AVC文件格式规范，在那里描述了如果在ISO基础媒体文件格式中使用这些内容。对于在3G2中存储H.263和AMR内容，3G2规范参见了 3GP文件格式规范。</p>
<p>　　3GP格式视频有两种分辨率：</p>
<p>分辨率176×144，适合市面上所有支持3GP格式的手机。</p>
<p>分辨率320×240，清晰，适合高档手机、MP4播放器、PSP以及苹果iPod.</p>
<p>ANIM</p>
<p>　　ANIM标准的多媒体文件用于经典的Commodore Amiga的数字动画。它遵循IFF ILBM主规范，他是第一个动画格式被操作系统正式采纳。</p>
<p>ASF</p>
<p>　　微软WMA和WMV的标准容器。</p>
<p>　　WMV（Windows Media Video）是微软公司开发的一组数字视频编解码格式的通称，ASF（Advanced Systems Format）是其封装格式。ASF封装的WMV档具有&quot;数字版权保护&quot;功能。扩展名:wmv/asf、wmvhd。</p>
<p>　　ASF (Advanced Streaming format高级流格式)。ASF 是 MICROSOFT为了和现在的 Real player 竞争而发展出来的一种可以直接在网上观看视频节目的文件压缩格式。ASF使用了 MPEG4 的压缩算法，压缩率和图像的质量都很不错。因为 ASF 是以一个可以在网上即时观赏的视频&quot;流&quot;格式存在的，所以它的图像质量比 VCD 差一点点并不出奇，但比同是视频&quot;流&quot;格式的 RAM 格式要好。</p>
<p>文件扩展名 ：.asf .wma .wmv</p>
<p>互联网媒体类型： video/x-ms-asf, application/vnd.ms-asf</p>
<p>类型码 ： ‘ASF_’</p>
<p>唯一类型码 ：Identifier com.microsoft.advanced-systems-format</p>
<p>Magic number ：30 26 b2 75</p>
<p>开发者 ：Microsoft</p>
<p>格式类型 ：Container format</p>
<p>容器容纳 ：WMA, WMV, MPEG4 etc.</p>
<p>AVI</p>
<p>　　AVI (the standard Microsoft Windows container, also based on RIFF)。AVI是英语Audio Video Interleave（&quot;音频视频交织&quot;或译为&quot;音频视频交错&quot;）的首字母缩写，由微软在 1992年11月推出的一种多媒体文件格式，用于对抗苹果Quicktime的技术。现在所说的AVI多是指一种封装格式。</p>
<p>　　比较早的AVI是Microsoft开发的。其含义是Audio Video Interactive，就是把视频和音频编码混合在一起存储。AVI也是最长寿的格式，已存在10余年了，虽然发布过改版（V2.0于1996年发布），但已显老态。AVI格式上限制比较多，只能有一个视频轨道和一个音频轨道（现在有非标准插件可加入最多两个音频轨道），还可以有一些附加轨道，如文字等。AVI格式不提供任何控制功能。扩展名：avi。</p>
<p>　　AVI能使用的编码：</p>
<p>视频名称（括号内表示的是此视频的FourCC） <br>o MPEG-1/-2 (MPEG/MPG1/MPG2)<br>o MPEG-4 (MP4V/XVID/DX50/DIVX/DIV5/3IVX/3IV2/RMP4)<br>o MS-MPEG4 (MPG4/MP42/MP43)<br>o WMV7/WMV8/WMV9 (WMV1/WMV2/WMV3)<br>o DV(DVSD/DVIS)<br>o Flash Video (FLV1/FLV4)<br>o Motion JPEG (MJPG)<br>o LossLess JPEG (LJPG)<br>o H.264 (AVC1/DAVC/H264/X264)<br>o H.263 (H263/S263)<br>o H.261 (H261)<br>o Huffyuv (HFYU)<br>o AVIzlib (ZLIB)<br>o AVImszh (MSZH)<br>o Theora (THEO)<br>o Indeo Video (IV31/IV32)<br>o Cinepak (cvid)<br>o Microsoft Video 1 (CRAM)<br>o On2VP3 (VP30/VP31)<br>o On2VP4 (VP40)<br>o On2 VP6 (VP60/VP61/VP62)<br>o VC-1 (WVC1)</p>
<p>音频 <br>o PCM<br>o MP3 (0x0055)<br>o AC-3 (0x0092)<br>o AAC <br>　　－ HE-AAC<br>　　－ LC-AAC<br>o FLAC<br>o Indeo Audio<br>o TrueSpeech<br>o WMA<br>o Vorbis</p>
<p>　　编码组合能根据以下的例子自由选择。</p>
<p>(DivX或XviD+MP3).avi，</p>
<p>(H.264+MP3).avi</p>
<p>(WMV9+MP3).avi</p>
<p>　　以XviD+MP3构成的AVI最为常见。</p>
<p>DVB－MS</p>
<p>　　DVR-MS (Microsoft Digital Video Recording，微软数字视频录制)是一种专用的视频和音频文件容器格式，有微软开发，用于存储由Windows XPMedia Center Edition，Windows Vista和Windows 7录制的电视内容。多个数据流（视频和音频）在带有DVR-MS扩展的ASF容器中封装。视频使用MPEG-2标准编码，音频使用MPEG-1 Layer II或者杜比数字AC-3(ATSC A/52)。扩展的格式包括内容和数字版权管理的元数据。这些格式的文件有流缓存引擎（SBE.dll）生成，这是一个在Windows XP Service Pack 1的DirectShow组件。</p>
<p>MPEG/MPG/DAT</p>
<p>　　MPEG格 式：MPEG(Moving Picture Experts Group)，是一个国际标准组织（ISO）认可的媒体封装形式，受到大部份机器的支持。其存储方式多样，可以适应不同的应用环境。MPEG-4档的档容 器格式在Part 1(mux)、14(asp)、15(avc)等中规定。MPEG的控制功能丰富，可以有多个视频（即角度）、音轨、字幕（位图字幕）等等。MPEG的一个简化版本3GP还广泛的用于准3G手机上。扩展名:dat(用于VCD)、vob、mpg/mpeg、3gp/3g2（用于手机）等。</p>
<p>　　MPEG也是Motion Picture Experts Group 的缩写。这类格式包括了 MPEG-1, MPEG-2 和 MPEG-4在内的多种视频格式。MPEG-1相信是大家接触得最多的了，因为目前其正在被广泛地应用在 VCD 的制作和一些视频片段下载的网络应用上面，大部分的 VCD 都是用 MPEG1 格式压缩的( 刻录软件自动将MPEG1转为 .DAT格式 ) ，使用 MPEG-1 的压缩算法，可以把一部 120 分钟长的电影压缩到 1.2 GB 左右大小。MPEG-2 则是应用在 DVD 的制作，同时在一些 HDTV（高清晰电视广播）和一些高要求视频编辑、处理上面也有相当多的应用。使用MPEG-2 的压缩算法压缩一部 120 分钟长的电影可以压缩到 5-8 GB 的大小（MPEG2的图像质量MPEG-1 与其无法比拟的）。</p>
<p>　　MPEG-PS：MPEG节目流（programstream），是MPEG-1和MPEG-2基准流的标准容器，用于在可靠介质上，例如磁盘，也用于DVD-Video光碟。</p>
<p>　　MPEG-TS：MPEG传输流，是数字广播和在非可靠媒体传输的标砖容器，也在蓝光光碟使用，通常携带多个视频和音频流以及一个电子节目指南。</p>
<p>ｎ AVI</p>
<p>　　如果你发现原来的播放软件突然打不开此类格式的AVI文件，那你就要考虑是不是碰到了n AVI。n AVI是 New AVI 的缩写，是一个名为 Shadow Realm 的地下组织发展起来的一种新视频格式。它是由MicrosoftASF 压缩算法的修改而来的（并不是想象中的 AVI），视频格式追求的无非是压缩率和图像质量，所以 NAVI 为了追求这个目标，改善了原始的 ASF 格式的一些不足，让 NAVI 可以拥有更高的帧率。可以这样说，NAVI 是一种去掉视频流特性的改良型 ASF 格式。</p>
<p>注：上述材料来源于wiki的整理。</p>
<p>编解码学习笔记（十四）：容器（下篇）</p>
<p>Matroska（MKV）</p>
<p>　　MKV ，不是任何的编解码或者系统的标准，但实际上可封装任何的东西。是一个开放以及开源的容器格式。</p>
<p>扩展名 　　　　　.mkv .mka .mks <br>互联网媒体类型 　video/x-matroska audio/x-matroska 开<br>发者 　　　　　　Matroska.org <br>格式 　　　　　　视频文件格式 <br>专门属 　　　　　多媒体 <br>自由文件格式？ 　Yes: GNU LGPL</p>
<p>　　Matroska，很多人把它当作为MKV，其实MKV只 是Matroska媒体系列的其中一种文件。Matroska是一种新的多媒体封装格式，这个封装格式可把多种不同编码的视频及16条或以上不同格式的音频和语言不同的字幕封装到一个Matroska Media档内。它也是其中一种开放源代码的多媒体封装格式。</p>
<p>　　多媒体封装格式，简称MCF、多媒体容器，是一个开放（没有身份规限，免费）及自由把数据存放的格式。开发者承诺大家可以自 由地使用这种格式和经这种格式所开发的软件；又不会在这种格式普遍的时候变成一个商业的科研项目。</p>
<p>Matroska媒体定义了三种类型的档：</p>
<p>MKV (Matroska Video File) ：视频档，可以包含音频和字幕；</p>
<p>MKA (Matroska Audio File) ：单一的音频档，可以有多条及多种类型的音轨；</p>
<p>MKS (Matroska Subtitles) ：字幕文件。</p>
<p>　　这三种文件中以MKV最为常见。</p>
<p>　　Matroska最大的特点就是能容纳多种不同类型的视频编码、音频编码及字幕流，并且它能把非常高密的RealMedia及QuickTime文 件也容纳在内，同时将它们的音频和视频重新组织起来，从而达到一个更好和鲜明的效果。</p>
<p>　　Matroska的开发是对多种传统媒体格式的一次大挑战，虽则如此，Matroska也被开发成一个多功能的多媒体容器。</p>
<p>MP４</p>
<p>　　MP4，是MPEG-4定义的标准音视频容器，基于ISO基础媒体文件格式（在MPEG-4 Part 12以及JPEG 2000 Part 12中定义），在MPEG-4 Part 14中描述。是一种使用MPEG-4的多媒体电脑档案格式，副档名为.mp4，以储存数码音讯及数码视讯为主。</p>
<p>扩展名 　　　　.mp4 <br>互联网媒体类型 video/mp4, audio/mp4, application/mp4 <br>类型代码 　　　mpg4 <br>开发者　　　　 ISO <br>格式 　　　　　视频文件格式 <br>专门属 　　　　Audio, video, text<br>延伸自 　　　　QuickTime .mov and MPEG-4 Part 12 <br>标准　　　　　 ISO/IEC 14496-14</p>
<p>MOD</p>
<p>　　MOD格式是JVC生产的 硬盘摄录机所采用的存储格式名称。</p>
<p>MOV</p>
<p>　　MOV是评估公司的标准QuickTime视频容器。QuickTime Movie是由苹果公司 开发的容器，由于苹果电脑在专业图形领域的统治地位，QuickTime格式格式基本上成为电影制作行业的通用格式。1998年2月11 日,国际标准组织（ISO）认可QuickTime文件格式作为MPEG-4标准的基础。QT可存储的内容相当丰富，除了视频、音频以外还可支持图片、文字（文本字幕）等。扩展名：mov</p>
<p>　　使用过Mac机的朋友应该多少接触过QuickTime。QuickTime原本是Apple公司用于Mac计 算机上的一种图像视频处理软件。 Quick-Time提供了两种标准图像和数字视频格式 , 即可以支持静态的PIC和JPG图像格式，动态的基于Indeo压缩法的MOV和基于MPEG压缩法的MPG视频格式。</p>
<p>Ogg</p>
<p>　　Ogg是Xiph.org音频编解码Vorbis和视频编解码Theora的标砖容器，Ogg Media一个完全开放性的多媒体系统计划，OGM（Ogg Media File）是其容器格式。OGM可以支持多视频、音频、字幕（文本字幕）等多种轨道。扩展名：ogg。</p>
<p>OGM</p>
<p>　　OGM（Ogg Media），是Xiph.ofg的视频编解码容器，已经不再支持，并不鼓励使用。</p>
<p>RealMedia</p>
<p>　　RealMedia是RealVideo和RealAudio的标准容器。Real Video或者称Real Media(RM)档是由RealNetworks开发的一种档容器。它通常只能容纳Real Video和Real Audio编码的媒体。该档带有一定的交互功能，允许编写脚本以控制播放。RM,尤其是可变比特率的RMVB格式，体积很小，非常受到网络下载者的欢迎。 扩展名：rm/rmvb</p>
<p>　RM</p>
<p>　　Real Networks公司所制定的音频/视频压缩规范Real Media中的一种，Real Player能做的就是利用Internet资源对这些符合Real Media技术规范的音频/视频进行实况转播。在Real Media规范中主要包括三类文件：RealAudio、Real Video和Real Flash （Real Networks公司与Macromedia公司合作推出的新一代高压缩比动画格式）。REAL VIDEO （RA、RAM）格式由一开始就是定位就是在视频流应用方面的，也可以说是视频流技术的始创者。它可以在用 56K MODEM 拨号上网的条件实现不间断的视频播放，可是其图像质量比VCD差些，如果您看过那些RM压缩的影碟就可以明显对比出来了。</p>
<p>　RMVB</p>
<p>　　这是一种由RM视频格式升级延伸出的新视频格式，它的先进之处在于RMVB视频格式打破了原先RM格式那种平均 压缩采样的方式，在保证平均压缩比的 基础上合理利用比特率资源，就是说静止和动作场面少的画面场景采用较低的编码速率，这样可以留出更多的带宽空间，而这些带宽会在出现快速运动的画面场景时被利用。这样在保证了静止画面质量的前提下，大幅地提高了运动图像的画面质量，从而图像质量和文件大小之间就达到了微妙的平衡。另外，相对于DVDrip 格式，RMVB视频也是有着较明显的优势，一部大小为700MB左右的DVD影片，如果将其转录成同样视听品质的RMVB格式，其个头最多也就400MB 左右。不仅如此，这种视频格式还具有内置字幕和无需外挂插件支持等独特优点。要想播放这种视频格式，可以使用RealOne Player2.0或RealPlayer8.0加RealVideo9.0以上版本的解码器形式进行播放。</p>
<p>VOB</p>
<p>　　VOB文件（video Object）是一个DVD视频媒体的容器格式。VOB可以包含视频，音频，字母和菜单整合在一个流格式中。VOB是基于MPEG PS格式，但是有额外的限制和私有流的规范。MPEG PS提供非标准数据称为私有流。VOB文件是MEPG PS表站中非常严格的子集。经所有的VOB文件都是MPEG PS，但不是所有的MPEG PS都遵守VOB文件的定义。</p>
<p>　　与MPEG的PS相似，VOB文件可以包含H.262/MPEG-2 Part2或者MPEG-1 Part 2视频，MPEG-1 Audio LayerII或者MOEG-2 Audio Layer II音频，但是和MPEG PS相比，在VOB文件中使用这些压缩格式有某些限制。此外，VOB可以包括线性PCM，AC-3或者DTS视频以及字母。VOB文件不能包含AAC音频（MPEG-2 Part 7），MPEG-4压缩格式或者其他，而这些在MPEG PS标准中是允许的。</p>
<p>　　文件扩展名 .VOB <br>　　开发者： 　DVD Forum <br>　　类型：　　 媒体容器 <br>　　包含：　　 音频，视频，字母 <br>　　用于： 　　DVD-Video <br>　　从何扩展： MPEG program stream, ISO/IEC 13818-1 <br>　　标准规范： DVD-Video Book</p>
<p>注：上述材料来源于wiki的整理。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解PackageManagerService</title>
    <url>/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PackageManagerService/</url>
    <content><![CDATA[<p>第4章  深入理解PackageManagerService</p>
<p>本章主要内容：</p>
<p>详细分析PackageManagerService</p>
<p>本章所涉及的源代码文件名及位置：</p>
<p>·  SystemServer.java</p>
<p>frameworks/base/services/java/com/android/server/SystemServer.java</p>
<p>·   IPackageManager.aidl</p>
<p>frameworks/base/core/android/java/content/pm/IPackageManager.aidl</p>
<p>·  PackageManagerService.java</p>
<p>frameworks/base/services/java/com/android/server/pm/PackageManagerService.java</p>
<p>·  Settings.java</p>
<p>frameworks/base/services/java/com/android/server/pm/Settings.java</p>
<p>·  SystemUI的AndroidManifest.xml</p>
<p>frameworks/base/package/systemui/AndroidManifest.xml</p>
<p>·  PackageParser.java</p>
<p>frameworks/base/core/java/android/content/pm/PackageParser.java</p>
<p>·  commandline.c</p>
<p>system/core/adb/commandline.c</p>
<p>·  installd.c</p>
<p>frameworks/base/cmds/installd/installd.c</p>
<p>·  commands.c</p>
<p>frameworks/base/cmds/installd/commands.c</p>
<p>·  pm脚本文件</p>
<p>frameworks/base/cmds/pm/pm</p>
<p>·  Pm.java</p>
<p>frameworks/base/cmds/pm/src/com/android/commands/pm/Pm.java</p>
<p>·  DefaultContainerService.java</p>
<p>frameworks/base/packages/defaultcontainerservice/src/com/android/defaultcontainerservice/DefaultContainerService.java</p>
<p>·  UserManager.java</p>
<p>frameworks/base/services/java/com/android/server/pm/UserManager.java</p>
<p>·  UserInfo.java</p>
<p>frameworks/base/core/android/java/content/pm/UserInfo.java</p>
<p>4.1  概述</p>
<p>PackageManagerService是本书分析的第一个核心服务，也是Android系统中最常用的服务之一。它负责系统中Package的管理，应用程序的安装、卸载、信息查询等。图4-1展示了PackageManagerService及客户端的类家族。</p>
<p>图4-1  PackageManagerService及客户端类家族</p>
<p>由图4-1可知：</p>
<p>·  IPackageManager接口类中定义了服务端和客户端通信的业务函数，还定义了内部类Stub，该类从Binder派生并实现了IPackageManager接口。</p>
<p>·  PackageManagerService继承自IPackageManager.Stub类，由于Stub类从Binder派生，因此PackageManagerService将作为服务端参与Binder通信。</p>
<p>·  Stub类中定义了一个内部类Proxy，该类有一个IBinder类型（实际类型为BinderProxy）的成员变量mRemote，根据第2章介绍的Binder系统的知识，mRemote用于和服务端PackageManagerService通信。</p>
<p>·  IPackageManager接口类中定义了许多业务函数，但是出于安全等方面的考虑，Android对外（即SDK）提供的只是一个子集，该子集被封装在抽象类PackageManager中。客户端一般通过Context的getPackageManager函数返回一个类型为PackageManager的对象，该对象的实际类型是PackageManager的子类ApplicationPackageManager。这种基于接口编程的方式，虽然极大降低了模块之间的耦合性，却给代码分析带来了不小的麻烦。</p>
<p>·  ApplicationPackageManager类继承自PackageManager类。它并没有直接参与Binder通信，而是通过mPM成员变量指向一个IPackageManager.Stub.Proxy类型的对象。</p>
<p>提示读者在源码中可能找不到IPackageManager.java文件。该文件在编译过程中是经aidl工具处理IPackageManager.aidl后得到，最终的文件位置在Android源码/out/target</p>
<p>/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/content/pm/目录中。如果读者没有整体编译过源码，也可使用aidl工具单独处理IPackageManager.aidl。</p>
<p>aidl工具生成的结果文件有着相似的代码结构。读者不妨看看下面这个笔者通过编译生成的IPackageManager.java文件。注意，aidl工具生成的结果文件没有格式缩进，所以看起来惨不忍睹，读者可用Eclipse中的源文件格式化命令处理它。</p>
<p>[–&gt;IPackageManager.java]</p>
<p>public interface IPackageManager extendsandroid.os.IInterface {</p>
<p>     //定义内部类Stub，派生自Binder，实现IPackageManager接口</p>
<p>      publicstatic abstract class Stub extends android.os.Binder</p>
<p>                      implements  android.content.pm.IPackageManager {</p>
<p>            privatestatic final java.lang.String DESCRIPTOR =</p>
<p>                                   &quot;android.content.pm.IPackageManager&quot;;</p>
<p>            publicStub() {</p>
<p>                 this.attachInterface(this,DESCRIPTOR);</p>
<p>             }</p>
<p>            ……</p>
<p>               //定义Stub的内部类Proxy，实现IPackageManager接口</p>
<p>            privatestatic class Proxy implements</p>
<p>                                   android.content.pm.IPackageManager{</p>
<p>                  //通过mRemote变量和服务端交互</p>
<p>                 private android.os.IBinder mRemote;</p>
<p>                         Proxy(android.os.IBinderremote) {</p>
<p>                         mRemote = remote;</p>
<p>                        }</p>
<p>                           ……</p>
<p>              }</p>
<p>          ……</p>
<p>}</p>
<p>接下来分析PackageManagerService，为书写方便起见，以后将其简称为PKMS。</p>
<p>4.2  初识PackageManagerService</p>
<p>PKMS作为系统的核心服务，由SystemServer创建，相关代码如下：</p>
<p>[–&gt;SystemServer.java]</p>
<p>……//ServerThread的run函数</p>
<p> /*</p>
<p> 4.0新增的一个功能，即设备加密（encrypting the device）,该功能由</p>
<p> 系统属性vold.decrypt指定。这部分功能比较复杂，本书暂不讨论。</p>
<p> 该功能对PKMS的影响就是通过onlyCore实现的，该变量用于判断是否只扫描系统库</p>
<p> （包括APK和Jar包）</p>
<p> */</p>
<p> StringcryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</p>
<p> booleanonlyCore = false;</p>
<p> //ENCRYPTING_STATE的值为&quot;trigger_restart_min_framework&quot;</p>
<p> if(ENCRYPTING_STATE.equals(cryptState)) {</p>
<p>       ……</p>
<p>      onlyCore = true;</p>
<p> } else if(ENCRYPTED_STATE.equals(cryptState)) {</p>
<p>       ……//ENCRYPTED_STATE的值为&quot;1&quot;</p>
<p>     onlyCore = true;</p>
<p> }</p>
<p> //①调用PKMS的main函数，第二个参数用于判断是否为工厂测试，我们不讨论的这种情况，</p>
<p> //假定onlyCore的值为false</p>
<p> pm =PackageManagerService.main(context,</p>
<p>           factoryTest !=SystemServer.FACTORY_TEST_OFF,onlyCore);</p>
<p> booleanfirstBoot = false;</p>
<p> try {</p>
<p>         //判断本次是否为初次启动。当Zygote或SystemServer退出时，init会再次启动</p>
<p>        //它们，所以这里的FirstBoot是指开机后的第一次启动</p>
<p>        firstBoot = pm.isFirstBoot();</p>
<p> }</p>
<p>……</p>
<p>  try {</p>
<p>        //②做dex优化。dex是Android上针对Java字节码的一种优化技术，可提高运行效率</p>
<p>       pm.performBootDexOpt();</p>
<p>  }</p>
<p> ……</p>
<p>  try {</p>
<p>        pm.systemReady();//③通知系统进入就绪状态</p>
<p> }</p>
<p>……</p>
<p>}//run函数结束</p>
<p>以上代码中共有4个关键调用，分别是：</p>
<p>·  PKMS的main函数。这个函数是PKMS的核心，稍后会重点分析它。</p>
<p>·  isFirstBoot、performBootDexOpt和systemReady。这3个函数比较简单。学完本章后，读者可完全自行分析它们，故这里不再赘述。</p>
<p>首先分析PKMS的main函数，它是核心函数，此处单独用一节进行分析。</p>
<p>4.3  PKMS的main函数分析</p>
<p>PKMS的main函数代码如下：</p>
<p>[–&gt;PackageManagerService.java]</p>
<p>public static final IPackageManager main(Contextcontext, boolean factoryTest,</p>
<p>           boolean onlyCore) {</p>
<p>        //调用PKMS的构造函数，factoryTest和onlyCore的值均为false</p>
<p>       PackageManagerService m = new PackageManagerService(context,</p>
<p>                                            factoryTest, onlyCore);</p>
<p>        //向ServiceManager注册PKMS</p>
<p>       ServiceManager.addService(&quot;package&quot;, m);</p>
<p>       return m;</p>
<p> }</p>
<p>main函数很简单，只有短短几行代码，执行时间却较长，主要原因是PKMS在其构造函数中做了很多“重体力活”，这也是Android启动速度慢的主要原因之一。在分析该函数前，先简单介绍一下PKMS构造函数的功能。</p>
<p>PKMS构造函数的主要功能是，扫描Android系统中几个目标文件夹中的APK，从而建立合适的数据结构以管理诸如Package信息、四大组件信息、权限信息等各种信息。抽象地看，PKMS像一个加工厂，它解析实际的物理文件（APK文件）以生成符合自己要求的产品。例如，PKMS将解析APK包中的AndroidManifest.xml，并根据其中声明的Activity标签来创建与此对应的对象并加以保管。</p>
<p>PKMS的工作流程相对简单，复杂的是其中用于保存各种信息的数据结构和它们之间的关系，以及影响最终结果的策略控制（例如前面代码中的onlyCore变量，用于判断是否只扫描系统目录）。曾经阅读过PKMS的读者可能会发现，代码中大量不同的数据结构以及它们之间的关系会令人大为头疼。所以，本章除了分析PKMS的工作流程外，也将关注重要的数据结构及它们的作用。</p>
<p>PKMS构造函数的工作流程大体可分三个阶段：</p>
<p>·  扫描目标文件夹之前的准备工作。</p>
<p>·  扫描目标文件夹。</p>
<p>·  扫描之后的工作。</p>
<p>该函数涉及到的知识点较多，代码段也较长，因此我们将通过分段讨论的方法，集中解决相关的重点问题。</p>
<p>4.3.1  构造函数分析之前期准备工作</p>
<p>下面开始分析构造函数第一阶段的工作，先看如下所示的代码。</p>
<p>[–&gt;PackageManagerService.java::构造函数]</p>
<p>public PackageManagerService(Context context,boolean factoryTest,</p>
<p>                                  booleanonlyCore) {</p>
<p>       ……</p>
<p>        if(mSdkVersion &lt;= 0) {</p>
<p>           /*</p>
<p>             mSdkVersion是PKMS的成员变量，定义的时候进行赋值，其值取自系统属性</p>
<p>             “ro.build.version.sdk”，即编译的SDK版本。如果没有定义，则APK</p>
<p>             就无法知道自己运行在Android哪个版本上</p>
<p>          */</p>
<p>           Slog.w(TAG, &quot;**** ro.build.version.sdk not set!&quot;);//打印一句警告</p>
<p>        }</p>
<p>       mContext = context;</p>
<p>        mFactoryTest= factoryTest;//假定为false，即运行在非工厂模式下</p>
<p>       mOnlyCore = onlyCore;//假定为false，即运行在普通模式下</p>
<p>        //如果此系统是eng版，则扫描Package后，不对package做dex优化</p>
<p>       mNoDexOpt =&quot;eng&quot;.equals(SystemProperties.get(&quot;ro.build.type&quot;));</p>
<p>       //mMetrics用于存储与显示屏相关的一些属性，例如屏幕的宽/高尺寸，分辨率等信息</p>
<p>       mMetrics = new DisplayMetrics();</p>
<p>       //Settings是一个非常重要的类，该类用于存储系统运行过程中的一些设置，</p>
<p>        //下面进行详细分析        mSettings = new Settings();</p>
<p>       //①addSharedUserLPw是什么？马上来分析</p>
<p>       mSettings.addSharedUserLPw(&quot;android.uid.system&quot;,</p>
<p>               Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);</p>
<p>       mSettings.addSharedUserLPw(&quot;android.uid.phone&quot;,</p>
<p>               MULTIPLE_APPLICATION_UIDS  //该变量的默认值是true</p>
<p>                        ? RADIO_UID :FIRST_APPLICATION_UID,</p>
<p>               ApplicationInfo.FLAG_SYSTEM);</p>
<p>       mSettings.addSharedUserLPw(&quot;android.uid.log&quot;,</p>
<p>               MULTIPLE_APPLICATION_UIDS</p>
<p>                        ? LOG_UID :FIRST_APPLICATION_UID,</p>
<p>               ApplicationInfo.FLAG_SYSTEM);</p>
<p>       mSettings.addSharedUserLPw(&quot;android.uid.nfc&quot;,</p>
<p>               MULTIPLE_APPLICATION_UIDS</p>
<p>                        ? NFC_UID :FIRST_APPLICATION_UID,</p>
<p>               ApplicationInfo.FLAG_SYSTEM);</p>
<p>       ……//第一段结束</p>
<p>刚进入构造函数，就会遇到第一个较为复杂的数据结构Setting及它的addSharedUserLPw函数。Setting的作用是管理Android系统运行过程中的一些设置信息。到底是哪些信息呢？来看下面的分析。</p>
<p>1.  初识Settings</p>
<p>先分析addSharedUserLPw函数。此处截取该函数的调用代码，如下所示：</p>
<p>mSettings.addSharedUserLPw(&quot;android.uid.system&quot;,//字符串</p>
<p>              Process.SYSTEM_UID, //系统进程使用的用户id，值为1000</p>
<p>              ApplicationInfo.FLAG_SYSTEM//标志系统Package</p>
<p>);</p>
<p>以此处的函数调用为例，我们为addSharedUserLPw传递了3个参数：</p>
<p>第一个是字符串“android.uid.system“；第二个是SYSTEM_UID，其值为1000；第三个是FLAG_SYSTEM标志，用于标识系统Package。</p>
<p>在进入对addSharedUserLPw函数的分析前，先介绍一下SYSTEM_UID 及相关知识。</p>
<p>（1） Android系统中UID/GID介绍</p>
<p>UID为用户ID的缩写，GID为用户组ID的缩写，这两个概念均与Linux系统中进程的权限管理有关。一般说来，每一个进程都会有一个对应的UID（即表示该进程属于哪个user，不同user有不同权限）。一个进程也可分属不同的用户组（每个用户组都有对应的权限）。</p>
<p>提示Linux的UID/GID还可细分为几种类型，此处我们仅考虑普适意义的UID/GID。</p>
<p>如上所述，UID/GID和进程的权限有关。在Android平台中，系统定义的UID/GID在Process.java文件中，如下所示：</p>
<p>[–&gt;Process.java]</p>
<p>   //系统进程使用的UID/GID，值为1000</p>
<p>   publicstatic final int SYSTEM_UID = 1000;</p>
<p>   //Phone进程使用的UID/GID，值为1001</p>
<p>   publicstatic final int PHONE_UID = 1001;</p>
<p>   //shell进程使用的UID/GID，值为2000</p>
<p>   publicstatic final int SHELL_UID = 2000;</p>
<p>   //使用LOG的进程所在的组的UID/GID为1007</p>
<p>   publicstatic final int LOG_UID = 1007;</p>
<p>   //供WIF相关进程使用的UID/GID为1010</p>
<p>   publicstatic final int WIFI_UID = 1010;</p>
<p>  //mediaserver进程使用的UID/GID为1013</p>
<p>   publicstatic final int MEDIA_UID = 1013;</p>
<p>   //设置能读写SD卡的进程的GID为1015</p>
<p>   publicstatic final int SDCARD_RW_GID = 1015;</p>
<p>   //NFC相关的进程的UID/GID为1025</p>
<p>   publicstatic final int NFC_UID = 1025;</p>
<p>   //有权限读写内部存储的进程的GID为1023</p>
<p>   publicstatic final int MEDIA_RW_GID = 1023;</p>
<p>   //第一个应用Package的起始UID为10000</p>
<p>   publicstatic final int FIRST_APPLICATION_UID = 10000;</p>
<p>   //系统所支持的最大的应用Package的UID为99999</p>
<p>   publicstatic final int LAST_APPLICATION_UID = 99999;</p>
<p>   //和蓝牙相关的进程的GID为2000</p>
<p>   publicstatic final int BLUETOOTH_GID = 2000;</p>
<p>对不同的UID/GID授予不同的权限，接下来就介绍和权限设置相关的代码。</p>
<p>提示读者可用adb shell（将什么？）登录到自己的手机，然后用busybox提供的ps命令查看进程的UID。</p>
<p>下面分析addSharedUserLPw函数，代码如下：</p>
<p>[–&gt;Settings.java]</p>
<p>SharedUserSetting addSharedUserLPw(String name,int uid, int pkgFlags) {</p>
<p>      /*</p>
<p>        注意这里的参数：name为字符串”android.uid.system”,uid为1000，pkgFlags为</p>
<p>        ApplicationInfo.FLAG_SYSETM(以后简写为FLAG_SYSTEM)</p>
<p>      */</p>
<p>       //mSharedUsers是一个HashMap，key为字符串，值为SharedUserSetting对象</p>
<p>       SharedUserSetting s = mSharedUsers.get(name);</p>
<p>        if(s != null) {</p>
<p>           if (s.userId == uid) {</p>
<p>               return s;</p>
<p>           }……</p>
<p>           return null;</p>
<p>        }</p>
<p>        //创建一个新的SharedUserSettings对象，并设置的userId为uid，</p>
<p>       //SharedUserSettings是什么？有什么作用？</p>
<p>        s =new SharedUserSetting(name, pkgFlags);</p>
<p>       s.userId = uid;</p>
<p>        if(addUserIdLPw(uid, s, name)) {</p>
<p>           mSharedUsers.put(name, s);//将name与s键值对添加到mSharedUsers中保存</p>
<p>           return s;</p>
<p>        }</p>
<p>       return null;</p>
<p>    }</p>
<p>从以上代码可知，Settings中有一个mSharedUsers成员，该成员存储的是字符串与SharedUserSetting键值对，也就是说以字符串为key得到对应的SharedUserSetting对象。</p>
<p>那么SharedUserSettings是什么？它的目的是什么？来看一个例子。</p>
<p>（2） SharedUserSetting分析</p>
<p>该例子来源于SystemUI的AndroidManifest.xml，如下所示：</p>
<p>[–&gt;SystemUI的AndroidManifest.xml]</p>
<p>&lt;manifestxmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&quot;</p>
<p>       package=&quot;com.android.systemui&quot;</p>
<p>       coreApp=&quot;true&quot;</p>
<p>        android:sharedUserId=&quot;android.uid.system&quot;</p>
<p>       android:process=&quot;system&quot;&gt;</p>
<p> ……</p>
<p>在xml中，声明了一个名为android:sharedUserId的属性，其值为“android.uid.system”。sharedUserId看起来和UID有关，确实如此，它有两个作用：</p>
<p>·  两个或多个声明了同一种sharedUserIds的APK可共享彼此的数据，并且可运行在同一进程中。</p>
<p>·  更重要的是，通过声明特定的sharedUserId，该APK所在进程将被赋予指定的UID。例如，本例中的SystemUI声明了system的uid，运行SystemUI的进程就可享有system用户所对应的权限（实际上就是将该进程的uid设置为system的uid）了。</p>
<p>提示除了在AndroidManifest.xml中声明sharedUserId外，APK在编译时还必须使用对应的证书进行签名。例如本例的SystemUI，在其Android.mk中需要额外声明LOCAL_CERTIFICATE := platform，如此，才可获得指定的UID。</p>
<p>通过以上介绍，读者能知道如何组织一种数据结构来包括上面的内容。此处有三个关键点需注意：</p>
<p>·  XML中sharedUserId属性指定了一个字符串，它是UID的字符串描述，故对应数据结构中也应该有这样一个字符串，这样就把代码和XML中的属性联系起来了。</p>
<p>·  在Linux系统中，真正的UID是一个整数，所以该数据结构中必然有一个整型变量。</p>
<p>·  多个Package可声明同一个sharedUserId，因此该数据结构必然会保存那些声明了相同sharedUserId的Package的某些信息。</p>
<p>了解了上面三个关键点，再来看Android是如何设计相应数据结构的，如图4-2所示。</p>
<p>图4-2  SharedUserSetting类的关系图</p>
<p>由图4-2可知：</p>
<p>·  Settings类定义了一个mSharedUsers成员，它是一个HashMap，以字符串（如“android.uid.system”）为Key，对应的Value是一个SharedUserSettings对象。</p>
<p>·  SharedUserSetting派生自GrantedPermissions类，从GrantedPermissions类的命名可知，它和权限有关。SharedUserSetting定义了一个成员变量packages，类型为HashSet，用于保存声明了相同sharedUserId的Package的权限设置信息。</p>
<p>·  每个Package有自己的权限设置。权限的概念由PackageSetting类表达。该类继承自PackagesettingBase，而PackageSettingBase又继承自GrantedPermissions。</p>
<p>·  Settings中还有两个成员，一个是mUserIds，另一个是mOtherUserIds，这两位成员的类型分别是ArrayList和SparseArray。其目的是以UID为索引，得到对应的SharedUserSettings对象。在一般情况下，以索引获取数组元素的速度，比以key获取HashMap中元素的速度要快很多。</p>
<p>提示 根据以上对mUserIds和mOtherUserIds的描述，可知这是典型的以空间换时间的做法。</p>
<p>下边来分析addUserIdLPw函数，它的功能就是将SharedUserSettings对象保存到对应的数组中，代码如下：</p>
<p>[–&gt;Settings.java]</p>
<p>private boolean addUserIdLPw(int uid, Object obj, Objectname) {</p>
<p>         //uid不能超出限制。Android对UID进行了分类，应用APK所在进程的UID从10000开始，</p>
<p>        //而系统APK所在进程小于10000</p>
<p>        if(uid &gt;= PackageManagerService.FIRST_APPLICATION_UID +</p>
<p>                            PackageManagerService.MAX_APPLICATION_UIDS){</p>
<p>           return false;</p>
<p>        }</p>
<p>        if(uid &gt;= PackageManagerService.FIRST_APPLICATION_UID) {</p>
<p>           int N = mUserIds.size();</p>
<p>          //计算索引，其值是uid和FIRST_APPLICATION_UID的差</p>
<p>           final int index = uid - PackageManagerService.FIRST_APPLICATION_UID;</p>
<p>           while (index &gt;= N) {</p>
<p>               mUserIds.add(null);</p>
<p>               N++;</p>
<p>           }</p>
<p>            ……//判断该索引位置的内容是否为空，为空才保存</p>
<p>           mUserIds.set(index, obj);//mUserIds保存应用Package的UID</p>
<p>        }else {</p>
<p>           ……</p>
<p>            mOtherUserIds.put(uid, obj);//系统Package的UID由mOtherUserIds保存</p>
<p>        }</p>
<p>       return true;</p>
<p>}</p>
<p>至此，对Settings的分析就告一段落了。在这次“行程”中，我们重点分析了UID/GID以及SharedUserId方面的知识，并见识好几个重要的数据结构。希望读者通过SystemUI的实例能够理解这些数据结构存在的目的。</p>
<p>2.  XML文件扫描</p>
<p>下面继续分析PKMS的构造函数，代码如下：</p>
<p>[–&gt;PackageMangerService.java::构造函数]</p>
<p>       ……//接前一段</p>
<p>       String separateProcesses = //该值和调试有关。一般不设置该属性</p>
<p>                          SystemProperties.get(&quot;debug.separate_processes&quot;);</p>
<p>        if(separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) {</p>
<p>          ……</p>
<p>        }else {</p>
<p>           mDefParseFlags = 0;</p>
<p>           mSeparateProcesses = null;</p>
<p>        }</p>
<p>        //创建一个Installer对象，该对象和Native进程installd交互，以后分析installd</p>
<p>        //时再来讨论它的作用</p>
<p>       mInstaller = new Installer();</p>
<p>       WindowManager wm =  //得到一个WindowManager对象</p>
<p>              (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</p>
<p>       Display d = wm.getDefaultDisplay();</p>
<p>       d.getMetrics(mMetrics); //获取当前设备的显示屏信息</p>
<p>       synchronized (mInstallLock) {</p>
<p>       synchronized (mPackages) {</p>
<p>           //创建一个ThreadHandler对象，实际就是创建一个带消息循环处理的线程，该线程</p>
<p>           //的工作是：程序的和卸载等。以后分析程序安装时会和它亲密接触</p>
<p>           mHandlerThread.start();</p>
<p>          //以ThreadHandler线程的消息循环(Looper对象)为参数创建一个PackageHandler，</p>
<p>           //可知该Handler的handleMessage函数将运行在此线程上</p>
<p>           mHandler = new PackageHandler(mHandlerThread.getLooper());</p>
<p>            File dataDir = Environment.getDataDirectory();</p>
<p>          // mAppDataDir指向/data/data目录</p>
<p>           mAppDataDir = new File(dataDir, &quot;data&quot;);</p>
<p>           // mUserAppDataDir指向/data/user目录</p>
<p>           mUserAppDataDir = new File(dataDir, &quot;user&quot;);</p>
<p>           // mDrmAppPrivateInstallDir指向/data/app-private目录</p>
<p>           mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;);</p>
<p>           /*</p>
<p>            创建一个UserManager对象，目前没有什么作用，但其前途将不可限量。</p>
<p>             根据Google的设想，未来手机将支持多个User，每个User将安装自己的应用，</p>
<p>             该功能为Andorid智能手机推向企业用户打下坚实基础</p>
<p>            */</p>
<p>           mUserManager = new UserManager(mInstaller, mUserAppDataDir);</p>
<p>           //①从文件中读权限</p>
<p>           readPermissions();</p>
<p>           //②readLPw分析</p>
<p>           mRestoredSettings = mSettings.readLPw();</p>
<p>           long startTime = SystemClock.uptimeMillis();</p>
<p>以上代码中创建了几个对象，此处暂可不去理会它们。另外，以上代码中还调用了两个函数，分别是readPermission和Setttings的readLPw，它们有什么作用呢？下面就展开分析。</p>
<p>（1） readPermissions函数分析</p>
<p>先来分析readPermissions函数，从其函数名可猜测到它和权限有关，代码如下：</p>
<p>[–&gt;PackageManagerService.java]</p>
<p>void readPermissions() {</p>
<p>        // 指向/system/etc/permission目录，该目录中存储了和设备相关的一些权限信息</p>
<p>        FilelibraryDir = new File(Environment.getRootDirectory(),</p>
<p>                                        &quot;etc/permissions&quot;);</p>
<p>        ……</p>
<p>        for(File f : libraryDir.listFiles()) {</p>
<p>           //先处理该目录下的非platform.xml文件</p>
<p>           if (f.getPath().endsWith(&quot;etc/permissions/platform.xml&quot;)) {</p>
<p>               continue;</p>
<p>           }</p>
<p>            ……//调用readPermissionFromXml解析此XML文件</p>
<p>           readPermissionsFromXml(f);</p>
<p>        }</p>
<p>       finalFile permFile = new File(Environment.getRootDirectory(),</p>
<p>               &quot;etc/permissions/platform.xml&quot;);</p>
<p>        //解析platform.xml文件，看来该文件优先级最高</p>
<p>       readPermissionsFromXml(permFile);</p>
<p>}</p>
<p>悬着的心终于放了下来！readPermissions函数不就是调用readPermissionFromXml函数解析/system/etc/permissions目录下的文件吗？这些文件似乎都是XML文件。该目录下都有哪些XML文件呢？这些XML文件中有些什么内容呢？来看一个实际的例子，如图4-3所示。</p>
<p>图4-3  /system/etc/permissions目录下的内容</p>
<p>图4-3中列出的是本人G7手机上/system/etc/permissions目录下的内容。在上面的代码中，虽然最后才解析platform.xml文件， 不过此处先分析此文件其内容如下所示：</p>
<p>[–&gt;platform.xml]</p>
<p>&lt;permissions&gt;</p>
<p>   &lt;!–建立权限名与gid的映射关系。如下面声明的BLUTOOTH_ADMIN权限，它对应的用户组是</p>
<p>    net_bt_admin。注意，该文件中的permission标签只对那些需要通过读写设备（蓝牙/camera）</p>
<p>     /创建socket等进程划分了gid。因为这些权限涉及和Linux内核交互，所以需要在底层</p>
<p>     权限（由不同的用户组界定）和Android层权限（由不同的字符串界定）之间建立映射关系</p>
<p>  –&gt;</p>
<p> &lt;permission name=&quot;android.permission.BLUETOOTH_ADMIN&quot; &gt;</p>
<p>       &lt;group gid=&quot;net_bt_admin&quot; /&gt;</p>
<p> &lt;/permission&gt;</p>
<p> &lt;permission name=&quot;android.permission.BLUETOOTH&quot; &gt;</p>
<p>       &lt;group gid=&quot;net_bt&quot; /&gt;</p>
<p>  &lt;/permission&gt;</p>
<p>  ……</p>
<p>   &lt;!–</p>
<p>     赋予对应uid相应的权限。如果下面一行表示uid为shell，那么就赋予</p>
<p>       它SEND_SMS的权限，其实就是把它加到对应的用户组中–&gt;</p>
<p>   &lt;assign-permission name=&quot;android.permission.SEND_SMS&quot;uid=&quot;shell&quot; /&gt;</p>
<p>   &lt;assign-permission name=&quot;android.permission.CALL_PHONE&quot;uid=&quot;shell&quot; /&gt;</p>
<p>   &lt;assign-permission name=&quot;android.permission.READ_CONTACTS&quot;uid=&quot;shell&quot; /&gt;</p>
<p>   &lt;assign-permission name=&quot;android.permission.WRITE_CONTACTS&quot;uid=&quot;shell&quot; /&gt;</p>
<p>    &lt;assign-permissionname=&quot;android.permission.READ_CALENDAR&quot; uid=&quot;shell&quot; /&gt;</p>
<p>……</p>
<p>    &lt;!– 系统提供的Java库，应用程序运行时候必须要链接这些库，该工作由系统自动完成 –&gt;</p>
<p>    &lt;libraryname=&quot;android.test.runner&quot;</p>
<p>           file=&quot;/system/frameworks/android.test.runner.jar&quot; /&gt;</p>
<p>    &lt;library name=&quot;javax.obex&quot;</p>
<p>           file=&quot;/system/frameworks/javax.obex.jar&quot;/&gt;</p>
<p>&lt;/permissions&gt;</p>
<p>platform.xml文件中主要使用了如下4个标签：</p>
<p>·  permission和group用于建立Linux层gid和Android层pemission之间的映射关系。</p>
<p>·  assign-permission用于向指定的uid赋予相应的权限。这个权限由Android定义，用字符串表示。</p>
<p>·  library用于指定系统库。当应用程序运行时，系统会自动为这些进程加载这些库。</p>
<p>了解了platform.xml后，再看其他的XML文件，这里以handheld-core-hardware.xml为例进行介绍，其内容如下：</p>
<p>[–&gt;handheld-core-hardware.xml]</p>
<p>&lt;permissions&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.camera&quot; /&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.location&quot; /&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.location.network&quot; /&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.sensor.compass&quot; /&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.sensor.accelerometer&quot; /&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.bluetooth&quot; /&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.touchscreen&quot; /&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.microphone&quot; /&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.screen.portrait&quot; /&gt;</p>
<p>   &lt;feature name=&quot;android.hardware.screen.landscape&quot; /&gt;</p>
<p>   &lt;/permissions&gt;</p>
<p>这个XML文件包含了许多feature标签。根据该文件中的注释，这些feature用来描述一个手持终端（包括手机、平板电脑等）应该支持的硬件特性，例如支持camera、支持蓝牙等。</p>
<p>注意对于不同的硬件特性，还需要包含其他的xml文件。例如，要支持前置摄像头，还需要包含android.hardware.camera.front.xml文件。这些文件内容大体一样，都通过feature标签表明自己的硬件特性。相关说明可参考handheld-core-hardware.xml中的注释。</p>
<p>有读者可能会好奇，真实设备上/system/etc/permission目录中的文件是从哪里的呢？</p>
<p>答案是，在编译阶段由不同硬件平台根据自己的配置信息复制相关文件到目标目录中得来的。</p>
<p>这里给出一个例子，如图4-4所示。</p>
<p>图4-4  /system/etc/permission目录中文件的来源</p>
<p>由图4-4可知，当编译的设备目标为htc-passion时，就会将Android源码目录/frameworks/base/data/etc/下某些和该目标设备硬件特性匹配的XML文件复制到最终输出目录/system/etc/permissions下。编译完成后，将生成system镜像。把该镜像文件烧到手机中，就成了目标设备使用的情况了。</p>
<p>注意4.0源码中并没有htc相关的文件，这是笔者从2.3源码中移植过去的。读者可参考笔者一篇关于如何移植4.0到G7的博文，地址为<a href="http://blog.csdn.net/innost/article/details/6977167%E3%80%82">http://blog.csdn.net/innost/article/details/6977167。</a></p>
<p>了解了与XML相关的知识后，再来分析readPermissionFromXml函数。相信聪明的读者已经知道它的作用了，就是将XML文件中的标签以及它们之间的关系转换成代码中的相应数据结构，代码如下：</p>
<p>[–&gt;PackageManagerService.java]</p>
<p>private void readPermissionsFromXml(File permFile){</p>
<p>       FileReader permReader = null;</p>
<p>        try{</p>
<p>           permReader = new FileReader(permFile);</p>
<p>        } ……</p>
<p>        try{</p>
<p>           XmlPullParser parser = Xml.newPullParser();</p>
<p>           parser.setInput(permReader);</p>
<p>           XmlUtils.beginDocument(parser, &quot;permissions&quot;);</p>
<p>           while (true) {</p>
<p>               ……</p>
<p>               String name = parser.getName();</p>
<p>               //解析group标签，前面介绍的XML文件中没有单独使用该标签的地方</p>
<p>               if (&quot;group&quot;.equals(name)) {</p>
<p>                   String gidStr = parser.getAttributeValue(null, &quot;gid&quot;);</p>
<p>                   if (gidStr != null) {</p>
<p>                        int gid =Integer.parseInt(gidStr);</p>
<p>                        //转换XML中的gid字符串为整型，并保存到mGlobalGids中</p>
<p>                        mGlobalGids =appendInt(mGlobalGids, gid);</p>
<p>                   } ……</p>
<p>               } else if (&quot;permission&quot;.equals(name)) {//解析permission标签</p>
<p>                   String perm = parser.getAttributeValue(null, &quot;name&quot;);</p>
<p>                  ……</p>
<p>                   perm = perm.intern();</p>
<p>                     //调用readPermission处理</p>
<p>                   readPermission(parser, perm);</p>
<p>                 //下面解析的是assign-permission标签</p>
<p>                } else if(&quot;assign-permission&quot;.equals(name)) {</p>
<p>                   String perm = parser.getAttributeValue(null, &quot;name&quot;);</p>
<p>                   ……</p>
<p>                   String uidStr = parser.getAttributeValue(null, &quot;uid&quot;);</p>
<p>                   ……</p>
<p>                   //如果是assign-permission，则取出uid字符串，然后获得Linux平台上</p>
<p>                   //的整型uid值</p>
<p>                   int uid = Process.getUidForName(uidStr);</p>
<p>                  ……</p>
<p>                   perm = perm.intern();</p>
<p>                   //和assign相关的信息保存在mSystemPermissions中</p>
<p>                   HashSet&lt;String&gt; perms = mSystemPermissions.get(uid);</p>
<p>                   if (perms == null) {</p>
<p>                        perms = newHashSet&lt;String&gt;();</p>
<p>                       mSystemPermissions.put(uid, perms);</p>
<p>                   }</p>
<p>                   perms.add(perm);……</p>
<p>                  } else if (&quot;library&quot;.equals(name)) {//解析library标签</p>
<p>                   String lname = parser.getAttributeValue(null, &quot;name&quot;);</p>
<p>                   String lfile = parser.getAttributeValue(null, &quot;file&quot;);</p>
<p>                   if (lname == null) {</p>
<p>                        ……</p>
<p>                   } else if (lfile == null) {</p>
<p>                        ……</p>
<p>                   } else {</p>
<p>                        //将XML中的name和library属性值存储到mSharedLibraries中</p>
<p>                       mSharedLibraries.put(lname,lfile);</p>
<p>                   } ……</p>
<p>               } else if (&quot;feature&quot;.equals(name)) {//解析feature标签</p>
<p>                   String fname = parser.getAttributeValue(null, &quot;name&quot;);</p>
<p>                    ……{</p>
<p>                        //在XML中定义的feature由FeatureInfo表达</p>
<p>                        FeatureInfo fi = newFeatureInfo();</p>
<p>                        fi.name = fname;</p>
<p>                        //存储feature名和对应的FeatureInfo到mAvailableFeatures中</p>
<p>                       mAvailableFeatures.put(fname, fi);</p>
<p>                   }……</p>
<p>                } ……</p>
<p>        } ……</p>
<p>    }</p>
<p>readPermissions函数果然将XML中的标签转换成对应的数据结构。总结相关的数据结构，如图4-4所示，此处借用了UML类图。在每个类图中，首行是数据结构名，第二行是数据结构的类型，第三行是注释。</p>
<p>图4-4  通过readPermissions函数建立的数据结构及其关系</p>
<p>这里必须再次强调：图4-4中各种数据结构的目的是为了保存XML中各种标签及它们之间的关系。在分析过程中，最重要的是理解各种标签的作用，而不是它们所使用的数据结构。</p>
<p>（2） readLPw的“佐料”</p>
<p>readLPw函数的功能也是解析文件，不过这些文件的内容却是在PKMS正常启动后生成的。这里仅介绍作为readLPw“佐料”的文件的信息。文件的具体位置在Settings构造函数中指明，其代码如下：</p>
<p>[–&gt;Settings.java]</p>
<p>Settings() {</p>
<p>        FiledataDir = Environment.getDataDirectory();</p>
<p>        FilesystemDir = new File(dataDir, &quot;system&quot;);//指向/data/system目录</p>
<p>       systemDir.mkdirs();//创建该目录</p>
<p>        ……</p>
<p>        /*</p>
<p>        一共有5个文件，packages.xml和packages-backup.xml为一组，用于描述系统中</p>
<p>        所安装的Package的信息，其中backup是临时文件。PKMS先把数据写到backup中，</p>
<p>        信息都写成功后再改名成非backup的文件。其目的是防止在写文件过程中出错，导致信息丢失。</p>
<p>         packages-stopped.xml和packages-stopped-backup.xml为一组，用于描述系统中</p>
<p>         强制停止运行的pakcage的信息，backup也是临时文件。如果此处存在该临时文件，表明</p>
<p>        此前系统因为某种原因中断了正常流程</p>
<p>        packages.list列出当前系统中应用级（即UID大于10000）Package的信息</p>
<p>        */</p>
<p>       mSettingsFilename = new File(systemDir, &quot;packages.xml&quot;);</p>
<p>       mBackupSettingsFilename = new File(systemDir,&quot;packages-backup.xml&quot;);</p>
<p>       mPackageListFilename = new File(systemDir, &quot;packages.list&quot;);</p>
<p>       mStoppedPackagesFilename = new File(systemDir,&quot;packages-stopped.xml&quot;);</p>
<p>       mBackupStoppedPackagesFilename = new File(systemDir,</p>
<p>                                            &quot;packages-stopped-backup.xml&quot;);</p>
<p>}</p>
<p>上面5个文件共分为三组，这里简单介绍一下这些文件的来历（不考虑临时的backup文件）。</p>
<p>·  packages.xml： PKMS扫描完目标文件夹后会创建该文件。当系统进行程序安装、卸载和更新等操作时，均会更新该文件。该文件保存了系统中与package相关的一些信息。</p>
<p>·  packages.list：描述系统中存在的所有非系统自带的APK的信息。当这些程序有变动时，PKMS就会更新该文件。</p>
<p>·  packages-stopped.xml：从系统自带的设置程序中进入应用程序页面，然后在选择强制停止（ForceStop）某个应用时，系统会将该应用的相关信息记录到此文件中。也就是该文件保存系统中被用户强制停止的Package的信息。</p>
<p>readLPw的函数功能就是解析其中的XML文件的内容，然后建立并更新对应的数据结构，例如停止的package重启之后依然是stopped状态。</p>
<p>提示读者看完本章后，可自行分析该函数。在此之前，建议读者不必关注该函数。</p>
<p>3.  第一阶段工作总结</p>
<p>在继续征程前，先总结一下PKMS构造函数在第一阶段的工作，千言万语汇成一句话：扫描并解析XML文件，将其中的信息保存到特定的数据结构中。</p>
<p>第一阶段扫描的XML文件与权限及上一次扫描得到的Package信息有关，它为PKMS下一阶段的工作提供了重要的参考信息。</p>
<p>4.3.2  构造函数分析之扫描Package</p>
<p>PKMS构造函数第二阶段的工作就是扫描系统中的APK了。由于需要逐个扫描文件，因此手机上装的程序越多，PKMS的工作量越大，系统启动速度也就越慢。</p>
<p>1.  系统库的dex优化</p>
<p>接着对PKMS构造函数进行分析，代码如下：</p>
<p>[–&gt;PackageManagerService.java]</p>
<p>……</p>
<p> mRestoredSettings= mSettings.readLPw();//接第一段的结尾</p>
<p> longstartTime = SystemClock.uptimeMillis();//记录扫描开始的时间</p>
<p>//定义扫描参数</p>
<p> intscanMode = SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX;</p>
<p> if(mNoDexOpt) {</p>
<p>    scanMode|= SCAN_NO_DEX; //在控制扫描过程中是否对APK文件进行dex优化</p>
<p>  }</p>
<p> finalHashSet&lt;String&gt; libFiles = new HashSet&lt;String&gt;();</p>
<p> // mFrameworkDir指向/system/frameworks目录</p>
<p> mFrameworkDir = newFile(Environment.getRootDirectory(),&quot;framework&quot;);</p>
<p> // mDalvikCacheDir指向/data/dalvik-cache目录</p>
<p> mDalvikCacheDir= new File(dataDir, &quot;dalvik-cache&quot;);</p>
<p> booleandidDexOpt = false;</p>
<p> /*</p>
<p>  获取Java启动类库的路径，在init.rc文件中通过BOOTCLASSPATH环境变量输出，该值如下</p>
<p>  /system/framework/core.jar:/system/frameworks/core-junit.jar:</p>
<p>  /system/frameworks/bouncycastle.jar:/system/frameworks/ext.jar:</p>
<p>  /system/frameworks/framework.jar:/system/frameworks/android.policy.jar:</p>
<p>  /system/frameworks/services.jar:/system/frameworks/apache-xml.jar:</p>
<p>  /system/frameworks/filterfw.jar</p>
<p>  该变量指明了framework所有核心库及文件位置</p>
<p> */</p>
<p> StringbootClassPath = System.getProperty(&quot;java.boot.class.path&quot;);</p>
<p> if(bootClassPath != null) {</p>
<p>     String[] paths = splitString(bootClassPath, ‘:’);</p>
<p>      for(int i=0; i&lt;paths.length; i++) {</p>
<p>        try{  //判断该jar包是否需要重新做dex优化</p>
<p>             if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {</p>
<p>                  /*</p>
<p>                   将该jar包文件路径保存到libFiles中，然后通过mInstall对象发送</p>
<p>                   命令给installd，让其对该jar包进行dex优化</p>
<p>                  */</p>
<p>                  libFiles.add(paths[i]);</p>
<p>                  mInstaller.dexopt(paths[i], Process.SYSTEM_UID, true);</p>
<p>                  didDexOpt = true;</p>
<p>                }</p>
<p>              } ……</p>
<p>           }</p>
<p>      } ……</p>
<p>   /*</p>
<p>    读者还记得mSharedLibrarires的作用吗？它保存的是platform.xml中声明的系统库的信息。</p>
<p>    这里也要判断系统库是否需要做dex优化。处理方式同上</p>
<p>   */</p>
<p>if (mSharedLibraries.size() &gt; 0) {</p>
<p>     ……</p>
<p> }</p>
<p>     //将framework-res.apk添加到libFiles中。framework-res.apk定义了系统常用的</p>
<p>    //资源，还有几个重要的Activity，如长按Power键后弹出的选择框</p>
<p>    libFiles.add(mFrameworkDir.getPath() + &quot;/framework-res.apk&quot;);</p>
<p>     //列举/system/frameworks目录中的文件</p>
<p>    String[] frameworkFiles = mFrameworkDir.list();</p>
<p>     if(frameworkFiles != null) {</p>
<p>         ……//判断该目录下的apk或jar文件是否需要做dex优化。处理方式同上</p>
<p> }</p>
<p>   /*</p>
<p>   上面代码对系统库（BOOTCLASSPATH指定，或 platform.xml定义，或</p>
<p>  /system/frameworks目录下的jar包与apk文件）进行一次仔细检查，该优化的一定要优化。</p>
<p>  如果发现期间对任何一个文件进行了优化，则设置didDexOpt为true</p>
<p>  */</p>
<p>     if (didDexOpt) {</p>
<p>      String[] files = mDalvikCacheDir.list();</p>
<p>        if (files != null) {</p>
<p>          /*</p>
<p>         如果前面对任意一个系统库重新做过dex优化，就需要删除cache文件。原因和</p>
<p>         dalvik虚拟机的运行机制有关。本书暂不探讨dex及cache文件的作用。</p>
<p>         从删除cache文件这个操作来看，这些cache文件应该使用了dex优化后的系统库</p>
<p>         所以当系统库重新做dex优化后，就需要删除旧的cache文件。可简单理解为缓存失效</p>
<p>        */</p>
<p>             for (int i=0; i&lt;files.length; i++) {</p>
<p>                   String fn = files[i];</p>
<p>                     if(fn.startsWith(&quot;data@app@&quot;)</p>
<p>                          ||fn.startsWith(&quot;data@app-private@&quot;)) {</p>
<p>                          (newFile(mDalvikCacheDir, fn)).delete();</p>
<p>        ……</p>
<p> }</p>
<p>2.  扫描系统Package</p>
<p>清空cache文件后，PKMS终于进入重点段了。接下来看PKMS第二阶段工作的核心内容，即扫描Package，相关代码如下：</p>
<p>[–&gt;PackageManagerService.java]</p>
<p>   //创建文件夹监控对象，监视/system/frameworks目录。利用了Linux平台的inotify机制</p>
<p>  mFrameworkInstallObserver = new AppDirObserver(</p>
<p>                      mFrameworkDir.getPath(),OBSERVER_EVENTS, true);</p>
<p>   mFrameworkInstallObserver.startWatching();</p>
<p> /*</p>
<p>  调用scanDirLI函数扫描/system/frameworks目录，这个函数很重要，稍后会再分析。</p>
<p>  注意，在第三个参数中设置了SCAN_NO_DEX标志，因为该目录下的package在前面的流程</p>
<p>  中已经过判断并根据需要做过dex优化了</p>
<p> */</p>
<p>   scanDirLI(mFrameworkDir, PackageParser.PARSE_IS_SYSTEM</p>
<p>            | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX, 0);</p>
<p>     //创建文件夹监控对象，监视/system/app目录</p>
<p>   mSystemAppDir = new File(Environment.getRootDirectory(),&quot;app&quot;);</p>
<p>   mSystemInstallObserver = new AppDirObserver(</p>
<p>               mSystemAppDir.getPath(), OBSERVER_EVENTS, true);</p>
<p>    mSystemInstallObserver.startWatching();</p>
<p> //扫描/system/app下的package</p>
<p>   scanDirLI(mSystemAppDir, PackageParser.PARSE_IS_SYSTEM</p>
<p>                   | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0);</p>
<p>     //监视并扫描/vendor/app目录</p>
<p>   mVendorAppDir = new File(&quot;/vendor/app&quot;);</p>
<p>   mVendorInstallObserver = new AppDirObserver(</p>
<p>               mVendorAppDir.getPath(), OBSERVER_EVENTS, true);</p>
<p>    mVendorInstallObserver.startWatching();</p>
<p>    //扫描/vendor/app下的package</p>
<p>   scanDirLI(mVendorAppDir, PackageParser.PARSE_IS_SYSTEM</p>
<p>                   | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0);</p>
<p>    //和installd交互。以后单独分析installd</p>
<p>   mInstaller.moveFiles();</p>
<p>由以上代码可知，PKMS将扫描以下几个目录。</p>
<p>·  /system/frameworks：该目录中的文件都是系统库，例如framework.jar、services.jar、framework-res.apk。不过scanDirLI只扫描APK文件，所以framework-res.apk是该目录中唯一“受宠”的文件。</p>
<p>·  /system/app：该目录下全是默认的系统应用，例如Browser.apk、SettingsProvider.apk等。</p>
<p>·  /vendor/app：该目录中的文件由厂商提供，即厂商特定的APK文件，不过目前市面上的厂商都把自己的应用放在/system/app目录下。</p>
<p>注意本书把这三个目录称为系统Package目录，以区分后面的非系统Package目录。</p>
<p>PKMS调用scanDirLI函数进行扫描，下面来分析此函数。</p>
<p>（1） scanDirLI函数分析</p>
<p>scanDirLI函数的代码如下：</p>
<p>[–&gt;PackageManagerService.java]</p>
<p>private void scanDirLI(File dir, int flags, intscanMode, long currentTime) {</p>
<p>       String[] files = dir.list();//列举该目录下的文件</p>
<p>       ……</p>
<p>        inti;</p>
<p>        for(i=0; i&lt;files.length; i++) {</p>
<p>           File file = new File(dir, files[i]);</p>
<p>           if (!isPackageFilename(files[i])) {</p>
<p>                continue; //根据文件名后缀，判断是否为APK 文件。这里只扫描APK 文件</p>
<p>           }</p>
<p>           /*</p>
<p>            调用scanPackageLI函数扫描一个特定的文件，返回值是PackageParser的内部类</p>
<p>            Package，该类的实例代表一个APK文件，所以它就是和APK文件对应的数据结构</p>
<p>          */</p>
<p>           PackageParser.Package pkg = scanPackageLI(file,</p>
<p>                flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime);</p>
<p>             if (pkg == null &amp;&amp; (flags &amp;PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp;</p>
<p>               mLastScanError ==PackageManager.INSTALL_FAILED_INVALID_APK) {</p>
<p>               //注意此处flags的作用，只有非系统Package扫描失败，才会删除该文件</p>
<p>               file.delete();</p>
<p>           }</p>
<p>   }</p>
<p>}</p>
<p>接着来分析scanPackageLI函数。PKMS中有两个同名的scanPackageLI函数，后面会一一见到。先来看第一个也是最先碰到的scanPackageLI函数。</p>
<p>（2） 初会scanPackageLI函数</p>
<p>首次相遇的scanPackageLI函数的代码如下：</p>
<p>[–&gt;PackageManagerService.java]</p>
<p>private PackageParser.Package scanPackageLI(FilescanFile, int parseFlags,</p>
<p>                                       int scanMode, long currentTime)</p>
<p>{</p>
<p>     mLastScanError = PackageManager.INSTALL_SUCCEEDED;</p>
<p>      StringscanPath = scanFile.getPath();</p>
<p>     parseFlags |= mDefParseFlags;//默认的扫描标志，正常情况下为0</p>
<p>      //创建一个PackageParser对象</p>
<p>     PackageParser pp = new PackageParser(scanPath);</p>
<p>     pp.setSeparateProcesses(mSeparateProcesses);// mSeparateProcesses为空</p>
<p>     pp.setOnlyCoreApps(mOnlyCore);// mOnlyCore为false</p>
<p>      /*</p>
<p>       调用PackageParser的parsePackage函数解析APK文件。注意，这里把代表屏幕</p>
<p>       信息的mMetrics对象也传了进去</p>
<p>       */</p>
<p>      finalPackageParser.Package pkg = pp.parsePackage(scanFile,</p>
<p>               scanPath, mMetrics, parseFlags);</p>
<p>        ……</p>
<p>     PackageSetting ps = null;</p>
<p>     PackageSetting updatedPkg;</p>
<p>        ……</p>
<p>      /*</p>
<p>        这里略去一大段代码，主要是关于Package升级方面的工作。读者可能会比较好奇：既然是</p>
<p>        升级，一定有新旧之分，如果这里刚解析后得到的Package信息是新，那么旧Package</p>
<p>        的信息从何得来？还记得”readLPw的‘佐料’”这一小节提到的package.xml文件吗？此</p>
<p>        文件中存储的就是上一次扫描得到的Package信息。对比这两次的信息就知道是否需要做</p>
<p>        升级了。这部分代码比较繁琐，但不影响我们正常分析。感兴趣的读者可自行研究</p>
<p>      */</p>
<p>      //收集签名信息，这部分内容涉及signature，本书暂不拟讨论[①]。</p>
<p>      if (!collectCertificatesLI(pp, ps, pkg,scanFile, parseFlags))</p>
<p>           returnnull;</p>
<p>     //判断是否需要设置PARSE_FORWARD_LOCK标志，这个标志针对资源文件和Class文件</p>
<p>     //不在同一个目录的情况。目前只有/vendor/app目录下的扫描会使用该标志。这里不讨论</p>
<p>     //这种情况。</p>
<p>      if (ps != null &amp;&amp;!ps.codePath.equals(ps.resourcePath))</p>
<p>           parseFlags|= PackageParser.PARSE_FORWARD_LOCK;</p>
<p>        String codePath = null;</p>
<p>       String resPath = null;</p>
<p>        if((parseFlags &amp; PackageParser.PARSE_FORWARD_LOCK) != 0) {</p>
<p>            ……//这里不考虑PARSE_FORWARD_LOCK的情况。</p>
<p>        }else {</p>
<p>           resPath = pkg.mScanPath;</p>
<p>        }</p>
<p>       codePath = pkg.mScanPath;//mScanPath指向该APK文件所在位置</p>
<p>        //设置文件路径信息，codePath和resPath都指向APK文件所在位置</p>
<p>       setApplicationInfoPaths(pkg, codePath, resPath);</p>
<p>        //调用第二个scanPackageLI函数</p>
<p>       return scanPackageLI(pkg, parseFlags, scanMode | SCAN_UPDATE_SIGNATURE,</p>
<p>                                 currentTime);</p>
<p>}</p>
<p>scanPackageLI函数首先调用PackageParser对APK文件进行解析。根据前面的介绍可知，PackageParser完成了从物理文件到对应数据结构的转换。下面来分析这个PackageParser。</p>
<p>（3） PackageParser分析</p>
<p>PackageParser主要负责APK文件的解析，即解析APK文件中的AndroidManifest.xml代码如下：</p>
<p>[–&gt;PackageParser.java]</p>
<p> publicPackage parsePackage(File sourceFile, String destCodePath,</p>
<p>           DisplayMetrics metrics, int flags) {</p>
<p>       mParseError = PackageManager.INSTALL_SUCCEEDED;</p>
<p>       mArchiveSourcePath = sourceFile.getPath();</p>
<p>        ……//检查是否为APK文件</p>
<p>      XmlResourceParser parser = null;</p>
<p>       AssetManager assmgr = null;</p>
<p>       Resources res = null;</p>
<p>       boolean assetError = true;</p>
<p>        try{</p>
<p>           assmgr = new AssetManager();</p>
<p>           int cookie = assmgr.addAssetPath(mArchiveSourcePath);</p>
<p>           if (cookie != 0) {</p>
<p>               res = new Resources(assmgr, metrics, null);</p>
<p>               assmgr.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0,</p>
<p>                              0, 0, 0, 0,Build.VERSION.RESOURCES_SDK_INT);</p>
<p>          /*</p>
<p>           获得一个XML资源解析对象，该对象解析的是APK中的AndroidManifest.xml文件。</p>
<p>           以后再讨论AssetManager、Resource及相关的知识</p>
<p>         */</p>
<p>            parser = assmgr.openXmlResourceParser(cookie,</p>
<p>                                                  ANDROID_MANIFEST_FILENAME);</p>
<p>               assetError = false;</p>
<p>           } ……//出错处理</p>
<p>       String[] errorText = new String[1];</p>
<p>       Package pkg = null;</p>
<p>       Exception errorException = null;</p>
<p>        try {</p>
<p>           //调用另外一个parsePackage函数</p>
<p>           pkg = parsePackage(res, parser, flags, errorText);</p>
<p>        } ……</p>
<p>        ……//错误处理</p>
<p>       parser.close();</p>
<p>       assmgr.close();</p>
<p>       //保存文件路径，都指向APK文件所在的路径</p>
<p>       pkg.mPath = destCodePath;</p>
<p>       pkg.mScanPath = mArchiveSourcePath;</p>
<p>       pkg.mSignatures = null;</p>
<p>       return pkg;</p>
<p>}</p>
<p>以上代码中调用了另一个同名的PackageParser函数，此函数内容较长，但功能单一，就是解析AndroidManifest.xml中的各种标签，这里只提取其中相关的代码：</p>
<p>[–&gt;PackageParser.java]</p>
<p>private Package parsePackage(</p>
<p>       Resources res, XmlResourceParser parser, int flags, String[] outError)</p>
<p>       throws XmlPullParserException, IOException {</p>
<p>       AttributeSet attrs = parser;</p>
<p>       mParseInstrumentationArgs = null;</p>
<p>       mParseActivityArgs = null;</p>
<p>        mParseServiceArgs= null;</p>
<p>       mParseProviderArgs = null;</p>
<p>       //得到Package的名字，其实就是得到AndroidManifest.xml中package属性的值，</p>
<p>       //每个APK都必须定义该属性</p>
<p>       String pkgName = parsePackageName(parser, attrs, flags, outError);</p>
<p>        ……</p>
<p>        inttype;</p>
<p>       ……</p>
<p>        //以pkgName名字为参数，创建一个Package对象。后面的工作就是解析XML并填充</p>
<p>       //该Package信息</p>
<p>       finalPackage pkg = new Package(pkgName);</p>
<p>       boolean foundApp = false;</p>
<p>       ……//下面开始解析该文件中的标签，由于这段代码功能简单，所以这里仅列举相关函数</p>
<p>      while(如果解析未完成){</p>
<p>      ……</p>
<p>       StringtagName = parser.getName(); //得到标签名</p>
<p>       if(tagName.equals(&quot;application&quot;)){</p>
<p>          ……//解析application标签</p>
<p>           parseApplication(pkg,res, parser, attrs, flags, outError);</p>
<p>       } elseif (tagName.equals(&quot;permission-group&quot;)) {</p>
<p>        ……//解析permission-group标签</p>
<p>        parsePermissionGroup(pkg, res, parser, attrs, outError);</p>
<p>       } elseif (tagName.equals(&quot;permission&quot;)) {</p>
<p>        ……//解析permission标签</p>
<p>        parsePermission(pkg, res, parser, attrs, outError);</p>
<p>       } else if(tagName.equals(&quot;uses-permission&quot;)){</p>
<p>          //从XML文件中获取uses-permission标签的属性</p>
<p>          sa= res.obtainAttributes(attrs,</p>
<p>            com.android.internal.R.styleable.AndroidManifestUsesPermission);</p>
<p>          //取出属性值，也就是对应的权限使用声明</p>
<p>         String name = sa.getNonResourceString(com.android.internal.</p>
<p>                               R.styleable.AndroidManifestUsesPermission_name);</p>
<p>          //添加到Package的requestedPermissions数组</p>
<p>          if(name != null &amp;&amp; !pkg.requestedPermissions.contains(name)) {</p>
<p>               pkg.requestedPermissions.add(name.intern());</p>
<p>          }</p>
<p>       }elseif (tagName.equals(&quot;uses-configuration&quot;)){</p>
<p>        /*</p>
<p>           该标签用于指明本package对硬件的一些设置参数，目前主要针对输入设备（触摸屏、键盘</p>
<p>           等）。游戏类的应用可能对此有特殊要求。</p>
<p>       */</p>
<p>         ConfigurationInfocPref = new ConfigurationInfo();</p>
<p>        ……//解析该标签所支持的各种属性</p>
<p>        pkg.configPreferences.add(cPref);//保存到Package的configPreferences数组</p>
<p>       }</p>
<p>      ……//对其他标签解析和处理</p>
<p>}</p>
<p>上面代码展示了AndroidManifest.xml解析的流程，其中比较重要的函数是parserApplication，它用于解析application标签及其子标签（Android的四大组件在application标签中已声明）。</p>
<p>图4-5表示了PackageParser及其内部重要成员的信息。</p>
<p>图4-5  PackageParser大家族</p>
<p>由图4-5可知：</p>
<p>·  PackageParser定了相当多的内部类，这些内部类的作用就是保存对应的信息。解析AndroidManifest.xml文件得到的信息由Package保存。从该类的成员变量可看出，和Android四大组件相关的信息分别由activites、receivers、providers、services保存。由于一个APK可声明多个组件，因此activites和receivers等均声明为ArrayList。</p>
<p>·  以</p>
<p>PackageParser.Activity为例，它从Component&lt;ActivityIntentInfo&gt;派生。Component是一个模板类，元素类型是ActivityIntentInfo，此类的顶层基类是IntentFilter。PackageParser.Activity内部有一个ActivityInfo类型的成员变量，该变量保存的就是四大组件中Activity的信息。细心的读者可能会有疑问，为什么不直接使用ActivityInfo，而是通过IntentFilter构造出一个使用模板的复杂类型PackageParser.Activity呢？原来，Package除了保存信息外，还需要支持Intent匹配查询。例如，设置Intent的Action为某个特定值，然后查找匹配该Intent的Activity。由于ActivityIntentInfo是从IntentFilter派生的，因此它它能判断自己是否满足该Intent的要求，如果满足，则返回对应的ActivityInfo。在后续章节会详细讨论根据Intent查询特定Activity的工作流程。</p>
<p>·  PackageParser定了一个轻量级的数据结构PackageLite，该类仅存储Package的一些简单信息。我们在介绍Package安装的时候，会遇到PackageLite。</p>
<p>注意读者需要了解Java泛型类的相关知识。</p>
<p>（4） 与scanPackageLI再相遇</p>
<p>在PackageParser扫描完一个APK后，此时系统已经根据该APK中AndroidManifest.xm，创建了一个完整的Package对象，下一步就是将该Package加入到系统中。此时调用的函数就是另外一个scanPackageLI，其代码如下：</p>
<p>[–&gt;PackageManagerService.java::scanPackageLI函数]</p>
<p>private PackageParser.PackagescanPackageLI(PackageParser.Package pkg,</p>
<p>           int parseFlags, int scanMode, long currentTime) {</p>
<p>        FilescanFile = new File(pkg.mScanPath);</p>
<p>        ……</p>
<p>       mScanningPath = scanFile;</p>
<p>        //设置package对象中applicationInfo的flags标签，用于标示该Package为系统</p>
<p>       //Package</p>
<p>        if((parseFlags&amp;PackageParser.PARSE_IS_SYSTEM) != 0) {</p>
<p>           pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;</p>
<p>        }</p>
<p>        //①下面这句if判断极为重要，见下面的解释</p>
<p>        if(pkg.packageName.equals(&quot;android&quot;)) {</p>
<p>           synchronized (mPackages) {</p>
<p>               if (mAndroidApplication != null) {</p>
<p>                  ……</p>
<p>               mPlatformPackage = pkg;</p>
<p>               pkg.mVersionCode = mSdkVersion;</p>
<p>               mAndroidApplication = pkg.applicationInfo;</p>
<p>               mResolveActivity.applicationInfo = mAndroidApplication;</p>
<p>               mResolveActivity.name = ResolverActivity.class.getName();</p>
<p>               mResolveActivity.packageName = mAndroidApplication.packageName;</p>
<p>               mResolveActivity.processName = mAndroidApplication.processName;</p>
<p>               mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;</p>
<p>               mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;</p>
<p>               mResolveActivity.theme =</p>
<p>                          com.android.internal.R.style.Theme_Holo_Dialog_Alert;</p>
<p>               mResolveActivity.exported = true;</p>
<p>               mResolveActivity.enabled = true;</p>
<p>               //mResoveInfo的activityInfo成员指向mResolveActivity</p>
<p>               mResolveInfo.activityInfo = mResolveActivity;</p>
<p>               mResolveInfo.priority = 0;</p>
<p>               mResolveInfo.preferredOrder = 0;</p>
<p>               mResolveInfo.match = 0;</p>
<p>               mResolveComponentName = new ComponentName(</p>
<p>                       mAndroidApplication.packageName, mResolveActivity.name);</p>
<p>           }</p>
<p>        }</p>
<p>刚进入scanPackageLI函数，我们就发现了一个极为重要的内容，即单独判断并处理packageName为“android”的Package。和该Package对应的APK是framework-res.apk，有图为证，如图4-6所示为该APK的AndroidManifest.xml中的相关内容。</p>
<p>图4-6  framework-res.apk的AndroidManifest.xml</p>
<p>实际上，framework-res.apk还包含了以下几个常用的Activity。</p>
<p>·  ChooserActivity：当多个Activity符合某个Intent的时候，系统会弹出此Activity，由用户选择合适的应用来处理。</p>
<p>·  RingtonePickerActivity：铃声选择Activity。</p>
<p>·  ShutdownActivity：关机前弹出的选择对话框。</p>
<p>由前述知识可知，该Package和系统息息相关，因此它得到了PKMS的特别青睐，主要体现在以下几点。</p>
<p>·  mPlatformPackage成员用于保存该Package信息。</p>
<p>·  mAndroidApplication用于保存此Package中的ApplicationInfo。</p>
<p>·  mResolveActivity指向用于表示ChooserActivity信息的ActivityInfo。</p>
<p>·  mResolveInfo为ResolveInfo类型，它用于存储系统解析Intent（经IntentFilter的过滤）后得到的结果信息，例如满足某个Intent的Activity的信息。由前面的代码可知，mResolveInfo的activityInfo其实指向的就是mResolveActivity。</p>
<p>注意在从PKMS中查询满足某个Intent的Activity时，返回的就是ResolveInfo，再根据ResolveInfo的信息得到具体的Activity。</p>
<p>此处保存这些信息，主要是为了提高运行过程中的效率。Goolge工程师可能觉得ChooserActivity使用的地方比较多，所以这里单独保存了此Activity的信息。</p>
<p>好，继续对scanPackageLI函数的分析。</p>
<p>[–&gt;PackageManagerService::scanPackageLI函数]</p>
<p>……//mPackages用于保存系统内的所有Package，以packageName为key</p>
<p>   if(mPackages.containsKey(pkg.packageName)</p>
<p>               || mSharedLibraries.containsKey(pkg.packageName)) {</p>
<p>       return null;</p>
<p>   }</p>
<p>      File destCodeFile = newFile(pkg.applicationInfo.sourceDir);</p>
<p>      FiledestResourceFile = new File(pkg.applicationInfo.publicSourceDir);</p>
<p>      SharedUserSettingsuid = null;//代表该Package的SharedUserSetting对象</p>
<p>     PackageSetting pkgSetting = null;//代表该Package的PackageSetting对象</p>
<p>      synchronized(mPackages) {</p>
<p>         ……//此段代码大约有300行左右，主要做了以下几方面工作</p>
<p>         /*</p>
<p>          ①如果该Packge声明了” uses-librarie”话，那么系统要判断该library是否</p>
<p>            在mSharedLibraries中</p>
<p>          ②如果package声明了SharedUser，则需要处理SharedUserSettings相关内容，</p>
<p>            由Settings的getSharedUserLPw函数处理</p>
<p>           ③处理pkgSetting，通过调用Settings的getPackageLPw函数完成</p>
<p>           ④调用verifySignaturesLP函数，检查该Package的signature</p>
<p>          */</p>
<p>       }</p>
<p>      finallong scanFileTime = scanFile.lastModified();</p>
<p>      finalboolean forceDex = (scanMode&amp;SCAN_FORCE_DEX) != 0;</p>
<p>      //确定运行该package的进程的进程名，一般用packageName作为进程名</p>
<p>     pkg.applicationInfo.processName = fixProcessName(</p>
<p>                         pkg.applicationInfo.packageName,</p>
<p>                         pkg.applicationInfo.processName,</p>
<p>                         pkg.applicationInfo.uid);</p>
<p>      if(mPlatformPackage == pkg) {</p>
<p>           dataPath = new File (Environment.getDataDirectory(),&quot;system&quot;);</p>
<p>           pkg.applicationInfo.dataDir = dataPath.getPath();</p>
<p>        }else {</p>
<p>            /*</p>
<p>             getDataPathForPackage函数返回该package的目录</p>
<p>            一般是/data/data/packageName/</p>
<p>           */</p>
<p>           dataPath = getDataPathForPackage(pkg.packageName, 0);</p>
<p>            if(dataPath.exists()){</p>
<p>             ……//如果该目录已经存在，则要处理uid的问题</p>
<p>           } else {</p>
<p>             ……//向installd发送install命令，实际上就是在/data/data下</p>
<p>                   //建立packageName目录。后续将分析installd相关知识</p>
<p>               int ret = mInstaller.install(pkgName, pkg.applicationInfo.uid,</p>
<p>                       pkg.applicationInfo.uid);</p>
<p>              //为系统所有user安装此程序</p>
<p>               mUserManager.installPackageForAllUsers(pkgName,</p>
<p>                                pkg.applicationInfo.uid);</p>
<p>               if (dataPath.exists()) {</p>
<p>                   pkg.applicationInfo.dataDir = dataPath.getPath();</p>
<p>               } ……</p>
<p>               if (pkg.applicationInfo.nativeLibraryDir == null &amp;&amp;</p>
<p>                      pkg.applicationInfo.dataDir!= null) {</p>
<p>               ……//为该Package确定native library所在目录</p>
<p>              //一般是/data/data/packagename/lib</p>
<p>           }</p>
<p>}</p>
<p>    //如果该APK包含了native动态库，则需要将它们从APK文件中解压并复制到对应目录中</p>
<p>    if(pkg.applicationInfo.nativeLibraryDir != null) {</p>
<p>           try {</p>
<p>               final File nativeLibraryDir = new</p>
<p>                            File(pkg.applicationInfo.nativeLibraryDir);</p>
<p>               final String dataPathString = dataPath.getCanonicalPath();</p>
<p>               //从2.3开始，系统package的native库统一放在/system/lib下。所以</p>
<p>               //系统不会提取系统Package目录下APK包中的native库</p>
<p>               if (isSystemApp(pkg) &amp;&amp; !isUpdatedSystemApp(pkg)) {</p>
<p>                   NativeLibraryHelper.removeNativeBinariesFromDirLI(</p>
<p>                                            nativeLibraryDir)){</p>
<p>           } else if (nativeLibraryDir.getParentFile().getCanonicalPath()</p>
<p>                       .equals(dataPathString)) {</p>
<p>                   boolean isSymLink;</p>
<p>                   try {</p>
<p>                        isSymLink = S_ISLNK(Libcore.os.lstat(</p>
<p>                                        nativeLibraryDir.getPath()).st_mode);</p>
<p>                   } ……//判断是否为链接，如果是，需要删除该链接</p>
<p>                   if (isSymLink) {</p>
<p>                       mInstaller.unlinkNativeLibraryDirectory(dataPathString);</p>
<p>                   }</p>
<p>             //在lib下建立和CPU类型对应的目录，例如ARM平台的是arm/，MIPS平台的是mips/</p>
<p>               NativeLibraryHelper.copyNativeBinariesIfNeededLI(scanFile,</p>
<p>                                   nativeLibraryDir);</p>
<p>               } else {</p>
<p>                   mInstaller.linkNativeLibraryDirectory(dataPathString,</p>
<p>                                       pkg.applicationInfo.nativeLibraryDir);</p>
<p>               }</p>
<p>           } ……</p>
<p>        }</p>
<p>     pkg.mScanPath= path;</p>
<p>     if((scanMode&amp;SCAN_NO_DEX) == 0) {</p>
<p>            ……//对该APK做dex优化</p>
<p>        performDexOptLI(pkg,forceDex, (scanMode&amp;SCAN_DEFER_DEX);</p>
<p>      }</p>
<p>     //如果该APK已经存在，要先杀掉运行该APK的进程</p>
<p>     if((parseFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) {</p>
<p>           killApplication(pkg.applicationInfo.packageName,</p>
<p>                       pkg.applicationInfo.uid);</p>
<p>     }</p>
<p>……</p>
<p>     /*</p>
<p>     在此之前，四大组件信息都属于Package的私有财产，现在需要把它们登记注册到PKMS内部的</p>
<p>     财产管理对象中。这样，PKMS就可对外提供统一的组件信息，而不必拘泥于具体的Package</p>
<p>     */</p>
<p>    synchronized(mPackages) {</p>
<p>   if ((scanMode&amp;SCAN_MONITOR) != 0) {</p>
<p>        mAppDirs.put(pkg.mPath, pkg);</p>
<p>   }</p>
<p>  mSettings.insertPackageSettingLPw(pkgSetting, pkg);</p>
<p>   mPackages.put(pkg.applicationInfo.packageName,pkg);</p>
<p>   //处理该Package中的Provider信息</p>
<p>   int N =pkg.providers.size();</p>
<p>   int i;</p>
<p>   for (i=0;i&lt;N; i++) {</p>
<p>   PackageParser.Providerp = pkg.providers.get(i);</p>
<p>   p.info.processName=fixProcessName(</p>
<p>                               pkg.applicationInfo.processName,</p>
<p>                  p.info.processName, pkg.applicationInfo.uid);</p>
<p>    //mProvidersByComponent提供基于ComponentName的Provider信息查询</p>
<p>    mProvidersByComponent.put(new ComponentName(</p>
<p>                               p.info.packageName,p.info.name), p);</p>
<p>             ……</p>
<p>   }</p>
<p>   //处理该Package中的Service信息</p>
<p>   N =pkg.services.size();</p>
<p>   r = null;</p>
<p>   for (i=0;i&lt;N; i++) {</p>
<p>   PackageParser.Service s =pkg.services.get(i);</p>
<p>   mServices.addService(s);</p>
<p>   }</p>
<p>   //处理该Package中的BroadcastReceiver信息</p>
<p>   N =pkg.receivers.size();</p>
<p>   r = null;</p>
<p>   for (i=0;i&lt;N; i++) {</p>
<p>   PackageParser.Activity a =pkg.receivers.get(i);</p>
<p>   mReceivers.addActivity(a,&quot;receiver&quot;);</p>
<p>   ……</p>
<p>   }</p>
<p>   //处理该Package中的Activity信息</p>
<p>   N = pkg.activities.size();</p>
<p>   r =null;</p>
<p>   for (i=0; i&lt;N; i++) {</p>
<p>   PackageParser.Activity a =pkg.activities.get(i);</p>
<p>   mActivities.addActivity(a,&quot;activity&quot;);//后续将详细分析该调用</p>
<p>  }</p>
<p>   //处理该Package中的PermissionGroups信息</p>
<p>   N = pkg.permissionGroups.size();</p>
<p>   ……//permissionGroups处理</p>
<p>   N =pkg.permissions.size();</p>
<p>   ……//permissions处理</p>
<p>   N =pkg.instrumentation.size();</p>
<p>   ……//instrumentation处理</p>
<p>   if(pkg.protectedBroadcasts != null) {</p>
<p>      N = pkg.protectedBroadcasts.size();</p>
<p>      for(i=0; i&lt;N; i++) {</p>
<p>        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));</p>
<p>      }</p>
<p>}</p>
<p>   ……//Package的私有财产终于完成了公有化改造</p>
<p>return pkg;</p>
<p>}</p>
<p>到此这个长达800行的代码就分析完了，下面总结一下Package扫描的流程。</p>
<p>（5） scanDirLI函数总结</p>
<p>scanDirLI用于对指定目录下的APK文件进行扫描，如图4-7所示为该函数的调用流程。</p>
<p>图4-7  scanDirLI工作流程总结</p>
<p>图4-7比较简单，相关知识无须赘述。读者在自行分析代码时，只要注意区分这两个同名scanPackageLI函数即可。</p>
<p>扫描完APK文件后，Package的私有财产就充公了。PKMS提供了好几个重要数据结构来保存这些财产，这些数据结构的相关信息如图4-8所示。</p>
<p>图4-8  PKMS中重要的数据结构</p>
<p>图4-8借用UML的类图来表示PKMS中重要的数据结构。每个类图的第一行为成员变量名，第二行为数据类型，第三行为注释说明。</p>
<p>3.  扫描非系统Package</p>
<p>非系统Package就是指那些不存储在系统目录下的APK文件，这部分代码如下：</p>
<p>[–&gt;PackageManagerService.java::构造函数第三部分]</p>
<p>           if (!mOnlyCore) {//mOnlyCore用于控制是否扫描非系统Package</p>
<p>               Iterator&lt;PackageSetting&gt; psit =  </p>
<p>                            mSettings.mPackages.values().iterator();</p>
<p>               while (psit.hasNext()) {</p>
<p>                   ……//删除系统package中那些不存在的APK</p>
<p>           }</p>
<p>             mAppInstallDir = new File(dataDir,&quot;app&quot;);</p>
<p>            ……//删除安装不成功的文件及临时文件</p>
<p>           if (!mOnlyCore) {</p>
<p>              //在普通模式下，还需要扫描/data/app以及/data/app_private目录 </p>
<p>              mAppInstallObserver = new AppDirObserver(</p>
<p>                   mAppInstallDir.getPath(), OBSERVER_EVENTS, false);</p>
<p>              mAppInstallObserver.startWatching();</p>
<p>              scanDirLI(mAppInstallDir, 0, scanMode, 0);</p>
<p>               mDrmAppInstallObserver = newAppDirObserver(</p>
<p>                   mDrmAppPrivateInstallDir.getPath(), OBSERVER_EVENTS, false);</p>
<p>              mDrmAppInstallObserver.startWatching();</p>
<p>              scanDirLI(mDrmAppPrivateInstallDir,           </p>
<p>                            PackageParser.PARSE_FORWARD_LOCK,scanMode,0);</p>
<p>           } else {</p>
<p>               mAppInstallObserver = null;</p>
<p>               mDrmAppInstallObserver = null;</p>
<p>      }</p>
<p>结合前述代码，这里总结几个存放APK文件的目录。</p>
<p>·  系统Package目录包括：/system/frameworks、/system/app和/vendor/app。</p>
<p>·  非系统Package目录包括：/data/app、/data/app-private。</p>
<p>4.  第二阶段工作总结</p>
<p>PKMS构造函数第二阶段的工作任务非常繁重，要创建比较多的对象，所以它是一个耗时耗内存的操作。在工作中，我们一直想优化该流程以加快启动速度，例如延时扫描不重要的APK，或者保存Package信息到文件中，然后在启动时从文件中恢复这些信息以减少APK文件读取并解析XML的工作量。但是一直没有一个比较完满的解决方案，原因有很多。比如APK之间有着比较微妙的依赖关系，因此到底延时扫描哪些APK，尚不能确定。另外，笔者感到比较疑惑的一个问题是：对于多核CPU架构，PKMS可以启动多个线程以扫描不同的目录，但是目前代码中还没有寻找到相关的蛛丝马迹。难道此处真的就不能优化了吗？读者如果有更好的解决方案，不妨和大家分享一下。</p>
<p>4.3.3  构造函数分析之扫尾工作</p>
<p>下面分析PKMS第三阶段的工作，这部分任务比较简单，就是将第二阶段收集的信息再集中整理一次，比如将有些信息保存到文件中，相关代码如下：</p>
<p>[–&gt;PackageManagerService.java::构造函数]</p>
<p>……</p>
<p>  mSettings.mInternalSdkPlatform= mSdkVersion;</p>
<p>  //汇总并更新和Permission相关的信息</p>
<p>  updatePermissionsLPw(null, null, true,</p>
<p>                           regrantPermissions,regrantPermissions);</p>
<p>   //将信息写到package.xml、package.list及package-stopped.xml文件中</p>
<p>   mSettings.writeLPr();</p>
<p>   Runtime.getRuntime().gc();</p>
<p>    mRequiredVerifierPackage= getRequiredVerifierLPr();</p>
<p>……//PKMS构造函数返回</p>
<p>}</p>
<p>读者可自行研究以上代码中涉及的几个函数，这里不再赘述。</p>
<p>4.3.4  PKMS构造函数总结</p>
<p>从流程角度看，PKMS构造函数的功能还算清晰，无非是扫描XML或APK文件，但是其中涉及的数据结构及它们之间的关系却较为复杂。这里有一些建议供读者参考：</p>
<p>·  理解PKMS构造函数工作的三个阶段及其各阶段的工作职责。</p>
<p>·  了解PKMS第二阶段工作中解析APK文件的几个关键步骤，可参考图4-7。</p>
<p>·  了解重点数据结构的名字和大体功能。</p>
<p>如果对PKMS的分析到此为止，则未免有些太小视它了。下面将分析几个重量级的知识点，期望能带领读者全方位认识PKMS。</p>
<p>4.4  APK Installation分析</p>
<p>本节将分析APK的安装及相关处理流程，它可能比读者想象得要复杂。</p>
<p>马上开始我们的行程，故事从adb install开始。</p>
<p>4.4.1  adb install分析</p>
<p>adb install有多个参数，这里仅考虑最简单的，如adb installframeworktest.apk。adb是一个命令，install是它的参数。此处直接跳到处理install参数的代码：</p>
<p>[–&gt;commandline.c]</p>
<p>int adb_commandline(int argc, char **argv){</p>
<p>   …… </p>
<p>if(!strcmp(argv[0], &quot;install&quot;)) {</p>
<p>       ……//调用install_app函数处理</p>
<p>       return install_app(ttype, serial, argc, argv);</p>
<p>}</p>
<p>……</p>
<p>}</p>
<p>install_app函数也在commandline.c中定义，代码如下：</p>
<p>[–&gt;commandline.c]</p>
<p>int install_app(transport_type transport, char*serial, int argc, char** argv)</p>
<p>{</p>
<p>    //要安装的APK现在还在Host机器上，要先把APK复制到手机中。</p>
<p>   //这里需要设置复制目标的目录，如果安装在内部存储中，则目标目录为/data/local/tmp；</p>
<p>   //如果安装在SD卡上，则目标目录为/sdcard/tmp。</p>
<p>    staticconst char *const DATA_DEST = &quot;/data/local/tmp/%s&quot;;</p>
<p>    staticconst char *const SD_DEST = &quot;/sdcard/tmp/%s&quot;;</p>
<p>    constchar* where = DATA_DEST;</p>
<p>    charapk_dest[PATH_MAX];</p>
<p>    charverification_dest[PATH_MAX];</p>
<p>    char*apk_file;</p>
<p>    char*verification_file = NULL;</p>
<p>    intfile_arg = -1;</p>
<p>    int err;</p>
<p>    int i;</p>
<p>    for (i =1; i &lt; argc; i++) {</p>
<p>        if(*argv[i] != ‘-‘) {</p>
<p>           file_arg = i;</p>
<p>           break;</p>
<p>        }else if (!strcmp(argv[i], &quot;-i&quot;)) {</p>
<p>            i++;</p>
<p>        }else if (!strcmp(argv[i], &quot;-s&quot;)) {</p>
<p>           where = SD_DEST; //-s参数指明该APK安装到SD卡上</p>
<p>        }</p>
<p>    }</p>
<p>    ……</p>
<p>    apk_file= argv[file_arg];</p>
<p>    ……</p>
<p>    //获取目标文件的全路径，如果安装在内部存储中，则目标全路径为/data/local/tmp/安装包名，</p>
<p>    //调用do_sync_push将此APK传送到手机的目标路径</p>
<p>    err =do_sync_push(apk_file, apk_dest, 1 /* verify APK */);</p>
<p>    …… //①4.0新增了一个安装包Verification功能，相关知识稍后分析</p>
<p>    //②执行pm命令，这个函数很有意思</p>
<p>    pm_command(transport,serial, argc, argv);</p>
<p>……</p>
<p>  cleanup_apk:</p>
<p>    //③在手机中执行shell rm 命令，删除刚才传送过去的目标APK文件。为什么要删除呢</p>
<p>   delete_file(transport, serial, apk_dest);</p>
<p>    returnerr;</p>
<p>}</p>
<p>以上代码中共有三个关键点，分别是：</p>
<p>·  4.0新增了APK安装过程中的Verification的功能。其实就是在安装时，把相关信息发送给指定的Verification程序（另外一个APK），由它对要安装的APK进行检查（Verify）。这部分内容在后面分析APK 安装时会介绍。目前，标准代码中还没有从事Verification工作的APK。</p>
<p>·  调用pm_command进行安装，这是一个比较有意思的函数，稍后对其进行分析。</p>
<p>·  安装完后，执行shell rm删除刚才传送给手机的APK文件。为什么会删除呢？因为PKMS在安装过程中会将该APK复制一份到/data/app目录下，所以/data/local/tmp下的对应文件就可以删除了。这部分代码在后面也能见到。</p>
<p>先来分析pm_command命令。为什么说它很有意思呢？</p>
<p>4.4.2  pm分析</p>
<p>pm_command代码如下：</p>
<p>[–&gt;commandline.c]</p>
<p>static int pm_command(transport_type transport,char* serial,</p>
<p>                      int argc, char** argv)</p>
<p>{</p>
<p>    charbuf[4096];</p>
<p>    snprintf(buf,sizeof(buf), &quot;shell:pm&quot;);</p>
<p>  ……//准备参数</p>
<p>  //发送&quot;shell:pm install 参数&quot;给手机端的adbd</p>
<p>   send_shellcommand(transport, serial, buf);</p>
<p>    return0;</p>
<p>}</p>
<p>手机端的adbd在收到客户端发来的shellpm命令时会启动一个shell，然后在其中执行pm。pm是什么？为什么可以在shell下执行？</p>
<p>提示读者可以通过adb shell登录到自己手机，然后执行pm，看看会发现什么。</p>
<p>pm实际上是一个脚本，其内容如下：</p>
<p>[–&gt;pm]</p>
<h1 id="Script-to-start-quot-pm-quot-on-the-device-which-has-a-very-rudimentary"><a href="#Script-to-start-quot-pm-quot-on-the-device-which-has-a-very-rudimentary" class="headerlink" title="Script to start &quot;pm&quot; on the device,which has a very rudimentary"></a>Script to start &quot;pm&quot; on the device,which has a very rudimentary</h1><h1 id="shell"><a href="#shell" class="headerlink" title="shell."></a>shell.</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>base=/system</p>
<p>export CLASSPATH=$base/frameworks/pm.jar</p>
<p>exec app_process $base/bincom.android.commands.pm.Pm &quot;$@&quot;</p>
<p>在编译system.image时，Android.mk中会将该脚本复制到system/bin目录下。从pm脚本的内容来看，它就是通过app_process执行pm.jar包的main函数。在卷I第4章分析Zygote时，已经介绍了app_process是一个Native进程，它通过创建虚拟机启动了Zygote，从而转变为一个Java进程。实际上，app_process还可以通过类似的方法（即先创建Dalvik虚拟机，然后执行某个类的main函数）来转变成其他Java程序。</p>
<p>注意Android系统中常用的monkeytest、pm、am等（这些都是脚本文件）都是以这种方式启动的，所以严格地说，app_process才是Android Java进程的老祖宗。</p>
<p>下面来分析pm.java，app_process执行的就是它定义的main函数，它相当于Java进程的入口函数，其代码如下：</p>
<p>[–&gt;pm.java]</p>
<p>public static void main(String[] args) {</p>
<p>        newPm().run(args);//创建一个Pm对象，并执行它的run函数</p>
<p>}</p>
<p>  //直接分析run函数</p>
<p>public void run(String[] args) {</p>
<p>       boolean validCommand = false;</p>
<p>        ……</p>
<p>        //获取PKMS的binder客户端</p>
<p>        mPm= IPackageManager.Stub.asInterface(</p>
<p>                        ServiceManager.getService(&quot;package&quot;));</p>
<p>        ……</p>
<p>       mArgs = args;</p>
<p>       String op = args[0];</p>
<p>       mNextArg = 1;</p>
<p>       ……//处理其他命令，这里仅考虑install的处理</p>
<p>        if(&quot;install&quot;.equals(op)) {</p>
<p>           runInstall();</p>
<p>           return;</p>
<p>        }</p>
<p>   ……</p>
<p>}</p>
<p>接下来分析pm.java的runInstall函数，代码如下：</p>
<p>[–&gt;pm.java]</p>
<p>private void runInstall() {</p>
<p>        intinstallFlags = 0;</p>
<p>       String installerPackageName = null;</p>
<p>       String opt;</p>
<p>       while ((opt=nextOption()) != null) {</p>
<p>           if (opt.equals(&quot;-l&quot;)) {</p>
<p>               installFlags |= PackageManager.INSTALL_FORWARD_LOCK;</p>
<p>            } else if (opt.equals(&quot;-r&quot;)) {</p>
<p>               installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;</p>
<p>           } else if (opt.equals(&quot;-i&quot;)) {</p>
<p>               installerPackageName = nextOptionData();</p>
<p>               …… //参数解析</p>
<p>           } ……</p>
<p>        }</p>
<p>       final Uri apkURI;</p>
<p>       final Uri verificationURI;</p>
<p>       final String apkFilePath = nextArg();</p>
<p>       System.err.println(&quot;/tpkg: &quot; + apkFilePath);</p>
<p>        if(apkFilePath != null) {</p>
<p>           apkURI = Uri.fromFile(new File(apkFilePath));</p>
<p>        }……</p>
<p>        //获取Verification Package的文件位置</p>
<p>       final String verificationFilePath = nextArg();</p>
<p>        if(verificationFilePath != null) {</p>
<p>          verificationURI = Uri.fromFile(new File(verificationFilePath));</p>
<p>        }else {</p>
<p>           verificationURI = null;</p>
<p>        }</p>
<p>        //创建PackageInstallObserver，用于接收PKMS的安装结果</p>
<p>       PackageInstallObserver obs = new PackageInstallObserver();</p>
<p>        try{</p>
<p>          //①调用PKMS的installPackageWithVerification完成安装</p>
<p>           mPm.installPackageWithVerification(apkURI, obs,</p>
<p>                                  installFlags,installerPackageName,</p>
<p>                                  verificationURI,null);</p>
<p>    synchronized (obs) {</p>
<p>      while(!obs.finished) {</p>
<p>          try{</p>
<p>                  obs.wait();//等待安装结果</p>
<p>             } ……</p>
<p>         }</p>
<p>         if(obs.result == PackageManager.INSTALL_SUCCEEDED) {</p>
<p>             System.out.println(&quot;Success&quot;);//安装成功，打印Success</p>
<p>         }……//安装失败，打印失败原因</p>
<p>        } ……</p>
<p>    }</p>
<p>Pm解析参数后，最终通过PKMS的Binder客户端调用installPackageWithVerification以完成后续的安装工作，所以，下面进入PKMS看看安装到底是怎么一回事。</p>
<p>4.4.3  installPackageWithVerification函数分析</p>
<p>installPackageWithVerification的代码如下：</p>
<p>[–&gt;PackageManagerService.java::installPackageWithVerification函数]</p>
<p>public void installPackageWithVerification(UripackageURI,</p>
<p>            IPackageInstallObserverobserver,</p>
<p>           int flags, String installerPackageName, Uri verificationURI,</p>
<p>           ManifestDigest manifestDigest) {</p>
<p>        //检查客户端进程是否具有安装Package的权限。在本例中，该客户端进程是shell</p>
<p>       mContext.enforceCallingOrSelfPermission(</p>
<p>               android.Manifest.permission.INSTALL_PACKAGES,null);</p>
<p>       final int uid = Binder.getCallingUid();</p>
<p>       final int filteredFlags;</p>
<p>        if(uid == Process.SHELL_UID || uid == 0) {</p>
<p>             ……//如果通过shell pm的方式安装，则增加INSTALL_FROM_ADB标志</p>
<p>           filteredFlags = flags | PackageManager.INSTALL_FROM_ADB;</p>
<p>        }else {</p>
<p>           filteredFlags = flags &amp; ~PackageManager.INSTALL_FROM_ADB;</p>
<p>        }</p>
<p>        //创建一个Message，code为INIT_COPY，将该消息发送给之前在PKMS构造函数中</p>
<p>       //创建的mHandler对象，将在另外一个工作线程中处理此消息</p>
<p>       final Message msg = mHandler.obtainMessage(INIT_COPY);</p>
<p>        //创建一个InstallParams，其基类是HandlerParams</p>
<p>       msg.obj = new InstallParams(packageURI, observer,</p>
<p>                   filteredFlags,installerPackageName,</p>
<p>                  verificationURI,manifestDigest);</p>
<p>       mHandler.sendMessage(msg);</p>
<p>}</p>
<p>installPackageWithVerification函数倒是蛮清闲，简简单单创建几个对象，然后发送INIT_COPY消息给mHandler，就甩手退出了。根据之前在PKMS构造函数中介绍的知识可知，mHandler被绑定到另外一个工作线程（借助ThreadHandler对象的Looper）中，所以该INIT_COPY消息也将在那个工作线程中进行处理。我们马上转战到那。</p>
<p>1.  INIT_COPY处理</p>
<p>INIT_COPY只是安装流程的第一步。先来看相关代码：</p>
<p>[–&gt;PackageManagerService.java::handleMesssage]</p>
<p>public void handleMessage(Message msg) {</p>
<p>  try {</p>
<p>         doHandleMessage(msg);//调用doHandleMessage函数</p>
<p>       } ……</p>
<p> }</p>
<p> voiddoHandleMessage(Message msg) {</p>
<p> switch(msg.what) {</p>
<p>    caseINIT_COPY: {</p>
<p>      //①这里记录的是params的基类类型HandlerParams，实际类型为InstallParams</p>
<p>     HandlerParams params = (HandlerParams) msg.obj;</p>
<p>      //idx为当前等待处理的安装请求的个数</p>
<p>      intidx = mPendingInstalls.size();</p>
<p>      if(!mBound) {</p>
<p>        /*</p>
<p>        很多读者可能想不到，APK的安装居然需要使用另外一个APK提供的服务，该服务就是</p>
<p>         DefaultContainerService，由DefaultCotainerService.apk提供，</p>
<p>         下面的connectToService函数将调用bindService来启动该服务</p>
<p>        */</p>
<p>        if(!connectToService()) {</p>
<p>             return;</p>
<p>         }else {//如果已经连上，则以idx为索引，将params保存到mPendingInstalls中</p>
<p>           mPendingInstalls.add(idx, params);</p>
<p>          }</p>
<p>        } else {</p>
<p>           mPendingInstalls.add(idx, params);</p>
<p>            if(idx == 0) {</p>
<p>            //如果安装请求队列之前的状态为空，则表明要启动安装</p>
<p>            mHandler.sendEmptyMessage(MCS_BOUND);</p>
<p>           }</p>
<p>         }</p>
<p>        break;</p>
<p>        }</p>
<p>      ……//后续再分析</p>
<p>这里假设之前已经成功启动了DefaultContainerService（以后简称DCS），并且idx为零，所以这是PKMS首次处理安装请求，也就是说，下一个将要处理的是MCS_BOUND消息。</p>
<p>注意connectToService在调用bindService时会传递一个DefaultContainerConnection类型的对象，以接收服务启动的结果。当该服务成功启动后，此对象的onServiceConnected被调用，其内部也将发送MCS_BOUND消息给mHandler。</p>
<p>2.  MCS_BOUND处理</p>
<p>现在，安装请求的状态从INIT_COPY变成MCS_BOUND了，此时的处理流程时怎样的呢？依然在doHandleMessage函数中，直接从对应的case开始，代码如下：</p>
<p>[–&gt;PackageManagerService.java::]</p>
<p>……//接doHandleMesage中的switch/case</p>
<p>case MCS_BOUND: {</p>
<p>  if(msg.obj != null) {</p>
<p>     mContainerService= (IMediaContainerService) msg.obj;</p>
<p>  }</p>
<p>  if(mContainerService == null) {</p>
<p>    ……//如果没法启动该service，则不能安装程序</p>
<p>     mPendingInstalls.clear();</p>
<p>  } else if(mPendingInstalls.size() &gt; 0) {</p>
<p>      HandlerParamsparams = mPendingInstalls.get(0);</p>
<p>      if(params != null) {</p>
<p>         //调用params对象的startCopy函数，该函数由基类HandlerParams定义</p>
<p>        if(params.startCopy()) {</p>
<p>           ……</p>
<p>            if(mPendingInstalls.size() &gt; 0) {</p>
<p>               mPendingInstalls.remove(0);//删除队列头</p>
<p>             }</p>
<p>          if (mPendingInstalls.size() == 0) {</p>
<p>            if (mBound) {</p>
<p>              ……//如果安装请求都处理完了，则需要和Service断绝联系,</p>
<p>              //通过发送MSC_UNB消息处理断交请求。读者可自行研究此情况的处理流程</p>
<p>               removeMessages(MCS_UNBIND);</p>
<p>               Message ubmsg = obtainMessage(MCS_UNBIND);</p>
<p>               sendMessageDelayed(ubmsg, 10000);</p>
<p>            }</p>
<p>            }else {</p>
<p>              //如果还有未处理的请求，则继续发送MCS_BOUND消息。</p>
<p>              //为什么不通过一个循环来处理所有请求呢</p>
<p>              mHandler.sendEmptyMessage(MCS_BOUND);</p>
<p>             }</p>
<p>            }</p>
<p>     } ……</p>
<p>    break;</p>
<p>MCS_BOUND的处理还算简单，就是调用HandlerParams的startCopy函数。在深入分析前，应先认识一下HandlerParams及相关的对象。</p>
<p>（1） HandlerParams和InstallArgs介绍</p>
<p>除了HandlerParams家族外，这里提前请出另外一个家族InstallArgs及其成员，如图4-8所示。</p>
<p>图4-8  HandlerParams及InstallArgs家族成员</p>
<p>由图4-8可知：</p>
<p>·  HandlerParams和InstallArgs均为抽象类。</p>
<p>·  HandlerParams有三个子类，分别是InstallParams、MoveParams和MeasureParams。其中，InstallParams用于处理APK的安装，MoveParams用于处理某个已安装APK的搬家请求（例如从内部存储移动到SD卡上），MeasureParams用于查询某个已安装的APK占据存储空间的大小（例如在设置程序中得到的某个APK使用的缓存文件的大小）。</p>
<p>·  对于InstallParams来说，它还有两个伴儿，即InstallArgs的派生类FileInstallArgs和SdInstallArgs。其中，FileInstallArgs针对的是安装在内部存储的APK，而SdInstallArgs针对的是那些安装在SD卡上的APK。</p>
<p>本节将讨论用于内部存储安装的FileInstallArgs。</p>
<p>提示读者可以在介绍完MountService后，结合本章知识点，自行研究SdInstallArgs的处理流程。</p>
<p>在前面MCS_BOUND的处理中，首先调用InstallParams的startCopy函数，该函数由其基类HandlerParams实现，代码如下：</p>
<p>[–&gt;PackageManagerService.java::HandlerParams.startCopy函数]</p>
<p>final boolean startCopy() {</p>
<p>    booleanres;</p>
<p>    try {</p>
<p>    //MAX_RETIRES目前为4，表示尝试4次安装，如果还不成功，则认为安装失败</p>
<p>    if(++mRetries &gt; MAX_RETRIES) {</p>
<p>        mHandler.sendEmptyMessage(MCS_GIVE_UP);</p>
<p>        handleServiceError();</p>
<p>        return false;</p>
<p>    } else {</p>
<p>         handleStartCopy();//①调用派生类的handleStartCopy函数</p>
<p>         res= true;</p>
<p>      }</p>
<p>    } ……</p>
<p>   handleReturnCode();//②调用派生类的handleReturnCode，返回处理结果</p>
<p>    returnres;</p>
<p>}</p>
<p>在上述代码中，基类的startCopy将调用子类实现的handleStartCopy和handleReturnCode函数。下面来看InstallParams是如何实现这两个函数的。</p>
<p>（2） InstallParams分析</p>
<p>先来看派生类InstallParams的handleStartCopy函数，代码如下：</p>
<p>[–&gt;PackageManagerService::InstallParams.handleStartCopy]</p>
<p>public void handleStartCopy() throwsRemoteException {</p>
<p>    int ret= PackageManager.INSTALL_SUCCEEDED;</p>
<p>    finalboolean fwdLocked = //本书不考虑fwdLocked的情况</p>
<p>        (flags &amp;PackageManager.INSTALL_FORWARD_LOCK) != 0;</p>
<p>    //根据adb install的参数，判断安装位置</p>
<p>    finalboolean onSd = (flags &amp; PackageManager.INSTALL_EXTERNAL) != 0;</p>
<p>    finalboolean onInt = (flags &amp; PackageManager.INSTALL_INTERNAL) != 0;</p>
<p>   PackageInfoLite pkgLite = null;</p>
<p>    if(onInt &amp;&amp; onSd) {</p>
<p>        //APK不能同时安装在内部存储和SD卡上</p>
<p>       ret =PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</p>
<p>    } elseif (fwdLocked &amp;&amp; onSd) {</p>
<p>    //fwdLocked的应用不能安装在SD卡上</p>
<p>      ret =PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</p>
<p>    } else {</p>
<p>       finallong lowThreshold;</p>
<p>       //获取DeviceStorageMonitorService的binder客户端</p>
<p>       finalDeviceStorageMonitorService dsm =                           </p>
<p>             (DeviceStorageMonitorService) ServiceManager.getService(</p>
<p>                                  DeviceStorageMonitorService.SERVICE);</p>
<p>       if(dsm == null) {</p>
<p>         lowThreshold = 0L;</p>
<p>       }else {</p>
<p>       //从DSMS查询内部空间最小余量，默认是总空间的10%</p>
<p>     lowThreshold = dsm.getMemoryLowThreshold();</p>
<p>     }</p>
<p>     try {</p>
<p>        //授权DefContainerService URI读权限</p>
<p>      mContext.grantUriPermission(DEFAULT_CONTAINER_PACKAGE,</p>
<p>                  packageURI,Intent.FLAG_GRANT_READ_URI_PERMISSION);</p>
<p>       //①调用DCS的getMinimalPackageInfo函数，得到一个PackageLite对象</p>
<p>       pkgLite =mContainerService.getMinimalPackageInfo(packageURI,</p>
<p>                                   flags,lowThreshold);</p>
<p>     }finally ……//撤销URI授权</p>
<p>    //PacakgeLite的recommendedInstallLocation成员变量保存该APK推荐的安装路径</p>
<p>   int loc =pkgLite.recommendedInstallLocation;</p>
<p>   if (loc== PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION) {</p>
<p>         ret= PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</p>
<p>   } else if……{</p>
<p>   } else {</p>
<p>       //②根据DCS返回的安装路径，还需要调用installLocationPolicy进行检查</p>
<p>       loc =installLocationPolicy(pkgLite, flags);</p>
<p>       if(!onSd &amp;&amp; !onInt) {</p>
<p>          if(loc == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) {</p>
<p>              flags |= PackageManager.INSTALL_EXTERNAL;</p>
<p>               flags &amp;=~PackageManager.INSTALL_INTERNAL;</p>
<p>              } ……//处理安装位置为内部存储的情况</p>
<p>           }</p>
<p>       }</p>
<p>    }</p>
<p>  //③创建一个安装参数对象，对于安装位置为内部存储的情况，args的真实类型为FileInstallArgs</p>
<p>    finalInstallArgs args = createInstallArgs(this);</p>
<p>    mArgs =args;</p>
<p>    if (ret== PackageManager.INSTALL_SUCCEEDED) {</p>
<p>        final int requiredUid = mRequiredVerifierPackage == null ? -1</p>
<p>                      :getPackageUid(mRequiredVerifierPackage);</p>
<p>        if(requiredUid != -1 &amp;&amp; isVerificationEnabled()) {</p>
<p>            ……//④待会再讨论verification的处理</p>
<p>         }else {</p>
<p>         //⑤调用args的copyApk函数</p>
<p>         ret= args.copyApk(mContainerService, true);</p>
<p>      }</p>
<p>   }</p>
<p>   mRet =ret;//确定返回值</p>
<p>}</p>
<p>在以上代码中，一共列出了五个关键点，总结如下：</p>
<p>·  调用DCS的getMinimalPackageInfo函数，将得到一个PackageLite对象，该对象是一个轻量级的用于描述APK的结构（相比PackageParser.Package来说）。在这段代码逻辑中，主要想取得其recommendedInstallLocation的值。此值表示该APK推荐的安装路径。</p>
<p>·  调用installLocationPolicy检查推荐的安装路径。例如系统Package不允许安装在SD卡上。</p>
<p>·  createInstallArgs将根据安装位置创建不同的InstallArgs。如果是内部存储，则返回FileInstallArgs，否则为SdInstallArgs。</p>
<p>·  在正式安装前，应先对该APK进行必要的检查。这部分代码后续再介绍。</p>
<p>·  调用InstallArgs的copyApk。对本例来说，将调用FileInstallArgs的copyApk函数。</p>
<p>下面围绕这五个基本关键点展开分析，其中installLocationPolicy和createInstallArgs比较简单，读者可自行研究。</p>
<p>3.  handleStartCopy分析</p>
<p>（1） DefaultContainerService分析</p>
<p>首先分析DCS的getMinimalPackageInfo函数，其代码如下：</p>
<p>[–&gt;DefaultContainerService.java::getMinimalPackageInfo函数]</p>
<p>public PackageInfoLite getMinimalPackageInfo(finalUri fileUri, int flags,</p>
<p>                                                      longthreshold) {</p>
<p>   //注意该函数的参数：fileUri指向该APK的文件路径（此时还在/data/local/tmp下）</p>
<p>  PackageInfoLite ret = new PackageInfoLite();</p>
<p>   ……</p>
<p>   Stringscheme = fileUri.getScheme();</p>
<p>   ……</p>
<p>   StringarchiveFilePath = fileUri.getPath();</p>
<p>  DisplayMetrics metrics = new DisplayMetrics();</p>
<p>  metrics.setToDefaults();</p>
<p>   //调用PackageParser的parsePackageLite解析该APK文件</p>
<p>  PackageParser.PackageLite pkg =</p>
<p>         PackageParser.parsePackageLite(archiveFilePath,0);</p>
<p>   if (pkg== null) {//解析失败</p>
<p>   ……//设置错误值</p>
<p>   returnret;</p>
<p> }</p>
<p>  ret.packageName = pkg.packageName;</p>
<p>  ret.installLocation = pkg.installLocation;</p>
<p>  ret.verifiers = pkg.verifiers;</p>
<p>   //调用recommendAppInstallLocation，取得一个合理的安装位置</p>
<p>  ret.recommendedInstallLocation =</p>
<p>          recommendAppInstallLocation(pkg.installLocation,archiveFilePath,</p>
<p>                                           flags, threshold);</p>
<p>   returnret;</p>
<p>}</p>
<p>APK可在AndroidManifest.xml中声明一个安装位置，不过DCS除了解析该位置外，还需要做进一步检查，这个工作由recommendAppInstallLocation函数完成，代码如下：</p>
<p>[–&gt;DefaultContainerService.java::recommendAppInstallLocation函数]</p>
<p>private int recommendAppInstallLocation(intinstallLocation,</p>
<p>                               StringarchiveFilePath, int flags,long threshold) {</p>
<p> int prefer;</p>
<p> booleancheckBoth = false;</p>
<p> check_inner: {</p>
<p>   if((flags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0) {</p>
<p>        prefer = PREFER_INTERNAL;</p>
<p>        break check_inner; //根据FOWRAD_LOCK的情况，只能安装在内部存储</p>
<p>    } elseif ((flags &amp; PackageManager.INSTALL_INTERNAL) != 0) {</p>
<p>        prefer = PREFER_INTERNAL;</p>
<p>        break check_inner;</p>
<p>   }</p>
<p>   ……//检查各种情况</p>
<p>  } else if(installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {</p>
<p>     prefer= PREFER_INTERNAL;//一般设定的位置为AUTO，默认是内部空间</p>
<p>    checkBoth = true; //设置checkBoth为true</p>
<p>     breakcheck_inner;</p>
<p> }</p>
<p>  //查询settings数据库中的secure表，获取用户设置的安装路径</p>
<p>  intinstallPreference =</p>
<p>        Settings.System.getInt(getApplicationContext()</p>
<p>            .getContentResolver(),</p>
<p>             Settings.Secure.DEFAULT_INSTALL_LOCATION,</p>
<p>             PackageHelper.APP_INSTALL_AUTO);</p>
<p>   if(installPreference == PackageHelper.APP_INSTALL_INTERNAL) {</p>
<p>       prefer = PREFER_INTERNAL;</p>
<p>       break check_inner;</p>
<p>   } else if(installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {</p>
<p>      prefer= PREFER_EXTERNAL;</p>
<p>      breakcheck_inner;</p>
<p>   }</p>
<p>   prefer =PREFER_INTERNAL;</p>
<p>  }</p>
<p>  //判断外部存储空间是否为模拟的，这部分内容我们以后再介绍</p>
<p>  finalboolean emulated = Environment.isExternalStorageEmulated();</p>
<p>  final FileapkFile = new File(archiveFilePath);</p>
<p>  booleanfitsOnInternal = false;</p>
<p>  if(checkBoth || prefer == PREFER_INTERNAL) {</p>
<p>      try {//检查内部存储空间是否足够大</p>
<p>          fitsOnInternal = isUnderInternalThreshold(apkFile, threshold);</p>
<p>      } ……</p>
<p>   }</p>
<p>   booleanfitsOnSd = false;</p>
<p>   if(!emulated &amp;&amp; (checkBoth || prefer == PREFER_EXTERNAL)) {</p>
<p>        try{ //检查外部存储空间是否足够大</p>
<p>         fitsOnSd = isUnderExternalThreshold(apkFile);</p>
<p>       } ……</p>
<p>   }</p>
<p>  if (prefer== PREFER_INTERNAL) {</p>
<p>      if(fitsOnInternal) {//返回推荐安装路径为内部空间</p>
<p>        return PackageHelper.RECOMMEND_INSTALL_INTERNAL;</p>
<p>         }</p>
<p>    } elseif (!emulated &amp;&amp; prefer == PREFER_EXTERNAL) {</p>
<p>      if(fitsOnSd) {//返回推荐安装路径为外部空间</p>
<p>         returnPackageHelper.RECOMMEND_INSTALL_EXTERNAL;</p>
<p>     }</p>
<p> }</p>
<p> if(checkBoth) {</p>
<p>     if(fitsOnInternal) {//如果内部存储满足条件，先返回内部空间</p>
<p>        return PackageHelper.RECOMMEND_INSTALL_INTERNAL;</p>
<p>       }else if (!emulated &amp;&amp; fitsOnSd) {</p>
<p>         return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;</p>
<p>      }</p>
<p>  }</p>
<p>     …… //到此，前几个条件都不满足，此处将根据情况返回一个明确的错误值</p>
<p>     returnPackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;</p>
<p>   }</p>
<p>}</p>
<p>DCS的getMinimalPackageInfo函数为了得到一个推荐的安装路径做了不少工作，其中，各种安装策略交叉影响。这里总结一下相关的知识点：</p>
<p>·  APK在AndroidManifest.xml中设置的安装点默认为AUTO，在具体对应时倾向内部空间。</p>
<p>·  用户在Settings数据库中设置的安装位置。</p>
<p>·  检查外部存储或内部存储是否有足够空间。</p>
<p>（2） InstallArgs的copyApk函数分析</p>
<p>至此，我们已经得到了一个合适的安装位置（先略过Verification这一步）。下一步工作就由copyApk来完成。根据函数名可知该函数将完成APK文件的复制工作，此中会有蹊跷吗？来看下面的代码。</p>
<p>[–&gt;PackageManagerService.java::InstallArgs.copyApk函数]</p>
<p>int copyApk(IMediaContainerService imcs, booleantemp) throws RemoteException {</p>
<p>   if (temp){</p>
<p>  /*</p>
<p>    本例中temp参数为true，createCopyFile将在/data/app下创建一个临时文件。</p>
<p>    临时文件名为vmdl-随机数.tmp。为什么会用这样的文件名呢？</p>
<p>    因为PKMS通过Linux的inotify机制监控了/data/app,目录，如果新复制生成的文件名后缀</p>
<p>    为apk，将触发PKMS扫描。为了防止发生这种情况，这里复制生成的文件才有了</p>
<p>    如此奇怪的名字</p>
<p>  */</p>
<p>   createCopyFile();</p>
<p>  }</p>
<p>   FilecodeFile = new File(codeFileName);</p>
<p>   ……</p>
<p>  ParcelFileDescriptor out = null;</p>
<p>   try {</p>
<p>     out =ParcelFileDescriptor.open(codeFile,</p>
<p>                            ParcelFileDescriptor.MODE_READ_WRITE);</p>
<p>           }……</p>
<p>     int ret= PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</p>
<p>     try {</p>
<p>       mContext.grantUriPermission(DEFAULT_CONTAINER_PACKAGE,</p>
<p>                   packageURI,Intent.FLAG_GRANT_READ_URI_PERMISSION);</p>
<p>        //调用DCS的copyResource，该函数将执行复制操作，最终结果是/data/local/tmp</p>
<p>       //下的APK文件被复制到/data/app下，文件名也被换成vmdl-随机数.tmp</p>
<p>         ret= imcs.copyResource(packageURI, out);</p>
<p>    }finally {</p>
<p>      ……//关闭out，撤销URI授权</p>
<p>           }</p>
<p>    returnret;</p>
<p> }</p>
<p>关于临时文件，这里提供一个示例，如图4-9所示。</p>
<p>图4-9  createCopyFile生成的临时文件</p>
<p>由图4-9可知：/data/app下有两个文件，第一个是正常的APK文件，第二个是createCopyFile生成的临时文件。</p>
<p>4.  handleReturnCode分析</p>
<p>在HandlerParams的startCopy函数中，handleStartCopy执行完之后，将调用handleReturnCode开展后续工作，代码如下：</p>
<p>[–&gt;PackageManagerService.java::InstallParams.HandleParams]</p>
<p>void handleReturnCode() {</p>
<p>       if(mArgs != null) {</p>
<p>         //调用processPendingInstall函数，mArgs指向之前创建的FileInstallArgs对象</p>
<p>        processPendingInstall(mArgs, mRet);</p>
<p>    }</p>
<p>}</p>
<p>[–&gt;PackageManagerService.java::]</p>
<p>private void processPendingInstall(finalInstallArgs args,</p>
<p>                                  final intcurrentStatus) {</p>
<p>   //向mHandler中抛一个Runnable对象</p>
<p>  mHandler.post(new Runnable() {</p>
<p>       publicvoid run() {</p>
<p>        mHandler.removeCallbacks(this);</p>
<p>         //创建一个PackageInstalledInfo对象，</p>
<p>       PackageInstalledInfo res = new PackageInstalledInfo();</p>
<p>       res.returnCode = currentStatus;</p>
<p>       res.uid = -1;</p>
<p>       res.pkg = null;</p>
<p>       res.removedInfo = new PackageRemovedInfo();</p>
<p>        if(res.returnCode == PackageManager.INSTALL_SUCCEEDED) {</p>
<p>           //①调用FileInstallArgs的doPreInstall</p>
<p>           args.doPreInstall(res.returnCode);</p>
<p>           synchronized (mInstallLock) {</p>
<p>               //②调用installPackageLI进行安装</p>
<p>               installPackageLI(args, true, res);</p>
<p>            }</p>
<p>          //③调用FileInstallArgs的doPostInstall</p>
<p>         args.doPostInstall(res.returnCode);</p>
<p>        }</p>
<p>       final boolean update = res.removedInfo.removedPackage != null;</p>
<p>       boolean doRestore = (!update&amp;&amp; res.pkg != null &amp;&amp;</p>
<p>                    res.pkg.applicationInfo.backupAgentName!= null);</p>
<p>       int token;//计算一个ID号</p>
<p>        if(mNextInstallToken &lt; 0) mNextInstallToken = 1;</p>
<p>            token = mNextInstallToken++;</p>
<p>            //创建一个PostInstallData对象</p>
<p>            PostInstallData data = new PostInstallData(args, res);</p>
<p>           //保存到mRunningInstalls结构中，以token为key</p>
<p>           mRunningInstalls.put(token, data);</p>
<p>           if (res.returnCode ==PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore)</p>
<p>             {</p>
<p>                  ……//备份恢复的情况暂时不考虑</p>
<p>            }</p>
<p>           if(!doRestore) {</p>
<p>            //④抛一个POST_INSTALL消息给mHandler进行处理</p>
<p>            Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</p>
<p>            mHandler.sendMessage(msg);</p>
<p>           }</p>
<p>        }</p>
<p>        });</p>
<p>}</p>
<p>由上面代码可知，handleReturnCode主要做了4件事情：</p>
<p>·  调用InstallArgs的doPreInstall函数，在本例中是FileInstallArgs的doPreInstall函数。</p>
<p>·  调用PKMS的installPackageLI函数进行APK安装，该函数内部将调用InstallArgs的doRename对临时文件进行改名。另外，还需要扫描此APK文件。此过程和之前介绍的“扫描系统Package”一节的内容类似。至此，该APK中的私有财产就全部被登记到PKMS内部进行保存了。</p>
<p>·  调用InstallArgs的doPostInstall函数，在本例中是FileInstallArgs的doPostInstall函数。</p>
<p>·  此时，该APK已经安装完成（不论失败还是成功），继续向mHandler抛送一个POST_INSTALL消息，该消息携带一个token，通过它可从mRunningInstalls数组中取得一个PostInstallData对象。</p>
<p>提示对于FileInstallArgs来说，其doPreInstall和doPostInstall都比较简单，读者可自行阅读相关代码。另外，读者也可自行研究PKMS的installPackageLI函数。</p>
<p>这里介绍一下FileInstallArgs的doRename函数，它的功能是将临时文件改名，最终的文件的名称一般为“包名-数字.apk”。其中，数字是一个index，从1开始。读者可参考图4-9中/data/app目录下第一个文件的文件名。</p>
<ol start="5">
<li> POST_INSTALL处理</li>
</ol>
<p>现在需要处理POST_INSTALL消息，因为adb install还等着安装结果呢。相关代码如下：</p>
<p>[–&gt;PackageManagerService.java::doHandleMessage函数]</p>
<p>……//接前面的switch/case</p>
<p>case POST_INSTALL: {</p>
<p>  PostInstallData data = mRunningInstalls.get(msg.arg1);</p>
<p> mRunningInstalls.delete(msg.arg1);</p>
<p>  booleandeleteOld = false;</p>
<p>  if (data!= null) {</p>
<p>      InstallArgs args = data.args;</p>
<p>      PackageInstalledInfo res = data.res;</p>
<p>       if(res.returnCode == PackageManager.INSTALL_SUCCEEDED) {</p>
<p>           res.removedInfo.sendBroadcast(false, true);</p>
<p>           Bundle extras = new Bundle(1);</p>
<p>           extras.putInt(Intent.EXTRA_UID, res.uid);</p>
<p>           final boolean update = res.removedInfo.removedPackage != null;</p>
<p>           if (update) {</p>
<p>                extras.putBoolean(Intent.EXTRA_REPLACING, true);</p>
<p>           }</p>
<p>           //发送PACKAGE_ADDED广播</p>
<p>           sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,</p>
<p>                    res.pkg.applicationInfo.packageName,extras, null, null);</p>
<p>           if (update) {</p>
<p>           /*</p>
<p>           如果是APK升级，那么发送PACKAGE_REPLACE和MY_PACKAGE_REPLACED广播。</p>
<p>          二者不同之处在于PACKAGE_REPLACE将携带一个extra信息</p>
<p>         */</p>
<p>       }</p>
<p>      Runtime.getRuntime().gc();</p>
<p>       if(deleteOld) {</p>
<p>         synchronized (mInstallLock) {</p>
<p>           //调用FileInstallArgs的doPostDeleteLI进行资源清理</p>
<p>           res.removedInfo.args.doPostDeleteLI(true);</p>
<p>            }</p>
<p>        }</p>
<p>      if(args.observer != null) {</p>
<p>      try {</p>
<p>          // 向pm通知安装的结果</p>
<p>        args.observer.packageInstalled(res.name, res.returnCode);</p>
<p>      } ……</p>
<p>} break;</p>
<p>4.4.4  APK 安装流程总结</p>
<p>没想到APK的安装流程竟然如此复杂，其目的无非是让APK中的私人财产公有化。相比之下，在PKMS构造函数中进行公有化改造就非常简单。另外，如果考虑安装到SD卡的处理流程，那么APK的安装将会更加复杂。</p>
<p>这里要总结APK安装过程中的几个重要步骤，如图4-10所示。</p>
<p>图4-10  APK安装流程</p>
<p>图4-10中列出以下内容：</p>
<p>·  安装APK到内部存储空间这一工作流程涉及的主要对象包括：PKMS、DCS、InstallParams和FileInstallArgs。</p>
<p>·  此工作流程中每个对象涉及到的关键函数。</p>
<p>·  对象之间的调用通过虚线表达，调用顺序通过①②③等标明。</p>
<p>4.4.5  Verification介绍</p>
<p>Verification功能的出现将打乱图4-10的工作流程，所以这部分内容要放在最后来介绍。其代码在InstallParams的handleStartCopy中，如下所示：</p>
<p>[–&gt;PackageManagerService.java::InstallParams.handleStartCopy函数]</p>
<p>  ……//此处已经获得了合适的安装位置</p>
<p>  finalInstallArgs args = createInstallArgs(this);</p>
<p>  mArgs =args;</p>
<p>if (ret == PackageManager.INSTALL_SUCCEEDED) {</p>
<p>    final int requiredUid =mRequiredVerifierPackage == null ? -1</p>
<p>                        :getPackageUid(mRequiredVerifierPackage);</p>
<p>  if (requiredUid != -1 &amp;&amp;isVerificationEnabled()) {</p>
<p>     //创建一个Intent，用于查找满足条件的广播接收者</p>
<p>   finalIntent verification = new</p>
<p>                    Intent(Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</p>
<p>   verification.setDataAndType(packageURI, PACKAGE_MIME_TYPE);</p>
<p>   verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</p>
<p>    //查找满足Intent条件的广播接收者</p>
<p>    finalList&lt;ResolveInfo&gt; receivers = queryIntentReceivers(</p>
<p>               verification,null,PackageManager.GET_DISABLED_COMPONENTS);</p>
<p>    // verificationId为当前等待Verification的安装包个数</p>
<p>    finalint verificationId = mPendingVerificationToken++;</p>
<p>   //设置Intent的参数，例如要校验的包名</p>
<p>    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID,</p>
<p>                              VerificationId);</p>
<p>    verification.putExtra(</p>
<p>                            PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,</p>
<p>                            installerPackageName);</p>
<p>  verification.putExtra(</p>
<p>                   PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,flags);</p>
<p>   if(verificationURI != null) {</p>
<p>     verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,</p>
<p>                                verificationURI);</p>
<p>    }</p>
<p>  finalPackageVerificationState verificationState = new</p>
<p>                       PackageVerificationState(requiredUid,args);</p>
<p>  //将上面创建的PackageVerificationState保存到mPendingVerification中</p>
<p> mPendingVerification.append(verificationId, verificationState);</p>
<p>  //筛选符合条件的广播接收者</p>
<p>  finalList&lt;ComponentName&gt; sufficientVerifiers =</p>
<p>                   matchVerifiers(pkgLite,receivers,verificationState);</p>
<p>  if (sufficientVerifiers != null) {</p>
<p>      finalint N = sufficientVerifiers.size();</p>
<p>      ……</p>
<p>      for(int i = 0; i &lt; N; i++) {</p>
<p>       finalComponentName verifierComponent = sufficientVerifiers.get(i);</p>
<p>       final Intent sufficientIntent = newIntent(verification);</p>
<p>       sufficientIntent.setComponent(verifierComponent);</p>
<p>       //向校验包发送广播</p>
<p>       mContext.sendBroadcast(sufficientIntent);</p>
<p>       }</p>
<p>    }</p>
<p> }</p>
<p>   //除此之外，如果在执行adb install的时候指定了校验包，则需要向其单独发送校验广播</p>
<p>   finalComponentName requiredVerifierComponent =</p>
<p>                        matchComponentForVerifier(mRequiredVerifierPackage,</p>
<p>                       receivers);</p>
<p>   if (ret == PackageManager.INSTALL_SUCCEEDED</p>
<p>        &amp;&amp;mRequiredVerifierPackage != null) {</p>
<p>      verification.setComponent(requiredVerifierComponent);</p>
<p>      mContext.sendOrderedBroadcast(verification,</p>
<p>      android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</p>
<p>           new BroadcastReceiver() {</p>
<p>           //调用sendOrderdBroadcast，并传递一个BroadcastReceiver，该对象将在</p>
<p>          //广播发送的最后被调用。读者可参考sendOrderdBroadcast的文档说明</p>
<p>           public void onReceive(Context context, Intent intent) {</p>
<p>            final Message msg =mHandler.obtainMessage(</p>
<p>                      CHECK_PENDING_VERIFICATION);</p>
<p>            msg.arg1 = verificationId;</p>
<p>            //设置一个超时执行时间，该值来自Settings数据库的secure表，默认为60秒</p>
<p>            mHandler.sendMessageDelayed(msg, getVerificationTimeout());</p>
<p>           }</p>
<p>         },null, 0, null, null);</p>
<p>           mArgs = null;</p>
<p>        }</p>
<p>    }……//不用做Verification的流程</p>
<p>PKMS的Verification工作其实就是收集安装包的信息，然后向对应的校验者发送广播。但遗憾的是，当前Android中还没有能处理Verification的组件。</p>
<p>另外，该组件处理完Verification后，需要调用PKMS的verifyPendingInstall函数，以通知校验结果。</p>
<p>4.5  queryIntentActivities分析</p>
<p>PKMS除了负责Android系统中Package的安装、升级、卸载外，还有一项很重要的职责，就是对外提供统一的信息查询功能，其中包括查询系统中匹配某Intent的Activities、BroadCastReceivers或Services等。本节将以查询匹配某Intent的Activities为例，介绍PKMS在这方便提供的服务。</p>
<p>正式分析queryIntentActivities之前，先来认识一下Intent及IntentFilter。</p>
<p>4.5.1  Intent及IntentFilter介绍</p>
<p>1.  Intent介绍</p>
<p>Intent中文是“意图”的意思，它是Android系统中一个很重要的概念，其基本思想来源于对日常生活及行为的高度抽象。我们结合用人单位招聘的例子介绍Intent背后的思想。</p>
<p>·  假设某用人单位现需招聘人员完成某项工作。该单位首先其需求发给猎头公司。</p>
<p>·  猎头公司从其内部的信息库中查找合适的人选。猎头公司除了考虑用人单位的需求外，还需要考虑求职者本身的要求，例如有些求职者对工作地点、加班等有要求。</p>
<p>·  二者匹配后，就会得到满足要求的求职者。之后用人单位将工作交给满足条件的人员来完成。</p>
<p>在现实生活中，用人单位还需和求职者进行一系列其他交互工作，例如面试、签订合同之类。但是从完成工作的角度来看，只要把工作任务交给满足要求的求职者去做即可，中间的系列行为和工作任务本身没有太大关系。因此，Android并未将这部分内容抽象化。</p>
<p>意图，是一个非常抽象的概念，在编码设计中，如何将它实例化呢？Android系统明确指定的一个Intent可由两方面属性来衡量。</p>
<p>·  主要属性：包括Action和Data。其中Action用于表示该Intent所表达的动作意图、Data用于表示该Action所操作的数据。</p>
<p>·  次要属性：包括Category、Type、Component和Extras。其中Category表示类别，Type表示数据的MIME类型，Component可用于指定特定的Intent响应者（例如指定广播接收者为某Package的某个BroadcastReceiver），Extras用于承载其他的信息。</p>
<p>如果Intent是一份用工需求表，那么上述信息就是该表的全部可填项。在实际使用中，可根据需要填写该表的内容。</p>
<p>当这份需求表传给猎头公司后，猎头公司就根据该表所填写的内容，进一步对Intent进行分类。</p>
<p>·  Explicit Intents：这类Intent明确指明了要找哪些人。在代码中通过setComponent或setClass来锁定目标对象。处理这种Intent，工作就很轻松了。</p>
<p>·  Implicit Intents：这一类Intents只标明了工作内容，而没有指定具体人名。对于这类意图，猎头公司不得不做一系列复杂的工作才能找到满足用人单位需求的人才。</p>
<p>Intent就先介绍到这里。下面来看在这次招聘过程中求职者填写的信息。</p>
<ol start="2">
<li> IntentFilter介绍</li>
</ol>
<p>求职方需要填写IntentFilter来表达自己的诉求。Andorid规定了3项内容.</p>
<p>·  Action：求职方支持的Intent动作（和Intent中的Action对应）。</p>
<p>·  Category：求职方支持的Intent种类（和Intent的Category对应）。</p>
<p>·  Data：求职方支持的Intent 数据（和Intent的Data对应，包括URI和MIME类型）。</p>
<p>至此，猎头公司既有了需求，又有了求职者的信息，马上要做的工作就是匹配查询。在Android中，该工作被称为Intent Resolution。由于现在及未来人才都是最宝贵的资源，因此猎头公司在做匹配工作时，将以Intent Filter列出的3项内容为参考标准，具体步骤如下：</p>
<p>·  首先匹配IntentFilter的Action，如果Intent设置的Action不满足IntentFilter的Action，则匹配失败。如果IntentFilter未设定Action，则匹配成功。</p>
<p>·  然后检查IntentFilter的Category，匹配方法同Action的匹配，唯一有些例外的是Category为CATEGORY_DEFAULT的情况。</p>
<p>·  最后检查Data。Data的匹配过程比较繁琐，因为它和IntentFilter设置的Data内容有关，见接下来的介绍。</p>
<p>IntentFilter中的Data可以包括两个内容。</p>
<p>·  URI：完整格式为“scheme://host:port/path”，包含4个部分，scheme、host、port和path。其中host和port合起来标示URI authority，用于指明服务器的网络地址（IP加端口号）。由于URI最多可包含,4个部分，因此要根据情况相应部分做匹配检查。</p>
<p>·  Date type：指定数据的MIME类型</p>
<p>要特别注意的是，URI中也可以携带数据的类型信息，所以在匹配过程中，还需要考虑URI中指定的数据类型。</p>
<p>提示关于具体的匹配流程，请读者务必阅读SDK docs/guide/topics/intents/intents-filters.html中的说明。</p>
<p>4.5.2  Activity信息的管理</p>
<p>前面在介绍PKMS扫描APK时提到，PKMS将解析得到的Package私有的Activity信息加入到自己的数据结构mActivities中保存。先来回顾一下代码：</p>
<p>[–&gt;PacakgeManagerService.java::scanPackageLI函数]</p>
<p>     ……//此时APK文件已经解析完成</p>
<p>     N =pkg.activities.size();//取出该APK中包含的Activities信息</p>
<p>     r =null;</p>
<p>     for (i=0; i&lt;N; i++) {</p>
<p>        PackageParser.Activity a = pkg.activities.get(i);</p>
<p>        a.info.processName = fixProcessName(pkg.applicationInfo.processName,</p>
<p>                                     a.info.processName,pkg.applicationInfo.uid);</p>
<p>         mActivities.addActivity(a,&quot;activity&quot;);//①加到mActivities中保存</p>
<p> }</p>
<p>上面的代码中有两个比较重要的数据结构，如图4-11所示。</p>
<p>图4-11  相关数据结构示意图</p>
<p>结合代码，由图4-11可知：</p>
<p>·  mActivities为ActivityIntentResolver类型，是PKMS的成员变量，用于保存系统中所有与Activity相关的信息。此数据结构内部有一个mActivities变量，它以ComponetName为Key，保存PackageParser.Activity对象</p>
<p>·  从APK中解析得到的所有和Activity相关的信息（包括在XML中声明的IntentFilter标签）都由PacakgeParser.Activity来保存。</p>
<p>前面代码中调用addActivity函数完成了私有信息的公有化。addActivity函数的代码如下：</p>
<p>[–&gt;PacakgeManagerService.java::ActivityIntentResolver.addActivity]</p>
<p>public final voidaddActivity(PackageParser.Activity a, String type) {</p>
<p>     finalboolean systemApp = isSystemApp(a.info.applicationInfo);</p>
<p>     //将Component和Activity保存到mActivities中</p>
<p>    mActivities.put(a.getComponentName(), a);</p>
<p>     finalint NI = a.intents.size();</p>
<p>     for(int j=0; j&lt;NI; j++) {</p>
<p>     //ActivityIntentInfo存储的就是XML中声明的IntentFilter信息</p>
<p>    PackageParser.ActivityIntentInfo intent = a.intents.get(j);</p>
<p>     if(!systemApp &amp;&amp; intent.getPriority() &gt; 0 &amp;&amp;&quot;activity&quot;.equals(type)) {</p>
<p>          //非系统APK的priority必须为0。后续分析中将介绍priority的作用</p>
<p>          intent.setPriority(0);</p>
<p>        }</p>
<p>         addFilter(intent);//接下来将分析这个函数</p>
<p>      }</p>
<p> }</p>
<p>下面来分析addFilter函数，这里涉及较多的复杂数据结构，代码如下：</p>
<p>[–&gt;IntentResolver.java::IntentResolver.addFilter]</p>
<p>public void addFilter(F f) {</p>
<p>        ……</p>
<p>       mFilters.add(f);//mFilters保存所有IntentFilter信息</p>
<p>       //除此之外，为了加快匹配工作的速度，还需要分类保存IntentFilter信息</p>
<p>       //下边register_xxx函数的最后一个参数用于打印信息</p>
<p>        intnumS = register_intent_filter(f, f.schemesIterator(),</p>
<p>                         mSchemeToFilter,&quot;      Scheme: &quot;);</p>
<p>        intnumT = register_mime_types(f, &quot;     Type: &quot;);</p>
<p>        if(numS == 0 &amp;&amp; numT == 0) {</p>
<p>           register_intent_filter(f, f.actionsIterator(),</p>
<p>                           mActionToFilter,&quot;      Action: &quot;);</p>
<p>        }</p>
<p>        if(numT != 0) {</p>
<p>           register_intent_filter(f, f.actionsIterator(),</p>
<p>                   mTypedActionToFilter, &quot;     TypedAction: &quot;);</p>
<p>        }</p>
<p> }</p>
<p>正如代码注释中所说，为了加快匹配工作的速度，这里使用了泛型编程并定义了较多的成员变量。下面总结一下这些变量的作用（注意，除mFilters为HashSet&lt;F&gt;类型外，其他成员变量的类型都是HashMap&lt;String, ArrayList&lt;F&gt;&gt;，其中F为模板参数）。</p>
<p>·  mSchemeToFilter：用于保存URI中与schema相关的IntentFilter信息。</p>
<p>·  mActionToFilter：用于保存仅设置Action条件的IntentFilter信息。</p>
<p>·  mTypedActionToFilter：用于保存既设置了Action又设置了Data的MIME类型的IntentFilter信息。</p>
<p>·  mFilters：用于保存所有IntentFilter信息</p>
<p>·  mWildTypeToFilter：用于保存设置了Data类型类似“image/*”的IntentFilter，但是设置MIME类型类似“Image/jpeg”的不算在此类。</p>
<p>·  mTypeToFilter：除了包含mWildTypeToFilter外，还包含那些指明了Data类型为确定参数的IntentFilter信息，例如“image/*”和”image/jpeg“等都包含在mTypeToFilter中。</p>
<p>·  mBaseTypeToFilter：包含MIME中Base 类型的IntentFilter信息，但不包括Sub type为“*”的IntentFilter。</p>
<p>不妨举个例子来说明这些变量的用法。</p>
<p>假设，在XML中声明一个IntentFilter，代码如下：</p>
<p>&lt;intent-filter android:label=&quot;test&quot;&gt;</p>
<p>   &lt;actionandroid:name=&quot;android.intent.action.VIEW&quot; /&gt;</p>
<p>   dataandroid:mimeType=&quot;audio/*&quot; android:scheme=&quot;http&quot;</p>
<p> &lt;/intent-filter&gt;</p>
<p>那么：</p>
<p>·  在mTypedActionToFilter中能够以“android.intent.action.VIEW”为key找到该IntentFilter。</p>
<p>·  在mWildTypeToFilter和mTypeToFilter中能够以“audio”为key找到该IntentFilter。</p>
<p>·  在mSchemeToFilter中能够以”http“为key找到该IntentFilter。</p>
<p>下面来分析Intent匹配查询工作。</p>
<p>4.5.2  Intent 匹配查询分析</p>
<p>1.  客户端查询</p>
<p>客户端通过ApplicationPackageManager输出的queryIntentActivities函数向PKMS发起一次查询请求，代码如下：</p>
<p>[–&gt;ApplicationPackageManager.java::queryIntentActivities]</p>
<p>public List&lt;ResolveInfo&gt;queryIntentActivities(Intent intent, int flags) {</p>
<p>   try {</p>
<p>           return mPM.queryIntentActivities(</p>
<p>               intent,//下面这句话很重要</p>
<p>               intent.resolveTypeIfNeeded(mContext.getContentResolver()),</p>
<p>               flags);</p>
<p>        }……</p>
<p>}</p>
<p>如果Intent的Data包含一个URI，那么就需要查询该URI的提供者（即ContentProvider）以取得该数据的数据类型。读者可自行阅读resolveTypeIfNeeded函数的代码。</p>
<p>另外，flags参数目前有3个可选值，分别是MATCH_DEFAULT_ONLY、GET_INTENT_FILTERS和GET_RESOLVED_FILTER。详细信息读者可查询SDK相关文档。</p>
<p>下面来看PKMS对匹配查询的处理。</p>
<p>2.  queryIntentActivities分析</p>
<p>该函数代码如下：</p>
<p>[–&gt;PacakgeManagerService.java::queryIntentActivities]</p>
<p>public List&lt;ResolveInfo&gt;queryIntentActivities(Intent intent,</p>
<p>                                  String resolvedType, int flags) {</p>
<p>       final ComponentName comp = intent.getComponent();</p>
<p>        if(comp != null) {</p>
<p>            //Explicit的Intents，直接根据component得到对应的ActivityInfo</p>
<p>           final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1);</p>
<p>           final ActivityInfo ai = getActivityInfo(comp, flags);</p>
<p>           if (ai != null) {</p>
<p>               final ResolveInfo ri = new ResolveInfo();</p>
<p>               //ResovlerInfo的activityInfo指向查询得到的ActivityInfo</p>
<p>               ri.activityInfo = ai;</p>
<p>               list.add(ri);</p>
<p>           }</p>
<p>           return list;</p>
<p>        }</p>
<p>       synchronized (mPackages) {</p>
<p>           final String pkgName = intent.getPackage();</p>
<p>           if (pkgName == null) {</p>
<p>                        //Implicit Intents，我们重点分析此中情况</p>
<p>               return mActivities.queryIntent(intent, resolvedType, flags);</p>
<p>           }</p>
<p>            //Intent指明了PackageName，比Explicit Intents情况差一点</p>
<p>           final PackageParser.Package pkg = mPackages.get(pkgName);</p>
<p>           if (pkg != null) {</p>
<p>               //其实是从该Package包含的Activities中进行匹配查询</p>
<p>               return mActivities.queryIntentForPackage(intent, resolvedType,</p>
<p>                                           flags, pkg.activities);</p>
<p>           }</p>
<p>           return new ArrayList&lt;ResolveInfo&gt;();</p>
<p>        }</p>
<p>    }</p>
<p>上边代码分三种情况：</p>
<p>·  如果Intent指明了Component，则直接查询该Component对应的ActivityInfo。</p>
<p>·  如果Intent指明了Package名，则根据Package名找到该Package，然后再从该Package包含的Activities中进行匹配查询。</p>
<p>·  如果上面条件都不满足，则需要在全系统范围内进行匹配查询，这就是queryIntent的工作。</p>
<p>queryIntent函数的代码如下：</p>
<p>public List&lt;ResolveInfo&gt; queryIntent(Intentintent, String resolvedType,</p>
<p>                                            intflags) {</p>
<p>    mFlags =flags;</p>
<p>   //调用基类的queryIntent函数</p>
<p>   returnsuper.queryIntent(intent, resolvedType,</p>
<p>               (flags&amp;PackageManager.MATCH_DEFAULT_ONLY) != 0);</p>
<p> }</p>
<p>[–&gt;IntentResolver.java::queryIntent]</p>
<p>public List&lt;R&gt; queryIntent(Intent intent,String resolvedType,</p>
<p>                             booleandefaultOnly) {</p>
<p>  Stringscheme = intent.getScheme();</p>
<p> ArrayList&lt;R&gt; finalList = new ArrayList&lt;R&gt;();</p>
<p> //最多有四轮匹配工作要做</p>
<p> ArrayList&lt;F&gt; firstTypeCut = null;</p>
<p> ArrayList&lt;F&gt; secondTypeCut = null;</p>
<p> ArrayList&lt;F&gt; thirdTypeCut = null;</p>
<p> ArrayList&lt;F&gt; schemeCut = null;</p>
<p> //下面将设置各轮校验者</p>
<p> if(resolvedType != null) {</p>
<p>     intslashpos = resolvedType.indexOf(‘/‘);</p>
<p>      if(slashpos &gt; 0) {</p>
<p>         final String baseType = resolvedType.substring(0, slashpos);</p>
<p>          if (!baseType.equals(&quot;*&quot;)) {</p>
<p>               if (resolvedType.length() != slashpos+2</p>
<p>                   || resolvedType.charAt(slashpos+1) != ‘*’) {</p>
<p>                       firstTypeCut =mTypeToFilter.get(resolvedType);</p>
<p>                       secondTypeCut =mWildTypeToFilter.get(baseType);</p>
<p>                   }……//略去一部分内容</p>
<p>           }</p>
<p>        }</p>
<p>      if(scheme != null) {</p>
<p>           schemeCut = mSchemeToFilter.get(scheme);</p>
<p>        }</p>
<p>      if(resolvedType == null &amp;&amp; scheme == null &amp;&amp; intent.getAction()!= null)</p>
<p>      {</p>
<p>        //看来action的filter优先级最低</p>
<p>       firstTypeCut = mActionToFilter.get(intent.getAction());</p>
<p>      }</p>
<p>   //FastImmutableArraySet是一种特殊的数据结构，用于保存该Intent中携带的</p>
<p>   //Category相关的信息。</p>
<p>   FastImmutableArraySet&lt;String&gt;categories = getFastIntentCategories(intent);</p>
<p>    if(firstTypeCut != null) {</p>
<p>     //匹配查询，第一轮过关斩将</p>
<p>     buildResolveList(intent, categories, debug, defaultOnly,</p>
<p>             resolvedType, scheme, firstTypeCut,finalList);</p>
<p>    }</p>
<p>    if(secondTypeCut != null) {</p>
<p>        buildResolveList(intent, categories, debug, defaultOnly,</p>
<p>                   resolvedType, scheme, secondTypeCut, finalList);</p>
<p>     }</p>
<p>    if(thirdTypeCut != null) {</p>
<p>        buildResolveList(intent, categories, debug, defaultOnly,</p>
<p>                   resolvedType, scheme, thirdTypeCut, finalList);</p>
<p>     }</p>
<p>    if(schemeCut != null) {</p>
<p>        //生成符合schemeCut条件的finalList</p>
<p>        buildResolveList(intent, categories, debug, defaultOnly,</p>
<p>                   resolvedType, scheme, schemeCut, finalList);</p>
<p>    }</p>
<p>   //将匹配结果按Priority的大小排序</p>
<p>   sortResults(finalList);</p>
<p>    returnfinalList;</p>
<p>}</p>
<p>在以上代码中设置了最多四轮匹配关卡，然后逐一执行匹配工作。具体的匹配代码由buildResolveList完成，无非是一项查找工作而已。此处就不再深究细节了，建议读者在研究代码时以目的为导向，不宜深究其中的数据结构。</p>
<p>4.5.3 queryIntentActivities总结</p>
<p>本节分析了queryIntentActivities函数的实现，其功能很简单，就是进行Intent匹配查询。一路走来，相信读者也感觉到旅程并不轻松，主要原因是涉及的数据结构较多，让人有些头晕。这里，再次建议读者不要在数据结构上花太多时间，最好结合SDK中的文档说明来分析相关代码。</p>
<p>4.6  installd及UserManager介绍</p>
<p>4.6.1  installd介绍</p>
<p>在前面对PKMS构造函数分析时介绍过一个Installer类型的对象mInstaller，它通过socket和后台服务installd交互，以完成一些重要操作。这里先回顾一下PKMS中mInstaller的调用方法：</p>
<p>mInstaller = new Installer();//创建一个Installer对象</p>
<p>//对某个APK文件进行dexopt优化</p>
<p>mInstaller.dexopt(paths[i], Process.SYSTEM_UID,true);</p>
<p>//扫描完系统Package后，调用moveFiles函数</p>
<p>mInstaller.moveFiles();</p>
<p>//当存储空间不足时，调用该函数清理存储空间</p>
<p>mInstaller.freeCache(freeStorageSize);</p>
<p>Installer的种种行为都和其背后的installd有关。下面来分析installd。</p>
<ol>
<li> installd概貌</li>
</ol>
<p>installd是一个native进程，代码非常简单，其功能就是启动一个socket，然后处理来自Installer的命令，其代码如下：</p>
<p>[–&gt;installd.c]</p>
<p>int main(const int argc, const char *argv[]) {</p>
<p>    charbuf[BUFFER_MAX];</p>
<p>    structsockaddr addr;</p>
<p>   socklen_t alen;</p>
<p>    intlsocket, s, count;</p>
<p>    //</p>
<p>  if (初始化全局变量,如果失败则退出) {</p>
<p>    initialize_globals();</p>
<p>    initialize_directories();</p>
<p>        ……</p>
<p>    }</p>
<p>    ……</p>
<p>    lsocket= android_get_control_socket(SOCKET_PATH);</p>
<p>   listen(lsocket, 5);</p>
<p>   fcntl(lsocket, F_SETFD, FD_CLOEXEC);</p>
<p>    for (;;){</p>
<p>        alen= sizeof(addr);</p>
<p>        s =accept(lsocket, &amp;addr, &amp;alen);</p>
<p>       fcntl(s, F_SETFD, FD_CLOEXEC);</p>
<p>        for(;;) {</p>
<p>           unsigned short count;</p>
<p>           readx(s, &amp;count, sizeof(count));</p>
<p>           //执行installer发出的命令，具体解释见下文</p>
<p>            execute(s, buf);</p>
<p>        }</p>
<p>       close(s);</p>
<p>    }</p>
<p>    return0;</p>
<p>}</p>
<p>installd支持的命令及参数信息都保存在数据结构cmds中，代码如下：</p>
<p>[–&gt;installd.c]</p>
<p>struct cmdinfo cmds[] = {//第二个变量是参数个数，第三个参数是命令响应函数</p>
<p>    {&quot;ping&quot;,                 0,do_ping },</p>
<p>    {&quot;install&quot;,              3,do_install },</p>
<p>    {&quot;dexopt&quot;,               3,do_dexopt },</p>
<p>    {&quot;movedex&quot;,              2,do_move_dex },</p>
<p>    {&quot;rmdex&quot;,                1,do_rm_dex },</p>
<p>    {&quot;remove&quot;,               2,do_remove },</p>
<p>    {&quot;rename&quot;,               2, do_rename },</p>
<p>    {&quot;freecache&quot;,            1,do_free_cache },</p>
<p>    {&quot;rmcache&quot;,              1,do_rm_cache },</p>
<p>    {&quot;protect&quot;,              2,do_protect },</p>
<p>    {&quot;getsize&quot;,              4,do_get_size },</p>
<p>    {&quot;rmuserdata&quot;,           2,do_rm_user_data },</p>
<p>    {&quot;movefiles&quot;,            0,do_movefiles },</p>
<p>    {&quot;linklib&quot;,              2,do_linklib },</p>
<p>    {&quot;unlinklib&quot;,            1,do_unlinklib },</p>
<p>    {&quot;mkuserdata&quot;,           3,do_mk_user_data },</p>
<p>    {&quot;rmuser&quot;,               1,do_rm_user },</p>
<p>};</p>
<p>下面来分析相关的几个命令。</p>
<p>2.  dexOpt命令分析</p>
<p>PKMS在需要对一个APK或jar包做dex优化时，会发送dexopt命令给installd，相应的处理函数为do_dexopt，代码如下：</p>
<p>[–&gt;installd.c]</p>
<p>static int do_dexopt(char **arg, charreply[REPLY_MAX])</p>
<p>{</p>
<p>     returndexopt(arg[0], atoi(arg[1]), atoi(arg[2]));</p>
<p>}</p>
<p>[–&gt;commands.c]</p>
<p>int dexopt(const char *apk_path, uid_t uid, intis_public)</p>
<p>{</p>
<p>    structutimbuf ut;</p>
<p>    structstat apk_stat, dex_stat;</p>
<p>    chardex_path[PKG_PATH_MAX];</p>
<p>    chardexopt_flags[PROPERTY_VALUE_MAX];</p>
<p>    char*end;</p>
<p>    int res,zip_fd=-1, odex_fd=-1;</p>
<p>    ……</p>
<p>    //取出系统级的dexopt_flags参数</p>
<p>   property_get(&quot;dalvik.vm.dexopt-flags&quot;, dexopt_flags,&quot;&quot;);</p>
<p>   strcpy(dex_path, apk_path);</p>
<p>    end =strrchr(dex_path, ‘.’);</p>
<p>    if (end!= NULL) {</p>
<p>       strcpy(end, &quot;.odex&quot;);</p>
<p>        if(stat(dex_path, &amp;dex_stat) == 0) {</p>
<p>           return 0;</p>
<p>        }</p>
<p>    }</p>
<p>    //得到一个字符串，用于描述dex文件名，位于/data/dalvik-cache/下</p>
<p>    if(create_cache_path(dex_path, apk_path)) {</p>
<p>       return -1;</p>
<p>    }</p>
<p>   memset(&amp;apk_stat, 0, sizeof(apk_stat));</p>
<p>   stat(apk_path, &amp;apk_stat);</p>
<p>    zip_fd =open(apk_path, O_RDONLY, 0);</p>
<p>    ……</p>
<p>   unlink(dex_path);</p>
<p>    odex_fd= open(dex_path, O_RDWR | O_CREAT | O_EXCL, 0644);</p>
<p>    ……</p>
<p>    pid_tpid;</p>
<p>    pid =fork();</p>
<p>    if (pid== 0) {</p>
<p>        ……//uid设置</p>
<p>        //创建一个新进程，然后对exec dexopt进程进行dex优化</p>
<p>        run_dexopt(zip_fd,odex_fd, apk_path, dexopt_flags);</p>
<p>       exit(67);  </p>
<p>} else {</p>
<p>        //installd将等待dexopt完成优化工作</p>
<p>        res= wait_dexopt(pid, apk_path);</p>
<p>        ……</p>
<p>    }</p>
<p>    ……//资源清理</p>
<p>    return-1;</p>
<p>}</p>
<p>让人大跌眼镜的是，dex优化工作竟然由installd委派给dexopt进程来实现。dex优化后会生成一个dex文件，一般位于/data/dalvik-cache/目录中。这里给出一个示例，如图4-12所示。</p>
<p>图4-12  dex文件示例</p>
<p>提示 dexopt进程由android源码/dalvik/dexopt/OptMain.cpp定义。感兴趣的读者可深入研究dex优化的工作原理。</p>
<ol start="3">
<li> movefiles命令分析</li>
</ol>
<p>PKMS扫描完系统Package后，将发送该命令给installd，相应处理函数的代码如下：</p>
<p>[–&gt;installd.c]</p>
<p>static int do_movefiles(char **arg, charreply[REPLY_MAX])</p>
<p>{</p>
<p>    returnmovefiles();</p>
<p>}</p>
<p>[–&gt;commands.c]</p>
<p>int movefiles()</p>
<p>{</p>
<p>    DIR *d;</p>
<p>    int dfd,subfd;</p>
<p>    structdirent *de;</p>
<p>    structstat s;</p>
<p>    charbuf[PKG_PATH_MAX+1];</p>
<p>    intbufp, bufe, bufi, readlen;</p>
<p>    charsrcpkg[PKG_NAME_MAX];</p>
<p>    chardstpkg[PKG_NAME_MAX];</p>
<p>    charsrcpath[PKG_PATH_MAX];</p>
<p>    chardstpath[PKG_PATH_MAX];</p>
<p>    intdstuid=-1, dstgid=-1;</p>
<p>    inthasspace;</p>
<p>    //打开/system/etc/updatecmds/目录</p>
<p>    d =opendir(UPDATE_COMMANDS_DIR_PREFIX);</p>
<p>    if (d ==NULL) {</p>
<p>        gotodone;</p>
<p>    }</p>
<p>    dfd =dirfd(d);</p>
<p>       while((de = readdir(d))) {</p>
<p>        ……//解析该目录下的文件，然后执行对应操作</p>
<p>   }</p>
<p>   closedir(d);</p>
<p>done:</p>
<p>    return0;</p>
<p>}</p>
<p>先来看/system/etc/updatecmds/目录下到底是什么文件，这里给出一个示例，如图4-13所示。</p>
<p>图4-13  movefiles示例</p>
<p>以图4-13中最后两行为例，movefiles将把com.google.android.gsf下的databases目录转移到com.andorid.providers.im下。从文件中的注释可知，movefiles的功能和系统升级有关。</p>
<p>4.  doFreeCache</p>
<p>第3章介绍了DeviceStorageMonitorService，当系统空间不够时，DSMS会调用PKMS的freeStorageAndNotify函数进行空间清理。该工作真正的实施者是installd，相应的处理命令为do_free_cache，其代码如下：</p>
<p>[–&gt;installd.c]</p>
<p>static int do_free_cache(char **arg, charreply[REPLY_MAX])</p>
<p>{</p>
<p>    returnfree_cache((int64_t)atoll(arg[0]));</p>
<p>}</p>
<p>[–&gt;commands.c]</p>
<p>int free_cache(int64_t free_size)</p>
<p>{</p>
<p>    constchar *name;</p>
<p>    int dfd,subfd;</p>
<p>    DIR *d;</p>
<p>    structdirent *de;</p>
<p>    int64_tavail;</p>
<p>    avail =disk_free();//获取当前系统的剩余空间大小</p>
<p>    if(avail &lt; 0) return -1;</p>
<p>    if(avail &gt;= free_size) return 0;</p>
<p>    d =opendir(android_data_dir.path);//打开/data/目录</p>
<p>    dfd =dirfd(d);</p>
<p>    while((de = readdir(d))) {</p>
<p>        if (de-&gt;d_type != DT_DIR) continue;</p>
<p>        name= de-&gt;d_name;</p>
<p>       ……//略过.和..文件</p>
<p>       subfd = openat(dfd, name, O_RDONLY | O_DIRECTORY);</p>
<p>        //删除/data及各级子目录中的cache文件夹</p>
<p>       delete_dir_contents_fd(subfd, &quot;cache&quot;);</p>
<p>       close(subfd);</p>
<p>       ……//如果剩余空间恢复正常，则返回</p>
<p>    }</p>
<p>   closedir(d);</p>
<p>    return-1;//清理空间后，仍然不满足要求</p>
<p>}</p>
<p>installd的介绍就到此为止，这部分内容比较简单，读者完全可自行深入研究。</p>
<p>4.6.2  UserManager介绍</p>
<p>UserManager是Andorid 4.0新增的一个功能，其作用是管理手机上的不同用户。这一点和PC上的Windows系统比较相似，例如，在Windows上安装程序时，都会提示是安装给本人使用还是安装给系统所有用户使用。非常遗憾的是，在目前的Andorid版本中，该功能尚未完全实现，在SDK中也没有相关说明。不过从现有代码中，也能发现一些蛛丝马迹。</p>
<p>提示 小米手机的访客模式和UserManager比较相似。</p>
<p>1.  UserManager构造函数分析</p>
<p>在PKMS中，创建UserManager调用的代码如下：</p>
<p>//mUserAppDataDir指向/data/app。该目录中包含的是非系统APK文件</p>
<p>mUserManager = new UserManager(mInstaller,mUserAppDataDir);</p>
<p>[–&gt;UserManager.java]</p>
<p>public UserManager(Installer installer, FilebaseUserPath) {</p>
<p>   this(Environment.getDataDirectory(), baseUserPath);</p>
<p>   mInstaller = installer;</p>
<p>}</p>
<p>UserManager(File dataDir, File baseUserPath) {</p>
<p>   //mUsersDir指向/data/system/users目录</p>
<p>   mUsersDir = new File(dataDir, USER_INFO_DIR);</p>
<p>   mUsersDir.mkdirs();//创建该目录</p>
<p>   mBaseUserPath = baseUserPath;</p>
<p>   FileUtils.setPermissions(mUsersDir.toString(),</p>
<p>            FileUtils.S_IRWXU|FileUtils.S_IRWXG</p>
<p>           |FileUtils.S_IROTH|FileUtils.S_IXOTH,</p>
<p>               -1, -1);</p>
<p>   //mUserListFile指向/data/system/user/userlist.xml</p>
<p>   mUserListFile = new File(mUsersDir, USER_LIST_FILENAME);</p>
<p>   readUserList();//解析userlist.xml文件</p>
<p>}</p>
<p>此处不深入readUserList代码了，只介绍其内部工作流程。</p>
<p>·  userlist.xml保存每个用户的id。</p>
<p>·  readUserList到/data/system/users下解析id.xml，将最终得到的信息保存在UserInfo对象中。</p>
<p>原来用户信息由UserInfo表达，下面是UserInfo的定义。</p>
<p>[–&gt;UserInfo]</p>
<p>public class UserInfo implements Parcelable {</p>
<p>   //主用户，全系统只能有一个这样的用户</p>
<p>    publicstatic final int FLAG_PRIMARY = 0x00000001;</p>
<p>    //管理员，可以创建、删除其他用户信息</p>
<p>    publicstatic final int FLAG_ADMIN   =0x00000002;</p>
<p>    //访客用户</p>
<p>    publicstatic final int FLAG_GUEST   =0x00000004;</p>
<p>    publicint id; //id</p>
<p>    publicString name;//用户名</p>
<p>    publicint flags; //属性标志</p>
<p>    ……//其他函数</p>
<p>}</p>
<p>UserInfo信息比较简单，笔者觉得UserManager的功能暂时还不能企业用户的需求。感兴趣的读者不妨关注Android未来版本在此方面的变化。</p>
<p>2.  installPackageForAllUsers分析</p>
<p>PKMS在扫描非系统APK的时候，每扫描完一个APK都会调用installPackageForAllUsers，调用代码如下：</p>
<p>mUserManager.installPackageForAllUsers(pkgName,pkg.applicationInfo.uid);</p>
<p>[–&gt;UserManager.java::installPackageForAllUsers]</p>
<p>public void installPackageForAllUsers(StringpackageName, int uid) {</p>
<p> for (intuserId : mUserIds) {</p>
<p>   if(userId == 0)</p>
<p>      continue;</p>
<p>  //向installd发送命令，其中getUid将组合userId和uid为一个整型值</p>
<p>  //installd将在/data/对应user/目录下创建相应的package子目录</p>
<p>  mInstaller.createUserData(packageName, PackageManager.getUid(userId,uid),</p>
<p>                                  userId);</p>
<p>        }</p>
<p> }</p>
<p>4.7  本章学习指导</p>
<p>PKMS是本书分析的第一个重要核心服务，其中的代码量，关联的知识点，涉及的数据结构都比较多。这里提出一些学习建议供读者参考。</p>
<p>·  从工作流程上看，PKMS包含几条重要的主线。一条是PKMS自身启动时构造函数的工作流程，另外几条和APK安装、卸载相关。每一条主线的难度都比较大，读者可结合日常工作的需求进行单独研究，例如研究如何加快构造函数的执行时间等。</p>
<p>·  从数据结构上看，PKMS涉及非常多的数据类型。如果对每个数据结构进行孤立分析，很容易陷入不可自拔的状态。笔者建议不妨跳出各种数据结构的具体形态，只从目的及功能角度去考虑。这里需要读者仔细查看前面的重要数据结构及说明示意图。</p>
<p>另外，由于篇幅所限，本章还有一些内容并没有涉及，需要读者在学习本章内容的基础上自行研究。这些内容包括：</p>
<p>·  APK安装在SD卡，以及APK从内部存储转移到SD卡的流程。</p>
<p>·  和Package相关的内容，例如签名管理、dex优化等。</p>
<p>4.8  本章小结</p>
<p>本章对PackageManagerService进行了较深入的分析。首先分析了PKMS创建时构造函数的工作流程；接着以APK安装为例，较详细地讲解了这个复杂的处理流程；然后又介绍了PKMS另外一项功能，即根据Intent查找匹配的Activities；最后，介绍了与installd和UserManager有关的知识。</p>
]]></content>
      <categories>
        <category>烂笔头</category>
      </categories>
  </entry>
</search>
