<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"edward.org.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="&#x2F;* drivers&#x2F;power&#x2F;rk30_adc_battery.c  *  * battery detect driver for the rk30   *  * This software is licensed under the terms of the GNU General Public  * License version 2, as published by the Free S">
<meta property="og:type" content="article">
<meta property="og:title" content="rk30_factory_adc_battery">
<meta property="og:url" content="http://edward.org.cn/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk30_factory_adc_battery.c/index.html">
<meta property="og:site_name" content="点点滴滴">
<meta property="og:description" content="&#x2F;* drivers&#x2F;power&#x2F;rk30_adc_battery.c  *  * battery detect driver for the rk30   *  * This software is licensed under the terms of the GNU General Public  * License version 2, as published by the Free S">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-31T06:48:01.548Z">
<meta property="article:modified_time" content="2020-01-16T04:37:32.157Z">
<meta property="article:author" content="Edward">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://edward.org.cn/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk30_factory_adc_battery.c/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>rk30_factory_adc_battery | 点点滴滴</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a92ed22eafce466e7a7b17546bb0dc6f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">点点滴滴</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://edward.org.cn/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk30_factory_adc_battery.c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="Edward">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="点点滴滴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rk30_factory_adc_battery
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-31 14:48:01" itemprop="dateCreated datePublished" datetime="2020-12-31T14:48:01+08:00">2020-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-16 12:37:32" itemprop="dateModified" datetime="2020-01-16T12:37:32+08:00">2020-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%83%82%E7%AC%94%E5%A4%B4/" itemprop="url" rel="index"><span itemprop="name">烂笔头</span></a>
                </span>
            </span>

          
            <span id="/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk30_factory_adc_battery.c/" class="post-meta-item leancloud_visitors" data-flag-title="rk30_factory_adc_battery" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>/* drivers/power/rk30_adc_battery.c</p>
<p> *</p>
<p> * battery detect driver for the rk30 </p>
<p> *</p>
<p> * This software is licensed under the terms of the GNU General Public</p>
<p> * License version 2, as published by the Free Software Foundation, and</p>
<p> * may be copied, distributed, and modified under those terms.</p>
<p> *</p>
<p> * This program is distributed in the hope that it will be useful,</p>
<p> * but WITHOUT ANY WARRANTY; without even the implied warranty of</p>
<p> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</p>
<p> * GNU General Public License for more details.</p>
<p> *</p>
<p> */</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/err.h&gt;</p>
<p>#include &lt;linux/platform_device.h&gt;</p>
<p>#include &lt;linux/power_supply.h&gt;</p>
<p>#include &lt;linux/regulator/consumer.h&gt;</p>
<p>#include &lt;linux/types.h&gt;</p>
<p>#include &lt;linux/pci.h&gt;</p>
<p>#include &lt;linux/interrupt.h&gt;</p>
<p>#include &lt;asm/io.h&gt;</p>
<p>#include &lt;asm/mach-types.h&gt;</p>
<p>#include &lt;asm/mach/arch.h&gt;</p>
<p>#include &lt;asm/mach/map.h&gt;</p>
<p>#include &lt;mach/gpio.h&gt;</p>
<p>#include &lt;linux/adc.h&gt;</p>
<p>#include &lt;mach/iomux.h&gt;</p>
<p>#include &lt;mach/board.h&gt;</p>
<p>#include &lt;linux/delay.h&gt;</p>
<p>#include &lt;linux/ktime.h&gt;</p>
<p>#include &lt;linux/slab.h&gt;</p>
<p>#include &lt;linux/syscalls.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/wakelock.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/string.h&gt;</p>
<p>#include &lt;linux/init.h&gt;</p>
<p>#include &lt;linux/earlysuspend.h&gt;</p>
<p>#include &lt;linux/suspend.h&gt;</p>
<p>#ifdef CONFIG_EARLYSUSPEND</p>
<p>/* kernel/power/earlysuspend.c */</p>
<p>extern suspend_state_t get_suspend_state(void);</p>
<p>#endif</p>
<p>static int rk30_battery_dbg_level = 0;</p>
<p>module_param_named(dbg_level, rk30_battery_dbg_level, int, 0644);</p>
<p>#define DBG( args…) \</p>
<p>do { \</p>
<p>if (rk30_battery_dbg_level) { \</p>
<p>pr_info(args); \</p>
<p>} \</p>
<p>} while (0)</p>
<p>#define TIMER_MS_COUNTS  1000 </p>
<p>#define SLOPE_SECOND_COUNTS                15 </p>
<p>#define DISCHARGE_MIN_SECOND                35</p>
<p>#define CHARGE_MIN_SECOND                45 </p>
<p>#define CHARGE_MID_SECOND                90 </p>
<p>#define CHARGE_MAX_SECOND                250</p>
<p>#define   CHARGE_FULL_DELAY_TIMES          10     </p>
<p>#define   USBCHARGE_IDENTIFY_TIMES        2        </p>
<p>#define NUM_VOLTAGE_SAMPLE                        ((SLOPE_SECOND_COUNTS * 1000) / TIMER_MS_COUNTS)  </p>
<p>#define NUM_DISCHARGE_MIN_SAMPLE          ((DISCHARGE_MIN_SECOND * 1000) / TIMER_MS_COUNTS)  </p>
<p>#define NUM_CHARGE_MIN_SAMPLE          ((CHARGE_MIN_SECOND * 1000) / TIMER_MS_COUNTS)     </p>
<p>#define NUM_CHARGE_MID_SAMPLE          ((CHARGE_MID_SECOND * 1000) / TIMER_MS_COUNTS)      </p>
<p>#define NUM_CHARGE_MAX_SAMPLE          ((CHARGE_MAX_SECOND * 1000) / TIMER_MS_COUNTS)   </p>
<p>#define   NUM_CHARGE_FULL_DELAY_TIMES         ((CHARGE_FULL_DELAY_TIMES * 1000) / TIMER_MS_COUNTS) </p>
<p>#define   NUM_USBCHARGE_IDENTIFY_TIMES      ((USBCHARGE_IDENTIFY_TIMES * 1000) / TIMER_MS_COUNTS) </p>
<p>#define   CHARGE_IS_OK                                 1</p>
<p>#define   INVALID_CHARGE_CHECK               -1</p>
<p>#if defined(CONFIG_ARCH_RK3066B)</p>
<p>#define  BAT_DEFINE_VALUE                                      1800</p>
<p>#elif defined(CONFIG_ARCH_RK2928)</p>
<p>#define  BAT_DEFINE_VALUE                                         3300</p>
<p>#else</p>
<p>#define  BAT_DEFINE_VALUE                                      2500</p>
<p>#endif</p>
<p>#define BATTERY_APK </p>
<p>#ifdef  BATTERY_APK</p>
<p>#define BATT_NUM  11</p>
<p>int    battery_dbg_level = 0;</p>
<p>int    battery_test_flag = 0;</p>
<p>int    gVoltageCnt = 3400;</p>
<p>int    gDoubleVoltageCnt = 6800;</p>
<p>unsigned long gSecondsCnt = 0;</p>
<p>char gDischargeFlag[4] = {&quot;on &quot;};</p>
<p>#ifdef CONFIG_BATTERY_RK30_VOL3V8</p>
<p>#define BATT_MAX_VOL_VALUE                             4120               //Full  charge volate  </p>
<p>#define BATT_ZERO_VOL_VALUE                            3600//3500               //power down voltage</p>
<p>#define BATT_NOMAL_VOL_VALUE                         3800            </p>
<p>static int batt_table[2*BATT_NUM+6] =</p>
<p>{</p>
<p>0x4B434F52,0x7461625F,0x79726574,0,200,200,</p>
<p>3495, 3580, 3599, 3626, 3655, 3697, 3751, 3812, 3877, 3920, 4020,  //discharge</p>
<p>3600, 3800, 3842, 3861, 3915, 3980, 4041, 4060, 4080, 4100, 4150   //charge</p>
<p>};</p>
<p>#define adc_to_voltage(adc_val) ((adc_val * BAT_DEFINE_VALUE * (batt_table[4] +batt_table[5])) / (1024 *batt_table[5]))</p>
<p>#else</p>
<p>#define BATT_MAX_VOL_VALUE                              8284               //Full charge voltage</p>
<p>#define BATT_ZERO_VOL_VALUE                             6900             // power down voltage </p>
<p>#define BATT_NOMAL_VOL_VALUE                          7600                </p>
<p>static int batt_table[2*BATT_NUM+6] =</p>
<p>{</p>
<p>0x4B434F52,0x7461625F,0x79726574,1,300,100,</p>
<p>6800, 7242, 7332, 7404, 7470, 7520, 7610, 7744, 7848, 8016, 8284,//discharge</p>
<p>7630, 7754, 7852, 7908, 7956, 8024, 8112, 8220, 8306, 8318, 8328//charge</p>
<p>};</p>
<p>#define adc_to_voltage(adc_val) ((adc_val * BAT_DEFINE_VALUE * (batt_table[4] +batt_table[5])) / (1024 *batt_table[5]))</p>
<p>#endif</p>
<p>#endif</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>enum {</p>
<p>BATTERY_STATUS = 0,</p>
<p>BATTERY_HEALTH = 1,</p>
<p>BATTERY_PRESENT = 2,</p>
<p>BATTERY_CAPACITY = 3,</p>
<p>BATTERY_AC_ONLINE = 4,</p>
<p>BATTERY_STATUS_CHANGED = 5,</p>
<p>AC_STATUS_CHANGED = 6,</p>
<p>BATTERY_INT_STATUS = 7,</p>
<p>BATTERY_INT_ENABLE = 8,</p>
<p>};</p>
<p>typedef enum {</p>
<p>CHARGER_BATTERY = 0,</p>
<p>CHARGER_USB,</p>
<p>CHARGER_AC</p>
<p>} charger_type_t;</p>
<p>struct rk30_adc_battery_data {</p>
<p>int irq;</p>
<p>//struct timer_list       timer;</p>
<p>struct workqueue_struct *wq;</p>
<p>struct delayed_work    delay_work;</p>
<p>struct delayed_work    check_work;</p>
<p>struct work_struct    dcwakeup_work;</p>
<p>struct work_struct                   lowerpower_work;</p>
<p>bool                    resume;</p>
<p>struct rk30_adc_battery_platform_data *pdata;</p>
<p>struct adc_client       *client; </p>
<p>int                     adc_val;</p>
<p>int                     adc_samples[NUM_VOLTAGE_SAMPLE+2];</p>
<p>int                     bat_status;</p>
<p>int                     bat_status_cnt;</p>
<p>int                     bat_health;</p>
<p>int                     bat_present;</p>
<p>int                     bat_voltage;</p>
<p>int                     bat_capacity;</p>
<p>int                     bat_change;</p>
<p>int                     old_charge_level;</p>
<p>int                    *pSamples;</p>
<p>int                     gBatCapacityDisChargeCnt;</p>
<p>int                     gBatCapacityChargeCnt;</p>
<p>int                     gBatCapacityacChargeCnt;</p>
<p>int                     gBatCapacityusbChargeCnt ;</p>
<p>int           gBatCapacityusbdisChargeCnt;</p>
<p>int                  capacitytmp;</p>
<p>int                     suspend_capacity;</p>
<p>int                     gBatUsbChargeCnt;</p>
<p>int                     status_lock;</p>
<p>struct power_supply bat;</p>
<p>struct power_supply usb;</p>
<p>struct power_supply ac;</p>
<p>struct power_supply bk_bat;</p>
<p>int                     poweron_check;</p>
<p>int                     usb_charging;</p>
<p>int                     ac_charging;</p>
<p>int                  charge_check;</p>
<p>int    charge_level;</p>
<p>int                     charge_source_now;</p>
<p>int                     charge_soure_old;</p>
<p>int                     charge_start_capacity;</p>
<p>int                     charge_start_voltage;</p>
<p>int                     start_voltage_status;</p>
<p>int                     charge_up_proprotion;</p>
<p>int                     charge_down_proportion;</p>
<p>int                     voltage_to_local;</p>
<p>unsigned long        suspend_time;</p>
<p>unsigned long resume_time;</p>
<p>int                      adc_value;</p>
<p>int                     full_times;</p>
<p>int     charge_full_flag;</p>
<p>int                     stop_check;</p>
<p>struct notifier_block battery_nb;</p>
<p>int    lower_power_flag;</p>
<p>int     time_to_full;</p>
<p>int     is_data_dir;</p>
<p>};</p>
<p>static struct rk30_adc_battery_data *gBatteryData;</p>
<p>static struct wake_lock batt_wake_lock;</p>
<p>static struct wake_lock batt_wake_lock_detect_lowpower;</p>
<p>static struct wake_lock charge_display_lock;</p>
<p>int system_lowerpower = 0;</p>
<p>extern void kernel_power_off(void);</p>
<p>extern int dwc_vbus_status(void);</p>
<p>extern int get_gadget_connect_flag(void);</p>
<p>extern int dwc_otg_check_dpdm(void);</p>
<p>static int  is_charge_ok(struct rk30_adc_battery_data *bat);</p>
<p>static void rk30_adc_battery_voltage_samples(struct rk30_adc_battery_data *bat);</p>
<p>#ifdef  BATTERY_APK</p>
<p>//#define BAT_ADC_TABLE_LEN               11</p>
<p>static ssize_t bat_param_read(struct device *dev,struct device_attribute *attr, char *buf)</p>
<p>{</p>
<p>int i;</p>
<p>for(i=0;i&lt;BATT_NUM;i++)</p>
<p>printk(&quot;i=%d batt_table=%d\n&quot;,i+6,batt_table[i+6]);</p>
<p>for(i=0;i&lt;BATT_NUM;i++)</p>
<p>printk(&quot;i=%d batt_table=%d\n&quot;,i+17,batt_table[i+17]);</p>
<p>return 0;</p>
<p>}</p>
<p>DEVICE_ATTR(batparam, 0664, bat_param_read,NULL);</p>
<p>static ssize_t rkbatt_show_debug_attrs(struct device *dev,</p>
<p>     struct device_attribute *attr, char *buf) </p>
<p>{  </p>
<p>return sprintf(buf, &quot;%d\n&quot;, battery_dbg_level);</p>
<p>}</p>
<p>static ssize_t rkbatt_restore_debug_attrs(struct device *dev, </p>
<p> struct device_attribute *attr, const char *buf, size_t size)</p>
<p>{</p>
<p>int liTmp;</p>
<p>sscanf(buf, &quot;%d&quot;, &amp;liTmp);</p>
<p>if(liTmp != 0 &amp;&amp; liTmp != 1)</p>
<p>{</p>
<p>dev_err(dev, &quot;rk29adc_restore_debug_attrs err\n&quot;);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>battery_dbg_level = liTmp;</p>
<p>}</p>
<p>return size;</p>
<p>}</p>
<p>static ssize_t rkbatt_show_state_attrs(struct device *dev,</p>
<p>struct device_attribute *attr, char *buf) </p>
<p>{</p>
<p>// struct rk30_adc_battery_platform_data *pdata = gBatteryData-&gt;pdata;</p>
<p>int charge_ok_value =0 ;</p>
<p>charge_ok_value = is_charge_ok(gBatteryData) ;</p>
<p>return sprintf(buf,</p>
<p>&quot;gBatVol=%d,gBatCap=%d,charge_ok=%d,%s\n&quot;,</p>
<p>gBatteryData-&gt;bat_voltage,gBatteryData-&gt;bat_capacity,</p>
<p>charge_ok_value,gDischargeFlag);</p>
<p>}</p>
<p>static ssize_t rkbatt_restore_state_attrs(struct device *dev, </p>
<p>struct device_attribute *attr, const char *buf, size_t size)</p>
<p>{</p>
<p>return size;</p>
<p>}</p>
<p>static ssize_t rkbatt_show_value_attrs(struct device *dev,</p>
<p>   struct device_attribute *attr, char *buf) </p>
<p>{  </p>
<p>return sprintf(buf, &quot;pull_up_res =%d,\npull_down_res=%d\n&quot;, batt_table[4],batt_table[5]);</p>
<p>}</p>
<p>static ssize_t rkbatt_restore_value_attrs(struct device *dev, </p>
<p>struct device_attribute *attr, const char *buf, size_t size)</p>
<p>{</p>
<p>int liUp = 0;</p>
<p>int liDown = 0;</p>
<p>sscanf(buf, &quot;%d,%d&quot;, &amp;liUp,&amp;liDown);</p>
<p>if(liUp != 0 &amp;&amp; liDown != 0)</p>
<p>{</p>
<p>batt_table[4] = liUp;</p>
<p>batt_table[5] = liDown;</p>
<p>}</p>
<p>return size;</p>
<p>}</p>
<p>static ssize_t rkbatt_show_flag_attrs(struct device *dev,</p>
<p>struct device_attribute *attr, char *buf) </p>
<p>{  </p>
<p>return sprintf(buf, &quot;rk29_battery_test_flag=%d\n&quot;, battery_test_flag);</p>
<p>}</p>
<p>static ssize_t rkbatt_restore_flag_attrs(struct device *dev, </p>
<p>   struct device_attribute *attr, const char *buf, size_t size)</p>
<p>{</p>
<p>int liFlag;</p>
<p>sscanf(buf, &quot;%d&quot;, &amp;liFlag);</p>
<p>if(liFlag != 0)</p>
<p>{</p>
<p>battery_test_flag = liFlag;</p>
<p>}</p>
<p>return size;</p>
<p>}</p>
<p>static struct device_attribute rkbatt_attrs[] = {</p>
<p>__ATTR(state, 0664, rkbatt_show_state_attrs, rkbatt_restore_state_attrs),</p>
<p>__ATTR(debug, 0664, rkbatt_show_debug_attrs, rkbatt_restore_debug_attrs),</p>
<p>__ATTR(value, 0555, rkbatt_show_value_attrs, rkbatt_restore_value_attrs),</p>
<p>__ATTR(flag,  0555, rkbatt_show_flag_attrs,  rkbatt_restore_flag_attrs),</p>
<p>};</p>
<p>static int create_sysfs_interfaces(struct device *dev)</p>
<p>{</p>
<p>int liTmep;</p>
<p>for (liTmep = 0; liTmep &lt; ARRAY_SIZE(rkbatt_attrs); liTmep++) {</p>
<p>if (device_create_file(dev, rkbatt_attrs + liTmep)){</p>
<p>goto error;</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>error:</p>
<p>for ( ; liTmep &gt;= 0; liTmep–){</p>
<p>device_remove_file(dev, rkbatt_attrs + liTmep);</p>
<p>}</p>
<p>dev_err(dev, &quot;%s:Unable to create sysfs interface\n&quot;, <strong>func</strong>);</p>
<p>return -1;</p>
<p>}</p>
<p>#endif</p>
<p>static int rk30_adc_battery_load_capacity(void)</p>
<p>{</p>
<p>char value[4];</p>
<p>int* p = (int *)value;</p>
<p>long fd, fdir;</p>
<p>fdir = sys_open(&quot;/metadata&quot;, O_RDONLY | O_DIRECTORY,0 );</p>
<p>if (fdir &lt;0){</p>
<p>fd = sys_open(&quot;/data/bat_last_capacity.dat&quot;,O_RDONLY,0);</p>
<p>gBatteryData -&gt;is_data_dir =1;</p>
<p>}else{</p>
<p>fd = sys_open(&quot;/metadata/bat_last_capacity.dat&quot;,O_RDONLY,0);</p>
<p>gBatteryData -&gt;is_data_dir = 0;</p>
<p>}</p>
<p>if(fd &lt; 0){</p>
<p>DBG(&quot;rk30_adc_battery_load_capacity: open file /data/bat_last_capacity.dat failed\n&quot;);</p>
<p>return -1;</p>
<p>}</p>
<p>sys_read(fd,(char __user *)value,4);</p>
<p>sys_close(fd);</p>
<p>return (*p);</p>
<p>}</p>
<p>static void rk30_adc_battery_put_capacity(int loadcapacity)</p>
<p>{</p>
<p>char value[4];</p>
<p>int* p = (int *)value;</p>
<p>long fd;</p>
<p>if ( gBatteryData -&gt;is_data_dir == 1)</p>
<p>fd = sys_open(&quot;/data/bat_last_capacity.dat&quot;,O_CREAT | O_RDWR,0);</p>
<p>else</p>
<p>fd = sys_open(&quot;/metadata/bat_last_capacity.dat&quot;,O_CREAT | O_RDWR,0);</p>
<p>if(fd &lt; 0){</p>
<p>DBG(&quot;rk30_adc_battery_put_capacity: open file /data/bat_last_capacity.dat failed\n&quot;);</p>
<p>return;</p>
<p>}</p>
<p>*p = loadcapacity;</p>
<p>sys_write(fd, (const char __user *)value, 4);</p>
<p>sys_close(fd);</p>
<p>}</p>
<p>static BLOCKING_NOTIFIER_HEAD(adc_battery_chain_head);</p>
<p>int register_adc_battery_notifier(struct notifier_block *nb)</p>
<p>{</p>
<p>return blocking_notifier_chain_register(&amp;adc_battery_chain_head, nb);</p>
<p>}</p>
<p>EXPORT_SYMBOL_GPL(register_adc_battery_notifier);</p>
<p>int unregister_adc_battery_notifier(struct notifier_block *nb)</p>
<p>{</p>
<p>return blocking_notifier_chain_unregister(&amp;adc_battery_chain_head, nb);</p>
<p>}</p>
<p>EXPORT_SYMBOL_GPL(unregister_adc_battery_notifier);</p>
<p>int adc_battery_notifier_call_chain(unsigned long val)</p>
<p>{</p>
<p>return (blocking_notifier_call_chain(&amp;adc_battery_chain_head, val, NULL)</p>
<p>== NOTIFY_BAD) ? -EINVAL : 0;</p>
<p>}</p>
<p>EXPORT_SYMBOL_GPL(adc_battery_notifier_call_chain);</p>
<p>static void rk_start_charge(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if (pdata-&gt;charge_set_pin != INVALID_GPIO){</p>
<p>gpio_direction_output(pdata-&gt;charge_set_pin, pdata-&gt;charge_set_level);</p>
<p>}</p>
<p>}</p>
<p>static void rk_stop_charge(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if (pdata-&gt;charge_set_pin != INVALID_GPIO){</p>
<p>gpio_direction_output(pdata-&gt;charge_set_pin, 1 - pdata-&gt;charge_set_level);</p>
<p>}</p>
<p>}</p>
<p>static int  get_ac_status(struct rk30_adc_battery_data *bat){</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int status = 0;</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>if (gpio_get_value (pdata-&gt;dc_det_pin) == pdata-&gt;dc_det_level){</p>
<p>status = 1;</p>
<p>}else{</p>
<p>status = 0;</p>
<p>}</p>
<p>}else{</p>
<p>if(pdata-&gt;is_dc_charging){</p>
<p>status = pdata-&gt;is_dc_charging();</p>
<p>}</p>
<p>}</p>
<p>return status;</p>
<p>}</p>
<p>// state of charge  — charge-display</p>
<p>static int  get_usb_status1(struct rk30_adc_battery_data *bat){</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int status = 0;</p>
<p>if(pdata-&gt;is_usb_charging){</p>
<p>status = pdata-&gt;is_usb_charging();</p>
<p>}</p>
<p>return status;</p>
<p>}</p>
<p>//state of charge —-running</p>
<p>static int  get_usb_status2(struct rk30_adc_battery_data *bat){</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int usb_status = 0; // 0–dischage ,1 —usb charge, 2 —ac charge</p>
<p>int vbus_status =  dwc_vbus_status();</p>
<p>if (1 == vbus_status) {</p>
<p>if (0 == get_gadget_connect_flag()){ </p>
<p>if (++bat-&gt;gBatUsbChargeCnt &gt;= NUM_USBCHARGE_IDENTIFY_TIMES){</p>
<p>bat-&gt;gBatUsbChargeCnt = NUM_USBCHARGE_IDENTIFY_TIMES + 1;</p>
<p>usb_status = 2; // non-standard AC charger</p>
<p>if(bat -&gt;pdata -&gt;control_usb_charging)</p>
<p>bat -&gt;pdata -&gt;control_usb_charging(1);</p>
<p>}else{</p>
<p>usb_status = 1; // connect to pc </p>
<p>if(bat -&gt;pdata -&gt;control_usb_charging)</p>
<p>bat -&gt;pdata -&gt;control_usb_charging(0);</p>
<p>}</p>
<p>}else{</p>
<p>usb_status = 1; // connect to pc </p>
<p>if(bat -&gt;pdata -&gt;control_usb_charging)</p>
<p>bat -&gt;pdata -&gt;control_usb_charging(0);</p>
<p>}</p>
<p>}else{</p>
<p>bat-&gt;gBatUsbChargeCnt = 0;</p>
<p>if (2 == vbus_status) {</p>
<p>usb_status = 2; //standard AC charger</p>
<p>if(bat -&gt;pdata -&gt;control_usb_charging)</p>
<p>bat -&gt;pdata -&gt;control_usb_charging(1);</p>
<p>}else{</p>
<p>usb_status = 0; </p>
<p>}</p>
<p>}</p>
<p>return usb_status;</p>
<p>}</p>
<p>static int rk_battery_get_status(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int charge_on = 0;</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int ac_ac_charging = 0, usb_ac_charging = 0;</p>
<p>int i=0;</p>
<p>#if defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>ac_ac_charging = get_ac_status(bat);</p>
<p>if(1 == ac_ac_charging)</p>
<p>charge_on = 1;</p>
<p>#endif</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE) </p>
<p>if (strstr(saved_command_line,&quot;charger&quot;)){</p>
<p>wake_lock(&amp;charge_display_lock);  //lock</p>
<p>if( bat-&gt;pdata-&gt;usb_det_pin  != INVALID_GPIO ){</p>
<p>if( gpio_get_value(bat-&gt;pdata-&gt;usb_det_pin)== bat-&gt;pdata-&gt;usb_det_level){</p>
<p>if(( 1 == usb_ac_charging )||( 1 == ac_ac_charging ))</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>if(( 1 == bat-&gt;usb_charging)||(1 == bat -&gt;ac_charging))</p>
<p>charge_on =1;</p>
<p>return charge_on;</p>
<p>}else{</p>
<p>if(( 0 == usb_ac_charging )&amp;&amp;( 0 == ac_ac_charging ))</p>
<p>bat -&gt; ac_charging = 0;</p>
<p>else</p>
<p>bat-&gt;ac_charging = 1;</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>if(1 == bat-&gt;ac_charging)</p>
<p>charge_on=1;</p>
<p>else</p>
<p>charge_on = 0;</p>
<p>return charge_on;</p>
<p>}</p>
<p>}else{</p>
<p>if(dwc_otg_check_dpdm() == 0){</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>usb_ac_charging = 0;</p>
<p>}else if(dwc_otg_check_dpdm() == 1){</p>
<p>bat-&gt;usb_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(0);</p>
<p>}else if(dwc_otg_check_dpdm() == 2){</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>usb_ac_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(1); </p>
<p>}</p>
<p>if((1 == usb_ac_charging)||(1 == ac_ac_charging))</p>
<p>bat -&gt;ac_charging = 1;</p>
<p>else</p>
<p>bat -&gt;ac_charging = 0;</p>
<p>if(( 0 == bat -&gt;ac_charging )&amp;&amp;(0 == bat-&gt;usb_charging  )){</p>
<p>charge_on = 0;</p>
<p>bat-&gt;bat_change = 1;</p>
<p>}</p>
<p>return charge_on;</p>
<p>}</p>
<p>}</p>
<p>if (charge_on == 0){</p>
<p>usb_ac_charging = get_usb_status2(bat); //0 –discharge, 1—usb charging,2—-AC charging;</p>
<p>if(1 == usb_ac_charging)</p>
<p>bat-&gt;usb_charging = 1;</p>
<p>else</p>
<p>bat-&gt;usb_charging = 0; </p>
<p>}</p>
<p>#endif</p>
<p>if((usb_ac_charging == 2)||(ac_ac_charging == 1))</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>else</p>
<p>bat -&gt; ac_charging = 0;</p>
<p>if((bat-&gt;usb_charging == 1)||(bat -&gt;ac_charging ==1))</p>
<p>charge_on =1;</p>
<p>if(1 == bat-&gt;ac_charging )</p>
<p>bat-&gt;charge_source_now = 1; //ac charge</p>
<p>else if( 1 == bat-&gt;usb_charging){</p>
<p>bat-&gt;charge_source_now = 2; //ac charge</p>
<p>}else{</p>
<p>bat-&gt;charge_soure_old =0;</p>
<p>bat-&gt;charge_source_now=0;</p>
<p>}</p>
<p>if(bat-&gt;charge_source_now != bat-&gt;charge_soure_old){</p>
<p>for (i = 0; i &lt; NUM_VOLTAGE_SAMPLE; i++){                //0.3 s</p>
<p>msleep(1); //mdelay — &gt; msleep</p>
<p>rk30_adc_battery_voltage_samples(bat);              //get new voltage</p>
<p>}</p>
<p>bat-&gt;charge_soure_old = bat-&gt;charge_source_now;</p>
<p>bat-&gt;bat_change = 1;</p>
<p>}</p>
<p>DBG(&quot;ac_status=%d,usb_status=%d bat-&gt;bat_change = %d\n&quot;,bat -&gt; ac_charging, bat-&gt;usb_charging ,bat-&gt;bat_change );</p>
<p>return charge_on;</p>
<p>}</p>
<p>static int  is_charge_ok(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int charge_is_ok = 0;</p>
<p>struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if( 1 != bat-&gt;charge_level)</p>
<p>return -1;</p>
<p>if((pdata-&gt;charge_ok_pin == INVALID_GPIO)&amp;&amp; ( pdata-&gt;charging_ok == NULL))</p>
<p>return -1;</p>
<p>if (pdata-&gt;charge_ok_pin != INVALID_GPIO){ </p>
<p>if (gpio_get_value(pdata-&gt;charge_ok_pin) == pdata-&gt;charge_ok_level){</p>
<p>charge_is_ok =1;</p>
<p>}</p>
<p>}else if( pdata-&gt;charging_ok){ </p>
<p>charge_is_ok = pdata-&gt;charging_ok();</p>
<p>}</p>
<p>return charge_is_ok;</p>
<p>}</p>
<p>static int rk30_adc_battery_status_samples(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int charge_level;</p>
<p>charge_level = bat -&gt;charge_level;//rk_battery_get_status(bat);</p>
<p>if (charge_level != bat-&gt;old_charge_level){</p>
<p>bat-&gt;old_charge_level = charge_level;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>#if 0</p>
<p>if(charge_level) {            </p>
<p>rk_start_charge(bat);</p>
<p>}</p>
<p>else{</p>
<p>rk_stop_charge(bat);</p>
<p>}</p>
<p>#endif</p>
<p>bat-&gt;bat_status_cnt = 0;        </p>
<p>}</p>
<p>if(( 1 == charge_level )&amp;&amp;(1 == bat-&gt;charge_full_flag) &amp;&amp; (bat-&gt;bat_capacity &lt; 90)){</p>
<p>rk_start_charge(bat);  //recharge</p>
<p>if(bat-&gt;pdata-&gt;ctrl_charge_led != NULL)</p>
<p>bat-&gt;pdata-&gt;ctrl_charge_led(0);</p>
<p>}else if (charge_level) {</p>
<p>rk_start_charge(bat);</p>
<p>}else{</p>
<p>rk_stop_charge(bat);</p>
<p>}</p>
<p>if(charge_level == 0){   </p>
<p>//discharge</p>
<p>bat-&gt;charge_full_flag = 0;</p>
<p>bat-&gt;full_times = 0;</p>
<p>bat-&gt;time_to_full = 0;</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_NOT_CHARGING;</p>
<p>}else{</p>
<p>//charging</p>
<p>if( is_charge_ok(bat)  ==  INVALID_CHARGE_CHECK){</p>
<p>if (bat-&gt;bat_capacity == 100){</p>
<p>if (bat-&gt;bat_status != POWER_SUPPLY_STATUS_FULL){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>bat-&gt;charge_full_flag = 1;</p>
<p>if(bat-&gt;pdata-&gt;ctrl_charge_led != NULL)</p>
<p>bat-&gt;pdata-&gt;ctrl_charge_led(1);</p>
<p>rk_stop_charge(bat);</p>
<p>}</p>
<p>}else{</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>if((bat-&gt;bat_capacity == 99)&amp;&amp;(bat-&gt;time_to_full == 0)){</p>
<p>bat-&gt;time_to_full = get_seconds();</p>
<p>}else if(bat-&gt;bat_capacity == 99)</p>
<p>{</p>
<p>if(get_seconds() - bat-&gt;time_to_full &gt; 1800){</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>bat-&gt;time_to_full = 0;</p>
<p>}</p>
<p>}</p>
<p>if(bat-&gt;pdata-&gt;ctrl_charge_led != NULL)</p>
<p>bat-&gt;pdata-&gt;ctrl_charge_led(0);</p>
<p>}</p>
<p>}else{  // pin of charge_ok_pin</p>
<p>if (is_charge_ok(bat) != CHARGE_IS_OK ){</p>
<p>bat-&gt;full_times = 0;</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>if((bat-&gt;bat_capacity == 99)&amp;&amp;(bat-&gt;time_to_full == 0)){</p>
<p>bat-&gt;time_to_full = get_seconds();</p>
<p>}else if(bat-&gt;bat_capacity == 99)</p>
<p>{</p>
<p>if(get_seconds() - bat-&gt;time_to_full &gt; 1800){</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>bat-&gt;time_to_full = 0;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}else{</p>
<p>bat-&gt;full_times++;</p>
<p>if (bat-&gt;full_times &gt;= NUM_CHARGE_FULL_DELAY_TIMES) {</p>
<p>bat-&gt;full_times = NUM_CHARGE_FULL_DELAY_TIMES + 1;</p>
<p>}</p>
<p>if ((bat-&gt;full_times &gt;= NUM_CHARGE_FULL_DELAY_TIMES) &amp;&amp; (bat-&gt;bat_capacity &gt;= 99)){</p>
<p>if (bat-&gt;bat_status != POWER_SUPPLY_STATUS_FULL){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>rk_stop_charge(bat);</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return charge_level;</p>
<p>}</p>
<p>static int rk_adc_voltage(struct rk30_adc_battery_data *bat, int value)</p>
<p>{</p>
<p>int voltage;</p>
<p>int ref_voltage; //reference_voltage</p>
<p>int pullup_res;</p>
<p>int pulldown_res;</p>
<p>ref_voltage = bat -&gt;pdata-&gt;reference_voltage;</p>
<p>pullup_res = bat -&gt;pdata-&gt;pull_up_res;</p>
<p>pulldown_res = bat -&gt;pdata-&gt;pull_down_res;</p>
<p>if(ref_voltage &amp;&amp; pullup_res &amp;&amp; pulldown_res){</p>
<p>#if defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3026)</p>
<p>ref_voltage = adc_get_curr_ref_volt();</p>
<p>#endif </p>
<p>voltage =  ((value * ref_voltage * (pullup_res + pulldown_res)) / (1024 * pulldown_res));</p>
<p>DBG(&quot;ref_voltage =%d, voltage=%d \n&quot;, ref_voltage,voltage);</p>
<p>}else{</p>
<p>#if 0</p>
<p>if(bat -&gt;capacitytmp &lt; 5)</p>
<p>ref_voltage = adc_get_curr_ref_volt();</p>
<p>else</p>
<p>ref_voltage = adc_get_def_ref_volt();</p>
<p>#endif</p>
<p>#if defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3026)</p>
<p>ref_voltage = adc_get_curr_ref_volt();</p>
<p>voltage = (value * ref_voltage * (batt_table[4] +batt_table[5])) / (1024 *batt_table[5]); </p>
<p>#else</p>
<p>voltage =voltage = adc_to_voltage(value);</p>
<p>#endif</p>
<p>}</p>
<p>DBG(&quot;ref_voltage =%d, voltage=%d \n&quot;, ref_voltage,voltage);</p>
<p>return voltage;</p>
<p>}</p>
<p>#if defined(CONFIG_MFD_TRS65910) //for trs65910 Trsilicon peter</p>
<p>//low power shutdown</p>
<p>void checklowpowershutdown(void)</p>
<p>{</p>
<p>int adc_val;</p>
<p>int voltage;</p>
<p>adc_val = adc_sync_read(gBatteryData-&gt;client);</p>
<p>voltage = rk_adc_voltage(gBatteryData, adc_val);</p>
<p>printk(&quot;Warning! Checking lowpower adc_val = %d, voltage = %d\n&quot;, adc_val, voltage);</p>
<p>if(voltage &lt;= 3200)</p>
<p>{</p>
<p>printk(&quot;pmic irq lower-power shutdown\n&quot;);</p>
<p>kernel_power_off();</p>
<p>}</p>
<p>}</p>
<p>#endif</p>
<p>static void rk_handle_ripple(struct rk30_adc_battery_data *bat, int status)</p>
<p>{</p>
<p>int *p_table;</p>
<p>if (bat-&gt;pdata-&gt;use_board_table){</p>
<p>p_table = bat-&gt;pdata-&gt;board_batt_table; </p>
<p>if(1 == status){</p>
<p>if(bat-&gt;bat_voltage &gt;= p_table[2*BATT_NUM +5]+ 10)</p>
<p>bat-&gt;bat_voltage = p_table[2*BATT_NUM +5]  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= p_table[BATT_NUM +6]  - 10)</p>
<p>bat-&gt;bat_voltage =  p_table[BATT_NUM +6] - 10;</p>
<p>}</p>
<p>else{</p>
<p>if(bat-&gt;bat_voltage &gt;= p_table[BATT_NUM +5]+ 10)</p>
<p>bat-&gt;bat_voltage = p_table[BATT_NUM +5]  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= p_table[6]  - 10)</p>
<p>bat-&gt;bat_voltage =  p_table[6] - 10;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//static int *pSamples;</p>
<p>static void rk30_adc_battery_voltage_samples(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int value;</p>
<p>int i,*pStart = bat-&gt;adc_samples, num = 0;</p>
<p>int level = bat-&gt;charge_level;</p>
<p>value = bat-&gt;adc_val;</p>
<p>adc_async_read(bat-&gt;client);</p>
<p>*(bat-&gt;pSamples++) = rk_adc_voltage(bat,value);</p>
<p>bat-&gt;bat_status_cnt++;</p>
<p>if (bat-&gt;bat_status_cnt &gt; NUM_VOLTAGE_SAMPLE)  bat-&gt;bat_status_cnt = NUM_VOLTAGE_SAMPLE + 1;</p>
<p>num = bat-&gt;pSamples - pStart;</p>
<p>if (num &gt;= NUM_VOLTAGE_SAMPLE){</p>
<p>bat -&gt;pSamples = pStart;</p>
<p>num = NUM_VOLTAGE_SAMPLE;</p>
<p>}</p>
<p>value = 0;</p>
<p>for (i = 0; i &lt; num; i++){</p>
<p>value += bat-&gt;adc_samples[i];</p>
<p>}</p>
<p>bat-&gt;bat_voltage = value / num;</p>
<p>/*handle  ripple */</p>
<p>if(battery_test_flag == 0)</p>
<p>{</p>
<p>if(0 == bat-&gt;pdata-&gt;use_board_table){</p>
<p>if(1 == level){</p>
<p>if(bat-&gt;bat_voltage &gt;= batt_table[2*BATT_NUM +5]+ 10)</p>
<p>bat-&gt;bat_voltage = batt_table[2*BATT_NUM +5]  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= batt_table[BATT_NUM +6]  - 10)</p>
<p>bat-&gt;bat_voltage =  batt_table[BATT_NUM +6] - 10;</p>
<p>}</p>
<p>else{</p>
<p>if(bat-&gt;bat_voltage &gt;= batt_table[BATT_NUM +5]+ 10)</p>
<p>bat-&gt;bat_voltage = batt_table[BATT_NUM +5]  + 10;</p>
<p>else if(bat-&gt;bat_voltage &lt;= batt_table[6]  - 10)</p>
<p>bat-&gt;bat_voltage =  batt_table[6] - 10;</p>
<p>}</p>
<p>}else{</p>
<p>rk_handle_ripple(bat, level);</p>
<p>}</p>
<p>}else if(battery_test_flag == 2){</p>
<p>if(batt_table[3] == 0){</p>
<p>if(bat-&gt;bat_voltage &lt; 3400){</p>
<p>if((get_seconds() - gSecondsCnt) &gt; 30){</p>
<p>gSecondsCnt = get_seconds();</p>
<p>if((gVoltageCnt - bat-&gt;bat_voltage) &gt; 15){</p>
<p>strncpy(gDischargeFlag, &quot;off&quot; ,4); </p>
<p>}</p>
<p>gVoltageCnt = bat-&gt;bat_voltage;</p>
<p>}</p>
<p>}</p>
<p>if(bat-&gt;bat_voltage &lt; 3400){</p>
<p>bat-&gt;bat_voltage = 3400;</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>if(bat-&gt;bat_voltage &lt; 6800){</p>
<p>if((get_seconds() - gSecondsCnt) &gt; 30){</p>
<p>gSecondsCnt = get_seconds();</p>
<p>if((gDoubleVoltageCnt - bat-&gt;bat_voltage) &gt; 30){</p>
<p>strncpy(gDischargeFlag, &quot;off&quot; ,4); </p>
<p>}</p>
<p>gDoubleVoltageCnt =bat-&gt;bat_voltage;</p>
<p>}</p>
<p>}</p>
<p>if(bat-&gt;bat_voltage &lt; 6800){</p>
<p>bat-&gt;bat_voltage = 6800;</p>
<p>} </p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>static int rk30_adc_battery_voltage_to_capacity(struct rk30_adc_battery_data *bat, int BatVoltage)</p>
<p>{</p>
<p>int i = 0;</p>
<p>int capacity = 0;</p>
<p>int  *p;</p>
<p>if (bat-&gt;pdata-&gt;use_board_table)</p>
<p>p = bat-&gt;pdata-&gt;board_batt_table; </p>
<p>else </p>
<p>p = batt_table;</p>
<p>if (1 == bat-&gt;charge_level){  //charge</p>
<p>if(0 == bat-&gt;start_voltage_status ){</p>
<p>if(BatVoltage &gt;= (p[2*BATT_NUM +5])){</p>
<p>capacity = 100;</p>
<p>} </p>
<p>else{</p>
<p>if(BatVoltage &lt;= (p[BATT_NUM +6])){</p>
<p>capacity = 0;</p>
<p>}</p>
<p>else{</p>
<p>for(i = BATT_NUM +6; i &lt;2*BATT_NUM +5; i++){</p>
<p>if(((p[i]) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt;  (p[i+1]))){</p>
<p>capacity = (i-(BATT_NUM +6))*10 + ((BatVoltage - p[i]) *  10)/ (p[i+1]- p[i]);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}  </p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>DBG(&quot;start_voltage=%d,start_capacity =%d\n&quot;, bat-&gt;charge_start_voltage, bat-&gt;charge_start_capacity);</p>
<p>DBG(&quot;charge_down_proportion =%d,charge_up_proprotion=%d\n&quot;,bat -&gt;charge_down_proportion,bat -&gt;charge_up_proprotion);</p>
<p>for(i = BATT_NUM +6; i &lt;2*BATT_NUM +5; i++)</p>
<p>if(((p[i]) &lt;= bat-&gt;charge_start_voltage) &amp;&amp; (bat-&gt;charge_start_voltage &lt;  (p[i+1]))) </p>
<p>bat-&gt;voltage_to_local = i;</p>
<p>if(BatVoltage &gt;= (p[2*BATT_NUM +5])){</p>
<p>capacity = 100;</p>
<p>}else{ </p>
<p>if(BatVoltage &lt;= (p[BATT_NUM +6])){</p>
<p>capacity = 0;</p>
<p>}else{</p>
<p>if(BatVoltage &lt;bat-&gt;charge_start_voltage){</p>
<p>for(i = BATT_NUM +6; i &lt;2*BATT_NUM +5; i++)</p>
<p>if(((p[i]) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt;  (p[i+1]))){</p>
<p>if( p[i+1] &lt; bat-&gt;charge_start_voltage ){</p>
<p>capacity =bat-&gt;charge_start_capacity - ((p[i+1] -BatVoltage) * bat-&gt;charge_start_capacity/(bat-&gt;voltage_to_local -17+1))/ (p[i+1]- p[i]) - (bat-&gt;voltage_to_local- (i ))*bat-&gt;charge_start_capacity/(bat-&gt;voltage_to_local -17+1);</p>
<p>DBG(&quot;1&lt;&lt;&lt;&lt;&lt;&lt;&lt; %d  bat-&gt;voltage_to_local =%d capacity = %d BatVoltage =%d  p[i] = %d,p[i+1] = %d  \n&quot;, i, bat-&gt;voltage_to_local,capacity,BatVoltage,p[i], p[i+1]);</p>
<p>}</p>
<p>else {</p>
<p>capacity =bat-&gt;charge_start_capacity - ((bat-&gt;charge_start_voltage -BatVoltage) * bat-&gt;charge_start_capacity/(bat-&gt;voltage_to_local -17+1) )/ (bat-&gt;charge_start_voltage - p[i]);</p>
<p>DBG(&quot;2&lt;&lt;&lt;&lt;&lt;&lt; %d   capacity = %d BatVoltage =%d  p[i] = %d,p[i+1] = %d  \n&quot;, i,capacity,BatVoltage,p[i], p[i+1]);</p>
<p>}</p>
<p>break;</p>
<p>}</p>
<p>}else{</p>
<p>if(BatVoltage &gt; bat-&gt;charge_start_voltage){</p>
<p>for(i = BATT_NUM +6; i &lt;2*BATT_NUM +5; i++)</p>
<p>if(((p[i]) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt;  (p[i+1]))){</p>
<p>if( p[i] &gt; bat-&gt;charge_start_voltage ){</p>
<p>capacity = bat-&gt;charge_start_capacity + (i +1- (bat-&gt;voltage_to_local))*(100- bat-&gt;charge_start_capacity )/( 10 -  (bat-&gt;voltage_to_local  - 17)) + (BatVoltage - p[i]) * (100- bat-&gt;charge_start_capacity )/( 10 -  (bat-&gt;voltage_to_local -17))/ (p[i+1]- p[i]);</p>
<p>DBG(&quot;3&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; %d bat-&gt;voltage_to_local =%d  capacity = %d BatVoltage =%d  p[i] = %d,p[i+1] = %d  \n&quot;, i, bat-&gt;voltage_to_local,capacity,BatVoltage,p[i], p[i+1]);</p>
<p>}</p>
<p>else {</p>
<p>      capacity = bat-&gt;charge_start_capacity + (BatVoltage - bat-&gt;charge_start_voltage) * (100- bat-&gt;charge_start_capacity )/( 10 -  (bat-&gt;voltage_to_local-17 )) /(p[i+1] - bat-&gt;charge_start_voltage );</p>
<p>DBG(&quot; 4&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;%d bat-&gt;voltage_to_local =%d  capacity = %d BatVoltage =%d  p[i] = %d,p[i+1] = %d  \n&quot;, i,bat-&gt;voltage_to_local,capacity,BatVoltage,p[i], p[i+1]);</p>
<p>}</p>
<p>break;</p>
<p>}</p>
<p>}else{</p>
<p>if(BatVoltage  ==  bat-&gt;charge_start_voltage)</p>
<p>capacity = bat -&gt;charge_start_capacity;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else{  //discharge</p>
<p>if(BatVoltage &gt;= (p[BATT_NUM +5])){</p>
<p>capacity = 100;</p>
<p>} </p>
<p>else{</p>
<p>if(BatVoltage &lt;= (p[6])){</p>
<p>capacity = 0;</p>
<p>}</p>
<p>else{</p>
<p>for(i = 6; i &lt; BATT_NUM +5; i++){</p>
<p>if(((p[i]) &lt;= BatVoltage) &amp;&amp; (BatVoltage &lt; (p[i+1]))){</p>
<p>capacity = (i-6)*10+ ((BatVoltage - p[i]) *10 )/ (p[i+1]- p[i]) ;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}  </p>
<p>}</p>
<p>}</p>
<p>DBG(&quot;real_voltage_to_capacity =%d\n&quot; ,capacity);</p>
<p>    return capacity;</p>
<p>}</p>
<p>static void rk_usb_charger(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int capacity = 0;</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>int timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>if((1 == bat -&gt;charge_level)&amp;&amp;( 0 == bat -&gt;start_voltage_status)){</p>
<p>bat -&gt;charge_start_voltage = bat -&gt;bat_voltage;</p>
<p>bat -&gt;start_voltage_status = 1;</p>
<p>bat -&gt;charge_start_capacity = bat -&gt;bat_capacity;</p>
<p>if(bat -&gt;charge_start_capacity%10 != 0){</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10+1;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10+1;</p>
<p>}else{</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10;</p>
<p>}</p>
<p>}</p>
<p>capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>if (capacity &gt; bat-&gt;bat_capacity){</p>
<p>if(capacity &gt; bat-&gt;bat_capacity + 10 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -10;  //5s</p>
<p>else if(capacity &gt; bat-&gt;bat_capacity + 7 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -5; //10s</p>
<p>       else if(capacity &gt; bat-&gt;bat_capacity + 3 )</p>
<p>               timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE - 2; // 13</p>
<p>if (++(bat-&gt;gBatCapacityusbChargeCnt) &gt;= timer_of_charge_sample){</p>
<p>bat-&gt;gBatCapacityusbChargeCnt  = 0;</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>bat -&gt;gBatCapacityusbdisChargeCnt = 0;//get_suspend_state(void)</p>
<p>}else //if(( get_suspend_state() != PM_SUSPEND_MEM)&amp;&amp;(capacity &lt; bat-&gt;bat_capacity)){</p>
<p>// if((gpio_get_value (bat-&gt;pdata-&gt;back_light_pin) == 1)&amp;&amp;(capacity &lt; bat-&gt;bat_capacity)){</p>
<p>if((capacity &lt; bat-&gt;bat_capacity)){</p>
<p>DBG(&quot;USB CHARGE DOWN\n&quot;);</p>
<p>// if (capacity &lt; bat-&gt;bat_capacity){</p>
<p>if(capacity &lt;10){</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 40; // 13</p>
<p>}else if(capacity &lt; 20){</p>
<p>if(capacity + 3 &gt; bat-&gt;bat_capacity  )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -5;  //5s</p>
<p>else if(capacity  + 7 &gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -10; //10s</p>
<p>else if(capacity  + 10&gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -25; // 13</p>
<p>else</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 35; // 13</p>
<p>}else{</p>
<p>if(capacity + 3 &gt; bat-&gt;bat_capacity  )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -5;  //5s</p>
<p>else if(capacity  + 7 &gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE -10; //10s</p>
<p>else if(capacity  + 10&gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 15; // 13</p>
<p>else</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 20; // 13</p>
<p>}</p>
<p>if (++(bat-&gt;gBatCapacityusbdisChargeCnt) &gt;= timer_of_discharge_sample){</p>
<p>bat-&gt;gBatCapacityusbdisChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &gt; 0){</p>
<p>bat-&gt;bat_capacity– ;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>//}</p>
<p>bat-&gt;gBatCapacityusbChargeCnt  = 0;</p>
<p>}</p>
<p>else //if(get_suspend_state() == PM_SUSPEND_MEM){</p>
<p>//if(gpio_get_value (bat-&gt;pdata-&gt;back_light_pin) == 0){</p>
<p>{</p>
<p>bat-&gt;gBatCapacityusbdisChargeCnt = 0;</p>
<p>// (bat-&gt;gBatCapacityusbChargeCnt)++;</p>
<p>if( is_charge_ok(bat) != INVALID_CHARGE_CHECK){</p>
<p>if( is_charge_ok(bat) == CHARGE_IS_OK){</p>
<p>if (++bat-&gt;gBatCapacityusbChargeCnt &gt;= timer_of_charge_sample-30){</p>
<p>bat-&gt;gBatCapacityusbChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &lt;= 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}else{</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;((bat-&gt;gBatCapacityChargeCnt) &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;(bat-&gt;gBatCapacityusbChargeCnt &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityusbChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt;= 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>bat-&gt;capacitytmp = capacity;</p>
<p>}</p>
<p>static void rk_ac_charger(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int capacity = 0;</p>
<p>int timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>if((1 == bat-&gt;charge_level)&amp;&amp;( 0 == bat-&gt;start_voltage_status)){</p>
<p>bat-&gt;charge_start_voltage = bat-&gt;bat_voltage;</p>
<p>bat-&gt;start_voltage_status = 1;</p>
<p>bat-&gt;charge_start_capacity = bat-&gt;bat_capacity;</p>
<p>if(bat -&gt;charge_start_capacity%10 != 0){</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10+1;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10+1;</p>
<p>}else{</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10;</p>
<p>}</p>
<p>}</p>
<p>capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>if (capacity &gt; bat-&gt;bat_capacity){</p>
<p>if(capacity &gt; bat-&gt;bat_capacity + 10 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -10;  //5s</p>
<p>else if(capacity &gt; bat-&gt;bat_capacity + 7 )</p>
<p>       timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE -5; //10s</p>
<p>       else if(capacity &gt; bat-&gt;bat_capacity + 3 )</p>
<p>               timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE - 2; // 13</p>
<p>if (++(bat-&gt;gBatCapacityacChargeCnt) &gt;= timer_of_charge_sample){</p>
<p>bat-&gt;gBatCapacityacChargeCnt  = 0;</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else{  </p>
<p>           bat-&gt;gBatCapacityacChargeCnt = 0;</p>
<p>           (bat-&gt;gBatCapacityChargeCnt)++;</p>
<p>if( is_charge_ok(bat) != INVALID_CHARGE_CHECK){</p>
<p>if( is_charge_ok(bat) == CHARGE_IS_OK){</p>
<p>if (bat-&gt;gBatCapacityChargeCnt &gt;= timer_of_charge_sample){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}else{</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;((bat-&gt;gBatCapacityChargeCnt) &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt; 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}else{</p>
<p>if (capacity &gt; bat-&gt;capacitytmp){</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>}</p>
<p>else{</p>
<p>if ((bat-&gt;bat_capacity &gt;= 85) &amp;&amp;(bat-&gt;gBatCapacityChargeCnt &gt; NUM_CHARGE_MAX_SAMPLE)){</p>
<p>bat-&gt;gBatCapacityChargeCnt = (NUM_CHARGE_MAX_SAMPLE - NUM_CHARGE_MID_SAMPLE);</p>
<p>if (bat-&gt;bat_capacity &lt;= 99){</p>
<p>bat-&gt;bat_capacity++;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}            </p>
<p>}</p>
<p>bat-&gt;capacitytmp = capacity;</p>
<p>}</p>
<p>static void rk_battery_charger(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int capacity = 0;</p>
<p>int timer_of_discharge_sample = DISCHARGE_MIN_SECOND;</p>
<p>capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>if (capacity &lt; bat-&gt;bat_capacity){</p>
<p>#if 0</p>
<p>if(capacity &lt;10){</p>
<p>timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE - 40; // 13</p>
<p>}else </p>
<p>#endif</p>
<p>if(capacity &lt; 20){</p>
<p>if(capacity + 3 &gt; bat-&gt;bat_capacity  )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -5;  //5s</p>
<p>else if(capacity  + 7 &gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -10; //10s</p>
<p>else if(capacity  + 10&gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -25; // 13</p>
<p>else</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND - 35; // 13</p>
<p>}else{</p>
<p>if(capacity + 3 &gt; bat-&gt;bat_capacity  )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -5;  //5s</p>
<p>else if(capacity  + 7 &gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND -10; //10s</p>
<p>else if(capacity  + 10&gt; bat-&gt;bat_capacity )</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND - 15; // 13</p>
<p>else</p>
<p>timer_of_discharge_sample = DISCHARGE_MIN_SECOND - 20; // 13</p>
<p>}</p>
<p>if(capacity &lt;= 5)              //get down quickly when lowwer power </p>
<p>timer_of_discharge_sample = 5 ;</p>
<p>if (++(bat-&gt;gBatCapacityDisChargeCnt) &gt;= timer_of_discharge_sample){</p>
<p>bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>if (bat-&gt;bat_capacity &gt; 0){</p>
<p>bat-&gt;bat_capacity– ;</p>
<p>bat-&gt;bat_change  = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>}</p>
<p>bat-&gt;gBatCapacityChargeCnt = 0;</p>
<p>bat-&gt;gBatCapacityusbdisChargeCnt=0 ;</p>
<p>bat-&gt;gBatCapacityusbChargeCnt =0;</p>
<p>bat-&gt;gBatCapacityacChargeCnt = 0;</p>
<p>bat-&gt;start_voltage_status = 0;</p>
<p>bat-&gt;capacitytmp = capacity;</p>
<p>}</p>
<p>static void rk30_adc_battery_capacity_samples(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>// int capacity = 0;</p>
<p>// int timer_of_charge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>// int timer_of_discharge_sample = NUM_CHARGE_MIN_SAMPLE;</p>
<p>if (bat-&gt;bat_status_cnt &lt; NUM_VOLTAGE_SAMPLE)  {</p>
<p>bat-&gt;gBatCapacityDisChargeCnt = 0;</p>
<p>bat-&gt;gBatCapacityChargeCnt    = 0;</p>
<p>bat-&gt;gBatCapacityacChargeCnt = 0;</p>
<p>return;</p>
<p>}</p>
<p>if(1 == bat-&gt;charge_level){</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE) </p>
<p>if(1 == bat-&gt;usb_charging)</p>
<p>rk_usb_charger(bat);</p>
<p>else</p>
<p>rk_ac_charger(bat);</p>
<p>#else</p>
<p>rk_ac_charger(bat);</p>
<p>#endif</p>
<p>}else{</p>
<p>rk_battery_charger(bat);</p>
<p>}</p>
<p>}</p>
<p>//static int poweron_check = 0;</p>
<p>static void rk30_adc_battery_poweron_capacity_check(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int new_capacity, old_capacity;</p>
<p>int cnt = 50 ;</p>
<p>new_capacity = bat -&gt;bat_capacity;</p>
<p>while( cnt – ){</p>
<p>   old_capacity = rk30_adc_battery_load_capacity();</p>
<p>   if( old_capacity &gt;= 0 ){</p>
<p>       break ;</p>
<p>   }</p>
<p>   msleep(100);</p>
<p>}</p>
<p>if ((old_capacity &lt; 0) || (old_capacity &gt; 100)){</p>
<p>old_capacity = new_capacity;</p>
<p>}    </p>
<p>//if(new_capacity &lt;= 1)       // no test</p>
<p>// old_capacity = 0;</p>
<p>if (bat -&gt;bat_status == POWER_SUPPLY_STATUS_FULL){</p>
<p>if (new_capacity &gt; 80){</p>
<p>bat -&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>else if (bat -&gt;bat_status != POWER_SUPPLY_STATUS_NOT_CHARGING){</p>
<p>//chargeing state</p>
<p>if( bat  -&gt;pdata-&gt;is_reboot_charging == 1)</p>
<p>bat -&gt;bat_capacity = (old_capacity &lt; 10) ?(old_capacity+1):old_capacity;</p>
<p>else</p>
<p>bat -&gt;bat_capacity = (new_capacity &gt; old_capacity) ? new_capacity : old_capacity;</p>
<p>}else{</p>
<p>if(new_capacity &gt; old_capacity + 50 )</p>
<p>bat -&gt;bat_capacity = old_capacity + 5;</p>
<p>else</p>
<p>bat -&gt;bat_capacity = (new_capacity &lt; old_capacity) ? new_capacity : old_capacity;  //avoid the value of capacity increase </p>
<p>if(bat-&gt;bat_capacity == 100)</p>
<p>bat-&gt;bat_capacity = 99;</p>
<p>if(bat-&gt;bat_capacity == 0)</p>
<p>bat-&gt;bat_capacity =1;</p>
<p>}</p>
<p>printk(&quot;old_capacity = %d , new_capacity =%d, capacity = %d\n  &quot;,old_capacity,new_capacity ,bat -&gt;bat_capacity);</p>
<p>bat -&gt;bat_change = 1;</p>
<p>}</p>
<p>#define to_battery_usb_device_info(x) container_of((x), \</p>
<p>struct rk30_adc_battery_data, usb);</p>
<p>static int rk30_adc_battery_get_usb_property(struct power_supply *psy, </p>
<p>   enum power_supply_property psp,</p>
<p>   union power_supply_propval *val)</p>
<p>{</p>
<p>struct rk30_adc_battery_data *bat=  to_battery_usb_device_info(psy);</p>
<p>switch (psp) {</p>
<p>case POWER_SUPPLY_PROP_ONLINE:</p>
<p>if (psy-&gt;type == POWER_SUPPLY_TYPE_USB){</p>
<p>val-&gt;intval = bat -&gt;usb_charging;</p>
<p>if (strstr(saved_command_line,&quot;charger&quot;) == NULL){ </p>
<p>if( 1 == bat-&gt;charge_full_flag)</p>
<p>val-&gt;intval = 0;</p>
<p>}</p>
<p>}</p>
<p>break;</p>
<p>default:</p>
<p>return -EINVAL;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>static enum power_supply_property rk30_adc_battery_usb_props[] = {</p>
<p>POWER_SUPPLY_PROP_ONLINE,</p>
<p>};</p>
<p>static struct power_supply rk30_usb_supply = </p>
<p>{</p>
<p>.name = &quot;usb&quot;,</p>
<p>.type = POWER_SUPPLY_TYPE_USB,</p>
<p>.get_property   = rk30_adc_battery_get_usb_property,</p>
<p>.properties     = rk30_adc_battery_usb_props,</p>
<p>.num_properties = ARRAY_SIZE(rk30_adc_battery_usb_props),</p>
<p>};</p>
<p>static irqreturn_t rk30_adc_battery_dc_wakeup(int irq, void *dev_id)</p>
<p>{   </p>
<p>disable_irq_nosync(irq);</p>
<p>queue_work(gBatteryData-&gt;wq, &amp;gBatteryData-&gt;dcwakeup_work);</p>
<p>return IRQ_HANDLED;</p>
<p>}</p>
<p>#define to_battery_ac_device_info(x) container_of((x), \</p>
<p>struct rk30_adc_battery_data, ac);</p>
<p>static int rk30_adc_battery_get_ac_property(struct power_supply *psy,</p>
<p>enum power_supply_property psp,</p>
<p>union power_supply_propval *val)</p>
<p>{</p>
<p>int ret;</p>
<p>struct rk30_adc_battery_data *bat = to_battery_ac_device_info(psy);</p>
<p>switch (psp) {</p>
<p>case POWER_SUPPLY_PROP_ONLINE:</p>
<p>if (psy-&gt;type == POWER_SUPPLY_TYPE_MAINS){</p>
<p>val-&gt;intval = bat -&gt;ac_charging;</p>
<p>if (strstr(saved_command_line,&quot;charger&quot;)  == NULL ){</p>
<p>if( 1 == bat-&gt;charge_full_flag)</p>
<p>val-&gt;intval = 0;</p>
<p>}</p>
<p>}</p>
<p>break;</p>
<p>default:</p>
<p>ret = -EINVAL;</p>
<p>break;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>static enum power_supply_property rk30_adc_battery_ac_props[] = </p>
<p>{</p>
<p>POWER_SUPPLY_PROP_ONLINE,</p>
<p>};</p>
<p>static struct power_supply rk30_ac_supply = </p>
<p>{</p>
<p>.name = &quot;ac&quot;,</p>
<p>.type = POWER_SUPPLY_TYPE_MAINS,</p>
<p>.get_property   = rk30_adc_battery_get_ac_property,</p>
<p>.properties     = rk30_adc_battery_ac_props,</p>
<p>.num_properties = ARRAY_SIZE(rk30_adc_battery_ac_props),</p>
<p>};</p>
<p>static void rk30_adc_battery_dcdet_delaywork(struct work_struct *work)</p>
<p>{</p>
<p>int ret;</p>
<p>struct rk30_adc_battery_platform_data *pdata;</p>
<p>int irq;</p>
<p>int irq_flag;</p>
<p>struct rk30_adc_battery_data  *bat = container_of((work), \</p>
<p>struct rk30_adc_battery_data, dcwakeup_work);</p>
<p>rk28_send_wakeup_key(); // wake up the system</p>
<p>pdata    = bat-&gt;pdata;</p>
<p>irq        = gpio_to_irq(pdata-&gt;dc_det_pin);</p>
<p>free_irq(irq, NULL);</p>
<p>msleep(10);</p>
<p>irq_flag = gpio_get_value (pdata-&gt;dc_det_pin) ? IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;</p>
<p>ret = request_irq(irq, rk30_adc_battery_dc_wakeup, irq_flag, &quot;ac_charge_irq&quot;, NULL);// reinitialize the DC irq </p>
<p>if (ret) {</p>
<p>free_irq(irq, NULL);</p>
<p>}</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>bat -&gt;bat_status_cnt = 0;        //the state of battery is change</p>
<p>}</p>
<p>static int rk30_adc_battery_get_status(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_status);</p>
<p>}</p>
<p>static int rk30_adc_battery_get_health(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return POWER_SUPPLY_HEALTH_GOOD;</p>
<p>}</p>
<p>static int rk30_adc_battery_get_present(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return 1;//(bat-&gt;bat_voltage &lt; BATT_MAX_VOL_VALUE) ? 0 : 1;</p>
<p>}</p>
<p>static int rk30_adc_battery_get_voltage(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_voltage );</p>
<p>}</p>
<p>static int rk30_adc_battery_get_capacity(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>return (bat-&gt;bat_capacity);</p>
<p>}</p>
<p>static int rk30_adc_battery_get_property(struct power_supply *psy,</p>
<p>enum power_supply_property psp,</p>
<p>union power_supply_propval *val)</p>
<p>{ </p>
<p>int ret = 0;</p>
<p>int voltage;</p>
<p>struct rk30_adc_battery_data  *bat = container_of((psy), \</p>
<p>struct rk30_adc_battery_data, bat);</p>
<p>switch (psp) {</p>
<p>case POWER_SUPPLY_PROP_STATUS:</p>
<p>val-&gt;intval = rk30_adc_battery_get_status(bat);</p>
<p>DBG(&quot;gBatStatus=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_HEALTH:</p>
<p>val-&gt;intval = rk30_adc_battery_get_health(bat);</p>
<p>DBG(&quot;gBatHealth=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_PRESENT:</p>
<p>val-&gt;intval = rk30_adc_battery_get_present(bat);</p>
<p>DBG(&quot;gBatPresent=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_VOLTAGE_NOW:</p>
<p>// val -&gt;intval = rk30_adc_battery_get_voltage(bat);</p>
<p>voltage = rk30_adc_battery_get_voltage(bat);</p>
<p>val-&gt;intval = voltage*1000;</p>
<p>DBG(&quot;gBatVoltage=%d\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_CAPACITY:</p>
<p>if(battery_test_flag == 2)</p>
<p>val-&gt;intval = 50;</p>
<p>else</p>
<p>val-&gt;intval = rk30_adc_battery_get_capacity(bat);</p>
<p>DBG(&quot;gBatCapacity=%d%%\n&quot;,val-&gt;intval);</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_TECHNOLOGY:</p>
<p>val-&gt;intval = POWER_SUPPLY_TECHNOLOGY_LION; </p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:</p>
<p>val-&gt;intval = BATT_MAX_VOL_VALUE;</p>
<p>break;</p>
<p>case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:</p>
<p>val-&gt;intval = BATT_ZERO_VOL_VALUE;</p>
<p>break;</p>
<p>default:</p>
<p>ret = -EINVAL;</p>
<p>break;</p>
<p>}</p>
<p>return ret;</p>
<p>}</p>
<p>static enum power_supply_property rk30_adc_battery_props[] = {</p>
<p>POWER_SUPPLY_PROP_STATUS,</p>
<p>POWER_SUPPLY_PROP_HEALTH,</p>
<p>POWER_SUPPLY_PROP_PRESENT,</p>
<p>POWER_SUPPLY_PROP_VOLTAGE_NOW,</p>
<p>POWER_SUPPLY_PROP_TECHNOLOGY,</p>
<p>POWER_SUPPLY_PROP_CAPACITY,</p>
<p>POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,</p>
<p>POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,</p>
<p>};</p>
<p>static struct power_supply rk30_battery_supply = </p>
<p>{</p>
<p>.name = &quot;battery&quot;,</p>
<p>.type = POWER_SUPPLY_TYPE_BATTERY,</p>
<p>.get_property   = rk30_adc_battery_get_property,</p>
<p>.properties     = rk30_adc_battery_props,</p>
<p>.num_properties = ARRAY_SIZE(rk30_adc_battery_props),</p>
<p>};</p>
<p>#ifdef CONFIG_PM</p>
<p>static void rk30_adc_battery_resume_check(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int i;</p>
<p>int level,oldlevel;</p>
<p>int new_capacity, old_capacity;</p>
<p>// struct rk30_adc_battery_data *bat = gBatteryData;</p>
<p>bat -&gt;old_charge_level = -1;</p>
<p>bat -&gt;pSamples = bat-&gt;adc_samples;</p>
<p>adc_sync_read(bat-&gt;client);                             //start adc sample</p>
<p>level = oldlevel =  rk_battery_get_status(bat);//rk30_adc_battery_status_samples(bat);//init charge status</p>
<p>for (i = 0; i &lt; NUM_VOLTAGE_SAMPLE; i++) {               //0.3 s   </p>
<p>mdelay(1);</p>
<p>rk30_adc_battery_voltage_samples(bat);              //get voltage</p>
<p>level = rk_battery_get_status(bat);// rk30_adc_battery_status_samples(bat);       //check charge status</p>
<p>if (oldlevel != level){ </p>
<p>   oldlevel = level;                               //if charge status changed, reset sample</p>
<p>   i = 0;</p>
<p>}        </p>
<p>}</p>
<p>new_capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);</p>
<p>old_capacity =bat-&gt; suspend_capacity;</p>
<p>//if (bat-&gt;bat_status != POWER_SUPPLY_STATUS_NOT_CHARGING){</p>
<p>if( 1 == level ){</p>
<p>//chargeing state</p>
<p>bat-&gt;bat_capacity = (new_capacity &lt; old_capacity) ? new_capacity : old_capacity;</p>
<p>}</p>
<p>else{</p>
<p>bat-&gt;bat_capacity = (new_capacity &lt; old_capacity) ? new_capacity : old_capacity;  // aviod the value of capacity increase    dicharge</p>
<p>}</p>
<p>if( bat -&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>if (gpio_get_value(bat -&gt;pdata-&gt;batt_low_pin) == bat -&gt;pdata-&gt;batt_low_level)</p>
<p>bat-&gt;bat_capacity = 0;</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>static int rk30_adc_battery_suspend(struct platform_device *dev, pm_message_t state)</p>
<p>{</p>
<p>int irq;</p>
<p>struct rk30_adc_battery_data *data = platform_get_drvdata(dev);</p>
<p>data -&gt;suspend_capacity = data-&gt;bat_capacity;</p>
<p>data -&gt;suspend_time = get_seconds();</p>
<p>cancel_delayed_work(&amp;data -&gt;delay_work);</p>
<p>if( data -&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>irq = gpio_to_irq(data -&gt;pdata-&gt;batt_low_pin);</p>
<p>enable_irq(irq);</p>
<p>enable_irq_wake(irq);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>static int rk30_adc_battery_resume(struct platform_device *dev)</p>
<p>{</p>
<p>int irq;</p>
<p>struct rk30_adc_battery_data *data = platform_get_drvdata(dev);</p>
<p>        if( data-&gt;bat_capacity &lt; 10 ){</p>
<p>wake_lock_timeout(&amp;batt_wake_lock_detect_lowpower,15*HZ);</p>
<p>data-&gt;bat_change  = 1;</p>
<p>}</p>
<p>data -&gt;resume_time = get_seconds();</p>
<p>data -&gt;resume = true;</p>
<p>queue_delayed_work(data-&gt;wq, &amp;data -&gt;delay_work, msecs_to_jiffies(100));</p>
<p>if( data -&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>irq = gpio_to_irq(data -&gt;pdata -&gt;batt_low_pin);</p>
<p>disable_irq_wake(irq);</p>
<p>disable_irq(irq);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>#else</p>
<p>#define rk30_adc_battery_suspend NULL</p>
<p>#define rk30_adc_battery_resume NULL</p>
<p>#endif</p>
<p>unsigned long AdcTestCnt = 0;</p>
<p>static void rk30_adc_battery_timer_work(struct work_struct *work)</p>
<p>{</p>
<p>struct rk30_adc_battery_data  *bat = container_of((work), \</p>
<p>struct rk30_adc_battery_data, delay_work);</p>
<p>#ifdef CONFIG_PM</p>
<p>if (bat -&gt;resume) {</p>
<p>// if( (bat-&gt;resume_time - bat-&gt;suspend_time) &gt;= 1800 )</p>
<p>rk30_adc_battery_resume_check(bat);</p>
<p>//else</p>
<p>//bat-&gt;bat_capacity = bat-&gt;suspend_capacity;</p>
<p>bat -&gt;resume = false;</p>
<p>bat -&gt;bat_change =1;</p>
<p>}</p>
<p>#endif</p>
<p>bat-&gt;stop_check = 1;</p>
<p>if( 1 == bat -&gt;lower_power_flag ){</p>
<p>bat -&gt;bat_capacity = 0;</p>
<p>bat -&gt;bat_change =1;</p>
<p>}</p>
<p>if (bat -&gt;poweron_check){   </p>
<p>bat -&gt;poweron_check = 0;</p>
<p>rk30_adc_battery_poweron_capacity_check(bat);</p>
<p>}</p>
<p>bat -&gt;charge_level = rk_battery_get_status(bat);</p>
<p>DBG(&quot;bat -&gt;charge_level =%d\n&quot;, bat -&gt;charge_level);</p>
<p>rk30_adc_battery_status_samples(bat);</p>
<p>rk30_adc_battery_voltage_samples(bat);</p>
<p>rk30_adc_battery_capacity_samples(bat);</p>
<p>if( 0 == bat -&gt;pdata -&gt;charging_sleep){</p>
<p>if( 1 == bat-&gt;charge_level){  // charge</p>
<p>if(0 == bat-&gt;status_lock ){ </p>
<p>wake_lock(&amp;batt_wake_lock);  //lock</p>
<p>bat -&gt;status_lock = 1; </p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>if(1 == bat -&gt;status_lock ){ </p>
<p>wake_unlock(&amp;batt_wake_lock);  //unlock</p>
<p>bat -&gt;status_lock = 0; </p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>/<em>update battery parameter after adc and capacity has been changed</em>/</p>
<p>if(bat -&gt;bat_change){</p>
<p>bat -&gt;bat_change= 0;</p>
<p>if (strstr(saved_command_line,&quot;charger&quot;) == NULL){  //when low charging-current,not in charging-displays</p>
<p>if(0 == bat -&gt;bat_capacity){</p>
<p>bat -&gt;ac_charging = 0;</p>
<p>bat -&gt;usb_charging = 0;</p>
<p>}</p>
<p>}</p>
<p>rk30_adc_battery_put_capacity(bat -&gt;bat_capacity);</p>
<p>power_supply_changed(&amp;bat -&gt;bat);</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>power_supply_changed(&amp;bat -&gt;usb);</p>
<p>#endif</p>
<p>}</p>
<p>//if (rk30_battery_dbg_level){</p>
<p>if (++AdcTestCnt &gt;= 2)</p>
<p>{</p>
<p>AdcTestCnt = 0;</p>
<p>DBG(&quot;Status = %d, RealAdcVal = %d, RealVol = %d,gBatVol = %d, gBatCap = %d, RealCapacity = %d, batt_dischargecnt = %d\n,  chargecnt = %d,ac_count = %d, usb_count =%d ,usb_dischargecount =%d\n&quot;, </p>
<p>bat -&gt;bat_status, bat -&gt;adc_val, rk_adc_voltage(bat, bat -&gt;adc_val), </p>
<p>bat -&gt;bat_voltage, bat -&gt;bat_capacity, bat -&gt;capacitytmp, bat -&gt;gBatCapacityDisChargeCnt, bat -&gt;gBatCapacityChargeCnt,</p>
<p>bat -&gt;gBatCapacityacChargeCnt, bat -&gt;gBatCapacityusbChargeCnt, bat -&gt;gBatCapacityusbdisChargeCnt);</p>
<p>}</p>
<p>//}</p>
<p>queue_delayed_work(bat -&gt;wq, &amp;bat -&gt;delay_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>}</p>
<p>static int rk30_adc_battery_io_init(struct rk30_adc_battery_platform_data *pdata)</p>
<p>{</p>
<p>int ret = 0;</p>
<p>if (pdata-&gt;io_init) {</p>
<p>pdata-&gt;io_init();</p>
<p>return 0;</p>
<p>}</p>
<p>//charge control pin</p>
<p>if (pdata-&gt;charge_set_pin != INVALID_GPIO){</p>
<p>ret = gpio_request(pdata-&gt;charge_set_pin, NULL);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to request dc_det gpio\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>gpio_direction_output(pdata-&gt;charge_set_pin, 1 - pdata-&gt;charge_set_level);</p>
<p>}</p>
<p>//dc charge detect pin</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>ret = gpio_request(pdata-&gt;dc_det_pin, NULL);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to request dc_det gpio\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>gpio_pull_updown(pdata-&gt;dc_det_pin, GPIOPullUp);//important</p>
<p>ret = gpio_direction_input(pdata-&gt;dc_det_pin);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to set gpio dc_det input\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>}</p>
<p>//charge ok detect</p>
<p>if (pdata-&gt;charge_ok_pin != INVALID_GPIO){</p>
<p>ret = gpio_request(pdata-&gt;charge_ok_pin, NULL);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to request charge_ok gpio\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>gpio_pull_updown(pdata-&gt;charge_ok_pin, GPIOPullUp);//important</p>
<p>ret = gpio_direction_input(pdata-&gt;charge_ok_pin);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to set gpio charge_ok input\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>}</p>
<p>//batt low pin</p>
<p>if( pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>ret = gpio_request(pdata-&gt;batt_low_pin, NULL);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to request batt_low_pin gpio\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>gpio_pull_updown(pdata-&gt;batt_low_pin, GPIOPullUp); </p>
<p>ret = gpio_direction_input(pdata-&gt;batt_low_pin);</p>
<p>if (ret) {</p>
<p>printk(&quot;failed to set gpio batt_low_pin input\n&quot;);</p>
<p>goto error;</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>error:</p>
<p>return -1;</p>
<p>}</p>
<p>extern void kernel_power_off(void);</p>
<p>int get_battery_status(void)</p>
<p>{</p>
<p>return system_lowerpower;</p>
<p>}</p>
<p>static int rk_adc_battery_poweron_status(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int status; </p>
<p>int otg_status = 0;</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>if (get_ac_status(bat) ){ </p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>bat -&gt; ac_charging = 1; </p>
<p>if (is_charge_ok(bat)  == 1){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>}</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>otg_status = dwc_otg_check_dpdm();</p>
<p>if( 0 != otg_status ){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>if (is_charge_ok(bat)  == 1){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>if(otg_status == 1){</p>
<p>bat-&gt;usb_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(0);</p>
<p>}else if(otg_status == 2){</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(1); </p>
<p>}else{</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>}</p>
<p>printk(&quot;charge_status = %d\n&quot;,otg_status);</p>
<p>#endif</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>power_supply_changed(&amp;bat -&gt;usb);</p>
<p>#endif</p>
<p>if((bat -&gt; ac_charging == 1)||(bat-&gt;usb_charging == 1)){</p>
<p>bat -&gt;old_charge_level =1;</p>
<p>bat-&gt;charge_level = 1;</p>
<p>status =1;</p>
<p>}else{</p>
<p>bat -&gt;old_charge_level =0;</p>
<p>bat-&gt;charge_level = 0;</p>
<p>status =0;</p>
<p>}</p>
<p>return status; </p>
<p>}</p>
<p>static void rk30_adc_battery_check(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int i;</p>
<p>int level,oldlevel;</p>
<p>// struct rk30_adc_battery_platform_data *pdata = bat-&gt;pdata;</p>
<p>int check_data[NUM_VOLTAGE_SAMPLE];</p>
<p>//bat -&gt;old_charge_level</p>
<p>// pSamples = bat-&gt;adc_samples;</p>
<p>adc_sync_read(bat-&gt;client);                             //start adc sample</p>
<p>DBG(&quot;first_adc_value is  %d \n&quot;,bat-&gt;adc_val );</p>
<p>level = oldlevel =  rk_adc_battery_poweron_status(bat);// rk30_adc_battery_status_samples(bat);//init charge status</p>
<p>for (i = 0; i &lt; NUM_VOLTAGE_SAMPLE; i++){                //0.3 s</p>
<p>mdelay(1);</p>
<p>rk30_adc_battery_voltage_samples(bat);              //get voltage</p>
<p>//level = rk30_adc_battery_status_samples(bat);       //check charge status</p>
<p>#if 0</p>
<p>level = rk_adc_battery_poweron_status(bat);</p>
<p>if (oldlevel != level){</p>
<p>oldlevel = level;                               //if charge status changed, reset sample</p>
<p>i = 0;</p>
<p>}  </p>
<p>#endif</p>
<p>}</p>
<p>for(i=0; i&lt; NUM_VOLTAGE_SAMPLE; i++){</p>
<p>mdelay(10);</p>
<p>check_data[i] = bat-&gt;adc_val;</p>
<p>adc_async_read(bat-&gt;client);</p>
<p>bat-&gt;adc_value += check_data[i];</p>
<p>}</p>
<p>bat-&gt;adc_value  /=  NUM_VOLTAGE_SAMPLE;</p>
<p>bat-&gt;bat_capacity = rk30_adc_battery_voltage_to_capacity(bat, bat-&gt;bat_voltage);  //init bat_capacity</p>
<p>bat-&gt;capacitytmp = bat-&gt;bat_capacity;</p>
<p>level = rk_adc_battery_poweron_status(bat);</p>
<p>if((1 == level)&amp;&amp;(0 == bat-&gt;start_voltage_status )){</p>
<p>bat-&gt;charge_start_voltage = bat-&gt;bat_voltage;</p>
<p>bat-&gt;start_voltage_status = 1;</p>
<p>bat-&gt;charge_start_capacity = bat-&gt;bat_capacity;</p>
<p>bat -&gt;charge_up_proprotion = (100 - bat -&gt;charge_start_capacity)/10+1;</p>
<p>bat -&gt;charge_down_proportion = bat -&gt;charge_start_capacity/10+1;</p>
<p>}</p>
<p>#if 0 </p>
<p>if (get_ac_status(bat) ){ </p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>bat -&gt; ac_charging = 1; </p>
<p>if (is_charge_ok(bat)  == 1){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>if( 0 != dwc_otg_check_dpdm() ){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>if (is_charge_ok(bat)  == 1){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_FULL;</p>
<p>bat-&gt;bat_capacity = 100;</p>
<p>}</p>
<p>}</p>
<p>if(dwc_otg_check_dpdm() == 1){</p>
<p>bat-&gt;usb_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(0);</p>
<p>}else if(dwc_otg_check_dpdm() == 2){</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>if(bat -&gt; pdata -&gt;control_usb_charging)</p>
<p>bat -&gt; pdata -&gt;control_usb_charging(1); </p>
<p>}else{</p>
<p>bat-&gt;usb_charging = 0;</p>
<p>}</p>
<p>#endif</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>power_supply_changed(&amp;bat -&gt;usb);</p>
<p>#endif</p>
<p>if((bat -&gt; ac_charging == 1)||(bat-&gt;usb_charging == 1)){</p>
<p>bat -&gt;old_charge_level =1;</p>
<p>bat-&gt;charge_level = 1;</p>
<p>}</p>
<p>#endif</p>
<p>#if 0</p>
<p>if (bat-&gt;bat_capacity == 0) {</p>
<p>bat-&gt;bat_capacity = 1;</p>
<p>system_lowerpower = 1;</p>
<p>}</p>
<p>#endif</p>
<p>if(0 !=bat -&gt;pdata-&gt;low_voltage_protection ){</p>
<p>if((bat-&gt;bat_voltage &lt;=  bat -&gt;pdata-&gt;low_voltage_protection) &amp;&amp; (bat-&gt;charge_level == 0) )</p>
<p>system_lowerpower = 1;</p>
<p>printk(&quot;protection lower power …..\n&quot;);</p>
<p>}else{</p>
<p>if((bat-&gt;bat_voltage &lt;= BATT_ZERO_VOL_VALUE) &amp;&amp; (bat-&gt;charge_level == 0))</p>
<p>system_lowerpower = 1;</p>
<p>printk(&quot;lower power …..\n&quot;);</p>
<p>} </p>
<p>#if 0</p>
<p>if ((bat-&gt;bat_voltage &lt;= BATT_ZERO_VOL_VALUE)&amp;&amp;(bat-&gt;bat_status != POWER_SUPPLY_STATUS_CHARGING)){</p>
<p>kernel_power_off();</p>
<p>}</p>
<p>#endif</p>
<p>}</p>
<p>static void rk30_adc_battery_callback(struct adc_client *client, void *param, int result)</p>
<p>{</p>
<p>struct rk30_adc_battery_data  *bat = container_of((client), \</p>
<p>struct rk30_adc_battery_data, client);</p>
<p>if (result &lt; 0){</p>
<p>DBG(&quot;adc_battery_callback    resule &lt; 0 , the value &quot;);</p>
<p>return;</p>
<p>}else{</p>
<p>gBatteryData-&gt;adc_val = result;</p>
<p>DBG(&quot;result = %d, gBatteryData-&gt;adc_val = %d\n&quot;, result, gBatteryData-&gt;adc_val );</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>static void rk30_adc_battery_lowerpower_delaywork(struct work_struct *work)</p>
<p>{</p>
<p>int irq;</p>
<p>struct rk30_adc_battery_data  *bat = container_of((work), \</p>
<p>struct rk30_adc_battery_data, lowerpower_work);</p>
<p>if( bat-&gt;pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>irq = gpio_to_irq(bat -&gt;pdata -&gt;batt_low_pin);</p>
<p>disable_irq(irq);</p>
<p>}</p>
<p>printk(&quot;lowerpower\n&quot;);</p>
<p>rk28_send_wakeup_key(); // wake up the system </p>
<p>return;</p>
<p>}</p>
<p>static irqreturn_t rk30_adc_battery_low_wakeup(int irq,void *dev_id)</p>
<p>{</p>
<p>queue_work(gBatteryData-&gt;wq, &amp;gBatteryData-&gt;lowerpower_work);</p>
<p>return IRQ_HANDLED;</p>
<p>}</p>
<p>static void rk_lowerpower_check(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>int adc_val;</p>
<p>int i;</p>
<p>int check_data[NUM_VOLTAGE_SAMPLE];</p>
<p>for(i=0; i&lt; NUM_VOLTAGE_SAMPLE; i++){</p>
<p>mdelay(10);</p>
<p>adc_async_read(bat-&gt;client);</p>
<p>check_data[i] = bat-&gt;adc_val; </p>
<p>adc_val += check_data[i];</p>
<p>}</p>
<p>adc_val /=NUM_VOLTAGE_SAMPLE;</p>
<p>DBG(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;one&gt;&gt;&gt;%d, two&lt;&lt;&lt;&lt;&lt;%d&lt;&lt;&lt;&lt;\n&quot;,bat-&gt;adc_value,adc_val);</p>
<p>DBG(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;firset-value&gt;&gt;&gt;%d, second-value&lt;&lt;&lt;&lt;&lt;%d&lt;&lt;&lt;&lt;\n&quot;,rk_adc_voltage(bat, bat-&gt;adc_value),rk_adc_voltage(bat, adc_val));</p>
<p>if((adc_val &gt;= bat-&gt;adc_value+15) &amp;&amp;(bat-&gt;bat_status == POWER_SUPPLY_STATUS_NOT_CHARGING ) )//</p>
<p>{</p>
<p>printk(&quot;%d,%d\n&quot;,adc_val,bat-&gt;adc_value);</p>
<p>printk(&quot;lower-power shutdown&quot;);</p>
<p>//kernel_power_off();</p>
<p>}</p>
<p>}</p>
<p>static void rk_adc_battery_check_work(struct work_struct *work)</p>
<p>{</p>
<p>struct rk30_adc_battery_data  *bat = container_of((work), \</p>
<p>struct rk30_adc_battery_data, check_work);</p>
<p>if(1 == get_ac_status(bat)){</p>
<p>bat-&gt;bat_status = POWER_SUPPLY_STATUS_CHARGING;</p>
<p>bat -&gt; ac_charging = 1;</p>
<p>}</p>
<p>power_supply_changed(&amp;bat -&gt;ac);</p>
<p>if(bat-&gt;stop_check != 1)</p>
<p>queue_delayed_work(bat -&gt;wq, &amp;bat -&gt;check_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>}</p>
<p>static void poweron_lowerpoer_handle(struct rk30_adc_battery_data *bat)</p>
<p>{</p>
<p>#if defined CONFIG_LOGO_LOWERPOWER_WARNING ||  defined CONFIG_LOGO_LOWERPOWER_WARNING_BMP</p>
<p>if((1 ==  get_battery_status())&amp;&amp;(0 == rk_battery_get_status(bat))){</p>
<p>printk(&quot;poweron_lowerpoer_handle: lower power \n&quot;);</p>
<p>mdelay (1500);</p>
<p>kernel_power_off();</p>
<p>}</p>
<p>#endif</p>
<p>}</p>
<p>static int battery_notifier_call(struct notifier_block *nb,</p>
<p>unsigned long event, void *data)</p>
<p>{</p>
<p>struct rk30_adc_battery_data *bat=</p>
<p>container_of(nb, struct rk30_adc_battery_data, battery_nb);</p>
<p>switch (event) {</p>
<p>case LCDC_ON:</p>
<p>DBG(&quot;LCDC on \n&quot;);</p>
<p>rk_lowerpower_check(bat);//for lower power protect</p>
<p>break;</p>
<p>case BACKLIGHT_ON:</p>
<p>DBG(&quot;display \n&quot;);</p>
<p>poweron_lowerpoer_handle(bat);</p>
<p>break;</p>
<p>default:</p>
<p>return NOTIFY_OK;</p>
<p>}</p>
<p>return NOTIFY_OK;</p>
<p>}</p>
<p>static int rk30_adc_battery_probe(struct platform_device *pdev)</p>
<p>{</p>
<p>int    ret;</p>
<p>int    irq;</p>
<p>int    irq_flag;</p>
<p>struct adc_client                   *client;</p>
<p>struct rk30_adc_battery_data          *data;</p>
<p>struct rk30_adc_battery_platform_data *pdata = pdev-&gt;dev.platform_data;</p>
<p>#ifdef CONFIG_MACH_RK_FAC</p>
<p>int i;</p>
<p>for(i=0;i&lt;BATT_NUM;i++)</p>
<p>{</p>
<p>batt_table[6+i]=pdata-&gt;chargeArray[i];</p>
<p>batt_table[BATT_NUM+6+i]=pdata-&gt;chargeArray[i];</p>
<p>}</p>
<p>#endif</p>
<p>gSecondsCnt = get_seconds();</p>
<p>data = kzalloc(sizeof(*data), GFP_KERNEL);</p>
<p>if (data == NULL) {</p>
<p>ret = -ENOMEM;</p>
<p>goto err_data_alloc_failed;</p>
<p>}</p>
<p>memset(data, 0, sizeof(struct rk30_adc_battery_data));</p>
<p>gBatteryData = data;</p>
<p>platform_set_drvdata(pdev, data);</p>
<p>data-&gt;pdata = pdata;</p>
<p>data-&gt;status_lock = 0;</p>
<p>data-&gt;old_charge_level = -1;</p>
<p>data-&gt;capacitytmp = 0;</p>
<p>data-&gt;suspend_capacity = 0;</p>
<p>data-&gt;ac_charging = 0;</p>
<p>data-&gt;usb_charging = 0;</p>
<p>data-&gt;full_times = 0;</p>
<p>data-&gt;gBatCapacityDisChargeCnt =0;</p>
<p>data-&gt;gBatCapacityChargeCnt=0;</p>
<p>data-&gt;gBatCapacityusbdisChargeCnt=0 ;</p>
<p>data-&gt;gBatCapacityusbChargeCnt =0;</p>
<p>data-&gt;gBatCapacityacChargeCnt = 0;</p>
<p>data-&gt;charge_source_now = 0;</p>
<p>data-&gt;charge_soure_old = 0;</p>
<p>data-&gt;start_voltage_status = 0;</p>
<p>data-&gt;charge_full_flag =0;</p>
<p>data-&gt;pSamples = data-&gt;adc_samples;</p>
<p>data-&gt;lower_power_flag = 0;</p>
<p>data-&gt;capacitytmp = 0;</p>
<p>data-&gt;time_to_full = 0;</p>
<p>data-&gt;stop_check = 0;</p>
<p>data-&gt;voltage_to_local = 0;</p>
<p>data-&gt;bat_status = POWER_SUPPLY_STATUS_NOT_CHARGING;</p>
<p>wake_lock_init(&amp;batt_wake_lock, WAKE_LOCK_SUSPEND, &quot;batt_lock&quot;); </p>
<p>wake_lock_init(&amp;charge_display_lock, WAKE_LOCK_SUSPEND, &quot;charge_display_lock&quot;); //charge_display_lock</p>
<p>wake_lock_init(&amp;batt_wake_lock_detect_lowpower, WAKE_LOCK_SUSPEND, &quot;lowpower_lock&quot;); </p>
<p>ret = rk30_adc_battery_io_init(pdata);</p>
<p>if (ret) {</p>
<p>ret = -EINVAL;</p>
<p>goto err_io_init;</p>
<p>}</p>
<p>memset(data-&gt;adc_samples, 0, sizeof(int)*(NUM_VOLTAGE_SAMPLE + 2));</p>
<p>//register adc for battery sample</p>
<p>if(0 == pdata-&gt;adc_channel)</p>
<p>client = adc_register(0, rk30_adc_battery_callback, NULL);  //pdata-&gt;adc_channel = ani0</p>
<p>else</p>
<p>client = adc_register(pdata-&gt;adc_channel, rk30_adc_battery_callback, NULL);  </p>
<p>if(!client){</p>
<p>ret = -EINVAL;</p>
<p>goto err_adc_register_failed;</p>
<p>}</p>
<p>data-&gt;wq = create_singlethread_workqueue(&quot;adc_battd&quot;);</p>
<p>//variable init</p>
<p>data-&gt;client  = client;</p>
<p>data-&gt;adc_val = adc_sync_read(client);</p>
<p>data -&gt;bat = rk30_battery_supply;</p>
<p>ret = power_supply_register(&amp;pdev-&gt;dev,&amp;data -&gt;bat);</p>
<p>if (ret){</p>
<p>ret = -EINVAL;</p>
<p>printk(KERN_INFO &quot;fail to battery power_supply_register\n&quot;);</p>
<p>goto err_battery_failed;</p>
<p>}</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE) </p>
<p>data -&gt;usb = rk30_usb_supply;</p>
<p>ret = power_supply_register(&amp;pdev-&gt;dev, &amp;data -&gt;usb);</p>
<p>if (ret){</p>
<p>ret = -EINVAL;</p>
<p>printk(KERN_INFO &quot;fail to usb power_supply_register\n&quot;);</p>
<p>goto err_usb_failed;</p>
<p>}</p>
<p>#endif</p>
<p>data -&gt;ac = rk30_ac_supply;</p>
<p>ret = power_supply_register(&amp;pdev-&gt;dev, &amp;data -&gt;ac);</p>
<p>if (ret) {</p>
<p>ret = -EINVAL;</p>
<p>printk(KERN_INFO &quot;fail to ac power_supply_register\n&quot;);</p>
<p>goto err_ac_failed;</p>
<p>}</p>
<p>#if  defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>//init dc dectet irq &amp; delay work</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>INIT_WORK(&amp;data-&gt;dcwakeup_work, rk30_adc_battery_dcdet_delaywork);</p>
<p>irq = gpio_to_irq(pdata-&gt;dc_det_pin);         </p>
<p>irq_flag = gpio_get_value (pdata-&gt;dc_det_pin) ? IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;</p>
<p>ret = request_irq(irq, rk30_adc_battery_dc_wakeup, irq_flag, &quot;ac_charge_irq&quot;, NULL);</p>
<p>if (ret) {</p>
<p>ret = -EINVAL;</p>
<p>printk(&quot;failed to request dc det irq\n&quot;);</p>
<p>goto err_dcirq_failed;</p>
<p>}</p>
<p>enable_irq_wake(irq);  </p>
<p>}</p>
<p>#endif</p>
<p>#ifdef BATTERY_APK</p>
<p>ret = device_create_file(&amp;pdev-&gt;dev,&amp;dev_attr_batparam);</p>
<p>if(ret){</p>
<p>ret = -EINVAL;</p>
<p>printk(KERN_ERR &quot;failed to create bat param file\n&quot;);</p>
<p>goto err_battery_failed;</p>
<p>}</p>
<p>ret = create_sysfs_interfaces(&amp;pdev-&gt;dev);</p>
<p>if (ret &lt; 0)</p>
<p>{</p>
<p>ret = -EINVAL;</p>
<p>dev_err(&amp;pdev-&gt;dev,   </p>
<p>&quot;device rk30_adc_batterry sysfs register failed\n&quot;);</p>
<p>goto err_sysfs;</p>
<p>}</p>
<p>#endif </p>
<p>//Power on Battery detect</p>
<p>rk30_adc_battery_check(data);</p>
<p>// data-&gt;wq = create_singlethread_workqueue(&quot;adc_battd&quot;);</p>
<p>INIT_DELAYED_WORK(&amp;data-&gt;delay_work, rk30_adc_battery_timer_work);</p>
<p>if(1 == pdata-&gt;save_capacity ){</p>
<p>queue_delayed_work(data-&gt;wq, &amp;data-&gt;delay_work, msecs_to_jiffies(TIMER_MS_COUNTS*10));</p>
<p>data -&gt;poweron_check = 1;</p>
<p>}else{</p>
<p>queue_delayed_work(data-&gt;wq, &amp;data-&gt;delay_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>data -&gt;poweron_check = 0;</p>
<p>}</p>
<p>INIT_DELAYED_WORK(&amp;data-&gt;check_work, rk_adc_battery_check_work);</p>
<p>queue_delayed_work(data -&gt;wq, &amp;data -&gt;check_work, msecs_to_jiffies(TIMER_MS_COUNTS));</p>
<p>if( pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>if (gpio_get_value(pdata-&gt;batt_low_pin) ==0){</p>
<p>      mdelay(20);    </p>
<p>      if (gpio_get_value(pdata-&gt;batt_low_pin) ==0){</p>
<p>printk(&quot;lower power\n&quot;);</p>
<p>              kernel_power_off(); </p>
<p>      }</p>
<p>}</p>
<p>INIT_WORK(&amp;data-&gt;lowerpower_work, rk30_adc_battery_lowerpower_delaywork); </p>
<p>irq = gpio_to_irq(pdata-&gt;batt_low_pin); </p>
<p>ret = request_irq(irq, rk30_adc_battery_low_wakeup, IRQF_TRIGGER_LOW, &quot;batt_low_irq&quot;, NULL);</p>
<p>if (ret) {</p>
<p>ret = -EINVAL;</p>
<p>printk(&quot;failed to request batt_low_irq irq\n&quot;);</p>
<p>goto err_lowpowerirq_failed;</p>
<p>}</p>
<p>disable_irq(irq);</p>
<p>}</p>
<p>data-&gt;battery_nb.notifier_call = battery_notifier_call;</p>
<p>register_adc_battery_notifier(&amp;data-&gt;battery_nb);</p>
<p>printk(KERN_INFO &quot;rk30_adc_battery: driver initialized\n&quot;);</p>
<p>return 0;</p>
<p>err_sysfs: </p>
<p>err_usb_failed:</p>
<p>power_supply_unregister(&amp;data -&gt;usb);</p>
<p>err_ac_failed:</p>
<p>power_supply_unregister(&amp;data -&gt;ac);</p>
<p>err_battery_failed:</p>
<p>power_supply_unregister(&amp;data -&gt;bat);</p>
<p>err_dcirq_failed:</p>
<p>if (pdata-&gt;dc_det_pin != INVALID_GPIO){</p>
<p>free_irq(gpio_to_irq(pdata-&gt;dc_det_pin), data);</p>
<p>}</p>
<p>#if 1</p>
<p> err_lowpowerirq_failed:</p>
<p>if( pdata-&gt;batt_low_pin != INVALID_GPIO){</p>
<p>free_irq(gpio_to_irq(pdata-&gt;batt_low_pin), data);</p>
<p>}</p>
<p>#endif</p>
<p>err_adc_register_failed:</p>
<p>err_io_init:    </p>
<p>err_data_alloc_failed:</p>
<p>kfree(data);</p>
<p>printk(&quot;rk30_adc_battery: error!\n&quot;);</p>
<p>return ret;</p>
<p>}</p>
<p>static int rk30_adc_battery_remove(struct platform_device *pdev)</p>
<p>{</p>
<p>struct rk30_adc_battery_data *data = platform_get_drvdata(pdev);</p>
<p>struct rk30_adc_battery_platform_data *pdata = pdev-&gt;dev.platform_data;</p>
<p>cancel_delayed_work_sync(&amp;data-&gt;delay_work); </p>
<p>#if  defined (CONFIG_BATTERY_RK30_AC_CHARGE)</p>
<p>    if (pdata-&gt;dc_det_pin != INVALID_GPIO)</p>
<p>        cancel_delayed_work_sync(&amp;data-&gt;dcwakeup_work);</p>
<p>#endif</p>
<p>        cancel_delayed_work_sync(&amp;data-&gt;check_work);</p>
<p>    if( pdata-&gt;batt_low_pin != INVALID_GPIO)</p>
<p>        cancel_delayed_work_sync(&amp;data-&gt;lowerpower_work);</p>
<p>#if  defined (CONFIG_BATTERY_RK30_USB_CHARGE)</p>
<p>power_supply_unregister(&amp;data -&gt;usb);</p>
<p>#endif</p>
<p>power_supply_unregister(&amp;data -&gt;ac);</p>
<p>power_supply_unregister(&amp;data -&gt;bat);</p>
<p>    if (pdata-&gt;dc_det_pin != INVALID_GPIO)</p>
<p>free_irq(gpio_to_irq(pdata-&gt;dc_det_pin), data);</p>
<p>kfree(data);</p>
<p>return 0;</p>
<p>}</p>
<p>static struct platform_driver rk30_adc_battery_driver = {</p>
<p>.probe = rk30_adc_battery_probe,</p>
<p>.remove = rk30_adc_battery_remove,</p>
<p>.suspend = rk30_adc_battery_suspend,</p>
<p>.resume = rk30_adc_battery_resume,</p>
<p>.driver = {</p>
<p>.name = &quot;rk30-battery&quot;,</p>
<p>.owner = THIS_MODULE,</p>
<p>}</p>
<p>};</p>
<p>static int __init rk30_adc_battery_init(void)</p>
<p>{</p>
<p>return platform_driver_register(&amp;rk30_adc_battery_driver);</p>
<p>}</p>
<p>static void __exit rk30_adc_battery_exit(void)</p>
<p>{</p>
<p>platform_driver_unregister(&amp;rk30_adc_battery_driver);</p>
<p>}</p>
<p>//module_init(rk30_adc_battery_init);//module_init(rk30_adc_battery_init);//</p>
<p>subsys_initcall(rk30_adc_battery_init);</p>
<p>//fs_initcall(rk30_adc_battery_init);</p>
<p>module_exit(rk30_adc_battery_exit);</p>
<p>MODULE_DESCRIPTION(&quot;Battery detect driver for the rk30&quot;);</p>
<p>MODULE_AUTHOR(&quot;luowei <a href="mailto:&#x6c;&#x77;&#64;&#x72;&#x6f;&#99;&#x6b;&#45;&#x63;&#104;&#105;&#x70;&#x73;&#x2e;&#99;&#111;&#x6d;">&#x6c;&#x77;&#64;&#x72;&#x6f;&#99;&#x6b;&#45;&#x63;&#104;&#105;&#x70;&#x73;&#x2e;&#99;&#111;&#x6d;</a>&quot;);</p>
<p>MODULE_LICENSE(&quot;GPL&quot;);</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk29_keys.c/" rel="prev" title="rk29_keys">
      <i class="fa fa-chevron-left"></i> rk29_keys
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/rk2928%20%E5%A3%B0%E9%81%93%E5%8F%96%E5%8F%8D/" rel="next" title="rk2928 声道取反">
      rk2928 声道取反 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Edward"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">Edward</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">554</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Edward</span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"wxYx0BX9gaKA3XC4LuO2of0v-gzGzoHsz","app_key":"LQMcs6IDIE4YAm10vMsn9IYq","server_url":"https://wxyx0bx9.lc-cn-n1-shared.com","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
