<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"edward.org.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="关键字：Java解析xml、解析xml四种方法、DOM、SAX、JDOM、DOM4j、XPath 【引言】 目前在Java中用于解析XML的技术很多，主流的有DOM、SAX、JDOM、DOM4j，下文主要介绍这4种解析XML文档技术的使用、优缺点及性能测试。 一、【基础知识——扫盲】 sax、dom是两种对xml文档进行解析的方法(没有具体实现，只是接口)，所以只有它们是无法解析xml文档的；ja">
<meta property="og:type" content="article">
<meta property="og:title" content="Java解析xml、解析xml四种方法、DOM、SAX、JDOM、DOM4j、XPath">
<meta property="og:url" content="http://edward.org.cn/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Java%E8%A7%A3%E6%9E%90xml%E3%80%81%E8%A7%A3%E6%9E%90xml%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E3%80%81DOM%E3%80%81SAX%E3%80%81JDOM%E3%80%81DOM4j%E3%80%81XPath/index.html">
<meta property="og:site_name" content="点点滴滴">
<meta property="og:description" content="关键字：Java解析xml、解析xml四种方法、DOM、SAX、JDOM、DOM4j、XPath 【引言】 目前在Java中用于解析XML的技术很多，主流的有DOM、SAX、JDOM、DOM4j，下文主要介绍这4种解析XML文档技术的使用、优缺点及性能测试。 一、【基础知识——扫盲】 sax、dom是两种对xml文档进行解析的方法(没有具体实现，只是接口)，所以只有它们是无法解析xml文档的；ja">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-31T06:48:01.237Z">
<meta property="article:modified_time" content="2020-01-16T04:37:32.122Z">
<meta property="article:author" content="Edward">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://edward.org.cn/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Java%E8%A7%A3%E6%9E%90xml%E3%80%81%E8%A7%A3%E6%9E%90xml%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E3%80%81DOM%E3%80%81SAX%E3%80%81JDOM%E3%80%81DOM4j%E3%80%81XPath/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java解析xml、解析xml四种方法、DOM、SAX、JDOM、DOM4j、XPath | 点点滴滴</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a92ed22eafce466e7a7b17546bb0dc6f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">点点滴滴</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://edward.org.cn/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Java%E8%A7%A3%E6%9E%90xml%E3%80%81%E8%A7%A3%E6%9E%90xml%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E3%80%81DOM%E3%80%81SAX%E3%80%81JDOM%E3%80%81DOM4j%E3%80%81XPath/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="Edward">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="点点滴滴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java解析xml、解析xml四种方法、DOM、SAX、JDOM、DOM4j、XPath
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-31 14:48:01" itemprop="dateCreated datePublished" datetime="2020-12-31T14:48:01+08:00">2020-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-16 12:37:32" itemprop="dateModified" datetime="2020-01-16T12:37:32+08:00">2020-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%83%82%E7%AC%94%E5%A4%B4/" itemprop="url" rel="index"><span itemprop="name">烂笔头</span></a>
                </span>
            </span>

          
            <span id="/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Java%E8%A7%A3%E6%9E%90xml%E3%80%81%E8%A7%A3%E6%9E%90xml%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E3%80%81DOM%E3%80%81SAX%E3%80%81JDOM%E3%80%81DOM4j%E3%80%81XPath/" class="post-meta-item leancloud_visitors" data-flag-title="Java解析xml、解析xml四种方法、DOM、SAX、JDOM、DOM4j、XPath" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>关键字：Java解析xml、解析xml四种方法、DOM、SAX、JDOM、DOM4j、XPath</p>
<p>【引言】</p>
<p>目前在Java中用于解析XML的技术很多，主流的有DOM、SAX、JDOM、DOM4j，下文主要介绍这4种解析XML文档技术的使用、优缺点及性能测试。</p>
<p>一、【基础知识——扫盲】</p>
<p>sax、dom是两种对xml文档进行解析的方法(没有具体实现，只是接口)，所以只有它们是无法解析xml文档的；jaxp只是api，它进一步封装了sax、dom两种接口，并且提供了DomcumentBuilderFactory/DomcumentBuilder和SAXParserFactory/SAXParser（默认使用xerces解释器）。</p>
<p>二、【DOM、SAX、JDOM、DOM4j简单使用介绍】</p>
<p>1、【DOM(Document Object Model) 】<br>由W3C提供的接口，它将整个XML文档读入内存，构建一个DOM树来对各个节点(Node)进行操作。<br>示例代码：</p>
<p>[html] view plaincopy </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;      &lt;university name=&quot;pku&quot;&gt;         &lt;college name=&quot;c1&quot;&gt;             &lt;class name=&quot;class1&quot;&gt;                 &lt;student name=&quot;stu1&quot; sex=’male’ age=&quot;21&quot; /&gt;                 &lt;student name=&quot;stu2&quot; sex=’female’ age=&quot;20&quot; /&gt;                 &lt;student name=&quot;stu3&quot; sex=’female’ age=&quot;20&quot; /&gt;             &lt;/class&gt;             &lt;class name=&quot;class2&quot;&gt;                 &lt;student name=&quot;stu4&quot; sex=’male’ age=&quot;19&quot; /&gt;                 &lt;student name=&quot;stu5&quot; sex=’female’ age=&quot;20&quot; /&gt;                 &lt;student name=&quot;stu6&quot; sex=’female’ age=&quot;21&quot; /&gt;             &lt;/class&gt;         &lt;/college&gt;         &lt;college name=&quot;c2&quot;&gt;             &lt;class name=&quot;class3&quot;&gt;                 &lt;student name=&quot;stu7&quot; sex=’male’ age=&quot;20&quot; /&gt;             &lt;/class&gt;         &lt;/college&gt;         &lt;college name=&quot;c3&quot;&gt;         &lt;/college&gt;      &lt;/university&gt;    </p>
<p>后文代码中有使用到text.xml（该文档放在src路径下，既编译后在classes路径下），都是指该xml文档。</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.File;      import java.io.FileNotFoundException;      import java.io.FileOutputStream;      import java.io.IOException;      import java.io.InputStream;           import javax.xml.parsers.DocumentBuilder;      import javax.xml.parsers.DocumentBuilderFactory;      import javax.xml.parsers.ParserConfigurationException;      import javax.xml.transform.Transformer;      import javax.xml.transform.TransformerConfigurationException;      import javax.xml.transform.TransformerException;      import javax.xml.transform.TransformerFactory;      import javax.xml.transform.dom.DOMSource;      import javax.xml.transform.stream.StreamResult;           import org.w3c.dom.Document;      import org.w3c.dom.Element;      import org.w3c.dom.Node;      import org.w3c.dom.NodeList;      import org.w3c.dom.Text;      import org.xml.sax.SAXException;           /**      * dom读写xml      * @author whwang      */      public class TestDom {                  public static void main(String[] args) {             read();             //write();         }                  public static void read() {             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();             try {                 DocumentBuilder builder = dbf.newDocumentBuilder();                 InputStream in = TestDom.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.parse(in);                 // root &lt;university&gt;                 Element root = doc.getDocumentElement();                 if (root == null) return;                 System.err.println(root.getAttribute(&quot;name&quot;));                 // all college node                 NodeList collegeNodes = root.getChildNodes();                 if (collegeNodes == null) return;                 for(int i = 0; i &lt; collegeNodes.getLength(); i++) {                     Node college = collegeNodes.item(i);                     if (college != null &amp;&amp; college.getNodeType() == Node.ELEMENT_NODE) {                         System.err.println(&quot;\t&quot; + college.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue());                         // all class node                         NodeList classNodes = college.getChildNodes();                         if (classNodes == null) continue;                         for (int j = 0; j &lt; classNodes.getLength(); j++) {                             Node clazz = classNodes.item(j);                             if (clazz != null &amp;&amp; clazz.getNodeType() == Node.ELEMENT_NODE) {                                 System.err.println(&quot;\t\t&quot; + clazz.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue());                                 // all student node                                 NodeList studentNodes = clazz.getChildNodes();                                 if (studentNodes == null) continue;                                 for (int k = 0; k &lt; studentNodes.getLength(); k++) {                                     Node student = studentNodes.item(k);                                     if (student != null &amp;&amp; student.getNodeType() == Node.ELEMENT_NODE) {                                         System.err.print(&quot;\t\t\t&quot; + student.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue());                                         System.err.print(&quot; &quot; + student.getAttributes().getNamedItem(&quot;sex&quot;).getNodeValue());                                         System.err.println(&quot; &quot; + student.getAttributes().getNamedItem(&quot;age&quot;).getNodeValue());                                     }                                 }                             }                         }                     }                 }             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (FileNotFoundException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }                      }                  public static void write() {             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();             try {                 DocumentBuilder builder = dbf.newDocumentBuilder();                 InputStream in = TestDom.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.parse(in);                 // root &lt;university&gt;                 Element root = doc.getDocumentElement();                 if (root == null) return;                 // 修改属性                 root.setAttribute(&quot;name&quot;, &quot;tsu&quot;);                 NodeList collegeNodes = root.getChildNodes();                 if (collegeNodes != null) {                     for (int i = 0; i &lt;collegeNodes.getLength() - 1; i++) {                         // 删除节点                         Node college = collegeNodes.item(i);                         if (college.getNodeType() == Node.ELEMENT_NODE) {                             String collegeName = college.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue();                             if (&quot;c1&quot;.equals(collegeName) || &quot;c2&quot;.equals(collegeName)) {                                 root.removeChild(college);                             } else if (&quot;c3&quot;.equals(collegeName)) {                                 Element newChild = doc.createElement(&quot;class&quot;);                                 newChild.setAttribute(&quot;name&quot;, &quot;c4&quot;);                                 college.appendChild(newChild);                             }                         }                     }                 }                 // 新增节点                 Element addCollege = doc.createElement(&quot;college&quot;);                 addCollege.setAttribute(&quot;name&quot;, &quot;c5&quot;);                 root.appendChild(addCollege);                 Text text = doc.createTextNode(&quot;text&quot;);                 addCollege.appendChild(text);                                  // 将修改后的文档保存到文件                 TransformerFactory transFactory = TransformerFactory.newInstance();                 Transformer transFormer = transFactory.newTransformer();                 DOMSource domSource = new DOMSource(doc);                 File file = new File(&quot;src/dom-modify.xml&quot;);                 if (file.exists()) {                     file.delete();                 }                 file.createNewFile();                 FileOutputStream out = new FileOutputStream(file);                          StreamResult xmlResult = new StreamResult(out);                 transFormer.transform(domSource, xmlResult);                 System.out.println(file.getAbsolutePath());             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             } catch (TransformerConfigurationException e) {                 e.printStackTrace();             } catch (TransformerException e) {                 e.printStackTrace();             }         }     }    </p>
<p>该代码只要稍做修改，即可变得更加简洁，无需一直写if来判断是否有子节点。<br>2、【SAX (Simple API for XML) 】<br>SAX不用将整个文档加载到内存，基于事件驱动的API(Observer模式)，用户只需要注册自己感兴趣的事件即可。SAX提供EntityResolver, DTDHandler, ContentHandler, ErrorHandler接口，分别用于监听解析实体事件、DTD处理事件、正文处理事件和处理出错事件，与AWT类似，SAX还提供了一个对这4个接口默认的类DefaultHandler（这里的默认实现，其实就是一个空方法），一般只要继承DefaultHandler，重写自己感兴趣的事件即可。<br>示例代码：</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.IOException;      import java.io.InputStream;           import javax.xml.parsers.ParserConfigurationException;      import javax.xml.parsers.SAXParser;      import javax.xml.parsers.SAXParserFactory;           import org.xml.sax.Attributes;      import org.xml.sax.InputSource;      import org.xml.sax.Locator;      import org.xml.sax.SAXException;      import org.xml.sax.SAXParseException;      import org.xml.sax.helpers.DefaultHandler;           /**      *      * @author whwang      */      public class TestSAX {              public static void main(String[] args) {             read();             write();         }                  public static void read() {             try {                 SAXParserFactory factory = SAXParserFactory.newInstance();                 SAXParser parser = factory.newSAXParser();                 InputStream in = TestSAX.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 parser.parse(in, new MyHandler());             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }         }                  public static void write() {             System.err.println(&quot;纯SAX对于写操作无能为力&quot;);         }              }           // 重写对自己感兴趣的事件处理方法      class MyHandler extends DefaultHandler {              @Override         public InputSource resolveEntity(String publicId, String systemId)                 throws IOException, SAXException {             return super.resolveEntity(publicId, systemId);         }              @Override         public void notationDecl(String name, String publicId, String systemId)                 throws SAXException {             super.notationDecl(name, publicId, systemId);         }              @Override         public void unparsedEntityDecl(String name, String publicId,                 String systemId, String notationName) throws SAXException {             super.unparsedEntityDecl(name, publicId, systemId, notationName);         }              @Override         public void setDocumentLocator(Locator locator) {             super.setDocumentLocator(locator);         }              @Override         public void startDocument() throws SAXException {             System.err.println(&quot;开始解析文档&quot;);         }              @Override         public void endDocument() throws SAXException {             System.err.println(&quot;解析结束&quot;);         }              @Override         public void startPrefixMapping(String prefix, String uri)                 throws SAXException {             super.startPrefixMapping(prefix, uri);         }              @Override         public void endPrefixMapping(String prefix) throws SAXException {             super.endPrefixMapping(prefix);         }              @Override         public void startElement(String uri, String localName, String qName,                 Attributes attributes) throws SAXException {             System.err.print(&quot;Element: &quot; + qName + &quot;, attr: &quot;);             print(attributes);         }              @Override         public void endElement(String uri, String localName, String qName)                 throws SAXException {             super.endElement(uri, localName, qName);         }              @Override         public void characters(char[] ch, int start, int length)                 throws SAXException {             super.characters(ch, start, length);         }              @Override         public void ignorableWhitespace(char[] ch, int start, int length)                 throws SAXException {             super.ignorableWhitespace(ch, start, length);         }              @Override         public void processingInstruction(String target, String data)                 throws SAXException {             super.processingInstruction(target, data);         }              @Override         public void skippedEntity(String name) throws SAXException {             super.skippedEntity(name);         }              @Override         public void warning(SAXParseException e) throws SAXException {             super.warning(e);         }              @Override         public void error(SAXParseException e) throws SAXException {             super.error(e);         }              @Override         public void fatalError(SAXParseException e) throws SAXException {             super.fatalError(e);         }                  private void print(Attributes attrs) {             if (attrs == null) return;             System.err.print(&quot;[&quot;);             for (int i = 0; i &lt; attrs.getLength(); i++) {                 System.err.print(attrs.getQName(i) + &quot; = &quot; + attrs.getValue(i));                 if (i != attrs.getLength() - 1) {                     System.err.print(&quot;, &quot;);                 }             }             System.err.println(&quot;]&quot;);         }     }    </p>
<p>3、【JDOM】<br>JDOM与DOM非常类似，它是处理XML的纯JAVA API，API大量使用了Collections类，且JDOM仅使用具体类而不使用接口。　JDOM 它自身不包含解析器。它通常使用 SAX2 解析器来解析和验证输入 XML 文档（尽管它还可以将以前构造的 DOM 表示作为输入）。它包含一些转换器以将 JDOM 表示输出成 SAX2 事件流、DOM 模型或 XML 文本文档<br>示例代码：</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.File;      import java.io.FileOutputStream;      import java.io.IOException;      import java.io.InputStream;      import java.util.List;           import org.jdom.Attribute;      import org.jdom.Document;      import org.jdom.Element;      import org.jdom.JDOMException;      import org.jdom.input.SAXBuilder;      import org.jdom.output.XMLOutputter;           /**      * JDom读写xml      * @author whwang      */      public class TestJDom {         public static void main(String[] args) {             //read();             write();         }                  public static void read() {             try {                 boolean validate = false;                 SAXBuilder builder = new SAXBuilder(validate);                 InputStream in = TestJDom.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.build(in);                 // 获取根节点 &lt;university&gt;                 Element root = doc.getRootElement();                 readNode(root, &quot;&quot;);             } catch (JDOMException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }         }                  @SuppressWarnings(&quot;unchecked&quot;)         public static void readNode(Element root, String prefix) {             if (root == null) return;             // 获取属性             List&lt;Attribute&gt; attrs = root.getAttributes();             if (attrs != null &amp;&amp; attrs.size() &gt; 0) {                 System.err.print(prefix);                 for (Attribute attr : attrs) {                     System.err.print(attr.getValue() + &quot; &quot;);                 }                 System.err.println();             }             // 获取他的子节点             List&lt;Element&gt; childNodes = root.getChildren();             prefix += &quot;\t&quot;;             for (Element e : childNodes) {                 readNode(e, prefix);             }         }                  public static void write() {             boolean validate = false;             try {                 SAXBuilder builder = new SAXBuilder(validate);                 InputStream in = TestJDom.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.build(in);                 // 获取根节点 &lt;university&gt;                 Element root = doc.getRootElement();                 // 修改属性                 root.setAttribute(&quot;name&quot;, &quot;tsu&quot;);                 // 删除                 boolean isRemoved = root.removeChildren(&quot;college&quot;);                 System.err.println(isRemoved);                 // 新增                 Element newCollege = new Element(&quot;college&quot;);                 newCollege.setAttribute(&quot;name&quot;, &quot;new_college&quot;);                 Element newClass = new Element(&quot;class&quot;);                 newClass.setAttribute(&quot;name&quot;, &quot;ccccc&quot;);                 newCollege.addContent(newClass);                 root.addContent(newCollege);                 XMLOutputter out = new XMLOutputter();                 File file = new File(&quot;src/jdom-modify.xml&quot;);                 if (file.exists()) {                     file.delete();                 }                 file.createNewFile();                 FileOutputStream fos = new FileOutputStream(file);                 out.output(doc, fos);             } catch (JDOMException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }         }              }    </p>
<p>4、【DOM4j】<br>dom4j是目前在xml解析方面是最优秀的(Hibernate、Sun的JAXM也都使用dom4j来解析XML)，它合并了许多超出基本 XML 文档表示的功能，包括集成的 XPath 支持、XML Schema 支持以及用于大文档或流化文档的基于事件的处理<br>示例代码：</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.File;      import java.io.FileWriter;      import java.io.IOException;      import java.io.InputStream;      import java.util.List;           import org.dom4j.Attribute;      import org.dom4j.Document;      import org.dom4j.DocumentException;      import org.dom4j.DocumentHelper;      import org.dom4j.Element;      import org.dom4j.ProcessingInstruction;      import org.dom4j.VisitorSupport;      import org.dom4j.io.SAXReader;      import org.dom4j.io.XMLWriter;           /**      * Dom4j读写xml      * @author whwang      */      public class TestDom4j {         public static void main(String[] args) {             read1();             //read2();             //write();         }              public static void read1() {             try {                 SAXReader reader = new SAXReader();                 InputStream in = TestDom4j.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = reader.read(in);                 Element root = doc.getRootElement();                 readNode(root, &quot;&quot;);             } catch (DocumentException e) {                 e.printStackTrace();             }         }                  @SuppressWarnings(&quot;unchecked&quot;)         public static void readNode(Element root, String prefix) {             if (root == null) return;             // 获取属性             List&lt;Attribute&gt; attrs = root.attributes();             if (attrs != null &amp;&amp; attrs.size() &gt; 0) {                 System.err.print(prefix);                 for (Attribute attr : attrs) {                     System.err.print(attr.getValue() + &quot; &quot;);                 }                 System.err.println();             }             // 获取他的子节点             List&lt;Element&gt; childNodes = root.elements();             prefix += &quot;\t&quot;;             for (Element e : childNodes) {                 readNode(e, prefix);             }         }                  public static void read2() {             try {                 SAXReader reader = new SAXReader();                 InputStream in = TestDom4j.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = reader.read(in);                 doc.accept(new MyVistor());             } catch (DocumentException e) {                 e.printStackTrace();             }         }                  public static void write() {             try {                 // 创建一个xml文档                 Document doc = DocumentHelper.createDocument();                 Element university = doc.addElement(&quot;university&quot;);                 university.addAttribute(&quot;name&quot;, &quot;tsu&quot;);                 // 注释                 university.addComment(&quot;这个是根节点&quot;);                 Element college = university.addElement(&quot;college&quot;);                 college.addAttribute(&quot;name&quot;, &quot;cccccc&quot;);                 college.setText(&quot;text&quot;);                                  File file = new File(&quot;src/dom4j-modify.xml&quot;);                 if (file.exists()) {                     file.delete();                 }                 file.createNewFile();                 XMLWriter out = new XMLWriter(new FileWriter(file));                 out.write(doc);                 out.flush();                 out.close();             } catch (IOException e) {                 e.printStackTrace();             }         }     }           class MyVistor extends VisitorSupport {         public void visit(Attribute node) {             System.out.println(&quot;Attibute: &quot; + node.getName() + &quot;=&quot;                     + node.getValue());         }              public void visit(Element node) {             if (node.isTextOnly()) {                 System.out.println(&quot;Element: &quot; + node.getName() + &quot;=&quot;                         + node.getText());             } else {                 System.out.println(node.getName());             }         }              @Override         public void visit(ProcessingInstruction node) {             System.out.println(&quot;PI:&quot; + node.getTarget() + &quot; &quot; + node.getText());         }     }    </p>
<p>三、【性能测试】</p>
<p>环境：AMD4400+ 2.0+GHz主频 JDK6.0<br>运行参数：-Xms400m -Xmx400m<br>xml文件大小：10.7M<br>结果：<br>DOM: &gt;581297ms<br>SAX: 8829ms<br>JDOM: 581297ms<br>DOM4j: 5309ms<br>时间包括IO的，只是进行了简单的测试，仅供参考！！！！</p>
<p>四、【对比】</p>
<p>1、【DOM】<br>DOM是基于树的结构，通常需要加载整文档和构造DOM树，然后才能开始工作。<br>优点：<br>    a、由于整棵树在内存中，因此可以对xml文档随机访问<br>    b、可以对xml文档进行修改操作<br>    c、较sax，dom使用也更简单。<br>缺点：<br>    a、整个文档必须一次性解析完<br>    a、由于整个文档都需要载入内存，对于大文档成本高<br>2、【SAX】<br>SAX类似流媒体，它基于事件驱动的，因此无需将整个文档载入内存，使用者只需要监听自己感兴趣的事件即可。<br>优点：<br>    a、无需将整个xml文档载入内存，因此消耗内存少<br>    b、可以注册多个ContentHandler<br>缺点：<br>    a、不能随机的访问xml中的节点<br>    b、不能修改文档<br>3、【JDOM】<br>JDOM是纯Java的处理XML的API，其API中大量使用Collections类，<br>优点：<br>    a、DOM方式的优点<br>    b、具有SAX的Java规则<br>缺点<br>    a、DOM方式的缺点<br>4、【DOM4J】<br>这4中xml解析方式中，最优秀的一个，集易用和性能于一身。</p>
<p>五、【小插曲XPath】</p>
<p>XPath 是一门在 XML 文档中查找信息的语言， 可用来在 XML 文档中对元素和属性进行遍历。XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 同时被构建于 XPath 表达之上。因此，对 XPath 的理解是很多高级 XML 应用的基础。<br>XPath非常类似对数据库操作的SQL语言，或者说JQuery，它可以方便开发者抓起文档中需要的东西。（dom4j也支持xpath）<br>示例代码：</p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.IOException;      import java.io.InputStream;           import javax.xml.parsers.DocumentBuilder;      import javax.xml.parsers.DocumentBuilderFactory;      import javax.xml.parsers.ParserConfigurationException;      import javax.xml.xpath.XPath;      import javax.xml.xpath.XPathConstants;      import javax.xml.xpath.XPathExpression;      import javax.xml.xpath.XPathExpressionException;      import javax.xml.xpath.XPathFactory;           import org.w3c.dom.Document;      import org.w3c.dom.NodeList;      import org.xml.sax.SAXException;           public class TestXPath {              public static void main(String[] args) {             read();         }                  public static void read() {             try {                 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();                 DocumentBuilder builder = dbf.newDocumentBuilder();                 InputStream in = TestXPath.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.parse(in);                 XPathFactory factory = XPathFactory.newInstance();                 XPath xpath = factory.newXPath();                 // 选取所有class元素的name属性                 // XPath语法介绍： <a target="_blank" rel="noopener" href="http://w3school.com.cn/xpath/">http://w3school.com.cn/xpath/</a>                 XPathExpression expr = xpath.compile(&quot;//class/@name&quot;);                 NodeList nodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);                 for (int i = 0; i &lt; nodes.getLength(); i++) {                     System.out.println(&quot;name = &quot; + nodes.item(i).getNodeValue());                         }             } catch (XPathExpressionException e) {                 e.printStackTrace();             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }         }              }    </p>
<p>六、【补充】</p>
<p>注意4种解析方法对TextNode（文本节点）的处理：</p>
<p>1、在使用DOM时，调用node.getChildNodes()获取该节点的子节点，文本节点也会被当作一个Node来返回，如：</p>
<p>[html] view plaincopy </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;      &lt;university name=&quot;pku&quot;&gt;         &lt;college name=&quot;c1&quot;&gt;             &lt;class name=&quot;class1&quot;&gt;                 &lt;student name=&quot;stu1&quot; sex=’male’ age=&quot;21&quot; /&gt;                 &lt;student name=&quot;stu2&quot; sex=’female’ age=&quot;20&quot; /&gt;                 &lt;student name=&quot;stu3&quot; sex=’female’ age=&quot;20&quot; /&gt;             &lt;/class&gt;         &lt;/college&gt;      &lt;/university&gt;    </p>
<p>[java] view plaincopy </p>
<p>package test.xml;           import java.io.FileNotFoundException;      import java.io.IOException;      import java.io.InputStream;      import java.util.Arrays;           import javax.xml.parsers.DocumentBuilder;      import javax.xml.parsers.DocumentBuilderFactory;      import javax.xml.parsers.ParserConfigurationException;           import org.w3c.dom.Document;      import org.w3c.dom.Element;      import org.w3c.dom.Node;      import org.w3c.dom.NodeList;      import org.xml.sax.SAXException;           /**      * dom读写xml      * @author whwang      */      public class TestDom2 {                  public static void main(String[] args) {             read();         }                  public static void read() {             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();             try {                 DocumentBuilder builder = dbf.newDocumentBuilder();                 InputStream in = TestDom2.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;);                 Document doc = builder.parse(in);                 // root &lt;university&gt;                 Element root = doc.getDocumentElement();                 if (root == null) return;      //          System.err.println(root.getAttribute(&quot;name&quot;));                 // all college node                 NodeList collegeNodes = root.getChildNodes();                 if (collegeNodes == null) return;                 System.err.println(&quot;university子节点数：&quot; + collegeNodes.getLength());                 System.err.println(&quot;子节点如下：&quot;);                 for(int i = 0; i &lt; collegeNodes.getLength(); i++) {                     Node college = collegeNodes.item(i);                     if (college == null) continue;                     if (college.getNodeType() == Node.ELEMENT_NODE) {                         System.err.println(&quot;\t元素节点：&quot; + college.getNodeName());                     } else if (college.getNodeType() == Node.TEXT_NODE) {                         System.err.println(&quot;\t文本节点：&quot; + Arrays.toString(college.getTextContent().getBytes()));                     }                 }             } catch (ParserConfigurationException e) {                 e.printStackTrace();             } catch (FileNotFoundException e) {                 e.printStackTrace();             } catch (SAXException e) {                 e.printStackTrace();             } catch (IOException e) {                 e.printStackTrace();             }                      }     }    </p>
<p>输出的结果是： </p>
<p>[java] view plaincopy </p>
<p>university子节点数：3     子节点如下：         文本节点：[10, 9]         元素节点：college         文本节点：[10]    </p>
<p>其中\n的ASCII码为10，\t的ASCII码为9。结果让人大吃一惊，university的子节点数不是1，也不是2，而是3，这3个子节点都是谁呢？为了看得更清楚点，把xml文档改为：</p>
<p>[html] view plaincopy </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;      &lt;university name=&quot;pku&quot;&gt;11         &lt;college name=&quot;c1&quot;&gt;             &lt;class name=&quot;class1&quot;&gt;                 &lt;student name=&quot;stu1&quot; sex=’male’ age=&quot;21&quot; /&gt;                 &lt;student name=&quot;stu2&quot; sex=’female’ age=&quot;20&quot; /&gt;                 &lt;student name=&quot;stu3&quot; sex=’female’ age=&quot;20&quot; /&gt;             &lt;/class&gt;         &lt;/college&gt;22      &lt;/university&gt;    </p>
<p>还是上面的程序，输出结果为： </p>
<p>[java] view plaincopy </p>
<p>university子节点数：3     子节点如下：         文本节点：[49, 49, 10, 9]         元素节点：college         文本节点：[50, 50, 10]    </p>
<p>其中数字1的ASCII码为49，数字2的ASCII码为50。 </p>
<p>2、使用SAX来解析同DOM，当你重写它的public void characters(char[] ch, int start, int length)方法时，你就能看到。</p>
<p>3、JDOM，调用node.getChildren()只返回子节点，不包括TextNode节点（不管该节点是否有Text信息）。如果要获取该节点的Text信息，可以调用node.getText()方法，该方法返回节点的Text信息，也包括\n\t等特殊字符。</p>
<p>4、DOM4j同JDOM</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/Java%20%E6%B3%A8%E6%84%8F%E7%82%B9%E5%8F%8Asocket/" rel="prev" title="Java 注意点及socket">
      <i class="fa fa-chevron-left"></i> Java 注意点及socket
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/31/%E7%83%82%E7%AC%94%E5%A4%B4/JVM%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/" rel="next" title="JVM 垃圾回收机制和调优手段">
      JVM 垃圾回收机制和调优手段 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Edward"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">Edward</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">554</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Edward</span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"wxYx0BX9gaKA3XC4LuO2of0v-gzGzoHsz","app_key":"LQMcs6IDIE4YAm10vMsn9IYq","server_url":"https://wxyx0bx9.lc-cn-n1-shared.com","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
